<!doctype html> <html lang="en"><head><meta http-equiv="Content-Type" content="text/html" charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>FAQ | Marko Widgets</title><link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml"><meta name="description"><link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1,width=device-width"><link rel="stylesheet" type="text/css" href="/static/docs-page-c76dd320.css">
<link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css"></head><body><header id="header" data-widget="/src/components/app-header"><div class="container"><div id="logo"><a href="/"><img src="/images/logo-header.png" alt="Marko"></a></div><nav role="navigation" id="nav" class="mobile-hidden"><ul class="main-navigation"><li><a href="/docs/" class="active">Docs</a></li><li><a href="/community/">Community</a></li><li><a href="/blog/">Blog</a></li><li><a href="/github/">Github</a></li><li class="nav-search"><i class="fa fa-search" data-w-onclick="handleToggleSearchClick|header"></i><form action="https://google.com/search" method="get" class="search-form"><input type="hidden" name="q" value="site:markojs.com"><input type="text" name="q" results="0" placeholder class="search-input"></form></li></ul></nav><div style="clear: both"></div></div></header><div class="container"><aside class="docs-nav"><section><h1>Marko</h1><ul><li><a href="/docs/">Overview</a></li><li><a href="/docs/marko/get-started/">Get Started</a></li><li><a href="/docs/marko/javascript-api/">JavaScript API</a></li><li><a href="/docs/marko/language-guide/">Language Guide</a></li><li><a href="/docs/marko/custom-taglibs/">Custom Taglibs</a></li><li><a href="/docs/marko/compiler/">Compiler</a></li><li><a href="/docs/marko/faq/">FAQ</a></li><li><a href="/docs/marko/additional-resources/">Additional Resources</a></li></ul><div class="footer"><a class="try-online" href="http://markojs.com/try-online/" target="_blank">Try Online! <img width="16" height="16" src="/static/new-window-81a33b35.svg"></a></div></section><section><h1>Marko Widgets</h1><ul><li><a href="/docs/marko-widgets/">Overview</a></li><li><a href="/docs/marko-widgets/get-started/">Get Started</a></li><li><a href="/docs/marko-widgets/component-lifecycle/">Component Lifecycle</a></li><li><a href="/docs/marko-widgets/javascript-api/">JavaScript API</a></li><li><a href="/docs/marko-widgets/faq/" class="active">FAQ</a></li><li><a href="/docs/marko-widgets/additional-resources/">Additional Resources</a></li></ul><div class="footer"><a class="try-online" href="http://markojs.com/marko-widgets/try-online/" target="_blank">Try Online! <img width="16" height="16" src="/static/new-window-81a33b35.svg"></a></div></section></aside><main><h1 class="page-title">FAQ <span class="subtitle">// Marko Widgets</span></h1><p class="toc"><strong>Table of Contents</strong><ul class="toc-level0"><li><a href="#what-are-the-difficulties-involved-in-creating-„reusable“-widgets-when-building-an-app">What are the difficulties involved in creating „reusable“ widgets when building an app?</a></li><li><a href="#is-there-a-difference-between-reuse-and-preserve-in-the-context-of-marko-widgets">Is there a difference between reuse and preserve in the context of Marko Widgets?</a></li><li><a href="#how-far-should-a-ui-be-&quotcomponentized&quot">How far should a UI be &quot;componentized&quot;?</a></li><li><a href="#when-should-the-body-of-a-custom-component-be-used">When should the body of a custom component be used?</a></li><li><a href="#which-component-functions-are-invoked-at-what-time---what&#39s-the-order-of-invocation">Which component functions are invoked at what time - what&#39;s the order of invocation?</a></li><li><a href="#marko-widgets-supports-the-batching-of-dom-updates-but-what-does-this-mean-to-the-developer">Marko Widgets supports the batching of DOM updates, but what does this mean to the developer?</a></li><li><a href="#how-do-widgets-communicate">How do widgets communicate?</a></li><li><a href="#why-is-state-so-important-for-marko-widgets">Why is state so important for Marko Widgets?</a></li></ul></p>
<h2 id="what-are-the-difficulties-involved-in-creating-„reusable“-widgets-when-building-an-app"><a name="what-are-the-difficulties-involved-in-creating-„reusable“-widgets-when-building-an-app" class="anchor" href="#what-are-the-difficulties-involved-in-creating-„reusable“-widgets-when-building-an-app"><span class="header-link"></span></a>What are the difficulties involved in creating „reusable“ widgets when building an app?</h2><p>As a developer one needs to make the choice between building a &quot;reusable&quot; UI component versus a widget that is tightly coupled with an app - there most certainly is a tradeoff between reusability and simplicity.</p>
<p>A reusable UI widget would need to emit generic events while a tightly coupled widget would directly talk to the app instance to control the app. Therefore, a reusable widget introduces complexity because it then becomes the responsibility of the parent widget to handle the events. A tightly coupled widget, in comparison, avoids the middleman and goes straight to the app.</p>
<p>As the decision is centered around individual situations, an application developer has to decide if a certain component would benefit to be reusable.</p>
<h2 id="is-there-a-difference-between-reuse-and-preserve-in-the-context-of-marko-widgets"><a name="is-there-a-difference-between-reuse-and-preserve-in-the-context-of-marko-widgets" class="anchor" href="#is-there-a-difference-between-reuse-and-preserve-in-the-context-of-marko-widgets"><span class="header-link"></span></a>Is there a difference between reuse and preserve in the context of Marko Widgets?</h2><p>DOM nodes can be preserved during a rerender and widget instances can be reused during a rerender (to have the same widget instance even after a rerender). A preserved DOM node is left completely in its previous state (other than being reinserted into the DOM with a new parent).</p>
<p>A preserved DOM nodes is detached from the DOM and reinserted into the updated DOM in its proper place.</p>
<p>Reusing the same widget instance ensures that any references to the old widget instance will still be correct.</p>
<h2 id="how-far-should-a-ui-be-&quotcomponentized&quot"><a name="how-far-should-a-ui-be-&quotcomponentized&quot" class="anchor" href="#how-far-should-a-ui-be-&quotcomponentized&quot"><span class="header-link"></span></a>How far should a UI be &quot;componentized&quot;?</h2><p>There is no right answer for how far a page should be decomposed into individual UI components. The goal should be for each UI component to be Focused, Independent, Reusable, Small &amp; Testable (<a href="http://addyosmani.com/first/">FIRST</a>). If you feel like a UI component does not meet these requirements then break it up into smaller UI components.</p>
<h2 id="when-should-the-body-of-a-custom-component-be-used"><a name="when-should-the-body-of-a-custom-component-be-used" class="anchor" href="#when-should-the-body-of-a-custom-component-be-used"><span class="header-link"></span></a>When should the body of a custom component be used?</h2><p>There are multiple ways to express the same thing using HTML. For example, an HTML button can be defined in two different ways:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"My Button"</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span>&gt;</span>
    My Button
<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
</code></pre>
<p>In the above example, the exact same button is produced, but when using the <code>&lt;input&gt;</code> tag the label of the button is provided in the <code>value</code> <em>attribute</em> and when using the <code>&lt;button&gt;</code> tag, the label of the button is provided in the nested body content. This is important because an HTML attribute does <em>not</em> allow HTML content, while HTML content can be provided in the body of an HTML element. When designing a UI component, if it may be necessary to provide input to a component that includes markup then it should be possible to provide that markup as part of the body content.</p>
<h2 id="which-component-functions-are-invoked-at-what-time---what&#39s-the-order-of-invocation"><a name="which-component-functions-are-invoked-at-what-time---what&#39s-the-order-of-invocation" class="anchor" href="#which-component-functions-are-invoked-at-what-time---what&#39s-the-order-of-invocation"><span class="header-link"></span></a>Which component functions are invoked at what time - what&#39;s the order of invocation?</h2><p>Please see <a href="/docs/marko-widgets/component-lifecycle">Component Lifecycle</a>.</p>
<h2 id="marko-widgets-supports-the-batching-of-dom-updates-but-what-does-this-mean-to-the-developer"><a name="marko-widgets-supports-the-batching-of-dom-updates-but-what-does-this-mean-to-the-developer" class="anchor" href="#marko-widgets-supports-the-batching-of-dom-updates-but-what-does-this-mean-to-the-developer"><span class="header-link"></span></a>Marko Widgets supports the batching of DOM updates, but what does this mean to the developer?</h2><p>DOM updates to widgets are batched to prevent DOM updates from happening after every state change. If a widget&#39;s DOM needs to be update due to either <code>setState()</code> or <code>setProps()</code> the widget will be queued for update with the next batch (a widget will only be queued up once).</p>
<p>For example, given the following code that repeatedly sets the same state property to a new value:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">this</span>.setState(<span class="hljs-string">'name'</span>, <span class="hljs-string">'Frank'</span>);
<span class="hljs-keyword">this</span>.setState(<span class="hljs-string">'name'</span>, <span class="hljs-string">'Jane'</span>);
<span class="hljs-keyword">this</span>.setState(<span class="hljs-string">'name'</span>, <span class="hljs-string">'John'</span>);
</code></pre>
<p>The DOM will only be updated once for the widget and it will be based on the final value of the <code>name</code> state property.</p>
<p>Marko Widgets starts a batch when handling a bubbling a DOM event that came off of the event loop. That is, the DOM will be updated once after all code has had a chance to respond to the DOM event. If a widget is queued for update and no batch has been started then a new batch will automatically be started and the update will be scheduled using <code>process.nextTick()</code>.</p>
<h2 id="how-do-widgets-communicate"><a name="how-do-widgets-communicate" class="anchor" href="#how-do-widgets-communicate"><span class="header-link"></span></a>How do widgets communicate?</h2><p>Every widget is an <a href="https://nodejs.org/api/events.html#events_class_events_eventemitter">EventEmitter</a> instance and widgets typically communicate by emitting custom events that can then be handled by the direct parent of the widget. The parent widget can choose to handle the event or emit another custom event that bubbles up to its parent. A widget should only communicate directly with nested widgets that it &quot;owns&quot; (i.e., nested widgets that were introduced in the containing widget&#39;s template). A widget can get a direct reference to a nested widget using the <code>this.getWidget(nestedWidgetId)</code> method (where <code>nestedWidgetId</code> is the ID assigned using the <code>w-id</code> attribute).</p>
<p>In some situations, it may be helpful to communicate an event on a global pub/sub channel. Pub/sub can be helpful in situations where it would overkill for an event to have to bubble up a complex widget hierarchy in order for it to be handled. The <a href="https://github.com/raptorjs/raptor-pubsub">raptor-pubsub</a> module provides a very simple pub/sub implementation based on the <a href="https://nodejs.org/api/events.html#events_class_events_eventemitter">EventEmitter</a> API.</p>
<h2 id="why-is-state-so-important-for-marko-widgets"><a name="why-is-state-so-important-for-marko-widgets" class="anchor" href="#why-is-state-so-important-for-marko-widgets"><span class="header-link"></span></a>Why is state so important for Marko Widgets?</h2><p>The concept of stateful widgets was introduced into Marko Widgets after evaluating some the great ideas introduced with <a href="https://facebook.github.io/react/">React</a>. By making widgets stateful and tracking changes to state, the Marko Widgets runtime can minimize updates to the DOM. Both Marko Widgets and React want to allow developers to create more easily maintainable applications by promoting rerendering over writing code that manually manipulates the DOM. Marko Widgets still allows developers to manually update the DOM if performance is a concern, but that should not be the norm.</p>
<p>A stateful widget&#39;s view will only be updated if any of its state properties have been changed. In addition, when rerendering a tree of widgets, only the specific widgets that need to be updated will be updated and the other widgets will continue to be used. While rerendering a widget with nested widgets, if Marko Widgets encounters a previously rendered widget in the DOM with the same ID then the previous widget will be reused to avoid rerendering and entire subtree of widgets. Marko Widgets also has the concept of container components that accept external nested content. If the state of the container component changes, only the outer &quot;shell&quot; will be rerendered and not the nested content.</p>
<p>For performance reasons, only a shallow compare is done when checking if the value of a state property has changed. This means that complex objects that exist in the state should be treated as immutable or, alternatively, Marko Widgets needs to be told when a state property has changed using <code>setStateDirty(name)</code>. Both supported solutions are compared below:</p>
<p><strong><em>Immutable objects and copy-on-write:</em></strong></p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addColor</span>(<span class="hljs-params">newColor</span>) </span>{
    <span class="hljs-comment">// Create a new Array with the new color added:</span>
    <span class="hljs-keyword">var</span> newColors = <span class="hljs-keyword">this</span>.state.colors.concat([newColor]);

    <span class="hljs-comment">// Set the colors state with the new Array:</span>
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-string">'colors'</span>, <span class="hljs-keyword">this</span>.state.colors.concat[newColor]);
}
</code></pre>
<p><strong><em>Using setStateDirty:</em></strong></p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addColor</span>(<span class="hljs-params">newColor</span>) </span>{
    <span class="hljs-comment">// Modify the existing colors array</span>
    <span class="hljs-keyword">this</span>.state.colors.push(newColor);

    <span class="hljs-comment">// Let Marko Widgets know that the colors Array was modified:</span>
    <span class="hljs-keyword">this</span>.setStateDirty(<span class="hljs-string">'colors'</span>);
}
</code></pre>
<p>Unlike React, Marko Widgets does not try to maintain a virtual DOM tree. This allows the Marko Widgets runtime to be much smaller. Marko Widgets makes the assumption that rerendering directly to the DOM is usually fast enough. In the cases where performance is a concern, developers have the option to provide custom state update handlers to manually update the DOM. In addition, Marko Widgets allows developers to mark entire subtrees of the DOM as &quot;preserved&quot; so that portions of the DOM are never rerendered and will continue be used across rerendering.</p>
</main></div><footer id="footer"><section id="footer-message" class="container">© 2015 eBay, Inc</section></footer><script type="text/javascript" src="/static/docs-page-e9fb7e38.js"></script>
<script type="text/javascript" src="/static/marko-widgets-2c3d3492.js"></script>
<script type="text/javascript" src="/static/marko-7aac30ba.js"></script>
<script type="text/javascript">$rmod.ready();</script><span id="markoWidgets" data-ids="header" style="display:none;"></span><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66854919-1', 'markojs.com');
  ga('send', 'pageview');

</script><script>
          ((window.gitter = {}).chat = {}).options = {
            room: 'marko-js/marko'
          };
        </script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script></body></html>