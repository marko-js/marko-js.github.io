{"version":3,"file":"215.cc3fa032.js","mappings":"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","sources":["webpack:///../../node_modules/@marko/translator-tags/dist/index.js"],"sourcesContent":["\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  analyze: () => analyze2,\n  getRuntimeEntryFiles: () => getRuntimeEntryFiles,\n  internalEntryBuilder: () => entry_builder_default,\n  taglibs: () => taglibs,\n  transform: () => transform,\n  translate: () => translate2\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/util/is-core-tag.ts\nvar import_babel_utils = require(\"@marko/babel-utils\");\nvar taglibId = \"marko-core\";\nvar interopTaglibId = \"@marko/translator-interop-class-tags\";\nfunction isCoreTag(tag) {\n  const id = tag.isMarkoTag() && (0, import_babel_utils.getTagDef)(tag)?.taglibId;\n  return id === taglibId || id === interopTaglibId;\n}\nfunction isCoreTagName(tag, name) {\n  return isCoreTag(tag) && tag.node.name.value === name;\n}\n\n// src/core/__flush_here_and_after__.ts\nvar import_babel_utils2 = require(\"@marko/babel-utils\");\nvar flush_here_and_after_default = {\n  transform: [\n    (tag) => {\n      if ((0, import_babel_utils2.getTagDef)(tag)?.renderer) {\n        return;\n      }\n      tag.replaceWithMultiple(tag.node.body.body);\n    }\n  ]\n};\n\n// src/core/attrs.ts\nvar import_compiler = require(\"@marko/compiler\");\nvar attrs_default = {\n  migrate: [\n    (tag) => {\n      const tagVar = tag.node.var;\n      if (tagVar && !(tagVar.type === \"Identifier\" && tagVar.name === \"input\")) {\n        const constTag = import_compiler.types.markoTag(\n          import_compiler.types.stringLiteral(\"const\"),\n          [import_compiler.types.markoAttribute(\"value\", import_compiler.types.identifier(\"input\"))],\n          import_compiler.types.markoTagBody([])\n        );\n        constTag.var = tagVar;\n        tag.replaceWith(constTag);\n      } else {\n        tag.remove();\n      }\n    }\n  ],\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"attrs/{ ... }\",\n      description: \"Use to receive the attributes passed into this template.\",\n      snippet: \"attrs/{ $1 }$2\"\n    }\n  ]\n};\n\n// src/core/client.ts\nvar import_babel_utils3 = require(\"@marko/babel-utils\");\nvar import_compiler2 = require(\"@marko/compiler\");\nvar client_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^client\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils3.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler2.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler2.types.markoScriptlet(body, true, \"client\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"client <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the client.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#client-javascript\"\n    }\n  ]\n};\n\n// src/core/condition/else.ts\nvar import_babel_utils12 = require(\"@marko/babel-utils\");\n\n// src/core/condition/if.ts\nvar import_babel_utils11 = require(\"@marko/babel-utils\");\nvar import_compiler18 = require(\"@marko/compiler\");\n\n// src/util/references.ts\nvar import_compiler16 = require(\"@marko/compiler\");\n\n// src/visitors/program/index.ts\nvar import_babel_utils10 = require(\"@marko/babel-utils\");\nvar import_compiler15 = require(\"@marko/compiler\");\nvar import_path = __toESM(require(\"path\"));\n\n// src/util/binding-has-downstream-expressions.ts\nfunction bindingHasDownstreamExpressions(binding) {\n  if (binding.downstreamExpressions.size) return true;\n  for (const alias of binding.aliases) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  return false;\n}\n\n// src/util/entry-builder.ts\nvar import_babel_utils4 = require(\"@marko/babel-utils\");\nvar import_compiler3 = require(\"@marko/compiler\");\nvar kState = Symbol();\nvar entry_builder_default = {\n  build(entryFile) {\n    const state = entryFile[kState];\n    if (!state) {\n      throw entryFile.path.buildCodeFrameError(\n        \"Unable to build hydrate code, no files were visited before finalizing the build\"\n      );\n    }\n    const body = state.imports.map(\n      (it) => import_compiler3.types.importDeclaration([], import_compiler3.types.stringLiteral(it))\n    );\n    if (state.init) {\n      body.unshift(\n        import_compiler3.types.importDeclaration(\n          [import_compiler3.types.importSpecifier(import_compiler3.types.identifier(\"init\"), import_compiler3.types.identifier(\"init\"))],\n          import_compiler3.types.stringLiteral(\n            `@marko/runtime-tags/${entryFile.markoOpts.optimize ? \"\" : \"debug/\"}dom`\n          )\n        )\n      );\n      body.push(\n        import_compiler3.types.expressionStatement(import_compiler3.types.callExpression(import_compiler3.types.identifier(\"init\"), []))\n      );\n    }\n    return body;\n  },\n  visit(file, entryFile, visitChild) {\n    const state = entryFile[kState] ||= {\n      imports: [],\n      init: false\n    };\n    const { analyzedTags } = file.metadata.marko;\n    state.imports.push(\n      (0, import_babel_utils4.resolveRelativePath)(entryFile, file.opts.filename)\n    );\n    state.init ||= file.path.node.extra.hasInteractiveChild || file.path.node.extra.isInteractive || false;\n    for (const tag of analyzedTags || []) {\n      visitChild(tag);\n    }\n  }\n};\n\n// src/util/marko-config.ts\nfunction isOutputHTML() {\n  return getMarkoOpts().output === \"html\";\n}\nfunction isOutputDOM() {\n  return !isOutputHTML();\n}\nfunction getMarkoOpts() {\n  return currentProgramPath.hub.file.markoOpts;\n}\nfunction isOptimize() {\n  return getMarkoOpts().optimize;\n}\n\n// src/util/sections.ts\nvar import_babel_utils6 = require(\"@marko/babel-utils\");\nvar import_compiler5 = require(\"@marko/compiler\");\n\n// src/util/state.ts\nvar createProgramState = (init) => {\n  const map = /* @__PURE__ */ new WeakMap();\n  return [\n    () => {\n      let state = map.get(currentProgramPath);\n      if (!state) {\n        map.set(currentProgramPath, state = init());\n      }\n      return state;\n    },\n    (value) => {\n      map.set(currentProgramPath, value);\n    }\n  ];\n};\nfunction createSectionState(key, init) {\n  return [\n    (section) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      const sectionData = arrayOfSectionData[section.id] ??= init && init(section);\n      return sectionData;\n    },\n    (section, value) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      arrayOfSectionData[section.id] = value;\n    }\n  ];\n}\n\n// src/util/tag-name-type.ts\nvar import_babel_utils5 = require(\"@marko/babel-utils\");\nvar import_compiler4 = require(\"@marko/compiler\");\n\n// src/util/with-previous-location.ts\nfunction withPreviousLocation(newNode, originalNode) {\n  newNode.start = originalNode.start;\n  newNode.loc = originalNode.loc;\n  newNode.end = originalNode.end;\n  return newNode;\n}\n\n// src/util/tag-name-type.ts\nvar MARKO_FILE_REG = /^<.*>$|\\.marko$/;\nfunction analyzeTagNameType(tag) {\n  const extra = tag.node.extra ??= {};\n  if (extra.tagNameType === void 0) {\n    const name = tag.get(\"name\");\n    if (name.isStringLiteral()) {\n      extra.tagNameType = name.node.value[0] === \"@\" ? 3 /* AttributeTag */ : (0, import_babel_utils5.isNativeTag)(tag) ? 0 /* NativeTag */ : 1 /* CustomTag */;\n      if (extra.tagNameType === 1 /* CustomTag */) {\n        const bindingName = name.node.value;\n        const bindingIdentifier = tag.scope.getBinding(bindingName)?.identifier;\n        if (bindingIdentifier) {\n          const tagIdentifier = withPreviousLocation(\n            import_compiler4.types.identifier(bindingName),\n            name.node\n          );\n          tagIdentifier.extra = {\n            referencedBindings: bindingIdentifier.extra?.binding\n          };\n          analyzeExpressionTagName(name.replaceWith(tagIdentifier)[0], extra);\n        } else {\n          const childFile = (0, import_babel_utils5.loadFileForTag)(tag);\n          const childProgram = childFile?.ast.program;\n          if (childProgram?.extra.featureType === \"class\") {\n            extra.tagNameType = 2 /* DynamicTag */;\n            extra.featureType = \"class\";\n          }\n        }\n      }\n      extra.tagNameNullable = extra.tagNameNullable = false;\n    } else {\n      analyzeExpressionTagName(name, extra);\n    }\n    if (extra.tagNameType === void 0) {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n  }\n  return extra.tagNameType;\n}\nfunction analyzeExpressionTagName(name, extra) {\n  const pending = [name];\n  let path3;\n  let type;\n  let nullable = false;\n  let tagNameImported;\n  while ((path3 = pending.pop()) && type !== 2 /* DynamicTag */) {\n    if (path3.isConditionalExpression()) {\n      pending.push(path3.get(\"consequent\"));\n      if (path3.node.alternate) {\n        pending.push(path3.get(\"alternate\"));\n      }\n    } else if (path3.isLogicalExpression()) {\n      if (path3.node.operator === \"||\") {\n        pending.push(path3.get(\"left\"));\n      } else {\n        nullable = true;\n      }\n      pending.push(path3.get(\"right\"));\n    } else if (path3.isAssignmentExpression()) {\n      pending.push(path3.get(\"right\"));\n    } else if (path3.isBinaryExpression()) {\n      type = path3.node.operator !== \"+\" || type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path3.isStringLiteral() || path3.isTemplateLiteral()) {\n      type = type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path3.isNullLiteral()) {\n      nullable = true;\n    } else if (path3.isIdentifier()) {\n      if (path3.node.name === \"undefined\") {\n        nullable = true;\n        continue;\n      }\n      const binding = path3.scope.getBinding(path3.node.name);\n      if (!binding) {\n        type = 2 /* DynamicTag */;\n        continue;\n      }\n      if (binding.kind === \"module\") {\n        const decl = binding.path.parent;\n        if (MARKO_FILE_REG.test(decl.source.value) && decl.specifiers.some((it) => import_compiler4.types.isImportDefaultSpecifier(it))) {\n          const resolvedImport = (0, import_babel_utils5.resolveTagImport)(name, decl.source.value) || decl.source.value;\n          if (type === 0 /* NativeTag */ || tagNameImported && tagNameImported !== resolvedImport) {\n            type = 2 /* DynamicTag */;\n            tagNameImported = void 0;\n          } else {\n            type = 1 /* CustomTag */;\n            tagNameImported = resolvedImport;\n          }\n        } else {\n          type = 2 /* DynamicTag */;\n        }\n        continue;\n      }\n      const bindingTag = binding.path;\n      if (bindingTag.isMarkoTag() && binding.kind === \"local\") {\n        const bindingTagName = bindingTag.get(\"name\").node.value;\n        if (bindingTagName === \"const\") {\n          pending.push(\n            bindingTag.get(\"attributes\")[0].get(\"value\")\n          );\n          continue;\n        }\n        if (bindingTagName === \"let\") {\n          type = 2 /* DynamicTag */;\n          continue;\n        }\n        continue;\n      }\n      type = 2 /* DynamicTag */;\n    } else {\n      type = 2 /* DynamicTag */;\n    }\n  }\n  extra.tagNameType = type;\n  extra.tagNameNullable = nullable;\n  extra.tagNameDynamic = true;\n  if (type === 1 /* CustomTag */ && tagNameImported) {\n    extra.tagNameImported = tagNameImported;\n  }\n}\n\n// src/util/sections.ts\nfunction startSection(path3) {\n  const extra = path3.node.extra ??= {};\n  let section = extra.section;\n  if (!section && (path3.type === \"Program\" || path3.get(\"body\").length)) {\n    const parentSection = path3.parentPath ? getOrCreateSection(path3.parentPath) : void 0;\n    const sectionNamePath = path3.parentPath?.get(\n      \"name\"\n    );\n    const sectionName = path3.isProgram() ? \"\" : currentProgramPath.scope.generateUid(\n      sectionNamePath.toString() + \"Body\"\n    );\n    const programExtra = path3.hub.file.path.node.extra ??= {};\n    const sections = programExtra.sections ??= [];\n    section = extra.section = {\n      id: sections.length,\n      name: sectionName,\n      depth: parentSection ? parentSection.depth + 1 : 0,\n      parent: parentSection,\n      closures: /* @__PURE__ */ new Set(),\n      bindings: /* @__PURE__ */ new Set(),\n      startNodeContentType: getStartNodeContentType(path3),\n      endNodeContentType: getEndNodeContentType(path3),\n      upstreamExpression: void 0\n    };\n    sections.push(section);\n  }\n  return section;\n}\nfunction getOrCreateSection(path3) {\n  let cur = path3;\n  while (true) {\n    if (cur.type === \"Program\" || cur.type === \"MarkoTagBody\" && analyzeTagNameType(cur.parentPath) !== 0 /* NativeTag */ && cur.parent.name.value !== \"html-comment\") {\n      return startSection(cur);\n    }\n    cur = cur.parentPath;\n  }\n}\nfunction hasSection(path3) {\n  return path3.node.extra?.section !== void 0;\n}\nfunction getSection(path3) {\n  let section;\n  let currentPath = path3;\n  while ((section = currentPath.node.extra?.section) === void 0) {\n    currentPath = currentPath.parentPath;\n  }\n  _setSectionPath(\n    section,\n    currentPath\n  );\n  return section;\n}\nvar [getScopeIdIdentifier] = createSectionState(\n  \"scopeIdIdentifier\",\n  (section) => currentProgramPath.scope.generateUidIdentifier(`scope${section.id}_id`)\n);\nvar [getSectionPath, _setSectionPath] = createSectionState(\"sectionPath\");\nvar [_getScopeIdentifier] = createSectionState(\n  \"scopeIdentifier\",\n  () => import_compiler5.types.identifier(\"undefined\")\n);\nvar getScopeIdentifier = (section, ignoreDefault) => {\n  const scopeId = _getScopeIdentifier(section);\n  if (!ignoreDefault && scopeId.name === \"undefined\") {\n    scopeId.name = currentProgramPath.scope.generateUid(`scope${section.id}_`);\n  }\n  return scopeId;\n};\nfunction forEachSection(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  sections?.forEach(fn);\n}\nfunction forEachSectionReverse(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  for (let i = sections.length; i--; ) {\n    fn(sections[i]);\n  }\n}\nfunction getStartNodeContentType(path3) {\n  for (const child of path3.get(\"body\")) {\n    const contentType = getNodeContentType(child, \"startNodeContentType\");\n    if (contentType !== 2 /* Empty */) {\n      return contentType;\n    }\n  }\n  return 2 /* Empty */;\n}\nfunction getEndNodeContentType(path3) {\n  const body = path3.get(\"body\");\n  for (let i = body.length; i--; ) {\n    const contentType = getNodeContentType(body[i], \"endNodeContentType\");\n    if (contentType !== 2 /* Empty */) {\n      return contentType;\n    }\n  }\n  return 2 /* Empty */;\n}\nfunction getNodeContentType(path3, extraMember) {\n  if (import_compiler5.types.isMarkoText(path3)) {\n    return 5 /* Text */;\n  }\n  if (import_compiler5.types.isMarkoPlaceholder(path3)) {\n    return 3 /* Placeholder */;\n  }\n  if (import_compiler5.types.isMarkoScriptlet(path3) || import_compiler5.types.isMarkoComment(path3)) {\n    return 2 /* Empty */;\n  }\n  if (import_compiler5.types.isMarkoTag(path3.node)) {\n    const tag = path3;\n    if ((0, import_babel_utils6.isNativeTag)(tag)) {\n      return 4 /* Tag */;\n    }\n    if ((0, import_babel_utils6.isAttributeTag)(tag)) {\n      return 2 /* Empty */;\n    }\n    if (import_compiler5.types.isStringLiteral(path3.node.name)) {\n      switch (path3.node.name.value) {\n        case \"html-comment\":\n          return 0 /* Comment */;\n        case \"let\":\n        case \"const\":\n        case \"attrs\":\n        case \"effect\":\n        case \"lifecycle\":\n        case \"return\":\n        case \"id\":\n        case \"define\":\n          return 2 /* Empty */;\n      }\n      const tagSection = (0, import_babel_utils6.loadFileForTag)(tag)?.ast.program.extra.section;\n      if (tagSection) {\n        return tagSection[extraMember] ?? 2 /* Empty */;\n      }\n    }\n  }\n  return 1 /* Dynamic */;\n}\nvar isStatefulSection = (section) => {\n  const upstreamExpression = section.upstreamExpression;\n  return !upstreamExpression || isStatefulReferences(upstreamExpression.referencedBindings);\n};\nvar checkStatefulClosures = (section, immediateOnly) => {\n  for (const binding of section.closures) {\n    if ((!immediateOnly || section.parent === binding.section) && isStatefulReferences(binding)) {\n      return true;\n    }\n  }\n};\n\n// src/visitors/program/dom.ts\nvar import_compiler13 = require(\"@marko/compiler\");\n\n// src/util/runtime.ts\nvar import_babel_utils7 = require(\"@marko/babel-utils\");\nvar import_compiler7 = require(\"@marko/compiler\");\n\n// ../runtime-tags/src/common/helpers.ts\nfunction classValue(value) {\n  return toDelimitedString(value, \" \", stringifyClassObject);\n}\nfunction stringifyClassObject(name, value) {\n  return value ? name : \"\";\n}\nfunction styleValue(value) {\n  return toDelimitedString(value, \";\", stringifyStyleObject);\n}\nvar NON_DIMENSIONAL = /^(--|ta|or|li|z)|n-c|i(do|nk|m|t)|w$|we/;\nfunction stringifyStyleObject(name, value) {\n  return value || value === 0 ? `${name}:${typeof value === \"number\" && value && !NON_DIMENSIONAL.test(name) ? value + \"px\" : value}` : \"\";\n}\nfunction toDelimitedString(val, delimiter, stringify) {\n  switch (typeof val) {\n    case \"string\":\n      return val;\n    case \"object\":\n      if (val !== null) {\n        let result = \"\";\n        let curDelimiter = \"\";\n        if (Array.isArray(val)) {\n          for (const v of val) {\n            const part = toDelimitedString(v, delimiter, stringify);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        } else {\n          for (const name in val) {\n            const v = val[name];\n            const part = stringify(name, v);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        }\n        return result;\n      }\n  }\n  return \"\";\n}\nfunction isVoid(value) {\n  return value == null || value === false;\n}\n\n// ../runtime-tags/src/html/serializer.ts\nvar { hasOwnProperty } = {};\nvar Generator = function* () {\n}().constructor;\nvar AsyncGenerator = async function* () {\n}().constructor;\nvar KNOWN_SYMBOLS = (() => {\n  const KNOWN_SYMBOLS2 = /* @__PURE__ */ new Map();\n  for (const name of Object.getOwnPropertyNames(Symbol)) {\n    const symbol = Symbol[name];\n    if (typeof symbol === \"symbol\") {\n      KNOWN_SYMBOLS2.set(symbol, \"Symbol.\" + name);\n    }\n  }\n  return KNOWN_SYMBOLS2;\n})();\nvar KNOWN_FUNCTIONS = /* @__PURE__ */ new Map([\n  // This is by no means an exhaustive list,\n  // but it should cover most of the built-in functions.\n  [AggregateError, \"AggregateError\"],\n  [Array, \"Array\"],\n  [Array.from, \"Array.from\"],\n  [Array.isArray, \"Array.isArray\"],\n  [Array.of, \"Array.of\"],\n  [ArrayBuffer, \"ArrayBuffer\"],\n  [ArrayBuffer.isView, \"ArrayBuffer.isView\"],\n  [Atomics.add, \"Atomics.add\"],\n  [Atomics.and, \"Atomics.and\"],\n  [Atomics.compareExchange, \"Atomics.compareExchange\"],\n  [Atomics.exchange, \"Atomics.exchange\"],\n  [Atomics.isLockFree, \"Atomics.isLockFree\"],\n  [Atomics.load, \"Atomics.load\"],\n  [Atomics.notify, \"Atomics.notify\"],\n  [Atomics.or, \"Atomics.or\"],\n  [Atomics.store, \"Atomics.store\"],\n  [Atomics.sub, \"Atomics.sub\"],\n  [Atomics.wait, \"Atomics.wait\"],\n  [BigInt, \"BigInt\"],\n  [BigInt.asIntN, \"BigInt.asIntN\"],\n  [BigInt.asUintN, \"BigInt.asUintN\"],\n  [BigInt64Array, \"BigInt64Array\"],\n  [BigInt64Array.from, \"BigInt64Array.from\"],\n  [BigInt64Array.of, \"BigInt64Array.of\"],\n  [BigUint64Array, \"BigUint64Array\"],\n  [BigUint64Array.from, \"BigUint64Array.from\"],\n  [BigUint64Array.of, \"BigUint64Array.of\"],\n  [Boolean, \"Boolean\"],\n  [console.assert, \"console.assert\"],\n  [console.clear, \"console.clear\"],\n  [console.count, \"console.count\"],\n  [console.countReset, \"console.countReset\"],\n  [console.debug, \"console.debug\"],\n  [console.dir, \"console.dir\"],\n  [console.dirxml, \"console.dirxml\"],\n  [console.error, \"console.error\"],\n  [console.group, \"console.group\"],\n  [console.groupCollapsed, \"console.groupCollapsed\"],\n  [console.groupEnd, \"console.groupEnd\"],\n  [console.info, \"console.info\"],\n  [console.log, \"console.log\"],\n  [console.table, \"console.table\"],\n  [console.time, \"console.time\"],\n  [console.timeEnd, \"console.timeEnd\"],\n  [console.timeLog, \"console.timeLog\"],\n  [console.timeStamp, \"console.timeStamp\"],\n  [console.trace, \"console.trace\"],\n  [console.warn, \"console.warn\"],\n  [DataView, \"DataView\"],\n  [Date, \"Date\"],\n  [Date.now, \"Date.now\"],\n  [Date.parse, \"Date.parse\"],\n  [Date.UTC, \"Date.UTC\"],\n  [decodeURI, \"decodeURI\"],\n  [decodeURIComponent, \"decodeURIComponent\"],\n  [encodeURI, \"encodeURI\"],\n  [encodeURIComponent, \"encodeURIComponent\"],\n  [Error, \"Error\"],\n  [EvalError, \"EvalError\"],\n  [Float32Array, \"Float32Array\"],\n  [Float32Array.from, \"Float32Array.from\"],\n  [Float32Array.of, \"Float32Array.of\"],\n  [Float64Array, \"Float64Array\"],\n  [Float64Array.from, \"Float64Array.from\"],\n  [Float64Array.of, \"Float64Array.of\"],\n  [Function, \"Function\"],\n  [globalThis.atob, \"atob\"],\n  [globalThis.btoa, \"btoa\"],\n  [globalThis.clearImmediate, \"clearImmediate\"],\n  [globalThis.clearInterval, \"clearInterval\"],\n  [globalThis.clearTimeout, \"clearTimeout\"],\n  [globalThis.crypto?.getRandomValues, \"crypto.getRandomValues\"],\n  [globalThis.crypto?.randomUUID, \"crypto.randomUUID\"],\n  [globalThis.fetch, \"fetch\"],\n  [globalThis.performance?.now, \"performance.now\"],\n  [globalThis.queueMicrotask, \"queueMicrotask\"],\n  [globalThis.setImmediate, \"setImmediate\"],\n  [globalThis.setInterval, \"setInterval\"],\n  [globalThis.setTimeout, \"setTimeout\"],\n  [globalThis.structuredClone, \"structuredClone\"],\n  [globalThis.URL, \"URL\"],\n  [globalThis.URLSearchParams, \"URLSearchParams\"],\n  [globalThis.WritableStream, \"WritableStream\"],\n  [Int16Array, \"Int16Array\"],\n  [Int16Array.from, \"Int16Array.from\"],\n  [Int16Array.of, \"Int16Array.of\"],\n  [Int32Array, \"Int32Array\"],\n  [Int32Array.from, \"Int32Array.from\"],\n  [Int32Array.of, \"Int32Array.of\"],\n  [Int8Array, \"Int8Array\"],\n  [Int8Array.from, \"Int8Array.from\"],\n  [Int8Array.of, \"Int8Array.of\"],\n  [Intl.Collator, \"Intl.Collator\"],\n  [Intl.DateTimeFormat, \"Intl.DateTimeFormat\"],\n  [Intl.DisplayNames, \"Intl.DisplayNames\"],\n  [Intl.getCanonicalLocales, \"Intl.getCanonicalLocales\"],\n  [Intl.ListFormat, \"Intl.ListFormat\"],\n  [Intl.Locale, \"Intl.Locale\"],\n  [Intl.NumberFormat, \"Intl.NumberFormat\"],\n  [Intl.PluralRules, \"Intl.PluralRules\"],\n  [Intl.RelativeTimeFormat, \"Intl.RelativeTimeFormat\"],\n  [Intl.Segmenter, \"Intl.Segmenter\"],\n  [Intl.supportedValuesOf, \"Intl.supportedValuesOf\"],\n  [isFinite, \"isFinite\"],\n  [isNaN, \"isNaN\"],\n  [JSON.parse, \"JSON.parse\"],\n  [JSON.stringify, \"JSON.stringify\"],\n  [Map, \"Map\"],\n  [Map.groupBy, \"Map.groupBy\"],\n  [Math.abs, \"Math.abs\"],\n  [Math.acos, \"Math.acos\"],\n  [Math.acosh, \"Math.acosh\"],\n  [Math.asin, \"Math.asin\"],\n  [Math.asinh, \"Math.asinh\"],\n  [Math.atan, \"Math.atan\"],\n  [Math.atan2, \"Math.atan2\"],\n  [Math.atanh, \"Math.atanh\"],\n  [Math.cbrt, \"Math.cbrt\"],\n  [Math.ceil, \"Math.ceil\"],\n  [Math.clz32, \"Math.clz32\"],\n  [Math.cos, \"Math.cos\"],\n  [Math.cosh, \"Math.cosh\"],\n  [Math.exp, \"Math.exp\"],\n  [Math.expm1, \"Math.expm1\"],\n  [Math.floor, \"Math.floor\"],\n  [Math.fround, \"Math.fround\"],\n  [Math.hypot, \"Math.hypot\"],\n  [Math.imul, \"Math.imul\"],\n  [Math.log, \"Math.log\"],\n  [Math.log10, \"Math.log10\"],\n  [Math.log1p, \"Math.log1p\"],\n  [Math.log2, \"Math.log2\"],\n  [Math.max, \"Math.max\"],\n  [Math.min, \"Math.min\"],\n  [Math.pow, \"Math.pow\"],\n  [Math.random, \"Math.random\"],\n  [Math.round, \"Math.round\"],\n  [Math.sign, \"Math.sign\"],\n  [Math.sin, \"Math.sin\"],\n  [Math.sinh, \"Math.sinh\"],\n  [Math.sqrt, \"Math.sqrt\"],\n  [Math.tan, \"Math.tan\"],\n  [Math.tanh, \"Math.tanh\"],\n  [Math.trunc, \"Math.trunc\"],\n  [Number, \"Number\"],\n  [Number.isFinite, \"Number.isFinite\"],\n  [Number.isInteger, \"Number.isInteger\"],\n  [Number.isNaN, \"Number.isNaN\"],\n  [Number.isSafeInteger, \"Number.isSafeInteger\"],\n  [Number.parseFloat, \"Number.parseFloat\"],\n  [Number.parseInt, \"Number.parseInt\"],\n  [Object, \"Object\"],\n  [Object.assign, \"Object.assign\"],\n  [Object.create, \"Object.create\"],\n  [Object.defineProperties, \"Object.defineProperties\"],\n  [Object.defineProperty, \"Object.defineProperty\"],\n  [Object.entries, \"Object.entries\"],\n  [Object.freeze, \"Object.freeze\"],\n  [Object.fromEntries, \"Object.fromEntries\"],\n  [Object.getOwnPropertyDescriptor, \"Object.getOwnPropertyDescriptor\"],\n  [Object.getOwnPropertyDescriptors, \"Object.getOwnPropertyDescriptors\"],\n  [Object.getOwnPropertyNames, \"Object.getOwnPropertyNames\"],\n  [Object.getOwnPropertySymbols, \"Object.getOwnPropertySymbols\"],\n  [Object.getPrototypeOf, \"Object.getPrototypeOf\"],\n  [Object.is, \"Object.is\"],\n  [Object.isExtensible, \"Object.isExtensible\"],\n  [Object.isFrozen, \"Object.isFrozen\"],\n  [Object.isSealed, \"Object.isSealed\"],\n  [Object.keys, \"Object.keys\"],\n  [Object.preventExtensions, \"Object.preventExtensions\"],\n  [Object.seal, \"Object.seal\"],\n  [Object.setPrototypeOf, \"Object.setPrototypeOf\"],\n  [Object.values, \"Object.values\"],\n  [parseFloat, \"parseFloat\"],\n  [parseInt, \"parseInt\"],\n  [Promise, \"Promise\"],\n  [Proxy, \"Proxy\"],\n  [RangeError, \"RangeError\"],\n  [ReferenceError, \"ReferenceError\"],\n  [Reflect.apply, \"Reflect.apply\"],\n  [Reflect.construct, \"Reflect.construct\"],\n  [Reflect.defineProperty, \"Reflect.defineProperty\"],\n  [Reflect.deleteProperty, \"Reflect.deleteProperty\"],\n  [Reflect.get, \"Reflect.get\"],\n  [Reflect.getOwnPropertyDescriptor, \"Reflect.getOwnPropertyDescriptor\"],\n  [Reflect.getPrototypeOf, \"Reflect.getPrototypeOf\"],\n  [Reflect.has, \"Reflect.has\"],\n  [Reflect.isExtensible, \"Reflect.isExtensible\"],\n  [Reflect.ownKeys, \"Reflect.ownKeys\"],\n  [Reflect.preventExtensions, \"Reflect.preventExtensions\"],\n  [Reflect.set, \"Reflect.set\"],\n  [Reflect.setPrototypeOf, \"Reflect.setPrototypeOf\"],\n  [RegExp, \"RegExp\"],\n  [Set, \"Set\"],\n  [String, \"String\"],\n  [String.fromCharCode, \"String.fromCharCode\"],\n  [String.fromCodePoint, \"String.fromCodePoint\"],\n  [String.raw, \"String.raw\"],\n  [Symbol, \"Symbol\"],\n  [Symbol.for, \"Symbol.for\"],\n  [SyntaxError, \"SyntaxError\"],\n  [TypeError, \"TypeError\"],\n  [Uint16Array, \"Uint16Array\"],\n  [Uint16Array.from, \"Uint16Array.from\"],\n  [Uint16Array.of, \"Uint16Array.of\"],\n  [Uint32Array, \"Uint32Array\"],\n  [Uint32Array.from, \"Uint32Array.from\"],\n  [Uint32Array.of, \"Uint32Array.of\"],\n  [Uint8Array, \"Uint8Array\"],\n  [Uint8Array.from, \"Uint8Array.from\"],\n  [Uint8Array.of, \"Uint8Array.of\"],\n  [Uint8ClampedArray, \"Uint8ClampedArray\"],\n  [Uint8ClampedArray.from, \"Uint8ClampedArray.from\"],\n  [Uint8ClampedArray.of, \"Uint8ClampedArray.of\"],\n  [URIError, \"URIError\"],\n  [WeakMap, \"WeakMap\"],\n  [WeakSet, \"WeakSet\"]\n]);\nvar KNOWN_OBJECTS = /* @__PURE__ */ new Map([\n  [Atomics, \"Atomics\"],\n  [console, \"console\"],\n  [globalThis, \"globalThis\"],\n  [globalThis.crypto, \"crypto\"],\n  [Intl, \"Intl\"],\n  [JSON, \"JSON\"],\n  [Math, \"Math\"],\n  [Reflect, \"Reflect\"]\n]);\n\n// ../runtime-tags/src/html/writer.ts\nvar K_SCOPE_ID = Symbol(\"Scope ID\");\nvar tick = globalThis.setImmediate || globalThis.setTimeout || globalThis.queueMicrotask || ((cb) => Promise.resolve().then(cb));\n\n// ../runtime-tags/src/html/attrs.ts\nfunction classAttr(val) {\n  return stringAttr(\"class\", classValue(val));\n}\nfunction styleAttr(val) {\n  return stringAttr(\"style\", styleValue(val));\n}\nfunction attr(name, val) {\n  return isVoid(val) ? \"\" : nonVoidAttr(name, val);\n}\nfunction stringAttr(name, val) {\n  return val && ` ${name}=${escapeAttrValue(val)}`;\n}\nfunction nonVoidAttr(name, val) {\n  switch (typeof val) {\n    case \"string\":\n      return ` ${name + attrAssignment(val)}`;\n    case \"boolean\":\n      return ` ${name}`;\n    case \"number\":\n      return ` ${name}=${val}`;\n    case \"object\":\n      if (val instanceof RegExp) {\n        return ` ${name + attrAssignment(val.source)}`;\n      }\n      break;\n  }\n  return ` ${name + attrAssignment(val + \"\")}`;\n}\nfunction attrAssignment(val) {\n  return val ? `=${escapeAttrValue(val)}` : \"\";\n}\nvar unsafeAttrChars = /[\"'>\\s]/g;\nfunction escapeAttrValue(str) {\n  if (unsafeAttrChars.test(str)) {\n    const c = str[unsafeAttrChars.lastIndex - 1];\n    unsafeAttrChars.lastIndex = 0;\n    return c === '\"' ? `'${str.replace(/'/g, \"&#39;\")}'` : `\"${str.replace(/\"/g, \"&#34;\")}\"`;\n  }\n  return str;\n}\n\n// ../runtime-tags/src/common/compat-meta.ts\nvar prefix = false ? \"$compat_\" : \"$C_\";\nvar RENDERER_REGISTER_ID = prefix + (false ? \"renderer\" : \"r\");\nvar SET_SCOPE_REGISTER_ID = prefix + (false ? \"setScope\" : \"s\");\n\n// ../runtime-tags/src/html/compat.ts\nvar K_TAGS_API_STATE = Symbol();\n\n// ../runtime-tags/src/html/content.ts\nfunction toString(val) {\n  return val ? val + \"\" : val === 0 ? \"0\" : \"\";\n}\nvar unsafeXMLReg = /[<&]/g;\nvar replaceUnsafeXML = (c) => c === \"&\" ? \"&amp;\" : \"&lt;\";\nvar escapeXMLStr = (str) => unsafeXMLReg.test(str) ? str.replace(unsafeXMLReg, replaceUnsafeXML) : str;\nfunction escapeXML(val) {\n  return val ? escapeXMLStr(val + \"\") : val === 0 ? \"0\" : \"&zwj;\";\n}\nvar unsafeScriptReg = /<\\/script/g;\nvar escapeScriptStr = (str) => unsafeScriptReg.test(str) ? str.replace(unsafeScriptReg, \"\\\\x3C/script\") : str;\nfunction escapeScript(val) {\n  return val ? escapeScriptStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\nvar unsafeStyleReg = /<\\/style/g;\nvar escapeStyleStr = (str) => unsafeStyleReg.test(str) ? str.replace(unsafeStyleReg, \"\\\\3C/style\") : str;\nfunction escapeStyle(val) {\n  return val ? escapeStyleStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\n\n// src/util/scope-read.ts\nvar import_compiler6 = require(\"@marko/compiler\");\n\n// src/util/optional.ts\nvar Sorted = class {\n  constructor(compare) {\n    this.compare = compare;\n  }\n  add(data, item) {\n    return data ? Array.isArray(data) ? addSorted(this.compare, data, item) : joinRepeatable(this.compare, data, item) : item;\n  }\n  union(a, b) {\n    if (a) {\n      if (Array.isArray(a)) {\n        if (b) {\n          if (Array.isArray(b)) {\n            return unionSortedRepeatable(this.compare, a, b);\n          } else {\n            return addSorted(this.compare, a, b);\n          }\n        }\n        return a;\n      }\n      if (b) {\n        if (Array.isArray(b)) {\n          return addSorted(this.compare, b, a);\n        }\n        return joinRepeatable(this.compare, b, a);\n      }\n      return a;\n    }\n    return b;\n  }\n  find(data, item) {\n    if (data) {\n      if (Array.isArray(data)) {\n        return findSorted(this.compare, data, item);\n      } else if (this.compare(data, item) === 0) {\n        return data;\n      }\n    }\n  }\n};\nfunction push(data, item) {\n  if (data) {\n    if (Array.isArray(data)) {\n      data.push(item);\n      return data;\n    }\n    return [data, item];\n  }\n  return item;\n}\nfunction size(data) {\n  return data ? Array.isArray(data) ? data.length : 1 : 0;\n}\nfunction forEach(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      for (const item of data) {\n        cb(item);\n      }\n    } else {\n      cb(data);\n    }\n  }\n}\nfunction findSorted(compare, data, item) {\n  let max = data.length;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const cur = data[mid];\n    const compareResult = compare(cur, item);\n    if (compareResult === 0) return cur;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n}\nfunction addSorted(compare, data, item) {\n  const len = data.length;\n  let max = len;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(data[mid], item);\n    if (compareResult === 0) return data;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n  const result = new Array(len + 1);\n  for (let i = 0; i < pos; i++) {\n    result[i] = data[i];\n  }\n  let cur = item;\n  while (pos < len) {\n    const next = cur;\n    cur = data[pos];\n    result[pos++] = next;\n  }\n  result[len] = cur;\n  return result;\n}\nfunction unionSortedRepeatable(compare, a, b) {\n  const aLen = a.length;\n  const bLen = b.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  const result = [\n    compare(a[aIndex], b[bIndex]) <= 0 ? a[aIndex++] : b[bIndex++],\n    compare(a[aIndex], b[bIndex]) <= 0 ? a[aIndex++] : b[bIndex++]\n  ];\n  while (aIndex < aLen && bIndex < bLen) {\n    result.push(compare(a[aIndex], b[bIndex]) <= 0 ? a[aIndex++] : b[bIndex++]);\n  }\n  if (aLen === bLen && aIndex === aLen) {\n    return a;\n  }\n  while (aIndex < aLen) {\n    result.push(a[aIndex++]);\n  }\n  while (bIndex < bLen) {\n    result.push(b[bIndex++]);\n  }\n  return result;\n}\nfunction joinRepeatable(compare, a, b) {\n  const compareResult = compare(a, b);\n  return compareResult === 0 ? a : compareResult < 0 ? [a, b] : [b, a];\n}\n\n// src/util/scope-read.ts\nfunction createScopeReadPattern(section, referencedBindings) {\n  const rootDepth = section.depth;\n  const rootPattern = import_compiler6.types.objectPattern([]);\n  let nestedPatterns;\n  forEach(referencedBindings, (ref) => {\n    if (ref.name.includes(\"#\")) return;\n    const propertyKey = getScopeAccessorLiteral(ref);\n    const propertyValue = import_compiler6.types.identifier(ref.name);\n    const isShorthand = propertyKey.value === propertyValue.name;\n    let pattern = rootPattern;\n    if (ref.section !== section) {\n      if (!nestedPatterns) nestedPatterns = [rootPattern];\n      const relativeDepth = rootDepth - ref.section.depth;\n      let i = nestedPatterns.length;\n      let prev = nestedPatterns[i - 1];\n      for (; i <= relativeDepth; i++) {\n        const nestedPattern = import_compiler6.types.objectPattern([]);\n        prev.properties.push(\n          import_compiler6.types.objectProperty(import_compiler6.types.identifier(\"_\"), nestedPattern)\n        );\n        nestedPatterns.push(nestedPattern);\n        prev = nestedPattern;\n      }\n      pattern = nestedPatterns[relativeDepth];\n    }\n    pattern.properties.push(\n      import_compiler6.types.objectProperty(\n        isShorthand ? propertyValue : propertyKey,\n        propertyValue,\n        false,\n        isShorthand\n      )\n    );\n  });\n  return rootPattern;\n}\nfunction getScopeExpression(section, targetSection) {\n  let scope = scopeIdentifier ?? import_compiler6.types.identifier(\"undefined\");\n  const diff = section.depth - targetSection.depth;\n  for (let i = 0; i < diff; i++) {\n    scope = import_compiler6.types.memberExpression(scope, import_compiler6.types.identifier(\"_\"));\n  }\n  if (diff < 0) {\n    throw new Error(\"Unable to find scope for reference.\");\n  }\n  return scope;\n}\nfunction createScopeReadExpression(section, reference) {\n  return import_compiler6.types.memberExpression(\n    getScopeExpression(section, reference.section),\n    getScopeAccessorLiteral(reference),\n    true\n  );\n}\n\n// src/util/runtime.ts\nvar pureFunctions = [\n  \"createTemplate\",\n  \"createRenderer\",\n  \"value\",\n  \"intersection\",\n  \"closure\",\n  \"dynamicClosure\",\n  \"loopOf\",\n  \"loopIn\",\n  \"loopTo\",\n  \"conditional\",\n  \"bindFunction\",\n  \"bindRenderer\"\n];\nfunction importRuntime(name) {\n  const { output } = getMarkoOpts();\n  return (0, import_babel_utils7.importNamed)(currentProgramPath.hub.file, getRuntimePath(output), name);\n}\nfunction callRuntime(name, ...args) {\n  const callExpression2 = import_compiler7.types.callExpression(\n    importRuntime(name),\n    filterArguments(args)\n  );\n  if (pureFunctions.includes(\n    name\n  )) {\n    callExpression2.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: ` @__PURE__ `\n      }\n    ];\n  }\n  return callExpression2;\n}\nfunction getHTMLRuntime() {\n  return {\n    escapeXML,\n    toString,\n    attr,\n    classAttr,\n    styleAttr,\n    escapeScript,\n    escapeStyle\n  };\n}\nfunction getRuntimePath(output) {\n  const { optimize } = getMarkoOpts();\n  return `@marko/runtime-tags/${optimize ? \"\" : \"debug/\"}${output === \"html\" ? \"html\" : \"dom\"}`;\n}\nfunction filterArguments(args) {\n  const filteredArgs = [];\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (arg || filteredArgs.length) {\n      filteredArgs[i] = arg || import_compiler7.types.unaryExpression(\"void\", import_compiler7.types.numericLiteral(0));\n    }\n  }\n  return filteredArgs;\n}\n\n// src/util/signals.ts\nvar import_babel_utils9 = require(\"@marko/babel-utils\");\nvar import_compiler12 = require(\"@marko/compiler\");\n\n// src/core/return.ts\nvar import_babel_utils8 = require(\"@marko/babel-utils\");\nvar import_compiler11 = require(\"@marko/compiler\");\n\n// src/util/assert.ts\nfunction assertNoSpreadAttrs(tag) {\n  for (const attr2 of tag.get(\"attributes\")) {\n    if (attr2.isMarkoSpreadAttribute()) {\n      throw attr2.buildCodeFrameError(\n        `The \\`${tag.get(\"name\").node.value}\\` tag does not support \\`...spread\\` attributes.`\n      );\n    }\n  }\n}\nfunction assertNoBodyContent(tag) {\n  if (tag.node.body.body.length) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${tag.get(\"name\").node.value}\\` tag does not support body content.`\n    );\n  }\n}\n\n// src/util/writer.ts\nvar import_compiler10 = require(\"@marko/compiler\");\n\n// src/util/to-template-string-or-literal.ts\nvar import_compiler8 = require(\"@marko/compiler\");\nfunction toTemplateOrStringLiteral(parts) {\n  const strs = [];\n  const exprs = [];\n  let curStr = parts[0];\n  for (let i = 1; i < parts.length; i++) {\n    let content = parts[i];\n    if (typeof content === \"object\") {\n      if (import_compiler8.types.isStringLiteral(content)) {\n        content = content.value;\n      } else if (import_compiler8.types.isTemplateLiteral(content)) {\n        let nextIndex = i + 1;\n        const exprLen = content.expressions.length;\n        shiftItems(parts, nextIndex, content.quasis.length + exprLen);\n        for (let j = 0; j < exprLen; j++) {\n          parts[nextIndex++] = content.quasis[j].value.raw;\n          parts[nextIndex++] = content.expressions[j];\n        }\n        parts[nextIndex] = content.quasis[exprLen].value.raw;\n        continue;\n      } else {\n        exprs.push(content);\n        strs.push(curStr);\n        curStr = \"\";\n        continue;\n      }\n    }\n    curStr += content;\n  }\n  if (exprs.length) {\n    strs.push(curStr);\n    return import_compiler8.types.templateLiteral(\n      strs.map((raw) => import_compiler8.types.templateElement({ raw })),\n      exprs\n    );\n  } else if (curStr) {\n    return import_compiler8.types.stringLiteral(curStr);\n  }\n}\nfunction appendLiteral(arr, str) {\n  arr[arr.length - 1] += str;\n}\nfunction shiftItems(list, start, offset) {\n  for (let i = list.length - 1; i >= start; i--) {\n    list[i + offset] = list[i];\n  }\n}\n\n// src/util/walks.ts\nvar import_compiler9 = require(\"@marko/compiler\");\nvar [getWalks] = createSectionState(\n  \"walks\",\n  () => [\"\"]\n);\nvar [getWalkComment] = createSectionState(\n  \"walkComment\",\n  () => []\n);\nvar [getSteps] = createSectionState(\"steps\", () => []);\nvar walkCodeToName = {\n  [32 /* Get */]: \"get\",\n  [33 /* Before */]: \"before\",\n  [35 /* After */]: \"after\",\n  [36 /* Inside */]: \"inside\",\n  [37 /* Replace */]: \"replace\",\n  [38 /* EndChild */]: \"endChild\",\n  [47 /* BeginChild */]: \"beginChild\",\n  [67 /* Next */]: \"next\",\n  [97 /* Over */]: \"over\",\n  [107 /* Out */]: \"out\",\n  [117 /* Multiplier */]: \"multiplier\",\n  [91 /* NextEnd */]: \"nextEnd\",\n  [106 /* OverEnd */]: \"overEnd\",\n  [116 /* OutEnd */]: \"outEnd\",\n  [126 /* MultiplierEnd */]: \"multiplierEnd\"\n};\nfunction enter(path3) {\n  getSteps(getSection(path3)).push(0 /* Enter */);\n}\nfunction exit(path3) {\n  getSteps(getSection(path3)).push(1 /* Exit */);\n}\nfunction enterShallow(path3) {\n  getSteps(getSection(path3)).push(0 /* Enter */, 1 /* Exit */);\n}\nfunction injectWalks(path3, expr) {\n  const walks = getWalks(getSection(path3));\n  const walkComment = getWalkComment(getSection(path3));\n  walkComment.push(\n    `${walkCodeToName[47 /* BeginChild */]}`,\n    expr.name,\n    walkCodeToName[38 /* EndChild */]\n  );\n  appendLiteral(walks, String.fromCharCode(47 /* BeginChild */));\n  walks.push(expr, String.fromCharCode(38 /* EndChild */));\n}\nfunction visit(path3, code) {\n  if (isOutputHTML()) {\n    return;\n  }\n  const section = getSection(path3);\n  const steps = getSteps(section);\n  const walks = getWalks(section);\n  const walkComment = getWalkComment(section);\n  let walkString = \"\";\n  if (steps.length) {\n    const walks2 = [];\n    let depth = 0;\n    for (const step of steps) {\n      if (step === 0 /* Enter */) {\n        depth++;\n        walks2.push(67 /* Next */);\n      } else {\n        depth--;\n        if (depth >= 0) {\n          walks2.length = walks2.lastIndexOf(67 /* Next */);\n          walks2.push(97 /* Over */);\n        } else {\n          walks2.length = walks2.lastIndexOf(107 /* Out */) + 1;\n          walks2.push(107 /* Out */);\n          depth = 0;\n        }\n      }\n    }\n    let current = walks2[0];\n    let count = 0;\n    for (const walk of walks2) {\n      if (walk !== current) {\n        walkComment.push(`${walkCodeToName[current]}(${count})`);\n        walkString += nCodeString(current, count);\n        current = walk;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n    walkComment.push(`${walkCodeToName[current]}(${count})`);\n    walkString += nCodeString(current, count);\n    steps.length = 0;\n  }\n  if (code !== void 0) {\n    if (code !== 32 /* Get */) {\n      writeTo(path3)`<!>`;\n    }\n    walkComment.push(`${walkCodeToName[code]}`);\n    walkString += String.fromCharCode(code);\n  }\n  appendLiteral(walks, walkString);\n}\nfunction nCodeString(code, number) {\n  switch (code) {\n    case 67 /* Next */:\n      return toCharString(number, code, 20 /* Next */);\n    case 97 /* Over */:\n      return toCharString(number, code, 10 /* Over */);\n    case 107 /* Out */:\n      return toCharString(number, code, 10 /* Out */);\n    default:\n      throw new Error(`Unexpected walk code: ${code}`);\n  }\n}\nfunction toCharString(number, startCode, rangeSize) {\n  let result = \"\";\n  if (number >= rangeSize) {\n    const multiplier = Math.floor(number / rangeSize);\n    result += toCharString(\n      multiplier,\n      117 /* Multiplier */,\n      10 /* Multiplier */\n    );\n    number -= multiplier * rangeSize;\n  }\n  result += String.fromCharCode(startCode + number);\n  return result;\n}\nfunction getWalkString(section) {\n  const prefix2 = section.startNodeContentType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const postfix = section.endNodeContentType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const walks = getWalks(section);\n  const walkLiteral = toTemplateOrStringLiteral([prefix2, ...walks, postfix]) || import_compiler9.types.stringLiteral(\"\");\n  if (walkLiteral.value !== \"\") {\n    walkLiteral.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: \" \" + getWalkComment(section).join(\", \") + \" \"\n      }\n    ];\n  }\n  return walkLiteral;\n}\n\n// src/util/writer.ts\nvar [getWrites] = createSectionState(\n  \"writes\",\n  () => [\"\"]\n);\nfunction writeTo(path3) {\n  const section = getSection(path3);\n  return (strs, ...exprs) => {\n    const exprsLen = exprs.length;\n    const writes = getWrites(section);\n    appendLiteral(writes, strs[0]);\n    for (let i = 0; i < exprsLen; i++) {\n      writes.push(exprs[i], strs[i + 1]);\n    }\n  };\n}\nfunction consumeHTML(path3) {\n  const writes = getWrites(getSection(path3));\n  const result = toTemplateOrStringLiteral(writes);\n  writes.length = 0;\n  writes[0] = \"\";\n  if (result) {\n    return import_compiler10.types.expressionStatement(callRuntime(\"write\", result));\n  }\n}\nfunction flushBefore(path3) {\n  const expr = consumeHTML(path3);\n  if (expr) {\n    path3.insertBefore(expr)[0].skip();\n  }\n}\nfunction flushInto(path3) {\n  const target = path3.isProgram() ? path3 : path3.get(\"body\");\n  const expr = consumeHTML(target);\n  if (expr) {\n    target.pushContainer(\"body\", expr)[0].skip();\n  }\n}\nfunction getSectionMeta(section) {\n  const writePrefix = section.startNodeContentType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writePostfix = section.endNodeContentType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writes = getWrites(section);\n  return {\n    setup: getSetup(section),\n    walks: getWalkString(section),\n    writes: toTemplateOrStringLiteral([writePrefix, ...writes, writePostfix]) || import_compiler10.types.stringLiteral(\"\")\n  };\n}\nfunction markNode(path3, binding) {\n  const section = getSection(path3);\n  if (binding.type !== 0 /* dom */) {\n    throw path3.buildCodeFrameError(\n      \"Tried to mark a node that was not determined to need a mark during analyze.\"\n    );\n  }\n  if (isOutputHTML()) {\n    writeTo(path3)`${callRuntime(\n      \"markResumeNode\",\n      getScopeIdIdentifier(section),\n      getScopeAccessorLiteral(binding)\n    )}`;\n  }\n}\n\n// src/core/return.ts\nvar [returnId, _setReturnId] = createSectionState(\n  \"returnId\"\n);\nvar usedTag = /* @__PURE__ */ new WeakSet();\nvar return_default = {\n  analyze(tag) {\n    (0, import_babel_utils8.assertNoArgs)(tag);\n    (0, import_babel_utils8.assertNoVar)(tag);\n    (0, import_babel_utils8.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    if (usedTag.has(tag.hub)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `return` tag can only be used once per template.\"\n      );\n    }\n    usedTag.add(tag.hub);\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    if (!import_compiler11.types.isMarkoAttribute(valueAttr) || !valueAttr.default) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `return` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 && node.attributes[1].name !== \"valueChange\") {\n      const start = node.attributes[1].loc?.start;\n      const end = node.attributes[node.attributes.length - 1].loc?.end;\n      const msg = \"The `return` tag only supports the `value` attribute.\";\n      if (start == null || end == null) {\n        throw tag.get(\"name\").buildCodeFrameError(msg);\n      } else {\n        throw tag.hub.buildError(\n          { loc: { start, end } },\n          msg,\n          Error\n        );\n      }\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const {\n        node: {\n          attributes: [{ value }]\n        },\n        hub: { file }\n      } = tag;\n      if (isOutputHTML()) {\n        flushBefore(tag);\n        const returnId2 = file.path.scope.generateUidIdentifier(\"return\");\n        _setReturnId(section, returnId2);\n        tag.replaceWith(\n          import_compiler11.types.variableDeclaration(\"const\", [\n            import_compiler11.types.variableDeclarator(returnId2, value)\n          ])\n        )[0].skip();\n      } else {\n        addValue(\n          section,\n          value.extra?.referencedBindings,\n          {\n            identifier: importRuntime(\"tagVarSignal\"),\n            hasDownstreamIntersections: () => true\n          },\n          value\n        );\n        tag.remove();\n      }\n    }\n  },\n  autocomplete: [\n    {\n      displayText: \"return=<value>\",\n      description: \"Provides a value for use in a parent template.\",\n      snippet: \"return=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#return\"\n    }\n  ]\n};\n\n// src/util/signals.ts\nvar [getSignals] = createSectionState(\n  \"signals\",\n  () => /* @__PURE__ */ new Map()\n);\nvar [getSubscribeBuilder, _setSubscribeBuilder] = createSectionState(\"queue\");\nfunction setSubscriberBuilder(tag, builder) {\n  _setSubscribeBuilder(getSection(tag.get(\"body\")), builder);\n}\nvar [getClosures] = createSectionState(\n  \"closures\",\n  () => []\n);\nvar addClosure = (fromSection, toSection, closure) => {\n  let currentSection = fromSection;\n  while (currentSection !== void 0 && currentSection !== toSection) {\n    getClosures(currentSection).push(closure);\n    currentSection = currentSection.parent;\n  }\n};\nvar [forceResumeScope, _setForceResumeScope] = createSectionState(\"forceResumeScope\");\nfunction setForceResumeScope(section) {\n  _setForceResumeScope(section, true);\n}\nvar [getSerializedScopeProperties] = createSectionState(\"serializedScopeProperties\", () => /* @__PURE__ */ new Map());\nvar unimplementedBuild = () => {\n  return import_compiler12.types.stringLiteral(\"SIGNAL NOT INITIALIZED\");\n};\nfunction getSignal(section, referencedBindings, name = generateSignalName(referencedBindings)) {\n  const signals = getSignals(section);\n  let signal = signals.get(referencedBindings);\n  if (!signal) {\n    const exportName = referencedBindings && !Array.isArray(referencedBindings) && referencedBindings.section === section && referencedBindings.export;\n    signals.set(\n      referencedBindings,\n      signal = {\n        identifier: exportName ? import_compiler12.types.identifier(exportName) : currentProgramPath.scope.generateUidIdentifier(\n          name + section.name.replace(\"_\", \"$\")\n        ),\n        referencedBindings,\n        section,\n        values: [],\n        intersection: void 0,\n        render: [],\n        effect: [],\n        effectInlineReferences: void 0,\n        subscribers: [],\n        closures: /* @__PURE__ */ new Map(),\n        hasDownstreamIntersections: () => {\n          let hasDownstreamIntersections = !!(signal.intersection || signal.closures.size);\n          if (!hasDownstreamIntersections) {\n            for (const value of signal.values) {\n              if (value.signal.hasDownstreamIntersections()) {\n                hasDownstreamIntersections = true;\n                break;\n              }\n            }\n          }\n          if (!hasDownstreamIntersections) {\n            if (!Array.isArray(referencedBindings) && referencedBindings) {\n              for (const alias of referencedBindings.aliases) {\n                if (getSignal(section, alias).hasDownstreamIntersections()) {\n                  hasDownstreamIntersections = true;\n                  break;\n                }\n              }\n              if (!hasDownstreamIntersections) {\n                for (const [, alias] of referencedBindings.propertyAliases) {\n                  if (getSignal(section, alias).hasDownstreamIntersections()) {\n                    hasDownstreamIntersections = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          signal.hasDownstreamIntersections = () => hasDownstreamIntersections;\n          return hasDownstreamIntersections;\n        },\n        build: unimplementedBuild,\n        export: !!exportName\n      }\n    );\n    if (isOutputHTML()) {\n      return signal;\n    } else if (!referencedBindings) {\n      signal.build = () => getSignalFn(signal, [scopeIdentifier]);\n    } else if (Array.isArray(referencedBindings)) {\n      subscribe(referencedBindings, signal);\n      signal.build = () => {\n        return callRuntime(\n          \"intersection\",\n          import_compiler12.types.numericLiteral(referencedBindings.length),\n          getSignalFn(signal, [scopeIdentifier], referencedBindings)\n        );\n      };\n    } else if (referencedBindings.section !== section) {\n      const provider = getSignal(\n        referencedBindings.section,\n        referencedBindings\n      );\n      addClosure(\n        section,\n        section.parent,\n        signal.identifier\n      );\n      provider.closures.set(section, signal);\n      signal.build = () => {\n        const builder = getSubscribeBuilder(section);\n        const ownerScope = getScopeExpression(\n          section,\n          referencedBindings.section\n        );\n        const isImmediateOwner = ownerScope.object === scopeIdentifier;\n        const isDynamicClosure = signal.isDynamicClosure = !(isImmediateOwner && builder);\n        return callRuntime(\n          isDynamicClosure ? \"dynamicClosure\" : \"closure\",\n          getScopeAccessorLiteral(referencedBindings),\n          getSignalFn(signal, [\n            scopeIdentifier,\n            import_compiler12.types.identifier(referencedBindings.name)\n          ]),\n          isImmediateOwner ? null : import_compiler12.types.arrowFunctionExpression([scopeIdentifier], ownerScope),\n          buildSignalIntersections(signal)\n        );\n      };\n    }\n  }\n  return signal;\n}\nfunction initValue(binding) {\n  const valueAccessor = getScopeAccessorLiteral(binding);\n  const section = binding.section;\n  const signal = getSignal(section, binding);\n  signal.build = () => {\n    const fn = getSignalFn(signal, [\n      scopeIdentifier,\n      import_compiler12.types.identifier(binding.name)\n    ]);\n    const intersections = buildSignalIntersections(signal);\n    const isParamBinding = !binding.upstreamAlias && (binding.type === 3 /* param */ || binding.type === 2 /* input */);\n    const isNakedAlias = binding.upstreamAlias && !binding.property;\n    const needsGuard = !isNakedAlias && (binding.downstreamExpressions.size || fn.body.body.length > 0);\n    const needsCache = needsGuard || intersections;\n    const needsMarks = isParamBinding || intersections;\n    if (needsCache || needsMarks) {\n      return callRuntime(\"value\", valueAccessor, fn, intersections);\n    } else {\n      return fn;\n    }\n  };\n  signal.valueAccessor = valueAccessor;\n  for (const alias of binding.aliases) {\n    initValue(alias);\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    initValue(alias);\n  }\n  return signal;\n}\nfunction getSignalFn(signal, params, referencedBindings) {\n  const section = signal.section;\n  const binding = signal.referencedBindings;\n  if (binding && !Array.isArray(binding) && binding.section === section) {\n    const [scopeIdentifier2, valueIdentifier] = params;\n    for (const alias of binding.aliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler12.types.expressionStatement(\n          import_compiler12.types.callExpression(aliasSignal.callee || aliasSignal.identifier, [\n            scopeIdentifier2,\n            valueIdentifier\n          ])\n        )\n      );\n    }\n    for (const [key, alias] of binding.propertyAliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler12.types.expressionStatement(\n          import_compiler12.types.callExpression(aliasSignal.callee || aliasSignal.identifier, [\n            scopeIdentifier2,\n            toMemberExpression(valueIdentifier, key)\n          ])\n        )\n      );\n    }\n  }\n  for (const value of signal.values) {\n    signal.render.push(\n      import_compiler12.types.expressionStatement(\n        import_compiler12.types.callExpression(value.signal.callee || value.signal.identifier, [\n          value.scope,\n          value.value\n        ])\n      )\n    );\n  }\n  if (referencedBindings) {\n    signal.render.unshift(\n      import_compiler12.types.variableDeclaration(\"const\", [\n        import_compiler12.types.variableDeclarator(\n          createScopeReadPattern(section, referencedBindings),\n          scopeIdentifier\n        )\n      ])\n    );\n  }\n  return import_compiler12.types.arrowFunctionExpression(params, import_compiler12.types.blockStatement(signal.render));\n}\nfunction buildSignalIntersections(signal) {\n  const section = signal.section;\n  let intersections = signal.intersection;\n  const binding = signal.referencedBindings;\n  if (binding && !Array.isArray(binding) && binding.section === signal.section) {\n    for (const alias of binding.aliases) {\n      const signal2 = getSignal(alias.section, alias);\n      if (signal2.hasDownstreamIntersections()) {\n        intersections = push(\n          intersections,\n          import_compiler12.types.identifier(signal2.identifier.name)\n        );\n      }\n    }\n    for (const [, alias] of binding.propertyAliases) {\n      const signal2 = getSignal(alias.section, alias);\n      if (signal2.hasDownstreamIntersections()) {\n        intersections = push(\n          intersections,\n          import_compiler12.types.identifier(signal2.identifier.name)\n        );\n      }\n    }\n  }\n  for (const value of signal.values) {\n    if (value.signal.hasDownstreamIntersections()) {\n      intersections = push(\n        intersections,\n        value.intersectionExpression ?? import_compiler12.types.identifier(value.signal.identifier.name)\n      );\n    }\n  }\n  const closureEntries = Array.from(signal.closures.entries()).sort(\n    ([a], [b]) => a.id - b.id\n  );\n  for (const [closureSection, closureSignal] of closureEntries) {\n    const builder = getSubscribeBuilder(closureSection);\n    const isImmediateOwner = closureSection.parent === section;\n    if (builder && isImmediateOwner) {\n      intersections = push(intersections, builder(closureSignal.identifier));\n    } else if (!signal.hasDynamicSubscribers) {\n      signal.hasDynamicSubscribers = true;\n    }\n  }\n  if (signal.hasDynamicSubscribers) {\n    signal.hasDynamicSubscribers = true;\n    intersections = push(\n      intersections,\n      callRuntime(\"dynamicSubscribers\", signal.valueAccessor)\n    );\n  }\n  return Array.isArray(intersections) ? callRuntime(\"intersections\", import_compiler12.types.arrayExpression(intersections)) : intersections;\n}\nfunction subscribe(provider, subscriber) {\n  if (Array.isArray(provider)) {\n    provider.forEach((p) => subscribe(p, subscriber));\n    return;\n  }\n  const providerSignal = getSignal(subscriber.section, provider);\n  providerSignal.intersection = push(\n    providerSignal.intersection,\n    subscriber.identifier\n  );\n}\nfunction generateSignalName(referencedBindings) {\n  let name;\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      name = \"expr\";\n      for (const ref of referencedBindings) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name = referencedBindings.name;\n    }\n  } else {\n    name = \"setup\";\n  }\n  return name;\n}\nfunction queueSource(source, value, targetSection, changeBinding) {\n  if (!changeBinding) {\n    return callRuntime(\n      \"queueSource\",\n      getScopeExpression(targetSection, source.section),\n      source.identifier,\n      value\n    );\n  }\n  const changeBindingId = import_compiler12.types.identifier(changeBinding.name);\n  if (changeBinding.upstreamExpression?.static) {\n    return import_compiler12.types.callExpression(changeBindingId, [value]);\n  }\n  return callRuntime(\n    \"queueControllableSource\",\n    getScopeExpression(targetSection, source.section),\n    source.identifier,\n    changeBindingId,\n    value\n  );\n}\nfunction finalizeSignalArgs(args) {\n  for (let i = args.length - 1; i >= 0; i--) {\n    const arg = args[i];\n    if (import_compiler12.types.isArrowFunctionExpression(arg)) {\n      const body = arg.body.body;\n      if (body) {\n        if (body.length === 0) {\n          args[i] = import_compiler12.types.nullLiteral();\n        } else if (body.length === 1 && import_compiler12.types.isExpressionStatement(body[0])) {\n          arg.body = body[0].expression;\n        }\n      }\n    }\n  }\n  for (let i = args.length - 1; import_compiler12.types.isNullLiteral(args[i]); ) {\n    args.length = i--;\n  }\n}\nfunction addStatement(type, targetSection, referencedBindings, statement, originalNodes, isInlined) {\n  const signal = getSignal(targetSection, referencedBindings);\n  const statements = signal[type] ??= [];\n  if (Array.isArray(statement)) {\n    statements.push(...statement);\n  } else {\n    statements.push(statement);\n  }\n  if (type === \"effect\") {\n    if (Array.isArray(originalNodes)) {\n      for (const node of originalNodes) {\n        if (isInlined || !import_compiler12.types.isFunction(node)) {\n          addEffectReferences(signal, node);\n        }\n      }\n    } else {\n      if (isInlined || !import_compiler12.types.isFunction(originalNodes)) {\n        addEffectReferences(signal, originalNodes);\n      }\n    }\n  }\n}\nfunction addValue(targetSection, referencedBindings, signal, value, scope = scopeIdentifier, intersectionExpression) {\n  getSignal(targetSection, referencedBindings).values.push({\n    signal,\n    value,\n    scope,\n    intersectionExpression\n  });\n}\nfunction addEffectReferences(signal, expression) {\n  signal.effectInlineReferences = bindingUtil.union(\n    signal.effectInlineReferences,\n    expression.extra?.referencedBindings\n  );\n}\nfunction getResumeRegisterId(section, referencedBindings, type) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let name = \"\";\n  if (referencedBindings) {\n    if (typeof referencedBindings === \"string\") {\n      name += `_${referencedBindings}`;\n    } else if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name += `_${referencedBindings.name}`;\n    }\n  }\n  return (0, import_babel_utils9.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}${name}${type ? \"/\" + type : \"\"}`\n  );\n}\nfunction renameBindings() {\n  import_compiler12.types.traverseFast(currentProgramPath.node, (node) => {\n    if (import_compiler12.types.isIdentifier(node)) {\n      const binding = node.extra && (node.extra.source || node.extra.binding);\n      if (binding && binding.name !== node.name) {\n        node.name = binding.name;\n      }\n    }\n  });\n}\nfunction replaceAssignments() {\n  if (currentProgramPath.node.extra.assignments) {\n    for (const [valueSection, assignment] of currentProgramPath.node.extra.assignments) {\n      const { node } = assignment;\n      if (node.type === \"UpdateExpression\") {\n        const binding = node.argument.extra?.source;\n        if (binding) {\n          const { buildAssignment } = getSignal(binding.section, binding);\n          if (buildAssignment) {\n            const replacement = buildAssignment(\n              valueSection,\n              import_compiler12.types.binaryExpression(\n                node.operator === \"++\" ? \"+\" : \"-\",\n                node.argument,\n                import_compiler12.types.numericLiteral(1)\n              )\n            );\n            assignment.replaceWith(\n              node.prefix || assignment.parentPath.isExpressionStatement() ? replacement : import_compiler12.types.sequenceExpression([replacement, node.argument])\n            );\n          }\n        }\n      } else {\n        if (node.left.type === \"ObjectPattern\" || node.left.type === \"ArrayPattern\") {\n          handleDestructure(assignment, node.left, valueSection);\n        } else if (node.left.type === \"Identifier\") {\n          const binding = node.left.extra?.source;\n          if (binding) {\n            const { buildAssignment } = getSignal(binding.section, binding);\n            if (buildAssignment) {\n              const replacement = buildAssignment(\n                valueSection,\n                node.operator === \"=\" ? node.right : import_compiler12.types.binaryExpression(\n                  node.operator.slice(\n                    0,\n                    -1\n                  ),\n                  node.left,\n                  node.right\n                )\n              );\n              assignment.replaceWith(replacement);\n            }\n          }\n        }\n      }\n    }\n  }\n}\nfunction writeSignals(section) {\n  const signals = [...getSignals(section).values()].sort(sortSignals);\n  for (const signal of signals) {\n    let effectDeclarator;\n    if (signal.effect.length) {\n      const effectIdentifier = import_compiler12.types.identifier(`${signal.identifier.name}_effect`);\n      if (signal.effectInlineReferences) {\n        signal.effect.unshift(\n          import_compiler12.types.variableDeclaration(\"const\", [\n            import_compiler12.types.variableDeclarator(\n              createScopeReadPattern(section, signal.effectInlineReferences),\n              scopeIdentifier\n            )\n          ])\n        );\n      }\n      effectDeclarator = import_compiler12.types.variableDeclarator(\n        effectIdentifier,\n        callRuntime(\n          \"register\",\n          import_compiler12.types.stringLiteral(\n            getResumeRegisterId(section, signal.referencedBindings)\n          ),\n          import_compiler12.types.arrowFunctionExpression(\n            [scopeIdentifier],\n            signal.effect.length === 1 && import_compiler12.types.isExpressionStatement(signal.effect[0]) ? signal.effect[0].expression : import_compiler12.types.blockStatement(signal.effect)\n          )\n        )\n      );\n      signal.render.push(\n        import_compiler12.types.expressionStatement(\n          callRuntime(\"queueEffect\", scopeIdentifier, effectIdentifier)\n        )\n      );\n    }\n    let value = signal.build();\n    if (import_compiler12.types.isCallExpression(value)) {\n      finalizeSignalArgs(value.arguments);\n    }\n    if (signal.register) {\n      value = callRuntime(\n        \"registerBoundSignal\",\n        import_compiler12.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings)\n        ),\n        value\n      );\n    }\n    if (signal.isDynamicClosure && isStatefulReferences(signal.referencedBindings)) {\n      value = callRuntime(\n        \"registerSubscriber\",\n        import_compiler12.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings, \"subscriber\")\n        ),\n        value\n      );\n    }\n    const signalDeclarator = import_compiler12.types.variableDeclarator(signal.identifier, value);\n    let signalDeclaration = import_compiler12.types.variableDeclaration(\"const\", [\n      signalDeclarator\n    ]);\n    if (signal.export) {\n      signalDeclaration = import_compiler12.types.exportNamedDeclaration(signalDeclaration);\n    }\n    const roots = currentProgramPath.pushContainer(\n      \"body\",\n      effectDeclarator ? [\n        import_compiler12.types.variableDeclaration(\"const\", [effectDeclarator]),\n        signalDeclaration\n      ] : signalDeclaration\n    );\n    for (const root of roots) {\n      root.traverse(bindFunctionsVisitor, { root, section });\n    }\n  }\n}\nfunction sortSignals(a, b) {\n  const aReferencedBindings = getReferencedBindings(a);\n  const bReferencedBindings = getReferencedBindings(b);\n  for (let i = Math.max(aReferencedBindings.length, bReferencedBindings.length) - 1; i >= 0; i--) {\n    const diff = (bReferencedBindings[i] ?? -1) - (aReferencedBindings[i] ?? -1);\n    if (diff !== 0) return diff;\n  }\n  return 0;\n}\nfunction getReferencedBindings({ referencedBindings: reserve }) {\n  if (!reserve) {\n    return [];\n  } else if (Array.isArray(reserve)) {\n    return reserve.map(getMappedId).sort();\n  } else {\n    return [getMappedId(reserve)];\n  }\n}\nfunction getMappedId(reference) {\n  return (reference.type === 0 /* dom */ ? 1 : 0) * 1e4 + reference.id;\n}\nfunction addHTMLEffectCall(section, referencedBindings) {\n  addStatement(\"effect\", section, referencedBindings, void 0, []);\n}\nfunction writeHTMLResumeStatements(path3, tagVarIdentifier) {\n  if (!hasSection(path3)) return;\n  const section = getSection(path3);\n  const allSignals = Array.from(getSignals(section).values());\n  const scopeIdIdentifier = getScopeIdIdentifier(section);\n  for (const closure of section.closures) {\n    if (isStatefulReferences(closure)) {\n      let currentSection = section;\n      while (currentSection !== closure.section) {\n        getSerializedScopeProperties(currentSection).set(\n          import_compiler12.types.stringLiteral(\"_\"),\n          callRuntime(\n            \"ensureScopeWithId\",\n            getScopeIdIdentifier(currentSection = currentSection.parent)\n          )\n        );\n      }\n      setForceResumeScope(closure.section);\n      const isImmediateOwner = section.parent?.id === closure.section.id;\n      const isDynamicClosure = !getSubscribeBuilder(section) || !isImmediateOwner;\n      if (isDynamicClosure) {\n        path3.pushContainer(\n          \"body\",\n          import_compiler12.types.expressionStatement(\n            callRuntime(\n              \"writeEffect\",\n              scopeIdIdentifier,\n              import_compiler12.types.stringLiteral(\n                getResumeRegisterId(section, closure, \"subscriber\")\n              )\n            )\n          )\n        );\n      }\n    }\n  }\n  for (let i = allSignals.length; i--; ) {\n    if (allSignals[i].effect.length) {\n      const signalRefs = allSignals[i].referencedBindings;\n      path3.pushContainer(\n        \"body\",\n        import_compiler12.types.expressionStatement(\n          callRuntime(\n            \"writeEffect\",\n            scopeIdIdentifier,\n            import_compiler12.types.stringLiteral(getResumeRegisterId(section, signalRefs))\n          )\n        )\n      );\n    }\n  }\n  const accessors = /* @__PURE__ */ new Set();\n  const additionalProperties = getSerializedScopeProperties(section);\n  const serializedProperties = [];\n  for (const binding of section.bindings) {\n    if (binding.serialize && binding.type !== 0 /* dom */) {\n      const accessor = getScopeAccessorLiteral(binding);\n      serializedProperties.push(\n        import_compiler12.types.objectProperty(accessor, import_compiler12.types.identifier(binding.name))\n      );\n      accessors.add(accessor.value);\n    }\n  }\n  if (tagVarIdentifier && returnId(section) !== void 0) {\n    serializedProperties.push(\n      import_compiler12.types.objectProperty(\n        import_compiler12.types.stringLiteral(\"/\" /* TagVariable */),\n        tagVarIdentifier\n      )\n    );\n  }\n  for (const [key, value] of additionalProperties) {\n    if (!accessors.has(key.value)) {\n      serializedProperties.push(\n        import_compiler12.types.objectProperty(key, value, !import_compiler12.types.isLiteral(key))\n      );\n      accessors.add(key.value);\n    }\n  }\n  if (serializedProperties.length || forceResumeScope(section)) {\n    path3.pushContainer(\n      \"body\",\n      import_compiler12.types.expressionStatement(\n        callRuntime(\n          \"writeScope\",\n          scopeIdIdentifier,\n          import_compiler12.types.objectExpression(serializedProperties)\n        )\n      )\n    );\n  }\n  if (path3.get(\"body\").length) {\n    path3.unshiftContainer(\n      \"body\",\n      import_compiler12.types.variableDeclaration(\"const\", [\n        import_compiler12.types.variableDeclarator(scopeIdIdentifier, callRuntime(\"nextScopeId\"))\n      ])\n    );\n  }\n}\nvar bindFunctionsVisitor = {\n  FunctionExpression: { exit: bindFunction },\n  ArrowFunctionExpression: { exit: bindFunction }\n};\nfunction handleDestructure(assignment, node, section, ctx, replace) {\n  if (!ctx) {\n    ctx = {\n      statement: assignment.getStatementParent(),\n      end: assignment.getStatementParent()\n    };\n  }\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        handleDestructure(assignment, prop, section, ctx);\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const i in node.elements) {\n        if (node.elements[i] === null) continue;\n        handleDestructure(\n          assignment,\n          node.elements[i],\n          section,\n          ctx,\n          (id) => node.elements[i] = id\n        );\n      }\n      break;\n    case \"RestElement\":\n      handleDestructure(\n        assignment,\n        node.argument,\n        section,\n        ctx,\n        (id) => node.argument = id\n      );\n      break;\n    case \"ObjectProperty\":\n      handleDestructure(\n        assignment,\n        node.value,\n        section,\n        ctx,\n        (id) => node.value = id\n      );\n      break;\n    case \"Identifier\":\n      {\n        const binding = node.extra?.source;\n        if (binding) {\n          const { buildAssignment } = getSignal(binding.section, binding);\n          if (buildAssignment) {\n            const valueId = ctx.statement.scope.generateUidIdentifier(\n              node.name\n            );\n            ctx.statement.insertBefore(\n              import_compiler12.types.variableDeclaration(\"let\", [import_compiler12.types.variableDeclarator(valueId)])\n            );\n            replace?.(valueId);\n            [ctx.end] = ctx.end.insertAfter(\n              import_compiler12.types.expressionStatement(buildAssignment(section, valueId))\n            );\n          }\n        }\n      }\n      break;\n  }\n}\nfunction bindFunction(fn, { root, section }) {\n  const { node } = fn;\n  const { extra } = node;\n  if (!extra?.referencedBindings) return;\n  const { name, referencedBindings } = extra;\n  const fnId = fn.hub.file.path.scope.generateUidIdentifier(name);\n  root.insertBefore(\n    import_compiler12.types.variableDeclaration(\"const\", [\n      import_compiler12.types.variableDeclarator(\n        fnId,\n        import_compiler12.types.arrowFunctionExpression(\n          [scopeIdentifier],\n          referencedBindings ? import_compiler12.types.blockStatement([\n            import_compiler12.types.variableDeclaration(\"const\", [\n              import_compiler12.types.variableDeclarator(\n                createScopeReadPattern(section, referencedBindings),\n                scopeIdentifier\n              )\n            ]),\n            import_compiler12.types.returnStatement(node)\n          ]) : node\n        )\n      )\n    ])\n  )[0].skip();\n  fn.replaceWith(import_compiler12.types.callExpression(fnId, [scopeIdentifier]))[0].skip();\n}\nfunction getSetup(section) {\n  return getSignals(section).get(void 0)?.identifier;\n}\nfunction toMemberExpression(value, key) {\n  const keyLiteral = keyToNode(key);\n  return import_compiler12.types.memberExpression(\n    value,\n    keyLiteral,\n    keyLiteral.type !== \"Identifier\"\n  );\n}\nfunction keyToNode(key) {\n  if (/^[a-z_$][a-z0-9_$]*$/i.test(key)) {\n    return import_compiler12.types.identifier(key);\n  } else if (/^(?:0|[1-9][0-9]*)$/.test(key)) {\n    return import_compiler12.types.numericLiteral(parseInt(key, 10));\n  }\n  return import_compiler12.types.stringLiteral(key);\n}\n\n// src/visitors/program/dom.ts\nvar dom_default = {\n  translate: {\n    exit(program) {\n      visit(program);\n      const section = getSection(program);\n      const { walks, writes, setup } = getSectionMeta(section);\n      const domExports = program.node.extra.domExports;\n      const templateIdentifier = import_compiler13.types.identifier(domExports.template);\n      const walksIdentifier = import_compiler13.types.identifier(domExports.walks);\n      const setupIdentifier = import_compiler13.types.identifier(domExports.setup);\n      const closuresIdentifier = import_compiler13.types.identifier(domExports.closures);\n      const paramsBinding = program.node.extra.binding;\n      const programParamsSignal = paramsBinding && bindingHasDownstreamExpressions(paramsBinding) ? initValue(paramsBinding) : void 0;\n      replaceAssignments();\n      forEachSectionReverse((childSection) => {\n        if (childSection !== section) {\n          const sectionPath = getSectionPath(childSection);\n          const sectionParamsBinding = sectionPath.node.extra?.binding;\n          const tagParamsSignal = sectionParamsBinding && initValue(sectionParamsBinding);\n          const { walks: walks2, writes: writes2, setup: setup2 } = getSectionMeta(childSection);\n          const closures2 = getClosures(childSection);\n          const identifier = import_compiler13.types.identifier(childSection.name);\n          const renderer = callRuntime(\n            \"createRenderer\",\n            writes2,\n            walks2,\n            setup2,\n            closures2.length && import_compiler13.types.arrayExpression(closures2),\n            void 0,\n            tagParamsSignal?.identifier\n          );\n          writeSignals(childSection);\n          program.node.body.push(\n            import_compiler13.types.variableDeclaration(\"const\", [\n              import_compiler13.types.variableDeclarator(\n                identifier,\n                isStatefulSection(childSection) ? callRuntime(\n                  childSection.closures.size ? \"registerRenderer\" : \"register\",\n                  import_compiler13.types.stringLiteral(\n                    getResumeRegisterId(childSection, \"renderer\")\n                  ),\n                  renderer\n                ) : renderer\n              )\n            ])\n          );\n        }\n      });\n      const closures = getClosures(section);\n      writeSignals(section);\n      renameBindings();\n      program.node.body.push(\n        import_compiler13.types.exportNamedDeclaration(\n          import_compiler13.types.variableDeclaration(\"const\", [\n            import_compiler13.types.variableDeclarator(\n              import_compiler13.types.identifier(domExports.template),\n              writes || import_compiler13.types.stringLiteral(\"\")\n            )\n          ])\n        ),\n        import_compiler13.types.exportNamedDeclaration(\n          import_compiler13.types.variableDeclaration(\"const\", [\n            import_compiler13.types.variableDeclarator(walksIdentifier, walks || import_compiler13.types.stringLiteral(\"\"))\n          ])\n        ),\n        import_compiler13.types.exportNamedDeclaration(\n          import_compiler13.types.variableDeclaration(\"const\", [\n            import_compiler13.types.variableDeclarator(\n              setupIdentifier,\n              import_compiler13.types.isNullLiteral(setup) || !setup ? import_compiler13.types.functionExpression(null, [], import_compiler13.types.blockStatement([])) : setup\n            )\n          ])\n        )\n      );\n      if (closures.length) {\n        program.node.body.push(\n          import_compiler13.types.exportNamedDeclaration(\n            import_compiler13.types.variableDeclaration(\"const\", [\n              import_compiler13.types.variableDeclarator(\n                closuresIdentifier,\n                import_compiler13.types.arrayExpression(closures)\n              )\n            ])\n          )\n        );\n      }\n      program.node.body.push(\n        import_compiler13.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            callRuntime(\n              \"createRenderer\",\n              templateIdentifier,\n              walksIdentifier,\n              setupIdentifier,\n              closures.length && closuresIdentifier,\n              void 0,\n              programParamsSignal?.identifier\n            ),\n            import_compiler13.types.stringLiteral(program.hub.file.metadata.marko.id)\n          )\n        )\n      );\n    }\n  }\n};\n\n// src/visitors/program/html.ts\nvar import_compiler14 = require(\"@marko/compiler\");\n\n// src/util/is-static.ts\nfunction isStatic(path3) {\n  return path3.isImportDeclaration() || path3.isExportDeclaration() || path3.isMarkoScriptlet({ static: true });\n}\n\n// src/visitors/program/html.ts\nvar html_default = {\n  translate: {\n    exit(program) {\n      const section = getSection(program);\n      const tagVarIdentifier = program.scope.generateUidIdentifier(\"tagVar\");\n      flushInto(program);\n      writeHTMLResumeStatements(program, tagVarIdentifier);\n      renameBindings();\n      const returnIdentifier = returnId(section);\n      if (returnIdentifier !== void 0) {\n        program.pushContainer(\"body\", import_compiler14.types.returnStatement(returnIdentifier));\n      }\n      const renderContent = [];\n      for (const child of program.get(\"body\")) {\n        if (!isStatic(child)) {\n          renderContent.push(child.node);\n          child.remove();\n        } else if (child.isMarkoScriptlet()) {\n          if (child.node.target && child.node.target !== \"server\") {\n            child.remove();\n          } else {\n            child.replaceWithMultiple(child.node.body);\n          }\n        }\n      }\n      const rendererId = program.scope.generateUidIdentifier(\"renderer\");\n      program.pushContainer(\"body\", [\n        import_compiler14.types.variableDeclaration(\"const\", [\n          import_compiler14.types.variableDeclarator(\n            rendererId,\n            callRuntime(\n              \"createRenderer\",\n              import_compiler14.types.arrowFunctionExpression(\n                [import_compiler14.types.identifier(\"input\"), tagVarIdentifier],\n                import_compiler14.types.blockStatement(renderContent)\n              )\n            )\n          )\n        ]),\n        import_compiler14.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            rendererId,\n            import_compiler14.types.stringLiteral(program.hub.file.metadata.marko.id)\n          )\n        )\n      ]);\n    }\n  }\n};\n\n// src/visitors/program/index.ts\nvar currentProgramPath;\nvar scopeIdentifier;\nvar cleanIdentifier;\nvar previousProgramPath = /* @__PURE__ */ new WeakMap();\nvar program_default = {\n  migrate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      program.node.params = [import_compiler15.types.identifier(\"input\")];\n      currentProgramPath = program;\n    },\n    exit() {\n      currentProgramPath.scope.crawl();\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  analyze: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      startSection(program);\n      trackParamsReferences(program, 2 /* input */);\n      const { scope } = program;\n      (program.node.extra ??= {}).domExports = {\n        template: scope.generateUid(\"template_\"),\n        walks: scope.generateUid(\"walks_\"),\n        setup: scope.generateUid(\"setup_\"),\n        params: void 0,\n        // TODO look into recursive components with fine grained params.\n        closures: scope.generateUid(\"closures_\")\n      };\n    },\n    exit(program) {\n      finalizeReferences();\n      const {\n        scope,\n        node: { extra }\n      } = program;\n      if (extra.binding && bindingHasDownstreamExpressions(extra.binding)) {\n        extra.domExports.params = recurseAndBuildExportTree(\n          extra.binding,\n          scope\n        );\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  translate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      scopeIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"scope\") : null;\n      cleanIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"clean\") : null;\n      if (getMarkoOpts().output === \"hydrate\") {\n        const entryFile = program.hub.file;\n        const visitedFiles = /* @__PURE__ */ new Set([\n          (0, import_babel_utils10.resolveRelativePath)(entryFile, entryFile.opts.filename)\n        ]);\n        entry_builder_default.visit(entryFile, entryFile, function visitChild(resolved) {\n          if (!visitedFiles.has(resolved)) {\n            visitedFiles.add(resolved);\n            const file = (0, import_babel_utils10.loadFileForImport)(entryFile, resolved);\n            if (file) {\n              entry_builder_default.visit(\n                file,\n                entryFile,\n                (id) => visitChild(resolveRelativeToEntry(entryFile, file, id))\n              );\n            }\n          }\n        });\n        program.node.body = entry_builder_default.build(entryFile);\n        program.skip();\n        return;\n      }\n    },\n    exit(program) {\n      if (isOutputHTML()) {\n        html_default.translate.exit(program);\n      } else {\n        dom_default.translate.exit(program);\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  }\n};\nfunction resolveRelativeToEntry(entryFile, file, req) {\n  return file === entryFile ? (0, import_babel_utils10.resolveRelativePath)(file, req) : (0, import_babel_utils10.resolveRelativePath)(\n    entryFile,\n    req[0] === \".\" ? import_path.default.join(file.opts.filename, \"..\", req) : req\n  );\n}\nfunction recurseAndBuildExportTree(binding, scope) {\n  const exportTree = {\n    id: binding.export ??= scope.generateUid(binding.name + \"_\"),\n    props: void 0\n  };\n  const { aliases, propertyAliases, downstreamExpressions } = binding;\n  if (!downstreamExpressions.size) {\n    exportTree.props = {};\n    for (const [property, alias] of propertyAliases) {\n      exportTree.props[property] = recurseAndBuildExportTree(alias, scope);\n    }\n    for (const alias of aliases) {\n      const exports2 = recurseAndBuildExportTree(alias, scope);\n      if (exports2.props) {\n        exportTree.props = { ...exportTree.props, ...exports2.props };\n      } else {\n        exportTree.props = void 0;\n        return exportTree;\n      }\n    }\n  }\n  return exportTree;\n}\n\n// src/util/get-root.ts\nfunction getMarkoRoot(path3) {\n  let curPath = path3;\n  do\n    curPath = curPath.parentPath;\n  while (curPath && !isMarko(curPath));\n  return curPath;\n}\nfunction getExprRoot(path3) {\n  let curPath = path3;\n  while (!isMarko(curPath.parentPath)) {\n    curPath = curPath.parentPath;\n    if (curPath.type === \"AssignmentExpression\") {\n      const destructRoot = getDestructureRoot(curPath);\n      if (isMarko(destructRoot.parentPath)) {\n        curPath = curPath.get(\"right\");\n        break;\n      }\n      curPath = destructRoot.parentPath;\n    }\n  }\n  return curPath;\n}\nfunction getFnRoot(path3) {\n  let curPath = path3;\n  if (curPath.isProgram()) return;\n  while (!isFunctionExpression(curPath)) {\n    if (isMarko(curPath)) return;\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction isMarko(path3) {\n  switch (path3.type) {\n    case \"MarkoTag\":\n    case \"MarkoTagBody\":\n    case \"MarkoAttribute\":\n    case \"MarkoSpreadAttribute\":\n    case \"MarkoPlaceholder\":\n    case \"MarkoScriptlet\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isFunctionExpression(path3) {\n  switch (path3.type) {\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction getDestructureRoot(path3) {\n  switch (path3.parent.type) {\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"ObjectProperty\":\n      return getDestructureRoot(path3.parentPath);\n    default:\n      return path3;\n  }\n}\n\n// src/util/references.ts\nvar [getBindings] = createProgramState(() => /* @__PURE__ */ new Set());\nvar [getNextBindingId, setNextBindingId] = createProgramState(() => 0);\nfunction createBinding(name, type, section, upstreamAlias, upstreamExpression, property) {\n  const id = getNextBindingId();\n  const binding = {\n    id,\n    name,\n    type,\n    section,\n    property,\n    excludeProperties: void 0,\n    serialize: false,\n    aliases: /* @__PURE__ */ new Set(),\n    propertyAliases: /* @__PURE__ */ new Map(),\n    upstreamAlias,\n    upstreamExpression,\n    downstreamExpressions: /* @__PURE__ */ new Set(),\n    export: void 0\n  };\n  if (property) {\n    const propBinding = upstreamAlias.propertyAliases.get(property);\n    if (propBinding) {\n      binding.property = void 0;\n      binding.upstreamAlias = propBinding;\n      propBinding.aliases.add(binding);\n    } else {\n      upstreamAlias.propertyAliases.set(property, binding);\n    }\n  } else if (upstreamAlias) {\n    upstreamAlias.aliases.add(binding);\n  }\n  setNextBindingId(id + 1);\n  getBindings().add(binding);\n  return binding;\n}\nfunction trackVarReferences(tag, type, upstreamAlias, upstreamExpression, changeBinding) {\n  const tagVar = tag.node.var;\n  if (tagVar) {\n    const section = getOrCreateSection(tag);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    upstreamAlias?.downstreamExpressions.delete(upstreamExpression);\n    createBindingsAndTrackReferences(\n      tagVar,\n      type,\n      tag.scope,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0,\n      changeBinding\n    );\n  }\n}\nfunction trackParamsReferences(body, type, upstreamAlias, upstreamExpression) {\n  const params = body.node.params;\n  if (body.get(\"body\").length && params.length) {\n    upstreamAlias?.downstreamExpressions.delete(upstreamExpression);\n    const section = getOrCreateSection(body);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    const paramsBinding = canonicalUpstreamAlias || ((body.node.extra ??= {}).binding = createBinding(\n      body.scope.generateUid(\"params_\"),\n      type,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0\n    ));\n    for (let i = 0; i < params.length; i++) {\n      createBindingsAndTrackReferences(\n        params[i],\n        type,\n        body.scope,\n        section,\n        paramsBinding,\n        void 0,\n        i + \"\"\n      );\n    }\n  }\n}\nfunction trackReferencesForBinding(babelBinding, changeBinding) {\n  const { identifier, referencePaths, constantViolations } = babelBinding;\n  const binding = identifier.extra.binding;\n  for (const referencePath of referencePaths) {\n    trackReference(referencePath, binding);\n  }\n  for (const referencePath of constantViolations) {\n    const node = referencePath.node;\n    if (import_compiler16.types.isAssignmentExpression(node)) {\n      assignBinding(node.left, binding);\n    }\n    if (import_compiler16.types.isUpdateExpression(node)) {\n      assignBinding(node.argument, binding);\n    }\n    if (import_compiler16.types.isAssignmentExpression(node) && import_compiler16.types.isIdentifier(node.left) && node.operator !== \"=\") {\n      trackReference(\n        referencePath.get(\n          \"left\"\n        ),\n        binding\n      );\n    }\n    if (changeBinding) {\n      if (referencePath.isUpdateExpression()) {\n        trackReference(\n          referencePath.get(\"argument\"),\n          changeBinding\n        );\n      } else if (referencePath.isAssignmentExpression()) {\n        trackReference(\n          referencePath.get(\"left\"),\n          changeBinding\n        );\n      }\n    }\n  }\n}\nfunction assignBinding(node, binding) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        assignBinding(prop, binding);\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const element of node.elements) {\n        if (element !== null) {\n          assignBinding(element, binding);\n        }\n      }\n      break;\n    case \"RestElement\":\n      assignBinding(node.argument, binding);\n      break;\n    case \"ObjectProperty\":\n      assignBinding(node.value, binding);\n      break;\n    case \"Identifier\":\n      if (node.name === binding.name) {\n        (node.extra ??= {}).source = binding;\n      }\n      break;\n  }\n}\nfunction createBindingsAndTrackReferences(lVal, type, scope, section, upstreamAlias, upstreamExpression, property, changeBinding) {\n  switch (lVal.type) {\n    case \"Identifier\":\n      (lVal.extra ??= {}).binding = createBinding(\n        lVal.name,\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      );\n      trackReferencesForBinding(scope.getBinding(lVal.name), changeBinding);\n      break;\n    case \"ObjectPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        scope.generateUid(\"pattern_\"),\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      ));\n      for (const prop of lVal.properties) {\n        if (prop.type === \"RestElement\") {\n          createBindingsAndTrackReferences(\n            prop.argument,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            property\n          );\n        } else {\n          let key;\n          if (prop.key.type === \"Identifier\") {\n            key = prop.key.name;\n          } else if (prop.key.type === \"StringLiteral\") {\n            key = prop.key.value;\n          } else {\n            throw new Error(\"computed keys not supported in object pattern\");\n          }\n          createBindingsAndTrackReferences(\n            prop.value,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            key\n          );\n        }\n      }\n      break;\n    }\n    case \"ArrayPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        scope.generateUid(\"pattern_\"),\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      ));\n      let i = -1;\n      for (const element of lVal.elements) {\n        i++;\n        if (element) {\n          if (element.type === \"RestElement\") {\n            createBindingsAndTrackReferences(\n              element.argument,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              property\n            );\n          } else {\n            createBindingsAndTrackReferences(\n              element,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              `${i}`\n            );\n          }\n        }\n      }\n      break;\n    }\n    case \"AssignmentPattern\":\n      createBindingsAndTrackReferences(\n        lVal.left,\n        type,\n        scope,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      );\n      break;\n  }\n}\nfunction trackReference(referencePath, binding) {\n  const fnRoot = getFnRoot(referencePath.scope.path);\n  const exprRoot = getExprRoot(fnRoot || referencePath);\n  const section = getOrCreateSection(exprRoot);\n  const reference = binding;\n  const exprExtra = exprRoot.node.extra ??= {};\n  addReferenceToExpression(exprRoot, binding);\n  assignBinding(referencePath.node, binding);\n  if (fnRoot) {\n    let fnExtra = exprExtra;\n    if (fnRoot !== exprRoot) {\n      fnExtra = fnRoot.node.extra ??= {};\n      fnExtra.referencedBindings = addReference(\n        section,\n        fnExtra.referencedBindings,\n        reference\n      );\n    }\n  }\n}\nvar [getMergedReferences] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction mergeReferences(target, nodes) {\n  getMergedReferences().set(target, nodes);\n}\nfunction compareIntersections(a, b) {\n  const len = a.length;\n  const lenDelta = len - b.length;\n  if (lenDelta !== 0) {\n    return lenDelta;\n  }\n  for (let i = 0; i < len; i++) {\n    const compareResult = bindingUtil.compare(a[i], b[i]);\n    if (compareResult !== 0) {\n      return compareResult;\n    }\n  }\n  return 0;\n}\nfunction finalizeReferences() {\n  const mergedReferences = getMergedReferences();\n  if (mergedReferences.size) {\n    for (const [target, nodes] of mergedReferences) {\n      const targetExtra = target.node.extra ??= {};\n      let { referencedBindings, isEffect } = targetExtra;\n      for (const node of nodes) {\n        const extra = node?.extra;\n        if (extra) {\n          const additionalBindings = extra.referencedBindings;\n          isEffect ||= extra.isEffect;\n          if (additionalBindings) {\n            referencedBindings = bindingUtil.union(\n              referencedBindings,\n              additionalBindings\n            );\n            forEach(additionalBindings, ({ downstreamExpressions }) => {\n              downstreamExpressions.delete(extra);\n              downstreamExpressions.add(targetExtra);\n            });\n          }\n        }\n      }\n      referencedBindings = findReferences(\n        getOrCreateSection(target),\n        referencedBindings\n      );\n      targetExtra.referencedBindings = referencedBindings;\n      targetExtra.isEffect = isEffect;\n    }\n    mergedReferences.clear();\n  }\n  const bindings = getBindings();\n  for (const binding of bindings) {\n    if (binding.type !== 0 /* dom */ && !binding.upstreamAlias) {\n      if (pruneBinding(bindings, binding)) {\n        const { upstreamExpression } = binding;\n        if (upstreamExpression) {\n          forEach(\n            upstreamExpression.referencedBindings,\n            (referencedBinding) => {\n              referencedBinding.downstreamExpressions.delete(\n                upstreamExpression\n              );\n              pruneBinding(bindings, referencedBinding);\n            }\n          );\n        }\n      }\n    }\n  }\n  const intersections = /* @__PURE__ */ new Set();\n  for (const binding of bindings) {\n    const { name, section } = binding;\n    if (binding.type !== 0 /* dom */) {\n      for (const existingBinding of section.bindings) {\n        if (existingBinding.name === binding.name) {\n          binding.name = currentProgramPath.scope.generateUid(name);\n          break;\n        }\n      }\n    }\n    section.bindings.add(binding);\n    for (const {\n      referencedBindings,\n      isEffect\n    } of binding.downstreamExpressions) {\n      if (Array.isArray(referencedBindings)) {\n        intersections.add(referencedBindings);\n      }\n      forEach(referencedBindings, (bindingReference) => {\n        if (isEffect) {\n          bindingReference.serialize = true;\n        }\n      });\n    }\n  }\n  for (const intersection of intersections) {\n    const numReferences = intersection.length;\n    for (let i = 0; i < numReferences - 1; i++) {\n      for (let j = i + 1; j < numReferences; j++) {\n        const binding1 = intersection[i];\n        const binding2 = intersection[j];\n        const sources1 = getSourceBindings(binding1);\n        const sources2 = getSourceBindings(binding2);\n        if (!binding1.serialize && !isSuperset(sources1, sources2)) {\n          binding1.serialize = true;\n        }\n        if (!binding2.serialize && !isSuperset(sources2, sources1)) {\n          binding2.serialize = true;\n        }\n      }\n    }\n  }\n  forEachSection((section) => {\n    for (const binding of section.closures) {\n      if (!binding.serialize) {\n        let serialize = false;\n        const sourceSection = binding.section;\n        let currentSection = section;\n        while (currentSection !== sourceSection && !(serialize = !currentSection.upstreamExpression || isStatefulReferences(\n          currentSection.upstreamExpression.referencedBindings\n        ))) {\n          currentSection = currentSection.parent;\n        }\n        binding.serialize = serialize;\n      }\n    }\n  });\n  forEachSection(({ id, bindings: bindings2 }) => {\n    const sortedBindings = [...bindings2].filter((b) => b.section.id === id).sort(bindingUtil.compare);\n    for (let i = sortedBindings.length; i--; ) {\n      const binding = sortedBindings[i];\n      binding.id = i;\n    }\n  });\n}\nfunction isSuperset(set, subset) {\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getSourceBindings(binding) {\n  const derived = /* @__PURE__ */ new Set();\n  const sources = /* @__PURE__ */ new Set();\n  crawl(binding);\n  return sources;\n  function crawl(binding2) {\n    if (binding2.type === 4 /* derived */ || binding2.type === 3 /* param */) {\n      let alias;\n      let curBinding = binding2;\n      while (alias = curBinding.upstreamAlias) {\n        curBinding = alias;\n      }\n      if (curBinding.upstreamExpression) {\n        if (derived.has(curBinding)) return;\n        derived.add(curBinding);\n        forEach(curBinding.upstreamExpression.referencedBindings, crawl);\n      } else {\n        sources.add(curBinding);\n      }\n    } else {\n      sources.add(binding2);\n    }\n  }\n}\nvar bindingUtil = new Sorted(function compareBindings(a, b) {\n  return a.section.id - b.section.id || a.type !== b.type && (a.type === 0 /* dom */ || b.type === 0 /* dom */) ? a.type - b.type : a.id - b.id;\n});\nvar [getIntersections, setIntersections] = createSectionState(\n  \"intersections\",\n  () => []\n);\nfunction addReferenceToExpression(path3, binding) {\n  const exprExtra = path3.node.extra ??= {};\n  const section = getOrCreateSection(path3);\n  exprExtra.referencedBindings = addReference(\n    section,\n    exprExtra.referencedBindings,\n    binding\n  );\n  binding.downstreamExpressions.add(exprExtra);\n}\nfunction getCanonicalBinding(binding) {\n  return binding && (binding.property ? binding : binding.upstreamAlias || binding);\n}\nfunction addReference(section, referencedBindings, binding) {\n  if (section !== binding.section) {\n    section.closures.add(binding);\n  }\n  const newIntersection = bindingUtil.add(referencedBindings, binding);\n  return findReferences(section, newIntersection);\n}\nfunction findReferences(section, referencedBindings) {\n  if (!referencedBindings || !Array.isArray(referencedBindings)) {\n    return referencedBindings;\n  }\n  const intersections = getIntersections(section);\n  let intersection = findSorted(\n    compareIntersections,\n    intersections,\n    referencedBindings\n  );\n  if (!intersection) {\n    setIntersections(\n      section,\n      addSorted(compareIntersections, intersections, referencedBindings)\n    );\n    intersection = referencedBindings;\n  }\n  return intersection;\n}\nfunction getScopeAccessorLiteral(binding) {\n  if (isOptimize()) {\n    return import_compiler16.types.numericLiteral(binding.id);\n  }\n  return import_compiler16.types.stringLiteral(\n    binding.name + (binding.type === 0 /* dom */ ? `/${binding.id}` : \"\")\n  );\n}\nfunction pruneBinding(bindings, binding) {\n  let shouldPrune = !binding.downstreamExpressions.size;\n  for (const alias of binding.aliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.aliases.delete(alias);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  for (const [key, alias] of binding.propertyAliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.propertyAliases.delete(key);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  if (shouldPrune) {\n    bindings.delete(binding);\n  }\n  return shouldPrune;\n}\n\n// src/util/is-stateful.ts\nfunction isStatefulReferences(referencedBindings) {\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        if (isStatefulBinding(ref)) {\n          return true;\n        }\n      }\n    } else {\n      return isStatefulBinding(referencedBindings);\n    }\n  }\n  return false;\n}\nfunction isStatefulBinding(binding) {\n  switch (binding.type) {\n    case 1 /* let */:\n    case 2 /* input */:\n      return true;\n    default:\n      return !binding.upstreamExpression || isStatefulReferences(binding.upstreamExpression.referencedBindings);\n  }\n}\n\n// src/util/to-first-statement-or-block.ts\nvar import_compiler17 = require(\"@marko/compiler\");\nfunction toFirstStatementOrBlock(body) {\n  const nodes = body.body;\n  if (nodes.length === 1) {\n    return nodes[0];\n  }\n  if (import_compiler17.types.isBlockStatement(body)) {\n    return body;\n  }\n  return import_compiler17.types.blockStatement(nodes);\n}\n\n// src/core/condition/if.ts\nvar kBinding = Symbol(\"if node binding\");\nvar if_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const [testAttr] = node.attributes;\n    (0, import_babel_utils11.assertNoArgs)(tag);\n    (0, import_babel_utils11.assertNoVar)(tag);\n    (0, import_babel_utils11.assertNoParams)(tag);\n    if (!import_compiler18.types.isMarkoAttribute(testAttr) || !testAttr.default) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `if` tag requires a value.\");\n    }\n    if (node.body.body.length === 0) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `if` tag requires body content.\");\n    }\n    if (node.attributes.length > 1) {\n      const start = node.attributes[1].loc?.start;\n      const end = node.attributes[node.attributes.length - 1].loc?.end;\n      const msg = \"The `if` tag only supports the `value` attribute.\";\n      if (start == null || end == null) {\n        throw tag.get(\"name\").buildCodeFrameError(msg);\n      } else {\n        throw tag.hub.buildError(\n          { loc: { start, end } },\n          msg,\n          Error\n        );\n      }\n    }\n    const tagBody = tag.get(\"body\");\n    const section = getOrCreateSection(tag);\n    const tagExtra = tag.node.extra ??= {};\n    startSection(tagBody);\n    tagExtra[kBinding] = createBinding(\n      \"#text\",\n      0 /* dom */,\n      section,\n      void 0,\n      tagExtra\n    );\n    analyze(tag);\n  },\n  translate: {\n    enter(tag) {\n      visit(tag, 37 /* Replace */);\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n      translate.enter(tag);\n    },\n    exit(tag) {\n      translate.exit(tag);\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      snippet: \"if=${1:condition}\",\n      description: \"Use to display content only if the condition is met.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar BRANCHES_LOOKUP = /* @__PURE__ */ new WeakMap();\nfunction getBranches(tag, bodySection) {\n  const branches = BRANCHES_LOOKUP.get(tag) ?? [];\n  const nextTag = tag.getNextSibling();\n  const isLast = !(isCoreTagName(nextTag, \"else\") || isCoreTagName(nextTag, \"else-if\"));\n  branches.push({\n    tag,\n    section: bodySection\n  });\n  if (!isLast) {\n    BRANCHES_LOOKUP.set(nextTag, branches);\n  }\n  return [isLast, branches];\n}\nfunction getRoot(tag) {\n  if (isCoreTagName(tag, \"if\")) {\n    return tag;\n  }\n  return BRANCHES_LOOKUP.get(tag)[0].tag;\n}\nfunction analyze(tag) {\n  const tagBody = tag.get(\"body\");\n  const bodySection = getOrCreateSection(tagBody);\n  const [isLast, branches] = getBranches(tag, bodySection);\n  if (isLast) {\n    const rootTag = branches[0].tag;\n    const rootExtra = rootTag.node.extra;\n    mergeReferences(\n      rootTag,\n      branches.map(({ tag: tag2 }) => tag2.node.attributes[0]?.value)\n    );\n    rootExtra.singleNodeOptimization = branches.every(({ tag: tag2 }) => {\n      return tag2.node.body.body.length === 1;\n    });\n    branches.forEach(({ section }) => {\n      section.upstreamExpression = rootExtra;\n    });\n  }\n}\nvar translate = {\n  enter(tag) {\n    const tagBody = tag.get(\"body\");\n    const bodySection = getSection(tagBody);\n    const rootExtra = getRoot(tag).node.extra;\n    const isStateful = isStatefulReferences(rootExtra.referencedBindings);\n    const singleNodeOptimization = rootExtra.singleNodeOptimization;\n    if (isOutputHTML() && isStateful && !singleNodeOptimization) {\n      writeTo(tagBody)`${callRuntime(\n        \"markResumeScopeStart\",\n        getScopeIdIdentifier(bodySection)\n      )}`;\n    }\n  },\n  exit(tag) {\n    const tagBody = tag.get(\"body\");\n    const section = getSection(tag);\n    const bodySection = getSection(tagBody);\n    const [isLast, branches] = getBranches(tag, bodySection);\n    const rootExtra = branches[0].tag.node.extra;\n    const nodeRef = rootExtra[kBinding];\n    const isStateful = isStatefulReferences(rootExtra.referencedBindings);\n    const singleNodeOptimization = rootExtra.singleNodeOptimization;\n    const hasStatefulClosures = checkStatefulClosures(bodySection, true);\n    if (isOutputHTML()) {\n      if (isStateful || hasStatefulClosures) {\n        setForceResumeScope(bodySection);\n      }\n      flushInto(tag);\n      setSubscriberBuilder(tag, () => {\n      });\n      writeHTMLResumeStatements(tagBody);\n    }\n    if (isLast) {\n      const extra = branches[0].tag.node.extra;\n      if (isOutputDOM()) {\n        let expr = import_compiler18.types.nullLiteral();\n        for (let i = branches.length; i--; ) {\n          const { tag: tag2, section: section2 } = branches[i];\n          const [testAttr] = tag2.node.attributes;\n          const id = import_compiler18.types.identifier(section2.name);\n          setSubscriberBuilder(tag2, (subscriber) => {\n            return callRuntime(\n              \"inConditionalScope\",\n              subscriber,\n              getScopeAccessorLiteral(nodeRef)\n              /*t.identifier(section.name)*/\n            );\n          });\n          tag2.remove();\n          if (testAttr) {\n            expr = import_compiler18.types.conditionalExpression(testAttr.value, id, expr);\n          } else {\n            expr = id;\n          }\n        }\n        const signal = getSignal(section, nodeRef, \"if\");\n        signal.build = () => {\n          return callRuntime(\n            \"conditional\",\n            getScopeAccessorLiteral(nodeRef),\n            getSignalFn(signal, [scopeIdentifier])\n          );\n        };\n        signal.hasDownstreamIntersections = () => branches.some((b) => getClosures(b.section).length > 0);\n        addValue(section, extra.referencedBindings, signal, expr);\n      } else {\n        const write2 = writeTo(tag);\n        const nextTag = tag.getNextSibling();\n        const ifScopeIdIdentifier = tag.scope.generateUidIdentifier(\"ifScopeId\");\n        const ifRendererIdentifier = tag.scope.generateUidIdentifier(\"ifRenderer\");\n        let statement;\n        for (let i = branches.length; i--; ) {\n          const { tag: tag2, section: section2 } = branches[i];\n          const branchHasStatefulClosures = checkStatefulClosures(\n            section2,\n            true\n          );\n          if (isStateful) {\n            tag2.node.body.body.push(\n              import_compiler18.types.expressionStatement(\n                callRuntime(\n                  \"register\",\n                  import_compiler18.types.assignmentExpression(\n                    \"=\",\n                    ifRendererIdentifier,\n                    callRuntime(\n                      \"createRenderer\",\n                      import_compiler18.types.arrowFunctionExpression([], import_compiler18.types.blockStatement([]))\n                    )\n                  ),\n                  import_compiler18.types.stringLiteral(getResumeRegisterId(section2, \"renderer\")),\n                  section2.closures.size && getScopeIdIdentifier(section2.parent)\n                )\n              )\n            );\n          }\n          if (isStateful || branchHasStatefulClosures) {\n            tag2.node.body.body.push(\n              import_compiler18.types.expressionStatement(\n                import_compiler18.types.assignmentExpression(\n                  \"=\",\n                  ifScopeIdIdentifier,\n                  getScopeIdIdentifier(section2)\n                )\n              )\n            );\n          }\n          const [testAttr] = tag2.node.attributes;\n          const curStatement = toFirstStatementOrBlock(tag2.node.body);\n          if (testAttr) {\n            statement = import_compiler18.types.ifStatement(testAttr.value, curStatement, statement);\n          } else {\n            statement = curStatement;\n          }\n          tag2.remove();\n        }\n        if (!isStateful && !hasStatefulClosures) {\n          nextTag.insertBefore(statement);\n        } else {\n          nextTag.insertBefore([\n            import_compiler18.types.variableDeclaration(\n              \"let\",\n              [\n                import_compiler18.types.variableDeclarator(ifScopeIdIdentifier),\n                isStateful && import_compiler18.types.variableDeclarator(ifRendererIdentifier)\n              ].filter(Boolean)\n            ),\n            statement\n          ]);\n          if (isStateful) {\n            if (singleNodeOptimization) {\n              write2`${callRuntime(\n                \"markResumeControlSingleNodeEnd\",\n                getScopeIdIdentifier(section),\n                getScopeAccessorLiteral(nodeRef),\n                ifScopeIdIdentifier\n              )}`;\n            } else {\n              write2`${callRuntime(\n                \"markResumeControlEnd\",\n                getScopeIdIdentifier(section),\n                getScopeAccessorLiteral(nodeRef)\n              )}`;\n            }\n            getSerializedScopeProperties(section).set(\n              import_compiler18.types.stringLiteral(\n                getScopeAccessorLiteral(nodeRef).value + \"(\" /* ConditionalRenderer */\n              ),\n              ifRendererIdentifier\n            );\n          }\n          getSerializedScopeProperties(section).set(\n            import_compiler18.types.stringLiteral(\n              getScopeAccessorLiteral(nodeRef).value + \"!\" /* ConditionalScope */\n            ),\n            callRuntime(\"getScopeById\", ifScopeIdIdentifier)\n          );\n        }\n      }\n    }\n  }\n};\n\n// src/core/condition/else.ts\nvar else_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const [testAttr] = node.attributes;\n    (0, import_babel_utils12.assertNoVar)(tag);\n    (0, import_babel_utils12.assertNoArgs)(tag);\n    (0, import_babel_utils12.assertNoParams)(tag);\n    if (node.body.body.length === 0) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `else` tag requires body content.\");\n    }\n    if (node.attributes.length > 1 || testAttr && testAttr.name !== \"if\") {\n      const start = node.attributes[1].loc?.start;\n      const end = node.attributes[node.attributes.length - 1].loc?.end;\n      const msg = \"The `else` tag only supports an `if=` attribute.\";\n      if (start == null || end == null) {\n        throw tag.get(\"name\").buildCodeFrameError(msg);\n      } else {\n        throw tag.hub.buildError(\n          { loc: { start, end } },\n          msg,\n          Error\n        );\n      }\n    }\n    analyze(tag);\n  },\n  translate,\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\n\n// src/core/condition/else-if.ts\nvar import_babel_utils13 = require(\"@marko/babel-utils\");\nvar import_compiler19 = require(\"@marko/compiler\");\nvar else_if_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    (0, import_babel_utils13.assertNoArgs)(tag);\n    (0, import_babel_utils13.assertNoVar)(tag);\n    (0, import_babel_utils13.assertNoParams)(tag);\n    if (!import_compiler19.types.isMarkoAttribute(valueAttr) || !valueAttr.default) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `else-if` tag requires a value.\");\n    }\n    if (node.body.body.length === 0) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `else-if` tag requires body content.\");\n    }\n    if (node.attributes.length > 1) {\n      const start = node.attributes[1].loc?.start;\n      const end = node.attributes[node.attributes.length - 1].loc?.end;\n      const msg = \"The `else-if` tag only supports the `value` attribute.\";\n      if (start == null || end == null) {\n        throw tag.get(\"name\").buildCodeFrameError(msg);\n      } else {\n        throw tag.hub.buildError(\n          { loc: { start, end } },\n          msg,\n          Error\n        );\n      }\n    }\n    analyze(tag);\n  },\n  translate,\n  attributes: {},\n  autocomplete: [\n    {\n      snippet: \"else-if=${1:condition}\",\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\n\n// src/core/const.ts\nvar import_babel_utils14 = require(\"@marko/babel-utils\");\nvar import_compiler21 = require(\"@marko/compiler\");\n\n// src/util/translate-var.ts\nvar import_compiler20 = require(\"@marko/compiler\");\nfunction translateVar(tag, initialValue, kind = \"const\") {\n  const {\n    node: { var: tagVar }\n  } = tag;\n  if (!tagVar) {\n    return;\n  }\n  tag.insertBefore(\n    import_compiler20.types.variableDeclaration(kind, [import_compiler20.types.variableDeclarator(tagVar, initialValue)])\n  );\n}\n\n// src/core/const.ts\nvar const_default = {\n  analyze(tag) {\n    (0, import_babel_utils14.assertNoArgs)(tag);\n    (0, import_babel_utils14.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a tag variable.\");\n    }\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler21.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `const` tag only supports the `value` attribute.\"\n      );\n    }\n    const upstreamAlias = import_compiler21.types.isIdentifier(valueAttr.value) ? tag.scope.getBinding(valueAttr.value.name)?.identifier.extra?.binding : void 0;\n    trackVarReferences(\n      tag,\n      4 /* derived */,\n      upstreamAlias,\n      valueAttr.value.extra ??= {}\n    );\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      const { value } = valueAttr;\n      if (isOutputDOM()) {\n        const section = getSection(tag);\n        const varBinding = node.var.extra?.binding;\n        if (varBinding && !varBinding.upstreamAlias) {\n          const derivation = initValue(varBinding);\n          addValue(section, value.extra?.referencedBindings, derivation, value);\n        }\n      } else {\n        translateVar(tag, value);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an constant binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#const\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/const.d.marko\"\n};\n\n// src/core/debug.ts\nvar import_babel_utils15 = require(\"@marko/babel-utils\");\nvar import_compiler22 = require(\"@marko/compiler\");\nvar debug_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils15.assertNoVar)(tag);\n    (0, import_babel_utils15.assertNoArgs)(tag);\n    (0, import_babel_utils15.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (tag.node.attributes.length > 1 || tag.node.attributes.length === 1 && (!import_compiler22.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\")) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `debug` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const referencedBindings = valueAttr?.value.extra?.referencedBindings;\n      const statement = import_compiler22.types.debuggerStatement();\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Debug on value change.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#debug\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/debug.d.marko\"\n};\n\n// src/core/define.ts\nvar import_babel_utils16 = require(\"@marko/babel-utils\");\nvar import_compiler25 = require(\"@marko/compiler\");\n\n// src/util/attrs-to-object.ts\nvar import_compiler24 = require(\"@marko/compiler\");\n\n// src/util/to-property-name.ts\nvar import_compiler23 = require(\"@marko/compiler\");\nvar IDENTIFIER_REG = /^[0-9A-Z_$]+$/i;\nfunction toPropertyName(name) {\n  return IDENTIFIER_REG.test(name) ? import_compiler23.types.identifier(name) : import_compiler23.types.stringLiteral(name);\n}\n\n// src/util/attrs-to-object.ts\nvar renderBodyProps = /* @__PURE__ */ new WeakMap();\nfunction attrsToObject(tag, withRenderBody = false) {\n  const { node } = tag;\n  let result = import_compiler24.types.objectExpression([]);\n  const resultExtra = result.extra = {};\n  for (const attr2 of tag.get(\"attributes\")) {\n    const value = attr2.node.value;\n    if (attr2.isMarkoSpreadAttribute()) {\n      result.properties.push(import_compiler24.types.spreadElement(value));\n    } else {\n      result.properties.push(\n        import_compiler24.types.objectProperty(\n          toPropertyName(attr2.node.name),\n          value\n        )\n      );\n    }\n  }\n  if (withRenderBody) {\n    const { body, params } = node.body;\n    let hoistedControlFlows = node.extra.hoistedControlFlows;\n    if (hoistedControlFlows) {\n      for (const child of tag.get(\"body\").get(\"body\")) {\n        tag.insertBefore(child.node);\n        child.remove();\n        if (child.isConditional() || child.isLoop()) {\n          if (!--hoistedControlFlows) {\n            break;\n          }\n        }\n      }\n    }\n    if (body.length) {\n      const renderBodySection = getSection(tag.get(\"body\"));\n      const renderBodyExpression = import_compiler24.types.arrowFunctionExpression(\n        params,\n        import_compiler24.types.blockStatement(body)\n      );\n      renderBodyProps.set(result, renderBodyExpression);\n      if (isOutputHTML()) {\n        result.properties.push(\n          import_compiler24.types.objectProperty(\n            import_compiler24.types.identifier(\"renderBody\"),\n            callRuntime(\n              \"register\",\n              callRuntime(\"createRenderer\", renderBodyExpression),\n              import_compiler24.types.stringLiteral(\n                getResumeRegisterId(renderBodySection, \"renderer\")\n              ),\n              renderBodySection.closures.size && getScopeIdIdentifier(renderBodySection.parent)\n            )\n          )\n        );\n      } else {\n        result.properties.push(\n          import_compiler24.types.objectProperty(import_compiler24.types.identifier(\"renderBody\"), renderBodyExpression)\n        );\n      }\n    }\n  }\n  if (result.properties.length) {\n    if (result.properties.length === 1) {\n      const [prop] = result.properties;\n      if (import_compiler24.types.isSpreadElement(prop)) {\n        result = prop.argument;\n        result.extra = resultExtra;\n      }\n    }\n  }\n  if (node.arguments?.length) {\n    if (result.properties.length) {\n      result = import_compiler24.types.arrayExpression([...node.arguments, result]);\n    } else if (node.arguments.length == 1) {\n      const arg = node.arguments[0];\n      result = import_compiler24.types.isSpreadElement(arg) ? arg.argument : arg;\n    } else {\n      result = import_compiler24.types.arrayExpression(node.arguments);\n    }\n  }\n  return result;\n}\nfunction getRenderBodyProp(attrsObject) {\n  if (import_compiler24.types.isObjectExpression(attrsObject)) {\n    const lastProp = attrsObject.properties[attrsObject.properties.length - 1];\n    if (import_compiler24.types.isObjectProperty(lastProp) && lastProp.key.name === \"renderBody\") {\n      return renderBodyProps.get(attrsObject);\n    }\n  }\n}\n\n// src/core/define.ts\nvar define_default = {\n  analyze(tag) {\n    (0, import_babel_utils16.assertNoArgs)(tag);\n    if (!tag.node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `define` tag requires a tag variable.\");\n    }\n    const tagBody = tag.get(\"body\");\n    startSection(tagBody);\n    trackVarReferences(tag, 4 /* derived */);\n    trackParamsReferences(tagBody, 3 /* param */);\n    mergeReferences(\n      tag,\n      tag.node.attributes.map((attr2) => attr2.value)\n    );\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        const attrs2 = attrsToObject(tag, true);\n        translateVar(tag, attrs2);\n      } else {\n        const section = getSection(tag);\n        const tagBody = tag.get(\"body\");\n        const tagBodySection = getSection(tagBody);\n        const referencedBindings = node.extra?.referencedBindings;\n        const derivation = initValue(tag.get(\"var\").node.extra.binding);\n        let attrsObject = attrsToObject(tag);\n        if (tagBodySection !== section) {\n          attrsObject ??= import_compiler25.types.objectExpression([]);\n          attrsObject.properties.push(\n            import_compiler25.types.objectProperty(\n              import_compiler25.types.identifier(\"renderBody\"),\n              callRuntime(\n                \"bindRenderer\",\n                scopeIdentifier,\n                import_compiler25.types.identifier(tagBodySection.name)\n              )\n            )\n          );\n        }\n        addValue(section, referencedBindings, derivation, attrsObject);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a constant object binding that can be rendered.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#define\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/define.d.marko\"\n};\n\n// src/core/do.ts\nvar import_babel_utils17 = require(\"@marko/babel-utils\");\nvar import_compiler26 = require(\"@marko/compiler\");\nvar do_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils17.assertNoArgs)(tag);\n    (0, import_babel_utils17.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils17.assertNoVar)(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `do` tag requires a value.\");\n    }\n    if (tag.node.attributes.length > 1 || !import_compiler26.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `do` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      let statement = null;\n      if (import_compiler26.types.isFunctionExpression(value) || import_compiler26.types.isArrowFunctionExpression(value)) {\n        if (import_compiler26.types.isBlockStatement(value.body)) {\n          let hasDeclaration = false;\n          for (const child of value.body.body) {\n            if (import_compiler26.types.isDeclaration(child)) {\n              hasDeclaration = true;\n              break;\n            }\n          }\n          statement = hasDeclaration ? value.body : value.body.body;\n        } else {\n          statement = import_compiler26.types.expressionStatement(value.body);\n        }\n      }\n      if (isOutputHTML()) {\n        if (statement) {\n          tag.insertBefore(statement);\n        } else {\n          tag.insertBefore(import_compiler26.types.expressionStatement(import_compiler26.types.callExpression(value, [])));\n        }\n      } else {\n        addStatement(\n          \"render\",\n          section,\n          referencedBindings,\n          statement ?? import_compiler26.types.expressionStatement(import_compiler26.types.callExpression(value, [scopeIdentifier]))\n        );\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to run a function on render.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#do\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/do.d.marko\"\n};\n\n// src/core/effect.ts\nvar import_babel_utils18 = require(\"@marko/babel-utils\");\nvar import_compiler27 = require(\"@marko/compiler\");\nvar effect_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    (0, import_babel_utils18.assertNoArgs)(tag);\n    (0, import_babel_utils18.assertNoVar)(tag);\n    (0, import_babel_utils18.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `effect` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler27.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `effect` tag only supports the `value` attribute.\"\n      );\n    }\n    (valueAttr.value.extra ??= {}).isEffect = true;\n    (currentProgramPath.node.extra ??= {}).isInteractive = true;\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      const section = getSection(tag);\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      if (isOutputDOM()) {\n        const { value: value2 } = valueAttr;\n        let inlineBody = null;\n        if (import_compiler27.types.isFunctionExpression(value2) || import_compiler27.types.isArrowFunctionExpression(value2)) {\n          if (import_compiler27.types.isBlockStatement(value2.body)) {\n            let hasDeclaration = false;\n            for (const child of value2.body.body) {\n              if (import_compiler27.types.isDeclaration(child)) {\n                hasDeclaration = true;\n                break;\n              }\n            }\n            inlineBody = hasDeclaration ? value2.body : value2.body.body;\n          } else {\n            inlineBody = import_compiler27.types.expressionStatement(value2.body);\n          }\n        }\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          inlineBody || import_compiler27.types.expressionStatement(import_compiler27.types.callExpression(value2, [scopeIdentifier])),\n          value2,\n          !!inlineBody\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/effect.d.marko\"\n};\n\n// src/core/export.ts\nvar import_babel_utils19 = require(\"@marko/babel-utils\");\nvar export_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils19.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"export <value>\"\n    }\n  ]\n};\n\n// src/core/for.ts\nvar import_babel_utils23 = require(\"@marko/babel-utils\");\nvar import_compiler29 = require(\"@marko/compiler\");\n\n// src/util/nested-attribute-tags.ts\nvar import_babel_utils20 = require(\"@marko/babel-utils\");\nfunction analyzeAttributeTags(tag) {\n  const extra = tag.node.extra ??= {};\n  extra.nestedAttributeTags = {};\n  extra.hoistedControlFlows = 0;\n  analyzeChildren(extra, false, false, tag);\n}\nfunction analyzeChildren(rootExtra, repeated, dynamic, tag) {\n  let hasAttributeTags = false;\n  for (const child of tag.get(\"body\").get(\"body\")) {\n    if (child.isMarkoTag()) {\n      if (analyzeChild(rootExtra, repeated, dynamic, child)) {\n        hasAttributeTags = true;\n      }\n    }\n  }\n  return hasAttributeTags;\n}\nfunction analyzeChild(rootExtra, repeated, dynamic, tag) {\n  if ((0, import_babel_utils20.isTransparentTag)(tag)) {\n    if (analyzeChildren(rootExtra, repeated || (0, import_babel_utils20.isLoopTag)(tag), true, tag)) {\n      if (!(0, import_babel_utils20.isTransparentTag)(tag.parentPath.parentPath)) {\n        rootExtra.hoistedControlFlows++;\n      }\n      return true;\n    }\n  } else if ((0, import_babel_utils20.isAttributeTag)(tag)) {\n    const attrName = tag.node.name.value.slice(1);\n    const lookup = rootExtra.nestedAttributeTags;\n    const existing = lookup[attrName];\n    const info = existing || (lookup[attrName] = {\n      dynamic: false,\n      repeated: false\n    });\n    info.dynamic ||= dynamic;\n    info.repeated ||= repeated || existing !== void 0;\n    return true;\n  }\n  return false;\n}\n\n// src/visitors/tag/native-tag.ts\nvar import_babel_utils22 = require(\"@marko/babel-utils\");\nvar import_compiler28 = require(\"@marko/compiler\");\n\n// src/util/evaluate.ts\nvar import_babel_utils21 = require(\"@marko/babel-utils\");\nfunction evaluate(path3) {\n  let { extra } = path3.node;\n  if (!extra) {\n    extra = path3.node.extra = {};\n  }\n  if (extra.confident === void 0) {\n    const computed = (0, import_babel_utils21.computeNode)(path3.node.value);\n    if (computed) {\n      extra.computed = computed.value;\n      extra.confident = true;\n    } else {\n      extra.computed = void 0;\n      extra.confident = false;\n    }\n  }\n  return extra;\n}\n\n// src/visitors/tag/native-tag.ts\nvar kNativeTagBinding = Symbol(\"native tag binding\");\nvar kSerializeMarker = Symbol(\"serialize marker\");\nvar native_tag_default = {\n  analyze: {\n    enter(tag) {\n      const { node } = tag;\n      const attrs2 = tag.get(\"attributes\");\n      let hasEventHandlers = false;\n      let hasDynamicAttributes = false;\n      for (const attr2 of attrs2) {\n        if (isSpreadAttr(attr2)) {\n          (attr2.node.value.extra ??= {}).isEffect = true;\n          hasEventHandlers = true;\n          hasDynamicAttributes = true;\n          mergeReferences(\n            tag,\n            attrs2.map((attr3) => attr3.node.value)\n          );\n        } else if (isEventHandler(attr2.node.name)) {\n          (attr2.node.value.extra ??= {}).isEffect = true;\n          hasEventHandlers = true;\n        } else if (!evaluate(attr2).confident) {\n          hasDynamicAttributes = true;\n        }\n      }\n      if (tag.has(\"var\") || hasEventHandlers || hasDynamicAttributes) {\n        currentProgramPath.node.extra.isInteractive ||= hasEventHandlers;\n        const section = getOrCreateSection(tag);\n        const tagName = node.name.type === \"StringLiteral\" ? node.name.value : import_compiler28.types.toIdentifier(tag.get(\"name\"));\n        const tagExtra = node.extra ??= {};\n        tagExtra[kSerializeMarker] = tag.has(\"var\") || hasEventHandlers;\n        tagExtra[kNativeTagBinding] = createBinding(\n          \"#\" + tagName,\n          0 /* dom */,\n          section\n        );\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      (0, import_babel_utils22.assertNoArgs)(tag);\n      const extra = tag.node.extra;\n      const nodeRef = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const name = tag.get(\"name\");\n      const attrs2 = tag.get(\"attributes\");\n      const tagDef = (0, import_babel_utils22.getTagDef)(tag);\n      const hasSpread = attrs2.some((attr2) => attr2.isMarkoSpreadAttribute());\n      const write2 = writeTo(tag);\n      const section = getSection(tag);\n      if (isHTML && extra.tagNameNullable) {\n        flushBefore(tag);\n      }\n      if (tag.has(\"var\")) {\n        if (isHTML) {\n          translateVar(\n            tag,\n            import_compiler28.types.arrowFunctionExpression(\n              [],\n              import_compiler28.types.blockStatement([\n                import_compiler28.types.throwStatement(\n                  import_compiler28.types.newExpression(import_compiler28.types.identifier(\"Error\"), [\n                    import_compiler28.types.stringLiteral(\"Cannot reference DOM node from server\")\n                  ])\n                )\n              ])\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let createElFunction = void 0;\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (reference.parentPath?.isCallExpression()) {\n              reference.parentPath.replaceWith(\n                import_compiler28.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, nodeRef)\n                )\n              );\n            } else {\n              createElFunction ??= import_compiler28.types.identifier(varName + \"_getter\");\n              reference.replaceWith(\n                callRuntime(\n                  \"bindFunction\",\n                  getScopeExpression(referenceSection, section),\n                  createElFunction\n                )\n              );\n            }\n          }\n          if (createElFunction) {\n            currentProgramPath.pushContainer(\n              \"body\",\n              import_compiler28.types.variableDeclaration(\"const\", [\n                import_compiler28.types.variableDeclarator(\n                  createElFunction,\n                  import_compiler28.types.arrowFunctionExpression(\n                    [scopeIdentifier],\n                    import_compiler28.types.memberExpression(\n                      scopeIdentifier,\n                      getScopeAccessorLiteral(nodeRef),\n                      true\n                    )\n                  )\n                )\n              ])\n            );\n          }\n        }\n      }\n      let visitAccessor;\n      if (nodeRef) {\n        visitAccessor = getScopeAccessorLiteral(nodeRef);\n        visit(tag, 32 /* Get */);\n      }\n      write2`<${name.node}`;\n      if (hasSpread) {\n        const attrsObj = attrsToObject(tag);\n        if (isHTML) {\n          addHTMLEffectCall(section, extra.referencedBindings);\n          write2`${callRuntime(\"attrs\", attrsObj, visitAccessor, getScopeIdIdentifier(section))}`;\n        } else {\n          addStatement(\n            \"render\",\n            section,\n            extra.referencedBindings,\n            import_compiler28.types.expressionStatement(\n              callRuntime(\"attrs\", scopeIdentifier, visitAccessor, attrsObj)\n            )\n          );\n          addStatement(\n            \"effect\",\n            section,\n            extra.referencedBindings,\n            import_compiler28.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            attrsObj\n          );\n        }\n      } else {\n        for (const attr2 of attrs2) {\n          const name2 = attr2.node.name;\n          const value = attr2.get(\"value\");\n          const { confident, computed } = attr2.node.extra ?? {};\n          const valueReferences = value.node.extra?.referencedBindings;\n          switch (name2) {\n            case \"class\":\n            case \"style\": {\n              const helper = `${name2}Attr`;\n              if (confident) {\n                write2`${getHTMLRuntime()[helper](computed)}`;\n              } else if (isHTML) {\n                write2`${callRuntime(helper, value.node)}`;\n              } else {\n                addStatement(\n                  \"render\",\n                  section,\n                  valueReferences,\n                  import_compiler28.types.expressionStatement(\n                    callRuntime(\n                      helper,\n                      import_compiler28.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                      value.node\n                    )\n                  )\n                );\n              }\n              break;\n            }\n            default:\n              if (confident) {\n                write2`${getHTMLRuntime().attr(name2, computed)}`;\n              } else if (isHTML) {\n                if (isEventHandler(name2)) {\n                  addHTMLEffectCall(section, valueReferences);\n                } else {\n                  write2`${callRuntime(\n                    \"attr\",\n                    import_compiler28.types.stringLiteral(name2),\n                    value.node\n                  )}`;\n                }\n              } else if (isEventHandler(name2)) {\n                addStatement(\n                  \"effect\",\n                  section,\n                  valueReferences,\n                  import_compiler28.types.expressionStatement(\n                    callRuntime(\n                      \"on\",\n                      import_compiler28.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                      import_compiler28.types.stringLiteral(getEventHandlerName(name2)),\n                      value.node\n                    )\n                  ),\n                  value.node\n                );\n              } else {\n                addStatement(\n                  \"render\",\n                  section,\n                  valueReferences,\n                  import_compiler28.types.expressionStatement(\n                    callRuntime(\n                      \"attr\",\n                      import_compiler28.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                      import_compiler28.types.stringLiteral(name2),\n                      value.node\n                    )\n                  )\n                );\n              }\n              break;\n          }\n        }\n      }\n      if (tagDef && tagDef.parseOptions?.openTagOnly) {\n        switch (tagDef.htmlType) {\n          case \"svg\":\n          case \"math\":\n            write2`/>`;\n            break;\n          default:\n            write2`>`;\n            break;\n        }\n      } else {\n        write2`>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(import_compiler28.types.ifStatement(name.node, consumeHTML(tag)))[0].skip();\n      }\n      enter(tag);\n    },\n    exit(tag) {\n      const extra = tag.node.extra;\n      const nodeRef = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const openTagOnly = (0, import_babel_utils22.getTagDef)(tag)?.parseOptions?.openTagOnly;\n      if (isHTML && extra.tagNameNullable) {\n        flushInto(tag);\n      }\n      tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n      if (!openTagOnly) {\n        writeTo(tag)`</${tag.node.name}>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(\n          import_compiler28.types.ifStatement(tag.node.name, consumeHTML(tag))\n        )[0].skip();\n      }\n      if (nodeRef && (extra[kSerializeMarker] || tag.node.attributes.some(\n        (attr2) => isStatefulReferences(attr2.value.extra?.referencedBindings)\n      ))) {\n        markNode(tag, nodeRef);\n      }\n      exit(tag);\n      tag.remove();\n    }\n  }\n};\nfunction isSpreadAttr(attr2) {\n  return attr2.type === \"MarkoSpreadAttribute\";\n}\nfunction isEventHandler(propName) {\n  return /^on[A-Z-]/.test(propName);\n}\nfunction getEventHandlerName(propName) {\n  return propName.charAt(2) === \"-\" ? propName.slice(3) : propName.charAt(2).toLowerCase() + propName.slice(3);\n}\n\n// src/core/for.ts\nvar kForMarkerBinding = Symbol(\"for marker binding\");\nvar for_default = {\n  analyze(tag) {\n    validateFor(tag);\n    const isOnlyChild = checkOnlyChild(tag);\n    const tagExtra = tag.node.extra ??= {};\n    const tagBody = tag.get(\"body\");\n    const section = getOrCreateSection(tag);\n    const bodySection = startSection(tagBody);\n    if (isOnlyChild) {\n      const parentTag = tag.parentPath.parent;\n      const parentTagName = parentTag.name?.value;\n      (parentTag.extra ??= {})[kNativeTagBinding] ??= createBinding(\n        \"#\" + parentTagName,\n        0 /* dom */,\n        section\n      );\n    } else {\n      tagExtra[kForMarkerBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section\n      );\n    }\n    trackParamsReferences(tagBody, 3 /* param */, void 0, tagExtra);\n    analyzeAttributeTags(tag);\n    mergeReferences(\n      tag,\n      tag.node.attributes.map((attr2) => attr2.value)\n    );\n    bodySection.upstreamExpression = tagExtra;\n    tagExtra.singleNodeOptimization = tag.node.body.body.length === 1;\n  },\n  translate: {\n    enter(tag) {\n      const tagBody = tag.get(\"body\");\n      const bodySection = getSection(tagBody);\n      const tagExtra = tag.node.extra;\n      const { singleNodeOptimization, isOnlyChild } = tagExtra;\n      const isStateful = isStatefulReferences(tagExtra.referencedBindings);\n      const hasNestedAttributeTags = tagExtra.nestedAttributeTags && Object.keys(tagExtra.nestedAttributeTags).length > 0;\n      if (!isOnlyChild) {\n        visit(tag, 37 /* Replace */);\n        enterShallow(tag);\n      }\n      if (isOutputHTML()) {\n        flushBefore(tag);\n        if (isStateful && !singleNodeOptimization && !hasNestedAttributeTags) {\n          writeTo(tagBody)`${callRuntime(\n            \"markResumeScopeStart\",\n            getScopeIdIdentifier(bodySection)\n          )}`;\n        }\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML.exit(tag);\n      } else {\n        translateDOM.exit(tag);\n      }\n    }\n  },\n  attributes: {\n    of: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over a list of items.\"\n        }\n      ]\n    },\n    in: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over the keys and values of an object.\"\n        }\n      ]\n    },\n    to: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates up to the provided number (inclusive)\"\n        }\n      ]\n    },\n    from: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates starting from the provided number (inclusive)\"\n        }\n      ]\n    },\n    step: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"The amount to increment during each interation (with from/to)\"\n        }\n      ]\n    }\n  },\n  autocomplete: [\n    {\n      snippet: \"for|${1:value, index}| of=${3:array}\",\n      description: \"Use to iterate over lists, object properties, or between ranges.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-a-list\"\n    },\n    {\n      snippet: \"for|${1:name, value}| in=${3:object}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties\"\n    },\n    {\n      snippet: \"for|${1:index}| from=${2:number} to=${3:number} step=${4:number}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers\"\n    }\n  ]\n};\nvar translateDOM = {\n  exit(tag) {\n    const tagBody = tag.get(\"body\");\n    const tagSection = getSection(tag);\n    const bodySection = getSection(tagBody);\n    const { node } = tag;\n    const { attributes } = node;\n    const { isOnlyChild, referencedBindings } = node.extra;\n    const nodeRef = isOnlyChild ? tag.parentPath.parent.extra[kNativeTagBinding] : tag.node.extra[kForMarkerBinding];\n    setSubscriberBuilder(tag, (signal2) => {\n      return callRuntime(\n        \"inLoopScope\",\n        signal2,\n        getScopeAccessorLiteral(nodeRef)\n      );\n    });\n    tag.remove();\n    const rendererId = import_compiler29.types.identifier(bodySection.name);\n    const ofAttr = findName(attributes, \"of\");\n    const toAttr = findName(attributes, \"to\");\n    const inAttr = findName(attributes, \"in\");\n    const loopArgs = [];\n    let loopKind;\n    if (ofAttr) {\n      loopKind = \"loopOf\";\n      loopArgs.push(ofAttr.value);\n    } else if (inAttr) {\n      loopKind = \"loopIn\";\n      loopArgs.push(inAttr.value);\n    } else if (toAttr) {\n      const fromAttr = findName(attributes, \"from\");\n      const stepAttr = findName(attributes, \"step\");\n      loopKind = \"loopTo\";\n      loopArgs.push(\n        toAttr.value,\n        fromAttr ? fromAttr.value : import_compiler29.types.numericLiteral(0),\n        stepAttr ? stepAttr.value : import_compiler29.types.numericLiteral(1)\n      );\n    }\n    const byAttr = findName(attributes, \"by\");\n    if (byAttr) {\n      loopArgs.push(byAttr.value);\n    }\n    const signal = getSignal(tagSection, nodeRef, \"for\");\n    signal.build = () => {\n      return callRuntime(\n        loopKind,\n        getScopeAccessorLiteral(nodeRef),\n        rendererId\n      );\n    };\n    const paramIdentifiers = Object.values(\n      tagBody.getBindingIdentifiers()\n    );\n    signal.hasDownstreamIntersections = () => {\n      if (getClosures(bodySection).length > 0) {\n        return true;\n      }\n      if (paramIdentifiers.length) {\n        const binding = paramIdentifiers[0].extra.binding;\n        for (const { referencedBindings: referencedBindings2 } of binding.downstreamExpressions) {\n          if (getSignal(\n            bodySection,\n            referencedBindings2\n          ).hasDownstreamIntersections()) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    addValue(\n      tagSection,\n      referencedBindings,\n      signal,\n      import_compiler29.types.arrayExpression(loopArgs)\n    );\n  }\n};\nvar translateHTML = {\n  exit(tag) {\n    const tagBody = tag.get(\"body\");\n    const tagSection = getSection(tag);\n    const bodySection = getSection(tagBody);\n    const { node } = tag;\n    const {\n      attributes,\n      body: { body, params }\n    } = node;\n    const tagExtra = node.extra;\n    const { singleNodeOptimization, isOnlyChild } = tagExtra;\n    const isStateful = isStatefulReferences(tagExtra.referencedBindings);\n    const hasNestedAttributeTags = tagExtra.nestedAttributeTags && Object.keys(tagExtra.nestedAttributeTags).length > 0;\n    const nodeRef = isOnlyChild ? tag.parentPath.parent.extra[kNativeTagBinding] : tag.node.extra[kForMarkerBinding];\n    const ofAttr = findName(attributes, \"of\");\n    const inAttr = findName(attributes, \"in\");\n    const toAttr = findName(attributes, \"to\");\n    const byAttr = findName(attributes, \"by\");\n    const block = import_compiler29.types.blockStatement(body);\n    const write2 = writeTo(tag);\n    const replacement = [];\n    const hasStatefulClosures = checkStatefulClosures(bodySection, true);\n    let byParams;\n    let keyExpression = import_compiler29.types.identifier(\"NOO\");\n    if (isStateful && isOnlyChild) {\n      tag.parentPath.parent.extra[kSerializeMarker] = true;\n    }\n    if (isStateful || hasStatefulClosures) {\n      setForceResumeScope(bodySection);\n    }\n    if (byAttr && isStateful) {\n      const byIdentifier = currentProgramPath.scope.generateUidIdentifier(\"by\");\n      replacement.push(\n        import_compiler29.types.variableDeclaration(\"const\", [\n          import_compiler29.types.variableDeclarator(byIdentifier, byAttr.value)\n        ])\n      );\n      byParams = [];\n      keyExpression = import_compiler29.types.callExpression(byIdentifier, byParams);\n    }\n    if (inAttr) {\n      const [keyParam, valParam] = params;\n      keyExpression = keyParam;\n      if (valParam) {\n        block.body.unshift(\n          import_compiler29.types.variableDeclaration(\"const\", [\n            import_compiler29.types.variableDeclarator(\n              valParam,\n              import_compiler29.types.memberExpression(inAttr.value, keyParam, true)\n            )\n          ])\n        );\n      }\n      replacement.push(\n        import_compiler29.types.forInStatement(\n          import_compiler29.types.variableDeclaration(\"const\", [import_compiler29.types.variableDeclarator(keyParam)]),\n          inAttr.value,\n          block\n        )\n      );\n    } else if (ofAttr) {\n      let ofAttrValue = ofAttr.value;\n      let [valParam, indexParam, loopParam] = params;\n      if (!import_compiler29.types.isIdentifier(valParam) && byParams) {\n        const tempValParam = currentProgramPath.scope.generateUidIdentifier(\"v\");\n        block.body.unshift(\n          import_compiler29.types.variableDeclaration(\"const\", [\n            import_compiler29.types.variableDeclarator(valParam, tempValParam)\n          ])\n        );\n        valParam = tempValParam;\n      }\n      if (indexParam || isStateful || hasStatefulClosures) {\n        indexParam ??= currentProgramPath.scope.generateUidIdentifier(\"i\");\n        const indexName = tag.scope.generateUidIdentifierBasedOnNode(\n          indexParam,\n          \"i\"\n        );\n        replacement.push(\n          import_compiler29.types.variableDeclaration(\"let\", [\n            import_compiler29.types.variableDeclarator(indexName, import_compiler29.types.numericLiteral(0))\n          ])\n        );\n        block.body.unshift(\n          import_compiler29.types.variableDeclaration(\"let\", [\n            import_compiler29.types.variableDeclarator(\n              indexParam,\n              import_compiler29.types.updateExpression(\"++\", indexName)\n            )\n          ])\n        );\n      }\n      if (loopParam) {\n        if (import_compiler29.types.isIdentifier(loopParam)) {\n          ofAttrValue = loopParam;\n        }\n        replacement.push(\n          import_compiler29.types.variableDeclaration(\"const\", [\n            import_compiler29.types.variableDeclarator(loopParam, ofAttr.value)\n          ])\n        );\n      }\n      if (byParams) {\n        byParams.push(valParam, indexParam);\n      } else {\n        keyExpression = indexParam;\n      }\n      replacement.push(\n        import_compiler29.types.forOfStatement(\n          import_compiler29.types.variableDeclaration(\"const\", [import_compiler29.types.variableDeclarator(valParam)]),\n          ofAttrValue,\n          block\n        )\n      );\n    } else if (toAttr) {\n      const stepValue = findName(attributes, \"step\")?.value ?? import_compiler29.types.numericLiteral(1);\n      const fromValue = findName(attributes, \"from\")?.value ?? import_compiler29.types.numericLiteral(0);\n      let [indexParam] = params;\n      const stepsName = tag.scope.generateUidIdentifier(\"steps\");\n      const indexName = tag.scope.generateUidIdentifier(\"i\");\n      const stepName = tag.scope.generateUidIdentifier(\"step\");\n      const fromName = tag.scope.generateUidIdentifier(\"from\");\n      if (indexParam || isStateful || hasStatefulClosures) {\n        indexParam ??= currentProgramPath.scope.generateUidIdentifier(\"i\");\n        keyExpression = indexParam;\n        block.body.unshift(\n          import_compiler29.types.variableDeclaration(\"const\", [\n            import_compiler29.types.variableDeclarator(\n              indexParam,\n              import_compiler29.types.binaryExpression(\n                \"+\",\n                fromName,\n                import_compiler29.types.binaryExpression(\"*\", indexName, stepName)\n              )\n            )\n          ])\n        );\n      }\n      replacement.push(\n        import_compiler29.types.forStatement(\n          import_compiler29.types.variableDeclaration(\"let\", [\n            import_compiler29.types.variableDeclarator(\n              fromName,\n              import_compiler29.types.logicalExpression(\"??\", fromValue, import_compiler29.types.numericLiteral(0))\n            ),\n            import_compiler29.types.variableDeclarator(\n              stepName,\n              import_compiler29.types.logicalExpression(\"??\", stepValue, import_compiler29.types.numericLiteral(1))\n            ),\n            import_compiler29.types.variableDeclarator(\n              stepsName,\n              import_compiler29.types.binaryExpression(\n                \"/\",\n                import_compiler29.types.binaryExpression(\"-\", toAttr.value, fromName),\n                stepName\n              )\n            ),\n            import_compiler29.types.variableDeclarator(indexName, import_compiler29.types.numericLiteral(0))\n          ]),\n          import_compiler29.types.binaryExpression(\"<=\", indexName, stepsName),\n          import_compiler29.types.updateExpression(\"++\", indexName),\n          block\n        )\n      );\n    }\n    if ((isStateful || hasStatefulClosures) && !hasNestedAttributeTags) {\n      const forScopeIdsIdentifier = tag.scope.generateUidIdentifier(\"forScopeIds\");\n      const forScopesIdentifier = getScopeIdentifier(bodySection);\n      replacement.unshift(\n        import_compiler29.types.variableDeclaration(\n          \"const\",\n          [\n            isStateful && singleNodeOptimization && import_compiler29.types.variableDeclarator(\n              forScopeIdsIdentifier,\n              import_compiler29.types.arrayExpression([])\n            ),\n            import_compiler29.types.variableDeclarator(\n              forScopesIdentifier,\n              import_compiler29.types.newExpression(import_compiler29.types.identifier(\"Map\"), [])\n            )\n          ].filter(Boolean)\n        )\n      );\n      if (isStateful) {\n        if (singleNodeOptimization) {\n          block.body.push(\n            import_compiler29.types.expressionStatement(\n              import_compiler29.types.callExpression(\n                import_compiler29.types.memberExpression(forScopeIdsIdentifier, import_compiler29.types.identifier(\"push\")),\n                [getScopeIdIdentifier(bodySection)]\n              )\n            )\n          );\n          write2`${callRuntime(\n            \"markResumeControlSingleNodeEnd\",\n            getScopeIdIdentifier(tagSection),\n            getScopeAccessorLiteral(nodeRef),\n            forScopeIdsIdentifier\n          )}`;\n        } else {\n          write2`${callRuntime(\n            \"markResumeControlEnd\",\n            getScopeIdIdentifier(tagSection),\n            getScopeAccessorLiteral(nodeRef)\n          )}`;\n        }\n      }\n      getSerializedScopeProperties(tagSection).set(\n        import_compiler29.types.stringLiteral(\n          getScopeAccessorLiteral(nodeRef).value + \"(\" /* LoopScopeMap */\n        ),\n        import_compiler29.types.conditionalExpression(\n          import_compiler29.types.memberExpression(forScopesIdentifier, import_compiler29.types.identifier(\"size\")),\n          forScopesIdentifier,\n          import_compiler29.types.identifier(\"undefined\")\n        )\n      );\n    }\n    flushInto(tag);\n    setSubscriberBuilder(tag, () => {\n    });\n    writeHTMLResumeStatements(tagBody);\n    if (isStateful || hasStatefulClosures) {\n      tag.node.body.body.push(\n        import_compiler29.types.expressionStatement(\n          import_compiler29.types.callExpression(\n            import_compiler29.types.memberExpression(\n              getScopeIdentifier(bodySection),\n              import_compiler29.types.identifier(\"set\")\n            ),\n            [\n              keyExpression,\n              callRuntime(\"getScopeById\", getScopeIdIdentifier(bodySection))\n            ]\n          )\n        )\n      );\n    }\n    tag.replaceWithMultiple(replacement);\n  }\n};\nfunction findName(arr, value) {\n  return arr.find((obj) => import_compiler29.types.isMarkoAttribute(obj) && obj.name === value);\n}\nfunction validateFor(tag) {\n  const attrs2 = tag.node.attributes;\n  const hasParams = tag.node.body.params.length > 0;\n  (0, import_babel_utils23.assertNoVar)(tag);\n  if (findName(attrs2, \"of\")) {\n    (0, import_babel_utils23.assertAllowedAttributes)(tag, [\"of\", \"by\"]);\n    if (!hasParams) {\n      throw tag.buildCodeFrameError(\n        \"Invalid `for of` tag, missing `|value, index|` params.\"\n      );\n    }\n  } else if (findName(attrs2, \"in\")) {\n    (0, import_babel_utils23.assertAllowedAttributes)(tag, [\"in\", \"by\"]);\n    if (!hasParams) {\n      throw tag.buildCodeFrameError(\n        \"Invalid `for in` tag, missing `|key, value|` params.\"\n      );\n    }\n  } else if (findName(attrs2, \"to\")) {\n    (0, import_babel_utils23.assertAllowedAttributes)(tag, [\"from\", \"to\", \"step\", \"by\"]);\n  } else {\n    throw tag.buildCodeFrameError(\n      \"Invalid `for` tag, missing an `of=`, `in=` or `to=` attribute.\"\n    );\n  }\n}\nfunction checkOnlyChild(tag) {\n  const extra = tag.node.extra;\n  if (import_compiler29.types.isMarkoTag(tag.parentPath?.parent) && (0, import_babel_utils23.getTagDef)(tag.parentPath.parentPath)?.html) {\n    return extra.isOnlyChild = tag.parent.body.length === 1;\n  }\n  return extra.isOnlyChild = false;\n}\n\n// src/core/html-comment.ts\nvar import_babel_utils24 = require(\"@marko/babel-utils\");\nvar import_compiler30 = require(\"@marko/compiler\");\nvar kCommentTagBinding = Symbol(\"comment tag binding\");\nvar html_comment_default = {\n  analyze(tag) {\n    (0, import_babel_utils24.assertNoArgs)(tag);\n    (0, import_babel_utils24.assertNoParams)(tag);\n    (0, import_babel_utils24.assertNoAttributes)(tag);\n    let needsBinding = false;\n    if (tag.has(\"var\")) {\n      if (!import_compiler30.types.isIdentifier(tag.node.var)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"The `html-comment` tag cannot be destructured.\"\n        );\n      }\n      needsBinding = true;\n    }\n    const referenceNodes = [];\n    for (const child of tag.get(\"body\").get(\"body\")) {\n      if (child.isMarkoPlaceholder()) {\n        referenceNodes.push(child.node.value);\n        needsBinding = true;\n      } else if (!child.isMarkoText()) {\n        throw child.buildCodeFrameError(\n          \"Invalid child. Only text is allowed inside an html comment.\"\n        );\n      }\n    }\n    if (needsBinding) {\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      tagExtra[kCommentTagBinding] = createBinding(\n        \"#comment\",\n        0 /* dom */,\n        section\n      );\n      mergeReferences(tag, referenceNodes);\n    }\n    tag.skip();\n  },\n  translate(tag) {\n    const tagExtra = tag.node.extra;\n    const commentBinding = tagExtra[kCommentTagBinding];\n    if (tag.has(\"var\")) {\n      if (isOutputHTML()) {\n        translateVar(\n          tag,\n          import_compiler30.types.arrowFunctionExpression(\n            [],\n            import_compiler30.types.blockStatement([\n              import_compiler30.types.throwStatement(\n                import_compiler30.types.newExpression(import_compiler30.types.identifier(\"Error\"), [\n                  import_compiler30.types.stringLiteral(\n                    \"Cannot reference a DOM node from the server\"\n                  )\n                ])\n              )\n            ])\n          )\n        );\n      } else {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        let createElFunction = void 0;\n        for (const reference of references) {\n          const referenceSection = getSection(reference);\n          if (reference.parentPath?.isCallExpression()) {\n            reference.parentPath.replaceWith(\n              import_compiler30.types.expressionStatement(\n                createScopeReadExpression(referenceSection, commentBinding)\n              )\n            );\n          } else {\n            createElFunction ??= import_compiler30.types.identifier(varName + \"_getter\");\n            reference.replaceWith(\n              callRuntime(\n                \"bindFunction\",\n                getScopeExpression(referenceSection, getSection(tag)),\n                createElFunction\n              )\n            );\n          }\n        }\n        if (createElFunction) {\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler30.types.variableDeclaration(\"const\", [\n              import_compiler30.types.variableDeclarator(\n                createElFunction,\n                import_compiler30.types.arrowFunctionExpression(\n                  [scopeIdentifier],\n                  import_compiler30.types.memberExpression(\n                    scopeIdentifier,\n                    getScopeAccessorLiteral(commentBinding),\n                    true\n                  )\n                )\n              )\n            ])\n          );\n        }\n      }\n    }\n    if (tagExtra[kCommentTagBinding]) {\n      visit(tag, 32 /* Get */);\n    }\n    const write2 = writeTo(tag);\n    enter(tag);\n    write2`<!--`;\n    if (isOutputHTML()) {\n      for (const child of tag.node.body.body) {\n        if (import_compiler30.types.isMarkoText(child)) {\n          write2`${child.value}`;\n        } else if (import_compiler30.types.isMarkoPlaceholder(child)) {\n          write2`${callRuntime(\"escapeXML\", child.value)}`;\n        }\n      }\n    } else {\n      const templateQuasis = [];\n      const templateExpressions = [];\n      let currentQuasi = \"\";\n      for (const child of tag.node.body.body) {\n        if (import_compiler30.types.isMarkoText(child)) {\n          currentQuasi += child.value;\n        } else if (import_compiler30.types.isMarkoPlaceholder(child)) {\n          templateQuasis.push(import_compiler30.types.templateElement({ raw: currentQuasi }));\n          templateExpressions.push(child.value);\n          currentQuasi = \"\";\n        }\n      }\n      if (templateExpressions.length === 0) {\n        write2`${currentQuasi}`;\n      } else {\n        templateQuasis.push(import_compiler30.types.templateElement({ raw: currentQuasi }));\n        addStatement(\n          \"render\",\n          getSection(tag),\n          tagExtra.referencedBindings,\n          import_compiler30.types.expressionStatement(\n            callRuntime(\n              \"data\",\n              import_compiler30.types.memberExpression(\n                scopeIdentifier,\n                getScopeAccessorLiteral(commentBinding),\n                true\n              ),\n              import_compiler30.types.templateLiteral(templateQuasis, templateExpressions)\n            )\n          )\n        );\n      }\n    }\n    exit(tag);\n    write2`-->`;\n    if (commentBinding) {\n      markNode(tag, commentBinding);\n    }\n    tag.remove();\n  },\n  parseOptions: {\n    // TODO: fix the types for Tag or parseOptions or something\n    text: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an html comment that is not stripped from the output.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#html-comment\"\n    }\n  ]\n};\n\n// src/core/id.ts\nvar import_babel_utils25 = require(\"@marko/babel-utils\");\nvar import_compiler31 = require(\"@marko/compiler\");\nvar id_default = {\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const { var: tagVar } = node;\n      const id = isOutputHTML() ? callRuntime(\"nextTagId\") : callRuntime(\"nextTagId\", scopeIdentifier);\n      (0, import_babel_utils25.assertNoArgs)(tag);\n      (0, import_babel_utils25.assertNoAttributes)(tag);\n      assertNoBodyContent(tag);\n      (0, import_babel_utils25.assertNoParams)(tag);\n      if (!node.var) {\n        throw tag.get(\"name\").buildCodeFrameError(\"The `id` tag requires a tag variable.\");\n      }\n      if (!import_compiler31.types.isIdentifier(tagVar)) {\n        throw tag.get(\"var\").buildCodeFrameError(\"The `id` tag cannot be destructured\");\n      }\n      if (isOutputHTML()) {\n        tag.replaceWith(\n          import_compiler31.types.variableDeclaration(\"const\", [import_compiler31.types.variableDeclarator(node.var, id)])\n        );\n      } else {\n        const source = initValue(tagVar.extra.binding);\n        addValue(getSection(tag), void 0, source, id);\n        tag.remove();\n      }\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"id/<name>\",\n      description: \"Use to create a unique identifier.\",\n      snippet: \"id/${1:name}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#id\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/id.d.marko\"\n};\n\n// src/core/import.ts\nvar import_babel_utils26 = require(\"@marko/babel-utils\");\nvar import_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils26.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: 'import <scope> from \"<path>\"',\n      description: \"Use to import external modules, follows the same syntax as JavaScript imports.\",\n      snippet: 'import ${2} from \"${1:path}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#importing-external-files\"\n    }\n  ]\n};\n\n// src/core/let.ts\nvar import_babel_utils27 = require(\"@marko/babel-utils\");\nvar import_compiler32 = require(\"@marko/compiler\");\nvar let_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    const { optimize } = getMarkoOpts();\n    let valueAttr;\n    let valueChangeAttr;\n    for (const attr2 of node.attributes) {\n      if (import_compiler32.types.isMarkoAttribute(attr2)) {\n        if (attr2.name === \"value\") {\n          valueAttr = attr2;\n        } else if (attr2.name === \"valueChange\") {\n          valueChangeAttr = attr2;\n        } else {\n          const start = attr2.loc?.start;\n          const end = attr2.loc?.end;\n          const msg = \"The `let` tag only supports the `value` attribute and its change handler.\";\n          if (start == null || end == null) {\n            throw tag.get(\"name\").buildCodeFrameError(msg);\n          } else {\n            throw tag.hub.buildError(\n              { loc: { start, end } },\n              msg,\n              Error\n            );\n          }\n        }\n      }\n    }\n    (0, import_babel_utils27.assertNoArgs)(tag);\n    (0, import_babel_utils27.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    if (!tagVar) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `let` tag requires a tag variable.\");\n    }\n    if (!import_compiler32.types.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `let` tag variable cannot be destructured.\");\n    }\n    if (valueChangeAttr && (0, import_babel_utils27.computeNode)(valueChangeAttr.value)) {\n      throw tag.get(\"attributes\").find((attr2) => attr2.node === valueChangeAttr).get(\"value\").buildCodeFrameError(\n        \"The `let` tag `valueChange` attribute must be a function.\"\n      );\n    }\n    if (valueChangeAttr) {\n      const valueChangeReferences = (valueChangeAttr.value.extra ??= {})?.referencedBindings;\n      valueChangeAttr.value.extra.static = import_compiler32.types.isFunction(valueChangeAttr.value);\n      if (optimize && import_compiler32.types.isIdentifier(valueChangeAttr.value) && size(valueChangeReferences) === 1) {\n        valueChangeAttr.value.extra.binding = valueChangeReferences;\n      } else {\n        valueChangeAttr.value.extra.binding = createBinding(\n          tag.scope.generateUid(tagVar.name + \"_change\"),\n          1 /* let */,\n          getSection(tag),\n          void 0,\n          valueChangeAttr.value.extra\n        );\n      }\n    }\n    const upstreamExpressionExtra = valueAttr ? valueAttr.value.extra ??= {} : void 0;\n    trackVarReferences(\n      tag,\n      1 /* let */,\n      void 0,\n      upstreamExpressionExtra,\n      valueChangeAttr?.value.extra?.binding\n    );\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const tagVar = node.var;\n      const { optimize } = getMarkoOpts();\n      const valueAttr = node.attributes.find(\n        (attr2) => import_compiler32.types.isMarkoAttribute(attr2) && (attr2.default || attr2.name === \"value\")\n      ) ?? import_compiler32.types.markoAttribute(\"value\", import_compiler32.types.identifier(\"undefined\"));\n      const valueChangeAttr = node.attributes.find(\n        (attr2) => import_compiler32.types.isMarkoAttribute(attr2) && attr2.name === \"valueChange\"\n      );\n      const valueChangeBinding = valueChangeAttr?.value.extra?.binding;\n      if (isOutputDOM()) {\n        const section = getSection(tag);\n        const binding = tagVar.extra.binding;\n        const signal = initValue(binding);\n        const referencedBindings = valueAttr.value.extra?.referencedBindings;\n        const isSetup = !referencedBindings;\n        if (valueChangeBinding && (!optimize || !import_compiler32.types.isIdentifier(valueChangeAttr.value))) {\n          const valueChangeSource = initValue(valueChangeBinding);\n          if (!optimize && !import_compiler32.types.isFunction(valueChangeAttr.value)) {\n            const build = valueChangeSource.build;\n            valueChangeSource.build = () => {\n              const fn = build();\n              return callRuntime(\n                \"changeHandler\",\n                getScopeAccessorLiteral(valueChangeBinding),\n                fn\n              );\n            };\n          }\n          addValue(\n            section,\n            valueChangeAttr.value.extra?.referencedBindings,\n            valueChangeSource,\n            valueChangeAttr.value\n          );\n        }\n        addValue(section, referencedBindings, signal, valueAttr.value);\n        if (!isSetup && !valueChangeAttr?.value.extra?.static) {\n          let calleeExpression;\n          Object.defineProperty(signal, \"callee\", {\n            get() {\n              if (!calleeExpression) {\n                const initValueId = tag.scope.generateUidIdentifier(\n                  signal.identifier.name + \"_init\"\n                );\n                calleeExpression = valueChangeBinding ? import_compiler32.types.conditionalExpression(\n                  createScopeReadExpression(section, valueChangeBinding),\n                  signal.identifier,\n                  initValueId\n                ) : initValueId;\n                currentProgramPath.pushContainer(\n                  \"body\",\n                  import_compiler32.types.variableDeclaration(\"const\", [\n                    import_compiler32.types.variableDeclarator(\n                      initValueId,\n                      callRuntime(\n                        \"initValue\",\n                        getScopeAccessorLiteral(binding),\n                        signal.identifier\n                      )\n                    )\n                  ])\n                );\n              }\n              return calleeExpression;\n            }\n          });\n        }\n        signal.buildAssignment = (valueSection, value) => {\n          return queueSource(signal, value, valueSection, valueChangeBinding);\n        };\n      } else {\n        translateVar(tag, valueAttr.value);\n        if (valueChangeBinding) {\n          tag.insertBefore(\n            import_compiler32.types.variableDeclaration(\"const\", [\n              import_compiler32.types.variableDeclarator(\n                import_compiler32.types.identifier(valueChangeBinding.name),\n                valueChangeAttr.value\n              )\n            ])\n          );\n        }\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a mutable binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#let\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/let.d.marko\"\n};\n\n// src/core/lifecycle.ts\nvar import_babel_utils28 = require(\"@marko/babel-utils\");\nvar import_compiler33 = require(\"@marko/compiler\");\nvar kRef = Symbol(\"lifecycle attrs reference\");\nvar supportedAttrNames = /* @__PURE__ */ new Set([\"onMount\", \"onUpdate\", \"onDestroy\"]);\nvar lifecycle_default = {\n  analyze(tag) {\n    (0, import_babel_utils28.assertNoArgs)(tag);\n    (0, import_babel_utils28.assertNoVar)(tag);\n    (0, import_babel_utils28.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const tagExtra = node.extra ??= {};\n    tagExtra[kRef] = createBinding(\n      tag.scope.generateUid(\"lifecycle\"),\n      4 /* derived */,\n      getOrCreateSection(tag),\n      void 0,\n      tagExtra\n    );\n    if (node.attributes.length === 0) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `lifecycle` tag requires at least one attribute.\"\n      );\n    }\n    for (const attr2 of node.attributes) {\n      if (import_compiler33.types.isMarkoSpreadAttribute(attr2)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The `lifecycle` tag does not support `...spread` attributes.\"\n        );\n      } else if (!supportedAttrNames.has(attr2.name)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          `The \\`lifecycle\\` tag does not support the \\`${attr2.name}\\` attribute.`\n        );\n      }\n      (attr2.value.extra ??= {}).isEffect = true;\n    }\n    (currentProgramPath.node.extra ??= {}).isInteractive = true;\n    mergeReferences(\n      tag,\n      tag.node.attributes.map((attr2) => attr2.value)\n    );\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const section = getSection(tag);\n      const tagExtra = node.extra;\n      const { referencedBindings } = tagExtra;\n      const lifecycleAttrsRef = tagExtra[kRef];\n      if (isOutputDOM()) {\n        const attrsObject = attrsToObject(tag);\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          import_compiler33.types.expressionStatement(\n            callRuntime(\n              \"lifecycle\",\n              scopeIdentifier,\n              getScopeAccessorLiteral(lifecycleAttrsRef),\n              attrsObject\n            )\n          ),\n          node.attributes.map((a) => a.value)\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/lifecycle.d.marko\"\n};\n\n// src/core/log.ts\nvar import_babel_utils29 = require(\"@marko/babel-utils\");\nvar import_compiler34 = require(\"@marko/compiler\");\nvar log_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils29.assertNoArgs)(tag);\n    (0, import_babel_utils29.assertNoVar)(tag);\n    (0, import_babel_utils29.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `log` tag requires a value.\");\n    }\n    if (tag.node.attributes.length > 1 || !import_compiler34.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `log` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      const statement = import_compiler34.types.expressionStatement(\n        import_compiler34.types.callExpression(\n          import_compiler34.types.memberExpression(import_compiler34.types.identifier(\"console\"), import_compiler34.types.identifier(\"log\")),\n          [value]\n        )\n      );\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to log a value to the console.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#log\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/log.d.marko\"\n};\n\n// src/core/noop.ts\nvar noop_default = {\n  migrate: [(tag) => tag.remove()]\n};\n\n// src/core/server.ts\nvar import_babel_utils30 = require(\"@marko/babel-utils\");\nvar import_compiler35 = require(\"@marko/compiler\");\nvar server_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^server\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils30.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler35.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler35.types.markoScriptlet(body, true, \"server\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"server <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the server.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#server-javascript\"\n    }\n  ]\n};\n\n// src/core/static.ts\nvar import_babel_utils31 = require(\"@marko/babel-utils\");\nvar import_compiler36 = require(\"@marko/compiler\");\nvar static_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^static\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils31.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler36.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler36.types.markoScriptlet(body, true));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"static <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#static-javascript\"\n    }\n  ]\n};\n\n// src/core/style.ts\nvar import_babel_utils32 = require(\"@marko/babel-utils\");\nvar import_compiler37 = require(\"@marko/compiler\");\n\n// ../../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs\nvar comma = \",\".charCodeAt(0);\nvar semicolon = \";\".charCodeAt(0);\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar intToChar = new Uint8Array(64);\nvar charToInt = new Uint8Array(128);\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\nfunction encodeInteger(builder, num, relative) {\n  let delta = num - relative;\n  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;\n  do {\n    let clamped = delta & 31;\n    delta >>>= 5;\n    if (delta > 0)\n      clamped |= 32;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n  return num;\n}\nvar bufLength = 1024 * 16;\nvar td = typeof TextDecoder !== \"undefined\" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== \"undefined\" ? {\n  decode(buf) {\n    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n    return out.toString();\n  }\n} : {\n  decode(buf) {\n    let out = \"\";\n    for (let i = 0; i < buf.length; i++) {\n      out += String.fromCharCode(buf[i]);\n    }\n    return out;\n  }\n};\nvar StringWriter = class {\n  constructor() {\n    this.pos = 0;\n    this.out = \"\";\n    this.buffer = new Uint8Array(bufLength);\n  }\n  write(v) {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n  flush() {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n};\nfunction encode(decoded) {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0)\n      writer.write(semicolon);\n    if (line.length === 0)\n      continue;\n    let genColumn = 0;\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0)\n        writer.write(comma);\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n      if (segment.length === 1)\n        continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n      if (segment.length === 4)\n        continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n  return writer.flush();\n}\n\n// ../../node_modules/magic-string/dist/magic-string.es.mjs\nvar BitSet = class _BitSet {\n  constructor(arg) {\n    this.bits = arg instanceof _BitSet ? arg.bits.slice() : [];\n  }\n  add(n2) {\n    this.bits[n2 >> 5] |= 1 << (n2 & 31);\n  }\n  has(n2) {\n    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));\n  }\n};\nvar Chunk2 = class _Chunk {\n  constructor(start, end, content) {\n    this.start = start;\n    this.end = end;\n    this.original = content;\n    this.intro = \"\";\n    this.outro = \"\";\n    this.content = content;\n    this.storeName = false;\n    this.edited = false;\n    {\n      this.previous = null;\n      this.next = null;\n    }\n  }\n  appendLeft(content) {\n    this.outro += content;\n  }\n  appendRight(content) {\n    this.intro = this.intro + content;\n  }\n  clone() {\n    const chunk = new _Chunk(this.start, this.end, this.original);\n    chunk.intro = this.intro;\n    chunk.outro = this.outro;\n    chunk.content = this.content;\n    chunk.storeName = this.storeName;\n    chunk.edited = this.edited;\n    return chunk;\n  }\n  contains(index) {\n    return this.start < index && index < this.end;\n  }\n  eachNext(fn) {\n    let chunk = this;\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.next;\n    }\n  }\n  eachPrevious(fn) {\n    let chunk = this;\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.previous;\n    }\n  }\n  edit(content, storeName, contentOnly) {\n    this.content = content;\n    if (!contentOnly) {\n      this.intro = \"\";\n      this.outro = \"\";\n    }\n    this.storeName = storeName;\n    this.edited = true;\n    return this;\n  }\n  prependLeft(content) {\n    this.outro = content + this.outro;\n  }\n  prependRight(content) {\n    this.intro = content + this.intro;\n  }\n  reset() {\n    this.intro = \"\";\n    this.outro = \"\";\n    if (this.edited) {\n      this.content = this.original;\n      this.storeName = false;\n      this.edited = false;\n    }\n  }\n  split(index) {\n    const sliceIndex = index - this.start;\n    const originalBefore = this.original.slice(0, sliceIndex);\n    const originalAfter = this.original.slice(sliceIndex);\n    this.original = originalBefore;\n    const newChunk = new _Chunk(index, this.end, originalAfter);\n    newChunk.outro = this.outro;\n    this.outro = \"\";\n    this.end = index;\n    if (this.edited) {\n      newChunk.edit(\"\", false);\n      this.content = \"\";\n    } else {\n      this.content = originalBefore;\n    }\n    newChunk.next = this.next;\n    if (newChunk.next) newChunk.next.previous = newChunk;\n    newChunk.previous = this;\n    this.next = newChunk;\n    return newChunk;\n  }\n  toString() {\n    return this.intro + this.content + this.outro;\n  }\n  trimEnd(rx) {\n    this.outro = this.outro.replace(rx, \"\");\n    if (this.outro.length) return true;\n    const trimmed = this.content.replace(rx, \"\");\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        this.split(this.start + trimmed.length).edit(\"\", void 0, true);\n        if (this.edited) {\n          this.edit(trimmed, this.storeName, true);\n        }\n      }\n      return true;\n    } else {\n      this.edit(\"\", void 0, true);\n      this.intro = this.intro.replace(rx, \"\");\n      if (this.intro.length) return true;\n    }\n  }\n  trimStart(rx) {\n    this.intro = this.intro.replace(rx, \"\");\n    if (this.intro.length) return true;\n    const trimmed = this.content.replace(rx, \"\");\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        const newChunk = this.split(this.end - trimmed.length);\n        if (this.edited) {\n          newChunk.edit(trimmed, this.storeName, true);\n        }\n        this.edit(\"\", void 0, true);\n      }\n      return true;\n    } else {\n      this.edit(\"\", void 0, true);\n      this.outro = this.outro.replace(rx, \"\");\n      if (this.outro.length) return true;\n    }\n  }\n};\nfunction getBtoa() {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));\n  } else if (typeof Buffer === \"function\") {\n    return (str) => Buffer.from(str, \"utf-8\").toString(\"base64\");\n  } else {\n    return () => {\n      throw new Error(\"Unsupported environment: `window.btoa` or `Buffer` should be supported.\");\n    };\n  }\n}\nvar btoa = /* @__PURE__ */ getBtoa();\nvar SourceMap = class {\n  constructor(properties) {\n    this.version = 3;\n    this.file = properties.file;\n    this.sources = properties.sources;\n    this.sourcesContent = properties.sourcesContent;\n    this.names = properties.names;\n    this.mappings = encode(properties.mappings);\n    if (typeof properties.x_google_ignoreList !== \"undefined\") {\n      this.x_google_ignoreList = properties.x_google_ignoreList;\n    }\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  toUrl() {\n    return \"data:application/json;charset=utf-8;base64,\" + btoa(this.toString());\n  }\n};\nfunction guessIndent(code) {\n  const lines = code.split(\"\\n\");\n  const tabbed = lines.filter((line) => /^\\t+/.test(line));\n  const spaced = lines.filter((line) => /^ {2,}/.test(line));\n  if (tabbed.length === 0 && spaced.length === 0) {\n    return null;\n  }\n  if (tabbed.length >= spaced.length) {\n    return \"\t\";\n  }\n  const min = spaced.reduce((previous, current) => {\n    const numSpaces = /^ +/.exec(current)[0].length;\n    return Math.min(numSpaces, previous);\n  }, Infinity);\n  return new Array(min + 1).join(\" \");\n}\nfunction getRelativePath(from, to) {\n  const fromParts = from.split(/[/\\\\]/);\n  const toParts = to.split(/[/\\\\]/);\n  fromParts.pop();\n  while (fromParts[0] === toParts[0]) {\n    fromParts.shift();\n    toParts.shift();\n  }\n  if (fromParts.length) {\n    let i = fromParts.length;\n    while (i--) fromParts[i] = \"..\";\n  }\n  return fromParts.concat(toParts).join(\"/\");\n}\nvar toString2 = Object.prototype.toString;\nfunction isObject(thing) {\n  return toString2.call(thing) === \"[object Object]\";\n}\nfunction getLocator(source) {\n  const originalLines = source.split(\"\\n\");\n  const lineOffsets = [];\n  for (let i = 0, pos = 0; i < originalLines.length; i++) {\n    lineOffsets.push(pos);\n    pos += originalLines[i].length + 1;\n  }\n  return function locate(index) {\n    let i = 0;\n    let j = lineOffsets.length;\n    while (i < j) {\n      const m = i + j >> 1;\n      if (index < lineOffsets[m]) {\n        j = m;\n      } else {\n        i = m + 1;\n      }\n    }\n    const line = i - 1;\n    const column = index - lineOffsets[line];\n    return { line, column };\n  };\n}\nvar wordRegex = /\\w/;\nvar Mappings = class {\n  constructor(hires) {\n    this.hires = hires;\n    this.generatedCodeLine = 0;\n    this.generatedCodeColumn = 0;\n    this.raw = [];\n    this.rawSegments = this.raw[this.generatedCodeLine] = [];\n    this.pending = null;\n  }\n  addEdit(sourceIndex, content, loc, nameIndex) {\n    if (content.length) {\n      const contentLengthMinusOne = content.length - 1;\n      let contentLineEnd = content.indexOf(\"\\n\", 0);\n      let previousContentLineEnd = -1;\n      while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {\n        const segment2 = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n        if (nameIndex >= 0) {\n          segment2.push(nameIndex);\n        }\n        this.rawSegments.push(segment2);\n        this.generatedCodeLine += 1;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n        this.generatedCodeColumn = 0;\n        previousContentLineEnd = contentLineEnd;\n        contentLineEnd = content.indexOf(\"\\n\", contentLineEnd + 1);\n      }\n      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n      if (nameIndex >= 0) {\n        segment.push(nameIndex);\n      }\n      this.rawSegments.push(segment);\n      this.advance(content.slice(previousContentLineEnd + 1));\n    } else if (this.pending) {\n      this.rawSegments.push(this.pending);\n      this.advance(content);\n    }\n    this.pending = null;\n  }\n  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n    let originalCharIndex = chunk.start;\n    let first = true;\n    let charInHiresBoundary = false;\n    while (originalCharIndex < chunk.end) {\n      if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n        const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n        if (this.hires === \"boundary\") {\n          if (wordRegex.test(original[originalCharIndex])) {\n            if (!charInHiresBoundary) {\n              this.rawSegments.push(segment);\n              charInHiresBoundary = true;\n            }\n          } else {\n            this.rawSegments.push(segment);\n            charInHiresBoundary = false;\n          }\n        } else {\n          this.rawSegments.push(segment);\n        }\n      }\n      if (original[originalCharIndex] === \"\\n\") {\n        loc.line += 1;\n        loc.column = 0;\n        this.generatedCodeLine += 1;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n        this.generatedCodeColumn = 0;\n        first = true;\n      } else {\n        loc.column += 1;\n        this.generatedCodeColumn += 1;\n        first = false;\n      }\n      originalCharIndex += 1;\n    }\n    this.pending = null;\n  }\n  advance(str) {\n    if (!str) return;\n    const lines = str.split(\"\\n\");\n    if (lines.length > 1) {\n      for (let i = 0; i < lines.length - 1; i++) {\n        this.generatedCodeLine++;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n      }\n      this.generatedCodeColumn = 0;\n    }\n    this.generatedCodeColumn += lines[lines.length - 1].length;\n  }\n};\nvar n = \"\\n\";\nvar warned = {\n  insertLeft: false,\n  insertRight: false,\n  storeName: false\n};\nvar MagicString = class _MagicString {\n  constructor(string, options = {}) {\n    const chunk = new Chunk2(0, string.length, string);\n    Object.defineProperties(this, {\n      original: { writable: true, value: string },\n      outro: { writable: true, value: \"\" },\n      intro: { writable: true, value: \"\" },\n      firstChunk: { writable: true, value: chunk },\n      lastChunk: { writable: true, value: chunk },\n      lastSearchedChunk: { writable: true, value: chunk },\n      byStart: { writable: true, value: {} },\n      byEnd: { writable: true, value: {} },\n      filename: { writable: true, value: options.filename },\n      indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n      sourcemapLocations: { writable: true, value: new BitSet() },\n      storedNames: { writable: true, value: {} },\n      indentStr: { writable: true, value: void 0 },\n      ignoreList: { writable: true, value: options.ignoreList }\n    });\n    this.byStart[0] = chunk;\n    this.byEnd[string.length] = chunk;\n  }\n  addSourcemapLocation(char) {\n    this.sourcemapLocations.add(char);\n  }\n  append(content) {\n    if (typeof content !== \"string\") throw new TypeError(\"outro content must be a string\");\n    this.outro += content;\n    return this;\n  }\n  appendLeft(index, content) {\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byEnd[index];\n    if (chunk) {\n      chunk.appendLeft(content);\n    } else {\n      this.intro += content;\n    }\n    return this;\n  }\n  appendRight(index, content) {\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byStart[index];\n    if (chunk) {\n      chunk.appendRight(content);\n    } else {\n      this.outro += content;\n    }\n    return this;\n  }\n  clone() {\n    const cloned = new _MagicString(this.original, { filename: this.filename });\n    let originalChunk = this.firstChunk;\n    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();\n    while (originalChunk) {\n      cloned.byStart[clonedChunk.start] = clonedChunk;\n      cloned.byEnd[clonedChunk.end] = clonedChunk;\n      const nextOriginalChunk = originalChunk.next;\n      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n      if (nextClonedChunk) {\n        clonedChunk.next = nextClonedChunk;\n        nextClonedChunk.previous = clonedChunk;\n        clonedChunk = nextClonedChunk;\n      }\n      originalChunk = nextOriginalChunk;\n    }\n    cloned.lastChunk = clonedChunk;\n    if (this.indentExclusionRanges) {\n      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n    }\n    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n    cloned.intro = this.intro;\n    cloned.outro = this.outro;\n    return cloned;\n  }\n  generateDecodedMap(options) {\n    options = options || {};\n    const sourceIndex = 0;\n    const names = Object.keys(this.storedNames);\n    const mappings = new Mappings(options.hires);\n    const locate = getLocator(this.original);\n    if (this.intro) {\n      mappings.advance(this.intro);\n    }\n    this.firstChunk.eachNext((chunk) => {\n      const loc = locate(chunk.start);\n      if (chunk.intro.length) mappings.advance(chunk.intro);\n      if (chunk.edited) {\n        mappings.addEdit(\n          sourceIndex,\n          chunk.content,\n          loc,\n          chunk.storeName ? names.indexOf(chunk.original) : -1\n        );\n      } else {\n        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n      }\n      if (chunk.outro.length) mappings.advance(chunk.outro);\n    });\n    return {\n      file: options.file ? options.file.split(/[/\\\\]/).pop() : void 0,\n      sources: [\n        options.source ? getRelativePath(options.file || \"\", options.source) : options.file || \"\"\n      ],\n      sourcesContent: options.includeContent ? [this.original] : void 0,\n      names,\n      mappings: mappings.raw,\n      x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0\n    };\n  }\n  generateMap(options) {\n    return new SourceMap(this.generateDecodedMap(options));\n  }\n  _ensureindentStr() {\n    if (this.indentStr === void 0) {\n      this.indentStr = guessIndent(this.original);\n    }\n  }\n  _getRawIndentString() {\n    this._ensureindentStr();\n    return this.indentStr;\n  }\n  getIndentString() {\n    this._ensureindentStr();\n    return this.indentStr === null ? \"\t\" : this.indentStr;\n  }\n  indent(indentStr, options) {\n    const pattern = /^[^\\r\\n]/gm;\n    if (isObject(indentStr)) {\n      options = indentStr;\n      indentStr = void 0;\n    }\n    if (indentStr === void 0) {\n      this._ensureindentStr();\n      indentStr = this.indentStr || \"\t\";\n    }\n    if (indentStr === \"\") return this;\n    options = options || {};\n    const isExcluded = {};\n    if (options.exclude) {\n      const exclusions = typeof options.exclude[0] === \"number\" ? [options.exclude] : options.exclude;\n      exclusions.forEach((exclusion) => {\n        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n          isExcluded[i] = true;\n        }\n      });\n    }\n    let shouldIndentNextCharacter = options.indentStart !== false;\n    const replacer = (match) => {\n      if (shouldIndentNextCharacter) return `${indentStr}${match}`;\n      shouldIndentNextCharacter = true;\n      return match;\n    };\n    this.intro = this.intro.replace(pattern, replacer);\n    let charIndex = 0;\n    let chunk = this.firstChunk;\n    while (chunk) {\n      const end = chunk.end;\n      if (chunk.edited) {\n        if (!isExcluded[charIndex]) {\n          chunk.content = chunk.content.replace(pattern, replacer);\n          if (chunk.content.length) {\n            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === \"\\n\";\n          }\n        }\n      } else {\n        charIndex = chunk.start;\n        while (charIndex < end) {\n          if (!isExcluded[charIndex]) {\n            const char = this.original[charIndex];\n            if (char === \"\\n\") {\n              shouldIndentNextCharacter = true;\n            } else if (char !== \"\\r\" && shouldIndentNextCharacter) {\n              shouldIndentNextCharacter = false;\n              if (charIndex === chunk.start) {\n                chunk.prependRight(indentStr);\n              } else {\n                this._splitChunk(chunk, charIndex);\n                chunk = chunk.next;\n                chunk.prependRight(indentStr);\n              }\n            }\n          }\n          charIndex += 1;\n        }\n      }\n      charIndex = chunk.end;\n      chunk = chunk.next;\n    }\n    this.outro = this.outro.replace(pattern, replacer);\n    return this;\n  }\n  insert() {\n    throw new Error(\n      \"magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)\"\n    );\n  }\n  insertLeft(index, content) {\n    if (!warned.insertLeft) {\n      console.warn(\n        \"magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead\"\n      );\n      warned.insertLeft = true;\n    }\n    return this.appendLeft(index, content);\n  }\n  insertRight(index, content) {\n    if (!warned.insertRight) {\n      console.warn(\n        \"magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead\"\n      );\n      warned.insertRight = true;\n    }\n    return this.prependRight(index, content);\n  }\n  move(start, end, index) {\n    if (index >= start && index <= end) throw new Error(\"Cannot move a selection inside itself\");\n    this._split(start);\n    this._split(end);\n    this._split(index);\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n    const oldLeft = first.previous;\n    const oldRight = last.next;\n    const newRight = this.byStart[index];\n    if (!newRight && last === this.lastChunk) return this;\n    const newLeft = newRight ? newRight.previous : this.lastChunk;\n    if (oldLeft) oldLeft.next = oldRight;\n    if (oldRight) oldRight.previous = oldLeft;\n    if (newLeft) newLeft.next = first;\n    if (newRight) newRight.previous = last;\n    if (!first.previous) this.firstChunk = last.next;\n    if (!last.next) {\n      this.lastChunk = first.previous;\n      this.lastChunk.next = null;\n    }\n    first.previous = newLeft;\n    last.next = newRight || null;\n    if (!newLeft) this.firstChunk = first;\n    if (!newRight) this.lastChunk = last;\n    return this;\n  }\n  overwrite(start, end, content, options) {\n    options = options || {};\n    return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n  }\n  update(start, end, content, options) {\n    if (typeof content !== \"string\") throw new TypeError(\"replacement content must be a string\");\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (end > this.original.length) throw new Error(\"end is out of bounds\");\n    if (start === end)\n      throw new Error(\n        \"Cannot overwrite a zero-length range \\u2013 use appendLeft or prependRight instead\"\n      );\n    this._split(start);\n    this._split(end);\n    if (options === true) {\n      if (!warned.storeName) {\n        console.warn(\n          \"The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string\"\n        );\n        warned.storeName = true;\n      }\n      options = { storeName: true };\n    }\n    const storeName = options !== void 0 ? options.storeName : false;\n    const overwrite = options !== void 0 ? options.overwrite : false;\n    if (storeName) {\n      const original = this.original.slice(start, end);\n      Object.defineProperty(this.storedNames, original, {\n        writable: true,\n        value: true,\n        enumerable: true\n      });\n    }\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n    if (first) {\n      let chunk = first;\n      while (chunk !== last) {\n        if (chunk.next !== this.byStart[chunk.end]) {\n          throw new Error(\"Cannot overwrite across a split point\");\n        }\n        chunk = chunk.next;\n        chunk.edit(\"\", false);\n      }\n      first.edit(content, storeName, !overwrite);\n    } else {\n      const newChunk = new Chunk2(start, end, \"\").edit(content, storeName);\n      last.next = newChunk;\n      newChunk.previous = last;\n    }\n    return this;\n  }\n  prepend(content) {\n    if (typeof content !== \"string\") throw new TypeError(\"outro content must be a string\");\n    this.intro = content + this.intro;\n    return this;\n  }\n  prependLeft(index, content) {\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byEnd[index];\n    if (chunk) {\n      chunk.prependLeft(content);\n    } else {\n      this.intro = content + this.intro;\n    }\n    return this;\n  }\n  prependRight(index, content) {\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byStart[index];\n    if (chunk) {\n      chunk.prependRight(content);\n    } else {\n      this.outro = content + this.outro;\n    }\n    return this;\n  }\n  remove(start, end) {\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (start === end) return this;\n    if (start < 0 || end > this.original.length) throw new Error(\"Character is out of bounds\");\n    if (start > end) throw new Error(\"end must be greater than start\");\n    this._split(start);\n    this._split(end);\n    let chunk = this.byStart[start];\n    while (chunk) {\n      chunk.intro = \"\";\n      chunk.outro = \"\";\n      chunk.edit(\"\");\n      chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n    }\n    return this;\n  }\n  reset(start, end) {\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (start === end) return this;\n    if (start < 0 || end > this.original.length) throw new Error(\"Character is out of bounds\");\n    if (start > end) throw new Error(\"end must be greater than start\");\n    this._split(start);\n    this._split(end);\n    let chunk = this.byStart[start];\n    while (chunk) {\n      chunk.reset();\n      chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n    }\n    return this;\n  }\n  lastChar() {\n    if (this.outro.length) return this.outro[this.outro.length - 1];\n    let chunk = this.lastChunk;\n    do {\n      if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n      if (chunk.content.length) return chunk.content[chunk.content.length - 1];\n      if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n    } while (chunk = chunk.previous);\n    if (this.intro.length) return this.intro[this.intro.length - 1];\n    return \"\";\n  }\n  lastLine() {\n    let lineIndex = this.outro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n    let lineStr = this.outro;\n    let chunk = this.lastChunk;\n    do {\n      if (chunk.outro.length > 0) {\n        lineIndex = chunk.outro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.outro + lineStr;\n      }\n      if (chunk.content.length > 0) {\n        lineIndex = chunk.content.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.content + lineStr;\n      }\n      if (chunk.intro.length > 0) {\n        lineIndex = chunk.intro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.intro + lineStr;\n      }\n    } while (chunk = chunk.previous);\n    lineIndex = this.intro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n    return this.intro + lineStr;\n  }\n  slice(start = 0, end = this.original.length) {\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    let result = \"\";\n    let chunk = this.firstChunk;\n    while (chunk && (chunk.start > start || chunk.end <= start)) {\n      if (chunk.start < end && chunk.end >= end) {\n        return result;\n      }\n      chunk = chunk.next;\n    }\n    if (chunk && chunk.edited && chunk.start !== start)\n      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n    const startChunk = chunk;\n    while (chunk) {\n      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n        result += chunk.intro;\n      }\n      const containsEnd = chunk.start < end && chunk.end >= end;\n      if (containsEnd && chunk.edited && chunk.end !== end)\n        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n      const sliceStart = startChunk === chunk ? start - chunk.start : 0;\n      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n      result += chunk.content.slice(sliceStart, sliceEnd);\n      if (chunk.outro && (!containsEnd || chunk.end === end)) {\n        result += chunk.outro;\n      }\n      if (containsEnd) {\n        break;\n      }\n      chunk = chunk.next;\n    }\n    return result;\n  }\n  // TODO deprecate this? not really very useful\n  snip(start, end) {\n    const clone = this.clone();\n    clone.remove(0, start);\n    clone.remove(end, clone.original.length);\n    return clone;\n  }\n  _split(index) {\n    if (this.byStart[index] || this.byEnd[index]) return;\n    let chunk = this.lastSearchedChunk;\n    const searchForward = index > chunk.end;\n    while (chunk) {\n      if (chunk.contains(index)) return this._splitChunk(chunk, index);\n      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n    }\n  }\n  _splitChunk(chunk, index) {\n    if (chunk.edited && chunk.content.length) {\n      const loc = getLocator(this.original)(index);\n      throw new Error(\n        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \\u2013 \"${chunk.original}\")`\n      );\n    }\n    const newChunk = chunk.split(index);\n    this.byEnd[index] = chunk;\n    this.byStart[index] = newChunk;\n    this.byEnd[newChunk.end] = newChunk;\n    if (chunk === this.lastChunk) this.lastChunk = newChunk;\n    this.lastSearchedChunk = chunk;\n    return true;\n  }\n  toString() {\n    let str = this.intro;\n    let chunk = this.firstChunk;\n    while (chunk) {\n      str += chunk.toString();\n      chunk = chunk.next;\n    }\n    return str + this.outro;\n  }\n  isEmpty() {\n    let chunk = this.firstChunk;\n    do {\n      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())\n        return false;\n    } while (chunk = chunk.next);\n    return true;\n  }\n  length() {\n    let chunk = this.firstChunk;\n    let length = 0;\n    do {\n      length += chunk.intro.length + chunk.content.length + chunk.outro.length;\n    } while (chunk = chunk.next);\n    return length;\n  }\n  trimLines() {\n    return this.trim(\"[\\\\r\\\\n]\");\n  }\n  trim(charType) {\n    return this.trimStart(charType).trimEnd(charType);\n  }\n  trimEndAborted(charType) {\n    const rx = new RegExp((charType || \"\\\\s\") + \"+$\");\n    this.outro = this.outro.replace(rx, \"\");\n    if (this.outro.length) return true;\n    let chunk = this.lastChunk;\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimEnd(rx);\n      if (chunk.end !== end) {\n        if (this.lastChunk === chunk) {\n          this.lastChunk = chunk.next;\n        }\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n      if (aborted) return true;\n      chunk = chunk.previous;\n    } while (chunk);\n    return false;\n  }\n  trimEnd(charType) {\n    this.trimEndAborted(charType);\n    return this;\n  }\n  trimStartAborted(charType) {\n    const rx = new RegExp(\"^\" + (charType || \"\\\\s\") + \"+\");\n    this.intro = this.intro.replace(rx, \"\");\n    if (this.intro.length) return true;\n    let chunk = this.firstChunk;\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimStart(rx);\n      if (chunk.end !== end) {\n        if (chunk === this.lastChunk) this.lastChunk = chunk.next;\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n      if (aborted) return true;\n      chunk = chunk.next;\n    } while (chunk);\n    return false;\n  }\n  trimStart(charType) {\n    this.trimStartAborted(charType);\n    return this;\n  }\n  hasChanged() {\n    return this.original !== this.toString();\n  }\n  _replaceRegexp(searchValue, replacement) {\n    function getReplacement(match, str) {\n      if (typeof replacement === \"string\") {\n        return replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n          if (i === \"$\") return \"$\";\n          if (i === \"&\") return match[0];\n          const num = +i;\n          if (num < match.length) return match[+i];\n          return `$${i}`;\n        });\n      } else {\n        return replacement(...match, match.index, str, match.groups);\n      }\n    }\n    function matchAll(re, str) {\n      let match;\n      const matches = [];\n      while (match = re.exec(str)) {\n        matches.push(match);\n      }\n      return matches;\n    }\n    if (searchValue.global) {\n      const matches = matchAll(searchValue, this.original);\n      matches.forEach((match) => {\n        if (match.index != null) {\n          const replacement2 = getReplacement(match, this.original);\n          if (replacement2 !== match[0]) {\n            this.overwrite(\n              match.index,\n              match.index + match[0].length,\n              replacement2\n            );\n          }\n        }\n      });\n    } else {\n      const match = this.original.match(searchValue);\n      if (match && match.index != null) {\n        const replacement2 = getReplacement(match, this.original);\n        if (replacement2 !== match[0]) {\n          this.overwrite(\n            match.index,\n            match.index + match[0].length,\n            replacement2\n          );\n        }\n      }\n    }\n    return this;\n  }\n  _replaceString(string, replacement) {\n    const { original } = this;\n    const index = original.indexOf(string);\n    if (index !== -1) {\n      this.overwrite(index, index + string.length, replacement);\n    }\n    return this;\n  }\n  replace(searchValue, replacement) {\n    if (typeof searchValue === \"string\") {\n      return this._replaceString(searchValue, replacement);\n    }\n    return this._replaceRegexp(searchValue, replacement);\n  }\n  _replaceAllString(string, replacement) {\n    const { original } = this;\n    const stringLength = string.length;\n    for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {\n      const previous = original.slice(index, index + stringLength);\n      if (previous !== replacement)\n        this.overwrite(index, index + stringLength, replacement);\n    }\n    return this;\n  }\n  replaceAll(searchValue, replacement) {\n    if (typeof searchValue === \"string\") {\n      return this._replaceAllString(searchValue, replacement);\n    }\n    if (!searchValue.global) {\n      throw new TypeError(\n        \"MagicString.prototype.replaceAll called with a non-global RegExp argument\"\n      );\n    }\n    return this._replaceRegexp(searchValue, replacement);\n  }\n};\n\n// src/core/style.ts\nvar import_path2 = __toESM(require(\"path\"));\nvar style_default = {\n  translate(tag) {\n    const {\n      hub: { file }\n    } = tag;\n    const { filename, sourceMaps } = file.opts;\n    (0, import_babel_utils32.assertNoParams)(tag);\n    assertNoSpreadAttrs(tag);\n    let type = \"text/css\";\n    const attrs2 = tag.get(\"attributes\");\n    const base = import_path2.default.basename(filename);\n    const typeAttr = attrs2.find(\n      (attr2) => attr2.isMarkoAttribute() && attr2.node.name === \"type\"\n    );\n    const classAttr2 = attrs2.find(\n      (attr2) => attr2.isMarkoAttribute() && attr2.node.name === \"class\"\n    );\n    if (typeAttr && classAttr2) {\n      throw classAttr2.buildCodeFrameError(\n        \"The `style` tag must only use `type` or `class` and not both.\"\n      );\n    } else if (typeAttr) {\n      const typeValue = typeAttr.get(\"value\");\n      if (typeValue.isStringLiteral()) {\n        type = typeValue.node.value;\n      } else {\n        throw typeValue.buildCodeFrameError(\n          \"The `style` tag `type` attribute can only be a string literal.\"\n        );\n      }\n    } else if (classAttr2) {\n      const classValue2 = classAttr2.get(\"value\");\n      if (classValue2.isStringLiteral()) {\n        type = classValue2.node.value;\n      } else {\n        throw classValue2.buildCodeFrameError(\n          \"The `style` tag `class` attribute can only be a string literal.\"\n        );\n      }\n    }\n    if (type === \"text/css\") {\n      type = \"css\";\n    }\n    if (tag.node.var && !type.startsWith(\"module\")) {\n      type = \"module.\" + type;\n    }\n    const body = tag.get(\"body\").get(\"body\");\n    const markoText = body[0];\n    if (body.length !== 1 || !markoText.isMarkoText()) {\n      throw (markoText.isMarkoText() ? body[1] : body[0]).buildCodeFrameError(\n        \"The `style` tag currently only supports static content.\"\n      );\n    }\n    const { resolveVirtualDependency } = getMarkoOpts();\n    const start = (0, import_babel_utils32.getStart)(file, markoText.node);\n    const end = (0, import_babel_utils32.getEnd)(file, markoText.node);\n    let code = markoText.node.value;\n    let map;\n    if (resolveVirtualDependency && sourceMaps && start !== null && end !== null) {\n      const magicString = new MagicString(file.code, { filename });\n      magicString.remove(0, start);\n      magicString.remove(end, file.code.length);\n      map = magicString.generateMap({\n        source: filename,\n        includeContent: true\n      });\n      if (sourceMaps === \"inline\" || sourceMaps === \"both\") {\n        code += `\n/*# sourceMappingURL=${map.toUrl()}*/`;\n        if (sourceMaps === \"inline\") {\n          map = void 0;\n        }\n      }\n    }\n    const importPath = resolveVirtualDependency?.(filename, {\n      virtualPath: `./${base}.${type}`,\n      code,\n      map\n    });\n    if (importPath) {\n      if (!tag.node.var) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler37.types.importDeclaration([], import_compiler37.types.stringLiteral(importPath))\n        );\n      } else if (import_compiler37.types.isIdentifier(tag.node.var)) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler37.types.importDeclaration(\n            [import_compiler37.types.importDefaultSpecifier(tag.node.var)],\n            import_compiler37.types.stringLiteral(importPath)\n          )\n        );\n      } else {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler37.types.variableDeclaration(\"const\", [\n            import_compiler37.types.variableDeclarator(\n              tag.node.var,\n              (0, import_babel_utils32.importDefault)(file, importPath, \"style\")\n            )\n          ])\n        );\n      }\n    }\n    tag.remove();\n  },\n  attributes: {}\n};\n\n// src/core/index.ts\nvar core_default = {\n  taglibId,\n  \"<import>\": import_default,\n  \"<export>\": export_default,\n  \"<attrs>\": attrs_default,\n  \"<if>\": if_default,\n  \"<else-if>\": else_if_default,\n  \"<else>\": else_default,\n  \"<for>\": for_default,\n  \"<let>\": let_default,\n  \"<const>\": const_default,\n  \"<define>\": define_default,\n  \"<effect>\": effect_default,\n  \"<do>\": do_default,\n  \"<log>\": log_default,\n  \"<debug>\": debug_default,\n  \"<lifecycle>\": lifecycle_default,\n  \"<id>\": id_default,\n  \"<html-comment>\": html_comment_default,\n  \"<return>\": return_default,\n  \"<style>\": style_default,\n  \"<await-reorderer>\": noop_default,\n  \"<init-widgets>\": noop_default,\n  \"<init-components>\": noop_default,\n  \"<static>\": static_default,\n  \"<server>\": server_default,\n  \"<client>\": client_default,\n  \"<__flush_here_and_after__>\": flush_here_and_after_default\n};\n\n// src/visitors/assignment-expression.ts\nvar import_compiler38 = require(\"@marko/compiler\");\nvar assignment_expression_default = {\n  translate: {\n    exit(assignment) {\n      if (isOutputDOM()) {\n        handleDestructure2(assignment, assignment.node.left);\n      }\n    }\n  }\n};\nfunction handleDestructure2(assignment, node) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        handleDestructure2(assignment, prop);\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const i in node.elements) {\n        if (node.elements[i] === null) continue;\n        handleDestructure2(assignment, node.elements[i]);\n      }\n      break;\n    case \"RestElement\":\n      handleDestructure2(assignment, node.argument);\n      break;\n    case \"ObjectProperty\":\n      handleDestructure2(assignment, node.value);\n      break;\n    case \"Identifier\": {\n      const source = node.extra?.source;\n      if (source) {\n        const section = getSection(assignment);\n        (currentProgramPath.node.extra.assignments ??= []).push([\n          section,\n          assignment\n        ]);\n      }\n      break;\n    }\n  }\n}\n\n// src/visitors/cdata.ts\nvar cdata_default = {\n  translate: {\n    exit(cdata) {\n      if (isOutputHTML()) {\n        writeTo(cdata)`<![CDATA[${cdata.node.value}]]>`;\n      }\n      cdata.remove();\n    }\n  }\n};\n\n// src/visitors/comment.ts\nvar comment_default = {\n  translate: {\n    exit(comment) {\n      comment.remove();\n    }\n  }\n};\n\n// src/visitors/declaration.ts\nvar declaration_default = {\n  translate: {\n    exit(declaration) {\n      if (isOutputHTML()) {\n        writeTo(declaration)`<?${declaration.node.value}?>`;\n      }\n      declaration.remove();\n    }\n  }\n};\n\n// src/visitors/document-type.ts\nvar document_type_default = {\n  translate: {\n    exit(documentType) {\n      if (isOutputHTML()) {\n        writeTo(documentType)`<!${documentType.node.value}>`;\n      }\n      documentType.remove();\n    }\n  }\n};\n\n// src/visitors/function.ts\nvar import_babel_utils33 = require(\"@marko/babel-utils\");\nvar import_compiler39 = require(\"@marko/compiler\");\nvar functionIdsBySection = /* @__PURE__ */ new WeakMap();\nvar registeredFunctions = /* @__PURE__ */ new WeakSet();\nvar function_default = {\n  analyze(fn) {\n    const markoRoot = getMarkoRoot(fn);\n    const isStatic2 = !markoRoot || markoRoot.isMarkoScriptlet({ static: true });\n    if (!isFunction(fn, isStatic2)) return;\n    if (markoRoot && (markoRoot.isMarkoPlaceholder() || markoRoot.isMarkoScriptlet({ target: \"server\" }))) {\n      return;\n    }\n    const { node } = fn;\n    const extra = node.extra ??= {};\n    const name = extra.name = fn.node.id?.name || (markoRoot?.isMarkoAttribute() ? markoRoot.node.default ? import_compiler39.types.toIdentifier(\n      markoRoot.parentPath.parentPath.get(\n        \"name\"\n      )\n    ) : markoRoot.node.name : \"anonymous\");\n    if (markoRoot && markoRoot.isMarkoAttribute() && ((0, import_babel_utils33.isNativeTag)(markoRoot.parentPath) || isCoreTagName(markoRoot.parentPath, \"effect\") || isCoreTagName(markoRoot.parentPath, \"lifecycle\") || isCoreTagName(markoRoot.parentPath, \"for\") || isCoreTagName(markoRoot.parentPath, \"do\"))) {\n      return;\n    }\n    const {\n      markoOpts,\n      opts: { filename }\n    } = currentProgramPath.hub.file;\n    const section = getSection(fn);\n    let functionNameCounts = functionIdsBySection.get(section);\n    if (!functionNameCounts) {\n      functionNameCounts = /* @__PURE__ */ new Map();\n      functionIdsBySection.set(section, functionNameCounts);\n    }\n    const index = functionNameCounts.get(name);\n    let id = \"\";\n    if (index === void 0) {\n      functionNameCounts.set(name, 0);\n    } else {\n      id = `_${index}`;\n    }\n    extra.registerId = (0, import_babel_utils33.getTemplateId)(\n      markoOpts,\n      filename,\n      `${section.id}/${name + id}`\n    );\n  },\n  translate: {\n    exit(fn) {\n      const markoRoot = getMarkoRoot(fn);\n      const isStatic2 = !markoRoot || markoRoot.isMarkoScriptlet({ static: true });\n      if (!isFunction(fn, isStatic2)) return;\n      const { node } = fn;\n      const { extra } = node;\n      if (!extra?.registerId) return;\n      if (registeredFunctions.has(node)) return;\n      const section = getSection(fn);\n      if (!section) return;\n      registeredFunctions.add(node);\n      if (isOutputHTML()) {\n        const serializedScopeProperties = getSerializedScopeProperties(section);\n        forEach(extra.referencedBindings, (ref) => {\n          serializedScopeProperties.set(\n            getScopeAccessorLiteral(ref),\n            import_compiler39.types.identifier(ref.name)\n          );\n        });\n        if (import_compiler39.types.isFunctionDeclaration(node)) {\n          currentProgramPath.unshiftContainer(\n            \"body\",\n            import_compiler39.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                node.id,\n                import_compiler39.types.stringLiteral(extra.registerId),\n                isStatic2 ? void 0 : getScopeIdIdentifier(section)\n              )\n            )\n          )[0].skip();\n        } else {\n          const replacement = callRuntime(\n            \"register\",\n            node,\n            import_compiler39.types.stringLiteral(extra.registerId),\n            isStatic2 ? void 0 : getScopeIdIdentifier(section)\n          );\n          if (isMarko(fn.parentPath)) {\n            replacement.extra = node.extra;\n          }\n          fn.replaceWith(replacement)[0].skip();\n        }\n      } else {\n        const { referencedBindings } = extra;\n        const fnId = currentProgramPath.scope.generateUidIdentifier(extra.name);\n        if (import_compiler39.types.isFunctionDeclaration(node)) {\n          currentProgramPath.unshiftContainer(\n            \"body\",\n            import_compiler39.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                import_compiler39.types.stringLiteral(extra.registerId),\n                node.id\n              )\n            )\n          )[0].skip();\n        } else if (isStatic2) {\n          const replacement = callRuntime(\n            \"register\",\n            import_compiler39.types.stringLiteral(extra.registerId),\n            node\n          );\n          if (isMarko(fn.parentPath)) {\n            replacement.extra = node.extra;\n          }\n          fn.replaceWith(replacement)[0].skip();\n        } else {\n          const replacement = import_compiler39.types.callExpression(fnId, [scopeIdentifier]);\n          if (isMarko(fn.parentPath)) {\n            replacement.extra = node.extra;\n          }\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler39.types.variableDeclaration(\"const\", [\n              import_compiler39.types.variableDeclarator(\n                fnId,\n                callRuntime(\n                  \"register\",\n                  import_compiler39.types.stringLiteral(extra.registerId),\n                  import_compiler39.types.arrowFunctionExpression(\n                    [scopeIdentifier],\n                    referencedBindings ? import_compiler39.types.blockStatement([\n                      import_compiler39.types.variableDeclaration(\"const\", [\n                        import_compiler39.types.variableDeclarator(\n                          createScopeReadPattern(\n                            section,\n                            referencedBindings\n                          ),\n                          scopeIdentifier\n                        )\n                      ]),\n                      import_compiler39.types.returnStatement(node)\n                    ]) : node\n                  )\n                )\n              )\n            ])\n          )[0].skip();\n          fn.replaceWith(replacement)[0].skip();\n        }\n      }\n    }\n  }\n};\nfunction isFunction(fn, isStatic2) {\n  switch (fn.node.type) {\n    case \"FunctionDeclaration\":\n      return isStatic2;\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// src/visitors/import-declaration.ts\nvar import_babel_utils34 = require(\"@marko/babel-utils\");\nvar import_declaration_default = {\n  analyze(importDecl) {\n    const { node } = importDecl;\n    const { source } = node;\n    const { value } = source;\n    const tagImport = (0, import_babel_utils34.resolveTagImport)(importDecl, value);\n    if (tagImport) {\n      node.extra ??= {};\n      node.extra.tagImport = tagImport;\n      const tags = importDecl.hub.file.metadata.marko.tags;\n      if (!tags.includes(tagImport)) {\n        tags.push(tagImport);\n      }\n    }\n  },\n  translate: {\n    exit(importDecl) {\n      const { node } = importDecl;\n      const { extra } = node;\n      const tagImport = extra?.tagImport;\n      if (tagImport) {\n        node.source.value = tagImport;\n      }\n    }\n  }\n};\n\n// src/visitors/placeholder.ts\nvar import_babel_utils35 = require(\"@marko/babel-utils\");\nvar import_compiler40 = require(\"@marko/compiler\");\nvar kBinding2 = Symbol(\"placeholder node binding\");\nvar kSiblingText = Symbol(\"placeholder has sibling text\");\nvar ESCAPE_TYPES = {\n  script: \"escapeScript\",\n  style: \"escapeStyle\"\n};\nvar placeholder_default = {\n  analyze(placeholder) {\n    const { node } = placeholder;\n    const { confident, computed } = evaluate(placeholder);\n    if (!(confident && (node.escape || !computed))) {\n      (node.extra ??= {})[kBinding2] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        getOrCreateSection(placeholder),\n        void 0,\n        node.value.extra\n      );\n      analyzeSiblingText(placeholder);\n    }\n  },\n  translate: {\n    exit(placeholder) {\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(placeholder);\n      const { node } = placeholder;\n      const { value } = node;\n      const extra = node.extra;\n      const { confident, computed } = extra;\n      const nodeBinding = extra[kBinding2];\n      const canWriteHTML = isHTML || confident && (node.escape || !computed);\n      const method = canWriteHTML ? node.escape ? ESCAPE_TYPES[getParentTagName(placeholder)] || \"escapeXML\" : \"toString\" : node.escape ? \"data\" : \"html\";\n      const isStateful = isStatefulReferences(value.extra?.referencedBindings);\n      const siblingText = extra[kSiblingText];\n      if (confident && canWriteHTML) {\n        write2`${getHTMLRuntime()[method](computed)}`;\n      } else {\n        if (siblingText === 1 /* Before */) {\n          if (isHTML && isStateful) {\n            write2`<!>`;\n          }\n          visit(placeholder, 37 /* Replace */);\n        } else if (siblingText === 2 /* After */) {\n          visit(placeholder, 37 /* Replace */);\n        } else {\n          if (!isHTML) write2` `;\n          visit(placeholder, 32 /* Get */);\n        }\n        if (isHTML) {\n          write2`${callRuntime(method, value)}`;\n          if (isStateful) {\n            markNode(placeholder, nodeBinding);\n          }\n        } else {\n          addStatement(\n            \"render\",\n            getSection(placeholder),\n            value.extra?.referencedBindings,\n            import_compiler40.types.expressionStatement(\n              method === \"data\" ? callRuntime(\n                \"data\",\n                import_compiler40.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(nodeBinding),\n                  true\n                ),\n                value\n              ) : callRuntime(\n                \"html\",\n                scopeIdentifier,\n                value,\n                getScopeAccessorLiteral(nodeBinding)\n              )\n            )\n          );\n        }\n      }\n      enterShallow(placeholder);\n      placeholder.remove();\n    }\n  }\n};\nfunction getParentTagName({ parentPath }) {\n  return parentPath.isMarkoTag() && (0, import_babel_utils35.isNativeTag)(parentPath) && parentPath.node.name.value || \"\";\n}\nfunction analyzeSiblingText(placeholder) {\n  const placeholderExtra = placeholder.node.extra;\n  let prev = placeholder.getPrevSibling();\n  while (prev.node) {\n    const contentType = getNodeContentType(\n      prev,\n      \"endNodeContentType\"\n    );\n    if (contentType === 2 /* Empty */) {\n      prev = prev.getPrevSibling();\n    } else if (contentType === 5 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 3 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 1 /* Before */;\n    } else {\n      break;\n    }\n  }\n  if (!prev.node && import_compiler40.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 1 /* Before */;\n  }\n  let next = placeholder.getNextSibling();\n  while (next.node) {\n    const contentType = getNodeContentType(\n      next,\n      \"startNodeContentType\"\n    );\n    if (contentType === 2 /* Empty */) {\n      next = next.getNextSibling();\n    } else if (contentType === 5 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 3 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 2 /* After */;\n    } else {\n      break;\n    }\n  }\n  if (!next.node && import_compiler40.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 2 /* After */;\n  }\n  return placeholderExtra[kSiblingText] = 0 /* None */;\n}\n\n// src/visitors/referenced-identifier.ts\nvar import_compiler41 = require(\"@marko/compiler\");\nvar abortIdsByExpressionForSection = /* @__PURE__ */ new WeakMap();\nvar referenced_identifier_default = {\n  migrate(identifier) {\n    const { name } = identifier.node;\n    if (identifier.scope.hasBinding(name)) return;\n    switch (name) {\n      case \"out\":\n        if (import_compiler41.types.isMemberExpression(identifier.parent) && import_compiler41.types.isIdentifier(identifier.parent.property) && identifier.parent.property.name === \"global\") {\n          identifier.parentPath.replaceWith(import_compiler41.types.identifier(\"$global\"));\n        } else {\n          throw identifier.buildCodeFrameError(\n            \"Only `out.global` is supported for compatibility.\"\n          );\n        }\n        break;\n    }\n  },\n  translate(identifier) {\n    const { name } = identifier.node;\n    if (identifier.scope.hasBinding(name)) return;\n    switch (name) {\n      case \"$global\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler41.types.memberExpression(\n              import_compiler41.types.callExpression(importRuntime(\"getStreamData\"), []),\n              import_compiler41.types.identifier(\"global\")\n            )\n          );\n        } else {\n          identifier.replaceWith(\n            import_compiler41.types.memberExpression(scopeIdentifier, import_compiler41.types.identifier(\"$global\"))\n          );\n        }\n        break;\n      case \"$signal\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler41.types.callExpression(\n              import_compiler41.types.arrowFunctionExpression(\n                [],\n                import_compiler41.types.blockStatement([\n                  import_compiler41.types.throwStatement(\n                    import_compiler41.types.newExpression(import_compiler41.types.identifier(\"Error\"), [\n                      import_compiler41.types.stringLiteral(\"Cannot use $signal in a server render.\")\n                    ])\n                  )\n                ])\n              ),\n              []\n            )\n          );\n        } else {\n          const section = getSection(identifier);\n          const exprRoot = getExprRoot(identifier);\n          let abortIdsByExpression = abortIdsByExpressionForSection.get(section);\n          let exprId;\n          if (abortIdsByExpression) {\n            exprId = abortIdsByExpression.get(exprRoot);\n          } else {\n            abortIdsByExpression = /* @__PURE__ */ new Map();\n            abortIdsByExpressionForSection.set(section, abortIdsByExpression);\n          }\n          if (!exprId) {\n            exprId = abortIdsByExpression.size;\n            abortIdsByExpression.set(exprRoot, exprId);\n            addStatement(\n              \"render\",\n              section,\n              exprRoot.node.extra?.referencedBindings,\n              import_compiler41.types.expressionStatement(\n                import_compiler41.types.callExpression(importRuntime(\"resetAbortSignal\"), [\n                  scopeIdentifier,\n                  import_compiler41.types.numericLiteral(exprId)\n                ])\n              )\n            );\n          }\n          identifier.replaceWith(\n            import_compiler41.types.callExpression(importRuntime(\"getAbortSignal\"), [\n              scopeIdentifier,\n              import_compiler41.types.numericLiteral(exprId)\n            ])\n          );\n        }\n    }\n  }\n};\n\n// src/visitors/scriptlet.ts\nvar scriptlet_default = {\n  analyze(scriptlet) {\n    mergeReferences(scriptlet, scriptlet.node.body);\n  },\n  translate: {\n    exit(scriptlet) {\n      const { node } = scriptlet;\n      if (isOutputHTML()) {\n        if (node.static) return;\n        scriptlet.replaceWithMultiple(node.body);\n      } else {\n        if (node.target && node.target !== \"client\") {\n          scriptlet.remove();\n        } else if (node.static) {\n          scriptlet.replaceWithMultiple(node.body);\n        } else {\n          addStatement(\n            \"render\",\n            getSection(scriptlet),\n            node.extra?.referencedBindings,\n            node.body\n          );\n          scriptlet.remove();\n        }\n      }\n    }\n  }\n};\n\n// src/visitors/tag/index.ts\nvar import_babel_utils39 = require(\"@marko/babel-utils\");\nvar import_compiler47 = require(\"@marko/compiler\");\n\n// src/util/plugin-hooks.ts\nvar import_compiler42 = require(\"@marko/compiler\");\nfunction enter2(modulePlugin, path3) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path3;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (isFunctionPlugin(plugin)) {\n    plugin(path3, import_compiler42.types);\n  } else if (plugin.enter) {\n    plugin.enter(path3, import_compiler42.types);\n  }\n  return node !== path3.node;\n}\nfunction exit2(modulePlugin, path3) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path3;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (!isFunctionPlugin(plugin) && plugin.exit) {\n    plugin.exit(path3, import_compiler42.types);\n  }\n  return node !== path3.node;\n}\nfunction isModulePlugin(plugin) {\n  return Boolean(plugin.default);\n}\nfunction isFunctionPlugin(plugin) {\n  return typeof plugin === \"function\";\n}\n\n// src/visitors/tag/attribute-tag.ts\nvar import_babel_utils36 = require(\"@marko/babel-utils\");\nvar import_compiler43 = require(\"@marko/compiler\");\nvar attribute_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils36.assertNoVar)(tag);\n      (0, import_babel_utils36.assertNoArgs)(tag);\n      startSection(tag.get(\"body\"));\n    }\n  },\n  translate: {\n    exit(tag) {\n      const parentTag = (0, import_babel_utils36.findParentTag)(tag);\n      if (!parentTag) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags must be nested within another tag.\");\n      }\n      const parentExtra = parentTag.node.extra;\n      if (parentExtra.tagNameType === 0 /* NativeTag */) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags cannot be nested under native tags.\");\n      }\n      if (isOutputHTML()) {\n        flushInto(tag);\n      } else {\n        tag.node.attributes.push(\n          import_compiler43.types.markoAttribute(\n            \"renderBody\",\n            callRuntime(\n              \"bindRenderer\",\n              scopeIdentifier,\n              import_compiler43.types.identifier(getSection(tag.get(\"body\")).name)\n            )\n          )\n        );\n      }\n      const attrName = tag.node.name.value.slice(1);\n      const info = parentExtra.nestedAttributeTags[attrName];\n      const attrsObject = attrsToObject(tag, true);\n      if (info.dynamic) {\n        if (!info.identifier) {\n          info.identifier = parentTag.scope.generateUidIdentifier(attrName);\n          parentTag.insertBefore(\n            info.repeated ? import_compiler43.types.variableDeclaration(\"const\", [\n              import_compiler43.types.variableDeclarator(info.identifier, import_compiler43.types.arrayExpression([]))\n            ]) : import_compiler43.types.variableDeclaration(\"let\", [\n              import_compiler43.types.variableDeclarator(info.identifier)\n            ])\n          );\n          parentTag.pushContainer(\n            \"attributes\",\n            import_compiler43.types.markoAttribute(attrName, info.identifier)\n          );\n        }\n        tag.replaceWith(\n          import_compiler43.types.expressionStatement(\n            info.repeated ? import_compiler43.types.callExpression(\n              import_compiler43.types.memberExpression(info.identifier, import_compiler43.types.identifier(\"push\")),\n              [attrsObject]\n            ) : import_compiler43.types.assignmentExpression(\"=\", info.identifier, attrsObject)\n          )\n        );\n      } else if (info.repeated) {\n        const existingAttr = parentTag.get(\"attributes\").find((attr2) => attr2.node.name === attrName);\n        if (existingAttr) {\n          existingAttr.get(\"value\").pushContainer(\"elements\", attrsObject);\n        } else {\n          parentTag.pushContainer(\n            \"attributes\",\n            import_compiler43.types.markoAttribute(attrName, import_compiler43.types.arrayExpression([attrsObject]))\n          );\n        }\n        tag.remove();\n      } else {\n        parentTag.pushContainer(\n          \"attributes\",\n          import_compiler43.types.markoAttribute(attrName, attrsObject)\n        );\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/visitors/tag/custom-tag.ts\nvar import_babel_utils37 = require(\"@marko/babel-utils\");\nvar import_compiler44 = require(\"@marko/compiler\");\nvar kChildScopeBinding = Symbol(\"custom tag child scope\");\nvar custom_tag_default = {\n  analyze: {\n    enter(tag) {\n      const section = getOrCreateSection(tag);\n      const tagBody = tag.get(\"body\");\n      startSection(tagBody);\n      trackVarReferences(tag, 4 /* derived */);\n      trackParamsReferences(tagBody, 3 /* param */);\n      if ((0, import_babel_utils37.getTagTemplate)(tag)) {\n        const tagExtra = tag.node.extra ??= {};\n        tagExtra[kChildScopeBinding] = createBinding(\n          \"#childScope\",\n          0 /* dom */,\n          section,\n          void 0,\n          tagExtra\n        );\n      }\n      const childFile = (0, import_babel_utils37.loadFileForTag)(tag);\n      const childProgramExtra = childFile?.ast.program.extra;\n      const hasInteractiveChild = childProgramExtra?.isInteractive || childProgramExtra?.hasInteractiveChild;\n      const inputExport = childProgramExtra?.domExports?.params?.props?.[0];\n      if (!inputExport?.props || tag.node.attributes.find((attr2) => import_compiler44.types.isMarkoSpreadAttribute(attr2))) {\n        mergeReferences(\n          tag,\n          tag.node.attributes.map((attr2) => attr2.value)\n        );\n      }\n      if (hasInteractiveChild) {\n        (currentProgramPath.node.extra ?? {}).hasInteractiveChild = true;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      (0, import_babel_utils37.assertAttributesOrSingleArg)(tag);\n      visit(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML2(tag);\n      } else {\n        translateDOM2(tag);\n      }\n    }\n  }\n};\nfunction translateHTML2(tag) {\n  const tagBody = tag.get(\"body\");\n  const { node } = tag;\n  let tagIdentifier;\n  flushInto(tag);\n  writeHTMLResumeStatements(tagBody);\n  if (import_compiler44.types.isStringLiteral(node.name)) {\n    const { file } = tag.hub;\n    const tagName = node.name.value;\n    const relativePath = getTagRelativePath(tag);\n    tagIdentifier = import_compiler44.types.memberExpression(\n      (0, import_babel_utils37.importDefault)(file, relativePath, tagName),\n      import_compiler44.types.identifier(\"_\")\n    );\n  } else {\n    tagIdentifier = import_compiler44.types.memberExpression(node.name, import_compiler44.types.identifier(\"_\"));\n  }\n  const tagVar = node.var;\n  const attrsObject = attrsToObject(tag, true);\n  const renderBodyProp = getRenderBodyProp(attrsObject);\n  const section = getSection(tag);\n  const childScopeBinding = node.extra[kChildScopeBinding];\n  const peekScopeId = tag.scope.generateUidIdentifier(childScopeBinding?.name);\n  tag.insertBefore(\n    import_compiler44.types.variableDeclaration(\"const\", [\n      import_compiler44.types.variableDeclarator(peekScopeId, callRuntime(\"peekNextScope\"))\n    ])\n  );\n  getSerializedScopeProperties(section).set(\n    getScopeAccessorLiteral(childScopeBinding),\n    peekScopeId\n  );\n  if (node.extra.tagNameNullable) {\n    let renderBodyId = void 0;\n    let renderTagExpr = callExpression(\n      tagIdentifier,\n      attrsToObject(tag)\n    );\n    if (renderBodyProp) {\n      renderBodyId = tag.scope.generateUidIdentifier(\"renderBody\");\n      const renderBodySection = getSection(tag.get(\"body\"));\n      const [renderBodyPath] = tag.insertBefore(\n        import_compiler44.types.variableDeclaration(\"const\", [\n          import_compiler44.types.variableDeclarator(\n            renderBodyId,\n            // TODO: only register if needed (child template analysis)\n            callRuntime(\n              \"register\",\n              callRuntime(\n                \"createRenderer\",\n                import_compiler44.types.arrowFunctionExpression(\n                  renderBodyProp.params,\n                  renderBodyProp.body\n                )\n              ),\n              import_compiler44.types.stringLiteral(\n                getResumeRegisterId(renderBodySection, \"renderer\")\n              ),\n              renderBodySection.closures.size && getScopeIdIdentifier(renderBodySection.parent)\n            )\n          )\n        ])\n      );\n      renderBodyPath.skip();\n      attrsObject.properties[attrsObject.properties.length - 1] = import_compiler44.types.objectProperty(import_compiler44.types.identifier(\"renderBody\"), renderBodyId);\n    }\n    if (tagVar) {\n      translateVar(tag, import_compiler44.types.unaryExpression(\"void\", import_compiler44.types.numericLiteral(0)), \"let\");\n      renderTagExpr = import_compiler44.types.assignmentExpression(\"=\", tagVar, renderTagExpr);\n    }\n    tag.replaceWith(\n      import_compiler44.types.ifStatement(\n        tagIdentifier,\n        import_compiler44.types.expressionStatement(renderTagExpr),\n        renderBodyId && callStatement(renderBodyId)\n      )\n    )[0].skip();\n  } else if (tagVar) {\n    translateVar(\n      tag,\n      callExpression(\n        tagIdentifier,\n        attrsObject,\n        callRuntime(\n          \"register\",\n          callRuntime(\n            \"createRenderer\",\n            import_compiler44.types.arrowFunctionExpression([], import_compiler44.types.blockStatement([]))\n          ),\n          import_compiler44.types.stringLiteral(\n            getResumeRegisterId(\n              section,\n              node.var.extra?.binding\n              // TODO: node.var is not always an identifier.\n            )\n          ),\n          getScopeIdIdentifier(section)\n        )\n      )\n    );\n    setForceResumeScope(section);\n    tag.remove();\n  } else {\n    tag.replaceWith(callStatement(tagIdentifier, attrsObject))[0].skip();\n  }\n}\nfunction translateDOM2(tag) {\n  const tagSection = getSection(tag);\n  const tagBody = tag.get(\"body\");\n  const tagBodySection = getSection(tagBody);\n  const { node } = tag;\n  const extra = node.extra;\n  const childScopeBinding = extra[kChildScopeBinding];\n  const write2 = writeTo(tag);\n  const { file } = tag.hub;\n  const tagName = import_compiler44.types.isIdentifier(node.name) ? node.name.name : import_compiler44.types.isStringLiteral(node.name) ? node.name.value : \"tag\";\n  const relativePath = getTagRelativePath(tag);\n  const childFile = (0, import_babel_utils37.loadFileForTag)(tag);\n  const childProgram = childFile.ast.program;\n  const tagIdentifier = (0, import_babel_utils37.importNamed)(\n    file,\n    relativePath,\n    childProgram.extra.domExports.setup,\n    tagName\n  );\n  const inputExport = childProgram.extra.domExports.params?.props?.[0];\n  if (inputExport) {\n    if (!inputExport.props || tag.node.attributes.some((attr2) => import_compiler44.types.isMarkoSpreadAttribute(attr2))) {\n      let attrsObject = attrsToObject(tag);\n      if (tagBodySection !== tagSection) {\n        attrsObject ??= import_compiler44.types.objectExpression([]);\n        attrsObject.properties.push(\n          import_compiler44.types.objectProperty(\n            import_compiler44.types.identifier(\"renderBody\"),\n            callRuntime(\n              \"bindRenderer\",\n              scopeIdentifier,\n              import_compiler44.types.identifier(tagBodySection.name)\n            )\n          )\n        );\n      }\n      const tagAttrsIdentifier = (0, import_babel_utils37.importNamed)(\n        file,\n        relativePath,\n        inputExport.id,\n        `${tagName}_input`\n      );\n      addValue(\n        tagSection,\n        extra.referencedBindings,\n        {\n          identifier: tagAttrsIdentifier,\n          hasDownstreamIntersections: () => true\n        },\n        attrsObject,\n        createScopeReadExpression(tagSection, childScopeBinding),\n        callRuntime(\n          \"inChild\",\n          getScopeAccessorLiteral(childScopeBinding),\n          import_compiler44.types.identifier(tagAttrsIdentifier.name)\n        )\n      );\n    } else {\n      for (const attrPath of tag.get(\n        \"attributes\"\n      )) {\n        const attr2 = attrPath.node;\n        const attrExport = inputExport.props[attr2.name];\n        if (attrExport) {\n          const attrExportIdentifier = (0, import_babel_utils37.importNamed)(\n            file,\n            relativePath,\n            attrExport.id,\n            `${tagName}_${attrExport.id}`\n          );\n          const attrReferences = attr2.value.extra?.referencedBindings;\n          addValue(\n            tagSection,\n            attrReferences,\n            {\n              identifier: attrExportIdentifier,\n              hasDownstreamIntersections: () => true\n            },\n            attr2.value,\n            createScopeReadExpression(tagSection, childScopeBinding),\n            callRuntime(\n              \"inChild\",\n              getScopeAccessorLiteral(childScopeBinding),\n              import_compiler44.types.identifier(attrExportIdentifier.name)\n            )\n          );\n        }\n      }\n      if (inputExport.props.renderBody && tagBodySection !== tagSection) {\n        const renderBodyExportIdentifier = (0, import_babel_utils37.importNamed)(\n          file,\n          relativePath,\n          inputExport.props.renderBody.id,\n          `${tagName}_renderBody`\n        );\n        addValue(\n          tagSection,\n          void 0,\n          {\n            identifier: renderBodyExportIdentifier,\n            hasDownstreamIntersections: () => true\n          },\n          callRuntime(\n            \"bindRenderer\",\n            scopeIdentifier,\n            import_compiler44.types.identifier(tagBodySection.name)\n          ),\n          createScopeReadExpression(tagSection, childScopeBinding),\n          callRuntime(\n            \"inChild\",\n            getScopeAccessorLiteral(childScopeBinding),\n            import_compiler44.types.identifier(renderBodyExportIdentifier.name)\n          )\n        );\n      }\n    }\n  }\n  write2`${(0, import_babel_utils37.importNamed)(file, relativePath, childProgram.extra.domExports.template, `${tagName}_template`)}`;\n  injectWalks(\n    tag,\n    (0, import_babel_utils37.importNamed)(\n      file,\n      relativePath,\n      childProgram.extra.domExports.walks,\n      `${tagName}_walks`\n    )\n  );\n  if (node.var) {\n    const source = initValue(\n      // TODO: support destructuring\n      node.var.extra.binding\n    );\n    source.register = true;\n    addStatement(\n      \"render\",\n      tagSection,\n      void 0,\n      import_compiler44.types.expressionStatement(\n        callRuntime(\n          \"setTagVar\",\n          scopeIdentifier,\n          getScopeAccessorLiteral(childScopeBinding),\n          source.identifier\n        )\n      )\n    );\n  }\n  addStatement(\n    \"render\",\n    tagSection,\n    void 0,\n    import_compiler44.types.expressionStatement(\n      import_compiler44.types.callExpression(tagIdentifier, [\n        createScopeReadExpression(tagSection, childScopeBinding)\n      ])\n    )\n  );\n  tag.remove();\n}\nfunction getTagRelativePath(tag) {\n  const {\n    node,\n    hub: { file }\n  } = tag;\n  const nameIsString = import_compiler44.types.isStringLiteral(node.name);\n  let relativePath;\n  if (nameIsString) {\n    const template = (0, import_babel_utils37.getTagTemplate)(tag);\n    relativePath = template && (0, import_babel_utils37.resolveRelativePath)(file, template);\n  } else if (node.extra?.tagNameImported) {\n    relativePath = node.extra.tagNameImported;\n  }\n  if (!relativePath) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `Unable to find entry point for custom tag \\`${nameIsString ? node.name.value : node.name}\\`.`\n    );\n  }\n  const tags = file.metadata.marko.tags;\n  if (!tags.includes(relativePath)) {\n    tags.push(relativePath);\n  }\n  return relativePath;\n}\nfunction callStatement(id, ...args) {\n  return import_compiler44.types.expressionStatement(callExpression(id, ...args));\n}\nfunction callExpression(id, ...args) {\n  return import_compiler44.types.callExpression(id, args.filter(Boolean));\n}\n\n// src/visitors/tag/dynamic-tag.ts\nvar import_babel_utils38 = require(\"@marko/babel-utils\");\nvar import_compiler46 = require(\"@marko/compiler\");\n\n// src/util/to-first-expression-or-block.ts\nvar import_compiler45 = require(\"@marko/compiler\");\nfunction toFirstExpressionOrBlock(body) {\n  const nodes = body.body;\n  if (nodes.length === 1 && import_compiler45.types.isExpressionStatement(nodes[0])) {\n    return nodes[0].expression;\n  }\n  if (import_compiler45.types.isBlockStatement(body)) {\n    return body;\n  }\n  return import_compiler45.types.blockStatement(nodes);\n}\n\n// src/visitors/tag/dynamic-tag.ts\nvar kDOMBinding = Symbol(\"dynamic tag dom binding\");\nvar dynamic_tag_default = {\n  analyze: {\n    enter(tag) {\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      const tagBody = tag.get(\"body\");\n      const domBinding = tagExtra[kDOMBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section,\n        void 0,\n        tagExtra\n      );\n      startSection(tagBody);\n      trackVarReferences(tag, 4 /* derived */);\n      trackParamsReferences(tagBody, 3 /* param */);\n      const referenceNodes = [];\n      if (tag.node.arguments) {\n        for (const arg of tag.node.arguments) {\n          referenceNodes.push(arg);\n        }\n      }\n      for (const attr2 of tag.node.attributes) {\n        referenceNodes.push(attr2.value);\n      }\n      mergeReferences(tag, referenceNodes);\n      addReferenceToExpression(tag, domBinding);\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag, 37 /* Replace */);\n      (0, import_babel_utils38.assertAttributesOrArgs)(tag);\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const extra = node.extra;\n      const nodeRef = extra[kDOMBinding];\n      let tagExpression = node.name;\n      if (import_compiler46.types.isStringLiteral(tagExpression)) {\n        const { file } = tag.hub;\n        const relativePath = getTagRelativePath(tag);\n        tagExpression = (0, import_babel_utils38.importDefault)(file, relativePath, tagExpression.value);\n      }\n      if (extra.featureType === \"class\") {\n        const { markoOpts } = tag.hub.file;\n        const compatRuntimeFile = `marko/src/runtime/helpers/tags-compat/${isOutputHTML() ? \"html\" : \"dom\"}${markoOpts.optimize ? \"\" : \"-debug\"}.${markoOpts.modules === \"esm\" ? \"mjs\" : \"js\"}`;\n        (0, import_babel_utils38.importDefault)(tag.hub.file, compatRuntimeFile);\n        if (isOutputHTML()) {\n          const serialized5to6 = (0, import_babel_utils38.importNamed)(\n            tag.hub.file,\n            compatRuntimeFile,\n            \"s\"\n          );\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler46.types.expressionStatement(\n              import_compiler46.types.callExpression(serialized5to6, [\n                import_compiler46.types.identifier(tagExpression.name),\n                import_compiler46.types.stringLiteral((0, import_babel_utils38.loadFileForTag)(tag).metadata.marko.id)\n              ])\n            )\n          );\n        } else {\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler46.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                import_compiler46.types.stringLiteral((0, import_babel_utils38.loadFileForTag)(tag).metadata.marko.id),\n                import_compiler46.types.identifier(tagExpression.name)\n              )\n            )\n          );\n        }\n      }\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        const attrsObject = attrsToObject(tag, true);\n        const renderBodyProp = getRenderBodyProp(attrsObject);\n        const args = [\n          tagExpression,\n          attrsObject\n        ];\n        if (import_compiler46.types.isObjectExpression(attrsObject) && renderBodyProp) {\n          const renderBodySection = getSection(tag.get(\"body\"));\n          attrsObject.properties.pop();\n          args.push(\n            // TODO: omit register if dynamic tag is string only\n            callRuntime(\n              \"register\",\n              callRuntime(\n                \"createRenderer\",\n                import_compiler46.types.arrowFunctionExpression(\n                  renderBodyProp.params,\n                  toFirstExpressionOrBlock(renderBodyProp.body)\n                )\n              ),\n              import_compiler46.types.stringLiteral(\n                getResumeRegisterId(renderBodySection, \"renderer\")\n              ),\n              renderBodySection.closures.size && getScopeIdIdentifier(renderBodySection.parent)\n            )\n          );\n        }\n        const dynamicScopeIdentifier = currentProgramPath.scope.generateUidIdentifier(\"dynamicScope\");\n        const dynamicTagExpr = import_compiler46.types.isArrayExpression(attrsObject) ? callRuntime(\"dynamicTagArgs\", ...args) : callRuntime(\"dynamicTagInput\", ...args);\n        if (node.var) {\n          translateVar(tag, dynamicTagExpr);\n          tag.remove();\n        } else {\n          tag.replaceWith(\n            import_compiler46.types.variableDeclaration(\"const\", [\n              import_compiler46.types.variableDeclarator(dynamicScopeIdentifier, dynamicTagExpr)\n            ])\n          )[0].skip();\n        }\n        const section = getSection(tag);\n        writeTo(tag)`${callRuntime(\n          \"markResumeControlEnd\",\n          getScopeIdIdentifier(section),\n          getScopeAccessorLiteral(nodeRef)\n        )}`;\n        getSerializedScopeProperties(section).set(\n          import_compiler46.types.stringLiteral(getScopeAccessorLiteral(nodeRef).value + \"!\"),\n          dynamicScopeIdentifier\n        );\n        getSerializedScopeProperties(section).set(\n          import_compiler46.types.stringLiteral(getScopeAccessorLiteral(nodeRef).value + \"(\"),\n          import_compiler46.types.isIdentifier(tagExpression) ? import_compiler46.types.identifier(tagExpression.name) : tagExpression\n        );\n      } else {\n        const section = getSection(tag);\n        const bodySection = getSection(tag.get(\"body\"));\n        const hasBody = section !== bodySection;\n        const renderBodyIdentifier = hasBody && import_compiler46.types.identifier(bodySection.name);\n        const signal = getSignal(section, nodeRef, \"dynamicTagName\");\n        signal.build = () => {\n          return callRuntime(\n            \"conditional\",\n            getScopeAccessorLiteral(nodeRef),\n            getSignalFn(signal, [scopeIdentifier]),\n            buildSignalIntersections(signal)\n          );\n        };\n        signal.hasDownstreamIntersections = () => true;\n        addValue(\n          section,\n          node.name.extra?.referencedBindings,\n          signal,\n          renderBodyIdentifier ? import_compiler46.types.logicalExpression(\"||\", tagExpression, renderBodyIdentifier) : tagExpression\n        );\n        const attrsObject = attrsToObject(tag, true);\n        const emptyAttrs = import_compiler46.types.isObjectExpression(attrsObject) && !attrsObject.properties.length;\n        if (!emptyAttrs || renderBodyIdentifier) {\n          const attrsGetter = import_compiler46.types.arrowFunctionExpression([], attrsObject);\n          const id = currentProgramPath.scope.generateUidIdentifier(\n            tag.get(\"name\").toString() + \"_input\"\n          );\n          let added = false;\n          addValue(\n            section,\n            node.extra?.referencedBindings,\n            {\n              get identifier() {\n                if (!added) {\n                  currentProgramPath.pushContainer(\n                    \"body\",\n                    import_compiler46.types.variableDeclaration(\"const\", [\n                      import_compiler46.types.variableDeclarator(\n                        id,\n                        callRuntime(\n                          \"dynamicTagAttrs\",\n                          getScopeAccessorLiteral(nodeRef),\n                          renderBodyIdentifier,\n                          import_compiler46.types.isArrayExpression(attrsObject) ? import_compiler46.types.booleanLiteral(true) : false\n                        )\n                      )\n                    ])\n                  );\n                  added = true;\n                }\n                return id;\n              },\n              hasDownstreamIntersections: () => true\n            },\n            attrsGetter\n          );\n        }\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/visitors/tag/index.ts\nvar tag_default = {\n  transform: {\n    enter(tag) {\n      const attrs2 = tag.get(\"attributes\");\n      for (let i = 0; i < attrs2.length; i++) {\n        const attr2 = attrs2[i];\n        if (import_compiler47.types.isMarkoAttribute(attr2.node) && attr2.node.bound) {\n          attr2.node.bound = false;\n          const changeValue = getChangeHandler(tag, attr2);\n          if (changeValue === null) {\n            throw attr2.buildCodeFrameError(\n              \"Attributes may only be bound to identifiers or member expressions\"\n            );\n          }\n          tag.node.attributes.splice(\n            ++i,\n            0,\n            import_compiler47.types.markoAttribute(attr2.node.name + \"Change\", changeValue)\n          );\n          tag.scope.crawl();\n        }\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils39.getTagDef)(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        enter2(hook, tag);\n        return;\n      }\n      if (type === 0 /* NativeTag */) {\n        native_tag_default.analyze.enter(tag);\n        return;\n      }\n      analyzeAttributeTags(tag);\n      switch (type) {\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.analyze.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.analyze.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const hook = (0, import_babel_utils39.getTagDef)(tag)?.analyzer?.hook;\n      if (hook) {\n        exit2(hook, tag);\n        return;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils39.getTagDef)(tag);\n      const extra = tag.node.extra;\n      if (tagDef?.translator) {\n        if (tagDef.translator.path) {\n          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);\n        }\n        enter2(tagDef.translator.hook, tag);\n        return;\n      }\n      for (const attr2 of tag.get(\"attributes\")) {\n        if (attr2.isMarkoAttribute()) {\n          if (attr2.node.arguments) {\n            throw attr2.buildCodeFrameError(\n              `Unsupported arguments on the \\`${attr2.node.name}\\` attribute.`\n            );\n          }\n          if (attr2.node.modifier) {\n            if ((0, import_babel_utils39.isNativeTag)(attr2.parentPath)) {\n              attr2.node.name += `:${attr2.node.modifier}`;\n            } else {\n              throw attr2.buildCodeFrameError(\n                `Unsupported modifier \\`${attr2.node.modifier}\\`.`\n              );\n            }\n          }\n        }\n      }\n      if (extra.tagNameDynamic && extra.tagNameNullable && !tag.get(\"name\").isIdentifier() && isOutputHTML()) {\n        const tagNameId = tag.scope.generateUidIdentifier(\"tagName\");\n        const [tagNameVarPath] = tag.insertBefore(\n          import_compiler47.types.variableDeclaration(\"const\", [\n            import_compiler47.types.variableDeclarator(tagNameId, tag.node.name)\n          ])\n        );\n        tagNameVarPath.skip();\n        tag.set(\"name\", tagNameId);\n      }\n      switch (extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const translator = (0, import_babel_utils39.getTagDef)(tag)?.translator;\n      if (translator) {\n        exit2(translator.hook, tag);\n        return;\n      }\n      switch (tag.node.extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.exit(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.exit(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.exit(tag);\n          break;\n      }\n    }\n  }\n};\nfunction getChangeHandler(tag, attr2) {\n  if (import_compiler47.types.isIdentifier(attr2.node.value)) {\n    const valueId = tag.scope.generateUidIdentifier(\n      \"new_\" + attr2.node.value.name\n    );\n    return import_compiler47.types.functionExpression(\n      null,\n      [valueId],\n      import_compiler47.types.blockStatement([\n        import_compiler47.types.expressionStatement(\n          import_compiler47.types.assignmentExpression(\"=\", attr2.node.value, valueId)\n        )\n      ])\n    );\n  } else if (import_compiler47.types.isMemberExpression(attr2.node.value)) {\n    const prop = attr2.node.value.property;\n    if (import_compiler47.types.isPrivateName(prop)) return null;\n    if (import_compiler47.types.isIdentifier(prop)) {\n      return import_compiler47.types.memberExpression(\n        import_compiler47.types.cloneNode(attr2.node.value.object),\n        import_compiler47.types.identifier(prop.name + \"Change\")\n      );\n    } else {\n      return import_compiler47.types.memberExpression(\n        import_compiler47.types.cloneNode(attr2.node.value.object),\n        import_compiler47.types.binaryExpression(\"+\", import_compiler47.types.cloneNode(prop), import_compiler47.types.stringLiteral(\"Change\")),\n        true\n      );\n    }\n  }\n  return null;\n}\n\n// src/visitors/text.ts\nvar import_compiler48 = require(\"@marko/compiler\");\nvar text_default = {\n  translate: {\n    exit(text) {\n      writeTo(text)`${text.node.value}`;\n      enterShallow(text);\n      text.remove();\n    }\n  }\n};\n\n// src/visitors/update-expression.ts\nvar import_compiler49 = require(\"@marko/compiler\");\nvar update_expression_default = {\n  translate: {\n    exit(assignment) {\n      if (isOutputDOM()) {\n        const source = assignment.node.argument.extra?.source;\n        if (source) {\n          const section = getSection(assignment);\n          (currentProgramPath.node.extra.assignments ??= []).push([\n            section,\n            assignment\n          ]);\n        }\n      }\n    }\n  }\n};\n\n// src/index.ts\nvar visitors = {\n  Program: program_default,\n  Function: function_default,\n  AssignmentExpression: assignment_expression_default,\n  UpdateExpression: update_expression_default,\n  ReferencedIdentifier: referenced_identifier_default,\n  ImportDeclaration: import_declaration_default,\n  MarkoDocumentType: document_type_default,\n  MarkoDeclaration: declaration_default,\n  MarkoCDATA: cdata_default,\n  MarkoText: text_default,\n  MarkoTag: tag_default,\n  MarkoPlaceholder: placeholder_default,\n  MarkoScriptlet: scriptlet_default,\n  MarkoComment: comment_default\n};\nvar getVisitorOfType = (typename) => Object.entries(visitors).reduce((visitor, [name, value]) => {\n  if (typename in value) {\n    visitor[name] = value[typename];\n  }\n  return visitor;\n}, {});\nvar transform = getVisitorOfType(\"transform\");\nvar analyze2 = getVisitorOfType(\"analyze\");\nvar translate2 = getVisitorOfType(\"translate\");\nvar taglibs = [\n  [\n    __dirname,\n    {\n      ...core_default,\n      migrate: getVisitorOfType(\"migrate\")\n    }\n  ]\n];\nfunction getRuntimeEntryFiles(output, optimize) {\n  return [\n    `@marko/runtime-tags${optimize ? \"\" : \"/debug\"}/${output === \"html\" ? \"html\" : \"dom\"}`\n  ];\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  analyze,\n  getRuntimeEntryFiles,\n  internalEntryBuilder,\n  taglibs,\n  transform,\n  translate\n});\n"],"names":["mod","__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__copyProps","to","from","except","desc","key","call","get","enumerable","__toESM","isNodeMode","target","__esModule","value","src_exports","__export","all","name","analyze","analyze2","getRuntimeEntryFiles","internalEntryBuilder","entry_builder_default","taglibs","transform","translate","translate2","module","exports","import_babel_utils","require","taglibId","interopTaglibId","isCoreTagName","tag","id","isMarkoTag","getTagDef","isCoreTag","node","import_babel_utils2","flush_here_and_after_default","renderer","replaceWithMultiple","body","import_compiler","attrs_default","migrate","tagVar","var","type","remove","constTag","types","markoTag","stringLiteral","markoAttribute","identifier","markoTagBody","replaceWith","attributes","autocomplete","displayText","description","snippet","import_babel_utils3","import_compiler2","client_default","parse","hub","file","rawValue","code","replace","trim","start","length","parseStatements","isBlockStatement","markoScriptlet","parseOptions","statement","rawOpenTag","descriptionMoreURL","import_babel_utils12","import_babel_utils11","import_compiler18","import_compiler16","import_babel_utils10","import_compiler15","import_path","bindingHasDownstreamExpressions","binding","downstreamExpressions","size","alias","aliases","propertyAliases","values","import_babel_utils4","import_compiler3","kState","Symbol","build","entryFile","state","path","buildCodeFrameError","imports","map","it","importDeclaration","init","unshift","importSpecifier","markoOpts","optimize","push","expressionStatement","callExpression","visit","visitChild","analyzedTags","metadata","marko","resolveRelativePath","opts","filename","extra","hasInteractiveChild","isInteractive","isOutputHTML","getMarkoOpts","output","isOutputDOM","currentProgramPath","import_babel_utils6","import_compiler5","createProgramState","WeakMap","set","createSectionState","section","arrayOfSectionData","import_babel_utils5","import_compiler4","MARKO_FILE_REG","analyzeTagNameType","tagNameType","isStringLiteral","isNativeTag","bindingName","bindingIdentifier","scope","getBinding","tagIdentifier","newNode","originalNode","loc","end","referencedBindings","analyzeExpressionTagName","childFile","loadFileForTag","childProgram","ast","program","featureType","tagNameNullable","pending","path3","tagNameImported","nullable","pop","isConditionalExpression","alternate","isLogicalExpression","operator","isAssignmentExpression","isBinaryExpression","isTemplateLiteral","isNullLiteral","isIdentifier","kind","decl","parent","test","source","specifiers","some","isImportDefaultSpecifier","resolvedImport","resolveTagImport","bindingTag","bindingTagName","tagNameDynamic","startSection","parentSection","parentPath","getOrCreateSection","sectionNamePath","sectionName","isProgram","generateUid","toString","programExtra","sections","depth","closures","Set","bindings","startNodeContentType","getStartNodeContentType","endNodeContentType","getEndNodeContentType","upstreamExpression","cur","getSection","currentPath","_setSectionPath","getScopeIdIdentifier","generateUidIdentifier","getSectionPath","_getScopeIdentifier","getScopeIdentifier","ignoreDefault","scopeId","forEachSection","fn","forEach","child","contentType","getNodeContentType","i","extraMember","isMarkoText","isMarkoPlaceholder","isMarkoScriptlet","isMarkoComment","isAttributeTag","tagSection","isStatefulSection","isStatefulReferences","checkStatefulClosures","immediateOnly","import_compiler13","import_babel_utils7","import_compiler7","stringifyClassObject","NON_DIMENSIONAL","stringifyStyleObject","toDelimitedString","val","delimiter","stringify","result","curDelimiter","Array","isArray","v","part","classAttr","stringAttr","styleAttr","attr","attrAssignment","RegExp","nonVoidAttr","escapeAttrValue","constructor","async","KNOWN_SYMBOLS2","Map","symbol","AggregateError","of","ArrayBuffer","isView","Atomics","add","and","compareExchange","exchange","isLockFree","load","notify","or","store","sub","wait","BigInt","asIntN","asUintN","BigInt64Array","BigUint64Array","Boolean","console","assert","clear","count","countReset","debug","dir","dirxml","error","group","groupCollapsed","groupEnd","info","log","table","time","timeEnd","timeLog","timeStamp","trace","warn","DataView","Date","now","UTC","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","Error","EvalError","Float32Array","Float64Array","Function","globalThis","atob","btoa","clearImmediate","clearInterval","clearTimeout","crypto","getRandomValues","randomUUID","fetch","performance","queueMicrotask","setImmediate","setInterval","setTimeout","structuredClone","URL","URLSearchParams","WritableStream","Int16Array","Int32Array","Int8Array","Intl","Collator","DateTimeFormat","DisplayNames","getCanonicalLocales","ListFormat","Locale","NumberFormat","PluralRules","RelativeTimeFormat","Segmenter","supportedValuesOf","isFinite","isNaN","JSON","groupBy","Math","abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","floor","fround","hypot","imul","log10","log1p","log2","max","min","pow","random","round","sign","sin","sinh","sqrt","tan","tanh","trunc","Number","isInteger","isSafeInteger","parseFloat","parseInt","assign","defineProperties","entries","freeze","fromEntries","getOwnPropertyDescriptors","getOwnPropertySymbols","is","isExtensible","isFrozen","isSealed","keys","preventExtensions","seal","setPrototypeOf","Promise","Proxy","RangeError","ReferenceError","Reflect","apply","construct","deleteProperty","has","ownKeys","String","fromCharCode","fromCodePoint","raw","for","SyntaxError","TypeError","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","URIError","WeakSet","unsafeAttrChars","str","c","lastIndex","unsafeXMLReg","replaceUnsafeXML","escapeXMLStr","escapeXML","unsafeScriptReg","escapeScriptStr","escapeScript","unsafeStyleReg","escapeStyleStr","escapeStyle","import_compiler6","data","item","cb","findSorted","compare","pos","mid","compareResult","addSorted","len","next","joinRepeatable","a","b","createScopeReadPattern","rootDepth","rootPattern","objectPattern","nestedPatterns","ref","includes","propertyKey","getScopeAccessorLiteral","propertyValue","isShorthand","pattern","relativeDepth","prev","nestedPattern","properties","objectProperty","getScopeExpression","targetSection","scopeIdentifier","diff","memberExpression","createScopeReadExpression","reference","pureFunctions","importRuntime","importNamed","getRuntimePath","callRuntime","args","callExpression2","filteredArgs","arg","unaryExpression","numericLiteral","filterArguments","leadingComments","getHTMLRuntime","import_babel_utils9","import_compiler12","import_babel_utils8","import_compiler11","assertNoSpreadAttrs","attr2","isMarkoSpreadAttribute","assertNoBodyContent","import_compiler10","import_compiler8","toTemplateOrStringLiteral","parts","strs","exprs","curStr","content","nextIndex","exprLen","expressions","shiftItems","quasis","j","templateLiteral","templateElement","appendLiteral","arr","list","offset","import_compiler9","getWalks","getWalkComment","getSteps","walkCodeToName","enter","exit","enterShallow","steps","walks","walkComment","walkString","walks2","step","lastIndexOf","current","walk","nCodeString","writeTo","number","toCharString","startCode","rangeSize","multiplier","getWalkString","prefix2","postfix","walkLiteral","join","getWrites","exprsLen","writes","consumeHTML","flushBefore","expr","insertBefore","skip","flushInto","pushContainer","getSectionMeta","writePrefix","writePostfix","setup","getSetup","markNode","returnId","_setReturnId","usedTag","return_default","assertNoArgs","assertNoVar","assertNoParams","valueAttr","isMarkoAttribute","default","msg","buildError","returnId2","variableDeclaration","variableDeclarator","addValue","hasDownstreamIntersections","getSignals","getSubscribeBuilder","_setSubscribeBuilder","setSubscriberBuilder","builder","getClosures","addClosure","fromSection","toSection","closure","currentSection","forceResumeScope","_setForceResumeScope","setForceResumeScope","getSerializedScopeProperties","unimplementedBuild","getSignal","generateSignalName","signals","signal","exportName","export","intersection","render","effect","effectInlineReferences","subscribers","subscribe","getSignalFn","provider","ownerScope","isImmediateOwner","object","isDynamicClosure","arrowFunctionExpression","buildSignalIntersections","initValue","valueAccessor","intersections","isParamBinding","upstreamAlias","property","params","scopeIdentifier2","valueIdentifier","aliasSignal","callee","toMemberExpression","blockStatement","signal2","intersectionExpression","closureEntries","sort","closureSection","closureSignal","hasDynamicSubscribers","arrayExpression","subscriber","p","providerSignal","finalizeSignalArgs","isArrowFunctionExpression","nullLiteral","isExpressionStatement","expression","addStatement","originalNodes","isInlined","statements","isFunction","addEffectReferences","bindingUtil","union","getResumeRegisterId","getTemplateId","renameBindings","traverseFast","writeSignals","sortSignals","effectDeclarator","effectIdentifier","isCallExpression","arguments","register","signalDeclarator","signalDeclaration","exportNamedDeclaration","roots","root","traverse","bindFunctionsVisitor","aReferencedBindings","getReferencedBindings","bReferencedBindings","reserve","getMappedId","addHTMLEffectCall","writeHTMLResumeStatements","tagVarIdentifier","hasSection","allSignals","scopeIdIdentifier","signalRefs","accessors","additionalProperties","serializedProperties","serialize","accessor","isLiteral","objectExpression","unshiftContainer","FunctionExpression","bindFunction","ArrowFunctionExpression","handleDestructure","assignment","ctx","getStatementParent","prop","elements","argument","buildAssignment","valueId","insertAfter","fnId","returnStatement","keyLiteral","keyToNode","dom_default","domExports","templateIdentifier","template","walksIdentifier","setupIdentifier","closuresIdentifier","paramsBinding","programParamsSignal","assignments","valueSection","replacement","binaryExpression","prefix","sequenceExpression","left","right","slice","replaceAssignments","forEachSectionReverse","childSection","sectionPath","sectionParamsBinding","tagParamsSignal","writes2","setup2","closures2","functionExpression","exportDefaultDeclaration","import_compiler14","html_default","returnIdentifier","renderContent","isImportDeclaration","isExportDeclaration","static","rendererId","previousProgramPath","program_default","crawl","trackParamsReferences","mergedReferences","getMergedReferences","nodes","targetExtra","isEffect","additionalBindings","delete","findReferences","getBindings","pruneBinding","referencedBinding","existingBinding","bindingReference","numReferences","binding1","binding2","sources1","getSourceBindings","sources2","isSuperset","sourceSection","bindings2","sortedBindings","filter","finalizeReferences","recurseAndBuildExportTree","visitedFiles","resolved","loadFileForImport","req","resolveRelativeToEntry","exportTree","props","exports2","getMarkoRoot","curPath","isMarko","getExprRoot","destructRoot","getDestructureRoot","isFunctionExpression","getNextBindingId","setNextBindingId","createBinding","excludeProperties","propBinding","trackVarReferences","changeBinding","canonicalUpstreamAlias","getCanonicalBinding","createBindingsAndTrackReferences","assignBinding","element","lVal","babelBinding","referencePaths","constantViolations","referencePath","trackReference","isUpdateExpression","trackReferencesForBinding","patternBinding","fnRoot","getFnRoot","exprRoot","exprExtra","addReferenceToExpression","fnExtra","addReference","mergeReferences","compareIntersections","lenDelta","subset","elem","derived","sources","curBinding","this","aLen","bLen","aIndex","bIndex","unionSortedRepeatable","find","getIntersections","setIntersections","shouldPrune","isStatefulBinding","import_compiler17","toFirstStatementOrBlock","kBinding","if_default","testAttr","tagBody","tagExtra","BRANCHES_LOOKUP","getBranches","bodySection","branches","nextTag","getNextSibling","isLast","rootTag","rootExtra","tag2","singleNodeOptimization","every","getRoot","isStateful","nodeRef","hasStatefulClosures","section2","conditionalExpression","write2","ifScopeIdIdentifier","ifRendererIdentifier","branchHasStatefulClosures","assignmentExpression","curStatement","ifStatement","else_default","import_babel_utils13","import_compiler19","else_if_default","import_babel_utils14","import_compiler21","import_compiler20","translateVar","initialValue","const_default","varBinding","derivation","import_babel_utils15","import_compiler22","debug_default","debuggerStatement","import_babel_utils16","import_compiler25","import_compiler24","import_compiler23","IDENTIFIER_REG","renderBodyProps","attrsToObject","withRenderBody","resultExtra","spreadElement","hoistedControlFlows","isConditional","isLoop","renderBodySection","renderBodyExpression","isSpreadElement","getRenderBodyProp","attrsObject","isObjectExpression","lastProp","isObjectProperty","define_default","tagBodySection","import_babel_utils17","import_compiler26","do_default","hasDeclaration","isDeclaration","import_babel_utils18","import_compiler27","effect_default","value2","inlineBody","import_babel_utils19","export_default","import_babel_utils23","import_compiler29","import_babel_utils20","analyzeAttributeTags","nestedAttributeTags","analyzeChildren","repeated","dynamic","hasAttributeTags","analyzeChild","isTransparentTag","isLoopTag","attrName","lookup","existing","import_babel_utils22","import_compiler28","import_babel_utils21","evaluate","confident","computed","computeNode","kNativeTagBinding","kSerializeMarker","native_tag_default","attrs2","hasEventHandlers","hasDynamicAttributes","isSpreadAttr","attr3","isEventHandler","tagName","toIdentifier","isHTML","tagDef","hasSpread","throwStatement","newExpression","varName","references","createElFunction","referenceSection","visitAccessor","attrsObj","name2","valueReferences","helper","propName","charAt","toLowerCase","openTagOnly","htmlType","kForMarkerBinding","for_default","hasParams","findName","assertAllowedAttributes","validateFor","isOnlyChild","html","checkOnlyChild","parentTag","parentTagName","hasNestedAttributeTags","translateHTML","translateDOM","in","ofAttr","toAttr","inAttr","loopArgs","loopKind","fromAttr","stepAttr","byAttr","paramIdentifiers","getBindingIdentifiers","referencedBindings2","block","byParams","keyExpression","byIdentifier","keyParam","valParam","forInStatement","ofAttrValue","indexParam","loopParam","tempValParam","indexName","generateUidIdentifierBasedOnNode","updateExpression","forOfStatement","stepValue","fromValue","stepsName","stepName","fromName","forStatement","logicalExpression","forScopeIdsIdentifier","forScopesIdentifier","obj","import_babel_utils24","import_compiler30","kCommentTagBinding","html_comment_default","assertNoAttributes","needsBinding","referenceNodes","commentBinding","templateQuasis","templateExpressions","currentQuasi","text","import_babel_utils25","import_compiler31","id_default","import_babel_utils26","import_default","import_babel_utils27","import_compiler32","let_default","valueChangeAttr","valueChangeReferences","valueChangeBinding","isSetup","valueChangeSource","calleeExpression","initValueId","changeBindingId","queueSource","import_babel_utils28","import_compiler33","kRef","supportedAttrNames","lifecycle_default","lifecycleAttrsRef","import_babel_utils29","import_compiler34","log_default","noop_default","import_babel_utils30","import_compiler35","server_default","import_babel_utils31","import_compiler36","static_default","import_babel_utils32","import_compiler37","comma","charCodeAt","semicolon","intToChar","charToInt","chars","encodeInteger","num","relative","delta","clamped","write","td","TextDecoder","Buffer","decode","buf","buffer","byteOffset","byteLength","out","StringWriter","flush","subarray","BitSet","_BitSet","bits","n2","Chunk2","_Chunk","original","intro","outro","storeName","edited","previous","appendLeft","appendRight","clone","chunk","contains","index","eachNext","eachPrevious","edit","contentOnly","prependLeft","prependRight","reset","split","sliceIndex","originalBefore","originalAfter","newChunk","trimEnd","rx","trimmed","trimStart","unescape","SourceMap","version","sourcesContent","names","mappings","decoded","writer","sourcesIndex","sourceLine","sourceColumn","namesIndex","line","genColumn","segment","encode","x_google_ignoreList","toUrl","getRelativePath","fromParts","toParts","shift","concat","toString2","getLocator","originalLines","lineOffsets","m","column","wordRegex","Mappings","hires","generatedCodeLine","generatedCodeColumn","rawSegments","addEdit","sourceIndex","nameIndex","contentLengthMinusOne","contentLineEnd","indexOf","previousContentLineEnd","segment2","advance","addUneditedChunk","sourcemapLocations","originalCharIndex","first","charInHiresBoundary","lines","n","warned","insertLeft","insertRight","MagicString","_MagicString","string","options","writable","firstChunk","lastChunk","lastSearchedChunk","byStart","byEnd","indentExclusionRanges","storedNames","indentStr","ignoreList","addSourcemapLocation","char","append","_split","cloned","originalChunk","clonedChunk","nextOriginalChunk","nextClonedChunk","generateDecodedMap","locate","includeContent","generateMap","_ensureindentStr","tabbed","spaced","reduce","numSpaces","exec","Infinity","guessIndent","_getRawIndentString","getIndentString","indent","thing","isExcluded","exclude","exclusion","shouldIndentNextCharacter","indentStart","replacer","match","charIndex","_splitChunk","insert","move","last","oldLeft","oldRight","newRight","newLeft","overwrite","update","prepend","lastChar","lastLine","lineIndex","substr","lineStr","startChunk","containsEnd","sliceStart","sliceEnd","snip","searchForward","isEmpty","trimLines","charType","trimEndAborted","aborted","trimStartAborted","hasChanged","_replaceRegexp","searchValue","getReplacement","_","groups","global","re","matches","matchAll","replacement2","_replaceString","_replaceAllString","stringLength","replaceAll","import_path2","core_default","sourceMaps","base","basename","typeAttr","classAttr2","typeValue","classValue2","startsWith","markoText","resolveVirtualDependency","getStart","getEnd","magicString","importPath","virtualPath","importDefaultSpecifier","importDefault","assignment_expression_default","handleDestructure2","cdata_default","cdata","comment_default","comment","declaration_default","declaration","document_type_default","documentType","import_babel_utils33","import_compiler39","functionIdsBySection","registeredFunctions","function_default","markoRoot","functionNameCounts","registerId","isStatic2","serializedScopeProperties","isFunctionDeclaration","import_babel_utils34","import_declaration_default","importDecl","tagImport","tags","import_babel_utils35","import_compiler40","kBinding2","kSiblingText","ESCAPE_TYPES","script","style","placeholder_default","placeholder","escape","placeholderExtra","getPrevSibling","analyzeSiblingText","nodeBinding","canWriteHTML","method","getParentTagName","siblingText","import_compiler41","abortIdsByExpressionForSection","referenced_identifier_default","hasBinding","isMemberExpression","exprId","abortIdsByExpression","scriptlet_default","scriptlet","import_babel_utils39","import_compiler47","import_compiler42","enter2","modulePlugin","plugin","isModulePlugin","isFunctionPlugin","exit2","import_babel_utils36","import_compiler43","attribute_tag_default","findParentTag","parentExtra","existingAttr","import_babel_utils37","import_compiler44","kChildScopeBinding","custom_tag_default","getTagTemplate","childProgramExtra","inputExport","assertAttributesOrSingleArg","relativePath","getTagRelativePath","renderBodyProp","childScopeBinding","peekScopeId","renderBodyId","renderTagExpr","renderBodyPath","callStatement","translateHTML2","tagAttrsIdentifier","attrPath","attrExport","attrExportIdentifier","attrReferences","renderBody","renderBodyExportIdentifier","injectWalks","translateDOM2","nameIsString","import_babel_utils38","import_compiler46","import_compiler45","kDOMBinding","dynamic_tag_default","domBinding","assertAttributesOrArgs","tagExpression","compatRuntimeFile","modules","serialized5to6","toFirstExpressionOrBlock","dynamicScopeIdentifier","dynamicTagExpr","isArrayExpression","renderBodyIdentifier","attrsGetter","added","booleanLiteral","tag_default","bound","changeValue","getChangeHandler","splice","hook","analyzer","translator","watchFiles","modifier","tagNameId","tagNameVarPath","isPrivateName","cloneNode","text_default","visitors","Program","AssignmentExpression","UpdateExpression","ReferencedIdentifier","ImportDeclaration","MarkoDocumentType","MarkoDeclaration","MarkoCDATA","MarkoText","MarkoTag","MarkoPlaceholder","MarkoScriptlet","MarkoComment","getVisitorOfType","typename","visitor"],"sourceRoot":""}