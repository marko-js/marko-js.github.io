{"version":3,"file":"420.2f85dec4.js","mappings":"gKA2BoBA,EA1BhBC,EAAWC,OAAOC,OAClBC,EAAYF,OAAOG,eACnBC,EAAmBJ,OAAOK,yBAC1BC,EAAoBN,OAAOO,oBAC3BC,EAAeR,OAAOS,eACtBC,EAAeV,OAAOW,UAAUC,eAKhCC,EAAcA,CAACC,EAAIC,EAAMC,EAAQC,KACnC,GAAIF,GAAwB,iBAATA,GAAqC,mBAATA,EAC7C,IAAK,IAAIG,KAAOZ,EAAkBS,GAC3BL,EAAaS,KAAKL,EAAII,IAAQA,IAAQF,GACzCd,EAAUY,EAAII,EAAK,CAAEE,IAAKA,IAAML,EAAKG,GAAMG,aAAcJ,EAAOb,EAAiBW,EAAMG,KAASD,EAAKI,aAE3G,OAAOP,CAAE,EAEPQ,EAAUA,CAACxB,EAAKyB,EAAYC,KAAYA,EAAgB,MAAP1B,EAAcC,EAASS,EAAaV,IAAQ,CAAC,EAAGe,GAKnGU,GAAezB,GAAQA,EAAI2B,WAA8ED,EAAjEtB,EAAUsB,EAAQ,UAAW,CAAEE,MAAO5B,EAAKuB,YAAY,IAC/FvB,IAKE6B,EAAgB,CAAC,EAvBNC,EAACJ,EAAQK,KACtB,IAAK,IAAIC,KAASD,EAChB3B,EAAUsB,EAAQM,EAAO,CAAEV,IAAKS,EAAIC,GAAQT,YAAY,GAAO,EAsBnEO,CAASD,EAAe,CACtBI,QAASA,IAAMA,GACfC,qBAAsBA,IAAMA,GAC5BC,qBAAsBA,IAAMC,GAC5BC,UAAWA,IAAMA,GACjBC,iBAAkBA,IAAMA,GACxBC,QAASA,IAAMA,GACfC,UAAWA,IAAMA,GACjBC,UAAWA,IAAMA,KAEnBC,EAAOC,SAda3C,EAcU6B,EAdFd,EAAYX,EAAU,CAAC,EAAG,aAAc,CAAEwB,OAAO,IAAS5B,IAiBtF,IACI4C,EAAuB,CACzBC,KAFmBC,EAAQ,uDAEND,KACrBE,SAAU,cAIRC,EAAkBF,EAAQ,yCAC1BG,EAAqBH,EAAQ,+CAGjC,SAASI,EAAoBC,GAC3B,IAAK,MAAMC,KAASD,EAAI7B,IAAI,cAC1B,GAAI8B,EAAMC,yBACR,MAAMD,EAAME,oBACV,SAASH,EAAI7B,IAAI,QAAQiC,KAAK3B,yDAItC,CACA,SAAS4B,EAAoBL,GAC3B,GAAIA,EAAII,KAAKE,KAAKA,KAAKC,OACrB,MAAMP,EAAI7B,IAAI,QAAQgC,oBACpB,SAASH,EAAI7B,IAAI,QAAQiC,KAAK3B,6CAGpC,CAGA,IA0CuC+B,EAkBFC,EA5DjCC,EAAgB,CAClBC,QAAS,CACNX,KACC,EAAIF,EAAmBc,cAAcZ,IACrC,EAAIF,EAAmBe,gBAAgBb,IACvC,EAAIF,EAAmBgB,oBAAoBd,GAC3CK,EAAoBL,IACpB,EAAIF,EAAmBiB,uBAAuBf,IAC9C,EAAIF,EAAmBkB,qBAAqBhB,EAAK,CAC/CiB,MAAO,mFACPC,GAAAA,GACE,MAAMC,EAASnB,EAAII,KAAKgB,IACxB,IAAID,GAA4B,eAAhBA,EAAOE,MAAyC,UAAhBF,EAAOzB,KASrDM,EAAIsB,aAToE,CACxE,MAAMC,EAAW1B,EAAgB2B,MAAMC,SACrC5B,EAAgB2B,MAAME,cAAc,SACpC,CAAC7B,EAAgB2B,MAAMG,eAAe,QAAS9B,EAAgB2B,MAAMI,WAAW,WAChF/B,EAAgB2B,MAAMK,aAAa,KAErCN,EAASH,IAAMD,EACfnB,EAAI8B,YAAYP,EAClB,CAGF,GACA,GAGNQ,WAAY,CAAC,EACbC,aAAc,CACZ,CACEC,YAAa,gBACbC,YAAa,2DACbC,QAAS,oBAMXC,EAAoBzC,EAAQ,yCAC5B0C,EAAuB1C,EAAQ,+CAG/B2C,IAAmC9B,EAiBpC8B,GAAkB,CAAC,GAhBW,cAAI,iBACnC9B,EAAoC,mBAAI,sBACxCA,EAAqC,oBAAI,uBACzCA,EAAkC,iBAAI,oBACtCA,EAAmC,kBAAI,qBACvCA,EAAgC,eAAI,kBACpCA,EAAiC,gBAAI,mBACrCA,EAA6C,4BAAI,+BACjDA,EAAiC,gBAAI,mBACrCA,EAAwB,OAAI,UAC5BA,EAA0C,yBAAI,4BAC9CA,EAAgC,eAAI,kBACpCA,EAA8B,aAAI,gBAClCA,EAAyB,QAAI,WAC7BA,EAAmC,kBAAI,qBAChCA,GAEL+B,IAAiC9B,EAUlC8B,GAAgB,CAAC,GATG,MAAI,IACzB9B,EAA8B,eAAI,kBAClCA,EAA4B,aAAI,gBAChCA,EAAiC,kBAAI,qBACrCA,EAAkC,mBAAI,sBACtCA,EAA2B,YAAI,eAC/BA,EAAiC,kBAAI,qBACrCA,EAA+B,gBAAI,mBAC5BA,GAIL+B,EAAsB7C,EAAQ,+CAClC,SAAS8C,EAAShE,GAChB,IAAI,MAAEiE,GAAUjE,EAIhB,GAHKiE,IACHA,EAAQjE,EAAMiE,MAAQ,CAAC,QAED,IAApBA,EAAMC,UAAsB,CAC9B,MAAMC,GAAW,EAAIJ,EAAoBK,aAAapE,GAClDmE,GACFF,EAAME,SAAWA,EAASnE,MAC1BiE,EAAMC,WAAY,EAClBD,EAAMI,SAA6B,MAAlBF,EAASnE,QAE1BiE,EAAME,cAAW,EACjBF,EAAMC,WAAY,EAClBD,EAAMI,SAAWC,EAAetE,GAEpC,CACA,OAAOiE,CACT,CACA,SAASK,EAAeC,GACtB,OAAQA,EAAK3B,MACX,IAAK,kBACL,IAAK,0BACL,IAAK,gBACL,IAAK,mBACL,IAAK,iBACL,IAAK,kBACL,IAAK,qBACL,IAAK,gBACL,IAAK,iBACL,IAAK,mBACL,IAAK,gBACL,IAAK,gBACL,IAAK,kBACL,IAAK,mBACH,OAAO,EACT,IAAK,uBACH,OAAQ2B,EAAKC,UACX,IAAK,IACH,OAAOF,EAAeC,EAAKE,OAC7B,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,MACL,IAAK,MACL,IAAK,OACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,MACH,OAAO,EACT,IAAK,MACL,IAAK,MACH,OAAOH,EAAeC,EAAKE,QAAUH,EAAeC,EAAKG,MAC3D,IAAK,MACH,OAAOJ,EAAeC,EAAKG,OAASJ,EAAeC,EAAKE,OAC1D,QACE,OAAO,EAEb,IAAK,kBACH,OAAOH,EAAeC,EAAKI,UAC7B,IAAK,wBACH,OAAOL,EAAeC,EAAKK,aAAeN,EAAeC,EAAKM,WAChE,IAAK,oBACH,OAAQN,EAAKC,UACX,IAAK,KACL,IAAK,KACH,OAAOF,EAAeC,EAAKE,QAAUH,EAAeC,EAAKG,MAC3D,IAAK,KACH,OAAOJ,EAAeC,EAAKG,OAASJ,EAAeC,EAAKE,OAC1D,QACE,OAAO,EAEb,IAAK,0BACH,OAAOH,EAAeC,EAAKO,YAC7B,IAAK,qBACH,OAAOR,EAAeC,EAAKQ,YAAYR,EAAKQ,YAAYjD,OAAS,IACnE,IAAK,kBACH,MAAyB,SAAlByC,EAAKC,SACd,QACE,OAAO,EAEb,CAGA,IAAIQ,EAAoB9D,EAAQ,yCAC5B+D,EAAuB/D,EAAQ,+CAGnC,SAASgE,EAAkBvD,EAAMwD,GAC/B,OAAQxD,EAAKiB,MACX,IAAK,gBACH,IAAK,MAAMwC,KAAQzD,EAAK0D,WACtB,OAAQD,EAAKxC,MACX,IAAK,iBACqB,sBAApBwC,EAAKpF,MAAM4C,KACbsC,EAAkBE,EAAKpF,MAAM0E,KAAMS,GAEnCD,EAAkBE,EAAKpF,MAAOmF,GAEhC,MACF,IAAK,cACHD,EAAkBE,EAAKT,SAAUQ,GAIvC,MACF,IAAK,eACH,IAAK,MAAMG,KAAM3D,EAAK4D,SACpB,GAAU,MAAND,EACF,OAAQA,EAAG1C,MACT,IAAK,cACHsC,EAAkBI,EAAGX,SAAUQ,GAC/B,MACF,IAAK,oBACHD,EAAkBI,EAAGZ,KAAMS,GAC3B,MACF,QACED,EAAkBI,EAAIH,GAK9B,MACF,IAAK,aACHA,EAAGxD,GAGT,CAGA,IAAI6D,EAAmBtE,EAAQ,yCAC3BuE,EAAsBvE,EAAQ,+CAG9BwE,EAAsBxE,EAAQ,+CAIlC,SAASyE,IACP,MAA6B,eAHtB,EAAID,EAAoBE,WAAWC,eAI5C,CAGA,IAAIC,EAAmB5E,EAAQ,yCAC3B6E,EAAOC,OAAO,QAClB,SAASC,EAAgBC,EAAW1G,EAAK2G,GACvC,MAAMxE,EAAOuE,EAAU1G,GACvB,GAAImC,EACF,GAAIyE,MAAMC,QAAQ1E,GAChB,IAAK,IAAI2E,EAAI3E,EAAKG,OAAQwE,KACxBL,EAAgBtE,EAAM2E,EAAGH,OAEtB,CACL,MAAMI,EAAOT,EAAiB/C,MAAMyD,aAAa7E,EAAKiB,MACtD,IAAK,IAAI0D,EAAIC,EAAKzE,OAAQwE,KACxBL,EAAgBtE,EAAM4E,EAAKD,GAAIH,GAEjC,MAAMM,EAAcN,EAAOxE,EAAMuE,EAAW1G,GACxCiH,IAAaP,EAAU1G,GAAOiH,EACpC,CAEJ,CACA,SAASC,EAAiB/E,EAAMgF,GAC9B,GAAIhF,EACF,GAAIyE,MAAMC,QAAQ1E,IAChB,IAAK,MAAMiF,KAAQjF,EACjB,GAAI+E,EAAiBE,EAAMD,GACzB,OAAO,MAGN,CACL,OAAQA,EAAMhF,IACZ,KAAK,EACH,OAAO,EACT,KAAKoE,EACH,OAAO,EAEX,IAAK,MAAMvG,KAAOsG,EAAiB/C,MAAMyD,aAAa7E,EAAKiB,MACzD,GAAI8D,EAAiB/E,EAAKnC,GAAMmH,GAC9B,OAAO,CAGb,CAEF,OAAO,CACT,CACA,SAASE,EAASC,EAAQnF,EAAMoF,EAAQC,GACtC,GAAIrF,EACF,GAAIyE,MAAMC,QAAQ1E,GAChB,IAAK,MAAMiF,KAAQjF,EACjBkF,EAASC,EAAQF,EAAMG,EAAQC,QAE5B,GAAIF,EAAOnF,EAAMoF,EAAQC,KAAiBjB,EAC/C,IAAK,MAAMvG,KAAOsG,EAAiB/C,MAAMyD,aAAa7E,EAAKiB,MACzDiE,EAASC,EAAQnF,EAAKnC,GAAMmC,EAAMoF,EAI1C,CAGA,IAAIE,EAAgC,IAAIC,QACxC,SAASC,EAAY/G,EAAQ,IAC3B,MAAMgH,GAAO,EAAI3B,EAAoBG,WACrC,IAAIyB,EAASJ,EAAcvH,IAAI0H,GAC/B,IAAKC,EAAQ,CACX,MAAM,MAAEC,GAAUF,EAAKG,WACjB,SAAEC,GAAaJ,EAAKK,KACpBC,EAAW,cAAcF,IAC/BH,EAASC,EAAM5H,IAAIgI,GACfL,EACE1B,MACF0B,EAAS,IAAIM,IAAIN,KAGnBA,EAgDN,SAA0BD,GACxB,MAAMC,EAAyB,IAAIM,IAC7BC,EAAUR,EAAKS,KACfC,EAAa1H,IACjB,MAAM2H,EAAQ,sBAAsBC,KAAK5H,GACzC,GAAI2H,EAAO,CACT,MAAME,EAAQF,EAAM,GACdG,EAAQH,EAAM,IAAMA,EAAM,GAAK,EAAI,EACzCV,EAAOc,IAAIF,EAAOG,KAAKC,IAAIhB,EAAO3H,IAAIuI,IAAU,EAAGC,GACrD,GAEF,IAAK,MAAM9H,KAASwH,EAAQU,MAAMC,QAChCT,EAAU1H,GAOZ,OALAyG,GAAS,CAAClF,EAAMoF,EAAQC,KACJ,eAAdrF,EAAKiB,MAAyB4C,EAAiBzC,MAAMyF,UAAU7G,EAAMoF,EAAQC,IAC/Ec,EAAUnG,EAAKV,KACjB,GACC2G,EAAQjG,MACJ0F,CACT,CApEeoB,CAAiBrB,GACrBzB,KACH2B,EAAMa,IAAIT,EAAUL,IAGxBJ,EAAckB,IAAIf,EAAMC,EAC1B,CACAjH,EAAQA,EAAMsI,QAAQ,0BAA2B,KAAO,OACxDtI,EAAQ,gBAAgB4H,KAAK5H,KAAS,IAAMA,EAC5C,MAAMkG,GAAKe,EAAO3H,IAAIU,IAAU,GAAK,EAC/BuI,EAAa,IAAIrC,EAAI,EAAIlG,EAAQkG,EAAIlG,IAE3C,OADAiH,EAAOc,IAAI/H,EAAOkG,GACXqC,CACT,CACA,SAASC,EAAsBxI,GAC7B,OAAOoF,EAAiBzC,MAAMI,WAAWgE,EAAY/G,GACvD,CACA,IAAIyI,EAAoC,IAAI3B,QAC5C,SAAS4B,EAAa1I,GACpB,MAAMgH,GAAO,EAAI3B,EAAoBG,WACrC,IAAImD,EAAaF,EAAkBnJ,IAAI0H,GACvC,IAAK2B,EAAY,CACf,MAAM,MAAEzB,GAAUF,EAAKG,WACjB,SAAEC,GAAaJ,EAAKK,KACpBC,EAAW,cAAcF,IAC/BuB,EAAazB,EAAM5H,IAAIgI,GACnBqB,EACEpD,MACFoD,EAAa,IAAIpB,IAAIoB,KAGvBA,EAA6B,IAAIpB,IAC5BhC,KACH2B,EAAMa,IAAIT,EAAUqB,IAGxBF,EAAkBV,IAAIf,EAAM2B,EAC9B,CACA,IAAIJ,EAAaI,EAAWrJ,IAAIU,GAKhC,OAJKuI,IACHA,EAAaxB,EAAY/G,GACzB2I,EAAWZ,IAAI/H,EAAOuI,IAEjBA,CACT,CACA,SAASK,EAAc5I,GACrB,QAASyI,EAAkBnJ,KAAI,EAAI+F,EAAoBG,aAAaqD,IAAI7I,EAC1E,CAwBA,IAAI8I,EAAkC,CAAEnH,IACtCA,EAA+B,cAAI,IACnCA,EAAoC,mBAAI,IACxCA,EAAqC,oBAAI,IACzCA,EAAkC,iBAAI,IACtCA,EAAmC,kBAAI,IACvCA,EAAgC,eAAI,IACpCA,EAAiC,gBAAI,IACrCA,EAA6C,4BAAI,IACjDA,EAAiC,gBAAI,IACrCA,EAAwB,OAAI,IAC5BA,EAA0C,yBAAI,IAC9CA,EAAgC,eAAI,IACpCA,EAA8B,aAAI,IAClCA,EAAyB,QAAI,IAC7BA,EAAmC,kBAAI,IAChCA,GAhB6B,CAiBnCmH,GAAmB,CAAC,GACnBC,EAAgC,CAAEnH,IACpCA,EAAqB,MAAI,IACzBA,EAA8B,eAAI,IAClCA,EAA4B,aAAI,IAChCA,EAAiC,kBAAI,IACrCA,EAAkC,mBAAI,IACtCA,EAA2B,YAAI,IAC/BA,EAAiC,kBAAI,IACrCA,EAA+B,gBAAI,IAC5BA,GAT2B,CAUjCmH,GAAiB,CAAC,GAGjBC,EAAsBlI,EAAQ,+CAClC,SAASmI,IACP,MAAiC,SAA1BC,IAAeC,MACxB,CACA,SAASC,IACP,OAAQH,GACV,CACA,SAASC,IACP,OAAO,EAAIF,EAAoBxD,WAAW2B,SAC5C,CACA,SAASkC,IACP,OAAOH,IAAeI,QACxB,CAGA,SAASC,IACP,OAAOF,IAAeP,EAAkBrF,CAC1C,CACA,SAAS+F,KACP,OAAOH,IAAeN,EAAgBrF,CACxC,CAGA,SAAS+F,GAAaC,GACpB,IAAIC,EAAUD,EACd,GACEC,EAAUA,EAAQC,iBACbD,IAAYE,GAAQF,IAC3B,OAAOA,CACT,CACA,SAASG,GAAYJ,GACnB,IAAIC,EAAUD,EACd,MAAQG,GAAQF,EAAQC,aACtBD,EAAUA,EAAQC,WAEpB,OAAOD,CACT,CACA,SAASI,GAAUL,GACjB,IACIM,EADAL,EAAUD,EAEd,IAAIC,EAAQM,YAAZ,CACA,MAAQJ,GAAQF,IAAU,CACxB,GAAIO,GAAWP,GACbK,EAASL,OAET,OAAQA,EAAQnH,MACd,IAAK,iBACL,IAAK,gBACHwH,OAAS,EAIfL,EAAUA,EAAQC,UACpB,CACA,OAAOI,CAdwB,CAejC,CACA,SAASH,GAAQH,GACf,OAAQA,EAAMlH,MACZ,IAAK,WACL,IAAK,eACL,IAAK,iBACL,IAAK,uBACL,IAAK,mBACL,IAAK,iBACH,OAAO,EACT,QACE,OAAO,EAEb,CACA,SAAS0H,GAAWR,GAClB,OAAQA,EAAMlH,MACZ,IAAK,sBACH,OAAQkH,EAAMnI,KAAK4I,QACrB,IAAK,qBACL,IAAK,0BACL,IAAK,eACH,OAAO,EACT,QACE,OAAO,EAEb,CAIA,SAASC,GAAkBjG,GACzB,IAAIwF,EAAUxF,EACd,KAAOwF,GAAS,CACd,MAAM,OAAEhD,EAAM,KAAEpF,GAASoI,EACzB,OAAQhD,EAAOnE,MACb,IAAK,iBACH,OAAOmE,EAAO0D,SAAW9I,EAC3B,IAAK,sBACHoI,EAAUA,EAAQC,WAClB,MACF,QACE,OAAO,EAEb,CACA,OAAO,CACT,CAhBuB9I,EAAQ,yCAmB/B,IAAIwJ,GAAS,MACXC,WAAAA,CAAYC,GACVC,KAAKD,QAAUA,CACjB,CACAE,GAAAA,CAAIC,EAAMnE,GACR,OAAOmE,EAAO3E,MAAMC,QAAQ0E,GAAQC,GAAUH,KAAKD,QAASG,EAAMnE,GAAQqE,GAAeJ,KAAKD,QAASG,EAAMnE,GAAQA,CACvH,CACAsE,KAAAA,CAAMC,EAAGC,GACP,OAAID,EACE/E,MAAMC,QAAQ8E,GACZC,EACEhF,MAAMC,QAAQ+E,GA6O5B,SAA+BR,EAASO,EAAGC,GACzC,MAAMC,EAAOF,EAAErJ,OACTwJ,EAAOF,EAAEtJ,OACf,IAAIyJ,EAAS,EACTC,EAAS,EACb,MAAMC,EAAS,GACf,KAAOF,EAASF,GAAQG,EAASF,GAAM,CACrC,MAAMI,EAASP,EAAEI,GACXI,EAASP,EAAEI,GACXI,EAAQhB,EAAQc,EAAQC,GAChB,IAAVC,GACFL,IACAC,IACAC,EAAOI,KAAKH,IACHE,EAAQ,GACjBL,IACAE,EAAOI,KAAKH,KAEZF,IACAC,EAAOI,KAAKF,GAEhB,CACA,GAAIN,IAASC,GAAQC,IAAWF,EAC9B,OAAOF,EAET,KAAOI,EAASF,GACdI,EAAOI,KAAKV,EAAEI,MAEhB,KAAOC,EAASF,GACdG,EAAOI,KAAKT,EAAEI,MAEhB,OAAOC,CACT,CA5QmBK,CAAsBjB,KAAKD,QAASO,EAAGC,GAEvCJ,GAAUH,KAAKD,QAASO,EAAGC,GAG/BD,EAELC,EACEhF,MAAMC,QAAQ+E,GACTJ,GAAUH,KAAKD,QAAS,IAAIQ,GAAID,GAElCF,GAAeJ,KAAKD,QAASQ,EAAGD,GAElCA,EAEFC,CACT,CACAW,IAAAA,CAAKhB,EAAMnE,GACT,GAAImE,EAAM,CACR,GAAI3E,MAAMC,QAAQ0E,GAChB,OAAOiB,GAAWnB,KAAKD,QAASG,EAAMnE,GACjC,GAAiC,IAA7BiE,KAAKD,QAAQG,EAAMnE,GAC5B,OAAOmE,CAEX,CACF,CACAkB,SAAAA,CAAUlB,EAAMnE,GACd,GAAImE,EAAM,CACR,GAAI3E,MAAMC,QAAQ0E,GAChB,OAAOmB,GAAgBrB,KAAKD,QAASG,EAAMnE,GACtC,GAAiC,IAA7BiE,KAAKD,QAAQG,EAAMnE,GAC5B,OAAO,CAEX,CACA,OAAQ,CACV,CACAuF,UAAAA,CAAWC,EAAUC,GACnB,IAAKA,EACH,OAAO,EAET,IAAKjG,MAAMC,QAAQgG,GACjB,OAA6C,IAAtCxB,KAAKoB,UAAUG,EAAUC,GAElC,IAAKjG,MAAMC,QAAQ+F,GACjB,OAAO,EAET,MAAME,EAASD,EAAOvK,OAChByK,EAASH,EAAStK,OACxB,GAAIwK,EAASC,EACX,OAAO,EAET,IAAK,IAAIjG,EAAIgG,EAAQhG,KAAO,CAC1B,MAAMkG,EAAW3B,KAAKoB,UAAUG,EAAUC,EAAO/F,IACjD,IAAkB,IAAdkG,GAAmBD,EAASC,GAAYlG,EAAG,OAAO,CACxD,CACA,OAAO,CACT,GAEF,SAASuF,GAAKd,EAAMnE,GAClB,OAAImE,EACE3E,MAAMC,QAAQ0E,IAChBA,EAAKc,KAAKjF,GACHmE,GAEF,CAACA,EAAMnE,GAETA,CACT,CACA,SAAS6F,GAAOtB,EAAGC,GACjB,OAAID,EACEC,EACEhF,MAAMC,QAAQ8E,GACTA,EAAEsB,OAAOrB,GACPhF,MAAMC,QAAQ+E,GAChB,CAACD,KAAMC,GAEP,CAACD,EAAGC,GAGRD,EAEFC,CACT,CACA,SAASsB,GAAO3B,EAAM5F,GACpB,GAAI4F,EAAM,CACR,GAAI3E,MAAMC,QAAQ0E,GAAO,CACvB,MAAM4B,EAAM5B,EAAKjJ,OACjB,IAAI2J,EACAnF,EAAI,EACR,KAAOA,EAAIqG,GAAK,CACd,IAAI/F,EAAOmE,EAAKzE,KAChB,GAAInB,EAAGyB,GAAO,CAEZ,IADA6E,EAAS7E,EACFN,EAAIqG,GAET,GADA/F,EAAOmE,EAAKzE,KACRnB,EAAGyB,GAAO,CAEZ,IADA6E,EAAS,CAACA,EAAQ7E,GACXN,EAAIqG,GACT/F,EAAOmE,EAAKzE,KACRnB,EAAGyB,IACL6E,EAAOI,KAAKjF,GAGhB,OAAO6E,CACT,CAEF,OAAOA,CACT,CACF,CACA,OAAOA,CACT,CACA,GAAItG,EAAG4F,GACL,OAAOA,CAEX,CAEF,CACA,SAAS6B,GAAQ7B,EAAM5F,GACrB,GAAI4F,EACF,GAAI3E,MAAMC,QAAQ0E,GAAO,CACvB,IAAIzE,EAAI,EACR,IAAK,MAAMM,KAAQmE,EACjB5F,EAAGyB,EAAMN,IAEb,MACEnB,EAAG4F,EAAM,EAGf,CAeA,SAASgB,GAAKhB,EAAM5F,GAClB,GAAI4F,EAAM,CACR,GAAI3E,MAAMC,QAAQ0E,GAChB,OAAOA,EAAKgB,KAAK5G,GAEnB,GAAIA,EAAG4F,EAAM,GACX,OAAOA,CAEX,CACF,CAoCA,SAASiB,GAAWpB,EAASG,EAAMnE,GACjC,IAAIyB,EAAM0C,EAAKjJ,OACX+K,EAAM,EACV,KAAOA,EAAMxE,GAAK,CAChB,MAAMyE,EAAMD,EAAMxE,IAAQ,EACpB0E,EAAMhC,EAAK+B,GACXE,EAAgBpC,EAAQmC,EAAKnG,GACnC,GAAsB,IAAlBoG,EAAqB,OAAOD,EAC5BC,EAAgB,EAAG3E,EAAMyE,EACxBD,EAAMC,EAAM,CACnB,CACF,CACA,SAASZ,GAAgBtB,EAASG,EAAMnE,GACtC,IAAIyB,EAAM0C,EAAKjJ,OACX+K,EAAM,EACV,KAAOA,EAAMxE,GAAK,CAChB,MAAMyE,EAAMD,EAAMxE,IAAQ,EACpB2E,EAAgBpC,EAAQG,EAAK+B,GAAMlG,GACzC,GAAsB,IAAlBoG,EAAqB,OAAOF,EAC5BE,EAAgB,EAAG3E,EAAMyE,EACxBD,EAAMC,EAAM,CACnB,CACA,OAAQ,CACV,CACA,SAAS9B,GAAUJ,EAASG,EAAMnE,GAChC,MAAM+F,EAAM5B,EAAKjJ,OACjB,IAAIuG,EAAMsE,EACNE,EAAM,EACV,KAAOA,EAAMxE,GAAK,CAChB,MAAMyE,EAAMD,EAAMxE,IAAQ,EACpB2E,EAAgBpC,EAAQG,EAAK+B,GAAMlG,GACzC,GAAsB,IAAlBoG,EAAqB,OAAOjC,EAC5BiC,EAAgB,EAAG3E,EAAMyE,EACxBD,EAAMC,EAAM,CACnB,CACA,MAAMrB,EAAS,IAAIrF,MAAMuG,EAAM,GAC/B,IAAK,IAAIrG,EAAI,EAAGA,EAAIuG,EAAKvG,IACvBmF,EAAOnF,GAAKyE,EAAKzE,GAEnB,IAAIyG,EAAMnG,EACV,KAAOiG,EAAMF,GAAK,CAChB,MAAMM,EAAOF,EACbA,EAAMhC,EAAK8B,GACXpB,EAAOoB,KAASI,CAClB,CAEA,OADAxB,EAAOkB,GAAOI,EACPtB,CACT,CAkCA,SAASR,GAAeL,EAASO,EAAGC,GAClC,MAAM4B,EAAgBpC,EAAQO,EAAGC,GACjC,OAAyB,IAAlB4B,EAAsB7B,EAAI6B,EAAgB,EAAI,CAAC7B,EAAGC,GAAK,CAACA,EAAGD,EACpE,CAGA,IAAI+B,GAAoBhM,EAAQ,yCAG5BiM,GAAoBjM,EAAQ,yCAC5BkM,GAAuBlM,EAAQ,+CAC/BmM,GAAezN,EAAQsB,EAAQ,gDAGnC,SAASoM,GAAgCC,GACvC,GAAIA,EAAQC,sBAAsBC,KAAM,OAAO,EAC/C,IAAK,MAAMC,KAASH,EAAQI,QAC1B,GAAIL,GAAgCI,GAAQ,OAAO,EAErD,IAAK,MAAMA,KAASH,EAAQK,gBAAgBC,SAC1C,GAAIP,GAAgCI,GAAQ,OAAO,EAErD,OAAO,CACT,CAGA,IAAII,GAAmB5M,EAAQ,yCAC3B6M,GAAsB7M,EAAQ,+CAC9B8M,GAAShI,SACTxF,GAAwB,CAC1ByN,KAAAA,CAAMC,GACJ,MAAMC,EAAQD,EAAUF,IACxB,IAAKG,EACH,MAAMD,EAAUrG,KAAKnG,oBACnB,mFAGJ,MAAMG,EAAOsM,EAAMC,QAAQC,KACxBC,GAAOR,GAAiB/K,MAAMwL,kBAAkB,GAAIT,GAAiB/K,MAAME,cAAcqL,MAe5F,OAbIH,EAAMK,OACR3M,EAAK4M,QACHX,GAAiB/K,MAAMwL,kBACrB,CAACT,GAAiB/K,MAAM2L,gBAAgBZ,GAAiB/K,MAAMI,WAAW,QAAS2K,GAAiB/K,MAAMI,WAAW,UACrH2K,GAAiB/K,MAAME,cACrB,GAAGjC,EAAqBC,QAAQiN,EAAU3G,UAAUmC,SAAW,GAAK,iBAI1E7H,EAAKgK,KACHiC,GAAiB/K,MAAM4L,oBAAoBb,GAAiB/K,MAAM6L,eAAed,GAAiB/K,MAAMI,WAAW,QAAS,OAGzHtB,CACT,EACAgN,KAAAA,CAAMzH,EAAM8G,EAAWY,GACrB,MAAMX,EAAQD,EAAUF,MAAY,CAClCI,QAAS,GACTI,MAAM,IAEF,aAAEO,GAAiB3H,EAAK4H,SAASC,MACvCd,EAAMC,QAAQvC,MACZ,EAAIkC,GAAoBmB,qBAAqBhB,EAAW9G,EAAKK,KAAKD,WAEpE2G,EAAMK,OAASpH,EAAKS,KAAKlG,KAAKsC,MAAMkL,qBAAuB/H,EAAKS,KAAKlG,KAAKsC,MAAMmL,gBAAiB,EACjG,IAAK,MAAM7N,KAAOwN,GAAgB,GAChCD,EAAWvN,EAEf,GAIF,SAAS8N,GAAmB9N,GAC1B,MAAM+N,EAAS,CAAC,EAChB,IAAK,MAAM9N,KAASD,EAAI+B,WACH,mBAAf9B,EAAMoB,OACR0M,EAAO9N,EAAMP,MAAQO,EAAMxB,OAG/B,OAAOsP,CACT,CAGA,IAAIC,GAAsBrO,EAAQ,+CAGlC,SAASsO,GAAWjO,GAClB,OAAOA,EAAII,KAAKV,KAAKjB,KACvB,CAGA,IAAI,SAAEmB,IAAaH,EAGnB,SAASyO,GAAUlO,GACjB,GAAIA,EAAImO,aAAc,CACpB,MAAMC,GAAS,EAAIJ,GAAoBK,WAAWrO,GAClD,GAAIoO,EACF,OAAQA,EAAOxO,UACb,KAAKA,GACL,IAPc,uCAQZ,OAAO,EACT,IAVW,aAWT,OAAQwO,EAAO1O,MACb,IAAK,SACL,IAAK,QACH,OAAO,GAKnB,CACA,OAAO,CACT,CACA,SAAS4O,GAActO,EAAKnB,GAC1B,OAAOqP,GAAUlO,IAAQiO,GAAWjO,KAASnB,CAC/C,CACA,SAAS0P,GAAevO,GACtB,GAAIkO,GAAUlO,GACZ,OAAQiO,GAAWjO,IACjB,IAAK,KACL,IAAK,UACL,IAAK,OACH,OAAO,EAGb,OAAO,CACT,CAiBA,IAAIwO,GAAmB7O,EAAQ,yCAC3B8O,GAAsB9O,EAAQ,+CASlC,SAAS+O,GAAqB7P,EAAOJ,GACnC,OAAOA,EAAQI,EAAQ,EACzB,CAIA,SAAS8P,GAAqB9P,EAAOJ,GACnC,OAAOA,GAAmB,IAAVA,EAAc,GAAGI,KAASJ,GAA0B,iBAAVA,IAAuB,yCAAyCmQ,KAAK/P,GAASJ,EAAQ,KAAOA,IAAU,EACnK,CACA,SAASoQ,GAAkBC,EAAKC,EAAWC,GACzC,IAEIC,EAFAC,EAAM,GACNC,EAAM,GAEV,GAAIL,EACF,GAAmB,iBAARA,EACTI,GAAOJ,OACF,GAAIjK,MAAMC,QAAQgK,GACvB,IAAK,MAAMM,KAAKN,EACdG,EAAOJ,GAAkBO,EAAGL,EAAWC,GACnCC,IACFC,GAAOC,EAAMF,EACbE,EAAMJ,QAIV,IAAK,MAAMlQ,KAASiQ,EAClBG,EAAOD,EAAUnQ,EAAOiQ,EAAIjQ,IACxBoQ,IACFC,GAAOC,EAAMF,EACbE,EAAMJ,GAKd,OAAOG,CACT,CACA,SAASG,GAAexQ,GACtB,MAAO,YAAY+P,KAAK/P,EAC1B,CACA,SAASyQ,GAAoBzQ,GAC3B,MAAoB,MAAbA,EAAM,GAAaA,EAAM0Q,MAAM,GAAK1Q,EAAM0Q,MAAM,GAAGC,aAC5D,CAMA,SAASC,GAASX,GAChB,OAAOA,EAAMA,EAAM,GAAa,IAARA,EAAY,IAAM,EAC5C,CAvD6CrK,SAwD7C,IAAIiL,GAAe,QACfC,GAAoBC,GAAY,MAANA,EAAY,QAAU,OAEpD,SAASC,GAAUf,GACjB,OAAOA,GAFWI,EAEQJ,EAAM,GAFNY,GAAad,KAAKM,GAAOA,EAAI/H,QAAQuI,GAAcC,IAAoBT,GAEnD,IAARJ,EAAY,IAAM,QAFtCI,KAGpB,CACA,IAAIY,GAAkB,aAEtB,SAASC,GAAajB,GACpB,OAAOA,GAFcI,EAEQJ,EAAM,GAFNgB,GAAgBlB,KAAKM,GAAOA,EAAI/H,QAAQ2I,GAAiB,gBAAkBZ,GAEvD,IAARJ,EAAY,IAAM,GAFtCI,KAGvB,CACA,IAAIc,GAAiB,YAErB,SAASC,GAAYnB,GACnB,OAAOA,GAFaI,EAEQJ,EAAM,GAFNkB,GAAepB,KAAKM,GAAOA,EAAI/H,QAAQ6I,GAAgB,cAAgBd,GAEnD,IAARJ,EAAY,IAAM,GAFtCI,KAGtB,CAGA,IAAIgB,GAAmBzL,UACnB,eAAE9G,IAAmB,CAAC,EACtBwS,GAAY,YAChB,CADgB,GACZ/G,YACAgH,GAAiBC,kBACrB,CADqBA,GACjBjH,YAoPJ,SAASkH,GAASC,GAChB,MAAMC,EAAQD,EAAS,GACvB,MAAiB,MAAVC,GAAiBA,GAAS,KAAOA,GAAS,IAAM,IAAMD,EAAW,IAAM,IAAMA,CACtF,CACA,SAASE,GAAkBC,GACzB,MAAM,KAAEhF,GAASgF,EACjBA,EAAMhF,KAAO,SAASjN,GAEpB,OADA6K,KAAK4G,IAAoB,EAClBxE,EAAKxN,KAAKoL,KAAM7K,EACzB,CACF,CAkBA,SAASkS,GAAUlS,GACjB,OAAOmS,GAAW,QA5VX/B,GA4V+BpQ,EA5VA,IAAKiQ,IA6V7C,CACA,SAASmC,GAAUpS,GACjB,OAAOmS,GAAW,QAzVX/B,GAyV+BpQ,EAzVA,IAAKkQ,IA0V7C,CAEA,SAASmC,GAAKjS,EAAOJ,GACnB,OAvTF,SAAgBA,GACd,OAAgB,MAATA,IAA2B,IAAVA,CAC1B,CAqTSsS,CAAOtS,GAAS,GAKzB,SAAqBI,EAAOJ,GAC1B,cAAeA,GACb,IAAK,SACH,MAAO,IAAMI,EAAQmS,GAAevS,GACtC,IAAK,UACH,MAAO,IAAMI,EACf,IAAK,SACH,MAAO,IAAMA,EAAQ,IAAMJ,EAC7B,IAAK,SACH,GAAIA,aAAiBwS,OACnB,MAAO,IAAMpS,EAAQmS,GAAevS,EAAMyS,QAIhD,MAAO,IAAMrS,EAAQmS,GAAevS,EAAQ,GAC9C,CApB8B0S,CAAYtS,EAAOJ,EACjD,CACA,SAASmS,GAAW/R,EAAOJ,GACzB,OAAOA,GAAS,IAAMI,EAAQmS,GAAevS,EAC/C,CA3RAgS,GAAkBN,GAAUzS,WAC5B+S,GAAkBL,GAAe1S,WACb,MAClB,MAAM0T,EAAiC,IAAIhL,IAC3C,IAAK,MAAMvH,KAAS9B,OAAOO,oBAAoBmH,QAAS,CACtD,MAAM4M,EAAS5M,OAAO5F,GACA,iBAAXwS,GACTD,EAAexK,IAAIyK,EAAQ,UAAYxS,EAE3C,CAED,EATmB,GAUkB,IAAIuH,IAAI,CAG5C,CAACkL,eAAgB,kBACjB,CAACzM,MAAO,SACR,CAACA,MAAM/G,KAAM,cACb,CAAC+G,MAAMC,QAAS,iBAChB,CAACD,MAAM0M,GAAI,YACX,CAACC,YAAa,eACd,CAACA,YAAYC,OAAQ,sBACrB,CAACC,QAAQnI,IAAK,eACd,CAACmI,QAAQC,IAAK,eACd,CAACD,QAAQE,gBAAiB,2BAC1B,CAACF,QAAQG,SAAU,oBACnB,CAACH,QAAQI,WAAY,sBACrB,CAACJ,QAAQK,KAAM,gBACf,CAACL,QAAQM,OAAQ,kBACjB,CAACN,QAAQO,GAAI,cACb,CAACP,QAAQQ,MAAO,iBAChB,CAACR,QAAQS,IAAK,eACd,CAACT,QAAQU,KAAM,gBACf,CAACC,OAAQ,UACT,CAACA,OAAOC,OAAQ,iBAChB,CAACD,OAAOE,QAAS,kBACjB,CAACC,cAAe,iBAChB,CAACA,cAAc1U,KAAM,sBACrB,CAAC0U,cAAcjB,GAAI,oBACnB,CAACkB,eAAgB,kBACjB,CAACA,eAAe3U,KAAM,uBACtB,CAAC2U,eAAelB,GAAI,qBACpB,CAACmB,QAAS,WACV,CAACC,QAAQC,OAAQ,kBACjB,CAACD,QAAQE,MAAO,iBAChB,CAACF,QAAQhM,MAAO,iBAChB,CAACgM,QAAQG,WAAY,sBACrB,CAACH,QAAQI,MAAO,iBAChB,CAACJ,QAAQK,IAAK,eACd,CAACL,QAAQM,OAAQ,kBACjB,CAACN,QAAQO,MAAO,iBAChB,CAACP,QAAQQ,MAAO,iBAChB,CAACR,QAAQS,eAAgB,0BACzB,CAACT,QAAQU,SAAU,oBACnB,CAACV,QAAQW,KAAM,gBACf,CAACX,QAAQY,IAAK,eACd,CAACZ,QAAQa,MAAO,iBAChB,CAACb,QAAQc,KAAM,gBACf,CAACd,QAAQe,QAAS,mBAClB,CAACf,QAAQgB,QAAS,mBAClB,CAAChB,QAAQiB,UAAW,qBACpB,CAACjB,QAAQkB,MAAO,iBAChB,CAAClB,QAAQmB,KAAM,gBACf,CAACC,SAAU,YACX,CAACC,KAAM,QACP,CAACA,KAAKC,IAAK,YACX,CAACD,KAAKE,MAAO,cACb,CAACF,KAAKG,IAAK,YACX,CAACC,UAAW,aACZ,CAACC,mBAAoB,sBACrB,CAACC,UAAW,aACZ,CAACC,mBAAoB,sBACrB,CAACC,MAAO,SACR,CAACC,UAAW,aACZ,CAACC,aAAc,gBACf,CAACA,aAAa5W,KAAM,qBACpB,CAAC4W,aAAanD,GAAI,mBAClB,CAACoD,aAAc,gBACf,CAACA,aAAa7W,KAAM,qBACpB,CAAC6W,aAAapD,GAAI,mBAClB,CAACqD,SAAU,YACX,CAACC,WAAWC,KAAM,QAClB,CAACD,WAAWE,KAAM,QAClB,CAACF,WAAWG,eAAgB,kBAC5B,CAACH,WAAWI,cAAe,iBAC3B,CAACJ,WAAWK,aAAc,gBAC1B,CAACL,WAAWM,QAAQC,gBAAiB,0BACrC,CAACP,WAAWM,QAAQE,WAAY,qBAChC,CAACR,WAAWS,MAAO,SACnB,CAACT,WAAWU,aAAatB,IAAK,mBAC9B,CAACY,WAAWW,eAAgB,kBAC5B,CAACX,WAAWY,aAAc,gBAC1B,CAACZ,WAAWa,YAAa,eACzB,CAACb,WAAWc,WAAY,cACxB,CAACd,WAAWe,gBAAiB,mBAC7B,CAACf,WAAWgB,IAAK,OACjB,CAAChB,WAAWiB,gBAAiB,mBAC7B,CAACjB,WAAWkB,eAAgB,kBAC5B,CAACC,WAAY,cACb,CAACA,WAAWlY,KAAM,mBAClB,CAACkY,WAAWzE,GAAI,iBAChB,CAAC0E,WAAY,cACb,CAACA,WAAWnY,KAAM,mBAClB,CAACmY,WAAW1E,GAAI,iBAChB,CAAC2E,UAAW,aACZ,CAACA,UAAUpY,KAAM,kBACjB,CAACoY,UAAU3E,GAAI,gBACf,CAAC4E,KAAKC,SAAU,iBAChB,CAACD,KAAKE,eAAgB,uBACtB,CAACF,KAAKG,aAAc,qBACpB,CAACH,KAAKI,oBAAqB,4BAC3B,CAACJ,KAAKK,WAAY,mBAClB,CAACL,KAAKM,OAAQ,eACd,CAACN,KAAKO,aAAc,qBACpB,CAACP,KAAKQ,YAAa,oBACnB,CAACR,KAAKS,mBAAoB,2BAC1B,CAACT,KAAKU,UAAW,kBACjB,CAACV,KAAKW,kBAAmB,0BACzB,CAACC,SAAU,YACX,CAACC,MAAO,SACR,CAACC,KAAK/C,MAAO,cACb,CAAC+C,KAAKjI,UAAW,kBACjB,CAAC5I,IAAK,OACN,CAACA,IAAI8Q,QAAS,eACd,CAACrQ,KAAKsQ,IAAK,YACX,CAACtQ,KAAKuQ,KAAM,aACZ,CAACvQ,KAAKwQ,MAAO,cACb,CAACxQ,KAAKyQ,KAAM,aACZ,CAACzQ,KAAK0Q,MAAO,cACb,CAAC1Q,KAAK2Q,KAAM,aACZ,CAAC3Q,KAAK4Q,MAAO,cACb,CAAC5Q,KAAK6Q,MAAO,cACb,CAAC7Q,KAAK8Q,KAAM,aACZ,CAAC9Q,KAAK+Q,KAAM,aACZ,CAAC/Q,KAAKgR,MAAO,cACb,CAAChR,KAAKiR,IAAK,YACX,CAACjR,KAAKkR,KAAM,aACZ,CAAClR,KAAKmR,IAAK,YACX,CAACnR,KAAKoR,MAAO,cACb,CAACpR,KAAKqR,MAAO,cACb,CAACrR,KAAKsR,OAAQ,eACd,CAACtR,KAAKuR,MAAO,cACb,CAACvR,KAAKwR,KAAM,aACZ,CAACxR,KAAK0M,IAAK,YACX,CAAC1M,KAAKyR,MAAO,cACb,CAACzR,KAAK0R,MAAO,cACb,CAAC1R,KAAK2R,KAAM,aACZ,CAAC3R,KAAKC,IAAK,YACX,CAACD,KAAK4R,IAAK,YACX,CAAC5R,KAAK6R,IAAK,YACX,CAAC7R,KAAK8R,OAAQ,eACd,CAAC9R,KAAK+R,MAAO,cACb,CAAC/R,KAAKgS,KAAM,aACZ,CAAChS,KAAKiS,IAAK,YACX,CAACjS,KAAKkS,KAAM,aACZ,CAAClS,KAAKmS,KAAM,aACZ,CAACnS,KAAKoS,IAAK,YACX,CAACpS,KAAKqS,KAAM,aACZ,CAACrS,KAAKsS,MAAO,cACb,CAACC,OAAQ,UACT,CAACA,OAAOrC,SAAU,mBAClB,CAACqC,OAAOC,UAAW,oBACnB,CAACD,OAAOpC,MAAO,gBACf,CAACoC,OAAOE,cAAe,wBACvB,CAACF,OAAOG,WAAY,qBACpB,CAACH,OAAOI,SAAU,mBAClB,CAACzc,OAAQ,UACT,CAACA,OAAO0c,OAAQ,iBAChB,CAAC1c,OAAOC,OAAQ,iBAChB,CAACD,OAAO2c,iBAAkB,2BAC1B,CAAC3c,OAAOG,eAAgB,yBACxB,CAACH,OAAO4c,QAAS,kBACjB,CAAC5c,OAAO6c,OAAQ,iBAChB,CAAC7c,OAAO8c,YAAa,sBACrB,CAAC9c,OAAOK,yBAA0B,mCAClC,CAACL,OAAO+c,0BAA2B,oCACnC,CAAC/c,OAAOO,oBAAqB,8BAC7B,CAACP,OAAOgd,sBAAuB,gCAC/B,CAAChd,OAAOS,eAAgB,yBACxB,CAACT,OAAOid,GAAI,aACZ,CAACjd,OAAOkd,aAAc,uBACtB,CAACld,OAAOmd,SAAU,mBAClB,CAACnd,OAAOod,SAAU,mBAClB,CAACpd,OAAOiI,KAAM,eACd,CAACjI,OAAOqd,kBAAmB,4BAC3B,CAACrd,OAAOsd,KAAM,eACd,CAACtd,OAAOud,eAAgB,yBACxB,CAACvd,OAAOuP,OAAQ,iBAChB,CAACiN,WAAY,cACb,CAACC,SAAU,YACX,CAACe,QAAS,WACV,CAACC,MAAO,SACR,CAACC,WAAY,cACb,CAACC,eAAgB,kBACjB,CAACC,QAAQC,MAAO,iBAChB,CAACD,QAAQE,UAAW,qBACpB,CAACF,QAAQzd,eAAgB,0BACzB,CAACyd,QAAQG,eAAgB,0BACzB,CAACH,QAAQxc,IAAK,eACd,CAACwc,QAAQvd,yBAA0B,oCACnC,CAACud,QAAQnd,eAAgB,0BACzB,CAACmd,QAAQjT,IAAK,eACd,CAACiT,QAAQV,aAAc,wBACvB,CAACU,QAAQI,QAAS,mBAClB,CAACJ,QAAQP,kBAAmB,6BAC5B,CAACO,QAAQ/T,IAAK,eACd,CAAC+T,QAAQL,eAAgB,0BACzB,CAACrJ,OAAQ,UACT,CAAC+J,IAAK,OACN,CAACC,OAAQ,UACT,CAACA,OAAOC,aAAc,uBACtB,CAACD,OAAOE,cAAe,wBACvB,CAACF,OAAOG,IAAK,cACb,CAAC3W,OAAQ,UACT,CAACA,OAAO4W,IAAK,cACb,CAACC,YAAa,eACd,CAACC,UAAW,aACZ,CAACC,YAAa,eACd,CAACA,YAAY1d,KAAM,oBACnB,CAAC0d,YAAYjK,GAAI,kBACjB,CAACkK,YAAa,eACd,CAACA,YAAY3d,KAAM,oBACnB,CAAC2d,YAAYlK,GAAI,kBACjB,CAACmK,WAAY,cACb,CAACA,WAAW5d,KAAM,mBAClB,CAAC4d,WAAWnK,GAAI,iBAChB,CAACoK,kBAAmB,qBACpB,CAACA,kBAAkB7d,KAAM,0BACzB,CAAC6d,kBAAkBpK,GAAI,wBACvB,CAACqK,SAAU,YACX,CAACjW,QAAS,WACV,CAACkW,QAAS,aAEwB,IAAIzV,IAAI,CAC1C,CAACsL,QAAS,WACV,CAACiB,QAAS,WACV,CAACkC,WAAY,cACb,CAACA,WAAWM,OAAQ,UACpB,CAACgB,KAAM,QACP,CAACc,KAAM,QACP,CAACpQ,KAAM,QACP,CAAC8T,QAAS,aAeKlW,OAAO,YACDA,OAAO,oBACZA,SAUPoQ,WAAWY,cAAgBZ,WAAWc,YAAcd,WAAWW,eASrD/Q,OAAO,iBAuB5B,IAAIqX,GAA8B,iBAC9BC,GAA8B,iBAC9BC,GAAkB,uBACtB,SAAShL,GAAevS,GACtB,OAAOA,EAAQud,GAAgBpN,KAAKnQ,GAASA,EAAMud,GAAgBC,UAAY,MAAQD,GAAgBC,UAAY,EAAG,KAAO,KAE/H,SAAqCxd,GACnC,OAAOqd,GAA4BlN,KAAKnQ,GAASA,EAAM0I,QACrD2U,GACAI,IACEzd,CACN,CAPsI0d,CAA4B1d,GAAS,IAAM,KAWjL,SAAqCA,GACnC,OAAOsd,GAA4BnN,KAAKnQ,GAASA,EAAM0I,QACrD4U,GACAK,IACE3d,CACN,CAhBwL4d,CAA4B5d,GAAS,IAAM,IAAMA,EAAQ,EACjP,CAOA,SAASyd,GAAiC1V,GACxC,MAAiB,MAAVA,EAAgB,QAAU,OACnC,CAOA,SAAS4V,GAAiC5V,GACxC,MAAiB,MAAVA,EAAgB,QAAU,OACnC,CASuB/B,SANvB,IASI6X,GAAmB3c,EAAQ,yCAC/B,SAAS4c,GAA0B1d,GACjC,MAAO,wBAAwB+P,KAAK/P,EACtC,CACA,SAAS2d,GAAe3d,GACtB,OAAI0d,GAA0B1d,GACrByd,GAAiB9a,MAAMI,WAAW/C,GAChC,sBAAsB+P,KAAK/P,GAC7Byd,GAAiB9a,MAAMib,eAAejD,SAAS3a,EAAO,KAExDyd,GAAiB9a,MAAME,cAAc7C,EAC9C,CACA,SAAS6d,GAAiB7d,EAAOJ,GAC/B,OAAO6d,GAAiB9a,MAAMmb,eAAeH,GAAe3d,GAAQJ,EACtE,CACA,SAASme,GAAmBC,EAAQ5e,EAAK6e,GACvC,MAAMjZ,EAAO2Y,GAAeve,GACtB2E,EAAyB,eAAdiB,EAAKxC,KACtB,OAAOyb,EAAWR,GAAiB9a,MAAMub,yBAAyBF,EAAQhZ,EAAMjB,GAAU,GAAQ0Z,GAAiB9a,MAAMwb,iBAAiBH,EAAQhZ,EAAMjB,EAC1J,CAGA,IAAIqa,GAAmC,IAAIjC,IAAI,CAC7C,WACA,cACA,qBACA,YACA,aACA,iBACA,gBACA,iBACA,iBACA,qBACA,eACA,cACA,SACA,SACA,SACA,QACA,UAEF,SAASkC,GAAcre,GACrB,MAAM,OAAEmJ,GAAWD,IACnB,OAAO6U,IACL,EAAInO,GAAoB0O,aAAY,EAAI1O,GAAoBpK,WA8BhE,SAAwB2D,GACtB,MAAM,SAAEG,GAAaJ,IACrB,MAAO,GAAGtI,EAAqBC,QAAQyI,EAAW,GAAK,WAAsB,SAAXH,EAAoB,OAAS,OACjG,CAjC4EoV,CAAepV,GAAS,KAChGnJ,EAEJ,CACA,SAASwe,GAAYxe,KAAUye,GAC7B,MAAMC,EAAkB/O,GAAiBhN,MAAM6L,eAC7C6P,GAAcre,GA4BlB,SAAyBye,GACvB,MAAME,EAAe,GACrB,IAAK,IAAIzY,EAAIuY,EAAK/c,OAAQwE,KAAO,CAC/B,MAAM0Y,EAAMH,EAAKvY,IACb0Y,GAAOD,EAAajd,UACtBid,EAAazY,GAAK0Y,GAAOjP,GAAiBhN,MAAMkc,gBAAgB,OAAQlP,GAAiBhN,MAAMib,eAAe,IAElH,CACA,OAAOe,CACT,CApCIG,CAAgBL,IAUlB,OARIrV,KAAiBgV,GAAiBvV,IAAI7I,KACxC0e,EAAgBK,gBAAkB,CAChC,CACEvc,KAAM,eACN5C,MAAO,iBAIN8e,CACT,CACA,SAASM,KACP,MAAO,CACLhO,aACAJ,YACAqB,QACAH,aACAE,aACAd,gBACAE,eAEJ,CAeA,SAAS6N,KACP,MAAM9X,EAAY+B,IAClB,MAAO,yCAAyCD,IAAiB,OAAS,QAAQ9B,EAAUmC,SAAW,GAAK,YAAkC,QAAtBnC,EAAU+X,QAAoB,MAAQ,MAChK,CAGA,IAAIC,GAAoBre,EAAQ,yCAC5Bse,GAAuBte,EAAQ,+CAI/Bue,IADmBve,EAAQ,yCACG,IAAIgG,SAClCwY,GAAmC,IAAIxY,QACvCyY,GAAyC,IAAIzY,QAC7C0Y,GAA+B,CAAC,EACpC,SAASC,GAAqBxgB,EAAMD,EAAIgG,GACtC,IAAI2H,EAAM1N,EACV,KAAO0N,IAAQ3N,GAAM2N,EAAIhG,QACvB+Y,GAAsB/S,EAAK3H,GAC3B2H,EAAMA,EAAIhG,MAEd,CACA,SAASgZ,GAAyB1gB,EAAMD,EAAI4gB,EAAQ5a,GAClD,GAAI4a,EAAQ,CACV,IAAIjT,EAAM1N,EACV,KAAO0N,IAAQ3N,GAAM2N,EAAIhG,QACvBkZ,GAA0BlT,EAAKiT,EAAQ5a,GACvC2H,EAAMA,EAAIhG,MAEd,CACF,CACA,SAAS+Y,GAAsBI,EAAS9a,GAClCA,EACF+a,GAAkBD,EAASE,GAAiCF,EAAS9a,KAChC,IAA5B8a,EAAQG,kBACjBZ,GAAYa,OAAOJ,GACnBK,GAA0BL,GAAS,GAEvC,CACA,SAASM,GAAsBN,EAAS3S,EAASkT,GAC/CN,GAAkBD,EAASQ,GAA6BnT,EAASkT,GACnE,CACA,SAASN,GAAkBD,EAAS1gB,IACQ,IAAtC0gB,EAAQS,iBAAiBjhB,IAAIF,KAC/BohB,GAA+BV,EAAS1gB,GAAK,GAC7CkgB,GAAiBhgB,IAAIwgB,IAAUI,OAAO9gB,GAE1C,CACA,SAASqhB,GAAyBX,EAAS3S,EAASkT,GAClD,OAEM,IAFCP,EAAQS,iBAAiBjhB,IAC9BghB,GAA6BnT,EAASkT,GAE1C,CAsBA,SAASK,GAA8BZ,EAAS3S,EAAShJ,EAAMkc,GAC7D,MAAMjhB,EAAMkhB,GAA6BnT,EAASkT,GAC9Clc,IAA8C,IAAtC2b,EAAQS,iBAAiBjhB,IAAIF,IACvCuhB,GAA4Bb,EAAS1gB,EAAK+E,EAE9C,CACA,SAASwc,GAA4Bb,EAAS1gB,EAAK+E,GACjD,IAAa,IAATA,EACF4b,GAAkBD,EAAS1gB,OACtB,CACL,IAAIwhB,EACAC,EAAavB,GAAiBhgB,IAAIwgB,GAClCe,EACFD,EAAeC,EAAWvhB,IAAIF,IAE9ByhB,EAA6B,IAAItZ,IACjC+X,GAAiBvX,IAAI+X,EAASe,IAEhCA,EAAW9Y,IAAI3I,EAAKwhB,EAAevU,GAAOuU,EAAczc,GAAQA,EAClE,CACF,CAgDA,SAAS0b,GAA0BC,EAASF,EAAQ5a,GAClD,GAAI4a,EACF,GAAI5a,EACF8b,GACEhB,EACAE,GAAiCF,EAAS9a,GAC1C4a,OAEG,CACL,MAAMmB,EAAiBjB,EAAQG,iBACR,IAAnBc,KACa,IAAXnB,EACFF,GAAsBI,GAEtBK,GACEL,EACAkB,GAAsBD,EAAgBnB,IAI9C,CAEJ,CACA,SAASqB,GAA0BnB,EAAS3S,EAASyS,EAAQS,GACvDT,GACFkB,GACEhB,EACAQ,GAA6BnT,EAASkT,GACtCT,EAGN,CACA,SAASkB,GAAwBhB,EAAS1gB,EAAKwgB,GAC7C,MAAMmB,EAAiBjB,EAAQS,iBAAiBjhB,IAAIF,IAC7B,IAAnB2hB,KACa,IAAXnB,EACFG,GAAkBD,EAAS1gB,GAE3BohB,GACEV,EACA1gB,EACA4hB,GAAsBD,EAAgBnB,IAI9C,CACA,SAASsB,GAA0BpB,EAAS9a,GAC1C,OAAOA,EAAO8a,EAAQS,iBAAiBjhB,IACrC0gB,GAAiCF,EAAS9a,IACxC8a,EAAQG,eACd,CACA,SAASkB,GAA0BrB,EAAS3S,EAASkT,GACnD,OAAOP,EAAQS,iBAAiBjhB,IAC9BghB,GAA6BnT,EAASkT,GAE1C,CACA,SAASL,GAAiCF,EAAS9a,GACjD,MAAMmB,EAAOqZ,GAA6Bxa,KAA0B,IAAI8B,QACxE,IAAI1H,EAAM+G,EAAK7G,IAAIwgB,GASnB,OARK1gB,GACH+G,EAAK4B,IACH+X,EACA1gB,EAAMwG,OACY,iBAATZ,EAAoB,UAAUA,EAAK3B,eAAiB2B,IAI1D5F,CACT,CACA,SAASkhB,GAA6BnT,EAASkT,GAC7C,MAAMla,EAAOka,EAAUb,GAA6Ba,KAA6B,IAAIvZ,QAAYyY,GACjG,IAAIngB,EAAM+G,EAAK7G,IAAI6N,GASnB,OARK/N,GACH+G,EAAK4B,IACHoF,EACA/N,EAAMwG,QACHya,EAA6B,iBAAZA,EAAuB,UAAUA,EAAQhd,eAAiBgd,EAAU,IAAMlT,EAAQtM,OAInGzB,CACT,CACA,SAASgiB,GAA0BtB,GACjC,MAAMe,EAAavB,GAAiBhgB,IAAIwgB,GACxC,GAAIe,EAAY,CACdvB,GAAiBY,OAAOJ,GACxB,IAAK,MAAO1gB,EAAKiiB,KAAUR,EAAY,CACrC,MAAMS,EAAUC,GAA4BF,GACxCC,GACFd,GACEV,EACA1gB,EACA4hB,GAAsBlB,EAAQS,iBAAiBjhB,IAAIF,GAAMkiB,GAG/D,CACF,CACA,MAAM1B,EAAS2B,GAA4BlC,GAAY/f,IAAIwgB,IACvDF,GACFO,GACEL,EACAkB,GAAsBlB,EAAQG,gBAAiBL,IAGnDP,GAAYa,OAAOJ,EACrB,CAcA,SAAS0B,GAA2Brd,GAClC,GAAIsd,GAAkBtd,GACpB,OAAOud,GAA0Bvd,EAAKwd,mBAE1C,CACA,SAASJ,GAA4BF,GACnC,GAAIA,EAAO,CACT,GAAIrb,MAAMC,QAAQob,GAAQ,CACxB,IAAIO,EACJ,IAAK,MAAMzd,KAAQkd,EAAO,CACxB,MAAMQ,EAAcL,GAA2Brd,GAC/C,IAAoB,IAAhB0d,EAAsB,OAAO,EACjCD,EAAkBE,GAAYhX,MAAM8W,EAAiBC,EACvD,CACA,OAAOD,CACT,CACE,OAAOJ,GAA2BH,EAEtC,CACF,CACA,SAASK,GAA0BK,GACjC,GAAIA,EAAK,CACP,IAAIC,EACJ,GAAIhc,MAAMC,QAAQ8b,GAAM,CACtB,IAAK,MAAM,iBAAEE,KAAsBF,EAAK,CACtC,IAAyB,IAArBE,EAA2B,OAAOA,EACtCD,EAAsBF,GAAYhX,MAChCkX,EACAC,EAEJ,CACA,OAAOD,CACT,CACE,OAAOD,EAAIE,gBAEf,CACF,CACA,SAASjB,GAAsBjW,EAAGC,GAChC,OAAU,IAAND,IAAoB,IAANC,GACX8W,GAAYhX,MAAMC,EAAGC,EAC9B,CACA,SAASmV,GAA0BL,EAASF,GAC1CE,EAAQG,gBAAkBL,CAC5B,CACA,SAASY,GAA+BV,EAAS1gB,EAAKwgB,GACpDE,EAAQS,iBAAiBxY,IAAI3I,EAAKwgB,EACpC,CAGA,IAAIsC,GAAsBphB,EAAQ,+CAC9BqhB,GAAsB/T,IACxB,MAAMH,EAAsB,IAAInH,QAChC,MAAO,CACL,KACE,IAAIiH,EAAQE,EAAI3O,KAAI,EAAI4iB,GAAoBE,eAI5C,OAHKrU,GACHE,EAAIlG,KAAI,EAAIma,GAAoBE,cAAerU,EAAQK,KAElDL,CAAK,EAEbnO,IACCqO,EAAIlG,KAAI,EAAIma,GAAoBE,cAAexiB,EAAM,EAExD,EAEH,SAASyiB,GAAmBjjB,EAAKgP,GAC/B,MAAO,CACJ0R,IACC,MAAMwC,GAAqB,EAAIJ,GAAoBE,cAAcrU,MAAM3O,KAAS,CAAC,EAEjF,OADoBkjB,EAAmBxC,EAAQyC,MAAQnU,GAAQA,EAAK0R,EAClD,EAEpB,CAACA,EAASlgB,OACmB,EAAIsiB,GAAoBE,cAAcrU,MAAM3O,KAAS,CAAC,GAC9D0gB,EAAQyC,IAAM3iB,CAAK,EAG5C,CAGA,IAAI4iB,GAAmB1hB,EAAQ,yCAC3B2hB,GAAuB3hB,EAAQ,+CAC/B4hB,GAAiB,kBACrB,SAASC,GAAmBxhB,GAC1B,MAAM0C,EAAQ1C,EAAII,KAAKsC,QAAU,CAAC,EAClC,QAA0B,IAAtBA,EAAM+e,YAAwB,CAChC,MAAM5iB,EAAQmB,EAAI7B,IAAI,QAiBtB,GAhBIU,EAAM6iB,mBACRhf,EAAM+e,YAAsC,MAAxB5iB,EAAMuB,KAAK3B,MAAM,GAAa,GAAuB,EAAI6iB,GAAqBK,aAAa3hB,GAAO,EAAoB,EAC1I0C,EAAMkf,gBAAkBlf,EAAMkf,iBAAkB,GACvC/iB,EAAMgjB,gBA0BrB,SAAkChjB,EAAO6D,GACvC,MAAMof,EAAU,CAACjjB,GACjB,IAAI0J,EACAlH,EAEA0gB,EADAjf,GAAW,EAEf,MAAQyF,EAAQuZ,EAAQE,QAAmB,IAAT3gB,GAChC,GAAIkH,EAAM0Z,0BACRH,EAAQxX,KAAK/B,EAAMpK,IAAI,eACnBoK,EAAMnI,KAAKkD,WACbwe,EAAQxX,KAAK/B,EAAMpK,IAAI,mBAEpB,GAAIoK,EAAM2Z,sBACa,OAAxB3Z,EAAMnI,KAAK6C,SACb6e,EAAQxX,KAAK/B,EAAMpK,IAAI,SAEvB2E,GAAW,EAEbgf,EAAQxX,KAAK/B,EAAMpK,IAAI,eAClB,GAAIoK,EAAM4Z,yBACfL,EAAQxX,KAAK/B,EAAMpK,IAAI,eAClB,GAAIoK,EAAM6Z,qBACf/gB,EAA+B,MAAxBkH,EAAMnI,KAAK6C,eAA6B,IAAT5B,EAAkB,EAAqB,OACxE,GAAIkH,EAAMmZ,mBAAqBnZ,EAAM8Z,oBAC1ChhB,OAAgB,IAATA,EAAkB,EAAqB,OACzC,GAAIkH,EAAM+Z,gBACfxf,GAAW,OACN,GAAIyF,EAAMsZ,eAAgB,CAC/B,GAAwB,cAApBtZ,EAAMnI,KAAKV,KAAsB,CACnCoD,GAAW,EACX,QACF,CACA,MAAMkJ,EAAUzD,EAAMxB,MAAMwb,WAAWha,EAAMnI,KAAKV,MAClD,IAAKsM,EAAS,CACZ3K,EAAO,EACP,QACF,CACA,GAAqB,WAAjB2K,EAAQwW,KAAmB,CAC7B,MAAMC,EAAOzW,EAAQ1F,KAAKd,OAC1B,GAAI+b,GAAe3S,KAAK6T,EAAKvR,OAAOzS,QAAUgkB,EAAKC,WAAWC,MAAM5V,GAAOsU,GAAiB7f,MAAMohB,yBAAyB7V,KAAM,CAC/H,MAAM8V,GAAiB,EAAIvB,GAAqBwB,kBAAkBjkB,EAAO4jB,EAAKvR,OAAOzS,QAAUgkB,EAAKvR,OAAOzS,MAC9F,IAAT4C,GAA8B0gB,GAAmBA,IAAoBc,GACvExhB,EAAO,EACP0gB,OAAkB,IAElB1gB,EAAO,EACP0gB,EAAkBc,EAEtB,MACExhB,EAAO,EAET,QACF,CACA,MAAM0hB,EAAa/W,EAAQ1F,KAC3B,GAAIyc,EAAW5U,cAAiC,UAAjBnC,EAAQwW,KAAkB,CACvD,MAAMQ,EAAiBD,EAAW5kB,IAAI,QAAQiC,KAAK3B,MACnD,GAAuB,UAAnBukB,EAA4B,CAC9BlB,EAAQxX,KACNyY,EAAW5kB,IAAI,cAAc,GAAGA,IAAI,UAEtC,QACF,CACA,GAAuB,QAAnB6kB,EAA0B,CAC5B3hB,EAAO,EACP,QACF,CACA,QACF,CACAA,EAAO,CACT,MACEA,EAAO,EAGXqB,EAAM+e,YAAcpgB,EACpBqB,EAAMkf,gBAAkB9e,EACxBJ,EAAMugB,gBAAiB,EACV,IAAT5hB,GAA8B0gB,IAChCrf,EAAMqf,gBAAkBA,EAE5B,CAxGMmB,CAAyBrkB,EAAO6D,GACN,IAAtBA,EAAM+e,cACR/e,EAAM+e,YAAc,IAEb5iB,EAAMwjB,sBAAwBxjB,EAAMuB,KAAKoD,YAAYjD,OAC9DmC,EAAM+e,YAAc,EAEpB/e,EAAM+e,YAAc,OAEI,IAAtB/e,EAAM+e,cACR/e,EAAM+e,YAAc,GAEI,IAAtB/e,EAAM+e,YAAmC,CAC3C,MAAM0B,GAAY,EAAI7B,GAAqB8B,gBAAgBpjB,GACtDmjB,EAEkD,UAA5CA,EAAUE,IAAIhd,QAAQ3D,MAAM4gB,cACrC5gB,EAAM+e,YAAc,EACpB/e,EAAM4gB,YAAc,UACnB,EAAIhC,GAAqBL,cAAc7gB,KAAKsC,QAAU,CAAC,GAAG6gB,aAAc,GAJzE7gB,EAAM+e,YAAc,CAMxB,CACF,CACA,OAAO/e,EAAM+e,WACf,CAmFA,IAAI+B,GAAc,IAAIra,IAAO,SAAyBS,EAAGC,GACvD,OAAOD,EAAEwX,GAAKvX,EAAEuX,EAClB,IACA,SAASqC,GAAalb,GACpB,MAAM7F,EAAQ6F,EAAMnI,KAAKsC,QAAU,CAAC,EACpC,IAAIic,EAAUjc,EAAMic,QACpB,IAAKA,IAA2B,YAAfpW,EAAMlH,MAAsBkH,EAAMpK,IAAI,QAAQoC,QAAS,CACtE,MAAMmjB,EAAgBnb,EAAME,WAAakb,GAAmBpb,EAAME,iBAAc,EAC1Emb,EAAkBrb,EAAME,YAAYtK,IACxC,QAEI0lB,EAActb,EAAMO,YAAc,GAAKlD,EAAYge,EAAgBnU,WAAa,YAChFqU,EAAevb,EAAMwb,IAAIle,KAAKS,KAAKlG,KAAKsC,QAAU,CAAC,EACnDshB,EAAWF,EAAaE,WAAa,GAC3CrF,EAAUjc,EAAMic,QAAU,CACxByC,GAAI4C,EAASzjB,OACbb,KAAMmkB,EACNI,IAAKL,GAAiBxjB,KAAK6jB,UAAO,EAClCC,MAAOR,EAAgBA,EAAcQ,MAAQ,EAAI,EACjD1e,OAAQke,EACRS,qBAAiB,EACjBC,YAAQ,EACRC,wBAAoB,EACpBC,sBAAkB,EAClBC,cAAU,EACVC,aAAS,EACTC,oBAAgB,EAChB3F,qBAAiB,EACjBM,iBAAkC,IAAIhZ,IACtCse,QAASC,GAAepc,GACxBqc,wBAAoB,EACpBC,uBAAmB,EACnBC,gBAAgB,EAChBC,UAAU,GAEZf,EAAS1Z,KAAKqU,EAChB,CACA,OAAOA,CACT,CACA,SAASgF,GAAmBpb,GAC1B,IAAIiD,EAAMjD,EACV,OAAa,CACX,GAAiB,YAAbiD,EAAInK,MAAmC,iBAAbmK,EAAInK,OAA4BmK,EAAIpL,KAAK4kB,gBAAkBC,GAAazZ,EAAI/C,YACxG,OAAOgb,GAAajY,GAEtBA,EAAMA,EAAI/C,UACZ,CACF,CACA,SAASyc,GAAkB5kB,GACzB,OAAOA,EAAKF,KAAKsC,OAAOic,OAC1B,CACA,SAASwG,GAAW5c,GAClB,IAAIoW,EACAyG,EAAc7c,EAClB,UAAuD,KAA/CoW,EAAUyG,EAAYhlB,KAAKsC,OAAOic,UACxCyG,EAAcA,EAAY3c,WAE5B,OAAOkW,CACT,CACA,IAAK0G,IAAwBnE,GAC3B,qBACCvC,GAAYtX,EAAsB,QAAQsX,EAAQyC,YAEhDkE,GAAyBC,IAA2BrE,GAAmB,iBAAiB,KAAM,KAC9FsE,IAAuBtE,GAC1B,mBACA,IAAMlD,GAAkBxc,MAAMI,WAAW,eAE3C,SAAS6jB,GAAeC,GACtB,MAAM,SAAE1B,IAAa,EAAI/F,GAAqBgD,cAAc7gB,KAAKsC,MACjEshB,GAAU3Y,QAAQqa,EACpB,CAOA,SAASf,GAAepc,GACtB,MAAMjI,EAAOiI,EAAMpK,IAAI,QACjBwnB,EAAc,CAClBC,UAAW,KACXC,QAAS,KACTC,aAAa,GAEf,IAAK,IAAIC,EAAWzlB,EAAKC,OAAQwlB,KAAc,CAC7C,MAAMF,EAAUG,GAAmB1lB,EAAKylB,GAAW,UAAWJ,GAC9D,GAAgB,OAAZE,EAAkB,CACpBF,EAAYE,QAAUA,EACN,IAAZA,IACFF,EAAYG,aAAc,GAE5B,IAAK,IAAIG,EAAa,EAAGA,EAAaF,EAAUE,IAAc,CAC5D,MAAML,EAAYI,GAAmB1lB,EAAK2lB,GAAa,aACvD,GAAkB,OAAdL,EAGF,OAFAD,EAAYC,UAAYA,EACxBD,EAAYG,aAAc,EACnBH,CAEX,CAEA,OADAA,EAAYC,UAAYI,GAAmB1lB,EAAKylB,GAAW,aACpDJ,CACT,CACF,CACA,OAAO,IACT,CACA,SAASK,GAAmBzd,EAAO2d,EAAaP,GAC9C,OAAQpd,EAAMlH,MACZ,IAAK,YACH,OAAO,EACT,IAAK,mBACH,OAAO,EACT,IAAK,iBACL,IAAK,eACL,IAAK,oBACL,IAAK,uBACL,IAAK,yBACH,OAAO,KACT,IAAK,WAAY,CACf,MAAMrB,EAAMuI,EACZ,GAAI2F,GAAUlO,GACZ,OAAQA,EAAII,KAAKV,KAAKjB,OACpB,IAAK,eACH,OAAO,EACT,IAAK,cACL,IAAK,aACH,OAAO,EACT,IAAK,MACL,IAAK,KACL,IAAK,QACL,IAAK,MACH,OAAO,EACT,QACE,OAAO,SAEN,KAAI,EAAIwf,GAAqB0D,aAAa3hB,GAC/C,OAAO,EACF,IAAI,EAAIie,GAAqBkI,gBAAgBnmB,GAClD,OAAO,KACF,GAAIge,GAAkBxc,MAAMkgB,gBAAgB1hB,EAAII,KAAKV,MAAO,CACjE,MAAM0mB,GAAa,EAAInI,GAAqBmF,gBAAgBpjB,IAAMqjB,IAAIhd,QAAQ3D,MAAMic,QACpF,GAAIyH,EACF,OAAIA,EAAW1B,SACTiB,IAAgBS,EAAW1B,QAAQoB,aACjB,YAAhBI,IACFP,EAAYC,UAAYQ,EAAW1B,QAAQkB,UAC3CD,EAAYG,aAAc,GAGvBM,EAAW1B,QAAQwB,IAEnB,IAGb,EACF,EAEF,OAAO,CACT,CACA,IAAIG,GAAuB1H,IACzB,GAAIA,EAAQoG,SAAU,OAAO,EAC7B,MAAM,kBAAEF,GAAsBlG,EAC9B,OAAIkG,KACO7E,GACP6E,EAAkBlG,QAClBkG,EAGO,EAEb,SAASyB,GAAiB3H,EAAS3S,GACjC,OAAO2S,EAAQnZ,QAAQ4b,KAAOpV,EAAQ2S,QAAQyC,EAChD,CAIA,SAASmF,GAAiB5H,EAAS6H,GACjC,OAJF,SAAyB7H,EAAS6H,GAChC,OAAO7H,EAAQoG,UAAYuB,GAAiB3H,EAAS6H,EACvD,CAEUC,CAAgB9H,EAAS6H,EACnC,CAoBA,SAASE,GAAqB/H,EAASgI,GACrC,GACE,GAAIA,IAAUhI,EACZ,OAAO,QAEFgI,EAAQA,EAAMnhB,QACvB,OAAO,CACT,CAkBA,SAASyf,GAAajlB,GACpB,GAAIkO,GAAUlO,GACZ,OAAQA,EAAII,KAAKV,KAAKjB,OACpB,IAAK,eACL,IAAK,cACL,IAAK,aACH,OAAO,EACT,QACE,OAAO,EAGb,OAAmC,IAA5B+iB,GAAmBxhB,EAC5B,CAGA,IAAI4mB,GAAoBjnB,EAAQ,yCAC5BknB,GAAuBlnB,EAAQ,+CAG/BmnB,GAAczoB,EAAQsB,EAAQ,gDA8BlC,IAAIonB,GAAiB,sBAMjBC,GAAoBrnB,EAAQ,yCAC5BsnB,GAAuBtnB,EAAQ,+CAG/BunB,GAAoBvnB,EAAQ,yCAC5BwnB,GAAuBxnB,EAAQ,+CAGnC,SAASynB,GAAapnB,GACpB,MAAMwF,EAA6B,iBAApBxF,EAAIwF,OAAOnE,KAA0BrB,EAAIyI,WAAWA,WAAazI,EAAIyI,WACpF,GAAoB,aAAhBjD,EAAOnE,KACT,OAAOmE,CAEX,CAGA,IAAI6hB,GAAoB1nB,EAAQ,yCAChC,SAAS2nB,GAAMC,EAAchf,GAC3B,IAAKgf,EACH,OAAO,EAET,MAAM,KAAEnnB,GAASmI,EACXif,EAASC,GAAeF,GAAgBA,EAAaG,QAAUH,EAMrE,OALII,GAAiBH,GACnBA,EAAOjf,EAAO8e,GAAkB7lB,OACvBgmB,EAAOF,OAChBE,EAAOF,MAAM/e,EAAO8e,GAAkB7lB,OAEjCpB,IAASmI,EAAMnI,IACxB,CACA,SAASwnB,GAAKL,EAAchf,GAC1B,IAAKgf,EACH,OAAO,EAET,MAAM,KAAEnnB,GAASmI,EACXif,EAASC,GAAeF,GAAgBA,EAAaG,QAAUH,EAIrE,OAHKI,GAAiBH,IAAWA,EAAOI,MACtCJ,EAAOI,KAAKrf,EAAO8e,GAAkB7lB,OAEhCpB,IAASmI,EAAMnI,IACxB,CACA,SAASqnB,GAAeD,GACtB,OAAO9U,QAAQ8U,EAAOE,QACxB,CACA,SAASC,GAAiBH,GACxB,MAAyB,mBAAXA,CAChB,CAoBA,SAASK,IAAkB,KACzBC,EAAI,IACJC,IAEA,MAAO,CACLT,KAAAA,CAAM/e,GACJ+e,GAAMxf,IAAiBggB,EAAOC,EAAKxf,EACrC,EACAqf,IAAAA,CAAKrf,GACHqf,GAAK9f,IAAiBggB,EAAOC,EAAKxf,EACpC,EAEJ,CAGA,IAAIyf,GAAoBroB,EAAQ,yCAG5BsoB,GAAoBtoB,EAAQ,yCAC5BuoB,GAAuBvoB,EAAQ,+CAQ/BwoB,GAAoBxoB,EAAQ,yCAChC,SAASyoB,GAAiB1C,GACxB,OAAQA,EAAGrkB,MACT,IAAK,sBACL,IAAK,qBACL,IAAK,0BACH,OAAOqkB,EACT,QACE,OAAOyC,GAAkB3mB,MAAM6mB,mBAC7B,KACA3C,EAAGtB,OACHsB,EAAGplB,KACHolB,EAAGrV,MACHqV,EAAG4C,WAGX,CAGA,SAASC,KACP,OAAOhhB,EAAa,UACtB,CACA,SAASihB,GAAoB/J,EAAQzb,GACnC,OAAOyb,GAAoB,IAAXA,EAAkBzb,EAAOilB,GAAkBzmB,MAAMinB,kBAC/D,KACApL,GACE,cACA4K,GAAkBzmB,MAAMI,WAAW2F,EAAa,cAChD0gB,GAAkBzmB,MAAMib,eACtBiM,IACE,EAAIR,GAAqBjH,cAAc7gB,KAAKsC,MAAMimB,sBAClDlK,KAINzb,QACE,CACN,CACA,SAAS4lB,GAAkBnK,GACzB,OAAOpB,GACL,iBACA4K,GAAkBzmB,MAAMI,WAAW2F,EAAa,cAChD0gB,GAAkBzmB,MAAMib,eACtBiM,IACE,EAAIR,GAAqBjH,cAAc7gB,KAAKsC,MAAMimB,sBAClDlK,IAIR,CACA,IAAIoK,GAAe,CACjBvpB,UAAW,CACTsoB,IAAAA,CAAKvhB,GACHyiB,GAAUziB,GACV0iB,GAA0B1iB,GAC1B3B,EAAgB2B,EAAQjG,KAAM,OAAQ4oB,IACtC,MAAMC,EAAgB,GACtB,IAAK,MAAMC,KAAS7iB,EAAQlI,IAAI,SA9DpBoK,EA+DI2gB,GA9DPC,uBAAyB5gB,EAAM6gB,uBAAyB7gB,EAAM8gB,iBAAiB,CAAEC,QAAQ,IAiErFJ,EAAMG,qBACXH,EAAM9oB,KAAK7B,QAAgC,WAAtB2qB,EAAM9oB,KAAK7B,OAClC2qB,EAAM5nB,SAEN4nB,EAAMK,oBAAoBL,EAAM9oB,KAAKE,QANvC2oB,EAAc3e,KAAK4e,EAAM9oB,MACzB8oB,EAAM5nB,UAjEhB,IAAkBiH,EA0EZ,MAAMihB,EAAc/hB,EAAc,cAAgBF,EAAa,aACzDkiB,EAAYhiB,EAAc,YAAc8gB,KACxCmB,EAAYzB,GAAkBzmB,MAAMmoB,wBACxCH,EAAc,CAACvB,GAAkBzmB,MAAMI,WAAW,SAAUqmB,GAAkBzmB,MAAMI,WAAW4nB,IAAgB,CAACvB,GAAkBzmB,MAAMI,WAAW,UACnJqmB,GAAkBzmB,MAAMooB,eAAeX,IAEnCY,EAAgB5B,GAAkBzmB,MAAMsoB,yBAC5CzM,GACE,iBACA4K,GAAkBzmB,MAAME,cAAc2E,EAAQ0d,IAAIle,KAAK4H,SAASC,MAAM0T,IACtEqI,EAAYxB,GAAkBzmB,MAAMI,WAAW6nB,GAAaC,IAG5DD,EACFpjB,EAAQjG,KAAKE,KAAKgK,KAChB2d,GAAkBzmB,MAAMuoB,oBAAoB,QAAS,CACnD9B,GAAkBzmB,MAAMwoB,mBAAmB/B,GAAkBzmB,MAAMI,WAAW6nB,GAAYC,KAE5FG,GAGFxjB,EAAQjG,KAAKE,KAAKgK,KAAKuf,EAE3B,IAGJ,SAASb,GAAY5oB,EAAMuE,GACzB,OAEF,SAAgCvE,GAC9B,OAAQA,EAAKiB,MACX,IAAK,aACL,IAAK,mBAAoB,CACvB,MAAM,MAAEqB,GAAUtC,EAClB,GAAIsC,KAAWA,EAAMunB,OAASvnB,EAAMunB,KAAKje,QAAQke,UAAYxnB,EAAMsJ,UAAYtJ,EAAMsJ,QAAQke,UAC3F,OAAOC,GAAmB/pB,EAE9B,EAEJ,CAZSgqB,CAAuBhqB,IAahC,SAAuCA,EAAMuE,GAC3C,OAAQvE,EAAKiB,MACX,IAAK,cAAe,CAClB,MAAM6D,EAAcmlB,GAA0BjqB,GAC9C,OAAO8E,GAAe+iB,GAAkBzmB,MAAM8oB,cAAclqB,EAAKnC,IAAKiH,EACxE,CACA,IAAK,qBAAsB,CACzB,MAAMA,EAAcmlB,GAA0BjqB,GAC9C,OAAO8E,GAAe+iB,GAAkBzmB,MAAM+oB,qBAAqBnqB,EAAKnC,IAAKiH,EAC/E,CACA,IAAK,eAAgB,CACnB,MAAMA,EAAcmlB,GAA0BjqB,GAC9C,OAAO8E,GAAe+iB,GAAkBzmB,MAAMmb,eAAevc,EAAKnC,IAAKiH,EACzE,CACA,IAAK,sBAAuB,CAC1B,MAAM,MAAExC,GAAUtC,EAClB,GAAIoqB,GAAoB9nB,GAAQ,CAC9B,IAAI+nB,EAA2BC,GAA+BvsB,IAC5DwG,GAEG8lB,GACHC,GAA+B9jB,IAC7BjC,EACA8lB,EAA2B,IAG/BA,EAAyBngB,KAAK,CAC5B8W,GAAIhhB,EAAKghB,GAAG1hB,KACZirB,WAAYjoB,EAAMioB,YAEtB,CACA,KACF,CACA,IAAK,0BACL,IAAK,qBACH,OAAON,GAA0BjqB,GAEnC,IAAK,iBACL,IAAK,kBAMT,SAAmCE,GACjC,MAAMmqB,EAA2BC,GAA+BvsB,IAAImC,GACpE,GAAImqB,EACF,IAAK,MAAM,GAAErJ,EAAE,WAAEuJ,KAAgBF,EAC/BnqB,EAAKgK,KACH2d,GAAkBzmB,MAAM4L,oBACtBiQ,GACE,WACA4K,GAAkBzmB,MAAMI,WAAWwf,GACnC6G,GAAkBzmB,MAAME,cAAcipB,KAMlD,CApBMC,CAA0BxqB,EAAKE,MAGrC,CAvDyCuqB,CAA8BzqB,EAAMuE,EAC7E,CAuDA,IAAI+lB,GAAiD,IAAI/kB,QAiBzD,SAAS0kB,GAA0BjqB,GACjC,MAAM,MAAEsC,GAAUtC,EAClB,GAAIoqB,GAAoB9nB,GACtB,OAAO2a,GACL,WACA+K,GAAiBhoB,GACjB6nB,GAAkBzmB,MAAME,cAAcgB,EAAMioB,aAC3CjoB,EAAMooB,8BAAgCpoB,EAAMqoB,kBAAoB1F,GAAqB3iB,EAAMic,SAGlG,CAGA,IAAIqM,GAAoBrrB,EAAQ,yCAChC,SAASsrB,GAA0BC,GACjC,MAAMC,EAAO,GACPjL,EAAQ,GACd,IAAIkL,EAASF,EAAM,GACnB,IAAK,IAAInmB,EAAI,EAAGA,EAAImmB,EAAM3qB,OAAQwE,IAAK,CACrC,IAAI2f,EAAUwG,EAAMnmB,GACpB,GAAuB,iBAAZ2f,EAAsB,CAC/B,IAAIsG,GAAkBxpB,MAAMkgB,gBAAgBgD,GAErC,IAAIsG,GAAkBxpB,MAAM6gB,kBAAkBqC,GAAU,CAC7D,IAAI2G,EAAYtmB,EAAI,EACpB,MAAMumB,EAAU5G,EAAQlhB,YAAYjD,OACpCgrB,GAAWL,EAAOG,EAAW3G,EAAQ8G,OAAOjrB,OAAS+qB,GACrD,IAAK,IAAIG,EAAI,EAAGA,EAAIH,EAASG,IAC3BP,EAAMG,KAAe3G,EAAQ8G,OAAOC,GAAGhtB,MAAM2c,IAC7C8P,EAAMG,KAAe3G,EAAQlhB,YAAYioB,GAE3CP,EAAMG,GAAa3G,EAAQ8G,OAAOF,GAAS7sB,MAAM2c,IACjD,QACF,CACE8E,EAAM5V,KAAKoa,GACXyG,EAAK7gB,KAAK8gB,GACVA,EAAS,GACT,QACF,CAhBE1G,EAAUA,EAAQjmB,KAiBtB,CACA2sB,GAAU1G,CACZ,CACA,OAAIxE,EAAM3f,OACa,IAAjB2f,EAAM3f,QAAiB6qB,GAAWD,EAAK,IAG3CA,EAAK7gB,KAAK8gB,GACHJ,GAAkBxpB,MAAMkqB,gBAC7BP,EAAKre,KAAKsO,GAAQ4P,GAAkBxpB,MAAMmqB,gBAAgB,CAAEvQ,UAC5D8E,IALOA,EAAM,GAONkL,EACFJ,GAAkBxpB,MAAME,cAAc0pB,QADxC,CAGT,CACA,SAASQ,GAAcC,EAAK3c,GAC1B2c,EAAIA,EAAItrB,OAAS,IAAM2O,CACzB,CACA,SAASqc,GAAWO,EAAMtb,EAAOub,GAC/B,IAAK,IAAIhnB,EAAI+mB,EAAKvrB,OAAS,EAAGwE,GAAKyL,EAAOzL,IACxC+mB,EAAK/mB,EAAIgnB,GAAUD,EAAK/mB,EAE5B,CAGwBpF,EAAQ,yCAAhC,IACKqsB,IAAY9K,GACf,SACA,IAAM,CAAC,OAEJ+K,IAAkB/K,GACrB,eACA,IAAM,MAEHgL,IAAYhL,GAAmB,SAAS,IAAM,KAC/CiL,GAAiB,CACnB,GAAgB,MAChB,GAAmB,SACnB,GAAoB,UACpB,GAAqB,WACrB,GAAuB,aACvB,GAA8B,oBAC9B,GAA8B,oBAC9B,GAAiB,OACjB,GAAiB,OACjB,IAAiB,MACjB,IAAwB,aACxB,GAAoB,UACpB,IAAqB,UACrB,IAAoB,SACpB,IAA2B,iBAE7B,SAASC,GAAO7jB,GACd2jB,GAAS/G,GAAW5c,IAAQ+B,KAAK,EACnC,CACA,SAAS+hB,GAAM9jB,GACb2jB,GAAS/G,GAAW5c,IAAQ+B,KAAK,EACnC,CACA,SAASgiB,GAAa/jB,GACpB2jB,GAAS/G,GAAW5c,IAAQ+B,KAAK,EAAe,EAClD,CAiBA,SAASgD,GAAM/E,EAAOgkB,GACpB,GAAIzkB,IACF,OAEF,MAAM6W,EAAUwG,GAAW5c,GACrBikB,EAAQN,GAASvN,GACjB8N,EAAQT,GAASrN,GACjB+N,EAAcT,GAAetN,GACnC,IAAIgO,EAAa,GACjB,GAAIH,EAAMjsB,OAAQ,CAChB,MAAMqsB,EAAY,GAClB,IAAI1I,EAAQ,EACZ,IAAK,MAAM2I,KAAQL,EACJ,IAATK,GACF3I,IACA0I,EAAUtiB,KAAK,MAEf4Z,IACIA,GAAS,GACX0I,EAAUrsB,OAASqsB,EAAUE,YAAY,IACzCF,EAAUtiB,KAAK,MAEfsiB,EAAUrsB,OAASqsB,EAAUE,YAAY,KAAiB,EAC1DF,EAAUtiB,KAAK,KACf4Z,EAAQ,IAId,IAAI6I,EAAUH,EAAU,GACpBjmB,EAAQ,EACZ,IAAK,MAAMqmB,KAAQJ,EACbI,IAASD,GACXL,EAAYpiB,KAAK,GAAG6hB,GAAeY,MAAYpmB,MAC/CgmB,GAAcM,GAAYF,EAASpmB,GACnComB,EAAUC,EACVrmB,EAAQ,GAERA,IAGJ+lB,EAAYpiB,KAAK,GAAG6hB,GAAeY,MAAYpmB,MAC/CgmB,GAAcM,GAAYF,EAASpmB,GACnC6lB,EAAMjsB,OAAS,CACjB,MACa,IAATgsB,IACW,KAATA,GACFW,GAAQ3kB,EAAM,MAEhBmkB,EAAYpiB,KAAK,GAAG6hB,GAAeI,MACnCI,GAAc1R,OAAOC,aAAaqR,IAEpCX,GAAca,EAAOE,EACvB,CACA,SAASM,GAAYV,EAAMY,GACzB,OAAQZ,GACN,KAAK,GACH,OAAOa,GAAaD,EAAQZ,EAAM,IACpC,KAAK,GAEL,KAAK,IACH,OAAOa,GAAaD,EAAQZ,EAAM,IACpC,QACE,MAAM,IAAI/X,MAAM,yBAAyB+X,KAE/C,CACA,SAASa,GAAaD,EAAQE,EAAWC,GACvC,IAAIpjB,EAAS,GACb,GAAIijB,GAAUG,EAAW,CACvB,MAAMC,EAAa1mB,KAAKqR,MAAMiV,EAASG,GACvCpjB,GAAUkjB,GACRG,EACA,IACA,IAEFJ,GAAUI,EAAaD,CACzB,CAEA,OADApjB,GAAU+Q,OAAOC,aAAamS,EAAYF,GACnCjjB,CACT,CACA,SAASsjB,GAAc7O,GACrB,MAAMO,EAAyC,IAA/BP,EAAQ+F,SAASkB,UAAgC3K,OAAOC,aAAa,IAAqB,GACpGuS,EAAuC,IAA7B9O,EAAQ+F,SAASmB,QAA8B5K,OAAOC,aAAa,IAAqB,GAElGwS,EAAczC,GAA0B,CAAC/L,KADjC8M,GAASrN,GAC2C8O,IASlE,OARIC,GAAqC,KAAtBA,EAAYjvB,QAC7BivB,EAAY9P,gBAAkB,CAC5B,CACEvc,KAAM,eACN5C,MAAO,IAAMwtB,GAAetN,GAASgP,KAAK,MAAQ,OAIjDD,CACT,CAGA,IAAKE,IAAa1M,GAChB,UACA,IAAM,CAAC,OAEJ2M,IAAoB3M,GACvB,iBACA,IAAM,CAAC,MAET,SAASgM,GAAQ3kB,EAAOulB,GACtB,MAAMnP,EAAUwG,GAAW5c,GACrBpK,EAAM2vB,EAAUD,GAAmBD,GACzC,MAAO,CAACzC,KAASjL,KACf,MAAM6N,EAAW7N,EAAM3f,OACjBytB,EAAS7vB,EAAIwgB,GACnBiN,GAAcoC,EAAQ7C,EAAK,IAC3B,IAAK,IAAIpmB,EAAI,EAAGA,EAAIgpB,EAAUhpB,IAC5BipB,EAAO1jB,KAAK4V,EAAMnb,GAAIomB,EAAKpmB,EAAI,GACjC,CAEJ,CACA,SAASkpB,GAAY1lB,GACnB,MAAMoW,EAAUwG,GAAW5c,GACrBylB,EAASJ,GAAUjP,GACnBuP,EAAWL,GAAiBlP,GAC5BwP,EAAclD,GAA0B+C,GACxCI,EAAgBnD,GAA0BiD,GAKhD,OAJAF,EAAOztB,OAAS,EAChBytB,EAAO,GAAK,GACZE,EAAS3tB,OAAS,EAClB2tB,EAAS,GAAK,GACVC,GAAeC,EACVpG,GAAkBxmB,MAAM4L,oBAC7B4a,GAAkBxmB,MAAM6sB,mBAAmB,CACzChR,GAAY,QAAS8Q,GACrB9Q,GAAY,gBAAiB+Q,MAGxBD,EACFnG,GAAkBxmB,MAAM4L,oBAAoBiQ,GAAY,QAAS8Q,IAC/DC,EACFpG,GAAkBxmB,MAAM4L,oBAAoBiQ,GAAY,gBAAiB+Q,SAD3E,CAGT,CACA,SAASE,GAAY/lB,GACnB,MAAMvF,EAAOirB,GAAY1lB,GACrBvF,GACFuF,EAAMgmB,aAAavrB,GAAM,GAAGwB,MAEhC,CACA,SAASskB,GAAUvgB,GACjB,MAAMhK,EAASgK,EAAMO,YAAcP,EAAQA,EAAMpK,IAAI,QAC/C6E,EAAOirB,GAAY1vB,GACrByE,GACFzE,EAAO6B,KAAKE,KAAKgK,KAAKtH,EAE1B,CACA,SAASwrB,GAAe7P,GACtB,MAAM8P,EAA6C,IAA/B9P,EAAQ+F,SAASkB,UAAgC,MAAQ,GACvE8I,EAA4C,IAA7B/P,EAAQ+F,SAASmB,QAA8B,MAAQ,GACtEmI,EAASJ,GAAUjP,GACzB,MAAO,CACLgQ,MAAOC,GAASjQ,GAChB8N,MAAOe,GAAc7O,GACrBqP,OAAQ/C,GAA0B,CAACwD,KAAgBT,EAAQU,IAE/D,CACA,SAASG,GAAStmB,EAAOumB,EAAarQ,GACpC,GAAyB,IAArBqQ,EAAYztB,KACd,MAAMkH,EAAMpI,oBACV,+EAGJ,GAAI2H,KACE2W,EAAQ,CACV,MAAME,EAAUwG,GAAW5c,GAC3B2kB,GAAQ3kB,EAAM,GAAG8U,GACf,iBACAgI,GAAqB1G,GACrBoQ,GAAwBD,IACb,IAAXrQ,OAAkB,EAASmK,GAAkBnK,KAEjD,CAEJ,CAGA,IAAIuQ,GAAiC,IAAInT,SACpCoT,GAAiCC,IAA4BhO,GAAmB,eACjFiO,GAAiB,CACnBrwB,OAAAA,CAAQkB,IACN,EAAImnB,GAAqBvmB,cAAcZ,IACvC,EAAImnB,GAAqBiI,aAAapvB,IACtC,EAAImnB,GAAqBtmB,gBAAgBb,GACzCK,EAAoBL,IACpB,EAAImnB,GAAqBkI,yBAAyBrvB,EAAK,CAAC,QAAS,gBACjE,MAAMsvB,EAAYlI,GAAapnB,GAC/B,GAAIsvB,EAAW,CACb,IAAI,EAAInI,GAAqBxF,aAAa2N,GACxC,MAAMtvB,EAAI7B,IAAI,QAAQgC,oBACpB,qDAEG,GA5yDb,SAA0BH,GACxB,GAAIkO,GAAUlO,GACZ,OAAQiO,GAAWjO,IACjB,IAAK,KACL,IAAK,UACL,IAAK,OACL,IAAK,MACL,IAAK,QACL,IAAK,MACH,OAAO,EAGb,OAAO,CACT,CA+xDiBuvB,CAAiBD,GAC1B,MAAMtvB,EAAI7B,IAAI,QAAQgC,oBACpB,iDAAiDmvB,EAAUnxB,IAAI,QAAQsR,oBAG7E,CACA,GAAIuf,GAAetnB,IAAI1H,EAAIyI,YACzB,MAAMzI,EAAI7B,IAAI,QAAQgC,oBACpB,wCAA4D,YAApBH,EAAIwF,OAAOnE,KAAqB,mBAAqB,kCAG/F2tB,GAAezlB,IAAIvJ,EAAIyI,YAEzB,MAAMsF,EAASD,GAAmB9N,EAAII,MACtC,IAAK2N,EAAOtP,MACV,MAAMuB,EAAI7B,IAAI,QAAQgC,oBAAoB,sCAExC4N,EAAOyhB,aACTjR,GACEoF,GAAmB3jB,GACnBqI,KAAkBonB,kBAGxB,EACAnwB,UAAWuoB,GAAkB,CAC3BC,KAAM,CACJF,IAAAA,CAAK5nB,GACH,MAAM2e,EAAUwG,GAAWnlB,GACrB+N,EAASD,GAAmB9N,EAAII,MAStC,GARAkuB,GAAYtuB,GACR+N,EAAOyhB,aAgHnB,SAAmC7Q,EAAS9a,EAAMN,GAChD,MAAMkb,EAASsB,GAA0BpB,EAAS9a,GAC9C4a,GACFiR,GAAuB/Q,GAAS/X,IAAI/C,EAAM,CAAEN,aAAYkb,UAE5D,CApHUkR,CACEhR,EACAtW,KAAkBonB,kBAClB1hB,EAAOyhB,aAGPzhB,EAAOtP,MAAO,CAChB,MAAMmxB,EAAWvoB,EAAsB,UACvC6nB,GAAyBvQ,EAASiR,GAClC5vB,EAAI8B,YACFolB,GAAkB1lB,MAAMuoB,oBAAoB,QAAS,CACnD7C,GAAkB1lB,MAAMwoB,mBAAmB4F,EAAU7hB,EAAOtP,UAE9D,GAAG+F,MACP,CACF,GAEFujB,IAAK,CACHH,IAAAA,CAAK5nB,GACH,MAAM2e,EAAUwG,GAAWnlB,GACrB+N,EAASD,GAAmB9N,EAAII,MAClC2N,EAAOtP,OACToxB,GACElR,EACA5Q,EAAOtP,MAAMiE,OAAO8d,mBACpB,CACE5e,WAAYsb,GAAc,gBAC1B4S,2BAA4BA,KAAM,GAEpC/hB,EAAOtP,OAGPsP,EAAOyhB,aACTK,GACElR,EACA5Q,EAAOyhB,YAAY9sB,OAAO8d,mBAC1B,CACE5e,WAAYsb,GAAc,mBAC1B4S,2BAA4BA,KAAM,GAEpC/hB,EAAOyhB,aAGXxvB,EAAIsB,QACN,KAGJyuB,aAAc,CACZC,aAAa,GAEfhuB,aAAc,CACZ,CACEC,YAAa,iBACbC,YAAa,iDACbC,QAAS,oBACT8tB,mBAAoB,gDAMtBC,GAAoBvwB,EAAQ,yCAChC,SAASwwB,GAA6BnkB,GACpC,OAAIA,EAAQke,WAAale,EAAQokB,cACxBF,GAAkB1uB,MAAMI,WAAWoK,EAAQtM,WACpB,IAArBsM,EAAQqkB,SACVzT,GACLuT,GAA6BnkB,EAAQokB,eACrCpkB,EAAQqkB,SACRrkB,EAAQokB,cAActtB,UAGjBqtB,GAA6BnkB,EAAQokB,cAEhD,CAGA,IAAIE,GAAoB3wB,EAAQ,yCAChC,SAAS4wB,GAAyBC,GAChC,GAAqB,IAAjBA,EAAMjwB,QAAgB+vB,GAAkB9uB,MAAMivB,sBAAsBD,EAAM,IAAK,CACjF,MAAM,WAAEjtB,GAAeitB,EAAM,GAC7B,OAAQjtB,EAAWlC,MACjB,IAAK,mBACL,IAAK,uBACH,OAAOqvB,GAAkCntB,GAC3C,QACE,OAAOA,EAEb,CACA,OAAO+sB,GAAkB9uB,MAAMooB,eAAe4G,EAChD,CACA,SAASE,GAAkC1tB,GACzC,OAAQA,EAAK3B,MACX,IAAK,mBACL,IAAK,uBACH,OAAOivB,GAAkB9uB,MAAMmvB,wBAAwB3tB,GACzD,QACE,OAAOA,EAEb,CAGA,IAAK4tB,IAAc1P,GACjB,WACA,IAAsB,IAAI9a,OAEvByqB,GAAyBC,IAA4B5P,GAAmB,SAC7E,SAAS6P,GAAwB/wB,EAAKgxB,GACpCF,GAAyB5L,GAAkBllB,EAAI7B,IAAI,SAAU6yB,EAC/D,CACA,IAAKtB,IAA0BxO,GAAmB,6BAA6B,IAAsB,IAAI9a,MAOzG,SAAS6qB,GAA0BtS,EAAS3S,EAASzI,EAAY2b,GAC/D,MAAMT,EAASuB,GAA0BrB,EAAS3S,EAASkT,GACvDT,GACFiR,GAAuB/Q,GAAS/X,KAC7BsY,GAAW,IAAMgS,GAAiBllB,GACnC,CAAEzI,aAAYkb,UAGpB,CACA,IAAI0S,GAAoD,IAAItV,QAC5D,SAASuV,GAAmBzS,EAAS1gB,EAAKsF,GACxC4tB,GAAkC5nB,IAAIoV,GACtC+Q,GAAuB/Q,GAAS/X,IAAI3I,EAAK,CAAEsF,aAAYkb,QAAQ,GACjE,CACA,IAAK4S,GAA6BC,IAA+BpQ,GAC/D,4BAEF,SAASqQ,GAAqB5S,EAASqS,GACrC,MAAMQ,EAAOH,GAA4B1S,GACzC2S,GACE3S,EACA6S,EAAQxuB,GAASguB,EAAQQ,EAAKxuB,IAASguB,EAE3C,CACA,IAAIS,GAAwD,IAAI9rB,SAC3D+rB,IAA4BxQ,GAC/B,uBACA,IAAM,MAEHyQ,IAA2BzQ,GAAmB,wBAAwB,IAAsB,IAAI9a,MACrG,SAASwrB,GAA2BC,GAClC,MAAMC,EAASH,GAAwBE,EAAelT,SACtD,IAAI/c,EAAakwB,EAAO3zB,IAAI0zB,GAO5B,OANKjwB,GACHkwB,EAAOlrB,IACLirB,EACAjwB,EAAayF,EAAsB,MAAMwqB,EAAenyB,SAGrDkC,CACT,CACA,IAAImwB,GAAqBA,IAChB/K,GAAkBxlB,MAAME,cAAc,0BAE/C,SAASswB,GAAUrT,EAAS6B,EAAoB3hB,EAgShD,SAA4B2hB,GAC1B,IAAI3hB,EACJ,GAAI2hB,EACF,GAAI3b,MAAMC,QAAQ0b,GAAqB,CACrC3hB,EAAQ,OACR,IAAK,MAAM+hB,KAAOJ,EAChB3hB,GAAS,IAAI+hB,EAAIlhB,MAErB,MACEb,EAAQ2hB,EAAmB9gB,UAG7Bb,EAAQ,QAEV,OAAOA,CACT,CA/SwDozB,CAAmBzR,IACzE,MAAM0R,EAAUtB,GAAWjS,GAC3B,IAAIwT,EAASD,EAAQ/zB,IAAIqiB,GACzB,IAAK2R,EAAQ,CACX,MAAMC,EAAa5R,GAAsB3b,MAAMC,QAAQ0b,IAAuBA,EAAmB7B,UAAYA,GAAW6B,EAAmB6R,QAAU1T,EAAQnZ,SAAU,EAAIyhB,GAAqBhG,cAAc7gB,KAAKsC,MAAM4vB,YAAY3D,MAiDrO,GAhDAuD,EAAQtrB,IACN4Z,EACA2R,EAAS,CACPvwB,WAAYwwB,EAAapL,GAAkBxlB,MAAMI,WAAWwwB,GAAc/qB,EAAsBxI,EAAQ8f,EAAQjf,KAAKyH,QAAQ,IAAK,MAClIqZ,qBACA7B,UACArS,OAAQ,GACRimB,kBAAc,EACdC,OAAQ,GACRC,8BAA0B,EAC1BC,OAAQ,GACRC,8BAA0B,EAC1BC,YAAa,GACb9C,2BAA4BA,KAC1B,IAAIA,IAA+BqC,EAAOI,aAC1C,IAAKzC,EACH,IAAK,MAAMrxB,KAAS0zB,EAAO7lB,OACzB,GAAI7N,EAAM0zB,OAAOrC,6BAA8B,CAC7CA,GAA6B,EAC7B,KACF,CAGJ,IAAKA,IACEjrB,MAAMC,QAAQ0b,IAAuBA,EAAoB,CAC5D,IAAK,MAAMrU,KAASqU,EAAmBpU,QACrC,GAAI4lB,GAAUrT,EAASxS,GAAO2jB,6BAA8B,CAC1DA,GAA6B,EAC7B,KACF,CAEF,IAAKA,EACH,IAAK,MAAO,CAAE3jB,KAAUqU,EAAmBnU,gBACzC,GAAI2lB,GAAUrT,EAASxS,GAAO2jB,6BAA8B,CAC1DA,GAA6B,EAC7B,KACF,CAGN,CAGF,OADAqC,EAAOrC,2BAA6B,IAAMA,EACnCA,CAA0B,EAEnCpjB,MAAOqlB,GACPM,SAAUD,IAGVtqB,IACF,OAAOqqB,EACG3R,EAED3b,MAAMC,QAAQ0b,IACvBqS,GAAUrS,EAAoB2R,GAC9BA,EAAOzlB,MAAQ,KACb,MAAM,GAAE0U,EAAE,YAAE0R,GAAgBC,GAAiB50B,IAAIqiB,GACjD,OAAOnD,GACL,eACA2J,GAAkBxlB,MAAMib,eAAe2E,GACvC4R,GAAYb,GACZW,GAAetS,EAAmBjgB,OAAS,EAAIymB,GAAkBxlB,MAAMib,eAAe+D,EAAmBjgB,OAAS,QAAK,EACvHuyB,GAAe/D,GAAwB+D,GACxC,GAEMtS,EAAmB7B,UAAYA,GAAWgC,GAAYnW,KAAKmU,EAAQ0F,mBAAoB7D,KAChG2R,EAAOzlB,MAAQ,KACb,MAAM8lB,EAASQ,GAAYb,GAE3B,OAD6BtB,GAAwBlS,IACrB4H,GAAiB5H,EAAS6B,GAAsBnD,GAC9E,qBACA0R,GAAwBvO,GACxBgS,EACAlM,GAAiB3H,EAAS6B,QAAsB,EAASwG,GAAkBxlB,MAAMmoB,wBAC/E,CAACsJ,IACDC,GAAmBvU,EAAS6B,EAAmB7B,WAE/CkS,GAAwBlS,EAAxBkS,CAAiCrQ,EAAoBgS,EAAO,GAzBlEL,EAAOzlB,MAAQ,IAAMsmB,GAAYb,EA4BrC,CACA,OAAOA,CACT,CACA,SAASgB,GAAUnnB,EAASonB,EAAgB,SAC1C,MACMjB,EAASH,GADChmB,EAAQ2S,QACU3S,GAClCmmB,EAAOzlB,MAAQ,KACb,MAAMgZ,EAAKsN,GAAYb,GACjBkB,GAAkBrnB,EAAQokB,gBAAmC,IAAjBpkB,EAAQ3K,MAA2C,IAAjB2K,EAAQ3K,MAGtFiyB,IAFetnB,EAAQokB,gBAAkBpkB,EAAQqkB,YAClBrkB,EAAQC,sBAAsBC,MAAoB,4BAAZwZ,EAAGrkB,MAAsCqkB,EAAGplB,KAAKA,KAAKC,OAAS,IACzG4xB,EAAOI,aAClCgB,EAAaF,GAAkBlB,EAAOI,aAC5C,OAAIe,GAAcC,GAAcvnB,EAAQwnB,OAAOtnB,KACtCmR,GACL+V,EACArE,GAAwB/iB,EAA2B,UAAlBonB,GACjC1N,GAGKA,CACT,EAEFyM,EAAOsB,cAAgB1E,GAAwB/iB,GAC/C,IAAK,MAAMG,KAASH,EAAQI,QAC1B+mB,GAAUhnB,GAEZ,IAAK,MAAMA,KAASH,EAAQK,gBAAgBC,SAC1C6mB,GAAUhnB,GAEZ,OAAOgmB,CACT,CACA,SAASa,GAAYb,GACnB,MAAMxT,EAAUwT,EAAOxT,QACjB3S,EAAUmmB,EAAO3R,mBACjB4D,EAAS,CAAC6O,IACVS,EAAiB7uB,MAAMC,QAAQkH,GAC/B/E,EAAY+E,IAAY0nB,EACxBC,EAAU1sB,GAAa+E,EAAQ2S,UAAYA,EACjD,IAAIiV,GAAwBzB,EAAOK,OAAOjyB,OAC1C,GAAI0G,IAAckrB,EAAOM,0BAA4BzmB,EAAQI,QAAQF,MAAQF,EAAQK,gBAAgBH,MAAO,CAC1G,MAAM2nB,EAAa7M,GAAkBxlB,MAAMI,WAAWoK,EAAQtM,MAC1DsM,EAAQiY,MACV4P,EAAW5P,IAAMjY,EAAQiY,IACzB4P,EAAWrjB,MAAQxE,EAAQiY,IAAIzT,MAAMsjB,MACrCD,EAAWE,IAAM/nB,EAAQiY,IAAI8P,IAAID,OAEnC1P,EAAO9Z,KAAKupB,EACd,CACA,GAAIF,EAAS,CACX,IAAK,MAAMxnB,KAASH,EAAQI,QAAS,CACnC,MAAM4nB,EAAchC,GAAU7lB,EAAMwS,QAASxS,GAC7CgmB,EAAOK,OAAOloB,KACZ0c,GAAkBxlB,MAAM4L,oBACtB4Z,GAAkBxlB,MAAM6L,eAAe2mB,EAAYpyB,WAAY,CAC7DqxB,GACAjM,GAAkBxlB,MAAMI,WAAWoK,EAAQtM,SACxCu0B,GAAuBD,MAIlC,CACA,IAAK,MAAO/1B,EAAKkO,KAAUH,EAAQK,gBAAiB,CAClD,MAAM2nB,EAAchC,GAAU7lB,EAAMwS,QAASxS,GAC7CgmB,EAAOK,OAAOloB,KACZ0c,GAAkBxlB,MAAM4L,oBACtB4Z,GAAkBxlB,MAAM6L,eAAe2mB,EAAYpyB,WAAY,CAC7DqxB,GACArW,GACEoK,GAAkBxlB,MAAMI,WAAWoK,EAAQtM,MAC3CzB,EACA+N,EAAQlJ,aAEPmxB,GAAuBD,MAIlC,CACF,CACA,IAAK,MAAMv1B,KAAS0zB,EAAO7lB,OACzB6lB,EAAOK,OAAOloB,KACZ0c,GAAkBxlB,MAAM4L,oBACtB4Z,GAAkBxlB,MAAM6L,eAAe5O,EAAM0zB,OAAOvwB,WAAY,CAC9DnD,EAAMsI,MACNtI,EAAMA,SACHw1B,GAAuBx1B,EAAM0zB,YAUxC,GALA9mB,GAAQ8mB,EAAOI,cAAeA,IAC5BJ,EAAOK,OAAOloB,KACZ0c,GAAkBxlB,MAAM4L,oBAAoB4Z,GAAkBxlB,MAAM6L,eAAeklB,EAAc,CAACU,MACnG,IAECU,EAAS,CACX,IAAIO,EACAC,EACJ9oB,GAAQW,EAAQooB,iBAAkBC,IAC5BroB,EAAQsoB,UACN/N,GAAiB8N,EAAgBroB,IAC9BkoB,IACHA,EAAqB,GACrBC,EAAiC9sB,EAC/B8qB,EAAOvwB,WAAWlC,KAAO,YAE3ByyB,EAAOK,OAAOloB,KACZ0c,GAAkBxlB,MAAM4L,oBACtB4Z,GAAkBxlB,MAAM6L,eAAe8mB,EAAgC,CACrElB,QAKRiB,EAAmB5pB,KACjB0nB,GAAUqC,EAAgBroB,GAASpK,aAGrCuwB,EAAOK,OAAOloB,KACZ0c,GAAkBxlB,MAAM4L,oBACtB4Z,GAAkBxlB,MAAM6L,eAAe2kB,GAAUqC,EAAgBroB,GAASpK,WAAY,CACpFqxB,OAKV,IAEEkB,IACDhC,EAAOoC,oBAAsB,IAAIjqB,KAChC0c,GAAkBxlB,MAAMuoB,oBAAoB,QAAS,CACnD/C,GAAkBxlB,MAAMwoB,mBACtBmK,EACA9W,GAAY,oBAAqB6W,MAK3C,CACA,GAAI/B,EAAOO,OAAOnyB,OAAQ,CACxB,MAAMi0B,EAAmBxN,GAAkBxlB,MAAMI,WAAW,GAAGuwB,EAAOvwB,WAAWlC,eACjFyyB,EAAOK,OAAOloB,KACZ0c,GAAkBxlB,MAAM4L,oBACtB4Z,GAAkBxlB,MAAM6L,eAAemnB,EAAkB,CAACvB,MAGhE,CAWA,GAVIS,GAAkBvB,EAAOM,0BAC3BN,EAAOK,OAAOtlB,QACZ8Z,GAAkBxlB,MAAMuoB,oBAAoB,QAAS,CACnD/C,GAAkBxlB,MAAMwoB,mBACtByK,GAAuB9V,EAASwT,EAAOM,0BACvCQ,OAKJW,GAAiD,IAAzBzB,EAAOK,OAAOjyB,OAAc,CACtD,MAAMiyB,EAASL,EAAOK,OAAO,GAC7B,GAAoB,wBAAhBA,EAAOnxB,KAAgC,CACzC,MAAM,WAAEkC,GAAeivB,EACvB,GAAwB,mBAApBjvB,EAAWlC,KAA2B,CACxC,MAAMic,EAAO/Z,EAAWmxB,UACxB,GAAItQ,EAAO7jB,QAAU+c,EAAK/c,OAAQ,CAChC,IAAK,IAAIwE,EAAIuY,EAAK/c,OAAQwE,KAAO,CAC/B,MAAM4vB,EAAQvQ,EAAOrf,GACf0Y,EAAMH,EAAKvY,GACjB,GAAiB,eAAb0Y,EAAIpc,MAAyBszB,EAAMj1B,OAAS+d,EAAI/d,KAAM,CACxDk0B,GAAuB,EACvB,KACF,CACF,CACA,GAAIA,EACF,OAAOrwB,EAAW2F,MAEtB,CACF,CACF,CACF,CACA,OAAO8d,GAAkBxlB,MAAMmoB,wBAAwBvF,EAAQ4C,GAAkBxlB,MAAMooB,eAAeuI,EAAOK,QAC/G,CACA,IAAIoC,GAAyC,IAAI/Y,QAC7CgZ,GAAiB,GACrB,SAASZ,GAAuB9B,GAC9B,OAAIA,EAAO2C,WACJF,GAAuBltB,IAAIyqB,KAC9ByC,GAAuBrrB,IAAI4oB,GAC3BztB,EAAgBytB,EAAQ,YAAa4C,KAEhC5C,EAAO2C,WAETD,EACT,CACA,SAAShC,GAAUmC,EAAUC,GAC3B,GAAIpwB,MAAMC,QAAQkwB,GAEhB,YADAA,EAAS3pB,SAAS6pB,GAAMrC,GAAUqC,EAAGD,KAGvC,MAAME,EAAiBnD,GAAUiD,EAAWtW,QAASqW,GACrDG,EAAe5C,aAAejoB,GAC5B6qB,EAAe5C,aACf0C,EAAWrzB,WAEf,CAiBA,SAASwzB,GAAqC9X,GAC5C,IAAK,IAAIvY,EAAIuY,EAAK/c,OAAQwE,KAAO,CAC/B,MAAM0Y,EAAMH,EAAKvY,GACjB,GAAK0Y,EAEE,GAAIuJ,GAAkBxlB,MAAM6zB,0BAA0B5X,IAAQuJ,GAAkBxlB,MAAM8zB,iBAAiB7X,EAAInd,MAAO,CACvH,MAAMA,EAAOmd,EAAInd,KAAKA,KACF,IAAhBA,EAAKC,OACP+c,EAAKvY,GAAKiiB,GAAkBxlB,MAAMib,eAAe,GACxB,IAAhBnc,EAAKC,QAAgBymB,GAAkBxlB,MAAMivB,sBAAsBnwB,EAAK,MACjFmd,EAAInd,KAAOowB,GAAkCpwB,EAAK,GAAGiD,YAEzD,MAAWyjB,GAAkBxlB,MAAM8gB,cAAc7E,IAAQuJ,GAAkBxlB,MAAM+zB,kBAAkB9X,IAAyB,SAAjBA,EAAIxa,YAC7Gqa,EAAKvY,GAAKiiB,GAAkBxlB,MAAMib,eAAe,SATjDa,EAAKvY,GAAKiiB,GAAkBxlB,MAAMib,eAAe,EAWrD,CACA,IAAK,IAAI1X,EAAIuY,EAAK/c,OAAS,EAAGymB,GAAkBxlB,MAAMg0B,iBAAiBlY,EAAKvY,KAAyB,IAAlBuY,EAAKvY,GAAGtG,OACzF6e,EAAK/c,OAASwE,IAEhB,OAAOuY,CACT,CACA,SAASmY,GAAap0B,EAAMq0B,EAAelV,EAAoBmV,EAAWC,GACxE,MAAMzD,EAASH,GAAU0D,EAAelV,GAClCqV,EAAa1D,EAAO9wB,KAAU,GAC9BkI,EAAe,WAATlI,EAAoBy0B,GAAsBC,GAMtD,GALIlxB,MAAMC,QAAQ6wB,GAChBE,EAAWvrB,QAAQqrB,GAEnBE,EAAWvrB,KAAKqrB,IAEK,IAAnBC,EACF,GAAIA,EACF,IAAK,MAAMhV,KAAOgV,EAChBrsB,EAAI4oB,EAAQvR,QAGdrX,EAAI4oB,EAAQ3R,EAGlB,CACA,SAASsV,GAAoB3D,EAAQ3R,GACnC2R,EAAOQ,yBAA2BhS,GAAYhX,MAC5CwoB,EAAOQ,yBACPnS,EAEJ,CACA,SAASuV,GAAoB5D,EAAQ3R,GACnC2R,EAAOM,yBAA2B9R,GAAYhX,MAC5CwoB,EAAOM,yBACPjS,EAEJ,CACA,SAASqP,GAAS6F,EAAelV,EAAoB2R,EAAQ1zB,EAAOsI,EAAQksB,IAC1E,MAAM+C,EAAehE,GAAU0D,EAAelV,GAC9CuV,GAAoBC,EAAcxV,GAClCwV,EAAa1pB,OAAOhC,KAAK,CACvB6nB,SACA1zB,QACAsI,SAEJ,CACA,SAASkvB,GAAoBtX,EAAS6B,EAAoBnf,GACxD,MAAM,UACJ2E,EACAE,MAAM,SAAED,KACN,EAAIghB,GAAqB5iB,WAC7B,IAAIxF,EAAQ,GACZ,GAAI2hB,EACF,GAAkC,iBAAvBA,EACT3hB,GAAS,IAAI2hB,SACR,GAAI3b,MAAMC,QAAQ0b,GACvB,IAAK,MAAMI,KAAOJ,EAChB3hB,GAAS,IAAI+hB,EAAIlhB,YAGnBb,GAAS,IAAI2hB,EAAmB9gB,OAGpC,OAAO,EAAIunB,GAAqBiP,eAC9BlwB,EACAC,EACA,GAAG0Y,EAAQyC,KAAKviB,IAAQwC,EAAO,IAAMA,EAAO,KAEhD,CACA,IAAI80B,GAA2C,IAAIxwB,QACnD,SAASywB,GAAezX,EAAS9f,GAC/B,MAAM,UACJmH,EACAE,MAAM,SAAED,KACN,EAAIghB,GAAqB5iB,WAC7B,IAAIgyB,EAAOF,GAAyBh4B,IAAIwgB,GACnC0X,GAAMF,GAAyBvvB,IAAI+X,EAAS0X,EAAuB,IAAIrb,KAC5E,MAAMsb,GAAS,EAAIrP,GAAqBiP,eACtClwB,EACAC,EACA,GAAG0Y,EAAQyC,MAAMviB,KAEnB,IAAI8H,EAAQ,EACRya,EAAKkV,EACT,KAAOD,EAAK3uB,IAAI0Z,IACdA,EAAKkV,EAAS,OAAQ3vB,EAGxB,OADA0vB,EAAK9sB,IAAI6X,GACFA,CACT,CACA,SAASmV,GAAa5X,GACpBtT,GAAQsT,EAAQ6F,SAAUxY,IACxB,IAAK,MAAM6lB,KAAkB7lB,EAAQwnB,OAAOlnB,SAAU,CACpD,MAAMkqB,EAAY,CACC,IAAjBxqB,EAAQ3K,KAAuB2lB,GAAkBxlB,MAAME,cACrD0G,IAAoBquB,OAASvF,GAAiBllB,IAC5C+iB,GAAwB/iB,IAE9B,IAAI0qB,EAAiB/X,EACrB,KAAO+X,GAAkBA,IAAmB7E,EAAelT,SAAS,CAClE,MAAM+E,EAAgBgT,EAAelxB,OACjCke,GACF8S,EAAUlsB,KAAKqsB,GAAmCD,IAEpDA,EAAiBhT,CACnB,CACA,MAAMkT,EAAkBhF,GAA2BC,IACnD,EAAI5K,GAAqBhG,cAAc7gB,KAAKE,KAAKgK,KAC/C0c,GAAkBxlB,MAAMuoB,oBAAoB,QAAS,CACnD/C,GAAkBxlB,MAAMwoB,mBACtB4M,EACA/E,EAAe5lB,sBAAsBC,KAAOmR,GAC1C,WACA2J,GAAkBxlB,MAAME,cACtBu0B,GACEpE,EAAelT,QACfkT,EACA,UAGJxU,GAAY,WAAYmZ,IACtBnZ,GAAY,WAAYmZ,OAI9B3E,EAAe5lB,sBAAsBC,MACvC2jB,GACEgC,EAAelT,aACf,EACAwU,GAAUtB,GACV7K,GAAkBxlB,MAAM6L,eAAeupB,EAAiB,CAAC3D,KAG/D,KAEF,MAAMf,EAAU,IAAItB,GAAWjS,GAASrS,UAAUuqB,KAAKC,IACvD,IAAK,MAAM3E,KAAUD,EAAS,CAC5BxtB,EAAgBytB,EAAQ,SAAU4C,IAClC,IAAK,MAAMgC,KAAU5E,EAAO7lB,OAC1B5H,EAAgBqyB,EAAQ,QAAShC,IAEnC,IAAIiC,EACJ,GAAI7E,EAAOO,OAAOnyB,OAAQ,CACxBmE,EAAgBytB,EAAQ,SAAU8E,IAClC,MAAMzC,EAAmBxN,GAAkBxlB,MAAMI,WAAW,GAAGuwB,EAAOvwB,WAAWlC,eAC3E8gB,EAAqB2R,EAAOQ,yBAC5B5H,EAAkB5lB,EACtBgtB,EAAOO,OACPwE,IAEFF,EAAmBhQ,GAAkBxlB,MAAMwoB,mBACzCwK,EACAnX,GACE,SACA2J,GAAkBxlB,MAAME,cACtBu0B,GAAoBtX,EAASwT,EAAO3R,qBAEtCwG,GAAkBxlB,MAAMmoB,wBACtBnJ,EAAqBuK,EAAkB,CACrCkI,GACAwB,GAAuB9V,EAAS6B,IAC9B,CAACiU,GAAuB9V,EAAS6B,IAAuBuK,EAAkB,CAACkI,IAAmB,GAClG1C,GAAyB4B,EAAOO,UAIxC,CACA,IAAIj0B,EAAQ0zB,EAAOzlB,QACfsa,GAAkBxlB,MAAM21B,iBAAiB14B,IAC3C22B,GAAqC32B,EAAMi2B,WAEzCvC,EAAOiF,WACT34B,EAAQ4e,GACN,sBACA2J,GAAkBxlB,MAAME,cACtBu0B,GAAoBtX,EAASwT,EAAO3R,mBAAoB,QAE1D/hB,IAGJ,MAAM44B,EAAmBrQ,GAAkBxlB,MAAMwoB,mBAAmBmI,EAAOvwB,WAAYnD,GACvF,IAAI64B,EAAqB3Y,EAAQnZ,QAAW2sB,EAAO3R,qBAAuBwG,GAAkBxlB,MAAM+1B,qBAAqB94B,KAAUuoB,GAAkBxlB,MAAM6zB,0BAA0B52B,GAI/KuoB,GAAkBxlB,MAAMuoB,oBAAoB,QAAS,CAACsN,IAJmIrQ,GAAkBxlB,MAAMg2B,oBACnNrF,EAAOvwB,WACPnD,EAAM2lB,OACN4C,GAAkBxlB,MAAMi2B,aAAah5B,EAAM6B,MAAQ0mB,GAAkBxlB,MAAMooB,eAAe,CAAC5C,GAAkBxlB,MAAM4L,oBAAoB3O,EAAM6B,QAAU7B,EAAM6B,MAE3J6xB,EAAOE,SACTiF,EAAoBtQ,GAAkBxlB,MAAMk2B,uBAAuBJ,IAErE,MAAMK,EAAmBxF,EAAOoC,mBAAqB,GACjDyC,GACFW,EAAiBrtB,KAAK0c,GAAkBxlB,MAAMuoB,oBAAoB,QAAS,CAACiN,KAE9EW,EAAiBrtB,KAAKgtB,IACtB,EAAIrQ,GAAqBhG,cAAc7gB,KAAKE,KAAKgK,QAAQqtB,EAC3D,CACF,CAuDA,SAASC,GAAmBC,GAC1B,MAAMnS,EAAK0C,GAAiByP,GAC5B,MAAmB,wBAAZnS,EAAGrkB,KAAiC,CAACqkB,EAAIsB,GAAkBxlB,MAAMs2B,gBAAgBpS,EAAGtE,KAAO,CAAC4F,GAAkBxlB,MAAMs2B,gBAAgBpS,GAC7I,CACA,SAASoR,GAAYltB,EAAGC,GACtB,MAAMkuB,EAAsBC,GAAsBpuB,GAC5CquB,EAAsBD,GAAsBnuB,GAClD,IAAK,IAAI9E,EAAI8B,KAAKC,IAAIixB,EAAoBx3B,OAAQ03B,EAAoB13B,QAAU,EAAGwE,GAAK,EAAGA,IAAK,CAC9F,MAAMmzB,GAAQD,EAAoBlzB,KAAO,IAAMgzB,EAAoBhzB,KAAO,GAC1E,GAAa,IAATmzB,EAAY,OAAOA,CACzB,CACA,OAAO,CACT,CACA,SAASF,IAAwBxX,mBAAoB2X,IACnD,OAAKA,EAEMtzB,MAAMC,QAAQqzB,GAChBA,EAAQrrB,IAAIsrB,IAAavB,OAEzB,CAACuB,GAAYD,IAJb,EAMX,CACA,SAASC,GAAYC,GACnB,OAAkD,KAAvB,IAAnBA,EAAUh3B,KAAuB,EAAI,GAAWg3B,EAAUjX,EACpE,CACA,SAASkX,GAAkB3Z,EAAS6B,GAClCiV,GAAa,SAAU9W,EAAS6B,OAAoB,GAAQ,EAC9D,CACA,SAASuI,GAA0BxgB,GACjC,MAAMoW,EAAUuG,GAAkB3c,GAClC,IAAKoW,EAAS,OACd,MAAMre,EAAOiI,EAAMnI,KAAKE,KAClBi4B,EAAa1zB,MAAM/G,KAAK8yB,GAAWjS,GAASrS,UAC5CksB,EAAoBnT,GAAqB1G,GAC/CtT,GAAQsT,EAAQ0F,oBAAqBmC,IACnC,GAAIA,EAAQ8N,SACN/N,GAAiB5H,EAAS6H,GAAU,CACtC,MAAMiS,EAAgBzG,GAAUxL,EAAQ7H,QAAS6H,GACjD,IAAI5kB,EAAa6vB,GAAsCtzB,IAAIs6B,GACtD72B,IACH6vB,GAAsC7qB,IACpC6xB,EACA72B,EAAayF,EACXoxB,EAAc72B,WAAWlC,KAAO,cAGpCgyB,GAAyBlL,EAAQ7H,SAASrU,KACxC0c,GAAkBxlB,MAAMuoB,oBAAoB,QAAS,CACnD/C,GAAkBxlB,MAAMwoB,mBACtBpoB,EACAolB,GAAkBxlB,MAAMk3B,cAAc1R,GAAkBxlB,MAAMI,WAAW,OAAQ,QAIvFqvB,GACEzK,EAAQ7H,QACR6H,EACA5kB,EACAwG,IAAoBuwB,gBAGxB1H,GACEtS,EACA6H,EACAQ,GAAkBxlB,MAAMib,eA79ClC,SAAgC+J,EAAS6N,GACvC,IAAIP,EAAQ,EAQZ,OAPAtpB,GAAKgc,EAAQ4N,iBAAkBzV,GACzBA,IAAY0V,IACZ9N,GAAiB5H,EAAS6H,IAC5BsN,KAEK,KAEFA,CACT,CAm9CiD8E,CAAuBpS,EAAS7H,IACvEvW,IAAoBywB,oBAEtBtH,GACE5S,GACC3b,GAASqa,GAAY,iBAAkBzb,EAAYoB,IAExD,CACF,IAEF,MAAM81B,EAA4C,IAAI9d,IACtD3P,GAAQsT,EAAQ6F,SAAUxY,IACxB,IAAK,MAAM6lB,KAAkB7lB,EAAQwnB,OAAOlnB,SAAU,CAChDulB,EAAe5lB,sBAAsBC,MACvCwlB,GAAyBG,EAAelT,SAASrU,KAC/C0c,GAAkBxlB,MAAMuoB,oBAAoB,QAAS,CACnD/C,GAAkBxlB,MAAMwoB,mBACtBhD,GAAkBxlB,MAAMI,WAAWiwB,EAAenyB,MAClD2d,GACE,QACAgI,GAAqBwM,EAAelT,SACpCqI,GAAkBxlB,MAAME,cACtBu0B,GACEpE,EAAelT,QACfkT,EACA,eAQd,IAAI6E,EAAiB/X,EACrB,KAAO+X,GAAkBA,IAAmB7E,EAAelT,SAAS,CAClE,MAAM+E,EAAgBgT,EAAelxB,OACrC,IAAKkxB,EAAevS,kBAAoB2U,EAA0BpxB,IAAIgvB,GAAiB,CACrF,MAAMqC,EAAwB1xB,EAC5B,GAAGqvB,EAAeh3B,oBAEpBo5B,EAA0BvvB,IAAImtB,GAC9BhF,GAAyBhO,GAAepZ,KACtC0c,GAAkBxlB,MAAMuoB,oBAAoB,QAAS,CACnD/C,GAAkBxlB,MAAMwoB,mBACtB+O,EACA/R,GAAkBxlB,MAAMk3B,cAAc1R,GAAkBxlB,MAAMI,WAAW,OAAQ,QAIvF2vB,GACEmF,GACC1zB,GAASqa,GAAY,iBAAkB0b,EAAuB/1B,KAEjEouB,GACE1N,EACAsV,GAA4BtC,GAC5BqC,EAEJ,CACArC,EAAiBhT,CACnB,CACF,CACI1X,EAAQwnB,OAAOtnB,MAAyB,IAAjBF,EAAQ3K,MACjC4vB,GACEtS,EACA3S,EACAmkB,GAA6BnkB,GAEjC,IAEF,IAAK,IAAIjH,EAAIwzB,EAAWh4B,OAAQwE,KAC9B,GAAIwzB,EAAWxzB,GAAG2tB,OAAOnyB,OAAQ,CAC/B,MAAM04B,EAAaV,EAAWxzB,GAAGyb,mBACjClgB,EAAKgK,KACH0c,GAAkBxlB,MAAM4L,oBACtBiQ,GACE,cACAmb,EACAxR,GAAkBxlB,MAAME,cAAcu0B,GAAoBtX,EAASsa,MAI3E,CAEF,MAAMC,EAAmBxJ,GAAuB/Q,GAC1Cwa,EAAuB,GACvBC,IAAyBjI,GAAkCzpB,IAAIiX,IAAkBA,EAAQG,gBAc/F,GAbAzT,GAAQsT,EAAQ4F,UAAWvY,IACzB,GAAqB,IAAjBA,EAAQ3K,KAAsB,OAClC,MAAMod,EAASuB,GAA0BrB,EAAS3S,GAClD,IAAKyS,EAAQ,OACb,MAAMlO,EAAW2gB,GAAiBllB,GAClCktB,EAAiBna,OAAOxO,GACxB4oB,EAAqB7uB,KACnBoS,GACEnM,EACA6oB,IAA2BA,IAA2B3a,IAAqC,IAA3B2a,IAA8C,IAAX3a,GAA+E,IAA5D4a,GAAwBD,EAAwB3a,IAAiB0R,GAA6BnkB,GAAWwc,GAAoB/J,EAAQ0R,GAA6BnkB,KAE3R,IAEC2S,EAAQnZ,OAAQ,CAClB,MAAM8zB,EAAgBjxB,KAAkBkxB,MAClCC,EAAczZ,GAA0BpB,EAAS2a,GACvD,GAAIE,EAAa,CACf,MAAMC,EAAepc,GACnB,oBACAgI,GAAqB1G,EAAQnZ,SAE/B0zB,EAAiBna,OAAOua,GACxBH,EAAqB7uB,KACnBoS,GACE4c,EACAF,IAA2BA,IAA2BI,IAA0C,IAA3BJ,IAAmD,IAAhBI,GAAyF,IAAjEH,GAAwBD,EAAwBI,IAAsBC,EAAejR,GAAoBgR,EAAaC,IAG5P,CACF,CACA,IAAK,MAAOx7B,GAAK,WAAEsF,EAAU,OAAEkb,MAAaya,EAC1CC,EAAqB7uB,KACnBoS,GAAiBze,EAAKuqB,GAAoB/J,EAAQlb,KAGtD,MAAMm2B,EAAoBrI,GAA4B1S,GACtD,GAAIya,EAAwB,CAC1B,IAAK,MAAMv1B,KAAQs1B,EACK,eAAlBt1B,EAAK5F,IAAIoD,MAA6C,eAApBwC,EAAKpF,MAAM4C,MAAyBwC,EAAK5F,IAAIyB,OAASmE,EAAKpF,MAAMiB,OACrGmE,EAAK81B,WAAY,GAGrB,MAAMC,EAAiB,CACrBpB,EACAxR,GAAkBxlB,MAAMq4B,iBAAiBV,IAE3C,IAAKjxB,IAAc,CACjB,IAAI4xB,EACJzuB,GAAQsT,EAAQ4F,UAAWvY,IACzB,GAAqB,IAAjBA,EAAQ3K,KAAsB,OAElC,IADwB2e,GAA0BrB,EAAS3S,GACrC,OACtB,IAAI+tB,EAAO/tB,EACPguB,EAAS,GACb,MAASD,EAAK9V,MAAO8V,EAAK7P,UAAa6P,EAAK3J,oBACpB,IAAlB2J,EAAK1J,WACP2J,EAAS1pB,GAASypB,EAAK1J,UAAY2J,GAErCD,EAAOA,EAAK3J,cAEd,MAAM6J,EAAUF,EAAK9V,KAAO+C,GAAkBxlB,MAAME,cAClD,GAAGq4B,EAAK9V,IAAIzT,MAAM0pB,QAAQH,EAAK9V,IAAIzT,MAAM2pB,OAAS,MAEnDL,IAAc,IAAIxvB,KACjBoS,GACEwU,GAAiBllB,GACjB+tB,IAAS/tB,EAAUgb,GAAkBxlB,MAAM44B,gBACzCH,EAAU,CAACjT,GAAkBxlB,MAAME,cAAcq4B,EAAKr6B,KAAOs6B,GAASC,GAAW,CAACjT,GAAkBxlB,MAAME,cAAcq4B,EAAKr6B,KAAOs6B,KAClIC,GAAWjT,GAAkBxlB,MAAMib,eAAe,IAEzD,IAEHmd,EAAetvB,KACb0c,GAAkBxlB,MAAME,cAAc6G,EAAMwb,IAAIle,KAAKK,KAAKm0B,kBAC1D1b,EAAQsF,KAAiC,MAA1BtF,EAAQsF,IAAIzT,MAAM0pB,KAAelT,GAAkBxlB,MAAME,cACtE,GAAGid,EAAQsF,IAAIzT,MAAM0pB,QAAQvb,EAAQsF,IAAIzT,MAAM2pB,OAAS,KACtDnT,GAAkBxlB,MAAMib,eAAe,IAEzCqd,GACFF,EAAetvB,KAAK0c,GAAkBxlB,MAAMq4B,iBAAiBC,GAEjE,CACA,IAAIQ,EAAiBZ,EAAoBA,EAAkBrc,GAAY,gBAAiBuc,IAAmBvc,GAAY,gBAAiBuc,IACzG,IAA3BR,IACFkB,EAAiBtT,GAAkBxlB,MAAMinB,kBACvC,KACAG,GAAkBwQ,GAClBkB,IAGJh6B,EAAKgK,KAAK0c,GAAkBxlB,MAAM4L,oBAAoBktB,GACxD,EAC8B3b,EAAQoG,WAAapG,EAAQmG,gBAAoBnG,EAAQ0F,oBAAwB7Z,GAAKmU,EAAQ4F,UAAWvY,GAA6B,IAAjBA,EAAQ3K,SAEzJf,EAAKgK,KACH0c,GAAkBxlB,MAAM4L,oBACtBiQ,GAAY,sBAAuBmb,KAIzC,MAAM+B,EAAuB7I,GAAyB/S,IAClDre,EAAKC,QAAUg6B,EAAqBh6B,SACtCD,EAAK4M,QACH8Z,GAAkBxlB,MAAMuoB,oBAAoB,QAAS,CACnD/C,GAAkBxlB,MAAMwoB,mBAAmBwO,EAAmBnb,GAAY,qBAEzEkd,GAGP,MAAMC,EAAmBvL,GAAgCtQ,QAChC,IAArB6b,GACFl6B,EAAKgK,KAAK0c,GAAkBxlB,MAAMs2B,gBAAgB0C,GAEtD,CACA,SAAS5L,GAASjQ,GAChB,OAAOiS,GAAWjS,GAASxgB,SAAI,IAASyD,UAC1C,CACA,SAASmzB,GAAkB30B,GACzB,OAAOq6B,GAAoBr6B,IAASs6B,GAAwBt6B,IAASu6B,GAA+Bv6B,EACtG,CACA,SAAS62B,GAAkB72B,GACzB,OAAOq6B,GAAoBr6B,IAASs6B,GAAwBt6B,EAC9D,CACA,SAASs6B,GAAwBt6B,GAC/B,OAAQA,EAAKiB,MACX,IAAK,aACL,IAAK,mBACH,OAAO8oB,GAAmB/pB,GAGhC,CACA,SAASq6B,GAAoBr6B,GAC3B,OAAQA,EAAKiB,MACX,IAAK,mBAAoB,CACvB,MAAM,MAAEqB,GAAUtC,EAAKgD,SACvB,GAAIw3B,GAAuBl4B,GAAQ,CACjC,MAAM,gBAAEm4B,GAAoB7I,GAC1BtvB,EAAMo4B,WAAWnc,QACjBjc,EAAMo4B,YAER,GAAID,EAAiB,CACnB,MAAM31B,EAAc21B,EAClBn4B,EAAMic,QACNqI,GAAkBxlB,MAAMu5B,iBACJ,OAAlB36B,EAAK6C,SAAoB,IAAM,IAC/B7C,EAAKgD,SACL4jB,GAAkBxlB,MAAMib,eAAe,KAG3C,OAAKrc,EAAK46B,OAGH91B,EAFE8hB,GAAkBxlB,MAAM6sB,mBAAmB,CAACnpB,EAAa9E,EAAKgD,UAGzE,CACF,CACA,KACF,CACA,IAAK,uBACH,OAAQhD,EAAK+C,KAAK9B,MAChB,IAAK,aAAc,CACjB,MAAM,MAAEqB,GAAUtC,EAAK+C,KACvB,GAAIy3B,GAAuBl4B,GAAQ,CACjC,MAAM,gBAAEm4B,GAAoB7I,GAC1BtvB,EAAMo4B,WAAWnc,QACjBjc,EAAMo4B,YAER,GAAID,EACF,OAAOA,EACLn4B,EAAMic,QACY,MAAlBve,EAAK6C,SAAmB7C,EAAK8C,MAAQ8jB,GAAkBxlB,MAAMu5B,iBAC3D36B,EAAK6C,SAASsM,MACZ,GACC,GAEHnP,EAAK+C,KACL/C,EAAK8C,OAIb,CACA,KACF,CACA,IAAK,eACL,IAAK,gBAAiB,CACpB,IAAIkhB,EACA6W,EAiBJ,GAhBAt3B,EAAkBvD,EAAK+C,MAAOie,IAC5B,MAAM,MAAE1e,GAAU0e,EAClB,GAAIwZ,GAAuBl4B,GAAQ,CACjC,MAAMyvB,EAASH,GACbtvB,EAAMo4B,WAAWnc,QACjBjc,EAAMo4B,YAEJ3I,GAAQ0I,kBACVzZ,EAAG1hB,KAAOkG,EAAYwb,EAAG1hB,OACxB0kB,IAAW,IAAI9Z,KAAK0c,GAAkBxlB,MAAMI,WAAWwf,EAAG1hB,QAC1Du7B,IAAgB,IAAI3wB,KACnB6nB,EAAO0I,gBAAgBn4B,EAAMic,QAASqI,GAAkBxlB,MAAMI,WAAWwf,EAAG1hB,QAGlF,KAEE0kB,GAAU6W,EAAa,CACzB,MAAMC,EAAWt1B,EAAY,UAC7B,OAAOohB,GAAkBxlB,MAAM6L,eAC7B2Z,GAAkBxlB,MAAMmoB,wBACtB,CAAC3C,GAAkBxlB,MAAMI,WAAWs5B,MAAc9W,GAClD4C,GAAkBxlB,MAAM6sB,mBAAmB,CACzCrH,GAAkBxlB,MAAM25B,qBACtB,IACA/6B,EAAK+C,KACL6jB,GAAkBxlB,MAAMI,WAAWs5B,OAElCD,EACHjU,GAAkBxlB,MAAMI,WAAWs5B,MAGvC,CAAC96B,EAAK8C,OAEV,CACA,KACF,GAIR,CACA,IAAIk4B,GAA0C,IAAIz1B,QAClD,SAASg1B,GAA+Bv6B,GACtC,OAAQA,EAAKiB,MACX,IAAK,cAAe,CAClB,MAAM6D,EAAcm2B,GAA2Bj7B,GAC/C,OAAO8E,GAAe8hB,GAAkBxlB,MAAM8oB,cAAclqB,EAAKnC,IAAKiH,EACxE,CACA,IAAK,qBAAsB,CACzB,MAAMA,EAAcm2B,GAA2Bj7B,GAC/C,OAAO8E,GAAe8hB,GAAkBxlB,MAAM+oB,qBAAqBnqB,EAAKnC,IAAKiH,EAC/E,CACA,IAAK,eAAgB,CACnB,MAAMA,EAAcm2B,GAA2Bj7B,GAC/C,OAAO8E,GAAe8hB,GAAkBxlB,MAAMmb,eAAevc,EAAKnC,IAAKiH,EACzE,CACA,IAAK,0BACL,IAAK,qBACH,OAAOm2B,GAA2Bj7B,GAEpC,IAAK,sBAAuB,CAC1B,MAAM8E,EAAcm2B,GAA2Bj7B,GAC/C,GAAI8E,EACF,OAAO8hB,GAAkBxlB,MAAMuoB,oBAAoB,QAAS,CAC1D/C,GAAkBxlB,MAAMwoB,mBAAmB5pB,EAAKghB,GAAIlc,KAGxD,KACF,EAEJ,CACA,SAASm2B,GAA2Bj7B,GAClC,MAAM,MAAEsC,GAAUtC,EAClB,GAAIoqB,GAAoB9nB,GAAQ,CAC9B,MAAM0e,EAAK1e,EAAMhD,KACXqrB,EAAkBroB,EAAMqoB,gBACxBvK,EAAqB9d,EAAMooB,6BACjC,IAAIwQ,EAAcF,GAAwBj9B,KAAI,EAAI8oB,GAAqBhG,cAAc7gB,MAYrF,OAXKk7B,GACHF,GAAwBx0B,KAAI,EAAIqgB,GAAqBhG,cAAc7gB,KAAMk7B,EAAc,IAEzFA,EAAYhxB,KAAK,CACf8W,KACAhhB,OACAuqB,WAAYjoB,EAAMioB,WAClBhM,QAASjc,EAAMic,QACfoM,kBACAvK,uBAEEuK,GAAmBvK,EACdwG,GAAkBxlB,MAAM6L,eAAe2Z,GAAkBxlB,MAAMI,WAAWwf,GAAK,CAAC6R,KAEhFjM,GAAkBxlB,MAAMI,WAAWwf,EAE9C,CACF,CAGA,IAkHI6R,GAlHAsI,GAAc,CAChBj8B,UAAW,CACTsoB,IAAAA,CAAKvhB,GACHiH,GAAMjH,GACN,MAAMsY,EAAUuG,GAAkB7e,IAC5B,MAAEomB,EAAK,OAAEuB,EAAM,MAAEW,GAAUH,GAAe7P,GAC1C2T,EAAajsB,EAAQjG,KAAKsC,MAAM4vB,WAChCkJ,EAAqB5U,GAAkBplB,MAAMI,WAAW0wB,EAAWmJ,UACnEC,EAAkB9U,GAAkBplB,MAAMI,WAAW0wB,EAAW7F,OAChEkP,EAAkB/U,GAAkBplB,MAAMI,WAAW0wB,EAAW3D,OAChEiN,EAAev1B,EAAQjG,KAAKgkB,OAAO,GAAG1hB,OAAOsJ,QAC7C6vB,EAAqBD,GAAgB7vB,GAAgC6vB,GAAgBzI,GAAUyI,QAAgB,EAC/GE,EA3xDZ,SAAsBj2B,GACpB,MAAM,SAAEI,GAAaJ,EAAKK,KACpB61B,EAAKl2B,EAAKG,UAAUg2B,WACpBC,EAUR,SAAiBh2B,GACf,MAAMuK,EAAQvK,EAAS6mB,YAAYhG,GAAYY,QAAQvY,KAAO,EACxD+sB,EAAUj2B,EAASk2B,QAAQ,IAAK3rB,GACtC,IAAiB,IAAb0rB,EACF,OAAOj2B,EAASsJ,MAAMiB,GAExB,MAAM4rB,EAAWn2B,EAAS6mB,YAAY,KAChCuP,EAAeH,EAAU,EAC/B,GAA+B,MAA3Bj2B,EAASo2B,GAAuB,CAClC,MAAMC,EAAcr2B,EAAS6mB,YAAY,IAAKuP,GAC9C,GAAIC,EAAc9rB,EAChB,OAAOvK,EAASsJ,MAAMiB,EAAO8rB,GAAer2B,EAASsJ,MAAM2sB,EAASE,EAExE,CACA,OAAOn2B,EAASsJ,MAAMiB,EAAO4rB,EAC/B,CAzBeG,CAAQt2B,GACfu2B,EAAa,IAAIvrB,OACrB,KAyBkB/B,EAzBA+sB,EA0Bb/sB,EAAI/H,QAAQ4f,GAAgB,aA1BJ,UAAYkV,EAAO,IAAM,oBAyB1D,IAAsB/sB,EAvBpB,IAAK,MAAMutB,KAASV,EAAGW,YAAY5V,GAAYY,QAAQiV,QAAQ12B,IAAW4wB,OACxE,GAAI2F,EAAW5tB,KAAK6tB,GAClB,MAAO,KAAKA,GAGlB,CA+wDwBG,CAAav2B,EAAQ0d,IAAIle,MACvCi2B,IACF,EAAIjV,GAAqBgW,eAAex2B,EAAQ0d,IAAIle,KAAMi2B,GAx8DlE,SAA+BpW,GAC7B,MAAM,SAAE1B,IAAa,EAAI/F,GAAqBgD,cAAc7gB,KAAKsC,MACjE,IAAK,IAAIqC,EAAIif,EAASzjB,OAAQwE,KAC5B2gB,EAAG1B,EAASjf,GAEhB,CAq8DM+3B,EAAuBC,IACrB,GAAIA,IAAiBpe,EAAS,CAC5B,MAAMqe,EAAkBD,EAAa3Y,QAAU+O,GAAU4J,EAAa3Y,SAC9DqI,MAAOwQ,EAAQjP,OAAQkP,EAASvO,MAAOwO,GAAW3O,GAAeuO,GACnEn7B,EAAaglB,GAAkBplB,MAAMI,WAAWm7B,EAAar9B,MAC7D2kB,EAAqB0Y,EAAa1Y,mBAAqBuC,GAAkBplB,MAAMmoB,wBACnF,CAACsJ,IACD1C,IAnuGW3sB,EAouGiC4iB,IACxC,MAAMiS,EAAgBzG,GAAU+K,EAAcvW,GAC9C,OAAOI,GAAkBplB,MAAM4L,oBAC7BwZ,GAAkBplB,MAAM6L,eACtBkZ,GAAiBwW,EAAcvW,GAAWiS,EAAc72B,WAAaglB,GAAkBplB,MAAMwb,iBAC3Fyb,EAAc72B,WACdglB,GAAkBplB,MAAMI,WAAWyG,KAAkBkxB,QAEvD,CAACtG,KAEJ,GA9uGAzpB,EAouGKuzB,EAAa1Y,oBAnuGnBxf,MAAMC,QAAQ0E,GAAQA,EAAKsD,IAAIlJ,GAAM,CAACA,EAAG4F,IAAY,WAgvGvD,EACE4zB,EAAW9X,GAAwByX,GAAgB1f,GACvD,oBACG+X,GAAqC,CACtC8H,EACAD,EACAE,EACAH,GAAiBp7B,WACjByiB,KAEAhH,GACFgJ,GAAoB0W,GAAgB,kBAAoB,gBACxDnW,GAAkBplB,MAAME,cAAcu0B,GAAoB8G,EAAc,gBACrE3H,GAAqC,CACtC8H,EACAD,EACAE,EACAH,GAAiBp7B,WACjByiB,EACA0Y,EAAavY,SAAWuY,EAAatY,eAAiBkS,GAAmCoG,QAAgB,KAG7GxG,GAAawG,GACb12B,EAAQjG,KAAKE,KAAKgK,KAChBsc,GAAkBplB,MAAMuoB,oBAAoB,QAAS,CACnDnD,GAAkBplB,MAAMwoB,mBAAmBpoB,EAAYw7B,KAG7D,CA7wGR,IAAiB5zB,EAAM5F,CA6wGf,IAEF2yB,GAAa5X,GA3iBnB,WACE,MAAM0e,EAAgBjC,GAAwBj9B,KAAI,EAAI8oB,GAAqBhG,cAAc7gB,MACnFy1B,EAAa,GACnB,GAAIwH,EAAe,CACjB,IAAK,MAAMC,KAAgBD,EAAe,CACxC,IAAI3X,EACJ,MAAMtB,EAASkZ,EAAa9c,mBAAqB8c,EAAavS,gBAAkB,CAC9EkI,GACAjM,GAAkBxlB,MAAM+7B,kBACtB9I,GACE6I,EAAa3e,QACb2e,EAAa9c,oBAEfyS,KAEA,CACFwB,GACE6I,EAAa3e,QACb2e,EAAa9c,qBAEb8c,EAAavS,gBAAkB,CAACkI,SAAmB,EAErDvN,EADEtB,EACG4C,GAAkBxlB,MAAMg2B,oBAC3BxQ,GAAkBxlB,MAAMI,WAAW07B,EAAalc,IAChDgD,EACA4C,GAAkBxlB,MAAMooB,eAAegO,GAAmB0F,EAAal9B,QAErC,wBAA3Bk9B,EAAal9B,KAAKiB,MAAkCi8B,EAAal9B,KAAKghB,IAAI1hB,OAAS49B,EAAalc,GACpGkc,EAAal9B,KAEb4mB,GAAkBxlB,MAAMg2B,oBAC3BxQ,GAAkBxlB,MAAMI,WAAW07B,EAAalc,IAChDkc,EAAal9B,KAAKgkB,OACc,mBAAhCkZ,EAAal9B,KAAKE,KAAKe,KAA4Bi8B,EAAal9B,KAAKE,KAAO0mB,GAAkBxlB,MAAMooB,eAAe,CAAC5C,GAAkBxlB,MAAMs2B,gBAAgBwF,EAAal9B,KAAKE,QAC9Kg9B,EAAal9B,KAAKkoB,UAClBgV,EAAal9B,KAAKiQ,OAGtBwlB,EAAWvrB,KAAKob,EAClB,CACA,IAAK,MAAM4X,KAAgBD,EACzBxH,EAAWvrB,KACT0c,GAAkBxlB,MAAM4L,oBACtBiQ,GACE,WACA2J,GAAkBxlB,MAAME,cAAc47B,EAAa3S,YACnD3D,GAAkBxlB,MAAMI,WAAW07B,EAAalc,QAKxD,EAAI6F,GAAqBhG,cAAc7gB,KAAKE,KAAKgK,QAAQurB,EAC3D,CACF,CAufM2H,GACK7O,GACHtoB,EAAQjG,KAAKE,KAAK4M,QAChB0Z,GAAkBplB,MAAMk2B,uBACtB9Q,GAAkBplB,MAAMuoB,oBAAoB,QAAS,CACnDnD,GAAkBplB,MAAMwoB,mBACtB2R,EACA/U,GAAkBplB,MAAMmoB,wBAAwB,GAAI/C,GAAkBplB,MAAMooB,eAAe,UAMrGvjB,EAAQjG,KAAKE,KAAK4M,QAChB0Z,GAAkBplB,MAAMk2B,uBACtB9Q,GAAkBplB,MAAMuoB,oBAAoB,QAAS,CACnDnD,GAAkBplB,MAAMwoB,mBACtBwR,EACAxN,GAAUpH,GAAkBplB,MAAME,cAAc,QAItDklB,GAAkBplB,MAAMk2B,uBACtB9Q,GAAkBplB,MAAMuoB,oBAAoB,QAAS,CACnDnD,GAAkBplB,MAAMwoB,mBAAmB0R,EAAiBjP,GAAS7F,GAAkBplB,MAAME,cAAc,SAIjH2E,EAAQjG,KAAKE,KAAKgK,KAChBsc,GAAkBplB,MAAMsoB,yBACtBzM,GACE,iBACAuJ,GAAkBplB,MAAME,cAAc2E,EAAQ0d,IAAIle,KAAK4H,SAASC,MAAM0T,IACtEoa,EACAE,EACAC,EACAE,GAAoBj6B,aAI5B,IAOJ,SAASs1B,GAAkB92B,GACzB,OAAOA,IAAS6yB,EAClB,CACA,IAAIwK,GAAkB,CACpB98B,QAAS,CACP2mB,KAAAA,CAAMjhB,GACJA,EAAQjG,KAAKgkB,OAAS,CAACxY,GAAkBpK,MAAMI,WAAW,SAC5D,EACAgmB,IAAAA,CAAKvhB,GACHA,EAAQU,MAAM22B,OAChB,GAEF5+B,QAAS,CACPwoB,KAAAA,CAAMjhB,GACJod,GAAapd,GACbs3B,GAAsBt3B,EAAS,GAC/B,MAAMyd,EAAezd,EAAQjG,KAAKsC,QAAU,CAAC,EACvCk5B,EAAev1B,EAAQjG,KAAKgkB,OAAO,GAAG1hB,OAAOsJ,QAC/C4vB,IACFA,EAAa94B,UAAW,GAE1BghB,EAAawO,WAAa,CACxBmJ,SAAU71B,EAAY,YACtB6mB,MAAO7mB,EAAY,SACnB+oB,MAAO/oB,EAAY,SACnBg4B,WAAO,GAGT,IAAK,MAAM1U,KAAS7iB,EAAQlI,IAAI,QAC9B,GAAImQ,GAAc4a,EAAO,UAAW,CAClC,MAAM,MAAEzqB,GAAUqP,GAAmBob,EAAM9oB,MACvC3B,IACFqlB,EAAa+Z,gBAAkBp/B,EAAMiE,QAAU,CAAC,GAElD,KACF,CAEJ,EACAklB,IAAAA,CAAKvhB,IAyfT,WACE,MAAMke,EAAWuZ,KACXC,EAAoBC,KACpBC,EAAYC,KACZC,EAAmBC,KACzB,GAAID,EAAiBjyB,KACnB,IAAK,MAAO3N,EAAQ8/B,KAAUF,EAAkB,CAC9C,MAAMG,EAAc//B,EAAOmE,MAC3B,IAAI67B,EAAQR,EAAkB5/B,IAAImgC,IAC9B,SAAEE,GAAaF,EACnB,IAAK,MAAMl+B,KAAQi+B,EAAO,CACxB,MAAM37B,EAAQtC,GAAMsC,MACpB,GAAI4d,GAAkB5d,GAAQ,CAC5B87B,IAAa97B,EAAM87B,SACnB,MAAMC,EAAkBV,EAAkB5/B,IAAIuE,GAC1C+7B,IACFF,EAAQrzB,GAAOqzB,EAAOE,GACtBV,EAAkBhf,OAAOrc,GAE7B,CACF,CACAq7B,EAAkBn3B,IAAI03B,EAAaC,GACnCD,EAAYE,SAAWA,CACzB,CAEF,MAAME,EAAyC,IAAIt4B,IACnD,IAAK,MAAOpD,EAAMu7B,KAAUR,EACtBzd,GAAkBtd,KACpBA,EAAKwd,mBAAqBme,GACxB37B,EACAu7B,EACAG,GAEFrzB,GAAQrI,EAAKwd,oBAAqBxU,IAChCA,EAAQC,sBAAsB1C,IAAIvG,EAAK,KAI7C,IAAK,MAAO0iB,EAAI6Y,KAAUN,EACxBvY,EAAGoF,6BAA+B6T,GAChCjZ,EACA6Y,EACAG,GAEFrzB,GACEqa,EAAGoF,8BACF9e,GAAYiT,GAAsBjT,EAAQ2S,QAAS3S,KAGxD,IAAK,MAAMA,KAAWuY,EACC,IAAjBvY,EAAQ3K,MAAyB2K,EAAQokB,eAC3CwO,GAAara,EAAUvY,GAG3B,IAAK,MAAMA,KAAWuY,EAAU,CAC9B,MAAQ7kB,KAAMb,EAAK,QAAE8f,GAAY3S,EACZ,IAAjBA,EAAQ3K,OACVw9B,GAAsB7yB,GAClBA,EAAQwnB,OAAOtnB,MACjB+S,GAAsBjT,EAAQ2S,QAAS3S,GAEzCX,GACEW,EAAQ8yB,oBACPC,GAAoBzgB,GAAqBygB,EAAiBpgB,EAAStW,KAAkBkxB,SAEpF/uB,GAAKmU,EAAQ4F,UAAU,EAAG7kB,KAAMgH,KAAYA,IAAUsF,EAAQtM,SAChEsM,EAAQtM,KAAOkG,EAAY/G,KAG/B8f,EAAQ4F,SAAW5D,GAAYpX,IAAIoV,EAAQ4F,SAAUvY,GACrD,IAAK,MAAM,mBACTwU,EAAkB,SAClBge,EACA7f,QAASqgB,KACNhzB,EAAQC,sBACP+yB,IAAahzB,EAAQ2S,UACvB3S,EAAQooB,gBAAkB5Q,GAAYja,IACpCyC,EAAQooB,gBACR4K,GAEFA,EAAS3a,mBAAqB1D,GAAYpX,IACxCy1B,EAAS3a,mBACTrY,GAEFwS,GACEwgB,EACAhzB,EAAQ2S,QACR3S,EAAQ8U,iBACRzY,KAAkBkxB,QAGlBiF,GACFnzB,GACEmV,GACCye,GAAahgB,GAAsBggB,EAAStgB,QAASsgB,IAI9D,CAmGA,IAAItW,EAlGJlD,IAAgB9G,IACVA,EAAQ8F,gBACVlG,GAAsBI,GAExBtT,GAAQsT,EAAQ2F,kBAAmBuN,IACjCvT,GACEK,EACAkT,EAAelT,QACftW,KAAkBkxB,MACnB,IAEC5a,EAAQnZ,QAAUmZ,EAAQoG,UAAYpG,EAAQwF,iBAAmBxF,EAAQiG,qBA9mGjF,SAAsCjG,EAASiC,EAAK/c,GAClD,GAAI+c,EACF,GAAI/c,GA0BR,SAAoC8a,EAAS1gB,EAAK2iB,GAChD,MAAMhB,EAAiBjB,EAAQS,iBAAiBjhB,IAAIF,GACpD,IAAuB,IAAnB2hB,EACF,IAAY,IAARgB,EACFhC,GAAkBD,EAAS1gB,OACtB,CACL,MAAMwgB,EAAS8B,GAA0BK,IAC1B,IAAXnC,EACFG,GAAkBD,EAAS1gB,GAE3BohB,GACEV,EACA1gB,EACA4hB,GAAsBD,EAAgBnB,GAG5C,CAEJ,CA3CMygB,CACEvgB,EACAE,GAAiCF,EAAS9a,GAC1C+c,OAEG,CACL,MAAMhB,EAAiBjB,EAAQG,gBAC/B,IAAuB,IAAnBc,EACF,IAAY,IAARgB,EACFrC,GAAsBI,OACjB,CACL,MAAMF,EAAS8B,GAA0BK,IAC1B,IAAXnC,EACFF,GAAsBI,GAEtBK,GACEL,EACAkB,GAAsBD,EAAgBnB,GAG5C,CAEJ,CAEJ,CAolGM0gB,CACExgB,KACGA,EAAQ8F,iBAAkB9F,EAAQ6F,UAvkF7C,SAA2B7F,GACzB,GAAIA,EAAQoG,SACV,OAAO5Z,GACLwT,EAAQ0F,oBACPmC,GAAYF,GAAiB3H,EAAS6H,IAG7C,CAgkFyD4Y,CAAkBzgB,GACnE0gB,IA5pGR,SAAuC1gB,EAAS3b,EAAMa,GACpD,GAAIb,EACF,GAAIa,EACF2b,GACEb,EACAE,GAAiCF,EAAS9a,GAC1Cb,QAEG,IAAgC,IAA5B2b,EAAQG,gBACjB,IAAa,IAAT9b,EACFub,GAAsBI,OACjB,CACL,MAAMc,EAAevB,GAAY/f,IAAIwgB,GACrCT,GAAYtX,IACV+X,EACAc,EAAevU,GAAOuU,EAAczc,GAAQA,EAEhD,CAGN,CA0oGMs8B,CACE3gB,EACAA,EAAQiG,mBACRya,IAEF9f,GACEZ,EAAQnZ,OACRmZ,EAAQwF,gBAAgBnY,QACxB2S,EAAQiG,oBAEZ,IAEFa,GAAexF,IACfwF,IAAgB9G,IACd,MAAM4gB,EAAgBb,EAAuBvgC,IAAIwgB,GACjD,GAAI4gB,EACF,IAAK,MAAMhN,KAAgBgN,EAAe,CACxC,MAAMC,EAAgBjN,EAAahyB,OACnC,IAAK,IAAIwE,EAAI,EAAGA,EAAIy6B,EAAgB,EAAGz6B,IACrC,IAAK,IAAI0mB,EAAI1mB,EAAI,EAAG0mB,EAAI+T,EAAe/T,IAAK,CAC1C,MAAMgU,EAAWlN,EAAaxtB,GACxBk6B,EAAW1M,EAAa9G,GACzBnM,GAAyBX,EAAS8gB,IAAc9e,GAAY/V,WAAW60B,EAASnL,QAAS2K,EAAS3K,UACrGxU,GACEnB,EACA8gB,EACAR,EAASne,kBAGRxB,GAAyBX,EAASsgB,IAActe,GAAY/V,WAAWq0B,EAAS3K,QAASmL,EAASnL,UACrGxU,GACEnB,EACAsgB,EACAQ,EAAS3e,iBAGf,CAEJ,CAEFzV,GAAQsT,EAAQ0F,oBAAqBmC,IACnC,IAAKlH,GAAyBkH,EAAQ7H,QAAS6H,GAAU,CACvD,MAAMkZ,EAAgBlZ,EAAQ7H,QAC9B,IAAIG,EACA4X,EAAiB/X,EACrB,KAAO+X,IAAmBgJ,GAAe,CACvC,MAAMC,GAAkBjJ,EAAe9R,oBAAsBvE,GAA2BqW,EAAe9R,oBACvG,IAAuB,IAAnB+a,EAAyB,CAC3B7gB,GAAkB,EAClB,KACF,CACAA,EAAkBe,GAChBf,EACA6gB,GAEFjJ,EAAiBA,EAAelxB,MAClC,CACAsa,GAA0B0G,EAAQ7H,QAAS6H,EAAS1H,EACtD,CACI0H,EAAQ8N,SACV5V,GACE8H,EAAQ7H,QACRqB,GAA0BwG,EAAQ7H,QAAS6H,IAG3CA,EAAQ1F,kBAAoByF,GAAiB5H,EAAS6H,KACxD1G,GACE0G,EAAQ7H,QACR6H,EACAA,EAAQ1F,iBACR1Y,IAAoBuwB,eAEtB7Y,GACEnB,EACA6H,EACAA,EAAQ1F,iBACR1Y,IAAoBywB,oBAExB,GACA,IAGJpT,IAAgB9G,KA7iGlB,SAAyCA,GACvC,IAAIF,EAASE,EAAQG,gBACrB,IAAe,IAAXL,EAAiB,CACnB,IAAK,MAAO,CAAEmhB,KAAgBjhB,EAAQS,iBAAkB,CACtD,IAAoB,IAAhBwgB,EAAsB,CACxBnhB,GAAS,EACT,KACF,CACAA,EAASoB,GAAsBpB,EAAQmhB,EACzC,CACA5gB,GAA0BL,EAASF,EACrC,CACF,CAkiGIohB,CAAgClhB,GAC5BA,EAAQG,kBAA+C,IAA5BH,EAAQG,kBACrC6J,EAAwBA,EAAwBlf,GAC9C4vB,GACA1Q,EACAhK,EAAQG,iBACN,CAACH,EAAQG,kBAEf,IAAK,MAAO,CAAEL,KAAWE,EAAQS,kBAChB,IAAXX,IACFkK,EAAwBA,EAAwBlf,GAAU4vB,GAAyB1Q,EAAuBlK,GAAU,CAACA,GAEzH,IAEF,MAAMqF,GAAe,EAAIpgB,EAAqBud,cAAc7gB,KAAKsC,MACjEohB,EAAagc,sBAAwBhc,EAAa+Z,iBAAmBxd,GAA2ByD,EAAa+Z,iBAC7G/Z,EAAa6E,sBAAwBA,EACrClD,IAAgB9G,IACd,IAAIohB,EAAoB,EACxB,MAAMR,EAAgBb,EAAuBvgC,IAAIwgB,IAAY,IACvD,GAAEyC,EAAImD,SAAUyb,GAAcrhB,EAC9BshB,EAAiBA,EAAGthB,QAASqgB,KAAeA,EAAS5d,KAAOA,EAClE,IACImR,EADA2N,EAAmB,EAWvB,IATA70B,GAAQF,GAAO60B,EAAWC,IAAiB,CAACj0B,EAASm0B,KAEnD,IADAn0B,EAAQoV,IAAM8e,EAAmBC,GAAgBJ,EAC1CA,EAAoBR,EAAch/B,SAAWgyB,EAAegN,EAAcQ,IAAoB50B,OAAO80B,GAAgBG,IAAI,KAAOp0B,GACrI+mB,GAAiBnsB,IAAI2rB,EAAc,CACjCnR,GAAI+e,KAAiBJ,EACrBjN,YAAauN,GAAsB9N,EAAc5T,IAErD,IAEKohB,EAAoBR,EAAch/B,QACvCgyB,EAAegN,EAAcQ,GAC7BhN,GAAiBnsB,IAAI2rB,EAAc,CACjCnR,GAAI8e,KAAqBH,EACzBjN,YAAauN,GAAsB9N,EAAc5T,IAErD,IAEFwf,EAAiBtrB,QACjBkrB,EAAkBlrB,QAClBorB,EAAUprB,OACZ,CA3uBMytB,GACA,MAAMxc,EAAezd,EAAQjG,KAAKsC,MAC5Bk5B,EAAev1B,EAAQjG,KAAKgkB,OAAO,GAAG1hB,OAAOsJ,QAC/C4vB,GAAgB7vB,GAAgC6vB,KAClD9X,EAAawO,WAAWsL,MAAQ2C,GAC9B3E,EACAv1B,GAGN,GAEF/G,UAAW,CACTgoB,KAAAA,CAAMjhB,GAGJ,GAFA4sB,GAAkBhrB,IAAgBZ,EAAsB,SAAW,KACjDY,KAAgBZ,EAAsB,SAC1B,YAA1BU,IAAeC,OAAsB,CACvC,MAAM2E,EAAYtG,EAAQ0d,IAAIle,KACxB26B,EAA+B,IAAIxlB,IAAI,EAC3C,EAAInP,GAAqB8B,qBAAqBhB,EAAWA,EAAUzG,KAAKD,YAiB1E,OAfAhH,GAAsBqO,MAAMX,EAAWA,GAAW,SAASY,EAAWkzB,GACpE,IAAKD,EAAa94B,IAAI+4B,GAAW,CAC/BD,EAAaj3B,IAAIk3B,GACjB,MAAM56B,GAAO,EAAIgG,GAAqB60B,mBAAmB/zB,EAAW8zB,GAChE56B,GACF5G,GAAsBqO,MACpBzH,EACA8G,GACCyU,GAAO7T,EA2CxB,SAAgCZ,EAAW9G,EAAM86B,GAC/C,OAAO96B,IAAS8G,GAAY,EAAId,GAAqB8B,qBAAqB9H,EAAM86B,IAAO,EAAI90B,GAAqB8B,qBAC9GhB,EACW,MAAXg0B,EAAI,GAAa70B,GAAa4b,QAAQiG,KAAK9nB,EAAKK,KAAKD,SAAU,KAAM06B,GAAOA,EAEhF,CAhDmCC,CAAuBj0B,EAAW9G,EAAMub,KAGjE,CACF,IACA/a,EAAQjG,KAAKE,KAAOrB,GAAsByN,MAAMC,QAChDtG,EAAQ7B,MAEV,CACF,EACAojB,IAAAA,CAAKvhB,GAMH,GALIyB,IACF+gB,GAAavpB,UAAUsoB,KAAKvhB,GAE5Bk1B,GAAYj8B,UAAUsoB,KAAKvhB,GAEzBA,EAAQjG,KAAKsC,OAAO6gB,YAAa,CACnC,MAAMsd,EAAa/iB,KACbxd,EAAO,MAAC,GACd,IAAK,MAAM4oB,KAAS7iB,EAAQjG,KAAKE,KACZ,sBAAf4oB,EAAM7nB,MAAgC6nB,EAAMhY,OAAOzS,QAAUoiC,EAC/DvgC,EAAK,GAAK4oB,EAEV5oB,EAAKgK,KAAK4e,GAGd5oB,EAAK,KAAOsL,GAAkBpK,MAAMwL,kBAAkB,GAAIpB,GAAkBpK,MAAME,cAAcm/B,IAChGx6B,EAAQjG,KAAKE,KAAOA,CACtB,CACF,IAGJ,SAASooB,GAAyBC,EAAuBlK,GACvD,MAAM2C,EAAKzW,GACT0uB,GACA1Q,EACAlK,GAEF,IAAY,IAAR2C,EACF,MAAM,IAAI5M,MAAM,oDAElB,OAAO4M,CACT,CAOA,SAASmf,GAAqBv0B,EAAS3F,GACrC,MAAMy6B,EAAiB,CACrB1f,GAAIpV,EAAQqmB,SAAWzsB,EAAYoG,EAAQtM,MAC3CsM,UACA+0B,WAAO,GAET,IAAM/0B,EAAQI,QAAQF,OAAQF,EAAQC,sBAAsBC,KAAO,CACjE40B,EAAeC,MAAQ,CAAC,EACxB,IAAK,MAAO1Q,EAAUlkB,KAAUH,EAAQK,gBACtCy0B,EAAeC,MAAM1Q,GAAYkQ,GAAqBp0B,EAAO9F,EAEjE,CACA,OAAOy6B,CACT,CAGA,SAASrM,GAAuB9V,EAAS6B,GACvC,MAAMwgB,EAAYriB,EAAQuF,MACpB+c,EAAct1B,GAAkBnK,MAAM0/B,cAAc,IAC1D,IAAIC,EAkCJ,OAjCA91B,GAAQmV,GAAqBI,IAC3B,MAAMwgB,EAAgBxgB,EAAIlhB,KAC1B,IAAK6c,GAA0B6kB,GAAgB,OAC/C,MAAMC,EAAcnQ,GAAiBtQ,GAC/B0gB,EAAcD,IAAgBD,EACpC,IAAIG,EAAUN,EACd,GAAIrgB,EAAIjC,UAAYA,EAAS,CACtBwiB,IAAgBA,EAAiB,CAACF,IACvC,MAAMO,EAAgBR,EAAYpgB,EAAIjC,QAAQuF,MAC9C,IAAInf,EAAIo8B,EAAe5gC,OACnBixB,EAAO2P,EAAep8B,EAAI,GAC9B,KAAOA,GAAKy8B,EAAez8B,IAAK,CAC9B,MAAM08B,EAAgB91B,GAAkBnK,MAAM0/B,cAAc,IAC5D1P,EAAK1tB,WAAWwG,KACdqB,GAAkBnK,MAAMmb,eACtBhR,GAAkBnK,MAAMI,WAAWyG,KAAkBkxB,OACrDkI,IAGJN,EAAe72B,KAAKm3B,GACpBjQ,EAAOiQ,CACT,CACAF,EAAUJ,EAAeK,EAC3B,CACAD,EAAQz9B,WAAWwG,KACjBqB,GAAkBnK,MAAMmb,eACtBH,GAAe6kB,GACf11B,GAAkBnK,MAAMI,WAAWw/B,IACnC,EACAE,GAEH,IAEIL,CACT,CACA,SAAS/N,GAAmBvU,EAAS+W,GACnC,IAAI3uB,EAAQksB,IAAmBtnB,GAAkBnK,MAAMI,WAAW,aAClE,MAAMs2B,EAAOvZ,EAAQuF,MAAQwR,EAAcxR,MAC3C,IAAK,IAAInf,EAAI,EAAGA,EAAImzB,EAAMnzB,IACxBgC,EAAQ4E,GAAkBnK,MAAMwb,iBAAiBjW,EAAO4E,GAAkBnK,MAAMI,WAAWyG,KAAkBkxB,QAE/G,GAAIrB,EAAO,EACT,MAAM,IAAI1jB,MAAM,uCAElB,OAAOzN,CACT,CACA,SAAS26B,GAA0B/iB,EAAS0Z,GAC1C,MAAMsJ,EAAWnlB,GAAe0U,GAAiBmH,IACjD,OAAO1sB,GAAkBnK,MAAMwb,iBAC7BkW,GAAmBvU,EAAS0Z,EAAU1Z,SACtCgjB,EACkB,eAAlBA,EAAStgC,KAEb,CAGA,SAASugC,GAAqBC,EAASC,GAIrC,OAHAD,EAAQrxB,MAAQsxB,EAAatxB,MAC7BqxB,EAAQ5d,IAAM6d,EAAa7d,IAC3B4d,EAAQ9N,IAAM+N,EAAa/N,IACpB8N,CACT,CAGA,IAAIE,GAAat9B,OAAO,oBACpB46B,GAAyB56B,OAAO,4BAC/Bq5B,IAAe9c,IAAmB,IAAsB,IAAIhG,OAC5DgnB,GAAkBC,IAAoBjhB,IAAmB,IAAM,IACpE,SAASkhB,GAAcrjC,EAAOwC,EAAMsd,EAASyR,EAAeC,EAAUpM,EAAM,KAAMiG,GAAW,GAC3F,MAAM9I,EAAK4gB,KACLh2B,EAAU,CACdoV,KACA1hB,KAAMb,EACNwC,OACA4iB,MACAtF,UACA0R,WACAnG,WACAkK,qBAAiB,EACjB0K,wBAAoB,EACpBqD,uBAAmB,EACnBrhB,sBAAkB,EAClBwT,aAAS,EACTloB,QAAyB,IAAI4O,IAC7BwY,OAAwB,IAAIptB,IAC5BiG,gBAAiC,IAAIjG,IACrCgqB,gBACAnkB,sBAAuC,IAAI+O,IAC3C8X,iBAAa,EACbT,YAAQ,EACRvvB,UAAU,GAEZ,GAAIutB,EAAU,CACRnG,IAAUkG,EAActtB,UAAW,GACvC,MAAMs/B,EAAchS,EAAc/jB,gBAAgBlO,IAAIkyB,GAClD+R,GACFp2B,EAAQqkB,cAAW,EACnBrkB,EAAQokB,cAAgBgS,EACxBA,EAAYh2B,QAAQ7C,IAAIyC,IAExBokB,EAAc/jB,gBAAgBzF,IAAIypB,EAAUrkB,EAEhD,MAAWokB,GACTA,EAAchkB,QAAQ7C,IAAIyC,GAI5B,OAFAi2B,GAAiB7gB,EAAK,GACtB0c,KAAcv0B,IAAIyC,GACXA,CACT,CACA,SAASq2B,GAAmBriC,EAAKqB,EAAM+uB,GACrC,MAAMjvB,EAASnB,EAAII,KAAKgB,IACxB,GAAID,EAAQ,CACV,MAAMwd,EAAUgF,GAAmB3jB,GAC7BsiC,EAAyBC,GAAoBnS,GASnD,OARAoS,GACErhC,EACAivB,EAAgBA,EAAc/uB,KAAOA,EACrCrB,EAAI+G,MACJ4X,EACA2jB,OACA,GAEKnhC,EAAOuB,OAAOsJ,OACvB,CACF,CACA,SAAS2xB,GAAsBr9B,EAAMe,EAAM+uB,GACzC,MAAMhM,EAAS9jB,EAAKF,KAAKgkB,OACzB,GAAI9jB,EAAKF,KAAKE,KAAKC,QAAU6jB,EAAO7jB,OAAQ,CAC1C,MAAMoe,EAAUgF,GAAmBrjB,GAC7BgiC,EAAyBC,GAAoBnS,GAC7CqS,EAAgBH,KAA4BhiC,EAAKF,KAAKsC,QAAU,CAAC,GAAGsJ,QAAUk2B,GAClFt8B,EAAY,UACZvE,EACAsd,EACA2jB,OACA,IAEF3jB,EAAQyF,OAASqe,EACjB,IAAK,IAAI19B,EAAI,EAAGA,EAAIqf,EAAO7jB,OAAQwE,IACjCy9B,GACEpe,EAAOrf,GACP1D,EACAf,EAAKyG,MACL4X,EACA8jB,EACA19B,EAAI,IAGR,OAAO09B,CACT,CACF,CACA,SAASC,GAAsBC,EAAe32B,GAC5C,MAAM2S,EAAU3S,EAAQ2S,QAClBikB,EAAmBjf,GAAmBgf,GACtCE,EAzsER,SAA0BlkB,EAASgI,GACjC,IAAImc,EAAWnkB,EAKf,IAJIgI,EAAMzC,MAAQvF,EAAQuF,QACxB4e,EAAWnc,EACXA,EAAQhI,GAEHmkB,GAAU,CACf,GAAInc,IAAUmc,IAAanc,EAAMnhB,OAC/B,OAAOs9B,GAETnc,EAAQA,EAAMnhB,QACJ0e,MAAQ4e,EAAS5e,QACzB4e,EAAWA,EAASt9B,OAExB,CACA,MAAM,IAAIgP,MAAM,oBAClB,CAyrEuBuuB,CAAiBH,EAAkBjkB,GAClDjc,EAAQigC,EAAcviC,KAAKsC,QAAU,CAAC,EAC5C,IAAImvB,EAAiB7lB,EAAQwnB,OAAOr1B,IAAI0kC,GACxC,IAAKhR,EAAgB,CACnB7lB,EAAQwnB,OAAO5sB,IACbi8B,EACAhR,EAAiBqQ,GACft8B,EAAY,WAAa+8B,EAAcviC,KAAKV,MAC5C,EACAmjC,OACA,OACA,EACA72B,EAAQiY,KACR,IAGJtF,EAAQ6F,QAAU7D,GAAYpX,IAAIoV,EAAQ6F,QAASxY,GACnD,IAAI0qB,EAAiB/X,EAAQnZ,OAC7B,KAAOkxB,GAAkBA,IAAmBmM,GAC1CnM,EAAejS,gBAAiB,EAChCiS,EAAiBA,EAAelxB,MAEpC,CACIyD,GAAkB05B,IACpBjgC,EAAMunB,KAAO+Y,GAAWnR,OAAgB,GACxCnvB,EAAMic,QAAUikB,EAChBlgC,EAAMq/B,KAAc,GAEpBkB,GAAeN,EAAe9Q,GAEhC+Q,EAAiBte,iBAAmB3D,GAAYpX,IAC9Cq5B,EAAiBte,iBACjBuN,EAEJ,CAyBA,SAASqR,GAAgBpI,EAAY9uB,GACnC,MAAM2S,EAAUgF,GAAmBmX,GACnCqI,GAAmBrI,GACnBn3B,EAAkBm3B,EAAW16B,MAAOghB,IAClC,GAAIA,EAAG1hB,OAASsM,EAAQtM,KAAM,CAC5B,MAAMgD,EAAQ0e,EAAG1e,QAAU,CAAC,EAC5BsJ,EAAQ8yB,mBAAqBtb,GAAYja,IACvCyC,EAAQ8yB,mBACRngB,GAEFjc,EAAMo4B,WAAa9uB,EACnBtJ,EAAMic,QAAUA,CAClB,IAEJ,CACA,SAASwkB,GAAmB56B,GAC1B,MAAM66B,EAASx6B,GAAUL,GACrB66B,KACDA,EAAOhjC,KAAKsC,QAAU,CAAC,GAAGqoB,iBAAkB,EAEjD,CACA,SAASyX,GAAiCa,EAAMhiC,EAAM0F,EAAO4X,EAASyR,EAAeC,GACnF,OAAQgT,EAAKhiC,MACX,IAAK,cA/CT,SAAmCiiC,EAAct3B,GAC/C,MAAM,eAAEu3B,EAAc,mBAAEC,GAAuBF,EAC/C,IAAK,MAAMX,KAAiBY,EAAgB,CAC1C,MAAMX,EAAmBjf,GAAmBgf,GACxCjc,GAAqB1a,EAAQ2S,QAASikB,GACxCK,GAAeN,EAAe32B,GAE9B02B,GAAsBC,EAAe32B,EAEzC,CACA,IAAK,MAAM4U,KAAO4iB,EAChB,GAAI5iB,EAAI6iB,qBACNP,GAAgBtiB,EAAIziB,IAAI,YAAa6N,QAChC,GAAI4U,EAAIuB,2BACb+gB,GAAgBtiB,EAAIziB,IAAI,QAAS6N,GACP,MAAtB4U,EAAIxgB,KAAK6C,UAAkB,CAC7B,MAAME,EAAOyd,EAAIziB,IAAI,QACjBgF,EAAK0e,gBACPohB,GAAe9/B,EAAM6I,EAEzB,CAGN,CAyBM03B,CACE38B,EAAMwb,WAAW8gB,EAAK3jC,OACrB2jC,EAAK3gC,QAAU,CAAC,GAAGsJ,QAAUk2B,GAC5BmB,EAAK3jC,KACL2B,EACAsd,EACAyR,EACAC,EACAgT,EAAKpf,KACL,IAGJ,MACF,IAAK,gBAAiB,CACpB,MAAM0f,GAAkBtT,EAAWD,EAAc/jB,gBAAgBlO,IAAIkyB,GAAYD,MAAoBiT,EAAK3gC,QAAU,CAAC,GAAGsJ,QAAUk2B,GAChIt8B,EAAYyqB,GAAY,WACxBhvB,EACAsd,EACAyR,EACAC,EACAgT,EAAKpf,MAEP,IAAK,MAAMpgB,KAAQw/B,EAAKv/B,WACtB,GAAkB,gBAAdD,EAAKxC,KACPmhC,GACE3+B,EAAKT,SACL/B,EACA0F,EACA4X,EACAglB,EACAtT,OAEG,CACL,IAAIpyB,EACJ,GAAsB,eAAlB4F,EAAK5F,IAAIoD,KACXpD,EAAM4F,EAAK5F,IAAIyB,SACV,IAAsB,kBAAlBmE,EAAK5F,IAAIoD,KAGlB,MAAM,IAAImT,MAAM,iDAFhBvW,EAAM4F,EAAK5F,IAAIQ,KAGjB,CACA+jC,GACE3+B,EAAKpF,MACL4C,EACA0F,EACA4X,EACAglB,EACA1lC,EAEJ,CAEF,KACF,CACA,IAAK,eAAgB,CACnB,MAAM0lC,GAAkBtT,EAAWD,EAAc/jB,gBAAgBlO,IAAIkyB,GAAYD,MAAoBiT,EAAK3gC,QAAU,CAAC,GAAGsJ,QAAUk2B,GAChIt8B,EAAYyqB,GAAY,WACxBhvB,EACAsd,EACAyR,EACAC,EACAgT,EAAKpf,MAEP,IAAIlf,GAAK,EACT,IAAK,MAAM6+B,KAAWP,EAAKr/B,SACzBe,IACI6+B,IACmB,gBAAjBA,EAAQviC,KACVmhC,GACEoB,EAAQxgC,SACR/B,EACA0F,EACA4X,EACAglB,EACAtT,GAGFmS,GACEoB,EACAviC,EACA0F,EACA4X,EACAglB,EACA,GAAG5+B,MAKX,KACF,CACA,IAAK,oBACHy9B,GACEa,EAAKlgC,KACL9B,EACA0F,EACA4X,EACAyR,EACAC,GAIR,CACA,SAAS4S,GAAeN,EAAe32B,GACrC,IAAI+tB,EAAO4I,EACPtK,EAAYrsB,EACZ63B,EAAW73B,EAAQtM,KACvB,OAAa,CACX,MAAM,OAAE8F,GAAWu0B,EACnB,IAAKt2B,EAAkBjC,MAAMsiC,mBAAmBt+B,GAAS,MACzD,MAAM3B,EAAOkgC,GAA8Bv+B,GAC3C,QAAa,IAAT3B,EAAiB,MACrB,GAAIw0B,EAAUhsB,gBAAgB3E,IAAI7D,GAChCk2B,EAAOA,EAAKtxB,WACZ4vB,EAAYA,EAAUhsB,gBAAgBlO,IAAI0F,GAC1CggC,EAAWxL,EAAU34B,SAHvB,CAMA,GAAIuJ,GAAkB8wB,EAAKtxB,cAAgBu7B,GAAuBngC,GAChE,MAEFk2B,EAAOA,EAAKtxB,WACZ4vB,EAAY6J,GACV2B,GAAY,IAAIhgC,EAAKsD,QAAQ,kBAAmB,OAChDkxB,EAAUh3B,KACVg3B,EAAU1Z,QACV0Z,EACAx0B,EAVF,CAYF,CACA,MAAMu/B,EAASx6B,GAAUmxB,GACnBkK,EAAWt7B,GAAYy6B,GAAUrJ,IACjC,QAAEpb,GAiXV,SAA6BpW,EAAOyD,EAAS5L,GAC3C,MAAM8jC,EAAY37B,EAAMnI,KAAKsC,QAAU,CAAC,EAClCq7B,EAAoBC,KAM1B,OALAkG,EAAUvlB,QAAUgF,GAAmBpb,GACvCw1B,EAAkBn3B,IAChBs9B,EACA55B,GAAKyzB,EAAkB5/B,IAAI+lC,GAAY,CAAEl4B,UAAS5L,UAE7C8jC,CACT,CA1XsBC,CAAoBF,EAAU5L,EAAW0B,EAAK35B,MAClE,GAAIgjC,EAAQ,CACV,MAAMnF,EAAYC,KACZkG,EAAUhB,EAAOhjC,KAAKsC,QAAU,CAAC,EACvC0hC,EAAQzlB,QAAUA,EAClBsf,EAAUr3B,IACRw9B,EACA95B,GAAK2zB,EAAU9/B,IAAIimC,GAAU,CAC3Bp4B,QAASqsB,EACTj4B,KAAM25B,EAAK35B,OAGjB,CACF,CACA,IAAKg+B,IAAuBpd,IAC1B,IAAsB,IAAI5a,MAE5B,SAASi+B,GAAgB1lB,EAASpgB,EAAQ8/B,GACxC,MAAMC,EAAc//B,EAAOmE,QAAU,CAAC,EAGtC,OAFA47B,EAAY3f,QAAUA,EACtByf,KAAsBx3B,IAAIrI,EAAQ8/B,GAC3BC,CACT,CACA,SAASjF,GAAwBzvB,EAAGC,GAClC,OAAOhF,MAAMC,QAAQ8E,GAAK/E,MAAMC,QAAQ+E,GAAKy6B,GAAqB16B,EAAGC,IAAM,EAAIhF,MAAMC,QAAQ+E,GAAK,EAAI8W,GAAYtX,QAAQO,EAAGC,EAC/H,CACA,SAASy6B,GAAqB16B,EAAGC,GAC/B,MAAMuB,EAAMxB,EAAErJ,OACRgkC,EAAWn5B,EAAMvB,EAAEtJ,OACzB,GAAiB,IAAbgkC,EACF,OAAOA,EAET,IAAK,IAAIx/B,EAAI,EAAGA,EAAIqG,EAAKrG,IAAK,CAC5B,MAAM0G,EAAgBkV,GAAYtX,QAAQO,EAAE7E,GAAI8E,EAAE9E,IAClD,GAAsB,IAAlB0G,EACF,OAAOA,CAEX,CACA,OAAO,CACT,CAqPA,SAAS40B,GAAsB9N,EAAc5T,GAC3C,IAAImU,EACJ,IAAK,MAAM9mB,KAAWumB,EAChBvmB,EAAQ2S,UAAYA,GACtBtT,GAAQW,EAAQsoB,SAAUpjB,IACpBA,EAAO4hB,eAAiBA,GAAeA,EAAY1R,GAAKlQ,EAAO4hB,YAAY1R,MAC7E0R,EAAc5hB,EAAO4hB,YACvB,IAIN,OAAOA,CACT,CACA,IAAIC,GAAmC,IAAIptB,QAC3C,SAAS6+B,GAAoBx4B,EAASy4B,GACpCC,GAAkB99B,IAAIoF,EAASy4B,IAAa,EAC9C,CACA,IAAIE,GAAkC,IAAI9oB,QACtC6oB,GAAoC,IAAI/+B,QAC5C,SAASk5B,GAAsB7yB,GAC7B,GAAI24B,GAAgBj9B,IAAIsE,GAAU,OAElC,OADA24B,GAAgBp7B,IAAIyC,GACZA,EAAQ3K,MACd,KAAK,EAGH,OAFA2K,EAAQsoB,QAAUtoB,OAClBA,EAAQ8U,kBAAmB,GAE7B,KAAK,EAGH,OAFA9U,EAAQsoB,QAAUtoB,OAClBA,EAAQ8U,iBAAmB9U,GAG/B,IAAIG,EACA+E,EAASlF,EACb,KAAOG,EAAQ+E,EAAOkf,eACpBlf,EAAS/E,EAEP+E,IAAWlF,GAIV24B,GAAgBj9B,IAAIwJ,KACvByzB,GAAgBp7B,IAAI2H,GACpB0zB,GAAsB1zB,IAExBlF,EAAQsoB,QAAUpjB,EAAOojB,QACzBtoB,EAAQ8U,iBAAmB5P,EAAO4P,kBARhC8jB,GAAsB54B,EAS1B,CACA,SAAS44B,GAAsB54B,GAC7B,MAAMkU,EAAQwkB,GAAkBvmC,IAAI6N,GAEpC,GADA04B,GAAkB3lB,OAAO/S,QACX,IAAVkU,IAA8B,IAAVA,EACtBlU,EAAQ8U,kBAAmB,EAC3B9U,EAAQsoB,QAAUtoB,OACb,GAAIkU,EAAO,CAChB,MAAM2kB,EAAuB,IAAI7pB,IACjC,IACIsZ,EADAwQ,GAAmB,EAEvBz5B,GAAQ6U,GAAQld,IACVsd,GAAkBtd,IACpBqI,GAAQrI,EAAKwd,oBAAqBI,IAC3BikB,EAAKn9B,IAAIkZ,KACZikB,EAAKt7B,IAAIqX,GACTie,GAAsBje,GACtB0T,EAAU3T,GAAYhX,MAAM2qB,EAAS1T,EAAI0T,SACzCwQ,KAA8C,IAAzBlkB,EAAIE,iBAC3B,GAEJ,IAEEwT,IACFtoB,EAAQsoB,QAAUA,EAClBtoB,EAAQ8U,kBAAmBgkB,GAAmBxQ,EAElD,CACF,CACA,IAAI3T,GAAc,IAAIxX,IAAO,SAAyBS,EAAGC,GACvD,OAAOD,EAAE+U,QAAQyC,GAAKvX,EAAE8U,QAAQyC,IAAMxX,EAAEvI,OAASwI,EAAExI,OAAoB,IAAXuI,EAAEvI,MAAmC,IAAXwI,EAAExI,QAAwBuI,EAAEvI,KAAOwI,EAAExI,MAAsBuI,EAAEwX,GAAKvX,EAAEuX,EAC5J,KACK4c,IAAwBhd,IAC3B,IAAsB,IAAI5a,OAEvB83B,IAAsBld,IACzB,IAAsB,IAAI5a,MAY5B,SAAS2+B,GAAe3kC,GACtB,GAAIyE,MAAMC,QAAQ1E,GAChB,IAAK,MAAMiF,KAAQjF,GAChBiF,EAAK3C,QAAU,CAAC,GAAGsiC,QAAS,OAG9B5kC,EAAKsC,QAAU,CAAC,GAAGsiC,QAAS,CAEjC,CACA,SAASzC,GAAoBv2B,GAC3B,OAAOA,IAAYA,EAAQqkB,SAAWrkB,EAAUA,EAAQokB,eAAiBpkB,EAC3E,CACA,SAASi5B,GAAwBjlC,EAAKklC,EAAiB,IACrD,GAAIllC,EAAI00B,UACN,IAAK,MAAMjX,KAAOzd,EAAI00B,UACpBwQ,EAAe56B,KAAKmT,GAGxB,IAAK,MAAMxd,KAASD,EAAI+B,WACtBmjC,EAAe56B,KAAKrK,EAAMxB,OAE5B,IAAK,MAAMyqB,KAASlpB,EAAIM,KAAK0kB,cAAgBhlB,EAAIM,KAAKA,KAAON,EAAIglB,cAC/D,OAAQkE,EAAM7nB,MACZ,IAAK,WACH4jC,GAAwB/b,EAAOgc,GAC/B,MACF,IAAK,iBACH,IAAK,MAAMvP,KAAazM,EAAM5oB,KAC5B4kC,EAAe56B,KAAKqrB,GAK5B,OAAOuP,CACT,CACA,SAASnW,GAAwB/iB,EAASm5B,GACxC,OAAIj9B,IACKzE,EAAkBjC,MAAMib,eAAezQ,EAAQoV,IAEjD3d,EAAkBjC,MAAME,cAC7BsK,EAAQtM,MAAQylC,GAA8B,IAAjBn5B,EAAQ3K,KAAuB,IAAI2K,EAAQoV,KAAO,IAEnF,CACA,SAAS8P,GAAiBllB,EAASm5B,GACjC,OAAIj9B,IACK8D,EAAQoV,GAAK,GAEfpV,EAAQtM,MAAQylC,GAA8B,IAAjBn5B,EAAQ3K,KAAuB,IAAI2K,EAAQoV,KAAO,GACxF,CACA,SAAS4X,GAA4Bra,GACnC,OAAOA,EAAQwF,gBAAkBxF,EAAQwF,gBAAgB6W,OAAS9J,GAAiBvS,EAAQwF,gBAAgBnY,SAAW5D,IAAoBuwB,cAAgBha,EAAQyC,EACpK,CACA,SAASuV,GAAmChY,GAC1C,MAAMpO,EAAWyoB,GAA4Bra,GAC7C,OAAOpO,EAA+B,iBAAbA,EAAwB9M,EAAkBjC,MAAMib,eAAelM,GAAY9M,EAAkBjC,MAAME,cAAc6O,QAAY,CACxJ,CACA,SAAS4Z,GAAmB/pB,GAC1B,MAAM,MAAEsC,GAAUtC,EAClB,IAAKsC,EAAO,OACZ,IACIwC,GADA,QAAE8G,EAAO,KAAEie,GAASvnB,EAUxB,GARIunB,SACiB,IAAfA,EAAK8W,OACP/0B,EAAUie,EAAKje,QACfie,OAAO,GAEPje,OAAU,GAGVA,EACgB,eAAd5L,EAAKiB,KACc,IAAjB2K,EAAQ3K,KACV6D,EAAc9E,EAAKsC,QAAQq/B,IAAct+B,EAAkBjC,MAAM6L,eAAeukB,GAA2B5lB,GAAU,CACnHknB,GAAmB9yB,EAAKsC,MAAMic,QAAS3S,EAAQ2S,WAC5Clb,EAAkBjC,MAAMI,WAAWsvB,GAAiBllB,IAChDA,EAAQtM,OAASU,EAAKV,OAC/BU,EAAKV,KAAOsM,EAAQtM,MAGtBwF,EAAczB,EAAkBjC,MAAMI,WAAWoK,EAAQtM,WAEtD,GAAIuqB,IACT/kB,EAAc0X,GACZnZ,EAAkBjC,MAAMI,WAAWqoB,EAAKje,QAAQtM,MAChDmF,MAAMC,QAAQmlB,EAAK8W,OAAS9W,EAAK8W,MAAM,GAAK9W,EAAK8W,OAE/Cl8B,MAAMC,QAAQmlB,EAAK8W,QACrB,IAAK,IAAIh8B,EAAI,EAAGA,EAAIklB,EAAK8W,MAAMxgC,OAAQwE,IACrCG,EAAc0X,GAAmB1X,EAAa+kB,EAAK8W,MAAMh8B,IAI/D,OAAOG,GAAe08B,GAAqB18B,EAAa9E,EAC1D,CACA,SAASw+B,GAAara,EAAUvY,GAC9B,IAAIo5B,GAAep5B,EAAQC,sBAAsBC,KAC7CF,EAAQwnB,OAAOtnB,OACjBk5B,GAAc,GAEhB,IAAK,MAAMj5B,KAASH,EAAQI,QACtBwyB,GAAara,EAAUpY,GACzBH,EAAQI,QAAQ2S,OAAO5S,GAEvBi5B,GAAc,EAGlB,IAAK,MAAOnnC,EAAKkO,KAAUH,EAAQK,gBAC7BuyB,GAAara,EAAUpY,GACzBH,EAAQK,gBAAgB0S,OAAO9gB,GAE/BmnC,GAAc,EAMlB,OAHIA,GACF7gB,EAASxF,OAAO/S,GAEXo5B,CACT,CACA,SAASzG,GAA0B37B,EAAMu7B,EAAOG,GAC9C,IAAIle,EACJ,GAAI3b,MAAMC,QAAQy5B,GAChB,IAAK,MAAMtU,KAAQsU,EAAO,CACxB,IAAI,QAAEvyB,GAAYie,EAClB,GAAIA,EAAK7pB,KAAM,CACb,MAAMilC,GAAiBpb,EAAK7pB,KAAKsC,QAAU,CAAC,GAAGunB,OAASqb,GAA2B/G,EAAOvyB,OAAS,KAChGA,YAAaie,EAAK7pB,KAAKsC,QAAU,CAAC,GAAGunB,KAAOob,EACjD,CACA7kB,EAAqBG,GAAYpX,IAAIiX,EAAoBxU,EAC3D,MACSuyB,IACLA,EAAMn+B,QACPm+B,EAAMn+B,KAAKsC,QAAU,CAAC,GAAGunB,KAAO+Y,GAAWzE,EAAMvyB,aAAS,IAE7DwU,EAAqB+d,EAAMvyB,SAE7B,GAAInH,MAAMC,QAAQ0b,GAAqB,CACrC,MAAM+e,EAAgBb,EAAuBvgC,IAAI6E,EAAK2b,UAAY,GAC5D4T,EAAe9nB,GACnB65B,GACA/E,EACA/e,GAEE+R,EACF/R,EAAqB+R,EAErBmM,EAAuB93B,IACrB5D,EAAK2b,QACLlV,GAAU66B,GAAsB/E,EAAe/e,GAGrD,CACA,OAAOA,CACT,CACA,SAAS8kB,GAA2B/G,EAAOgH,EAAaC,GACtD,MAAM,cAAEpV,GAAkBmV,EAC1B,GAAInV,GAAiBvrB,MAAMC,QAAQy5B,GAAQ,CACzC,MAAM16B,GAgBoBmI,EAhBQu5B,GAiBrBlV,UAAYrkB,EAAQokB,eAAeC,SAhB1CoV,OAAsB,IAAT5hC,EAAkB2hC,EAAYl7B,GAAKk7B,EAAW3hC,GACjE,IAAK,MAAM,QAAEmI,KAAauyB,EACxB,GAAIvyB,IAAYu5B,EAAa,CAC3B,IAAIp5B,EAAQikB,EACZ,KAAOjkB,GAAO,CACZ,GAAIH,IAAYG,EACd,OAAOm5B,GAA2B/G,EAAOpyB,EAAOs5B,GAElDt5B,EAAQA,EAAMikB,aAChB,CACF,CAEJ,CAGF,IAA8BpkB,EAF5B,OAAOg3B,GAAWuC,EAAaC,EACjC,CAIA,SAASxC,GAAWh3B,EAAS+0B,GAC3B,MAAO,CAAE/0B,UAAS+0B,QACpB,CACA,SAASgD,GAA8B/gC,GACrC,OAAQA,EAAKqtB,SAAShvB,MACpB,IAAK,gBACH,OAAO2B,EAAKqtB,SAAS5xB,MACvB,IAAK,iBACH,MAAO,GAAKuE,EAAKqtB,SAAS5xB,MAC5B,IAAK,aACH,GAAIuE,EAAKJ,SAAU,OACnB,OAAOI,EAAKqtB,SAAS3wB,KAE3B,CACA,SAASskC,GAAuBngC,GAC9B,MAAO,yDAAyD+K,KAAK/K,EACvE,CACA,SAASyc,GAAkB5d,GACzB,SAAUA,GAAUA,EAAMsiC,SAAUtiC,EAAMic,QAC5C,CACA,SAASic,GAAuBl4B,GAC9B,OAAO4d,GAAkB5d,SAA+B,IAArBA,EAAMo4B,UAC3C,CACA,SAAStQ,GAAoB9nB,GAC3B,OAAO4d,GAAkB5d,SAA+B,IAArBA,EAAMioB,UAC3C,CAGA,IAAI+a,GAAcjhC,OAAO,yBACrBkhC,GAAgB,CAClB7mC,OAAAA,CAAQkB,IACN,EAAIqC,EAAqB+sB,aAAapvB,IACtC,EAAIqC,EAAqBzB,cAAcZ,GACvCD,EAAoBC,IACpB,EAAIqC,EAAqBtB,uBAAuBf,GAChD,MAAM,KAAEI,GAASJ,EACX4lC,EAAU5lC,EAAI7B,IAAI,QAClBwgB,EAAUgF,GAAmB3jB,IAC5B6lC,GAAazlC,EAAK2B,WAGzB,IAFiB/B,EAAII,KAAKsC,QAAU,CAAC,GAC5BgjC,IAAexD,GAAc,QAAS,EAAavjB,IACvDknB,EACH,MAAM7lC,EAAI7B,IAAI,QAAQgC,oBAAoB,qCAE5C,GAAIC,EAAK2B,WAAWxB,OAAS,IAAM6B,EAAkBZ,MAAMskC,iBAAiBD,IAAiC,UAAnBA,EAAUnmC,KAClG,MAAMM,EAAI7B,IAAI,QAAQgC,oBACpB,wDAGJ,IAAKC,EAAKE,KAAKA,KAAKC,OAClB,MAAMP,EAAI7B,IAAI,QAAQgC,oBAAoB,0CAE5C,GAAIC,EAAKE,KAAK8jB,OAAO7jB,SAAWH,EAAKE,KAAK8jB,OAAO7jB,OAAS,GAAK6B,EAAkBZ,MAAMukC,gBAAgB3lC,EAAKE,KAAK8jB,OAAO,KACtH,MAAMpkB,EAAI7B,IAAI,QAAQgC,oBACpB,qDAGJ,MAAM6lC,EAAcviB,GAAamiB,GAC3BK,EAAaxjC,EAASojC,EAAUpnC,OACtCklB,GAAmB3jB,GACnB,MAAMyiC,EAAgB9E,GAAsBiI,EAAS,GACjDnD,GACF+B,GAAoB/B,EAAewD,GAErCD,EAAYphB,mBAAqBihB,EAAUpnC,MAAMiE,KACnD,EACApD,UAAWuoB,GAAkB,CAC3BC,KAAM,CACJR,KAAAA,CAAMtnB,GACJ,MACMgmC,EAAc9gB,GADJllB,EAAI7B,IAAI,SAEnB6nC,GAILzgB,GAAwBygB,GAAa,GACrC1X,GAAYtuB,IAJVA,EAAIsB,QAKR,EACAsmB,IAAAA,CAAK5nB,GACH,MAAM,KAAEI,GAASJ,GACV6lC,GAAazlC,EAAK2B,WAEnBmkC,EADW9lC,EAAKsC,MACIgjC,IACpBE,EAAU5lC,EAAI7B,IAAI,QAClBwgB,EAAUwG,GAAWnlB,GACrBgmC,EAAc9gB,GAAkB0gB,GAChC9mB,EAAkBknB,GAAejmB,GAA0BimB,GACjEld,GAAU9oB,GACV+oB,GAA0B6c,GAC1B5lC,EAAI8B,YACFM,EAAkBZ,MAAM4L,oBACtBiQ,GACE,OACAgI,GAAqB1G,GACrBoQ,GAAwBmX,GACxBL,EAAUpnC,MACV2D,EAAkBZ,MAAMmoB,wBACtBvpB,EAAKE,KAAK8jB,OACVmM,GAAyBnwB,EAAKE,KAAKA,OAEpCwe,GAAkF,IAApBA,OAA2B,EAAS8J,GAAkB9J,GAAlG1c,EAAkBZ,MAAMib,eAAe,MAG9D,GAAGjY,MACP,GAEFujB,IAAK,CACHT,KAAAA,CAAMtnB,GACJ,MACMgmC,EAAc9gB,GADJllB,EAAI7B,IAAI,SAEnB6nC,GAILzgB,GAAwBygB,GAAa,GACrC14B,GAAMtN,EAAK,IACXssB,GAAatsB,IALXA,EAAIsB,QAMR,EACAsmB,IAAAA,CAAK5nB,GACH,MAAM,KAAEI,GAASJ,EAEXkmC,EADW9lC,EAAKsC,MACIgjC,IACpB/mB,EAAUwG,GAAWnlB,GACrBgmC,EAAc9gB,GAAkBllB,EAAI7B,IAAI,SACxCg0B,EAASH,GAAUrT,EAASunB,EAAU,SAC5C/T,EAAOzlB,MAAQ,IACN2Q,GACL,WACA0R,GAAwBmX,GACxB9jC,EAAkBZ,MAAMI,WAAWokC,EAAYtmC,OAGnDmwB,GACElR,EACAqnB,EAAYphB,oBAAoBpE,mBAChC2R,EACAnyB,EAAII,KAAK2B,WAAW,GAAGtD,OAEzBuB,EAAIsB,QACN,KAGJS,WAAY,CAAC,EACbC,aAAc,CACZ,CACEE,YAAa,uCACb+tB,mBAAoB,8CAGxBzuB,MAAO/B,EAAqBC,KAAO,4BAIjCymC,GAAoBxmC,EAAQ,yCAC5BymC,GAAuBzmC,EAAQ,+CAC/B0mC,GAAiB,CACnBnyB,KAAAA,CAAMlU,GACJ,MAAM,KACJI,EACA2jB,KAAK,KAAEle,IACL7F,EACEsmC,EAAWlmC,EAAKkmC,SAChB/Z,EAAO+Z,EAASn/B,QAAQ,aAAc,IAAIo/B,OAC1C/1B,EAAQpQ,EAAKV,KAAK8Q,OAAS81B,EAAS/lC,OAASgsB,EAAKhsB,QACxD,IAAID,GAAO,EAAI8lC,GAAqBI,iBAAiB3gC,EAAM0mB,EAAM/b,EAAOA,EAAQ+b,EAAKhsB,QACjE,IAAhBD,EAAKC,QAAgB4lC,GAAkB3kC,MAAM8zB,iBAAiBh1B,EAAK,MACrEA,EAAOA,EAAK,GAAGA,MAEjBN,EAAI8B,YAAYqkC,GAAkB3kC,MAAMilC,eAAenmC,GAAM,EAAM,UACrE,EACAyvB,aAAc,CACZ4F,WAAW,EACX+Q,YAAY,GAEd1kC,aAAc,CACZ,CACEC,YAAa,qBACbC,YAAa,6FACb+tB,mBAAoB,wDAMtB0W,GAAoBhnC,EAAQ,yCAC5BinC,GAAuBjnC,EAAQ,+CAG/BknC,GAAoBlnC,EAAQ,yCAChC,SAASmnC,GAAa9mC,EAAK+mC,EAAcvkB,EAAO,SAC9C,MACEpiB,MAAQgB,IAAKD,IACXnB,EACCmB,GAGLnB,EAAIuuB,aACFsY,GAAkBrlC,MAAMuoB,oBAAoBvH,EAAM,CAACqkB,GAAkBrlC,MAAMwoB,mBAAmB7oB,EAAQ4lC,KAE1G,CAGA,IAAIC,GAAgB,CAClBloC,OAAAA,CAAQkB,IACN,EAAI4mC,GAAqBhmC,cAAcZ,IACvC,EAAI4mC,GAAqB/lC,gBAAgBb,GACzCK,EAAoBL,GACpB,MAAM,KAAEI,GAASJ,GACV6lC,GAAazlC,EAAK2B,WACzB,IAAK3B,EAAKgB,IACR,MAAMpB,EAAI7B,IAAI,QAAQgC,oBAAoB,4CAE5C,IAAK0lC,EACH,MAAM7lC,EAAI7B,IAAI,QAAQgC,oBAAoB,qCAE5C,GAAIC,EAAK2B,WAAWxB,OAAS,IAAMomC,GAAkBnlC,MAAMskC,iBAAiBD,KAAeA,EAAUne,SAA8B,UAAnBme,EAAUnmC,KACxH,MAAMM,EAAI7B,IAAI,QAAQgC,oBACpB,wDAGJ,MAAM8lC,EAAaxjC,EAASojC,EAAUpnC,OAChC2xB,EAAgBuW,GAAkBnlC,MAAMqgB,aAAagkB,EAAUpnC,OAASuB,EAAI+G,MAAMwb,WAAWsjB,EAAUpnC,MAAMiB,OAAOkC,WAAWc,OAAOsJ,aAAU,EAClJokB,IACF6V,EAAWjB,QAAS,GAEtB,MAAMh5B,EAAUq2B,GAAmBriC,EAAK,EAAiBowB,GACrDpkB,IACGi6B,EAAWnjC,WAAUkJ,EAAQlJ,UAAW,GAC7C0hC,GAAoBx4B,EAASi6B,GAEjC,EACA3mC,UAAW,CACTsoB,IAAAA,CAAK5nB,GACH,MAAM,KAAEI,GAASJ,GACV6lC,GAAazlC,EAAK2B,YACnB,MAAEtD,GAAUonC,EAClB,GAAI59B,IAAe,CACjB,MAAM0W,EAAUwG,GAAWnlB,GACrBinC,EAAa7mC,EAAKgB,IAAIsB,OAAOsJ,QACnC,GAAIi7B,IAAeA,EAAW7W,cAAe,CAC3C,MAAM8W,EAAa/T,GAAU8T,GAC7BpX,GAASlR,EAASlgB,EAAMiE,OAAO8d,mBAAoB0mB,EAAYzoC,EACjE,CACF,MACEqoC,GAAa9mC,EAAKvB,GAEpBuB,EAAIsB,QACN,GAEFyuB,aAAc,CACZC,aAAa,GAEfjuB,WAAY,CAAC,EACbC,aAAc,CACZ,CACEE,YAAa,qCACb+tB,mBAAoB,8CAGxBzuB,MAAO/B,EAAqBC,KAAO,4BAIjCynC,GAAoBxnC,EAAQ,yCAC5BynC,GAAuBznC,EAAQ,+CAC/B0nC,GAAgB,CAClBvoC,OAAAA,CAAQkB,GACN,MAAO6lC,GAAa7lC,EAAII,KAAK2B,WAK7B,IAJA,EAAIqlC,GAAqBhY,aAAapvB,IACtC,EAAIonC,GAAqBxmC,cAAcZ,IACvC,EAAIonC,GAAqBvmC,gBAAgBb,GACzCK,EAAoBL,GAChBA,EAAII,KAAK2B,WAAWxB,OAAS,GAAoC,IAA/BP,EAAII,KAAK2B,WAAWxB,UAAkB4mC,GAAkB3lC,MAAMskC,iBAAiBD,KAAeA,EAAUne,SAA8B,UAAnBme,EAAUnmC,MACjK,MAAMM,EAAI7B,IAAI,QAAQgC,oBACpB,uDAGN,EACAb,UAAW,CACTsoB,IAAAA,CAAK5nB,GACH,MAAM2e,EAAUwG,GAAWnlB,IACpB6lC,GAAa7lC,EAAII,KAAK2B,WACvBye,EAAqBqlB,GAAWpnC,MAAMiE,OAAO8d,mBAC7CmV,EAAYiM,GAAqBuF,GAAkB3lC,MAAM8lC,oBAAqBtnC,EAAII,MACpF0H,IACF9H,EAAIuuB,aAAaoH,GAEjBF,GAAa,SAAU9W,EAAS6B,EAAoBmV,GAEtD31B,EAAIsB,QACN,GAEFyuB,aAAc,CACZC,aAAa,GAEfjuB,WAAY,CAAC,EACbC,aAAc,CACZ,CACEE,YAAa,yBACb+tB,mBAAoB,8CAGxBzuB,MAAO/B,EAAqBC,KAAO,4BAKjC6nC,IADoB5nC,EAAQ,yCACLA,EAAQ,gDAG/B6nC,GAAoB7nC,EAAQ,yCAC5B8nC,GAAuB9nC,EAAQ,+CAC/B+nC,GAA4C,IAAI/hC,QACpD,SAASgiC,GAAqBC,GAC5B,IAAI/oC,EAAQ6oC,GAA0BvpC,IAAIypC,GAK1C,OAJK/oC,IACHA,EAAQ+G,EAAYgiC,EAAKloC,MACzBgoC,GAA0B9gC,IAAIghC,EAAM/oC,IAE/B2oC,GAAkBhmC,MAAMI,WAAW/C,EAC5C,CACA,SAASgpC,GAAqB7nC,GAC5B,GAAIA,EAAII,KAAKsC,OAAOsiB,cAAe,OAAOhlB,EAAII,KAAKsC,MAAMsiB,cACzD,MAAM8iB,EAAY9nC,EAAII,KAAKE,KAAK0kB,cAAgBhlB,EAAI7B,IAAI,QAAQA,IAAI,QAAU6B,EAAI7B,IAAI,iBACtF,IAAK2pC,EAAUvnC,OAAQ,OACvB,MACMwnC,GADW/nC,EAAII,KAAKsC,QAAU,CAAC,GACbsiB,cAAgB,CAAC,EACnCgjB,EAAqB,CAAC,EACtBC,EAA+C,IAAI7hC,IACzD,IAAK,MAAM8iB,KAAS4e,EAClB,GAAI5e,EAAM/a,aACR,IAAI,EAAIs5B,GAAqBthB,gBAAgB+C,GAAQ,CACnD,MAAMrqB,EAAQoP,GAAWib,GACzB6e,EAAOlpC,KAAWqpC,GAAkBrpC,EAAO,CAACA,KAC3CmpC,EAAmBnpC,KAAW,IAAIyL,KAAK4e,GACxC2e,GAAqB3e,EACvB,KAAO,CACL,MAAMif,GAAa,EAAIV,GAAqBW,WAAWlf,GACvD,IAAImf,EACJ,IAAK,MAAMxpC,KAASypC,GAAcpf,EAAO8e,GAAqB,CAC5D,MAAMO,EAAUR,EAAOlpC,GACvB,GAAI0pC,EACF,GAAKF,GAEE,GAAIA,IAAaE,EAAQp1B,MAC9B,IAAK,MAAMzM,KAAS6hC,EAAQp1B,MAC1B40B,EAAOrhC,GAAOyM,MAAQk1B,EACtBA,EAAS/9B,KAAK5D,QAJhB2hC,EAAWE,EAAQp1B,MAQvB,IAAIq1B,EAAcT,EAAOlpC,GACpB2pC,IACHA,EAAcT,EAAOlpC,GAASqpC,GAAkBrpC,EAAO,IACvDwpC,EAAWG,EAAYr1B,MACvBk1B,EAAS/9B,KAAKzL,IAEhB2pC,EAAYC,SAAU,EAClBN,IACFK,EAAYE,UAAW,GAEzBT,EAA6BrhC,IAAIsiB,EAAOrqB,EAC1C,CACF,CAGJ,IAAK,MAAO8pC,EAAgBC,KAAmBX,GAC5CU,EAAevoC,KAAKsC,QAAU,CAAC,GAAGmmC,kBAAoBd,EAAOa,GAAgBz1B,MAEhF,IAAK,MAAMtU,KAASmpC,EAAoB,CACtC,MAAMQ,EAAcT,EAAOlpC,GAC3B,IAAK2pC,EAAYE,SAAU,CACzB,MAAMI,EAAed,EAAmBnpC,GACpCiqC,EAAavoC,OAAS,IACxBioC,EAAYE,UAAYF,EAAYC,SAAWM,GAA2BD,GAE9E,CACF,CACA,OAAOf,CACT,CACA,SAASG,GAAkBrpC,EAAOsU,GAChC,MAAO,CACLzT,KAAMb,EAAM0Q,MAAM,GAClBk5B,SAAS,EACTC,UAAU,EACVv1B,QAEJ,CACA,SAASm1B,GAActoC,EAAKgoC,EAAoBgB,EAA+B,IAAIhuB,KACjF,MAAM8sB,EAAY9nC,EAAII,KAAKE,KAAK0kB,cAAgBhlB,EAAI7B,IAAI,QAAQA,IAAI,QAAU6B,EAAI7B,IAAI,iBACtF,IAAK,MAAM+qB,KAAS4e,EAClB,GAAI5e,EAAM/a,aACR,IAAI,EAAIs5B,GAAqBthB,gBAAgB+C,GAAQ,CACnD,MAAM+f,EAAUh7B,GAAWib,GAC3B8f,EAAaz/B,IAAI0/B,IAChBjB,EAAmBiB,KAAa,IAAI3+B,KAAK4e,GAC1C2e,GAAqB3e,EACvB,MACEof,GAAcpf,EAAO8e,EAAoBgB,GAI/C,OAAOA,CACT,CACA,SAASD,GAA2BjB,GAClC,IAAIoB,EACJ,MAAMC,EAA+B,IAAInuB,IACzC,IAAK,MAAMouB,KAAYtB,EAAW,CAChC,MAAMxY,EAAYlI,GAAagiB,GAC/B,GAAID,EAAazhC,IAAI4nB,KAAe/gB,GAAe+gB,GACjD,OAAO,EAET,MAAM+Z,EAAmBC,GAAiBha,GAC1C,GAAI+Z,GAAoBA,KAAsBH,IAAkBG,GAC9D,OAAO,EAETF,EAAa5/B,IAAI+lB,EACnB,CACA,OAAO,CACT,CACA,SAASga,GAAiBtpC,GACxB,GAAwB,OAApBiO,GAAWjO,GAAe,OAAOA,EACrC,IAAIwxB,EAAOxxB,EAAIupC,iBACf,KAAO/X,EAAKpxB,MAAM,CAChB,GAAIoxB,EAAKrjB,cAAqC,OAArBF,GAAWujB,GAClC,OAAOA,EAETA,EAAOA,EAAK+X,gBACd,CACF,CAGA,IAAIC,GAAoB7pC,EAAQ,yCAC5B8pC,GAAuB9pC,EAAQ,+CAG/B+pC,GAAoB/pC,EAAQ,yCAC5BgqC,GAAuBhqC,EAAQ,+CAI/BiqC,IADoBjqC,EAAQ,yCACLA,EAAQ,gDAG/BkqC,GAAoBlqC,EAAQ,yCAC5BmqC,GAAuBnqC,EAAQ,+CAG/BoqC,GAAuC,IAAI/uB,IAAI,CACjD,kBACA,iBACA,4BACA,6BACA,sBACA,oBACA,qBACA,yBACA,0BACA,mBACA,SACA,aACA,oBACA,eACA,KACA,KACA,aACA,YACA,oBACA,iBACA,SACA,OACA,iBACA,gBACA,cACA,eACA,aACA,aACA,YACA,aACA,YACA,kBACA,iBACA,gBACA,iBACA,eACA,gBACA,cACA,cACA,IACA,QACA,UACA,KACA,KACA,eACA,oBACA,eACA,cACA,MACA,iBACA,QACA,eACA,IACA,MAIEgvB,GAAoBvlC,OAAO,sBAC3BwlC,GAAYxlC,OAAO,wBACnBylC,GAAYzlC,OAAO,kBACnB0lC,GAAiC,IAAIxkC,QACrCykC,GAAqB,CACvB/qC,UAAW,CACTioB,KAAAA,CAAMtnB,GAEJ,GAAgB,aADAiO,GAAWjO,IACGA,EAAII,KAAKE,KAAKA,KAAKC,OAAQ,CACvD,MAAM2qB,EAAQ,GACd,IAAK,MAAMhC,KAASlpB,EAAII,KAAKE,KAAKA,KAAM,CACtC,KAAmB,cAAf4oB,EAAM7nB,MAAuC,qBAAf6nB,EAAM7nB,MAA+B6nB,EAAMmhB,QAG3E,MAAMrqC,EAAI+jB,IAAIle,KAAKke,IAAIumB,WACrBphB,EACA,4EACA5N,aALF4P,EAAM5gB,KAAK4e,EAAMzqB,MAQrB,CACAuB,EAAII,KAAK2B,WAAWuI,KAClBu/B,GAAkBroC,MAAMG,eACtB,QACAspB,GAA0BC,IAAUqf,OAGxCvqC,EAAII,KAAKE,KAAKA,KAAO,EACvB,CACF,GAEFxB,QAAS,CACPwoB,KAAAA,CAAMtnB,IACJ,EAAI8pC,GAAqBlpC,cAAcZ,IACvC,EAAI8pC,GAAqBjpC,gBAAgBb,IACzC,EAAI8pC,GAAqB/oC,uBAAuBf,GAChD,MAAM,KAAEI,GAASJ,EACjB,GAAII,EAAKgB,MAAQyoC,GAAkBroC,MAAMqgB,aAAazhB,EAAKgB,KACzD,MAAMpB,EAAI7B,IAAI,OAAOgC,oBACnB,4DAGJ,MAAM8oC,EAAUh7B,GAAWjO,GACrB6kC,EAAO,CAAC,GACR,WAAE9iC,GAAe/B,EAAII,KAC3B,IAEIoqC,EACAC,EACAC,EAJAC,GAAuB,EACvBC,GAAmB,EAIvB,IAAK,IAAI7lC,EAAIhD,EAAWxB,OAAQwE,KAAO,CACrC,MAAM9E,EAAQ8B,EAAWgD,GACnBkhC,EAAahmC,EAAMxB,MAAMiE,QAAU,CAAC,EAC1C,GAAImnC,GAAkBroC,MAAMskC,iBAAiB7lC,GAAQ,CACnD,GAAI4kC,EAAK5kC,EAAMP,MAAO,CACpBqlC,GAAe9kC,EAAMxB,OACrB,QACF,CACAomC,EAAK5kC,EAAMP,MAAQO,EACfoP,GAAepP,EAAMP,QAwwBViiC,EAxwBmC1hC,EAAMP,KAywBzD,0CAA0CkP,KAAK+yB,KAxwB5CsE,EAAWzH,UAAW,EACtBoM,GAAmB,GACTnoC,EAASxC,EAAMxB,OAAOkE,YAChCgoC,GAAuB,EAE3B,MAAWd,GAAkBroC,MAAMtB,uBAAuBD,KACxDgmC,EAAWzH,UAAW,EACtBoM,GAAmB,EACnBD,GAAuB,GAErBF,EACFA,EAAqBngC,KAAKrK,EAAMxB,OACvBorC,GAAkBroC,MAAMtB,uBAAuBD,IACxDwqC,EAAuB,CAACxqC,EAAMxB,OAC9B+rC,EAAsBK,GAAuB5B,EAASpE,IAEtD6F,EAAiBpgC,GAAKogC,EAAgBzE,EAE1C,CAqvBN,IAAyBtE,EAnvBnB,GAmhBN,SAA2C3hC,EAAK+N,GAC9C,MAAM+8B,EAAkB,CACtB/8B,EAAOg9B,MAAQh9B,EAAOi9B,WACtBj9B,EAAOk9B,SAAWl9B,EAAOm9B,cACzBn9B,EAAOo9B,cAAgBp9B,EAAOq9B,mBAC9Br9B,EAAOyhB,aACPrkB,OAAOuH,SACT,GAAIo4B,EAAgBvqC,OAAS,EAC3B,MAAMP,EAAI7B,IAAI,QAAQgC,oBACpB,kBAAkB2qC,EAAgBh+B,KAAK7M,GAAU,IAAIA,EAAMP,UAASiuB,KAAK,gCAG/E,CAhiBM0d,CAAkCrrC,EAAK6kC,GACnCzkC,EAAKgB,KAAOwpC,GAAoBD,EAAsB,CACxD,MAAMW,EAAWlrC,EAAKsC,QAAU,CAAC,EAC3B0jB,EAAazC,GAAmB3jB,GAChC8uB,EAAcwc,EAAStB,IAAqB9H,GAChD,KAA0B,kBAAnB9hC,EAAKV,KAAK2B,KAA2BjB,EAAKV,KAAKjB,MAAQorC,GAAkBroC,MAAM+pC,aAAavrC,EAAI7B,IAAI,UAC3G,EACAioB,GAGF,IADA,EAAI0jB,GAAqB7oB,cAAc7gB,KAAKsC,MAAMmL,gBAAkB+8B,EAChEH,EAAsB,CACxB,GAAID,IAAwBA,EAAoBgB,MAAMC,MAAM/4B,SAAU,CACpE,IAAK,MAAMzS,KAASuqC,EAAoBgB,MAClCvrC,GACFwqC,EAAqBngC,KAAKrK,EAAMxB,OAGpC+rC,OAAsB,CACxB,CACAnG,GAAgBje,EAAYpmB,EAAII,KAAMqqC,EACxC,MACED,EAAsBK,GAAuB5B,EAASpE,GAYxD,GAVI2F,GACFnG,GACEje,EACAokB,EAAoBgB,MAAMhhC,KAAKkI,SAASjU,MACxC+rC,EAAoBgB,MAAM1+B,KAAKC,GAAOA,GAAItO,UAG1CmsC,GAAoBH,IACtBxrB,GAAsBmH,EAAY0I,GAEhC1uB,EAAKgB,IAAK,CACZ6d,GAAsBmH,EAAY0I,GAClC,IAAK,MAAMlO,KAAO5gB,EAAI+G,MAAMwb,WAAWniB,EAAKgB,IAAI1B,MAAM6jC,eAAgB,CACpE,MAAMmI,EAAa/nB,GAAmB/C,GACtCuiB,GAAmBviB,GACf8F,GAAqBN,EAAYslB,IACnCptB,GACEotB,EACAtlB,EACA/d,KAAkBkxB,OAEf+R,EAASpB,KAAejhC,GAAkB2X,KAC7C0qB,EAASpB,IAAa9T,GACpBhQ,EACA0I,EAAYpvB,QAIhBgjC,GACE9hB,EACAkO,EAGN,CACF,CACAvP,GACE6G,EACA0I,EACAxkB,GAAKogC,EAAgBY,GAEzB,CACF,GAEFhsC,UAAWuoB,GAAkB,CAC3BC,KAAM,CACJR,KAAAA,CAAMtnB,GACJ,MAAMipC,EAAUh7B,GAAWjO,GACrBsrC,EAAWtrC,EAAII,KAAKsC,MACpBosB,EAAcwc,EAAStB,IACvB57B,GAAS,EAAI07B,GAAqBz7B,WAAWrO,GAC7C2rC,EAASze,GAAQltB,GACjBomB,EAAajB,GAAWnlB,GAI9B,GAHIsrC,EAAS1pB,iBACX0M,GAAYtuB,GAEVA,EAAII,KAAKgB,IAAK,CAChB,MAAMwqC,EAAWN,EAASpB,IAC1BpD,GACE9mC,EACAqd,GACE,UACAuuB,GAAYvmB,GAAqBe,GACjCwlB,GAAY/B,GAAkBroC,MAAME,cAAckqC,IAGxD,CACA,MAAMC,EAAgB/c,GAAeC,GAAwBD,GAC7D6c,CAAM,IAAI3rC,EAAII,KAAKV,OACnB,MAAMosC,EAAYC,GAAa9C,EAASjpC,EAAII,OACtC,YAAE4rC,EAAW,mBAAEC,EAAkB,eAAEC,GAAmBJ,EAC5D,IASIK,GATA,iBAAEC,GAAqBN,EAC3B,GAAIG,EAAoB,CACtB,MAAM,OAAEI,EAAQb,MAAOz9B,GAAWk+B,EAClC,GAAgB,WAAZhD,GAAoC,aAAZA,EAAwB,CAClD,MAAM38B,EAASyB,EAAOjB,KAAK7M,GAAUA,GAAOxB,QAC5CktC,CAAM,GAAGtuB,GAAYgvB,EAAQhnB,GAAqBe,GAAaylB,KAAkBv/B,IACnF,CACAgsB,GAAkBlS,OAAY,EAChC,CAEA,GAAgB,WAAZ6iB,GACF,GAAIgD,EACF9B,GAAevjC,IAAI5G,EAAII,KAAM,CAC3B3B,MAAOwtC,EAAmBT,MAAM,IAAI/sC,OAAS8rC,KAC7C/a,YAAayc,EAAmBT,MAAM,IAAI/sC,OAAS8rC,YAEhD,GAAI6B,EAAkB,CAC3B,MAAME,EAAmBjlC,EAAsB,gBAC/CrH,EAAIuuB,aACFsb,GAAkBroC,MAAMuoB,oBAAoB,QAAS,CACnD8f,GAAkBroC,MAAMwoB,mBAAmBsiB,EAAkBF,MAGjEjC,GAAevjC,IAAI5G,EAAII,KAAM,CAC3B3B,MAAOorC,GAAkBroC,MAAMwb,iBAC7BsvB,EACAzC,GAAkBroC,MAAMI,WAAW,UAErC4tB,YAAaqa,GAAkBroC,MAAMwb,iBACnCsvB,EACAzC,GAAkBroC,MAAMI,WAAW,kBAGvCwqC,EAAmBE,CACrB,OACK,GAAgB,aAAZrD,EAAwB,CACjC,IAAIxqC,EACA+wB,EACJ,GAAIyc,EACFxtC,EAAQwtC,EAAmBT,MAAM,IAAI/sC,MACrC+wB,EAAcyc,EAAmBT,MAAM,IAAI/sC,WACtC,GAAI2tC,EAAkB,CAC3B,MAAME,EAAmBjlC,EAAsB,kBAC/CrH,EAAIuuB,aACFsb,GAAkBroC,MAAMuoB,oBAAoB,QAAS,CACnD8f,GAAkBroC,MAAMwoB,mBAAmBsiB,EAAkBF,MAGjE3tC,EAAQorC,GAAkBroC,MAAMwb,iBAAiBsvB,EAAkBzC,GAAkBroC,MAAMI,WAAW,UACtG4tB,EAAcqa,GAAkBroC,MAAMwb,iBACpCsvB,EACAzC,GAAkBroC,MAAMI,WAAW,gBAErCwqC,EAAmBE,CACrB,EACI7tC,GAAS+wB,KACX2c,EAAqB9uB,GACnB,8BACAgI,GAAqBF,GAAWnlB,IAChC+uB,GAAwBD,GACxBrwB,EACA+wB,GAGN,CACA,IAAK,MAAMvvB,KAAS+rC,EAAa,CAC/B,MAAQtsC,KAAMb,EAAK,MAAEJ,GAAUwB,GACzB,UAAE0C,EAAS,SAAEC,GAAanE,EAAMiE,OAAS,CAAC,EAC1C6pC,EAAkB9tC,EAAMiE,OAAO8d,mBACrC,GAAgB,WAAZyoB,GAAkC,UAAVpqC,EAI5B,OAAQA,GACN,IAAK,QACL,IAAK,QAAS,CACZ,MAAMwtC,EAAS,GAAGxtC,QACd8D,EACFgpC,CAAM,GAAG9tB,KAAiBwuB,GAAQzpC,KAElC+oC,CAAM,GAAGtuB,GAAYgvB,EAAQ5tC,KAE/B,KACF,CACA,QACMkE,EACFgpC,CAAM,GAAG9tB,KAAiB/M,KAAKjS,EAAO+D,KAC7ByM,GAAexQ,GACxBy5B,GAAkBlS,EAAYmmB,GAE9BZ,CAAM,GAAGtuB,GAAY,OAAQwsB,GAAkBroC,MAAME,cAAc7C,GAAQJ,UApB/EktC,CAAM,GAAGtuB,GAAY,kBAAmB5e,IAwB5C,CASA,GARI2tC,IACF9T,GAAkBlS,EAAYklB,EAAS9qB,oBACnC0rB,EACFP,CAAM,GAAGtuB,GAAY,eAAgB+uB,EAAkBF,EAAgBL,EAAexmB,GAAqBe,GAAapmB,EAAII,KAAKV,QAEjIisC,CAAM,GAAGtuB,GAAY,QAAS+uB,EAAkBP,EAAexmB,GAAqBe,GAAapmB,EAAII,KAAKV,SAG1G0O,GAAUA,EAAO2hB,cAAcC,YACjC,OAAQ5hB,EAAOo+B,UACb,IAAK,MACL,IAAK,OACHb,CAAM,KACN,MACF,QACEA,CAAM,SAIVA,CAAM,IAEJL,EAAS1pB,iBACX5hB,EAAIuuB,aACFsb,GAAkBroC,MAAMirC,YAAYzsC,EAAII,KAAKV,KAAMuuB,GAAYjuB,KAC/D,GAAGwE,OAEH2nC,GACFR,CAAM,GAAGQ,GAEb,EACAvkB,IAAAA,CAAK5nB,GACH,MAAMsrC,EAAWtrC,EAAII,KAAKsC,MACpBosB,EAAcwc,EAAStB,IACvBha,GAAc,EAAI8Z,GAAqBz7B,WAAWrO,IAAM+vB,cAAcC,YACtE0c,EAAavC,GAAehsC,IAAI6B,EAAII,MACpC6oC,EAAUh7B,GAAWjO,GACrBomB,EAAajB,GAAWnlB,GAC1BsrC,EAAS1pB,iBACXkH,GAAU9oB,GAER0sC,GACFxf,GAAQltB,EAAI,KAAKA,EAAII,KAAKV,QAC1BopB,GAAU9oB,GACVA,EAAIuuB,aACFsb,GAAkBroC,MAAM4L,oBACtBiQ,GACE,4BACAgI,GAAqBF,GAAWnlB,IAChC+uB,GAAwBD,GACxB4d,EAAWjuC,MACXiuC,EAAWld,YACXqa,GAAkBroC,MAAMmoB,wBACtB,GACAkgB,GAAkBroC,MAAMooB,eAAe5pB,EAAII,KAAKE,KAAKA,WAM7DN,EAAIuuB,aAAavuB,EAAII,KAAKE,KAAKA,MAAM+K,SAAS6d,GAAUA,EAAM1kB,SAEhE,MAAMmoC,EAAwB7d,IAAgBwc,EAASrB,KAAcjqB,GAA0BoG,EAAY0I,GACtGkB,GAAgB0c,GACnBxf,GACEltB,GACC2sC,IAAsC,SAAZ1D,GAAkC,SAAZA,GAClD,KAAKjpC,EAAII,KAAKV,QAEb4rC,EAAS1pB,iBACX5hB,EAAIuuB,aACFsb,GAAkBroC,MAAMirC,YAAYzsC,EAAII,KAAKV,KAAMuuB,GAAYjuB,KAC/D,GAAGwE,OAEHmoC,GACF9d,GAAS7uB,EAAK8uB,EAAa6d,GAE7B3sC,EAAIsB,QACN,GAEFymB,IAAK,CACHT,KAAAA,CAAMtnB,GACJ,MAAMipC,EAAUh7B,GAAWjO,GACrBsrC,EAAWtrC,EAAII,KAAKsC,MACpBosB,EAAcwc,EAAStB,IACvB57B,GAAS,EAAI07B,GAAqBz7B,WAAWrO,GAC7C2rC,EAASze,GAAQltB,GACjBomB,EAAajB,GAAWnlB,GAC9B,GAAIA,EAAII,KAAKgB,IAAK,CAChB,MAAMwrC,EAAU5sC,EAAII,KAAKgB,IAAI1B,KACvBunC,EAAajnC,EAAI+G,MAAMwb,WAAWqqB,GAClChB,EAAWN,EAASpB,IAC1B,IAAI2C,EACAjB,IACFiB,EAAqBxlC,EAAsB,OAAOulC,MAClD,EAAI9C,GAAqB7oB,cAAc7gB,KAAKE,KAAKgK,KAC/Cu/B,GAAkBroC,MAAMuoB,oBAAoB,QAAS,CACnD8f,GAAkBroC,MAAMwoB,mBACtB6iB,EACAxvB,GACE,UACAwsB,GAAkBroC,MAAME,cAAckqC,GACtC/B,GAAkBroC,MAAME,cACtB0G,IAAoBquB,OAAS1H,GAAwBD,GAAarwB,aAO9E,IAAK,MAAM45B,KAAa4O,EAAW1D,eAAgB,CACjD,MAAMX,EAAmBzd,GAAWkT,GAChC3R,GAAqBN,EAAYwc,KAC/B35B,GAAkBovB,GACpBA,EAAU5vB,WAAW3G,YACnB+nC,GAAkBroC,MAAM4L,oBACtBs0B,GAA0BkB,EAAkB9T,KAGvC+d,EACTxU,EAAUv2B,YACR+nC,GAAkBroC,MAAM6L,eAAew/B,EAAoB,CACzD3Z,GAAmB0P,EAAkBzd,GAAWnlB,OAIpDq4B,EAAUv2B,YACR+nC,GAAkBroC,MAAM4L,oBACtBy8B,GAAkBroC,MAAMwb,iBACtBkW,GAAmB9M,EAAYwc,GAC/BiH,GAAkBroC,MAAME,cACtB0G,IAAoBquB,OAAS1H,GAAwBD,GAAarwB,QAEpE,KAMZ,CACF,CACA,MAAMotC,EAAgB/c,GAAeC,GAAwBD,GACzD+c,GACFv+B,GAAMtN,EAAK,IAEb2rC,CAAM,IAAI3rC,EAAII,KAAKV,OACnB,MAAMosC,EAAYC,GAAa9C,EAASjpC,EAAII,OACtC,YAAE4rC,EAAW,mBAAEC,EAAkB,eAAEC,GAAmBJ,GACtD,iBAAEM,GAAqBN,EAC7B,GAAIG,EAAoB,CACtB,MAAM,OAAEI,EAAQb,MAAOz9B,GAAWk+B,EAC5Ba,EAAY/+B,EAAOvD,KAAKkI,SACxB8N,EAAqBssB,EAAUruC,MAAMiE,OAAO8d,mBAC5ClU,EAASyB,EAAOjB,KAAK7M,GAAUA,GAAOxB,QAC5Cg3B,GACE,SACArP,EACA5F,EACAqpB,GAAkBroC,MAAM4L,oBACtBiQ,GAAYgvB,EAAQpZ,GAAiB4Y,KAAkBv/B,KAG3DmpB,GACE,SACArP,OACA,EACAyjB,GAAkBroC,MAAM4L,oBACtBiQ,GAAY,GAAGgvB,WAAiBpZ,GAAiB4Y,IAGvD,CACA,IAAK,MAAM5rC,KAAS+rC,EAAa,CAC/B,MAAQtsC,KAAMb,EAAK,MAAEJ,GAAUwB,GACzB,UAAE0C,EAAS,SAAEC,GAAanE,EAAMiE,OAAS,CAAC,EAC1C6pC,EAAkB9tC,EAAMiE,OAAO8d,mBACrC,OAAQ3hB,GACN,IAAK,QACL,IAAK,QAAS,CACZ,MAAMwtC,EAAS,GAAGxtC,QAClB,GAAI8D,EACFgpC,CAAM,GAAG9tB,KAAiBwuB,GAAQzpC,SAC7B,CACL,MAAMmqC,EAAWlD,GAAkBroC,MAAMwb,iBACvCiW,GACA4Y,GACA,GAEIjE,EAAO,CACXoF,iBAAa,EACbC,kBAAc,EACdC,mBAAe,GAEjB,IAAIC,EAEJ,GADAC,GAAwB3uC,EAAOmpC,GAC3BA,EAAKqF,aACPE,EAAOtD,GAAkBroC,MAAM4L,oBAC7BiQ,GAAYgvB,EAAQU,EAAUtuC,SAMhC,GAHImpC,EAAKoF,aACPrB,CAAM,GAAG9tB,KAAiBwuB,GAAQzpC,KAEhCglC,EAAKsF,cAAe,CACtB,MAAMloC,EAAOjI,OAAOiI,KAAK4iC,EAAKsF,eAC9B,GAAoB,IAAhBloC,EAAKzE,OAAc,CACrB,MAAOtC,GAAO+G,EACR+xB,EAAS6Q,EAAKsF,cAAcjvC,GAClCkvC,EAAOtD,GAAkBroC,MAAM4L,oBAC7BiQ,GACE,GAAGxe,QACHkuC,EACAlD,GAAkBroC,MAAME,cAAczD,GAC5B,UAAVY,GAAqBkrC,GAAqBriC,IAAI7I,GAASwe,GAAY,iBAAkB0Z,GAAUA,GAGrG,KAAO,CACL,MAAMgK,EAAQ,GACd,IAAK,MAAM9iC,KAAO+G,EAAM,CACtB,MAAM+xB,EAAS6Q,EAAKsF,cAAcjvC,GAClC8iC,EAAMz2B,KACJu/B,GAAkBroC,MAAMmb,eACtBH,GAAeve,GACL,UAAVY,GAAqBkrC,GAAqBriC,IAAI7I,GAASwe,GAAY,iBAAkB0Z,GAAUA,GAGrG,CACAoW,EAAOtD,GAAkBroC,MAAM4L,oBAC7BiQ,GACE,GAAGxe,SACHkuC,EACAlD,GAAkBroC,MAAMq4B,iBAAiBkH,IAG/C,CACF,CAEEoM,GACF1X,GAAa,SAAUrP,EAAYmmB,EAAiBY,EAExD,CACA,KACF,CACA,QACMxqC,EACFgpC,CAAM,GAAG9tB,KAAiB/M,KAAKjS,EAAO+D,KAC7ByM,GAAexQ,GACxB42B,GACE,SACArP,EACAmmB,EACA1C,GAAkBroC,MAAM4L,oBACtBiQ,GACE,KACAwsB,GAAkBroC,MAAMwb,iBAAiBiW,GAAiB4Y,GAAe,GACzEhC,GAAkBroC,MAAME,cAAc4N,GAAoBzQ,IAC1DJ,KAKNg3B,GACE,SACArP,EACAmmB,EACA1C,GAAkBroC,MAAM4L,oBACtBiQ,GACE,OACAwsB,GAAkBroC,MAAMwb,iBAAiBiW,GAAiB4Y,GAAe,GACzEhC,GAAkBroC,MAAME,cAAc7C,GACtCJ,KAOd,CA0CA,GAzCI2tC,IAEA3W,GACE,SACArP,EACAklB,EAAS9qB,mBAJT0rB,EAKArC,GAAkBroC,MAAM4L,oBACtBiQ,GACE,eACA4V,GACA4Y,EACAO,EACAF,IASJrC,GAAkBroC,MAAM4L,oBACtBiQ,GACE,QACA4V,GACA4Y,EACAO,KAKR3W,GACE,SACArP,EACAklB,EAAS9qB,mBACTqpB,GAAkBroC,MAAM4L,oBACtBiQ,GAAY,cAAe4V,GAAiB4Y,KAE9C,IAGAz9B,GAAUA,EAAO2hB,cAAcC,YACjC,OAAQ5hB,EAAOo+B,UACb,IAAK,MACL,IAAK,OACHb,CAAM,KACN,MACF,QACEA,CAAM,SAIVA,CAAM,IAERvf,GAAOpsB,EACT,EACA4nB,IAAAA,CAAK5nB,GACH,MAAMgwB,GAAc,EAAI8Z,GAAqBz7B,WAAWrO,IAAM+vB,cAAcC,YAC5EhwB,EAAIuuB,aAAavuB,EAAII,KAAKE,KAAKA,MAAM+K,SAAS6d,GAAUA,EAAM1kB,SACzDwrB,GACH9C,GAAQltB,EAAI,KAAKA,EAAII,KAAKV,QAE5B2sB,GAAMrsB,GACNA,EAAIsB,QACN,MAiBN,SAASupC,GAAuB5B,EAASl7B,GACvC,OAAQk7B,GACN,IAAK,QACH,GAAIl7B,EAAOk9B,SAAWl9B,EAAOm9B,cAC3B,MAAO,CACLmC,SAAS,EACThB,OAAQ,6BACRb,MAAO,CAACz9B,EAAOk9B,QAASl9B,EAAOm9B,gBAGnC,GAAIn9B,EAAOo9B,cAAgBp9B,EAAOq9B,mBAChC,MAAO,CACLiC,SAAS,EACThB,OAAQ,kCACRb,MAAO,CAACz9B,EAAOo9B,aAAcp9B,EAAOq9B,mBAAoBr9B,EAAOtP,QAGnE,GAAIsP,EAAOtP,OAASsP,EAAOyhB,YACzB,MAAO,CACL6d,SAAS,EACThB,OAAQ,2BACRb,MAAO,CAACz9B,EAAOtP,MAAOsP,EAAOyhB,cAGjC,MACF,IAAK,SACH,GAAIzhB,EAAOtP,OAASsP,EAAOyhB,YACzB,MAAO,CACL6d,SAAS,EACThB,OAAQ,4BACRb,MAAO,CAACz9B,EAAOtP,MAAOsP,EAAOyhB,cAGjC,MACF,IAAK,WACH,GAAIzhB,EAAOtP,OAASsP,EAAOyhB,YACzB,MAAO,CACL6d,SAAS,EACThB,OAAQ,8BACRb,MAAO,CAACz9B,EAAOtP,MAAOsP,EAAOyhB,cAGjC,MACF,IAAK,UACL,IAAK,SACH,GAAIzhB,EAAOg9B,MAAQh9B,EAAOi9B,WACxB,MAAO,CACLqC,SAAS,EACThB,OAAQ,oCACRb,MAAO,CAACz9B,EAAOg9B,KAAMh9B,EAAOi9B,aAKtC,CACA,SAASe,GAAa9C,EAASjpC,GAC7B,MAAM6kC,EAAO,CAAC,GACR,WAAE9iC,GAAe/B,EACjBstC,EAAmC,IAAItyB,IAC7C,IAAIoxB,EACAF,EACAqB,EACAC,EACAvB,EACJ,IAAK,IAAIlnC,EAAIhD,EAAWxB,OAAQwE,KAAO,CACrC,MAAM9E,EAAQ8B,EAAWgD,IACnB,MAAEtG,GAAUwB,EAClB,GAAI4pC,GAAkBroC,MAAMtB,uBAAuBD,GAAQ,CACzD,IAAKstC,IACHA,EAAc,GACdtB,EAAqBpB,GAAuB5B,EAASpE,GACjDoH,IAAuBA,EAAmBT,MAAMC,MAAM/4B,UAAU,CAClE,IAAK,MAAM+6B,KAASxB,EAAmBT,MACjCiC,IACFF,EAAYjjC,KAAKoS,GAAiB+wB,EAAM/tC,KAAM+tC,EAAMhvC,QACpD6uC,EAAiBvuB,OAAO0uB,IAG5BxB,OAAqB,CACvB,CAEFsB,EAAYjjC,KAAKu/B,GAAkBroC,MAAMksC,cAAcjvC,GACzD,MAAYomC,EAAK5kC,EAAMP,QACrBmlC,EAAK5kC,EAAMP,MAAQO,EACfstC,EACFA,EAAYjjC,KAAKoS,GAAiBzc,EAAMP,KAAMO,EAAMxB,QAEpD6uC,EAAiB/jC,IAAItJ,GAG3B,CAOA,GANKstC,IACHtB,EAAqBpB,GAAuB5B,EAASpE,IACjB,IAAhCoH,GAAoBoB,SAAsBpB,EAAmBT,MAAM,KACrES,OAAqB,IAGrBA,EACF,IAAK,MAAMhsC,KAASgsC,EAAmBT,MACjCvrC,GACFqtC,EAAiBvuB,OAAO9e,GAI9B,MAAM+rC,EAAc,IAAIsB,GAAkBK,UAC1C,GAAIJ,EAAa,CAEf,GADAA,EAAYI,UACR1B,EACF,IAAK,MAAMhsC,KAASgsC,EAAmBT,MACjCvrC,IACDutC,IAAc,IAAIljC,KACjBoS,GAAiBzc,EAAMP,KAAMmqC,GAAkBroC,MAAMib,eAAe,KAK5E,IAAK,MAAQ/c,KAAMb,KAAWmtC,GAC3BwB,IAAc,IAAIljC,KAAKoS,GAAiB7d,EAAOgrC,GAAkBroC,MAAMib,eAAe,KAErF+wB,IACFtB,EAAiBrC,GAAkBroC,MAAMq4B,iBAAiB2T,IAE5DpB,EAAmBwB,GAAkBL,EACvC,CACA,MAAO,CACLvB,cACAC,qBACAG,mBACAF,iBAEJ,CACA,SAASkB,GAAwBpqC,EAAM4kC,GACrC,OAAQ5kC,EAAK3B,MACX,IAAK,mBACHwsC,GAAmC7qC,EAAM4kC,GACzC,MACF,IAAK,kBACHkG,GAA6B9qC,EAAM4kC,GACnC,MACF,SACGA,EAAKqF,eAAiB,IAAI3iC,KAAKtH,GAGtC,CACA,SAAS8qC,GAA6BjiB,EAAK+b,GACzC,IAAK,MAAMviC,KAAQwmB,EAAI7nB,SACrB,GAAIqB,EACF,OAAQA,EAAKhE,MACX,IAAK,kBACHysC,GAA6BzoC,EAAMuiC,GACnC,MAEF,IAAK,mBACHiG,GAAmCxoC,EAAMuiC,GACzC,MAEF,IAAK,gBACwB,oBAAvBviC,EAAKjC,SAAS/B,KAChBysC,GAA6BzoC,EAAKjC,SAAUwkC,IAE3CA,EAAKqF,eAAiB,IAAI3iC,KAAKjF,GAElC,MACF,QAAS,CACP,MAAM0oC,EAAWtrC,EAAS4C,GACtB0oC,EAASprC,WACVilC,EAAKoF,cAAgB,IAAI1iC,KAAKyjC,EAASnrC,WAEvCglC,EAAKqF,eAAiB,IAAI3iC,KAAKjF,GAElC,KACF,EAIR,CACA,SAASwoC,GAAmCG,EAAKpG,GAC/C,IAAIqG,EACAC,EACJ,IAAK,MAAMrqC,KAAQmqC,EAAIlqC,WAAY,CACjC,GAAkB,mBAAdD,EAAKxC,MAA6BwC,EAAKjB,SAAU,EAClDsrC,IAAiB,IAAI5jC,KAAKzG,GAC3B,QACF,CACA,IAAI5F,EACJ,GAAsB,eAAlB4F,EAAK5F,IAAIoD,KACXpD,EAAM4F,EAAK5F,IAAIyB,SACV,CACL,MAAMyuC,EAAU1rC,EAASoB,EAAK5F,KAC9B,IAAIkwC,EAAQxrC,UAEL,EACJurC,IAAiB,IAAI5jC,KAAKzG,GAC3B,QACF,CAJE5F,EAAMkwC,EAAQvrC,SAAW,EAK7B,CACA,MAAMnE,EAAQoF,EAAKpF,MACb2vC,EAAW3rC,EAAShE,GACtB2vC,EAASzrC,WACVsrC,IAAgB,CAAC,GAAGhwC,GAAOmwC,EAASxrC,UAEpCglC,EAAKsF,gBAAkB,CAAC,GAAGjvC,GAAOQ,CAEvC,CACIwvC,IACDrG,EAAKoF,cAAgB,IAAI1iC,KAAK2jC,GAE7BC,IACDtG,EAAKqF,eAAiB,IAAI3iC,KAAKu/B,GAAkBroC,MAAMq4B,iBAAiBqU,GAE7E,CAIA,SAAS3D,KACP,OAAOV,GAAkBroC,MAAMkc,gBAAgB,OAAQmsB,GAAkBroC,MAAMib,eAAe,GAChG,CAGA,IAAI4xB,GAAqB5pC,OAAO,wBAC5B6pC,GAAW7pC,OAAO,iCACtB,SAAS8pC,GAAoBvuC,EAAKwuC,EAAa,GAC7C,MAAM9rC,EAAQ1C,EAAII,KAAKsC,MACvB,QAAkC,IAA9BA,EAAM2rC,IACR,OAAO3rC,EAAM2rC,IAEf,MAAM/e,EAAYlI,GAAapnB,GAC/B,OAAIsvB,IAAa,EAAIsa,GAAqBv7B,WAAWihB,IAAYxH,KACxDplB,EAAM2rC,IAAsBruC,EAAIwF,OAAOlF,KAAKC,SAAWiuC,EAEzD9rC,EAAM2rC,KAAsB,CACrC,CACA,SAASI,GAAiCzuC,EAAK2e,EAAS6vB,EAAa,GACnE,GAAID,GAAoBvuC,EAAKwuC,GAAa,CACxC,MAAMlf,EAAYlI,GAAapnB,GAAKI,KAC9BsuC,EAAgBpf,EAAU5vB,MAAMjB,MACtC,OAAQ6wB,EAAU5sB,QAAU,CAAC,GAAGsnC,MAAuB9H,GACrD,IAAMwM,EACN,EACA/vB,EAEJ,CACE,OAAQ3e,EAAII,KAAKsC,QAAU,CAAC,GAAG4rC,MAAcpM,GAC3C,QACA,EACAvjB,EAGN,CAGA,IAAIgwB,GAAc,CAChB7vC,OAAAA,CAAQkB,GACN,MAAM4uC,EAAY5uC,EAAII,KAAKE,KAAK0kB,cAChC,IAAI6pB,EAIJ,QAHA,EAAIlF,GAAqBva,aAAapvB,IACtC,EAAI2pC,GAAqB/oC,cAAcZ,GACvCD,EAAoBC,GACZ8uC,GAAW9uC,EAAII,OACrB,IAAK,KACHyuC,EAAa,CAAC,MACd,MACF,IAAK,KACHA,EAAa,CAAC,MACd,MACF,IAAK,KACHA,EAAa,CAAC,KAAM,OAAQ,QAC5B,MACF,QACE,MAAM7uC,EAAIG,oBACR,gEAON,GAJKyuC,GACHC,EAAWvkC,KAAK,OAElB,EAAIq/B,GAAqBta,yBAAyBrvB,EAAK6uC,GACnDD,EAAW,OACf,MAAMhJ,EAAU5lC,EAAI7B,IAAI,QAClB6nC,EAAcviB,GAAamiB,GACjC,IAAKI,EAEH,YADAjB,GAAeE,GAAwBjlC,EAAII,OAG7C,MAAMgmB,EAAazC,GAAmB3jB,GAChC8uB,EAAc2f,GAAiCzuC,EAAKomB,GACpDqc,EAAgB9E,GAAsBiI,EAAS,GAC/C0F,EAAWjH,GACfje,EACApmB,EAAII,KACJ6kC,GAAwBjlC,EAAII,OAE1BqiC,GACF+B,GAAoB/B,EAAe6I,GAErCtF,EAAY7hB,gBAAkB,CAC5BnY,QAAS8iB,EACTkM,OAAQ5yB,IAAoB2mC,cAE9B/I,EAAYphB,mBAAqB0mB,EACjCtF,EAAYjhB,UAAW,CACzB,EACAzlB,UAAWuoB,GAAkB,CAC3BC,KAAM,CACJR,KAAAA,CAAMtnB,GACJ,GAAIA,EAAII,KAAKE,KAAK0kB,cAAe,OACjC,MACMghB,EAAc9gB,GADJllB,EAAI7B,IAAI,SAEnB6nC,GAILzgB,GAAwBygB,GAAa,GAChCuI,GAAoBvuC,KACvBsN,GAAMtN,EAAK,IACXssB,GAAatsB,IAEfsuB,GAAYtuB,IARVA,EAAIsB,QASR,EACAsmB,IAAAA,CAAK5nB,GACH,GAAIA,EAAII,KAAKE,KAAK0kB,cAAe,OACjC,MAAM4gB,EAAU5lC,EAAI7B,IAAI,QAClBioB,EAAajB,GAAWnlB,GACxBgmC,EAAc9gB,GAAkB0gB,IAChC,KAAExlC,GAASJ,EACXgvC,EAAgCT,GAAoBvuC,GACpD8uB,EAAc2f,GAAiCzuC,EAAKomB,GACpD6oB,EAAWnhC,GAAmB1N,GAC9B8uC,EAAUJ,GAAW1uC,GACrBgkB,EAAShkB,EAAKE,KAAK8jB,OACnByR,EAAa,GACbsZ,EAAiB/uC,EAAKE,KAAKA,KAC3B8uC,EAAiD,OAAxBpJ,EAAYthB,SAAoBshB,EAAYthB,QAAQoB,aAAiD,IAAlCkgB,EAAYthB,QAAQkB,UAChHypB,EAAwBtvB,GAC5BimB,EACA3G,IAEIsN,EAAwB3sB,GAC5BoG,EACA0I,GAEFhG,GAAU9oB,GACV+oB,GAA0B6c,GAC1B,MAAM0J,EAAaC,GAAoBL,EAASD,GAC1CO,EAAoBH,EAgMlC,SAAoChuC,EAAM+tC,GACxC,GAAIA,EACF,OAAQ/tC,GACN,IAAK,KACH,MAAO,wBACT,IAAK,KACH,MAAO,wBACT,IAAK,KACH,MAAO,6BAGX,OAAQA,GACN,IAAK,KACH,MAAO,cACT,IAAK,KACH,MAAO,cACT,IAAK,KACH,MAAO,cAGf,CApN0DouC,CAA2BP,EAASE,GAA0BM,GAAiBR,GACjII,EAAWhlC,KACTo/B,GAAkBloC,MAAMmoB,wBAAwBvF,EAAQslB,GAAkBloC,MAAMooB,eAAeulB,KAE7FE,IACE1C,GAAyBqC,IAC3B5nB,GAAapnB,GAAKI,KAAKsC,MAAMunC,KAAa,GAE5CqF,EAAWhlC,KACT2kC,EAASU,IAAMjG,GAAkBloC,MAAMib,eAAe,GACtD4I,GAAqBe,GACrB2I,GAAwBD,IACE,IAA1BugB,GAA2D,IAA1B1C,GAAmCqC,EAAyCtF,GAAkBloC,MAAMib,eAAe,QAAhD,EAAqDmM,GAAkBymB,GAC1K1C,GAA8F,IAA1BA,EAAiCqC,EAAgCtF,GAAkBloC,MAAMib,eAAe,QAAK,EAASmM,GAAkB+jB,GAApLjD,GAAkBloC,MAAMib,eAAe,IAE9DuyB,GACFM,EAAWhlC,KAAKo/B,GAAkBloC,MAAMib,eAAe,KAG3DoZ,EAAWvrB,KACTo/B,GAAkBloC,MAAM4L,oBAAoBiQ,GAAYmyB,KAAsBF,KAEhF,IAAK,MAAMpqC,KAAelF,EAAIupB,oBAAoBsM,GAChD3wB,EAAYV,MAEhB,GAEFujB,IAAK,CACHT,KAAAA,CAAMtnB,GACJ,GAAIA,EAAII,KAAKE,KAAK0kB,cAAe,OACjC,MACMghB,EAAc9gB,GADJllB,EAAI7B,IAAI,SAEnB6nC,GAILzgB,GAAwBygB,GAAa,GAChCuI,GAAoBvuC,KACvBsN,GAAMtN,EAAK,IACXssB,GAAatsB,KANbA,EAAIsB,QAQR,EACAsmB,IAAAA,CAAK5nB,GACH,GAAIA,EAAII,KAAKE,KAAK0kB,cAAe,OACjC,MAAM4gB,EAAU5lC,EAAI7B,IAAI,QAClBioB,EAAajB,GAAWnlB,GACxBgmC,EAAc9gB,GAAkB0gB,IAChC,KAAExlC,GAASJ,EACXsrC,EAAWlrC,EAAKsC,OAChB,mBAAE8d,GAAuB8qB,EACzBpF,EAAWuI,GAAiCzuC,EAAKomB,GACvD2K,GAAwB/wB,GAAK,CAACwmB,EAASgM,IAC9BnV,GACL,cACA0R,GAAwBvI,GACxBuI,GAAwBmX,GACxB1T,KAGJ,MAAM0c,EAAUJ,GAAW1uC,GACrB+xB,EAASH,GAAU5L,EAAY8f,EAAU,OAC/C/T,EAAOzlB,MAAQ,IACN2Q,GAuJjB,SAA6Bhc,GAC3B,OAAQA,GACN,IAAK,KACH,MAAO,SACT,IAAK,KACH,MAAO,SACT,IAAK,KACH,MAAO,SAEb,CA/JYuuC,CAAoBV,GACpBngB,GAAwBmX,GACxBwD,GAAkBloC,MAAMI,WAAWokC,EAAYtmC,OAGnD,MAAM0kB,EAAShkB,EAAKE,KAAK8jB,OACzB+N,EAAOrC,2BAA6B,KAClC,IAAK,MAAM6E,KAASvQ,EAAQ,CAC1B,MAAMpY,EAAU2oB,EAAMjyB,OAAOsJ,QAC7B,GAAIA,EACF,IAAK,MACHwU,mBAAoBqvB,KACjB7jC,EAAQC,sBACX,GAAI+lB,GACFgU,EACA6J,GACA/f,6BACA,OAAO,CAIf,CACA,OAAO,CAAK,EAEd,MAAMmf,EAAWnhC,GAAmB1N,GAC9B0vC,EAAWP,GAAoBL,EAASD,GAC1CA,EAASU,IACXG,EAASxlC,KAAK2kC,EAASU,IAEzB9f,GACEzJ,EACA5F,EACA2R,EACAuX,GAAkBloC,MAAM44B,gBAAgB0V,IAE1C9vC,EAAIsB,QACN,KAGJyuB,aAAc,CAAEggB,aAAa,GAC7BhuC,WAAY,CACVwP,GAAI,CACFlQ,KAAM,aACNW,aAAc,CACZ,CACEE,YAAa,oCAInB8tC,GAAI,CACF3uC,KAAM,aACNW,aAAc,CACZ,CACEE,YAAa,qDAInBrE,GAAI,CACFwD,KAAM,SACNW,aAAc,CACZ,CACEE,YAAa,oDAInBpE,KAAM,CACJuD,KAAM,SACNW,aAAc,CACZ,CACEE,YAAa,4DAInB2qB,KAAM,CACJxrB,KAAM,SACNW,aAAc,CACZ,CACEE,YAAa,oEAKrBF,aAAc,CACZ,CACEG,QAAS,uCACTD,YAAa,mEACb+tB,mBAAoB,6DAEtB,CACE9tB,QAAS,uCACT8tB,mBAAoB,4EAEtB,CACE9tB,QAAS,iCACT8tB,mBAAoB,8EAa1B,SAAS6e,GAAW9uC,GAClB,IAAK,MAAMC,KAASD,EAAI+B,WACtB,GAAmB,mBAAf9B,EAAMoB,KACR,OAAQpB,EAAMP,MACZ,IAAK,KACL,IAAK,KACL,IAAK,KACH,OAAOO,EAAMP,KAIvB,CACA,SAASgwC,GAAiBruC,GACxB,OAAQA,GACN,IAAK,KACH,MAAO,QACT,IAAK,KACH,MAAO,QACT,IAAK,KACH,MAAO,QAEb,CAgCA,SAASkuC,GAAoBluC,EAAM0M,GACjC,OAAQ1M,GACN,IAAK,KACH,MAAO,CAAC0M,EAAOiiC,IACjB,IAAK,KACH,MAAO,CAACjiC,EAAOwD,IACjB,IAAK,KACH,MAAO,CACLxD,EAAOlQ,GACPkQ,EAAOjQ,MAAQ4rC,GAAkBloC,MAAMib,eAAe,GACtD1O,EAAO8e,MAAQ6c,GAAkBloC,MAAMib,eAAe,IAG9D,CAGA,IAAIwzB,GAA+B,IAAIp0B,QACvC,SAASq0B,GAAelwC,EAAKmwC,EAAiBta,EAAa,GAAIua,EAAa,WAC1E,MAAMvL,EAAuB,IAAI7pB,IAC3BlX,EAAa,GACbusC,EAAgBrwC,EAAII,KAAKsC,OAAOsiB,cACtC,GAAIqrB,EAAe,CACjB,IAAK,MAAMxxC,KAASwxC,EAAe,CACjC,MAAM7H,EAAc6H,EAAcxxC,GAC9ByxC,GAAWH,EAAiB3H,EAAY9oC,QAC1CmlC,EAAKt7B,IAAIi/B,EAAY9oC,MACjB8oC,EAAYC,UACd5S,EAAWvrB,KACTk/B,GAAkBhoC,MAAMuoB,oBAAoB,MAAO,CACjDyf,GAAkBhoC,MAAMwoB,mBAAmB2d,GAAqBa,OAGpE1kC,EAAWwG,KACToS,GACE8rB,EAAY9oC,KACZioC,GAAqBa,MAK/B,CACA,MAAMV,EAAY9nC,EAAII,KAAKE,KAAK0kB,cAAgBhlB,EAAI7B,IAAI,QAAQA,IAAI,QAAU6B,EAAI7B,IAAI,iBACtF,IAAK,IAAI4G,EAAI,EAAGA,EAAI+iC,EAAUvnC,OAAQwE,IAAK,CACzC,MAAMmkB,EAAQ4e,EAAU/iC,GACxB,GAAImkB,EAAM/a,aACR,IAAI,EAAIs7B,GAAqBtjB,gBAAgB+C,GAAQ,CACnD,MAAMsf,EAAc6H,EAAcpiC,GAAWib,IAC7C,GAAIsf,EAAYC,QACd1jC,EAAIwrC,GACFzI,EACA/iC,EACAsrC,EACAxa,EACAsa,EACAC,OAEG,CACL,MAAMI,EAAoBN,GACxBhnB,EACAinB,IAAkB3H,EAAY9oC,OAAOqhC,MACrClL,EACAua,GAEF,GAAI5H,EAAYE,SAAU,CACxB,MAAM+H,EAAWC,GAAmBlI,EAAY9oC,KAAMoE,GAClD2sC,EACFA,EAAShyC,MAAQ4e,GACf,WACAozB,EAAShyC,MACTmvC,GAAkB4C,EAAkB1sC,aAGtCA,EAAWwG,KACToS,GACE8rB,EAAY9oC,KACZ2d,GACE,UACAuwB,GAAkB4C,EAAkB1sC,cAK9C,MACEA,EAAWwG,KACToS,GACE8rB,EAAY9oC,KACZ2d,GACE,UACAuwB,GAAkB4C,EAAkB1sC,cAK9C,CACF,MACEiB,EAAIwrC,GACFzI,EACA/iC,EACAsrC,EACAxa,EACAsa,EACAC,EAIR,CACF,CACA,IAAKvL,EAAKn9B,IAAI0oC,IAAeE,GAAWH,EAAiBC,GAAa,CACpEvL,EAAKt7B,IAAI6mC,GACT,MAAMO,EAkNV,SAAsBrwC,GACpB,MAAM0lC,EAAc1lC,EAAKF,KAAKsC,OAAOic,QACrC,GAAIqnB,EAAa,CACf,GAAIl+B,IAAgB,CAClB,MAAM8oC,EAAavqB,GAAoB2f,GACvC,OAAO3oB,GACLuzB,EAAa,kBAAoB,gBACjCpH,GAAkBhoC,MAAME,cAAcu0B,GAAoB+P,EAAa,aACvEwD,GAAkBhoC,MAAMmoB,wBACtBrpB,EAAKF,KAAKgkB,OACVolB,GAAkBhoC,MAAMooB,eAAetpB,EAAKF,KAAKE,OAEnDswC,EAAavrB,GACXF,GAcV,SAAkCnlB,GAChC,IAAIwL,EAAMxL,EACV,MAAO,EAAIypC,GAAqBtjB,gBAAgB3a,KAAQ,EAAIi+B,GAAqBoH,kBAAkBrlC,IACjGA,EAAM4b,GAAa5b,GAErB,OAAOA,CACT,CAnBYslC,CACExwC,EAAKmI,mBAGP,EAER,CACE,OAAO+gC,GAAkBhoC,MAAM6L,eAAem8B,GAAkBhoC,MAAMI,WAAWokC,EAAYtmC,MAAO,CAClGuzB,IAGN,CACF,CA5O8B8d,CAAa/wC,EAAI7B,IAAI,SAC/C,GAAIwyC,EAAmB,CACrB,MAAMK,EAAcxH,GAAkBhoC,MAAMmb,eAC1C6sB,GAAkBhoC,MAAMI,WAAWwuC,GACnCO,GAEFV,GAAa1mC,IAAIynC,GACjBltC,EAAWwG,KAAK0mC,EAClB,CACF,CACA,MAAM,WAAEjvC,GAAe/B,EAAII,KAC3B,IAAK,IAAI2E,EAAIhD,EAAWxB,OAAQwE,KAAO,CACrC,MAAM9E,EAAQ8B,EAAWgD,IACnB,MAAEtG,GAAUwB,EACdupC,GAAkBhoC,MAAMtB,uBAAuBD,GACjD6D,EAAWwG,KAAKk/B,GAAkBhoC,MAAMksC,cAAcjvC,KAC5ComC,EAAKn9B,IAAIzH,EAAMP,OAAS4wC,GAAWH,EAAiBlwC,EAAMP,QACpEmlC,EAAKt7B,IAAItJ,EAAMP,MACfoE,EAAWwG,KAAKoS,GAAiBzc,EAAMP,KAAMjB,IAEjD,CAEA,OADAqF,EAAW6pC,UACJ,CAAE7pC,aAAY+xB,aACvB,CACA,SAASob,GAAiClQ,GACxC,IAAK,MAAMl9B,KAAQk9B,EACjB,GAAIkP,GAAavoC,IAAI7D,GACnB,OAAOA,CAGb,CACA,SAAS0sC,GAA4BzI,EAAWhU,EAAOuc,EAAexa,EAAYsa,EAAiBC,EAAa,WAC9G,MAAMpwC,EAAM8nC,EAAUhU,GACtB,GAAI9zB,EAAImO,aACN,IAAI,EAAIs7B,GAAqBtjB,gBAAgBnmB,GAAM,CACjD,MAAMwoC,EAAc6H,EAAcpiC,GAAWjO,IAC7C,GAAIswC,GAAWH,EAAiB3H,EAAY9oC,OAAS8oC,EAAYC,QAAS,CACxE,MAAM+H,EAAoBN,GACxBlwC,EACAmwC,IAAkB3H,EAAY9oC,OAAOqhC,MACrClL,EACAua,GAEE5H,EAAYE,SACd7S,EAAWvrB,KACTk/B,GAAkBhoC,MAAM4L,oBACtBo8B,GAAkBhoC,MAAM25B,qBACtB,IACAwM,GAAqBa,GACrBnrB,GACE,WACAsqB,GAAqBa,GACrBoF,GAAkB4C,EAAkB1sC,gBAM5C+xB,EAAWvrB,KACTk/B,GAAkBhoC,MAAM4L,oBACtBo8B,GAAkBhoC,MAAM25B,qBACtB,IACAwM,GAAqBa,GACrBnrB,GACE,UACAuwB,GAAkB4C,EAAkB1sC,eAMhD,CACF,MACE,OAAQmK,GAAWjO,IACjB,IAAK,KACH,OA8CV,SAA4B8nC,EAAWhU,EAAOuc,EAAexa,EAAYsa,EAAiBC,GACxF,MAAMc,EAAQpJ,EAAUhU,GAClBqd,EAAuB,GAC7B,IAAI1E,EAAcjD,GAAkBhoC,MAAMirC,YACxC2E,GAAsBF,GACtB1H,GAAkBhoC,MAAMooB,eAAeunB,IAEzCtb,EAAWvrB,KAAKmiC,GAChB4E,GACEH,EACAb,EACAc,EACAhB,EACAC,GAEF,IAAI/kB,EAAYyI,EAAQ,EACxB,KAAOzI,EAAYyc,EAAUvnC,QAAQ,CACnC,MAAM+wC,EAAUxJ,EAAUzc,GAC1B,GAAIimB,EAAQnjC,aACV,OAAQF,GAAWqjC,IACjB,IAAK,UACL,IAAK,OAAQ,CACX,MAAMC,EAAYH,GAAsBE,GAClCE,EAAsB,GAQ5B,GAPAH,GACEC,EACAjB,EACAmB,EACArB,EACAC,GAEEmB,EAAW,CACb9E,EAAYnpC,UAAYmpC,EAAcjD,GAAkBhoC,MAAMirC,YAC5D8E,EACA/H,GAAkBhoC,MAAMooB,eAAe4nB,IAEzCnmB,IACA,QACF,CACEohB,EAAYnpC,UAAYkmC,GAAkBhoC,MAAMooB,eAAe4nB,GAC/D,KAEJ,EAGJ,KACF,CACA,OAAOnmB,EAAY,CACrB,CA9FiBomB,CACL3J,EACAhU,EACAuc,EACAxa,EACAsa,EACAC,GAEJ,IAAK,MACH,OAiBV,SAA6BtI,EAAWhU,EAAOuc,EAAexa,EAAYsa,EAAiBC,GACzF,MAAMsB,EAAS5J,EAAUhU,GACnBqb,EAAiB,GAgBvB,OAfAkC,GACEK,EACArB,EACAlB,EACAgB,EACAC,GAEFva,EAAWvrB,KA1Rb,SAA6BjJ,EAAM0M,EAAQqW,EAAQyR,GACjD,OAAO6T,GAAkBloC,MAAM4L,oBAC7BiQ,GACEqyB,GAAiBruC,MACdkuC,GAAoBluC,EAAM0M,GAC7B27B,GAAkBloC,MAAMmoB,wBAAwBvF,EAAQslB,GAAkBloC,MAAMooB,eAAeiM,KAGrG,CAmRI8b,CACE7C,GAAW4C,EAAOtxC,MAClB0N,GAAmB4jC,EAAOtxC,MAC1BsxC,EAAOtxC,KAAKE,KAAK8jB,OACjB+qB,IAGGrb,CACT,CApCiB8d,CACL9J,EACAhU,EACAuc,EACAxa,EACAsa,EACAC,GAMV,OAAOtc,CACT,CACA,SAAS8Z,GAAkB7M,GACzB,OAAwB,IAAjBA,EAAMxgC,QAAgBipC,GAAkBhoC,MAAMukC,gBAAgBhF,EAAM,IAAMA,EAAM,GAAG39B,SAAWomC,GAAkBhoC,MAAMq4B,iBAAiBkH,EAChJ,CAsEA,SAASsQ,GAAwBrxC,EAAKqwC,EAAexa,EAAYsa,EAAiBC,GAChF,MAAMtI,EAAY9nC,EAAII,KAAKE,KAAK0kB,cAAgBhlB,EAAI7B,IAAI,QAAQA,IAAI,QAAU6B,EAAI7B,IAAI,iBACtF,IAAK,IAAI4G,EAAI,EAAGA,EAAI+iC,EAAUvnC,OAAQwE,IACpCA,EAAIwrC,GACFzI,EACA/iC,EACAsrC,EACAxa,EACAsa,EACAC,EAGN,CACA,SAASE,GAAWH,EAAiBtxC,GACnC,OAAQsxC,KAAqBA,EAAgBtxC,EAC/C,CACA,SAAS6xC,GAAmB7xC,EAAOkiC,GACjC,IAAK,MAAMl9B,KAAQk9B,EACjB,GAAkB,mBAAdl9B,EAAKxC,KACP,OAAQwC,EAAK5F,IAAIoD,MACf,IAAK,gBACH,GAAIwC,EAAK5F,IAAIQ,QAAUI,EACrB,OAAOgF,EAET,MACF,IAAK,aACH,GAAIA,EAAK5F,IAAIyB,OAASb,EACpB,OAAOgF,EAMjB,OAAO,CACT,CACA,SAASutC,IACPhxC,MAAM,WAAE2B,KAER,OAA6B,IAAtBA,EAAWxB,OAAewB,EAAW,GAAGtD,WAAQ,CACzD,CAqCA,IAAIozC,GAAiB,CACnB/yC,OAAAA,CAAQkB,GAEN,IADA,EAAIunC,GAAqB3mC,cAAcZ,IAClCA,EAAII,KAAKgB,IACZ,MAAMpB,EAAI7B,IAAI,QAAQgC,oBAAoB,6CAE5C,MAAMylC,EAAU5lC,EAAI7B,IAAI,QAClB6nC,EAAcviB,GAAamiB,GAC3BqB,EAAa5E,GAAmBriC,EAAK,GACvCgmC,GACEiB,IACFjB,EAAYnhB,kBAAoBoiB,EAAW56B,gBAAgBlO,IAAI,YAAc8oC,GAGjFtJ,GAAsBiI,EAAS,GAC/BiC,GAAqB7nC,GACrB,MAAMsrC,EAAWjH,GACf1gB,GAAmB3jB,GACnBA,EAAII,KACJ6kC,GAAwBjlC,EAAII,OAE1B6mC,GACFzC,GAAoByC,EAAYqE,EAEpC,EACAhsC,UAAW,CACTgoB,KAAAA,CAAMtnB,GACA8H,KACFwmB,GAAYtuB,EAEhB,EACA4nB,IAAAA,CAAK5nB,GACH,MAAM,KAAEI,GAASJ,EACX8xC,EAAkB5B,GAAelwC,GACvC,GAAI8H,IACFghB,GAAU9oB,GACV+oB,GAA0B/oB,EAAI7B,IAAI,SAClC6B,EAAIuuB,aAAaujB,EAAgBjc,YACjCiR,GAAa9mC,EAAK4tC,GAAkBkE,EAAgBhuC,iBAC/C,CACL,MAAM6a,EAAUwG,GAAWnlB,GACrBwgB,EAAqBpgB,EAAKsC,OAAO8d,mBACjC0mB,EAAa/T,GAAUnzB,EAAI7B,IAAI,OAAOiC,KAAKsC,MAAMsJ,SACnD8lC,EAAgBjc,WAAWt1B,QAC7Bk1B,GACE,SACA9W,EACA6B,EACAsxB,EAAgBjc,YAGpBhG,GACElR,EACA6B,EACA0mB,EACA0G,GAAkBkE,EAAgBhuC,YAEtC,CACA9D,EAAIsB,QACN,GAEFS,WAAY,CAAC,EACbC,aAAc,CACZ,CACEE,YAAa,gEACb+tB,mBAAoB,+CAGxBzuB,MAAO/B,EAAqBC,KAAO,6BAIjCqyC,GAAoBpyC,EAAQ,yCAC5BqyC,GAAuBryC,EAAQ,+CAC/BsyC,GAAiB,CACnBtxC,QAAS,CACNX,KACC,EAAIgyC,GAAqBpxC,cAAcZ,IACvC,EAAIgyC,GAAqBnxC,gBAAgBb,GACzCK,EAAoBL,IACpB,EAAIgyC,GAAqBjxC,uBAAuBf,GAChDD,EAAoBC,IACpB,EAAIgyC,GAAqB3iB,yBAAyBrvB,EAAK,CAAC,WACxD,EAAIgyC,GAAqBhxC,qBAAqBhB,EAAK,CACjDiB,MAAO,0DACPC,GAAAA,GACE,MAAM,KAAEd,GAASJ,EACjBA,EAAI8B,YACFiwC,GAAkBvwC,MAAMC,SACtBmgC,GAAqBmQ,GAAkBvwC,MAAME,cAAc,UAAWtB,EAAKV,MAC3EU,EAAK2B,WACL3B,EAAKE,KACLF,EAAKs0B,UACLt0B,EAAKgB,IACLhB,EAAK4kB,eAGX,GACA,GAGNjjB,WAAY,CAAC,EACbP,MAAO/B,EAAqBC,KAAO,6BAIjCwyC,GAAuBvyC,EAAQ,+CAC/BwyC,GAAiB,CACnBj+B,KAAAA,CAAMlU,GACJ,MAAM,KAAEI,GAASJ,EACjBA,EAAI8B,aACF,EAAIowC,GAAqB1L,iBAAiBxmC,EAAI+jB,IAAIle,KAAMzF,EAAKkmC,SAAUlmC,EAAKoQ,MAAOpQ,EAAK2zB,KAAK,GAEjG,EACAhE,aAAc,CACZ4F,WAAW,EACX+Q,YAAY,GAEd1kC,aAAc,CACZ,CACEC,YAAa,oBAMfmwC,GAAoBzyC,EAAQ,yCAC5B0yC,GAAuB1yC,EAAQ,+CAC/B2yC,GAAe7tC,OAAO,uBACtB8tC,GAAa9tC,OAAO,kBACpB+tC,GAAuB,CACzB1zC,OAAAA,CAAQkB,IACN,EAAIqyC,GAAqBzxC,cAAcZ,IACvC,EAAIqyC,GAAqBxxC,gBAAgBb,IACzC,EAAIqyC,GAAqBvxC,oBAAoBd,GAC7C,MAAMmB,EAASnB,EAAII,KAAKgB,IACxB,IAAIqxC,GAAe,EACfC,GAAc,EAClB,GAAIvxC,EAAQ,CACV,IAAKixC,GAAkB5wC,MAAMqgB,aAAa1gB,GACxC,MAAMnB,EAAI7B,IAAI,OAAOgC,oBACnB,2DAGJsyC,GAAe,EACf,IAAK,MAAM7xB,KAAO5gB,EAAI+G,MAAMwb,WAAWphB,EAAOzB,MAAM6jC,eAClD,IAAKt6B,GAAkB2X,GAAM,CAC3B8xB,GAAc,EACd,KACF,CAEJ,CACA,MAAMxN,EAAiB,GACvB,IAAK,MAAMhc,KAASlpB,EAAI7B,IAAI,QAAQA,IAAI,QACtC,GAAI+qB,EAAMypB,qBACRzN,EAAe56B,KAAK4e,EAAM9oB,KAAK3B,OAC/Bg0C,GAAe,OACV,IAAKvpB,EAAM0pB,cAChB,MAAM1pB,EAAM/oB,oBACV,+DAIN,GAAIsyC,EAAc,CAChB,MAAMrsB,EAAazC,GAAmB3jB,GAChCsrC,EAAWjH,GAAgBje,EAAYpmB,EAAII,KAAM8kC,GACjDpW,EAAcwc,EAASgH,IAAgBpQ,GAC3C,WACA,EACA9b,GAEEssB,IACFpH,EAASiH,IAAcnc,GAAehQ,EAAY,YAEhDjlB,EACF8d,GAAsBmH,EAAY0I,GAElCvP,GAA8B6G,EAAY0I,EAAawc,EAE3D,CACAtrC,EAAIwE,MACN,EACAlF,UAAW,CACTgoB,KAAAA,CAAMtnB,GACJ,MAAMsrC,EAAWtrC,EAAII,KAAKsC,MACpBosB,EAAcwc,EAASgH,IAE7B,GADiBtyC,EAAII,KAAKgB,IACd,CACV,MAAMwqC,EAAWN,EAASiH,IAC1B,GAAIzqC,IACFg/B,GACE9mC,EACAqd,GACE,UACAuuB,GAAYvmB,GAAqBF,GAAWnlB,IAC5C4rC,GAAYwG,GAAkB5wC,MAAME,cAAckqC,SAGjD,CACL,MAAMgB,EAAU5sC,EAAII,KAAKgB,IAAI1B,KACvBmzC,EAAa7yC,EAAI+G,MAAMwb,WAAWqqB,GAASrJ,eACjD,IAAIsJ,EACAjB,IACFiB,EAAqBxlC,EAAsB,OAAOulC,MAClD,EAAIyF,GAAqBpxB,cAAc7gB,KAAKE,KAAKgK,KAC/C8nC,GAAkB5wC,MAAMuoB,oBAAoB,QAAS,CACnDqoB,GAAkB5wC,MAAMwoB,mBACtB6iB,EACAxvB,GACE,UACA+0B,GAAkB5wC,MAAME,cAAckqC,GACtC7c,GAAwBD,SAMlC,IAAK,MAAMuJ,KAAawa,EAAY,CAClC,MAAMjQ,EAAmBzd,GAAWkT,GAChCpvB,GAAkBovB,GACpBA,EAAU5vB,WAAW3G,YACnBswC,GAAkB5wC,MAAM4L,oBACtBs0B,GAA0BkB,EAAkB9T,KAGvC+d,GACTxU,EAAUv2B,YACRswC,GAAkB5wC,MAAM6L,eAAew/B,EAAoB,CACzD3Z,GAAmB0P,EAAkBzd,GAAWnlB,MAIxD,CACF,CACF,CACI8uB,GACFxhB,GAAMtN,EAAK,IAEbosB,GAAOpsB,GACPktB,GAAQltB,EAAI,MACd,EACA4nB,IAAAA,CAAK5nB,GACH,MAAMomB,EAAajB,GAAWnlB,GACxBsrC,EAAWtrC,EAAII,KAAKsC,MACpBosB,EAAcwc,EAASgH,IACvB3G,EAASze,GAAQltB,GACvB,GAAI8H,IACF,IAAK,MAAMohB,KAASlpB,EAAII,KAAKE,KAAKA,KAC5B8xC,GAAkB5wC,MAAMoxC,YAAY1pB,GACtCyiB,CAAM,GAAGziB,EAAMzqB,QACN2zC,GAAkB5wC,MAAMmxC,mBAAmBzpB,IACpDyiB,CAAM,GAAGtuB,GAAY,YAAa6L,EAAMzqB,aAGvC,CACL,MAAMq0C,EAAiB,GACjBC,EAAsB,GAC5B,IAAIC,EAAe,GACnB,IAAK,MAAM9pB,KAASlpB,EAAII,KAAKE,KAAKA,KAC5B8xC,GAAkB5wC,MAAMoxC,YAAY1pB,GACtC8pB,GAAgB9pB,EAAMzqB,MACb2zC,GAAkB5wC,MAAMmxC,mBAAmBzpB,KACpD4pB,EAAexoC,KAAK8nC,GAAkB5wC,MAAMmqB,gBAAgB,CAAEvQ,IAAK43B,KACnED,EAAoBzoC,KAAK4e,EAAMzqB,OAC/Bu0C,EAAe,IAGgB,IAA/BD,EAAoBxyC,OACtBorC,CAAM,GAAGqH,KAETF,EAAexoC,KAAK8nC,GAAkB5wC,MAAMmqB,gBAAgB,CAAEvQ,IAAK43B,KACnEvd,GACE,SACAtQ,GAAWnlB,GACXsrC,EAAS9qB,mBACT4xB,GAAkB5wC,MAAM4L,oBACtBiQ,GACE,OACA+0B,GAAkB5wC,MAAMwb,iBACtBiW,GACAlE,GAAwBD,IACxB,GAEFsjB,GAAkB5wC,MAAMkqB,gBAAgBonB,EAAgBC,MAKlE,CACA1mB,GAAMrsB,GACN2rC,CAAM,MACF7c,GACFD,GACE7uB,EACA8uB,EACA9O,GAA0BoG,EAAY0I,IAG1C9uB,EAAIsB,QACN,GAEFyuB,aAAc,CACZkjB,MAAM,GAERlxC,WAAY,CAAC,EACbC,aAAc,CACZ,CACEE,YAAa,sEACb+tB,mBAAoB,sDAMtBijB,GAAoBvzC,EAAQ,yCAC5BwzC,GAAuBxzC,EAAQ,+CAC/ByzC,GAAgB3uC,OAAO,2BACvB4uC,GAAa5uC,OAAO,kBACpB6uC,GAAsB,CACxBx0C,OAAAA,CAAQkB,IACN,EAAImzC,GAAqBvyC,cAAcZ,IACvC,EAAImzC,GAAqBtyC,gBAAgBb,GACzC,MAAM,KAAEI,GAASJ,EACjB,GAAII,EAAKgB,MAAQ8xC,GAAkB1xC,MAAMqgB,aAAazhB,EAAKgB,KACzD,MAAMpB,EAAI7B,IAAI,OAAOgC,oBACnB,4DAGJ,MAAM0kC,EAAO,CAAC,GACR,WAAE9iC,GAAe/B,EAAII,KAC3B,IAAIqqC,EACAC,EACAE,GAAmB,EACnBD,GAAuB,EAC3B,IAAK,IAAI5lC,EAAIhD,EAAWxB,OAAQwE,KAAO,CACrC,MAAM9E,EAAQ8B,EAAWgD,GACnBkhC,EAAahmC,EAAMxB,MAAMiE,QAAU,CAAC,EAC1C,GAAIwwC,GAAkB1xC,MAAMskC,iBAAiB7lC,GAAQ,CACnD,GAAI4kC,EAAK5kC,EAAMP,MAAO,CACpBqlC,GAAe9kC,EAAMxB,OACrB,QACF,CACAomC,EAAK5kC,EAAMP,MAAQO,EACfoP,GAAepP,EAAMP,OACvBumC,EAAWzH,UAAW,EACtBoM,GAAmB,GACTnoC,EAASxC,EAAMxB,OAAOkE,YAChCgoC,GAAuB,EAE3B,MAAWuI,GAAkB1xC,MAAMtB,uBAAuBD,KACxDgmC,EAAWzH,UAAW,EACtBoM,GAAmB,EACnBD,GAAuB,GAErBF,EACFA,EAAqBngC,KAAKrK,EAAMxB,OACvBy0C,GAAkB1xC,MAAMtB,uBAAuBD,GACxDwqC,EAAuB,CAACxqC,EAAMxB,OAE9BisC,EAAiBpgC,GAAKogC,EAAgBzE,EAE1C,CACA,MAAMsN,EAAuB,GAC7B,IAAIC,GAAsB,EAC1B,IAAK,MAAMtqB,KAASlpB,EAAII,KAAKE,KAAKA,KAChC,GAAI4yC,GAAkB1xC,MAAMmxC,mBAAmBzpB,GAC7CqqB,EAAqBjpC,KAAK4e,EAAMzqB,OAChC+0C,GAAsB,OACjB,IAAKN,GAAkB1xC,MAAMoxC,YAAY1pB,GAC9C,MAAMlpB,EAAI+jB,IAAIumB,WACZphB,EACA,8DAIN,GAAI9oB,EAAKgB,KAAOwpC,GAAoBD,GAAwB6I,EAAqB,CAC/E,MAAMlI,EAAWlrC,EAAKsC,QAAU,CAAC,EAC3B0jB,EAAazC,GAAmB3jB,GAChC8uB,EAAcwc,EAAS8H,IAAiBlR,GAC5C,UACA,EACA9b,GAgBF,IAdA,EAAI+sB,GAAqBlyB,cAAc7gB,KAAKsC,MAAMmL,gBAAkB+8B,EAChEH,GACFpG,GAAgBje,EAAYpmB,EAAII,KAAMqqC,GAEpC8I,EAAqBhzC,OAAS,GAChC8jC,GACEje,EACAmtB,EAAqB,GACrBA,EAAqBhkC,MAAM,KAG3Bq7B,GAAoBH,IACtBxrB,GAAsBmH,EAAY0I,GAEhC1uB,EAAKgB,IAAK,CACZ6d,GAAsBmH,EAAY0I,GAClC,IAAK,MAAMlO,KAAO5gB,EAAI+G,MAAMwb,WAAWniB,EAAKgB,IAAI1B,MAAM6jC,eAAgB,CACpE,MAAMmI,EAAa/nB,GAAmB/C,GACtCuiB,GAAmBviB,GACf8F,GAAqBN,EAAYslB,IACnCptB,GACEotB,EACAtlB,EACA/d,KAAkBkxB,OAEf+R,EAAS+H,KAAgBpqC,GAAkB2X,KAC9C0qB,EAAS+H,IAAcjd,GAAehQ,EAAY,aAGpDsc,GAAsB9hB,EAAKkO,EAE/B,CACF,CACAvP,GACE6G,EACA0I,EACAxkB,GAAKogC,EAAgBY,GAEzB,CACF,EACAhsC,UAAW,CACTgoB,KAAAA,CAAMtnB,GACJ,MAAMsrC,EAAWtrC,EAAII,KAAKsC,MACpBosB,EAAcwc,EAAS8H,IACvBK,EAAS3rC,IACT6jC,EAASze,GAAQltB,GACjBomB,EAAajB,GAAWnlB,GAE9B,GADiBA,EAAII,KAAKgB,IACd,CACV,MAAMwqC,EAAWN,EAAS+H,IAC1B,GAAII,EACF3M,GACE9mC,EACAqd,GACE,UACAuuB,GAAYvmB,GAAqBe,GACjCwlB,GAAYsH,GAAkB1xC,MAAME,cAAckqC,SAGjD,CACL,MAAMgB,EAAU5sC,EAAII,KAAKgB,IAAI1B,KACvBmzC,EAAa7yC,EAAI+G,MAAMwb,WAAWqqB,GAASrJ,eACjD,IAAIsJ,EACAjB,IACFiB,EAAqBxlC,EAAsB,OAAOulC,MAClD,EAAIuG,GAAqBlyB,cAAc7gB,KAAKE,KAAKgK,KAC/C4oC,GAAkB1xC,MAAMuoB,oBAAoB,QAAS,CACnDmpB,GAAkB1xC,MAAMwoB,mBACtB6iB,EACAxvB,GACE,UACA61B,GAAkB1xC,MAAME,cAAckqC,GACtC7c,GAAwBD,SAMlC,IAAK,MAAMuJ,KAAawa,EAAY,CAClC,MAAMjQ,EAAmBzd,GAAWkT,GAChCpvB,GAAkBovB,GACpBA,EAAU5vB,WAAW3G,YACnBoxC,GAAkB1xC,MAAM4L,oBACtBs0B,GAA0BkB,EAAkB9T,KAGvC+d,GACTxU,EAAUv2B,YACRoxC,GAAkB1xC,MAAM6L,eAAew/B,EAAoB,CACzD3Z,GAAmB0P,EAAkBzd,GAAWnlB,MAIxD,CACF,CACF,CACA,MAAM6rC,EAAgB/c,GAAeC,GAAwBD,GACzD+c,GACFv+B,GAAMtN,EAAK,IAEb2rC,CAAM,UACN,MAAMG,EAsMZ,SAAuB9rC,GACrB,MAAM6kC,EAAO,CAAC,GACR,WAAE9iC,GAAe/B,EACjBstC,EAAmC,IAAItyB,IAC7C,IAAIoxB,EACAF,EACAqB,EACAC,EACJ,IAAK,IAAIzoC,EAAIhD,EAAWxB,OAAQwE,KAAO,CACrC,MAAM9E,EAAQ8B,EAAWgD,IACnB,MAAEtG,GAAUwB,EACdizC,GAAkB1xC,MAAMtB,uBAAuBD,IAC5CstC,IACHA,EAAc,IAEhBA,EAAYjjC,KAAK4oC,GAAkB1xC,MAAMksC,cAAcjvC,KAC7ComC,EAAK5kC,EAAMP,QACrBmlC,EAAK5kC,EAAMP,MAAQO,EACfstC,EACFA,EAAYjjC,KAAKoS,GAAiBzc,EAAMP,KAAMO,EAAMxB,QAEpD6uC,EAAiB/jC,IAAItJ,GAG3B,CACA,MAAM+rC,EAAc,IAAIsB,GAAkBK,UAC1C,GAAIJ,EAAa,CACfA,EAAYI,UACZ,IAAK,MAAQjuC,KAAMb,KAAWmtC,GAC3BwB,IAAc,IAAIljC,KAAKoS,GAAiB7d,EAAOq0C,GAAkB1xC,MAAMib,eAAe,KAErF+wB,IACFtB,EAAiBgH,GAAkB1xC,MAAMq4B,iBAAiB2T,IAE5DpB,EAAmBwB,GAAkBL,EACvC,CACA,MAAO,CACLvB,cACAI,mBACAF,iBAEJ,CA/OwBwH,CAAc1zC,EAAII,OAC9B,YAAE4rC,EAAW,eAAEE,EAAc,iBAAEE,GAAqBN,EAC1D,IAAK,MAAM7rC,KAAS+rC,EAAa,CAC/B,MAAQtsC,KAAMb,EAAK,MAAEJ,GAAUwB,GACzB,UAAE0C,EAAS,SAAEC,GAAanE,EAAMiE,OAAS,CAAC,EAC1C6pC,EAAkB9tC,EAAMiE,OAAO8d,mBACrC,OAAQ3hB,GACN,IAAK,QACL,IAAK,QAAS,CACZ,MAAMwtC,EAAS,GAAGxtC,QACd8D,EACFgpC,CAAM,GAAG9tB,KAAiBwuB,GAAQzpC,KACzB6wC,EACT9H,CAAM,GAAGtuB,GAAYgvB,EAAQ5tC,KAE7Bg3B,GACE,SACArP,EACAmmB,EACA2G,GAAkB1xC,MAAM4L,oBACtBiQ,GACEgvB,EACA6G,GAAkB1xC,MAAMwb,iBAAiBiW,GAAiB4Y,GAAe,GACzEptC,KAKR,KACF,CACA,QACMkE,EACFgpC,CAAM,GAAG9tB,KAAiB/M,KAAKjS,EAAO+D,KAC7B6wC,EACLpkC,GAAexQ,GACjBy5B,GAAkBlS,EAAYmmB,GAE9BZ,CAAM,GAAGtuB,GAAY,OAAQ61B,GAAkB1xC,MAAME,cAAc7C,GAAQJ,KAEpE4Q,GAAexQ,GACxB42B,GACE,SACArP,EACAmmB,EACA2G,GAAkB1xC,MAAM4L,oBACtBiQ,GACE,KACA61B,GAAkB1xC,MAAMwb,iBAAiBiW,GAAiB4Y,GAAe,GACzEqH,GAAkB1xC,MAAME,cAAc4N,GAAoBzQ,IAC1DJ,KAKNg3B,GACE,SACArP,EACAmmB,EACA2G,GAAkB1xC,MAAM4L,oBACtBiQ,GACE,OACA61B,GAAkB1xC,MAAMwb,iBAAiBiW,GAAiB4Y,GAAe,GACzEqH,GAAkB1xC,MAAME,cAAc7C,GACtCJ,KAOd,CACI2tC,IACEqH,GACFnb,GAAkBlS,EAAYklB,EAAS9qB,oBACnC0rB,EACFP,CAAM,GAAGtuB,GAAY,eAAgB+uB,EAAkBF,EAAgBL,EAAexmB,GAAqBe,GAAa8sB,GAAkB1xC,MAAME,cAAc,aAE9JiqC,CAAM,GAAGtuB,GAAY,QAAS+uB,EAAkBP,EAAexmB,GAAqBe,GAAa8sB,GAAkB1xC,MAAME,cAAc,eAIvI+zB,GACE,SACArP,EACAklB,EAAS9qB,mBAJT0rB,EAKAgH,GAAkB1xC,MAAM4L,oBACtBiQ,GACE,eACA4V,GACA4Y,EACAO,EACAF,IASJgH,GAAkB1xC,MAAM4L,oBACtBiQ,GACE,QACA4V,GACA4Y,EACAO,KAKR3W,GACE,SACArP,EACAklB,EAAS9qB,mBACT0yB,GAAkB1xC,MAAM4L,oBACtBiQ,GAAY,cAAe4V,GAAiB4Y,KAE9C,KAINF,CAAM,IACNvf,GAAOpsB,EACT,EACA4nB,IAAAA,CAAK5nB,GACH,MAAMomB,EAAajB,GAAWnlB,GAExB8uB,EADW9uB,EAAII,KAAKsC,MACG0wC,IACvBzH,EAASze,GAAQltB,GACjB6rC,EAAgB9c,GAAwBD,GAC9C,GAAIhnB,IACF,IAAK,MAAMohB,KAASlpB,EAAII,KAAKE,KAAKA,KAC5B4yC,GAAkB1xC,MAAMoxC,YAAY1pB,GACtCyiB,CAAM,GAAGziB,EAAMzqB,QACNy0C,GAAkB1xC,MAAMmxC,mBAAmBzpB,IACpDyiB,CAAM,GAAGtuB,GAAY,eAAgB6L,EAAMzqB,aAG1C,CACL,MAAMq0C,EAAiB,GACjBC,EAAsB,GAC5B,IACIY,EADAX,EAAe,GAEnB,IAAK,MAAM9pB,KAASlpB,EAAII,KAAKE,KAAKA,KAC5B4yC,GAAkB1xC,MAAMoxC,YAAY1pB,GACtC8pB,GAAgB9pB,EAAMzqB,MACby0C,GAAkB1xC,MAAMmxC,mBAAmBzpB,KACpDyqB,IAAyBzqB,EACzB4pB,EAAexoC,KAAK4oC,GAAkB1xC,MAAMmqB,gBAAgB,CAAEvQ,IAAK43B,KACnED,EAAoBzoC,KAAK4e,EAAMzqB,OAC/Bu0C,EAAe,IAGdW,GAGHb,EAAexoC,KAAK4oC,GAAkB1xC,MAAMmqB,gBAAgB,CAAEvQ,IAAK43B,KACnEvd,GACE,SACAtQ,GAAWnlB,GACX2zC,EAAqBl1C,MAAMiE,OAAO8d,mBAClC0yB,GAAkB1xC,MAAM4L,oBACtBiQ,GACE,cACA61B,GAAkB1xC,MAAMwb,iBAAiBiW,GAAiB4Y,GAAe,GACzEqH,GAAkB1xC,MAAMkqB,gBAAgBonB,EAAgBC,OAX9DpH,CAAM,GAAGqH,GAgBb,CACArH,CAAM,YACF7c,GACFD,GACE7uB,EACA8uB,EACA9O,GAA0BoG,EAAY0I,IAG1CzC,GAAMrsB,GACNA,EAAIsB,QACN,GAEF,SAAU,cACV,eAAgB,oBAChB,SAAU,cACV,aAAc,kBACd,YAAa,iBACb,SAAU,cACV,kBAAmB,uBACnB,OAAQ,YACR,QAAS,aACT,mBAAoB,CAAC,mBACrByuB,aAAc,CACZkjB,MAAM,EACNW,oBAAoB,IA+CpBC,GAAoBl0C,EAAQ,yCAC5Bm0C,GAAuBn0C,EAAQ,+CAC/Bo0C,GAAgBtvC,OAAO,0BACvBuvC,GAAavvC,OAAO,kBACpBwvC,GAAqB,CACvBn1C,OAAAA,CAAQkB,IACN,EAAI8zC,GAAqBlzC,cAAcZ,IACvC,EAAI8zC,GAAqBjzC,gBAAgBb,GACzC,MAAM,KAAEI,GAASJ,EACjB,GAAII,EAAKgB,MAAQyyC,GAAkBryC,MAAMqgB,aAAazhB,EAAKgB,KACzD,MAAMpB,EAAI7B,IAAI,OAAOgC,oBACnB,4DAGJ,MAAM0kC,EAAO,CAAC,GACR,WAAE9iC,GAAe/B,EAAII,KAC3B,IAAIqqC,EACAC,EACAE,GAAmB,EACnBD,GAAuB,EAC3B,IAAK,IAAI5lC,EAAIhD,EAAWxB,OAAQwE,KAAO,CACrC,MAAM9E,EAAQ8B,EAAWgD,GACnBkhC,EAAahmC,EAAMxB,MAAMiE,QAAU,CAAC,EAC1C,GAAImxC,GAAkBryC,MAAMskC,iBAAiB7lC,GAAQ,CACnD,GAAI4kC,EAAK5kC,EAAMP,MAAO,CACpBqlC,GAAe9kC,EAAMxB,OACrB,QACF,CACAomC,EAAK5kC,EAAMP,MAAQO,EACfoP,GAAepP,EAAMP,OACvBumC,EAAWzH,UAAW,EACtBoM,GAAmB,GACTnoC,EAASxC,EAAMxB,OAAOkE,YAChCgoC,GAAuB,EAE3B,MAAWkJ,GAAkBryC,MAAMtB,uBAAuBD,KACxDgmC,EAAWzH,UAAW,EACtBoM,GAAmB,EACnBD,GAAuB,GAErBF,EACFA,EAAqBngC,KAAKrK,EAAMxB,OACvBo1C,GAAkBryC,MAAMtB,uBAAuBD,GACxDwqC,EAAuB,CAACxqC,EAAMxB,OAE9BisC,EAAiBpgC,GAAKogC,EAAgBzE,EAE1C,CACA,MAAMsN,EAAuB,GAC7B,IAAIC,GAAsB,EAC1B,IAAK,MAAMtqB,KAASlpB,EAAII,KAAKE,KAAKA,KAChC,GAAIuzC,GAAkBryC,MAAMmxC,mBAAmBzpB,GAC7CqqB,EAAqBjpC,KAAK4e,EAAMzqB,OAChC+0C,GAAsB,OACjB,IAAKK,GAAkBryC,MAAMoxC,YAAY1pB,GAC9C,MAAMlpB,EAAI+jB,IAAIumB,WACZphB,EACA,6DAIN,GAAI9oB,EAAKgB,KAAOwpC,GAAoBD,GAAwB6I,EAAqB,CAC/E,MAAMlI,EAAWlrC,EAAKsC,QAAU,CAAC,EAC3B0jB,EAAazC,GAAmB3jB,GAChC8uB,EAAcwc,EAASyI,IAAiB7R,GAC5C,SACA,EACA9b,GAgBF,IAdA,EAAI0tB,GAAqB7yB,cAAc7gB,KAAKsC,MAAMmL,gBAAkB+8B,EAChEH,GACFpG,GAAgBje,EAAYpmB,EAAII,KAAMqqC,GAEpC8I,EAAqBhzC,OAAS,GAChC8jC,GACEje,EACAmtB,EAAqB,GACrBA,EAAqBhkC,MAAM,KAG3Bq7B,GAAoBH,IACtBxrB,GAAsBmH,EAAY0I,GAEhC1uB,EAAKgB,IAAK,CACZ6d,GAAsBmH,EAAY0I,GAClC,IAAK,MAAMlO,KAAO5gB,EAAI+G,MAAMwb,WAAWniB,EAAKgB,IAAI1B,MAAM6jC,eAAgB,CACpE,MAAMmI,EAAa/nB,GAAmB/C,GACtCuiB,GAAmBviB,GACf8F,GAAqBN,EAAYslB,IACnCptB,GACEotB,EACAtlB,EACA/d,KAAkBkxB,OAEf+R,EAAS0I,KAAgB/qC,GAAkB2X,KAC9C0qB,EAAS0I,IAAc5d,GAAehQ,EAAY,YAGpDsc,GAAsB9hB,EAAKkO,EAE/B,CACF,CACAvP,GACE6G,EACA0I,EACAxkB,GAAKogC,EAAgBY,GAEzB,CACF,EACAhsC,UAAW,CACTgoB,KAAAA,CAAMtnB,GACJ,MAAMsrC,EAAWtrC,EAAII,KAAKsC,MACpBosB,EAAcwc,EAASyI,IACvBN,EAAS3rC,IACT6jC,EAASze,GAAQltB,GACjBomB,EAAajB,GAAWnlB,GAE9B,GADiBA,EAAII,KAAKgB,IACd,CACV,MAAMwqC,EAAWN,EAAS0I,IAC1B,GAAIP,EACF3M,GACE9mC,EACAqd,GACE,UACAuuB,GAAYvmB,GAAqBe,GACjCwlB,GAAYiI,GAAkBryC,MAAME,cAAckqC,SAGjD,CACL,MAAMgB,EAAU5sC,EAAII,KAAKgB,IAAI1B,KACvBmzC,EAAa7yC,EAAI+G,MAAMwb,WAAWqqB,GAASrJ,eACjD,IAAIsJ,EACAjB,IACFiB,EAAqBxlC,EAAsB,OAAOulC,MAClD,EAAIkH,GAAqB7yB,cAAc7gB,KAAKE,KAAKgK,KAC/CupC,GAAkBryC,MAAMuoB,oBAAoB,QAAS,CACnD8pB,GAAkBryC,MAAMwoB,mBACtB6iB,EACAxvB,GACE,UACAw2B,GAAkBryC,MAAME,cAAckqC,GACtC7c,GAAwBD,SAMlC,IAAK,MAAMuJ,KAAawa,EAAY,CAClC,MAAMjQ,EAAmBzd,GAAWkT,GAChCpvB,GAAkBovB,GACpBA,EAAU5vB,WAAW3G,YACnB+xC,GAAkBryC,MAAM4L,oBACtBs0B,GAA0BkB,EAAkB9T,KAGvC+d,GACTxU,EAAUv2B,YACR+xC,GAAkBryC,MAAM6L,eAAew/B,EAAoB,CACzD3Z,GAAmB0P,EAAkBzd,GAAWnlB,MAIxD,CACF,CACF,CACA,MAAM6rC,EAAgB/c,GAAeC,GAAwBD,GACzD+c,GACFv+B,GAAMtN,EAAK,IAEb2rC,CAAM,SACN,MAAMG,EAiMZ,SAAuB9rC,GACrB,MAAM6kC,EAAO,CAAC,GACR,WAAE9iC,GAAe/B,EACjBstC,EAAmC,IAAItyB,IAC7C,IAAIoxB,EACAF,EACAqB,EACAC,EACJ,IAAK,IAAIzoC,EAAIhD,EAAWxB,OAAQwE,KAAO,CACrC,MAAM9E,EAAQ8B,EAAWgD,IACnB,MAAEtG,GAAUwB,EACd4zC,GAAkBryC,MAAMtB,uBAAuBD,IAC5CstC,IACHA,EAAc,IAEhBA,EAAYjjC,KAAKupC,GAAkBryC,MAAMksC,cAAcjvC,KAC7ComC,EAAK5kC,EAAMP,QACrBmlC,EAAK5kC,EAAMP,MAAQO,EACfstC,EACFA,EAAYjjC,KAAKoS,GAAiBzc,EAAMP,KAAMO,EAAMxB,QAEpD6uC,EAAiB/jC,IAAItJ,GAG3B,CACA,MAAM+rC,EAAc,IAAIsB,GAAkBK,UAC1C,GAAIJ,EAAa,CACfA,EAAYI,UACZ,IAAK,MAAQjuC,KAAMb,KAAWmtC,GAC3BwB,IAAc,IAAIljC,KAAKoS,GAAiB7d,EAAOg1C,GAAkBryC,MAAMib,eAAe,KAErF+wB,IACFtB,EAAiB2H,GAAkBryC,MAAMq4B,iBAAiB2T,IAE5DpB,EAAmBwB,GAAkBL,EACvC,CACA,MAAO,CACLvB,cACAI,mBACAF,iBAEJ,CA1OwBgI,CAAcl0C,EAAII,OAC9B,YAAE4rC,EAAW,eAAEE,EAAc,iBAAEE,GAAqBN,EAC1D,IAAK,MAAM7rC,KAAS+rC,EAAa,CAC/B,MAAQtsC,KAAMb,EAAK,MAAEJ,GAAUwB,GACzB,UAAE0C,EAAS,SAAEC,GAAanE,EAAMiE,OAAS,CAAC,EAC1C6pC,EAAkB9tC,EAAMiE,OAAO8d,mBACrC,OAAQ3hB,GACN,IAAK,QACL,IAAK,QAAS,CACZ,MAAMwtC,EAAS,GAAGxtC,QACd8D,EACFgpC,CAAM,GAAG9tB,KAAiBwuB,GAAQzpC,KACzB6wC,EACT9H,CAAM,GAAGtuB,GAAYgvB,EAAQ5tC,KAE7Bg3B,GACE,SACArP,EACAmmB,EACAsH,GAAkBryC,MAAM4L,oBACtBiQ,GACEgvB,EACAwH,GAAkBryC,MAAMwb,iBAAiBiW,GAAiB4Y,GAAe,GACzEptC,KAKR,KACF,CACA,QACMkE,EACFgpC,CAAM,GAAG9tB,KAAiB/M,KAAKjS,EAAO+D,KAC7B6wC,EACLpkC,GAAexQ,GACjBy5B,GAAkBlS,EAAYmmB,GAE9BZ,CAAM,GAAGtuB,GAAY,OAAQw2B,GAAkBryC,MAAME,cAAc7C,GAAQJ,KAEpE4Q,GAAexQ,GACxB42B,GACE,SACArP,EACAmmB,EACAsH,GAAkBryC,MAAM4L,oBACtBiQ,GACE,KACAw2B,GAAkBryC,MAAMwb,iBAAiBiW,GAAiB4Y,GAAe,GACzEgI,GAAkBryC,MAAME,cAAc4N,GAAoBzQ,IAC1DJ,KAKNg3B,GACE,SACArP,EACAmmB,EACAsH,GAAkBryC,MAAM4L,oBACtBiQ,GACE,OACAw2B,GAAkBryC,MAAMwb,iBAAiBiW,GAAiB4Y,GAAe,GACzEgI,GAAkBryC,MAAME,cAAc7C,GACtCJ,KAOd,CACI2tC,IACEqH,GACFnb,GAAkBlS,EAAYklB,EAAS9qB,oBACnC0rB,EACFP,CAAM,GAAGtuB,GAAY,eAAgB+uB,EAAkBF,EAAgBL,EAAexmB,GAAqBe,GAAaytB,GAAkBryC,MAAME,cAAc,YAE9JiqC,CAAM,GAAGtuB,GAAY,QAAS+uB,EAAkBP,EAAexmB,GAAqBe,GAAaytB,GAAkBryC,MAAME,cAAc,cAIvI+zB,GACE,SACArP,EACAklB,EAAS9qB,mBAJT0rB,EAKA2H,GAAkBryC,MAAM4L,oBACtBiQ,GACE,eACA4V,GACA4Y,EACAO,EACAF,IASJ2H,GAAkBryC,MAAM4L,oBACtBiQ,GACE,QACA4V,GACA4Y,EACAO,KAKR3W,GACE,SACArP,EACAklB,EAAS9qB,mBACTqzB,GAAkBryC,MAAM4L,oBACtBiQ,GAAY,cAAe4V,GAAiB4Y,KAE9C,KAINF,CAAM,IACNvf,GAAOpsB,EACT,EACA4nB,IAAAA,CAAK5nB,GACH,MAAMomB,EAAajB,GAAWnlB,GAExB8uB,EADW9uB,EAAII,KAAKsC,MACGqxC,IACvBpI,EAASze,GAAQltB,GACjB6rC,EAAgB9c,GAAwBD,GAC9C,GAAIhnB,IACF,IAAK,MAAMohB,KAASlpB,EAAII,KAAKE,KAAKA,KAC5BuzC,GAAkBryC,MAAMoxC,YAAY1pB,GACtCyiB,CAAM,GAAGziB,EAAMzqB,QACNo1C,GAAkBryC,MAAMmxC,mBAAmBzpB,IACpDyiB,CAAM,GAAGtuB,GAAY,cAAe6L,EAAMzqB,aAGzC,CACL,MAAMq0C,EAAiB,GACjBC,EAAsB,GAC5B,IACIY,EADAX,EAAe,GAEnB,IAAK,MAAM9pB,KAASlpB,EAAII,KAAKE,KAAKA,KAC5BuzC,GAAkBryC,MAAMoxC,YAAY1pB,GACtC8pB,GAAgB9pB,EAAMzqB,MACbo1C,GAAkBryC,MAAMmxC,mBAAmBzpB,KACpDyqB,IAAyBzqB,EACzB4pB,EAAexoC,KAAKupC,GAAkBryC,MAAMmqB,gBAAgB,CAAEvQ,IAAK43B,KACnED,EAAoBzoC,KAAK4e,EAAMzqB,OAC/Bu0C,EAAe,IAGdW,GAGHb,EAAexoC,KAAKupC,GAAkBryC,MAAMmqB,gBAAgB,CAAEvQ,IAAK43B,KACnEvd,GACE,SACAtQ,GAAWnlB,GACX2zC,EAAqBl1C,MAAMiE,OAAO8d,mBAClCqzB,GAAkBryC,MAAM4L,oBACtBiQ,GACE,cACAw2B,GAAkBryC,MAAMwb,iBAAiBiW,GAAiB4Y,GAAe,GACzEgI,GAAkBryC,MAAMkqB,gBAAgBonB,EAAgBC,OAX9DpH,CAAM,GAAGqH,GAgBb,CACArH,CAAM,WACF7c,GACFD,GACE7uB,EACA8uB,EACA9O,GAA0BoG,EAAY0I,IAG1CzC,GAAMrsB,GACNA,EAAIsB,QACN,GAEF,YAAa,iBACb,SAAU,cACV,SAAU,cACV,QAAS,aACT,mBAAoB,CAAC,mBACrByuB,aAAc,CACZkjB,MAAM,EACNW,oBAAoB,IA+CpBO,GAAoBx0C,EAAQ,yCAC5By0C,GAAuBz0C,EAAQ,+CAC/B00C,GAAa,CACfv1C,OAAAA,CAAQkB,IACN,EAAIo0C,GAAqBxzC,cAAcZ,IACvC,EAAIo0C,GAAqBvzC,gBAAgBb,IACzC,EAAIo0C,GAAqBtzC,oBAAoBd,GAC7CK,EAAoBL,IACpB,EAAIo0C,GAAqBrzC,uBAAuBf,GAChD,MAAM,KAAEI,GAASJ,EACjB,IAAKI,EAAKgB,IACR,MAAMpB,EAAI7B,IAAI,QAAQgC,oBAAoB,yCAE5C,IAAKg0C,GAAkB3yC,MAAMqgB,aAAazhB,EAAKgB,KAC7C,MAAMpB,EAAI7B,IAAI,OAAOgC,oBAAoB,uCAE3C,MAAM6L,EAAUq2B,GAAmBriC,EAAK,GACpCgM,GACFw4B,GAAoBx4B,GAAS,EAEjC,EACA1M,UAAW,CACTsoB,IAAAA,CAAK5nB,GACH,MAAM,KAAEI,GAASJ,EACXohB,EAAKtZ,IAAiBuV,GAAY,aAAeA,GAAY,YAAa4V,IAChF,GAAInrB,IACF9H,EAAI8B,YACFqyC,GAAkB3yC,MAAMuoB,oBAAoB,QAAS,CAACoqB,GAAkB3yC,MAAMwoB,mBAAmB5pB,EAAKgB,IAAKggB,UAExG,CACL,MAAMlQ,EAASiiB,GAAU/yB,EAAKgB,IAAIsB,MAAMsJ,SACxC6jB,GAAS1K,GAAWnlB,QAAM,EAAQkR,EAAQkQ,GAC1CphB,EAAIsB,QACN,CACF,GAEFyuB,aAAc,CACZC,aAAa,GAEfjuB,WAAY,CAAC,EACbC,aAAc,CACZ,CACEC,YAAa,YACbC,YAAa,qCACbC,QAAS,eACT8tB,mBAAoB,2CAGxBzuB,MAAO/B,EAAqBC,KAAO,yBAIjC40C,GAAoB30C,EAAQ,yCAC5B40C,GAAuB50C,EAAQ,+CAG/B60C,GAAoB70C,EAAQ,yCAY5B80C,GAAkC,IAAI9uC,QACtC+uC,GAAQ,CACV51C,OAAAA,CAAQkB,GAEN,GAmOJ,SAA8BA,GAM5B,QALA,EAAIu0C,GAAqBnlB,aAAapvB,IACtC,EAAIu0C,GAAqB3zC,cAAcZ,IACvC,EAAIu0C,GAAqB1zC,gBAAgBb,GA0B3C,SAAuBA,GACrB,IAAMA,EAAII,KAAKE,KAAKA,KAAKC,SAAUP,EAAII,KAAK4kB,cAAczkB,OACxD,MAAMP,EAAI7B,IAAI,QAAQgC,oBACpB,SAAS8N,GAAWjO,kCAG1B,CA/BE20C,CAAc30C,GACdD,EAAoBC,GACZiO,GAAWjO,IACjB,IAAK,KACH40C,GAAwB50C,GACxB,MACF,IAAK,UACH40C,GAAwB50C,GACxB60C,GAA4B70C,GAC5B,MACF,IAAK,QA2CT,SAAmCA,GACjC,MAAM,KAAEI,GAASJ,GACV80C,GAAU10C,EAAK2B,WACtB,GAAI3B,EAAK2B,WAAWxB,OAAS,GAAKu0C,GAA0B,OAAhBA,EAAOp1C,KAAe,CAChE,MAAM8Q,EAAQpQ,EAAK2B,WAAW,GAAGkiB,KAAKzT,MAChCujB,EAAM3zB,EAAK2B,WAAW3B,EAAK2B,WAAWxB,OAAS,GAAG0jB,KAAK8P,IACvDghB,EAAM,SAAS9mC,GAAWjO,+CAChC,MAAa,MAATwQ,GAAwB,MAAPujB,EACb/zB,EAAI7B,IAAI,QAAQgC,oBAAoB40C,GAEpC/0C,EAAI+jB,IAAIumB,WACZ,CAAErmB,IAAK,CAAEzT,QAAOujB,QAChBghB,EACAvgC,MAGN,CACF,CA3DMwgC,CAA0Bh1C,GAC1B60C,GAA4B70C,GAGlC,CAvPIi1C,CAAqBj1C,IACjBA,EAAII,KAAKE,KAAK0kB,eACdkwB,GAAal1C,GAAM,CACrB,MAAMm1C,EAAWC,GAAYp1C,IACtBkxC,GAASiE,EAAS,GACnBE,EAAe1xB,GAAmButB,GAClCoE,EAAapE,EAAM9wC,KAAKsC,QAAU,CAAC,EACnC6yC,EAAsB,GAMtBpxB,EAAkB,CACtBnY,QANkByiC,GAClByC,EACAmE,EACAF,EAAS50C,QAITy6B,OAAQ5yB,IAAoBotC,kBAE9B,IAAIpG,GAAyB,EAC7B,IAAK,MAAOqG,EAAWC,KAAsBP,EACvCO,IACFtG,IAAyD,OAA9BsG,EAAkBhxB,SAAoBgxB,EAAkBhxB,SAASoB,aAAuD,IAAxC4vB,EAAkBhxB,QAAQkB,UACrI8vB,EAAkB3wB,UAAW,EAC7B2wB,EAAkB9wB,mBAAqB0wB,EACvCI,EAAkBvxB,gBAAkBA,GAElCsxB,EAAUr1C,KAAK2B,WAAWxB,QAC5Bg1C,EAAoBjrC,KAAKmrC,EAAUr1C,KAAK2B,WAAW,GAAGtD,OAG1D4lC,GAAgBgR,EAAcnE,EAAM9wC,KAAMm1C,GAC1CD,EAAWlG,uBAAyBA,CACtC,CACF,EACA9vC,UAAWuoB,GAAkB,CAC3BC,KAAM,CACJR,KAAAA,CAAMtnB,GACJ,GAAIA,EAAII,KAAKE,KAAK0kB,cAAe,OACjC,MACMghB,EAAc9gB,GADJllB,EAAI7B,IAAI,SAEpBw3C,GAAO31C,KAASuuC,GAAoBvuC,KACtCsN,GAAMtN,EAAK,IACXssB,GAAatsB,IAEfsuB,GAAYtuB,GACRgmC,GACFzgB,GAAwBygB,GAAa,EAEzC,EACApe,IAAAA,CAAK5nB,GACH,GAAIA,EAAII,KAAKE,KAAK0kB,cAAe,OACjC,MAAM4gB,EAAU5lC,EAAI7B,IAAI,QAMxB,GALoB+mB,GAAkB0gB,KAEpC9c,GAAU9oB,GACV+oB,GAA0B6c,IAExBsP,GAAal1C,GAAM,CACrB,MAAMm1C,EAAWC,GAAYp1C,IACtBkxC,GAASiE,EAAS,GACnBE,EAAelwB,GAAW+rB,GAE1B9B,EADa8B,EAAM9wC,KAAKsC,MACY0sC,uBACpCtgB,EAAc2f,GAClByC,EACAmE,GAEIrG,EAAgCT,GAAoB2C,GACpDvE,EAAwB3sB,GAC5Bq1B,EACAvmB,GAEIwiB,EAAUtxC,EAAI41C,iBACpB,IAAIC,EACAlgB,EACJ,IAAK,IAAI5wB,EAAIowC,EAAS50C,OAAQwE,KAAO,CACnC,MAAO0wC,EAAWK,GAAcX,EAASpwC,GACnCoqC,EAAiBsG,EAAUr1C,KAAKE,KAAKA,KAC3C,GAAIw1C,EAAY,CACd,MAAMzG,EAAwBtvB,GAC5B+1B,EACAzW,IAEEgQ,KAC6B,IAA3BwG,IAEAA,GAD4B,IAA1BxG,IAEOwG,EACgBpsC,GACvB4vB,GACAwc,EACAxG,GAGuB,CAACA,KAG9BF,EAAe7kC,KACbgqC,GAAkB9yC,MAAMs2B,gBAAgBwc,GAAkB9yC,MAAMib,eAAe1X,KAGrF,CACA,MAAOgxC,GAAYN,EAAUr1C,KAAK2B,WAC5Bi0C,GApHe11C,EAoHwB6uC,EAnHnDtqC,MAAMC,QAAQxE,GACI,IAAhBA,EAAKC,OACAD,EAAK,GAEPk0C,GAAkBhzC,MAAMooB,eAAetpB,GAEzCA,GA+GKq1B,EADEogB,EACUzB,GAAkB9yC,MAAMirC,YAClCsJ,EAASt3C,MACTu3C,EACArgB,GAGUqgB,EAEdP,EAAUn0C,QACZ,CACA,GAAIu0C,EAAwB,CACtB7G,GAAiCrC,IACnCvlB,GAAa8pB,GAAO9wC,KAAKsC,MAAMunC,KAAa,GAE9C,MAAMgM,EAAS3B,GAAkB9yC,MAAMmoB,wBACrC,GACA2qB,GAAkB9yC,MAAMooB,eAAe,CAAC+L,KAE1CA,EAAY2e,GAAkB9yC,MAAM4L,oBAClCgiC,EAAyB/xB,GACvB,8BACA44B,EACA5wB,GAAqBgwB,GACrBtmB,GAAwBD,IACG,IAA3B+mB,GAA4D,IAA1BlJ,GAAmCqC,EAAyCsF,GAAkB9yC,MAAMib,eAAe,QAAhD,EAAqDy5B,GAAwBL,GACjLlJ,GAA8F,IAA1BA,EAAiCqC,EAAgCsF,GAAkB9yC,MAAMib,eAAe,QAAK,EAASmM,GAAkB+jB,GAApL2H,GAAkB9yC,MAAMib,eAAe,GAChEuyB,GAAiCsF,GAAkB9yC,MAAMib,eAAe,IACtEY,GACF,oBACA44B,EACA5wB,GAAqBgwB,GACrBtmB,GAAwBD,IACG,IAA3B+mB,GAA4D,IAA1BlJ,OAAiC,EAAS2H,GAAkB9yC,MAAMib,eAAe,GAAKy5B,GAAwBL,GAC/IlJ,GAA8F,IAA1BA,OAAiC,EAAS/jB,GAAkB+jB,GAAxG2H,GAAkB9yC,MAAMib,eAAe,IAGtE,CACA60B,EAAQ/iB,aAAaoH,EACvB,CA5JR,IAAiCr1B,CA6J3B,GAEFynB,IAAK,CACHT,KAAAA,CAAMtnB,GACJ,GAAIA,EAAII,KAAKE,KAAK0kB,cAAe,OACjC,MACMghB,EAAc9gB,GADJllB,EAAI7B,IAAI,SAEpB6nC,GACFzgB,GAAwBygB,GAAa,GAEnC2P,GAAO31C,KAASuuC,GAAoBvuC,KACtCsN,GAAMtN,EAAK,IACXssB,GAAatsB,GAEjB,EACA4nB,IAAAA,CAAK5nB,GACH,IAAIA,EAAII,KAAKE,KAAK0kB,eACdkwB,GAAal1C,GAAM,CACrB,MAAMm1C,EAAWC,GAAYp1C,IACtBkxC,GAASiE,EAAS,GACnBE,EAAelwB,GAAW+rB,GAC1BoE,EAAaH,EAAS,GAAG,GAAG/0C,KAAKsC,MACjCwjC,EAAWuI,GAAiCyC,EAAOmE,GACnDc,EAAsB,GAC5B,IAAInzC,EAAOsxC,GAAkB9yC,MAAMib,eAAe04B,EAAS50C,QAC3D,IAAK,IAAIwE,EAAIowC,EAAS50C,OAAQwE,KAAO,CACnC,MAAO0wC,EAAWC,GAAqBP,EAASpwC,IACzCgxC,GAAYN,EAAUr1C,KAAK2B,WAC5BsB,EAAaixC,GAAkB9yC,MAAMib,eAAei5B,EAAoB3wC,GAAK,GAC/E2wC,IACFS,EAAoB7rC,KAAKgqC,GAAkB9yC,MAAMI,WAAW8zC,EAAkBh2C,OAC9EqxB,GAAwB0kB,GAAW,CAACjvB,EAASgM,IACpCnV,GACL,qBACA0R,GAAwBvI,GACxBuI,GAAwBmX,GACxBoO,GAAkB9yC,MAAMib,eAAe1X,GACvCytB,MAINijB,EAAUn0C,SACV0B,EAAO+yC,EAAWzB,GAAkB9yC,MAAM40C,sBAAsBL,EAASt3C,MAAO4E,EAAYL,GAAQK,CACtG,CACA,MAAM8uB,EAASH,GAAUqjB,EAAcnP,EAAU,MACjD/T,EAAOzlB,MAAQ,IACN2Q,GACL,cACA0R,GAAwBmX,MACrBiQ,EAAoBxI,WAG3B9d,GAASwlB,EAAcC,EAAW90B,mBAAoB2R,EAAQnvB,EAChE,CACF,KAGJ+sB,aAAc,CAAEggB,aAAa,GAC7B/tC,aAAc,CACZ,CACEG,QAAS,oBACTD,YAAa,uDACb+tB,mBAAoB,yDAItBomB,GAAY,IACX3B,GACH1yC,aAAc,CACZ,CACEG,QAAS,yBACTD,YAAa,4GACb+tB,mBAAoB,yDAItBqmB,GAAU,IACT5B,GACH1yC,aAAc,CACZ,CACEE,YAAa,0FACb+tB,mBAAoB,yDAwB1B,SAAS4kB,GAA4B70C,GACnC,IAAIwxB,EAAOxxB,EAAIupC,iBACf,KAAO/X,EAAKpxB,MAAQoxB,EAAK+kB,kBAAkB/kB,EAAOA,EAAK+X,iBACvD,IAAKh7B,GAAeijB,IAA8B,SAArBvjB,GAAWujB,KAAqBA,EAAKpxB,KAAK2B,WAAWxB,OAChF,MAAMP,EAAIG,oBACR,UAAU8N,GAAWjO,wFAG3B,CAQA,SAAS40C,GAAwB50C,GAC/B,MAAM,KAAEI,GAASJ,GACV6lC,GAAazlC,EAAK2B,WACzB,IAAKuyC,GAAkB9yC,MAAMskC,iBAAiBD,KAAeA,EAAUne,QACrE,MAAM1nB,EAAI7B,IAAI,QAAQgC,oBAAoB,SAAS8N,GAAWjO,8BAEhE,GAAII,EAAK2B,WAAWxB,OAAS,EAAG,CAC9B,MAAMiQ,EAAQpQ,EAAK2B,WAAW,GAAGkiB,KAAKzT,MAChCujB,EAAM3zB,EAAK2B,WAAW3B,EAAK2B,WAAWxB,OAAS,GAAG0jB,KAAK8P,IACvDghB,EAAM,SAAS9mC,GAAWjO,kDAChC,MAAa,MAATwQ,GAAwB,MAAPujB,EACb/zB,EAAI7B,IAAI,QAAQgC,oBAAoB40C,GAEpC/0C,EAAI+jB,IAAIumB,WACZ,CAAErmB,IAAK,CAAEzT,QAAOujB,QAChBghB,EACAvgC,MAGN,CACF,CAmBA,SAAS4gC,GAAYp1C,GACnB,IAAIm1C,EAAWV,GAAgBt2C,IAAI6B,GACnC,IAAKm1C,EAAU,CACb,IAAIqB,EAASx2C,EACbm1C,EAAW,GACX,GAME,IALAV,GAAgB7tC,IAAI4vC,EAAQrB,GAC5BA,EAAS7qC,KAAK,CACZksC,EACA/yB,GAAa+yB,EAAOr4C,IAAI,YAElBq4C,EAASA,EAAOZ,kBAAkBW,0BACnCjoC,GAAckoC,EAAQ,SAAWloC,GAAckoC,EAAQ,WAClE,CACA,OAAOrB,CACT,CACA,SAASe,GAAwBO,GAC/B,IAAIzzC,EAAO4lB,GAAkB6tB,EAAQ,IACrC,IAAK,IAAI1xC,EAAI,EAAGA,EAAI0xC,EAAQl2C,OAAQwE,IAClC/B,EAAOsxC,GAAkB9yC,MAAMinB,kBAAkB,KAAMzlB,EAAM4lB,GAAkB6tB,EAAQ1xC,KAEzF,OAAO/B,CACT,CACA,SAASkyC,GAAal1C,GACpB,MAAMm1C,EAAWC,GAAYp1C,GAC7B,OAAOm1C,EAASA,EAAS50C,OAAS,GAAG,KAAOP,CAC9C,CACA,SAAS21C,GAAO31C,GACd,OAAOsO,GAActO,EAAK,KAC5B,CAGA,IAAI02C,GAAuB/2C,EAAQ,+CAC/Bg3C,GAAiB,CACnBziC,KAAAA,CAAMlU,GACJ,MAAM,KAAEI,GAASJ,EACjBA,EAAI8B,aACF,EAAI40C,GAAqBlQ,iBAAiBxmC,EAAI+jB,IAAIle,KAAMzF,EAAKkmC,SAAUlmC,EAAKoQ,MAAOpQ,EAAK2zB,KAAK,GAEjG,EACAhE,aAAc,CACZ4F,WAAW,EACX+Q,YAAY,GAEd1kC,aAAc,CACZ,CACEC,YAAa,+BACbC,YAAa,iFACbC,QAAS,+BACT8tB,mBAAoB,+DAMtB2mB,GAAoBj3C,EAAQ,yCAC5Bk3C,GAAuBl3C,EAAQ,+CAC/Bm3C,GAAc,CAChBh4C,OAAAA,CAAQkB,GACN,MAAM,KAAEI,GAASJ,EACXmB,EAASf,EAAKgB,IACpB,IAAIykC,EACAkR,EACJ,IAAK,MAAM92C,KAASG,EAAK2B,WACvB,GAAI60C,GAAkBp1C,MAAMskC,iBAAiB7lC,GAC3C,GAAmB,UAAfA,EAAMP,KACRmmC,EAAY5lC,MACP,IAAmB,gBAAfA,EAAMP,KAEV,CACL,MAAM8Q,EAAQvQ,EAAMgkB,KAAKzT,MACnBujB,EAAM9zB,EAAMgkB,KAAK8P,IACjBghB,EAAM,4EACZ,MAAa,MAATvkC,GAAwB,MAAPujB,EACb/zB,EAAI7B,IAAI,QAAQgC,oBAAoB40C,GAEpC/0C,EAAI+jB,IAAIumB,WACZ,CAAErmB,IAAK,CAAEzT,QAAOujB,QAChBghB,EACAvgC,MAGN,CAdEuiC,EAAkB92C,CAcpB,CAOJ,IAJA,EAAI42C,GAAqBj2C,cAAcZ,IACvC,EAAI62C,GAAqBh2C,gBAAgBb,GACzCK,EAAoBL,GACpBD,EAAoBC,IACfmB,EACH,MAAMnB,EAAI7B,IAAI,QAAQgC,oBAAoB,0CAE5C,IAAKy2C,GAAkBp1C,MAAMqgB,aAAa1gB,GACxC,MAAMnB,EAAI7B,IAAI,OAAOgC,oBAAoB,kDAE3C,GAAI42C,IAAmB,EAAIF,GAAqBh0C,aAAak0C,EAAgBt4C,OAC3E,MAAMuB,EAAI7B,IAAI,cAAcqM,MAAMvK,GAAUA,EAAMG,OAAS22C,IAAiB54C,IAAI,SAASgC,oBACvF,6DAGJ,MAAMimB,EAAazC,GAAmB3jB,GAChCgM,EAAUq2B,GAAmBriC,EAAK,GACxCwkC,GACEx4B,EACAq4B,GAAgBje,EAAYpmB,EAAII,KAAM,CACpCylC,GAAWpnC,MACXs4C,GAAiBt4C,SAGjBs4C,GACF93B,GACEmH,EACApa,EACA5D,IAAoBqnB,kBAG1B,EACAnwB,UAAW,CACTsoB,IAAAA,CAAK5nB,GACH,MAAM,KAAEI,GAASJ,EACXmB,EAASf,EAAKgB,IACdykC,EAAYzlC,EAAK2B,WAAWyI,MAC/BvK,GAAU22C,GAAkBp1C,MAAMskC,iBAAiB7lC,KAAWA,EAAMynB,SAA0B,UAAfznB,EAAMP,SACnFk3C,GAAkBp1C,MAAMG,eAAe,QAASi1C,GAAkBp1C,MAAMI,WAAW,cAClFm1C,EAAkB32C,EAAK2B,WAAWyI,MACrCvK,GAAU22C,GAAkBp1C,MAAMskC,iBAAiB7lC,IAAyB,gBAAfA,EAAMP,OAEhEif,EAAUwG,GAAWnlB,GACrBgM,EAAU7K,EAAOuB,MAAMsJ,QAC7B,GAAI/D,IAAe,CACjB,MAAMkqB,EAASgB,GAAUnnB,EAAS,SAElC6jB,GAASlR,EADkB3e,EAAII,KAAKsC,MAAM8d,mBACJ2R,EAAQ0T,EAAUpnC,OACpDs4C,IACF5kB,EAAO2C,UAAY,CAACiiB,EAAgBt4C,QAEtC0zB,EAAO0I,gBAAkB,CAACmc,EAAcv4C,KACtC,MAAMsI,EAAQmsB,GAAmB8jB,EAAc7kB,EAAOxT,SACtD,OAAOi4B,GAAkBp1C,MAAM6L,eAAe8kB,EAAOvwB,WAAY,CAACmF,EAAOtI,GAAO,CAEpF,MACEqoC,GAAa9mC,EAAK6lC,EAAUpnC,MAAO,OAC/Bs4C,GACF9lB,GACEtS,EACA3S,EACA+qC,EAAgBt4C,MAChB2J,IAAoBqnB,mBAI1BzvB,EAAIsB,QACN,GAEFyuB,aAAc,CACZC,aAAa,GAEfjuB,WAAY,CAAC,EACbC,aAAc,CACZ,CACEE,YAAa,mCACb+tB,mBAAoB,4CAGxBzuB,MAAO/B,EAAqBC,KAAO,0BAIjCu3C,GAAoBt3C,EAAQ,yCAC5Bu3C,GAAuBv3C,EAAQ,+CAC/Bw3C,GAAO1yC,OAAO,6BACd2yC,GAAoB,CACtBt4C,OAAAA,CAAQkB,IACN,EAAIk3C,GAAqBt2C,cAAcZ,IACvC,EAAIk3C,GAAqB9nB,aAAapvB,IACtC,EAAIk3C,GAAqBr2C,gBAAgBb,GACzCK,EAAoBL,GACpB,MAAM,KAAEI,GAASJ,EACX2e,EAAUgF,GAAmB3jB,GAWnC,GAViBqkC,GACf1lB,EACA3e,EAAII,KACJ6kC,GAAwBjlC,EAAII,OAErB+2C,IAAQjV,GACft8B,EAAY,aACZ,EACA+Y,GAE6B,IAA3Bve,EAAK2B,WAAWxB,OAClB,MAAMP,EAAI7B,IAAI,QAAQgC,oBACpB,wDAGJ,IAAK,MAAMF,KAASG,EAAK2B,WAAY,CACnC,GAAIk1C,GAAkBz1C,MAAMtB,uBAAuBD,GACjD,MAAMD,EAAI7B,IAAI,QAAQgC,oBACpB,iEAGHF,EAAMxB,MAAMiE,QAAU,CAAC,GAAG87B,UAAW,CACxC,GACC,EAAI0Y,GAAqBj2B,cAAc7gB,KAAKsC,QAAU,CAAC,GAAGmL,eAAgB,CAC7E,EACAvO,UAAW,CACTsoB,IAAAA,CAAK5nB,GACH,MAAM,KAAEI,GAASJ,EACX2e,EAAUwG,GAAWnlB,GACrBsrC,EAAWlrC,EAAKsC,OAChB,mBAAE8d,GAAuB8qB,EACzB+L,EAAoB/L,EAAS6L,IACnC,GAAIlvC,IAAe,CACjB,MAAM6pC,EAAkB5B,GAAelwC,GACvC8xC,EAAgBjc,WAAWvrB,KACzB2sC,GAAkBz1C,MAAM4L,oBACtBiQ,GACE,YACA4V,GACAlE,GAAwBsoB,GACxBzJ,GAAkBkE,EAAgBhuC,eAIxC2xB,GACE,SACA9W,EACA6B,EACAsxB,EAAgBjc,WAEpB,MACEyC,GAAkB3Z,EAAS6B,GAE7BxgB,EAAIsB,QACN,GAEFyuB,aAAc,CACZC,aAAa,GAEfjuB,WAAY,CAAC,EACbC,aAAc,CACZ,CACEE,YAAa,gCACb+tB,mBAAoB,+CAGxBzuB,MAAO/B,EAAqBC,KAAO,gCAIjC43C,GAAoB33C,EAAQ,yCAC5B43C,GAAuB53C,EAAQ,+CAC/B63C,GAAc,CAChB14C,OAAAA,CAAQkB,GACN,MAAO6lC,GAAa7lC,EAAII,KAAK2B,WAK7B,IAJA,EAAIw1C,GAAqB32C,cAAcZ,IACvC,EAAIu3C,GAAqBnoB,aAAapvB,IACtC,EAAIu3C,GAAqB12C,gBAAgBb,GACzCK,EAAoBL,IACf6lC,EACH,MAAM7lC,EAAI7B,IAAI,QAAQgC,oBAAoB,mCAE5C,GAAIH,EAAII,KAAK2B,WAAWxB,OAAS,IAAM+2C,GAAkB91C,MAAMskC,iBAAiBD,KAAeA,EAAUne,SAA8B,UAAnBme,EAAUnmC,KAC5H,MAAMM,EAAI7B,IAAI,QAAQgC,oBACpB,qDAGN,EACAb,UAAW,CACTsoB,IAAAA,CAAK5nB,GACH,MAAM2e,EAAUwG,GAAWnlB,IACpB6lC,GAAa7lC,EAAII,KAAK2B,YACvB,MAAEtD,GAAUonC,EACZrlB,EAAqB/hB,EAAMiE,OAAO8d,mBAClCmV,EAAY2hB,GAAkB91C,MAAM4L,oBACxCkqC,GAAkB91C,MAAM6L,eACtBiqC,GAAkB91C,MAAMwb,iBAAiBs6B,GAAkB91C,MAAMI,WAAW,WAAY01C,GAAkB91C,MAAMI,WAAW,QAC3H,CAACnD,KAGDqJ,IACF9H,EAAIuuB,aAAaoH,GAEjBF,GAAa,SAAU9W,EAAS6B,EAAoBmV,GAEtD31B,EAAIsB,QACN,GAEFyuB,aAAc,CACZC,aAAa,GAEfjuB,WAAY,CAAC,EACbC,aAAc,CACZ,CACEE,YAAa,qCACb+tB,mBAAoB,4CAGxBzuB,MAAO/B,EAAqBC,KAAO,0BAIjC+3C,GAAoB93C,EAAQ,yCAC5B+3C,GAAuB/3C,EAAQ,+CAC/Bg4C,GAA4B,0EAC5BC,GAAiB,CACnB1jC,KAAAA,CAAMlU,GACJ,MAAM,KAAEI,GAASJ,GACX,KAAEM,GAASF,EAAKE,KACtB,GAAIA,EAAKC,OAAQ,CACf,IAAIgsB,EAAO,GACX,IAAK,MAAMrD,KAAS5oB,EAAM,CACxB,GAAmB,cAAf4oB,EAAM7nB,KACR,MAAMrB,EAAI+jB,IAAIle,KAAKke,IAAIumB,WACrBphB,EACA,mFAAqFyuB,GACrFr8B,aAGJiR,GAAQrD,EAAMzqB,KAChB,CACA,MAAM+R,EAAQlQ,EAAK,IAAIkQ,MACjBujB,EAAMzzB,EAAKA,EAAKC,OAAS,IAAIwzB,IAC7Bob,GAAiB,EAAIuI,GAAqBlR,iBAAiBxmC,EAAI+jB,IAAIle,KAAM0mB,EAAM/b,EAAOujB,GACtF8jB,EAAUJ,GAAkBj2C,MAAMmoB,wBACtC,GACA8tB,GAAkBj2C,MAAMooB,eAAeulB,GACvChqC,EAAiBgqC,EAAgB2I,KAEnC13C,EAAK2B,WAAWuI,KAAKmtC,GAAkBj2C,MAAMG,eAAe,QAASk2C,IACrEz3C,EAAKE,KAAKA,KAAO,EACnB,CACF,EACAxB,OAAAA,CAAQkB,GACN,MAAM,KAAEI,GAASJ,EAKjB,IAJA,EAAI03C,GAAqB92C,cAAcZ,IACvC,EAAI03C,GAAqB72C,gBAAgBb,GACzCK,EAAoBL,IACpB,EAAI03C,GAAqB32C,uBAAuBf,GAC5CI,EAAKgB,IACP,MAAMpB,EAAI+jB,IAAIumB,WACZlqC,EAAKgB,IACL,8DAAgEu2C,IAGpE,IAAII,GAAgB,EACpB,IAAK,MAAM93C,KAASG,EAAK2B,WAAY,CACnC,GAAmB,mBAAf9B,EAAMoB,MAA4C,UAAfpB,EAAMP,KAQ3C,MAAMM,EAAI+jB,IAAIumB,WACZrqC,EACA,qDAAuD03C,IATzD,GAAII,EACF,MAAM/3C,EAAI+jB,IAAIumB,WAAWrqC,EAAO,sCAElC83C,GAAgB,GACf93C,EAAMxB,MAAMiE,QAAU,CAAC,GAAG87B,UAAW,IACrC,EAAIkZ,GAAqBz2B,cAAc7gB,KAAKsC,QAAU,CAAC,GAAGmL,eAAgB,CAO/E,CACKkqC,GACHhT,GAAeE,GAAwB7kC,GAE3C,EACAd,UAAW,CACTsoB,IAAAA,CAAK5nB,GACH,MAAM,KAAEI,GAASJ,GACV6lC,GAAazlC,EAAK2B,WACzB,IAAK8jC,EAEH,YADA7lC,EAAIsB,SAGN,MAAMqd,EAAUwG,GAAWnlB,IACrB,MAAEvB,GAAUonC,EACZrlB,EAAqB/hB,EAAMiE,OAAO8d,mBACxC,GAAIvY,IAAe,CACjB,MAAQxJ,MAAOs4B,GAAW8O,EACpBmS,EAAcP,GAAkBj2C,MAAM+1B,qBAAqBR,IAAW0gB,GAAkBj2C,MAAM6zB,0BAA0B0B,GAC9H,IAAIkhB,EAAa,KACjB,GAAID,IAAiBjhB,EAAO1mB,QAAS0mB,EAAOzO,UAC1C,GAAImvB,GAAkBj2C,MAAM8zB,iBAAiByB,EAAOz2B,MAAO,CACzD,IAAI43C,GAAiB,EACrB,IAAK,MAAMhvB,KAAS6N,EAAOz2B,KAAKA,KAC9B,GAAIm3C,GAAkBj2C,MAAM22C,cAAcjvB,GAAQ,CAChDgvB,GAAiB,EACjB,KACF,CAEFD,EAAaC,EAAiBnhB,EAAOz2B,KAAOy2B,EAAOz2B,KAAKA,IAC1D,MACE23C,EAAaR,GAAkBj2C,MAAM4L,oBAAoB2pB,EAAOz2B,MAGpEm1B,GACE,SACA9W,EACA6B,EACAy3B,GAAcR,GAAkBj2C,MAAM4L,oBACpCqqC,GAAkBj2C,MAAM6L,eAAe0pB,EAAQihB,EAAc,GAAK,CAAC/kB,MAGzE,MACEqF,GAAkB3Z,EAAS6B,GAE7BxgB,EAAIsB,QACN,GAEFwmB,MAAM,EACNiI,aAAc,CACZkjB,MAAM,EACNW,oBAAoB,GAEtB7xC,WAAY,CAAC,EACbC,aAAc,CACZ,CACEE,YAAa,gCACb+tB,mBAAoB,+CAGxBzuB,MAAO/B,EAAqBC,KAAO,6BAErC,SAASo4C,GAAkB13C,GACzB,OAAQA,EAAKiB,MACX,IAAK,iBACH,OAAOjB,EAAKg4C,MACd,IAAK,sBACL,IAAK,qBACL,IAAK,0BACL,IAAK,cACL,IAAK,eACL,IAAK,qBACH,OAAO5zC,EACT,IAAK,kBACH,OAAO,EACT,QACE,OAAO,EAEb,CAGA,IAAI6zC,GAAoB14C,EAAQ,yCAC5B24C,GAAuB34C,EAAQ,+CAC/B44C,GAAiB,CACnBrkC,KAAAA,CAAMlU,GACJ,MAAM,KACJI,EACA2jB,KAAK,KAAEle,IACL7F,EACEsmC,EAAWlmC,EAAKkmC,SAChB/Z,EAAO+Z,EAASn/B,QAAQ,aAAc,IAAIo/B,OAC1C/1B,EAAQpQ,EAAKV,KAAK8Q,OAAS81B,EAAS/lC,OAASgsB,EAAKhsB,QACxD,IAAID,GAAO,EAAIg4C,GAAqB9R,iBAAiB3gC,EAAM0mB,EAAM/b,EAAOA,EAAQ+b,EAAKhsB,QACjE,IAAhBD,EAAKC,QAAgB83C,GAAkB72C,MAAM8zB,iBAAiBh1B,EAAK,MACrEA,EAAOA,EAAK,GAAGA,MAEjBN,EAAI8B,YAAYu2C,GAAkB72C,MAAMilC,eAAenmC,GAAM,EAAM,UACrE,EACAyvB,aAAc,CACZ4F,WAAW,EACX+Q,YAAY,GAEd1kC,aAAc,CACZ,CACEC,YAAa,qBACbC,YAAa,6FACb+tB,mBAAoB,wDAMtBuoB,GAAoB74C,EAAQ,yCAC5B84C,GAAuB94C,EAAQ,+CAC/B+4C,GAAiB,CACnBxkC,KAAAA,CAAMlU,GACJ,MAAM,KACJI,EACA2jB,KAAK,KAAEle,IACL7F,EACEsmC,EAAWlmC,EAAKkmC,SAChB/Z,EAAO+Z,EAASn/B,QAAQ,aAAc,IAAIo/B,OAC1C/1B,EAAQpQ,EAAKV,KAAK8Q,OAAS81B,EAAS/lC,OAASgsB,EAAKhsB,QACxD,IAAID,GAAO,EAAIm4C,GAAqBjS,iBAAiB3gC,EAAM0mB,EAAM/b,EAAOA,EAAQ+b,EAAKhsB,QACjE,IAAhBD,EAAKC,QAAgBi4C,GAAkBh3C,MAAM8zB,iBAAiBh1B,EAAK,MACrEA,EAAOA,EAAK,GAAGA,MAEjBN,EAAI8B,YAAY02C,GAAkBh3C,MAAMilC,eAAenmC,GAAM,GAC/D,EACAyvB,aAAc,CACZ4F,WAAW,EACX+Q,YAAY,GAEd1kC,aAAc,CACZ,CACEC,YAAa,qBACbC,YAAa,+EACb+tB,mBAAoB,wDAMtB0oB,GAAoBh5C,EAAQ,yCAC5Bi5C,GAAuBj5C,EAAQ,+CAC/Bk5C,GAAsBx6C,EAAQsB,EAAQ,6DACtCm5C,GAAez6C,EAAQsB,EAAQ,gDAC/Bo5C,GAAgB,kCAChBC,GAA2B,wEAC3BC,GAAgB,CAClBn6C,OAAAA,CAAQkB,IACN,EAAI44C,GAAqBh4C,cAAcZ,IACvC,EAAI44C,GAAqB/3C,gBAAgBb,IACzC,EAAI44C,GAAqB73C,uBAAuBf,GAChD,MAAM,KAAEI,GAASJ,EACXk5C,EAAMH,GAActyC,KAAKrG,EAAKkmC,UAAY,MAAM,IAAI/2B,MAAM,GAChE,IAAK,MAAMtP,KAASG,EAAK2B,WACvB,GAAmB,MAAf9B,EAAMuQ,OAAgC,mBAAfvQ,EAAMoB,MAA4C,UAAfpB,EAAMP,MAAyC,kBAArBO,EAAMxB,MAAM4C,MAA4BpB,EAAMxB,MAAMA,QAAUy6C,EAGtJ,MAAMl5C,EAAI+jB,IAAIumB,WACZrqC,EAAMxB,MACN,gDAAkDu6C,IAGtD,IAAK,MAAM9vB,KAAS9oB,EAAKE,KAAKA,KAC5B,GAAmB,cAAf4oB,EAAM7nB,KACR,MAAMrB,EAAI+jB,IAAIumB,WACZphB,EACA,0DAA4D8vB,IAIlE,GAAI54C,EAAKE,KAAKA,KAAKC,OAAS,EAC1B,MAAMP,EAAI+jB,IAAIumB,WACZlqC,EAAKV,KACL,0DAA4Ds5C,GAGlE,EACA15C,SAAAA,CAAUU,GACR,MAAM,KACJI,EACA2jB,KAAK,KAAEle,IACL7F,GACE,SAAEiG,EAAQ,WAAEkzC,GAAetzC,EAAKK,KACtC,IAAIgzC,EAAMH,GAActyC,KAAKrG,EAAKkmC,UAAY,MAAM,IAAM,OACtDlmC,EAAKgB,MAAQ,aAAawN,KAAKsqC,KACjCA,EAAM,UAAYA,GAEpB,MAAME,EAAYh5C,EAAKE,KAAKA,KAAK,IAC3B,yBAAE+4C,GAA6BtxC,IAC/ByI,GAAQ,EAAIooC,GAAqBU,UAAUzzC,EAAMuzC,GACjDrlB,GAAM,EAAI6kB,GAAqBW,QAAQ1zC,EAAMuzC,GACnD,IACItsC,EADAyf,EAAO6sB,EAAU36C,MAErB,GAAI46C,GAA4BF,GAAwB,OAAV3oC,GAA0B,OAARujB,EAAc,CAC5E,MAAMylB,EAAc,IAAIX,GAAoBnxB,QAAQ7hB,EAAK0mB,KAAM,CAAEtmB,aACjEuzC,EAAYl4C,OAAO,EAAGkP,GACtBgpC,EAAYl4C,OAAOyyB,EAAKluB,EAAK0mB,KAAKhsB,QAClCuM,EAAM0sC,EAAYC,YAAY,CAC5BvoC,OAAQjL,EACRyzC,gBAAgB,IAEC,WAAfP,GAA0C,SAAfA,IAC7B5sB,GAAQ,0BACOzf,EAAI6sC,YACA,WAAfR,IACFrsC,OAAM,GAGZ,CACA,MAAM8sC,EAAaP,IAA2BpzC,EAAU,CACtD4zC,YAAa,KAAKf,GAAapxB,QAAQoyB,SAAS7zC,GAAYizC,IAC5D3sB,OACAzf,QAEE8sC,IACGx5C,EAAKgB,IAICu3C,GAAkBn3C,MAAMqgB,aAAazhB,EAAKgB,MACnD,EAAIw3C,GAAqB33B,cAAc7gB,KAAKE,KAAKgK,KAC/CquC,GAAkBn3C,MAAMwL,kBACtB,CAAC2rC,GAAkBn3C,MAAMu4C,uBAAuB35C,EAAKgB,MACrDu3C,GAAkBn3C,MAAME,cAAck4C,MAI1C,EAAIhB,GAAqB33B,cAAc7gB,KAAKE,KAAKgK,KAC/CquC,GAAkBn3C,MAAMuoB,oBAAoB,QAAS,CACnD4uB,GAAkBn3C,MAAMwoB,mBACtB5pB,EAAKgB,KACL,EAAIw3C,GAAqB/b,eAAeh3B,EAAM+zC,EAAY,cAfhE,EAAIhB,GAAqB33B,cAAc7gB,KAAKE,KAAKgK,KAC/CquC,GAAkBn3C,MAAMwL,kBAAkB,GAAI2rC,GAAkBn3C,MAAME,cAAck4C,MAoB1F55C,EAAIsB,QACN,EACAyuB,aAAc,CACZjI,MAAM,EACNmrB,MAAM,EACNvM,YAAY,EACZkN,oBAAoB,GAEtB7xC,WAAY,CAAC,GAIXi4C,GAAoBr6C,EAAQ,yCAC5Bs6C,GAAuBt6C,EAAQ,+CAC/Bu6C,GAAez1C,OAAO,uBACtB01C,GAAc,CAChBr7C,OAAAA,CAAQkB,IACN,EAAIi6C,GAAqB7qB,aAAapvB,IACtC,EAAIi6C,GAAqBr5C,cAAcZ,IACvC,EAAIi6C,GAAqBp5C,gBAAgBb,IACzC,EAAIi6C,GAAqBn5C,oBAAoBd,GAC7CD,EAAoBC,GACpB6nC,GAAqB7nC,GACrB,MAAM2e,EAAUgF,GAAmB3jB,GAOnC,GANiBqkC,GACf1lB,EACA3e,EAAII,KACJ6kC,GAAwBjlC,EAAII,OAErB85C,IAAgBhY,GAAc,QAAS,EAAavjB,IACxD3e,EAAII,KAAKE,KAAKA,KAAKC,OACtB,MAAMP,EAAI7B,IAAI,QAAQgC,oBAAoB,wCAE5CsjB,GAAazjB,EAAI7B,IAAI,QACvB,EACAmB,UAAWuoB,GAAkB,CAC3BC,KAAM,CACJR,KAAAA,CAAMtnB,GACJ,IAAKklB,GAAkBllB,EAAI7B,IAAI,SAE7B,YADA6B,EAAIsB,SAGN,MACM0kC,EAAc9gB,GADJllB,EAAI7B,IAAI,SAExBonB,GAAwBygB,GAAa,GACrC1X,GAAYtuB,EACd,EACA4nB,IAAAA,CAAK5nB,GACH,MAAM,KAAEI,GAASJ,EACX2e,EAAUwG,GAAWnlB,GACrBsrC,EAAWlrC,EAAKsC,MAChBkjC,EAAU5lC,EAAI7B,IAAI,QAClB2zC,EAAkB5B,GAAelwC,GACjCkmC,EAAWoF,EAAS4O,IACpBlJ,EAAcC,GAClBa,EAAgBhuC,YAEdktC,GACFc,EAAgBhuC,WAAWs2C,OACzBtI,EAAgBhuC,WAAWq4B,QAAQ6U,GACnC,GAGJloB,GAAU9oB,GACV+oB,GAA0B6c,GAC1B5lC,EAAIuuB,aAAaujB,EAAgBjc,YACjC71B,EAAI8B,YACFk4C,GAAkBx4C,MAAM4L,oBACtBiQ,GACE,aACAgI,GAAqB1G,GACrBoQ,GAAwBmX,GACxB8K,GAAavyC,MACbmvC,GAAkBkE,EAAgBhuC,eAGtC,GAAGU,MACP,GAEFujB,IAAK,CACHT,KAAAA,CAAMtnB,GACJ,MACMgmC,EAAc9gB,GADJllB,EAAI7B,IAAI,SAExBonB,GAAwBygB,GAAa,GACrC14B,GAAMtN,EAAK,IACXssB,GAAatsB,EACf,EACA4nB,IAAAA,CAAK5nB,GACH,MAAM,KAAEI,GAASJ,EACXsrC,EAAWlrC,EAAKsC,MAChBwjC,EAAWoF,EAAS4O,IACpB15B,EAAqB8qB,EAAS9qB,mBAC9BsxB,EAAkB5B,GAAelwC,GACjCgxC,EAAcC,GAClBa,EAAgBhuC,YAEdktC,GACFc,EAAgBhuC,WAAWs2C,OACzBtI,EAAgBhuC,WAAWq4B,QAAQ6U,GACnC,GAGJ,MAAMryB,EAAUwG,GAAWnlB,GACrBgmC,EAAc9gB,GAAkBllB,EAAI7B,IAAI,SACxCg0B,EAASH,GAAUrT,EAASunB,EAAU,OAC5C/T,EAAOzlB,MAAQ,IACN2Q,GACL,YACA0R,GAAwBmX,GACxB8T,GAAkBx4C,MAAMI,WAAWokC,EAAYtmC,OAG/CoyC,EAAgBjc,WAAWt1B,QAC7Bk1B,GACE,SACA9W,EACA6B,EACAsxB,EAAgBjc,aAGpB,EAAIokB,GAAqBh5B,cAAc7gB,KAAKE,KAAKgK,KAC/C0vC,GAAkBx4C,MAAM4L,oBAAoBiQ,GAAY,iBAE1DwS,GACElR,EACA6B,EACA2R,EACAyb,GAAkBkE,EAAgBhuC,aAEpCquB,EAAOrC,2BAA6B,KAAM,EAC1C9vB,EAAIsB,QACN,KAGJS,WAAY,CAAC,EACbC,aAAc,CACZ,CACEE,YAAa,sEACb+tB,mBAAoB,4CAGxBzuB,MAAO/B,EAAqBC,KAAO,0BAIjC26C,GAAe,CACjBz6C,SAAUH,EAAqBG,SAC/B,UAAWc,EACX,UAAWilC,GACX,WAAYU,GACZ,UAAWW,GACX,UAAWK,GACX,WAAYwK,GACZ,WAAYI,GACZ,YAAaoE,GACb,SAAUC,GACV,WAAYnE,GACZ,QAASxD,GACT,iBAAkB6D,GAClB,gBAAiBc,GACjB,eAAgBW,GAChB,OAAQI,GACR,OAAQK,GACR,WAAYiC,GACZ,QAASG,GACT,cAAeM,GACf,QAASI,GACT,WAAYroB,GACZ,WAAYyoB,GACZ,WAAYW,GACZ,WAAYG,GACZ,UAAWO,GACX,QAASkB,IAIPG,GAAgB,CAClBh7C,UAAW,CACTgoB,KAAAA,CAAMizB,GACJ,MAAMA,EAAMp6C,oBACV,6CAEJ,IAKAq6C,GAAkB,CACpBl7C,UAAW,CACTsoB,IAAAA,CAAK6yB,GACHA,EAAQn5C,QACV,IAKAo5C,GAAsB,CACxBp7C,UAAW,CACTgoB,KAAAA,CAAM7E,GACJ,MAAMA,EAAKtiB,oBACT,wDAEJ,IAKAw6C,GAAwB,CAC1Br7C,UAAW,CACTsoB,IAAAA,CAAKgzB,GACC9yC,KACFolB,GAAQ0tB,EAAa,KAAKA,EAAax6C,KAAK3B,SAE9Cm8C,EAAat5C,QACf,IAKAu5C,GAAoBl7C,EAAQ,yCAC5Bm7C,GAAuBn7C,EAAQ,+CAC/Bo7C,GAAmB,CACrBj8C,OAAAA,CAAQ4mB,GACN,GAAIA,IAAO9c,GAAU8c,GACnB,OAEF,MAAMs1B,EAAY1yC,GAAaod,GAC/B,GAAIs1B,IAAcA,EAAUrI,sBAAwBqI,EAAU3xB,oBAAgD,WAA1B2xB,EAAU56C,KAAK7B,QACjG,OAEF,GAAIunC,GAAiBkV,MAAe,EAAIF,GAAqBn5B,aAAaq5B,EAAUvyC,aAAe,YAAYmG,KAAKosC,EAAU56C,KAAKV,OAAS4O,GAAc0sC,EAAUvyC,WAAY,WAAa6F,GAAc0sC,EAAUvyC,WAAY,cAAgB6F,GAAc0sC,EAAUvyC,WAAY,QACnR,OAEF,MAAM,KAAErI,GAASslB,EACX/G,EAAUwG,GAAWO,GACrBhjB,EAAQtC,EAAKsC,QAAU,CAAC,GACxB,UACJsD,EACAE,MAAM,SAAED,KACN,EAAI60C,GAAqBz2C,WACvBxF,EAAQ6D,EAAMhD,KAAOkG,EACzB8f,EAAGtlB,KAAKghB,IAAI1hB,OAASomC,GAAiBkV,GAAaA,EAAU56C,KAAKsnB,QAAUmzB,GAAkBr5C,MAAM+pC,aAClGyP,EAAUvyC,WAAWf,IAAI,OAASszC,EAAUvyC,WAAWtK,IAAI,OAAS68C,EAAUvyC,WAAWtK,IAAI,SAC3F68C,EAAU56C,KAAKV,KAAOm7C,GAAkBr5C,MAAMy5C,qBAAqBv1B,EAAGlgB,SAAWq1C,GAAkBr5C,MAAMqgB,aAAa6D,EAAGlgB,OAAO4b,IAAMsE,EAAGlgB,OAAO4b,GAAG1hB,KAAOm7C,GAAkBr5C,MAAM05C,eAAe96C,IAASy6C,GAAkBr5C,MAAMqgB,aAAazhB,EAAKnC,KAAOmC,EAAKnC,IAAIyB,KAAO,cAEjRgD,EAAMic,QAAUA,EAChBjc,EAAMioB,YAAa,EAAImwB,GAAqB5kB,eAC1ClwB,EACAC,EACA,GAAG0Y,EAAQyC,MAAMviB,EAAM0Q,MAAM,KAEjC,GAEF,SAASu2B,GAAiBv9B,GACxB,QAAOA,GAAQA,EAAMu9B,kBACvB,CAGA,IAAIqV,GAAuBx7C,EAAQ,+CAC/By7C,GAA6B,CAC/Bt8C,OAAAA,CAAQu8C,GACN,MAAM,KAAEj7C,GAASi7C,GACX,OAAEnqC,GAAW9Q,GACb,MAAE3B,GAAUyS,EACZoqC,GAAY,EAAIH,GAAqBr4B,kBAAkBu4B,EAAY58C,GACzE,GAAI68C,EAAW,CACbl7C,EAAKsC,QAAU,CAAC,EAChBtC,EAAKsC,MAAM44C,UAAYA,EACvB,MAAMC,EAAOF,EAAWt3B,IAAIle,KAAK4H,SAASC,MAAM6tC,KAC3CA,EAAKC,SAASF,IACjBC,EAAKjxC,KAAKgxC,EAEd,CACF,EACAh8C,UAAW,CACTsoB,IAAAA,CAAKyzB,GACH,MAAM,KAAEj7C,GAASi7C,GACX,MAAE34C,GAAUtC,EACZk7C,EAAY54C,GAAO44C,UACrBA,IACFl7C,EAAK8Q,OAAOzS,MAAQ68C,EAExB,IAKAG,GAAoB97C,EAAQ,yCAIhC,SAAS+7C,GAAcC,GACrB,MAAMrsB,EAAYqsB,EAAYlzC,WAAWmzC,kBAAoBD,EAAYlzC,WAAWA,WACpF,GAAI6mB,GAAaphB,GAAUohB,GACzB,OAAQA,EAAUlvB,KAAKV,KAAKjB,OAC1B,IAAK,eACL,IAAK,cACL,IAAK,aACH,OAAO,EAGb,OAAO,CACT,CAZwBkB,EAAQ,yCAehC,IAAIk8C,GAAgBp3C,OAAO,4BACvBq3C,GAAer3C,OAAO,gCACtBs3C,GAAsB,CACxBj9C,OAAAA,CAAQ68C,GACN,GAAID,GAAcC,GAAc,OAChC,MAAM,KAAEv7C,GAASu7C,EACX1V,EAAaxjC,EAASrC,EAAK3B,QAC3B,UAAEkE,EAAS,SAAEC,GAAaqjC,EAChC,IAAMtjC,IAAcvC,EAAKiqC,SAAU2R,GAAQp5C,GAAa,CACtD,MAAM+b,EAAUgF,GAAmBg4B,GAC7B7sB,GAAe1uB,EAAKsC,QAAU,CAAC,GAAGm5C,IAAiB3Z,GACvD,QACA,EACAvjB,IA8ER,SAA4Bg9B,GAC1B,MAAMM,EAAmBN,EAAYv7C,KAAKsC,MAC1C,IAAI8uB,EAAOmqB,EAAYpS,iBACvB,KAAO/X,EAAKpxB,MAAM,CAChB,MAAM87C,EAAcl2B,GAClBwL,EACA,WAEF,GAAoB,OAAhB0qB,EAEG,IAAoB,IAAhBA,GAAgD,IAAhBA,GAAmD,IAAhBA,EAC5E,OAAOD,EAAiBH,IAAgB,EAExC,KACF,CALEtqB,EAAOA,EAAK+X,gBAMhB,CACA,IAAK/X,EAAKpxB,MAAQq7C,GAAkBj6C,MAAMsH,UAAU6yC,EAAYlzC,YAC9D,OAAOwzC,EAAiBH,IAAgB,EAE1C,IAAIpwC,EAAOiwC,EAAY/F,iBACvB,KAAOlqC,EAAKtL,MAAM,CAChB,MAAM87C,EAAcl2B,GAClBta,EACA,aAEF,GAAoB,OAAhBwwC,EAEG,IAAoB,IAAhBA,GAAgD,IAAhBA,GAAmD,IAAhBA,EAC5E,OAAOD,EAAiBH,IAAgB,EAExC,KACF,CALEpwC,EAAOA,EAAKkqC,gBAMhB,CACA,IAAKlqC,EAAKtL,MAAQq7C,GAAkBj6C,MAAMsH,UAAU6yC,EAAYlzC,YAC9D,OAAOwzC,EAAiBH,IAAgB,EAEnCG,EAAiBH,IAAgB,CAC1C,CAjHMK,CAAmBR,GACnBp8B,GAA8BZ,EAASmQ,EAAamX,EACtD,CACF,EACA3mC,UAAW,CACTsoB,IAAAA,CAAK+zB,GACH,GAAID,GAAcC,GAAc,OAChC,MAAM,KAAEv7C,GAASu7C,GACX,MAAEl9C,GAAU2B,EACZ6lC,EAAaxjC,EAAShE,IACtB,UAAEkE,EAAS,SAAEC,GAAaqjC,EAChC,GAAItjC,GAAaq5C,GAAQp5C,GAEvB,YADA+4C,EAAYr6C,SAGd,MAAMmyC,EAAS3rC,IACT6jC,EAASze,GAAQyuB,GACjBj5C,EAAQtC,EAAKsC,OAAS,CAAC,EACvBosB,EAAcpsB,EAAMm5C,IACpBO,EAAe3I,GAAU9wC,GAAavC,EAAKiqC,OAC3CgS,EAASD,EAAeh8C,EAAKiqC,OAAS,YAAc,WAAajqC,EAAKiqC,OAAS,OAAS,OACxF1rB,EAAUwG,GAAWw2B,GACrBhP,EAAwB7d,GAAe9O,GAA0BrB,EAASmQ,GAC1EwtB,EAAc55C,EAAMo5C,IACtBn5C,GAAay5C,EACfzQ,CAAM,GAAG9tB,KAAiBw+B,GAAQz5C,MAEd,IAAhB05C,GACE7I,GAAU9G,KACkB,IAA1BA,EACFhB,CAAM,MAENA,CAAM,GAAGtuB,GAAY,mBAAoBuL,GAAkB+jB,OAG/Dr/B,GAAMquC,EAAa,KACM,IAAhBW,EACThvC,GAAMquC,EAAa,KAEdlI,GAAQ9H,CAAM,IACnBr+B,GAAMquC,EAAa,KAEjBlI,GACF9H,CAAM,GAAGtuB,GAAYg/B,EAAQ59C,KACzBqwB,GACFD,GAAS8sB,EAAa7sB,EAAa6d,IAGrClX,GACE,SACAtQ,GAAWw2B,GACX1V,EAAWzlB,mBACXi7B,GAAkBj6C,MAAM4L,oBACX,SAAXivC,EAAoBh/B,GAClB,OACAo+B,GAAkBj6C,MAAMwb,iBACtBiW,GACAlE,GAAwBD,IACxB,GAEFrwB,GACE4e,GACF,OACA4V,GACAx0B,EACAswB,GAAwBD,OAMlCxC,GAAaqvB,GACbA,EAAYr6C,QACd,IAyCJ,SAAS06C,GAAQv9C,GACf,OAAgB,MAATA,IAA2B,IAAVA,CAC1B,CAGA,IAAI89C,GAAoB58C,EAAQ,yCAC5B68C,GAAiD,IAAI72C,QACrD82C,GAAgC,CAClC97C,OAAAA,CAAQiB,GACN,MAAQlC,KAAMb,GAAU+C,EAAWxB,KACnC,IAAIwB,EAAWmF,MAAM21C,WAAW79C,IAEzB,QADCA,EACN,CACE,IAAI09C,GAAkB/6C,MAAMsiC,mBAAmBliC,EAAW4D,UAAW+2C,GAAkB/6C,MAAMqgB,aAAajgB,EAAW4D,OAAO6qB,WAAiD,WAApCzuB,EAAW4D,OAAO6qB,SAAS3wB,KAGlK,MAAMkC,EAAWzB,oBACf,qDAHFyB,EAAW6G,WAAW3G,YAAYy6C,GAAkB/6C,MAAMI,WAAW,WAMlE,CAEX,EACA9C,OAAAA,CAAQ8C,GACN,MAAQlC,KAAMb,GAAU+C,EAAWxB,KAC/BwB,EAAWmF,MAAM21C,WAAW79C,KAClB,YAAVA,EACFskC,GAAmBvhC,GACA,YAAV/C,IACO8kB,GAAmB/hB,GAC3BkjB,gBAAiB,EACzBqe,GAAmBvhC,IAEvB,EACAtC,SAAAA,CAAUsC,GACR,MAAQlC,KAAMb,GAAU+C,EAAWxB,KACnC,IAAIwB,EAAWmF,MAAM21C,WAAW79C,GAChC,OAAQA,GACN,IAAK,UACCiJ,IACFlG,EAAWE,YACTy6C,GAAkB/6C,MAAM6L,eAAe6P,GAAc,WAAY,KAGnEtb,EAAWE,YACTy6C,GAAkB/6C,MAAMwb,iBAAiBiW,GAAiBspB,GAAkB/6C,MAAMI,WAAW,aAGjG,MACF,IAAK,UACH,GAAIkG,IACFlG,EAAWE,YACTy6C,GAAkB/6C,MAAM6L,eACtBkvC,GAAkB/6C,MAAMmoB,wBACtB,GACA4yB,GAAkB/6C,MAAMooB,eAAe,CACrC2yB,GAAkB/6C,MAAMm7C,eACtBJ,GAAkB/6C,MAAMk3B,cAAc6jB,GAAkB/6C,MAAMI,WAAW,SAAU,CACjF26C,GAAkB/6C,MAAME,cAAc,gDAK9C,SAGC,CACL,MAAMid,EAAUwG,GAAWvjB,GACrBqiC,EAAWt7B,GAAY/G,GAC7B,IACIg7C,EADAC,EAAuBL,GAA+Br+C,IAAIwgB,GAE1Dk+B,EACFD,EAASC,EAAqB1+C,IAAI8lC,IAElC4Y,EAAuC,IAAIz2C,IAC3Co2C,GAA+B51C,IAAI+X,EAASk+B,IAEzCD,IACHA,EAASC,EAAqB3wC,KAC9B2wC,EAAqBj2C,IAAIq9B,EAAU2Y,GACnCnnB,GACE,SACA9W,EACAslB,EAAS7jC,KAAKsC,OAAO8d,mBACrB+7B,GAAkB/6C,MAAM4L,oBACtBmvC,GAAkB/6C,MAAM6L,eAAe6P,GAAc,oBAAqB,CACxE+V,GACAspB,GAAkB/6C,MAAMib,eAAemgC,OAG3C,IAGJh7C,EAAWE,YACTy6C,GAAkB/6C,MAAM6L,eAAe6P,GAAc,kBAAmB,CACtE+V,GACAspB,GAAkB/6C,MAAMib,eAAemgC,KAG7C,EAEN,GAIEE,GAAoB,CACtBh+C,OAAAA,CAAQi+C,GACN,IAAKA,EAAU38C,KAAKkpB,OAClB,MAAMyzB,EAAU58C,oBACd,yDAGJkkC,GACE1gB,GAAmBo5B,GACnBA,EAAU38C,KACV28C,EAAU38C,KAAKE,KAEnB,EACAhB,UAAW,CACTsoB,IAAAA,CAAKm1B,GACH,MAAM,KAAE38C,GAAS28C,EACXtJ,EAAS3rC,IACX1H,EAAK7B,QAAU6B,EAAK7B,UAAYk1C,EAAS,SAAW,UACtDsJ,EAAUz7C,SAGRmyC,IAEF/uC,EAAgBtE,EAAM,OAAQu6B,IAC9BoiB,EAAUxzB,oBAAoBnpB,EAAKE,MAEvC,IAKA08C,GAAoBr9C,EAAQ,yCAC5Bs9C,GAAuBt9C,EAAQ,+CAI/Bu9C,IADoBv9C,EAAQ,yCACLA,EAAQ,gDAC/Bw9C,GAAwB,CAC1Br+C,QAAS,CACPwoB,KAAAA,CAAMtnB,IACJ,EAAIk9C,GAAqB9tB,aAAapvB,IACtC,EAAIk9C,GAAqBt8C,cAAcZ,GACvC,MAAMM,EAAON,EAAI7B,IAAI,QAGrB,GAFAslB,GAAanjB,GACbq9B,GAAsBr9B,EAAM,KACvB,EAAI48C,GAAqBE,eAAep9C,GAC3C,MAAMA,EAAI7B,IAAI,QAAQgC,oBAAoB,2CAE9C,GAEFb,UAAW,CACTgoB,KAAAA,CAAMtnB,GACA8H,KACFwmB,GAAYtuB,EAEhB,EACA4nB,IAAAA,CAAK5nB,GACC8H,MACFghB,GAAU9oB,GACV+oB,GAA0B/oB,EAAI7B,IAAI,SAEtC,IAKAk/C,GAAoB19C,EAAQ,yCAC5B29C,GAAuB39C,EAAQ,+CAC/B49C,GAAel/C,EAAQsB,EAAQ,gDAC/B69C,GAAqB/4C,OAAO,0BAC5Bg5C,GAA2Bh5C,OAAO,2BAClCi5C,GAA8Bj5C,OAChC,sCAEEk5C,GAAqB,CACvB7+C,QAAS,CACPwoB,KAAAA,CAAMtnB,GAIJ,IAHA,EAAIs9C,GAAqBM,6BAA6B59C,GACtD6nC,GAAqB7nC,KACA,EAAIs9C,GAAqBO,gBAAgB79C,GAC3C,CACjB,MAAMipC,EAAUh7B,GAAWjO,GAC3B,GAAIipC,GAAWjpC,EAAI+G,MAAM21C,WAAWzT,GAClC,MAAMjpC,EAAI7B,IAAI,QAAQgC,oBACpB,kFAAkF8oC,yBAA+BA,EAAQ6U,OAAO,GAAGC,cAAgB9U,EAAQ15B,MAAM,SAGrK,MAAMvP,EAAI7B,IAAI,QAAQgC,oBAAoB,6CAC5C,CACA,MAAMwe,EAAUgF,GAAmB3jB,GAC7B4lC,EAAU5lC,EAAI7B,IAAI,QAClBmtC,EAAWtrC,EAAII,KAAKsC,QAAU,CAAC,EAC/Bs7C,EAAoB1S,EAASkS,IAAsBtb,GACvD,cACA,EACAvjB,GAEIs/B,EAA4B,IAAIjjC,IAAI,CAACswB,IAC3C7nB,GAAamiB,GACbjI,GAAsBiI,EAAS,GAC/B,MAAMziB,GAAY,EAAIm6B,GAAqBl6B,gBAAgBpjB,GAC3D,IAAKmjB,EACH,MAAMnjB,EAAI7B,IAAI,QAAQgC,oBAAoB,mCAE5C,MAAM8mC,EAAa5E,GAAmBriC,EAAK,GAI3C,GAHIinC,IACFA,EAAWnU,YAAcwY,EAASmS,IAA4Bvb,GAAc,eAAgB,EAAavjB,IAEvGwE,EAAUjd,KAAKD,WAAajG,EAAI+jB,IAAIle,KAAKK,KAAKD,UAEhD,GADAo+B,GAAgB1lB,EAAS3e,EAAII,KAAM6kC,GAAwBjlC,EAAII,OAC3D6mC,EAAY,CACd,MAAMiX,GAAqB,EAAIZ,GAAqBr8B,cAAc7gB,KAAKsC,MAAMm7B,gBAC7E2G,GAAoByC,EAAYiX,GAChC3+B,GACEZ,EACAq/B,EACAE,EAEJ,MACK,CACL,MAAMC,EAAeh7B,EAAUE,IAAIhd,QAC7B+3C,EAAaD,EAAaz7C,MAC1B27C,EAAoBF,EAAa/5B,OAAO,GAAG1hB,OAAOsJ,QAClDsyC,EAAY,CAAC,EASnB,GARAC,GACEjT,EACA3sB,EACA3e,EACAo+C,GAAY9rB,WAAWsL,MACvBqgB,EACAK,GAEErX,EAAY,CACd,MAAMiX,EAAqBM,GACzBJ,EAAWte,sBACXue,EACAC,GAEF9Z,GAAoByC,EAAYiX,GAChC3+B,GACEZ,EACAq/B,EACAE,EAEJ,CACA,GAAIE,EAAWz1B,sBAAuB,CACpC,MAAM81B,EAA6BnT,EAASoS,IAA+B,GAC3E,IAAK,MAAMj/B,KAAU2/B,EAAWz1B,sBAAuB,CACrD,MAAM+1B,EAASj6C,SACfg6C,EAA2Bn0C,KAAKo0C,GAChCn/B,GACEZ,EACAq/B,EACAQ,GAA4B//B,EAAQ4/B,EAAmBC,GACvDI,EAEJ,CACF,EACA,EAAIpB,GAAqBr8B,cAAc7gB,KAAKsC,MAAMkL,oBAAsBwwC,GAAYvwC,eAAiBuwC,GAAYxwC,sBAAuB,CAC1I,CACA2R,GACEZ,EACAq/B,EAnnSR,SAAkBx0C,GAChB,IAAIm1C,EACAC,EACJ,IAAK,MAAMv5C,KAAQmE,EACbo1C,EACFA,EAAKt0C,KAAKjF,GACDs5C,EACTC,EAAO,CAACD,EAAKt5C,GAEbs5C,EAAMt5C,EAGV,OAAOu5C,GAAQD,CACjB,CAumSQE,CAASZ,GAEb,GAEF3+C,UAAW,CACTgoB,KAAAA,CAAMtnB,GACJsN,GAAMtN,GACF8H,KACFwmB,GAAYtuB,EAEhB,EACA4nB,IAAAA,CAAK5nB,GACC8H,IAQV,SAAuB9H,GACrB,MAAM4lC,EAAU5lC,EAAI7B,IAAI,SAClB,KAAEiC,GAASJ,EACXsrC,EAAWlrC,EAAKsC,MACtB,IAAIo8C,EAGJ,GAFAh2B,GAAU9oB,GACV+oB,GAA0B6c,GACtByX,GAAkB77C,MAAMkgB,gBAAgBthB,EAAKV,MAAO,CACtD,MAAMq/C,EAAeC,GAAmBh/C,GACxC8+C,EAAgBG,GAAkBj/C,EAAI+jB,IAAIle,KAAMk5C,GAAgB1B,GAAkB77C,MAAMI,WAAW2mB,OAA4B,EAAI+0B,GAAqBzgB,eAAe78B,EAAI+jB,IAAIle,KAAMk5C,EAAc9wC,GAAWjO,GAChN,MACE8+C,EAAgB1+C,EAAKV,KAEvB,MAAMyB,EAASf,EAAKgB,IACdud,EAAUwG,GAAWnlB,GAErBo+C,GADe,EAAId,GAAqBl6B,gBAAgBpjB,GAAKqjB,IAAIhd,QACvC3D,MAC1Bw8C,EAAcd,EAAW9rB,YAAYsL,OACrC,WAAE95B,EAAU,WAAE+xB,GAAeqpB,EAAchP,GAAelwC,EAAKk/C,EAAYne,OAAS,CACxFj9B,WAAY,GACZ+xB,WAAY,IAERmoB,EAAoB1S,EAASkS,IAC7B2B,EAA4Bn/B,GAChCrB,EACAq/B,GAEIoB,EAA0B9T,EAASoS,IACzC,IAAI2B,EACJ,GAAID,EACF,GAAuC,IAAnCA,EAAwB7+C,OAAc,CACxC,MAAMke,EAASuB,GACbrB,EACAq/B,EACAoB,EAAwB,IAE1BC,EAA4B5gC,EAA4B,GAAVA,EAAiB4+B,GAAkB77C,MAAMib,eAAe,GAAKmM,GAAkBnK,QAAxF,CACvC,KAAO,CACL,MAAMsiB,EAAQ,GACd,IAAIue,GAAoB,EACpBC,GAAoB,EACxB,IAAK,IAAIx6C,EAAI,EAAGA,EAAIq6C,EAAwB7+C,OAAQwE,IAAK,CACvD,MAAM0Z,EAASuB,GACbrB,EACAq/B,EACAoB,EAAwBr6C,IAEtB0Z,GACF6gC,KAAiC,IAAX7gC,EACtBsiB,EAAMz2B,KACJ+yC,GAAkB77C,MAAMmb,eACtB0gC,GAAkB77C,MAAMib,eAAe1X,IAC5B,IAAX0Z,EAAkB4+B,GAAkB77C,MAAMib,eAAe,GAAKmM,GAAkBnK,MAIpF8gC,GAAoB,CAExB,CACIxe,EAAMxgC,SACR8+C,EAA2BC,GAAqBC,EAAoBlC,GAAkB77C,MAAMq4B,iBAAiBkH,GAASsc,GAAkB77C,MAAMib,eAAe,GAEjK,CAEF,GAAI0iC,EAA2B,CAC7B,MAAMK,EAAcn4C,EAAsB22C,GAAmBt+C,MAC7DM,EAAIuuB,aACF8uB,GAAkB77C,MAAMuoB,oBAAoB,QAAS,CACnDszB,GAAkB77C,MAAMwoB,mBAAmBw1B,EAAaniC,GAAY,uBAGxE4T,GACEtS,EACAq/B,EACA3gC,GAAY,qBAAsBmiC,IAEhCr+C,GACF00B,EAAWvrB,KACT+yC,GAAkB77C,MAAM4L,oBACtBiQ,GACE,YACAgI,GAAqB1G,GACrBoQ,GAAwB/uB,EAAII,KAAKsC,MAAM+6C,KACvC+B,EACAnC,GAAkB77C,MAAME,cACtBu0B,GACEtX,EACAve,EAAKgB,IAAIsB,OAAOsJ,QAEhB,UAOd,CACA,GAAI5L,EAAKsC,MAAMkf,gBAAiB,CAC9B,MAAMovB,EAAcC,GAAiCntC,GACrD,IAAI2lB,EACJ,GAAIunB,EAAa,CACf,MAAML,EAAoBK,EAAYvyC,MACtCuyC,EAAYvyC,MAAQgrB,EAAYpiB,EAAsB,WACtD,MAAOo4C,GAAez/C,EAAIuuB,aACxB8uB,GAAkB77C,MAAMuoB,oBAAoB,QAAS,CACnDszB,GAAkB77C,MAAMwoB,mBACtBP,EAEAknB,MAIN8O,EAAYj7C,MACd,CACA,IAAIk7C,EAAgBryC,GAClByxC,EACAlR,GAAkB9pC,GAClBu7C,GAEEl+C,IACF2lC,GAAa9mC,EAAKq9C,GAAkB77C,MAAMkc,gBAAgB,OAAQ2/B,GAAkB77C,MAAMib,eAAe,IAAK,OAC9GijC,EAAgBrC,GAAkB77C,MAAM25B,qBAAqB,IAAKh6B,EAAQu+C,IAE5E7pB,EAAWvrB,KACT+yC,GAAkB77C,MAAMirC,YACtBqS,EACAzB,GAAkB77C,MAAM4L,oBAAoBsyC,GAC5Cj2B,GAAak2B,GAAcl2B,IAGjC,MAAWtoB,EACT2lC,GACE9mC,EACAqN,GACEyxC,EACAlR,GAAkB9pC,GAClBu7C,IAIJxpB,EAAWvrB,KACTq1C,GACEb,EACAlR,GAAkB9pC,GAClBu7C,IAIN,IAAK,MAAMn6C,KAAelF,EAAIupB,oBAAoBsM,GAChD3wB,EAAYV,MAEhB,CA9JQo7C,CAAc5/C,GA+JtB,SAAsBA,GACpB,MAAMomB,EAAajB,GAAWnlB,IACxB,KAAEI,GAASJ,EAEXg+C,EADQ59C,EAAKsC,MACa86C,IAC1B7R,EAASze,GAAQltB,IACjB,KAAE6F,GAAS7F,EAAI+jB,IACfklB,EAAUoU,GAAkB77C,MAAMqgB,aAAazhB,EAAKV,MAAQU,EAAKV,KAAKA,KAAO29C,GAAkB77C,MAAMkgB,gBAAgBthB,EAAKV,MAAQU,EAAKV,KAAKjB,MAAQ,MACpJsgD,EAAeC,GAAmBh/C,GAClCmjB,GAAY,EAAIm6B,GAAqBl6B,gBAAgBpjB,GACrD6/C,EAAe18B,EAAUE,IAAIhd,QAAQ3D,MAAM4vB,WAC3CwsB,EAAgBgB,GACpBj6C,EACAk5C,EACAc,EAAalxB,MACbsa,GAEIiW,EAAcW,EAAajiB,MAejC,GAdIshB,GACFa,GAAoB//C,EAAKk/C,EAAa,GAAGjxC,GAAWjO,IAAQ,cAAe,CACzEggD,SAAU78B,EAAUjd,KAAKD,WAAaJ,EAAKK,KAAKD,SAChDmgB,aACA24B,eACAf,oBACAiC,uBAAmB,IAGvBtU,CAAM,IAAG,EAAI2R,GAAqB4C,aAAar6C,EAAMk5C,EAAcc,EAAapkB,SAAU,GAAGwN,gBAx9O/F,SAAqBjpC,EAAKgD,GACxB,MAAMypB,EAAQT,GAAS7G,GAAWnlB,IACdisB,GAAe9G,GAAWnlB,IAClCsK,KACV,GAAG6hB,GAAensB,EAAII,KAAKgB,IAAM,GAA6B,MAC9D4B,EAAKtD,KACLysB,GAAe,KAEjBP,GACEa,EACAxR,OAAOC,aACLlb,EAAII,KAAKgB,IAAM,GAA6B,KAGhDqrB,EAAMniB,KAAKtH,EAAMiY,OAAOC,aAAa,IACvC,CA08OEilC,CACEngD,GACA,EAAIs9C,GAAqB4C,aAAar6C,EAAMk5C,EAAcc,EAAapzB,MAAO,GAAGwc,YAE/E7oC,EAAKgB,IAAK,CACZ,MAAM8P,EAASiiB,GAEb/yB,EAAKgB,IAAIsB,MAAMsJ,SAEjBkF,EAAOkmB,UAAW,EAClBlmB,EAAO2pB,gBAAkB,CAACmc,EAAcv4C,IAC/B4+C,GAAkB77C,MAAM6L,eAAe6P,GAAc,sBAAuB,CACjFwkB,GAA0BsV,EAAcgH,GACxCv/C,IAGJg3B,GACE,SACArP,OACA,EACAi3B,GAAkB77C,MAAM4L,oBACtBiQ,GACE,YACA4V,GACAlE,GAAwBivB,GACxB9sC,EAAOtP,aAIf,CACA6zB,GACE,SACArP,OACA,EACAi3B,GAAkB77C,MAAM4L,oBACtBiwC,GAAkB77C,MAAM6L,eAAeyxC,EAAe,CACpDpd,GAA0Btb,EAAY43B,OAI5Ch+C,EAAIsB,QACN,CAlOQ8+C,CAAapgD,EAEjB,IAiOJ,SAASg/C,GAAmBh/C,GAC1B,MAAM,KACJI,EACA2jB,KAAK,KAAEle,IACL7F,EACJ,IAAI++C,EACJ,GAAI1B,GAAkB77C,MAAMkgB,gBAAgBthB,EAAKV,MAAO,CACtD,MAAM+7B,GAAW,EAAI6hB,GAAqBO,gBAAgB79C,GAC1D++C,EAAetjB,IAAY,EAAI6hB,GAAqB3vC,qBAAqB9H,EAAM41B,EACjF,MAAWr7B,EAAKsC,OAAOqf,kBACrBg9B,EAAe3+C,EAAKsC,MAAMqf,iBAE5B,IAAKg9B,EAAc,CACjB,MAAM9V,EAAUh7B,GAAWjO,GAC3B,GAAIipC,GAAWjpC,EAAI+G,MAAM21C,WAAWzT,GAClC,MAAMjpC,EAAI7B,IAAI,QAAQgC,oBACpB,kFAAkF8oC,yBAA+BA,EAAQ6U,OAAO,GAAGC,cAAgB9U,EAAQ15B,MAAM,SAGrK,MAAMvP,EAAI7B,IAAI,QAAQgC,oBAAoB,6CAC5C,CACA,OAAO4+C,CACT,CACA,SAASR,GAAa8B,EAAc1hC,EAAS3e,EAAK8gC,EAAgBwf,EAAehC,GAC/E,IAAKxd,EAEH,YADAiE,GAAeE,GAAwBjlC,EAAII,OAG7C,IAAK0gC,EAAeC,OAAS/gC,EAAII,KAAKs0B,WAAWn0B,OAM/C,YALA+9C,EAAU7/C,MAAQ4lC,GAChB1lB,EACA3e,EAAII,KACJ6kC,GAAwBjlC,EAAII,QAIhC,MAAMmgD,EAAQjC,EAAUiC,MAAQ,CAAC,EAC3BlQ,EAAgBxI,GAAqB7nC,GACrC6kC,EAAuB,IAAI7pB,IACjC,GAAIq1B,EAAe,CACjB,MAAMmQ,EAAwC,IAAIp6C,IAC5Cq6C,EAA2BA,CAACttC,EAAO+V,KACvC,MAAMgc,EAAiBD,GAAwB/b,EAAM9oB,MAC/CsgD,EAAkBF,EAAsBriD,IAAIgV,GAC9CutC,EACFA,EAAgBxb,eAAiBwb,EAAgBxb,eAAeh6B,OAAOg6B,GAEvEsb,EAAsB55C,IAAIuM,EAAO,CAC/BwtC,SAAUz3B,EACVgc,kBAEJ,EAEF,IAAK,MAAM0b,KAAevQ,EACxBxL,EAAKt7B,IAAI8mC,EAAcuQ,GAAalhD,MAEtC,MAAMooC,EAAY9nC,EAAII,KAAKE,KAAK0kB,cAAgBhlB,EAAI7B,IAAI,QAAQA,IAAI,QAAU6B,EAAI7B,IAAI,iBACtF,IAAK,MAAM+qB,KAAS4e,EAClB,GAAI5e,EAAM/a,aACR,IAAI,EAAImvC,GAAqBn3B,gBAAgB+C,GAAQ,CACnD,MAAMsf,EAAc6H,EAAcpiC,GAAWib,IACvC23B,EAAmB/f,EAAeC,MAAMyH,EAAY9oC,MACtDmhD,EACEA,EAAiB9f,QAAUyH,EAAYC,QACzC8V,GACE8B,EACA1hC,EACAuK,EACA23B,EACAP,EACAC,EAAM/X,EAAY9oC,MAAQ,CAAC,GAG7B+gD,EAAyBjY,EAAYr1B,MAAO+V,GAG9C6b,GAAeE,GAAwB/b,EAAM9oB,MAEjD,KAAO,CACL,MAAM+S,EAAQ+V,EAAM9oB,KAAKsC,MAAMmmC,kBAC/B,IAAIiY,GAAqB,EACzB,IAAK,MAAMjiD,KAASsU,EAClB,GAAI2tB,EAAeC,MAAMsP,EAAcxxC,GAAOa,MAAO,CACnDohD,GAAqB,EACrB,KACF,CAEEA,EACFL,EAAyBttC,EAAO+V,GAEhC6b,GAAeE,GAAwB/b,EAAM9oB,MAEjD,CAGJ,IAAK,MACH+S,GAEEwtC,UAAU,KAAEvgD,GAAM,eAClB8kC,MAECsb,EAAuB,CAC1B,MAAMO,EAAa1c,GAAgB1lB,EAASve,EAAM8kC,GAC5C8b,EAAkB,CAAEviD,MAAOsiD,GACjCT,EAAc/2C,IAAIw3C,GAClB,IAAK,MAAMliD,KAASsU,EAClBotC,EAAMlQ,EAAcxxC,GAAOa,MAAQshD,CAEvC,CACF,CACA,IAAKnc,EAAKn9B,IAAI,WAAY,CACxB,MAAMs+B,EAAc9gB,GAAkBllB,EAAI7B,IAAI,SAC1C6nC,IACFnB,EAAKt7B,IAAI,WACTg3C,EAAM77B,QAAU,CAAEjmB,WAAO,GACzBunC,EAAYnhB,mBAAqBic,EAAeC,MAAMrc,SAAWoc,EAAeC,OAAO/0B,QAE3F,CACA,MAAM,WAAEjK,GAAe/B,EAAII,KAC3B,IAAIqqC,EACJ,IAAK,IAAI1lC,EAAIhD,EAAWxB,OAAQwE,KAAO,CACrC,MAAM9E,EAAQ8B,EAAWgD,GACzB,GAAIs4C,GAAkB77C,MAAMskC,iBAAiB7lC,GAAQ,CACnD,GAAI4kC,EAAKn9B,IAAIzH,EAAMP,QAAUohC,EAAeC,MAAM9gC,EAAMP,MAAO,CAC7DqlC,GAAe9kC,EAAMxB,OACrB,QACF,CACAomC,EAAKt7B,IAAItJ,EAAMP,KACjB,CACA,GAAI+qC,EACFA,EAAqBngC,KAAKrK,EAAMxB,YAC3B,GAAI4+C,GAAkB77C,MAAMtB,uBAAuBD,GACxDwqC,EAAuB,CAACxqC,EAAMxB,WACzB,CACL,MAAMwiD,EAAiBhhD,EAAMxB,MAAMiE,QAAU,CAAC,EAC9C69C,EAAMtgD,EAAMP,MAAQ,CAAEjB,MAAOwiD,GAC7BX,EAAc/2C,IAAI03C,EACpB,CACF,CACIxW,IACF6T,EAAU7/C,MAAQ4lC,GAAgB1lB,EAAS3e,EAAII,KAAMqqC,GAEzD,CACA,SAASsV,GAAoB//C,EAAK8gC,EAAgBogB,EAAa5tC,GAC7D,GAAItT,EAAII,KAAKs0B,WAAWn0B,OAAQ,CAC9B,MAAOkd,GAAOzd,EAAII,KAAKs0B,UACjBysB,EAAqBrB,GACzB9/C,EAAI+jB,IAAIle,KACRyN,EAAKyrC,aACLje,EAAe1f,GACf8/B,GAWF,YATArxB,GACEvc,EAAK8S,WAGLpmB,EAAII,KAAKsC,OAAO8d,mBAChB4gC,GAAmBD,GACnB9D,GAAkB77C,MAAMukC,gBAAgBtoB,GAAO4/B,GAAkB77C,MAAMwb,iBAAiBS,EAAIra,SAAUi6C,GAAkB77C,MAAMib,eAAe,IAAI,GAAQgB,EACzJikB,GAA0BpuB,EAAK8S,WAAY9S,EAAK0qC,mBAGpD,CACA,IAAKld,EAAeC,OAASztB,EAAK0sC,SAAU,CAC1C,MAAMx/B,EAAqBxgB,EAAII,KAAKsC,OAAO8d,mBACrC2gC,EAAqBrB,GACzB9/C,EAAI+jB,IAAIle,KACRyN,EAAKyrC,aACLje,EAAe1f,GACf8/B,GAEIpP,EAAkB5B,GAAelwC,GACnC8xC,EAAgBjc,WAAWt1B,QAC7Bk1B,GACE,SACAniB,EAAK8S,WACL5F,EACAsxB,EAAgBjc,YAGpB,IAAIwrB,EAAkBzT,GAAkBkE,EAAgBhuC,YACxD,IAAI,EAAIw5C,GAAqBn3B,gBAAgBnmB,GAAM,CACjD,MAAM4gD,EAAc3yC,GAAWjO,GACzBsvB,EAAYtvB,EAAIyI,WAChBigC,EAAWb,GAAqBvY,KAAasxB,IAAclY,SACjE,GAAIA,EAAU,CACZ,IAAI4Y,GAAsBhuC,EAAK2sC,oBAAsC,IAAI75C,KAAOjI,IAC9EmxB,GAEGgyB,GACHhuC,EAAK2sC,kBAAkBr5C,IACrB0oB,EACAgyB,EAAqC,IAAIl7C,KAG7C,MAAMm7C,EAAcD,EAAmBnjD,IAAIyiD,GAC3C,GAAIW,EAMF,YALAA,EAAYh+C,WAAa8Z,GACvB,WACAkkC,EAAYh+C,WACZ89C,IAIFC,EAAmB16C,IACjBg6C,EACAS,EAAkBhE,GAAkB77C,MAAMmvB,wBACxCtT,GAAY,UAAWgkC,IAI/B,MACEA,EAAkBhkC,GAAY,UAAWgkC,EAE7C,CAQA,YAPAxxB,GACEvc,EAAK8S,WACL5F,EACA4gC,GAAmBD,GACnBE,EACA3f,GAA0BpuB,EAAK8S,WAAY9S,EAAK0qC,mBAGpD,CACA,MAAMnZ,EAAuB,IAAI7pB,IAC3Bq1B,EAAgBxI,GAAqB7nC,GAC3C,GAAIqwC,EAAe,CACjB,MAAMvI,EAAY9nC,EAAI7B,IAAI,iBACpBqjD,EAAoC,IAAIp7C,IACxCq7C,EAAsCA,CAACtuC,EAAO2gB,KAClD,MAAM5K,EAAQ4e,EAAUhU,GACxB,IAAI+B,EAAa2rB,EAAkBrjD,IAAIgV,IAAQ0iB,WAQ/C,OAPKA,IACHA,EAAa,GACb2rB,EAAkB56C,IAAIuM,EAAO,CAC3BqN,mBAAoB0I,EAAM9oB,KAAKsC,OAAO8d,mBACtCqV,gBAGG0a,GACLzI,EACAhU,EACAuc,EACAxa,EACAiL,EAAeC,MAChB,EAEH,IAAK,MAAM6f,KAAevQ,EACxBxL,EAAKt7B,IAAI8mC,EAAcuQ,GAAalhD,MAEtC,IAAK,IAAIqF,EAAI,EAAGA,EAAI+iC,EAAUvnC,OAAQwE,IAAK,CACzC,MAAMmkB,EAAQ4e,EAAU/iC,GACxB,GAAImkB,EAAM/a,aACR,IAAI,EAAImvC,GAAqBn3B,gBAAgB+C,GAAQ,CACnD,MAAMsf,EAAc6H,EAAcpiC,GAAWib,IACvCw4B,EAAkB5gB,EAAeC,MAAMyH,EAAY9oC,MACrDgiD,IACElZ,EAAYC,QACd1jC,EAAI08C,EAAoCjZ,EAAYr1B,MAAOpO,GAE3Dg7C,GACE72B,EACAw4B,EACA,GAAGR,KAAe1Y,EAAY9oC,OAC9B4T,GAIR,MAAW4V,EAAM9oB,KAAKsC,OAAOmmC,oBAC3B9jC,EAAI08C,EACFv4B,EAAM9oB,KAAKsC,MAAMmmC,kBACjB9jC,GAIR,CACA,IAAK,MACHoO,GACA,mBAAEqN,EAAkB,WAAEqV,MACnB2rB,EAAmB,CACtB,MAAMG,EAAQ,GACd,IAAK,MAAM9iD,KAASsU,EAAO,CACzB,MAAMq1B,EAAc6H,EAAcxxC,GAC5BgiD,EAAmB/f,EAAeC,MAAMyH,EAAY9oC,MAC1D,IAAKmhD,EAAkB,SACvB,MAAMe,EAAuB9B,GAC3B9/C,EAAI+jB,IAAIle,KACRyN,EAAKyrC,aACL8B,EAAiBz/B,GACjB,GAAG8/B,KAAe1Y,EAAY9oC,QAEhCiiD,EAAMr3C,KAAK+yC,GAAkB77C,MAAMwoB,mBAAmB2d,GAAqBa,KAC3E3Y,GACEvc,EAAK8S,WACL5F,EACA4gC,GAAmBQ,GACnBja,GAAqBa,GACrB9G,GAA0BpuB,EAAK8S,WAAY9S,EAAK0qC,mBAEpD,CACAvoB,GAAa,SAAUniB,EAAK8S,WAAY5F,EAAoB,CAC1D68B,GAAkB77C,MAAMuoB,oBAAoB,MAAO43B,MAChD9rB,GAEP,CACF,CACA,MAAMmQ,EAAchmC,EAAII,KAAKE,KAAKoC,OAAOic,QACzC,GAAIqnB,IAAgBnB,EAAKn9B,IAAI,aAC3Bm9B,EAAKt7B,IAAI,WACLu3B,EAAeC,MAAMrc,SAAS,CAChC,MAAMm9B,GAA0B,EAAIvE,GAAqB4C,aACvDlgD,EAAI+jB,IAAIle,KACRyN,EAAKyrC,aACLje,EAAeC,MAAMrc,QAAQtD,GAC7B,GAAG8/B,aAELrxB,GACEvc,EAAK8S,gBACL,EAEAg7B,GAAmBS,GACnBxE,GAAkB77C,MAAM6L,eAAegwC,GAAkB77C,MAAMI,WAAWokC,EAAYtmC,MAAO,CAACuzB,KAC9FyO,GAA0BpuB,EAAK8S,WAAY9S,EAAK0qC,mBAEpD,CAEF,MAAM,WAAEj8C,GAAe/B,EAAII,KACrB4rC,EAAc,GACpB,IAAIuB,EACJ,IAAK,IAAIxoC,EAAIhD,EAAWxB,OAAQwE,KAAO,CACrC,MAAM9E,EAAQ8B,EAAWgD,GACzB,GAAIs4C,GAAkB77C,MAAMskC,iBAAiB7lC,GAAQ,CAEnD,IADyB6gC,EAAeC,MAAM9gC,EAAMP,OAC3BmlC,EAAKn9B,IAAIzH,EAAMP,MAAO,SAE/C,GADAmlC,EAAKt7B,IAAItJ,EAAMP,MACX6tC,EAAa,CACfA,EAAYjjC,KAAKoS,GAAiBzc,EAAMP,KAAMO,EAAMxB,QACpD,QACF,CACAutC,EAAY1hC,KAAKrK,EACnB,MAAWstC,EACTA,EAAYjjC,KAAK+yC,GAAkB77C,MAAMksC,cAAcztC,EAAMxB,QAE7D8uC,EAAc,CAAC8P,GAAkB77C,MAAMksC,cAAcztC,EAAMxB,OAE/D,CACA,IAAK,MAAMwB,KAAS+rC,EAAY2B,UAAW,CACzC,MAAMkT,EAAmB/f,EAAeC,MAAM9gC,EAAMP,MAC9CkiD,EAAuB9B,GAC3B9/C,EAAI+jB,IAAIle,KACRyN,EAAKyrC,aACL8B,EAAiBz/B,GACjB,GAAG8/B,KAAejhD,EAAMP,QAE1BmwB,GACEvc,EAAK8S,WACLnmB,EAAMxB,MAAMiE,OAAO8d,mBACnB4gC,GAAmBQ,GACnB3hD,EAAMxB,MACNijC,GAA0BpuB,EAAK8S,WAAY9S,EAAK0qC,mBAEpD,CACA,MAAM8D,EAAU,IAAI9mC,IAAIje,OAAOiI,KAAK87B,EAAeC,QACnD,IAAK,MAAMliC,KAASgmC,EAAMid,EAAQ/iC,OAAOlgB,GACzC,GAAIijD,EAAQ51C,KAAM,CAChB,MAAMsU,EAAqBxgB,EAAII,KAAKsC,OAAO8d,mBAC3C,IAAIuhC,EAAsBC,GAC1B,GAAIzU,EAAa,CACf,MAAM0U,EAAW56C,EAAsB,GAAG65C,YAC1C3T,EAAYI,UACZoU,EAAuBljD,GAAU+d,GAAmBqlC,EAAUpjD,GAC9D42B,GAAa,SAAUniB,EAAK8S,WAAY5F,EAAoB,CAC1D68B,GAAkB77C,MAAMuoB,oBAAoB,QAAS,CACnDszB,GAAkB77C,MAAMwoB,mBAAmBi4B,EAAUrU,GAAkBL,OAG7E,CACA,IAAK,MAAM1uC,KAASijD,EAAS,CAC3B,MAAMjB,EAAmB/f,EAAeC,MAAMliC,GACxC+iD,EAAuB9B,GAC3B9/C,EAAI+jB,IAAIle,KACRyN,EAAKyrC,aACL8B,EAAiBz/B,GACjB,GAAG8/B,KAAeriD,KAEpBgxB,GACEvc,EAAK8S,WACL5F,EACA4gC,GAAmBQ,GACnBG,EAAoBljD,GACpB6iC,GAA0BpuB,EAAK8S,WAAY9S,EAAK0qC,mBAEpD,CACF,CACF,CACA,SAAS8B,GAA0Bj6C,EAAMq8C,EAASrjD,EAAOsjD,GACvD,OAAIlD,GAAkBp5C,EAAMq8C,GACnB7E,GAAkB77C,MAAMI,WAAW/C,IAErC,EAAIy+C,GAAqB4C,aAAar6C,EAAMq8C,EAASrjD,EAAOsjD,EACrE,CACA,SAAS3D,GAA4B4D,EAAa/D,EAAmBC,GACnE,GAAI8D,EACF,OAAoB,IAAhBA,GA9tTR,SAAmB54C,EAAM5F,GACvB,GAAI4F,EAAM,CACR,GAAI3E,MAAMC,QAAQ0E,GAAO,CACvB,MAAM4B,EAAM5B,EAAKjJ,OACjB,IAAI2J,EACAnF,EAAI,EACR,KAAOA,EAAIqG,GAAK,CACd,IAAI/F,EAAOzB,EAAG4F,EAAKzE,MACnB,GAAIM,EAAM,CAER,IADA6E,EAAS7E,EACFN,EAAIqG,GAET,GADA/F,EAAOzB,EAAG4F,EAAKzE,MACXM,EAAM,CAER,IADA6E,EAAS,CAACA,EAAQ7E,GACXN,EAAIqG,GACT/F,EAAOzB,EAAG4F,EAAKzE,MACXM,GACF6E,EAAOI,KAAKjF,GAGhB,OAAO6E,CACT,CAEF,OAAOA,CACT,CACF,CACA,OAAOA,CACT,CACE,OAAOtG,EAAG4F,EAEd,CACF,CAgsTW64C,CACLD,GACCxmB,GAIP,SAA+BA,EAAcwG,EAAap/B,GACxD,GAAIA,EAAM,CACR,IAAIs/C,EAAUt/C,EACd,GAAI44B,IAAiBwG,EAAa,CAChC,MAAMrB,EAAQ,CAACqB,EAAY/R,UAC3B,IAAIkyB,EAAangB,EACjB,KAAOxG,KAAkB2mB,EAAaA,EAAWnyB,gBAC/C2Q,EAAMz2B,KAAKi4C,EAAWlyB,UAExB,IAAK,IAAItrB,EAAIg8B,EAAMxgC,OAAQwE,KAAO,CAChC,MAAMy9C,EAAaF,EAAQ/B,QAAQxf,EAAMh8B,IACzC,IAAIy9C,EAGF,MAFAF,EAAUE,CAId,CACF,CACA,OAAOF,EAAQ7jD,KACjB,CACF,CAxBwBgkD,CAAsBpE,EAAmBziB,EAAc0iB,IAG/E,CAsBA,SAASW,GAAkBp5C,EAAMq8C,GAC/B,MAAM,SAAEj8C,GAAaJ,EAAKK,KAC1B,OAAOg8C,IAAYj8C,GAA2B,MAAfi8C,EAAQ,IAAc3E,GAAa71B,QAAQg7B,QAAQz8C,EAAU,KAAMi8C,KAAaj8C,CACjH,CACA,SAAS05C,GAAcv+B,KAAO9D,GAC5B,OAAO+/B,GAAkB77C,MAAM4L,oBAAoBC,GAAe+T,KAAO9D,GAC3E,CACA,SAASjQ,GAAe+T,KAAO9D,GAC7B,OAAO+/B,GAAkB77C,MAAM6L,eAAe+T,EAAI9D,EAAKnS,OAAOuH,SAChE,CACA,SAAS0uC,GAAmBx/C,GAC1B,MAAO,CACLA,aACAkuB,2BAA4B6yB,GAEhC,CACA,SAASX,KACP,OAAO3E,GAAkB77C,MAAMkc,gBAAgB,OAAQ2/B,GAAkB77C,MAAMib,eAAe,GAChG,CACA,SAASkmC,KACP,OAAO,CACT,CAGA,IAAIC,GAAoBjjD,EAAQ,yCAC5BkjD,GAAuBljD,EAAQ,+CAC/BmjD,GAAer+C,OAAO,2BACtBs+C,GAA4Bt+C,OAAO,2BACnCu+C,GAAsB,CACxBlkD,QAAS,CACPwoB,KAAAA,CAAMtnB,IACJ,EAAI6iD,GAAqBI,wBAAwBjjD,GACjD6nC,GAAqB7nC,GACrB,MAAMomB,EAAazC,GAAmB3jB,GAChCsrC,EAAWjH,GAAgBje,EAAYpmB,EAAII,KAAM,CACrDJ,EAAII,KAAKV,QACNulC,GAAwBjlC,EAAII,QAE3BwlC,EAAU5lC,EAAI7B,IAAI,QAClB+kD,EAAsC,UAAzB5X,EAAShoB,YACtB6/B,IAAWnjD,EAAII,KAAKgB,IACpB0tB,EAAcwc,EAASwX,IAAgB5gB,GAC3C,QACA,EACA9b,GAEE+8B,IACF9gB,GAAmBriC,EAAK,GACxBA,EAAII,KAAKgB,IAAIsB,MAAMsJ,QAAQ8mB,YAAcwY,EAASyX,IAA6B7gB,GAAc,eAAgB,EAAa9b,IAE5H3C,GAAamiB,GACbjI,GAAsBiI,EAAS,GAC/BrmB,GACE6G,EACA0I,EACAo0B,GAAcC,GAAU7X,EAE5B,GAEFhsC,UAAW,CACTgoB,KAAAA,CAAMtnB,GACJsN,GACEtN,EACAA,EAAII,KAAKgB,IAAM,GAA6B,IAE9CkrB,GAAatsB,GACT8H,KACFwmB,GAAYtuB,EAEhB,EACA4nB,IAAAA,CAAK5nB,GACH,MAAM,KAAEI,GAASJ,EACXsrC,EAAWlrC,EAAKsC,MAChBosB,EAAcwc,EAASwX,IACvB18B,EAAajB,GAAWnlB,GACxBkjD,EAAsC,UAAzB5X,EAAShoB,YAC5B,IAAI8/B,EAAgBhjD,EAAKV,KACrBkjD,GAAkBphD,MAAMkgB,gBAAgB0hC,KAC1CA,GAAgB,EAAIP,GAAqBhmB,eACvC78B,EAAI+jB,IAAIle,KACRm5C,GAAmBh/C,GACnBojD,EAAc3kD,QAGdykD,IACEp7C,KACF,EAAI+6C,GAAqB5hC,cAAc7gB,KAAKE,KAAKgK,KAC/Cs4C,GAAkBphD,MAAMilC,eACtB,CACEmc,GAAkBphD,MAAM4L,oBACtBw1C,GAAkBphD,MAAM6L,gBACtB,EAAIw1C,GAAqB3C,aAAalgD,EAAI+jB,IAAIle,KAAMiY,KAAwB,KAC5E,CACE8kC,GAAkBphD,MAAMI,WAAWwhD,EAAc1jD,MACjDkjD,GAAkBphD,MAAME,eAAc,EAAImhD,GAAqBz/B,gBAAgBpjB,GAAKyN,SAASC,MAAM0T,SAK3G,KAIJ,EAAIyhC,GAAqB5hC,cAAc7gB,KAAKE,KAAKgK,KAC/Cs4C,GAAkBphD,MAAM4L,oBACtBiQ,GACE,WACAulC,GAAkBphD,MAAME,eAAc,EAAImhD,GAAqBz/B,gBAAgBpjB,GAAKyN,SAASC,MAAM0T,IACnGwhC,GAAkBphD,MAAMI,WAAWwhD,EAAc1jD,UAM3D,MAAM,WAAEoE,EAAU,WAAE+xB,GAAeqa,GACjClwC,OACA,OACA,EACAkjD,EAAa,aAAe,WAExB5lC,EAAO,GACb,IAAI+lC,GAAa,EACjB,GAAIjjD,EAAKs0B,UACP2uB,GAAa,EACb/lC,EAAKhT,QAAQlK,EAAKs0B,WACd5wB,EAAWvD,QACb+c,EAAKhT,KAAKsjC,GAAkB9pC,QAEzB,CACL,MAAMktC,EAAcC,GAAiCntC,GACjDktC,GACFltC,EAAWs2C,OAAOt2C,EAAWq4B,QAAQ6U,GAAc,GACnD1zB,EAAKhT,KAAKsjC,GAAkB9pC,GAAaktC,EAAYvyC,QAErD6e,EAAKhT,KAAKsjC,GAAkB9pC,GAEhC,CACA,GAAIgE,IAAgB,CAClBghB,GAAU9oB,GACV+oB,GAA0B/oB,EAAI7B,IAAI,SAClC,MAAM2gB,EAAkBkB,GACtBoG,EACA0I,GAEIw0B,EAAgBxkC,GAAkF,IAApBA,OAA2B,EAAS8J,GAAkB9J,GAAlG8jC,GAAkBphD,MAAMib,eAAe,GACzE8mC,EAAiBF,EAAahmC,GAClC,aACAgI,GAAqBe,GACrB2I,GAAwBD,GACxBs0B,EACAR,GAAkBphD,MAAM44B,gBAAgB9c,GACxCslC,GAAkBphD,MAAMib,eAAe,GACvCmmC,GAAkBphD,MAAMib,eAAe,GACvC6mC,GACEjmC,GACF,aACAgI,GAAqBe,GACrB2I,GAAwBD,GACxBs0B,EACA9lC,EAAK,GACLA,EAAK,KAAOgmC,EAAeV,GAAkBphD,MAAMib,eAAe,QAAK,GACvE6mC,EAAeV,GAAkBphD,MAAMib,eAAe,QAAK,EAC3D6mC,GAEF,GAAIljD,EAAKgB,IAAK,CACZ,MAAMoiD,EAAyBn8C,EAC7BrH,EAAI7B,IAAI,QAAQsR,WAAa,UAE/BomB,EAAWvrB,KACTs4C,GAAkBphD,MAAMuoB,oBAAoB,QAAS,CACnD64B,GAAkBphD,MAAMwoB,mBACtBw5B,EACAnmC,GAAY,uBAIlBwY,EAAWvrB,KACTs4C,GAAkBphD,MAAMuoB,oBAAoB,QAAS,CACnD64B,GAAkBphD,MAAMwoB,mBAAmB5pB,EAAKgB,IAAKmiD,KAEvDX,GAAkBphD,MAAM4L,oBACtBiQ,GACE,YACAgI,GAAqBe,GACrB2I,GACE/uB,EAAII,KAAKsC,MAAMqgD,KAEjBS,EACAZ,GAAkBphD,MAAME,cACtBu0B,GACE7P,EACAhmB,EAAKgB,IAAIsB,OAAOsJ,QAEhB,UAMZ,MACE6pB,EAAWvrB,KAAKs4C,GAAkBphD,MAAM4L,oBAAoBm2C,IAE9D,IAAK,MAAMr+C,KAAelF,EAAIupB,oBAAoBsM,GAChD3wB,EAAYV,MAEhB,KAAO,CACL,MAAMma,EAAUwG,GAAWnlB,GACrBgmC,EAAc9gB,GAAkBllB,EAAI7B,IAAI,SACxCg0B,EAASH,GAAUrT,EAASmQ,EAAa,cAC/C,IAAI20B,EA6BJ,GA5BIzjD,EAAII,KAAKgB,MACXqiD,EAAetwB,GAEbnzB,EAAII,KAAKgB,IAAIsB,MAAMsJ,SAErBy3C,EAAarsB,UAAW,EACxBqsB,EAAa5oB,gBAAkB,CAACmc,EAAcv4C,IACrCmkD,GAAkBphD,MAAM6L,eAAe6P,GAAc,sBAAuB,CACjF0lC,GAAkBphD,MAAMwb,iBACtBkW,GAAmBuwB,EAAa9kC,QAASq4B,GACzC4L,GAAkBphD,MAAME,cACtB0G,IAAoBotC,iBAAmBtkB,GAAiBpC,KAE1D,GAEFrwB,KAIN0zB,EAAOzlB,MAAQ,IACN2Q,GACL,aACA0R,GAAwBD,GACxBkX,GAAe4c,GAAkBphD,MAAMI,WAAWokC,EAAYtmC,MAC9D+jD,EAAeb,GAAkBphD,MAAMmoB,wBAAwB,GAAI85B,EAAa7hD,iBAAc,EAC9FyhD,GAAcT,GAAkBphD,MAAMib,eAAe,IAGrDa,EAAK/c,OAAQ,CACf,MAAMmjD,EAAcL,EAAaT,GAAkBphD,MAAM44B,gBAAgB9c,GAAQA,EAAK,GACjFslC,GAAkBphD,MAAMmiD,mBAAmBD,KAAgBA,EAAY5/C,WAAWvD,SACrF4xB,EAAO2C,UAAY,CACjB8tB,GAAkBphD,MAAMmoB,wBACtB,GACAkM,EAAWt1B,OAASqiD,GAAkBphD,MAAMooB,eAC1CiM,EAAW3qB,OAAO03C,GAAkBphD,MAAMs2B,gBAAgB4rB,KACxDA,IAIZ,CACAvxB,EAAOrC,2BAA6B,KAAM,EAC1CD,GAASlR,EAAS2sB,EAAS9qB,mBAAoB2R,EAAQixB,GACvDpjD,EAAIsB,QACN,CACF,IAKAsiD,GAA0B,wBAC1BC,GAAyC,IAAIl+C,QAC7Cm+C,GAAc,CAChBzkD,UAAW,CACTioB,KAAAA,CAAMtnB,GACJ,MAAM,KAAEI,GAASJ,GACTN,KAAMb,EAAK,WAAEkD,GAAe/B,EAAII,KACxC,IAAIs9B,GAAQ,EACZ,GAAIsf,GAAkBx7C,MAAMkgB,gBAAgB7iB,GAAQ,CAClD,MAAMoqC,EAAUpqC,EAAMJ,MAClBuB,EAAI+G,MAAMwb,WAAW0mB,IAAY2a,GAAwBh1C,KAAKq6B,KAChE7oC,EAAKV,KAAOkiC,GAAqBob,GAAkBx7C,MAAMI,WAAWqnC,GAAUpqC,GAC9E6+B,GAAQ,EAEZ,CACA,IAAK,IAAI34B,EAAI,EAAGA,EAAIhD,EAAWxB,OAAQwE,IAAK,CAC1C,MAAM9E,EAAQ8B,EAAWgD,GACrBi4C,GAAkBx7C,MAAMskC,iBAAiB7lC,IAAUA,EAAM8jD,QAC3D9jD,EAAM8jD,OAAQ,EACdhiD,EAAWq4C,SAASr1C,EAAG,EAAGi/C,GAAiBhkD,EAAKC,IAChDy9B,GAAQ,EAEZ,CACIA,GACF19B,EAAI+G,MAAM22B,OAEd,GAEF5+B,QAAS,CACPwoB,KAAAA,CAAMtnB,GACJ,MAAMoO,GAAS,EAAI6uC,GAAqB5uC,WAAWrO,GAC7CqB,EAAOmgB,GAAmBxhB,GAC1BikD,EAAO71C,GAAQ81C,UAAUD,KAC/B,GAAIA,EACF38B,GAAM28B,EAAMjkD,QAGd,GAAa,IAATqB,EAIJ,OAAQA,GACN,KAAK,EACHs8C,GAAmB7+C,QAAQwoB,MAAMtnB,GACjC,MACF,KAAK,EACHm9C,GAAsBr+C,QAAQwoB,MAAMtnB,GACpC,MACF,KAAK,EACHgjD,GAAoBlkD,QAAQwoB,MAAMtnB,QAXpCoqC,GAAmBtrC,QAAQwoB,MAAMtnB,EAcrC,EACA4nB,IAAAA,CAAK5nB,GACH,MAAMikD,GAAO,EAAIhH,GAAqB5uC,WAAWrO,IAAMkkD,UAAUD,KAC7DA,GACFr8B,GAAKq8B,EAAMjkD,EAGf,GAEFV,UAAW,CACTgoB,KAAAA,CAAMtnB,GACJ,MAAMoO,GAAS,EAAI6uC,GAAqB5uC,WAAWrO,GAC7C0C,EAAQ1C,EAAII,KAAKsC,MACvB,GAAI0L,GAAQ+1C,WAKV,OAJI/1C,EAAO+1C,WAAW79C,MACpBtG,EAAI+jB,IAAIle,KAAK4H,SAASC,MAAM02C,WAAW95C,KAAK8D,EAAO+1C,WAAW79C,WAEhEghB,GAAMlZ,EAAO+1C,WAAWF,KAAMjkD,GAGhC,IAAK,MAAMC,KAASD,EAAI7B,IAAI,cAC1B,GAAI8B,EAAM6lC,mBAAoB,CAC5B,GAAI7lC,EAAMG,KAAKs0B,UACb,MAAMz0B,EAAME,oBACV,kCAAkCF,EAAMG,KAAKV,qBAGjD,GAAIO,EAAMG,KAAKikD,SAAU,CACvB,KAAI,EAAIpH,GAAqBt7B,aAAa1hB,EAAMwI,YAG9C,MAAMxI,EAAME,oBACV,0BAA0BF,EAAMG,KAAKikD,eAHvCpkD,EAAMG,KAAKV,MAAQ,IAAIO,EAAMG,KAAKikD,UAMtC,CACF,CAEF,GAAI3hD,EAAMugB,gBAAkBvgB,EAAMkf,kBAAoB5hB,EAAI7B,IAAI,QAAQ0jB,gBAAkB/Z,IAAgB,CACtG,MAAMw8C,EAAYj9C,EAAsB,YACjCk9C,GAAkBvkD,EAAIuuB,aAC3ByuB,GAAkBx7C,MAAMuoB,oBAAoB,QAAS,CACnDizB,GAAkBx7C,MAAMwoB,mBAAmBs6B,EAAWtkD,EAAII,KAAKV,SAGnE6kD,EAAe//C,OACfxE,EAAI4G,IAAI,OAAQ09C,EAClB,CACA,OAAQ5hD,EAAM+e,aACZ,KAAK,EACH2oB,GAAmB9qC,UAAUgoB,MAAMtnB,GACnC,MACF,KAAK,EACH29C,GAAmBr+C,UAAUgoB,MAAMtnB,GACnC,MACF,KAAK,EACHgjD,GAAoB1jD,UAAUgoB,MAAMtnB,GACpC,MACF,KAAK,EACHm9C,GAAsB79C,UAAUgoB,MAAMtnB,GAG5C,EACA4nB,IAAAA,CAAK5nB,GACH,MAAMmkD,GAAa,EAAIlH,GAAqB5uC,WAAWrO,IAAMmkD,WAC7D,GAAIA,EACFv8B,GAAKu8B,EAAWF,KAAMjkD,QAGxB,OAAQA,EAAII,KAAKsC,MAAM+e,aACrB,KAAK,EACH2oB,GAAmB9qC,UAAUsoB,KAAK5nB,GAClC,MACF,KAAK,EACH29C,GAAmBr+C,UAAUsoB,KAAK5nB,GAClC,MACF,KAAK,EACHgjD,GAAoB1jD,UAAUsoB,KAAK5nB,GACnC,MACF,KAAK,EACHm9C,GAAsB79C,UAAUsoB,KAAK5nB,GAG3C,IAGJ,SAASgkD,GAAiBhkD,EAAKC,GAC7B,MACMukD,EADWvkD,EAAMP,KACW,SAClC,GAAIs9C,GAAkBx7C,MAAMqgB,aAAa5hB,EAAMxB,OAAQ,CACrD,MAAMuN,EAAUhM,EAAI+G,MAAMwb,WAAWtiB,EAAMxB,MAAMiB,MACjD,IAAKsM,EACH,OAAOgxC,GAAkBx7C,MAAMG,eAC7B6iD,EACAC,GAA2BxkD,EAAMxB,QAErC,MAAMimD,EAAsBb,GAAuB1lD,IAAI6N,EAAQpK,YAC/D,IAAK8iD,EAAqB,CACxB,MAAMC,EAAoB3H,GAAkBx7C,MAAMG,eAChD6iD,EACAC,GAA2BxkD,EAAMxB,QAGnC,OADAolD,GAAuBj9C,IAAIoF,EAAQpK,WAAY+iD,GACxCA,CACT,CACA,GAAiC,eAA7BD,EAAoBrjD,KACtB,OAAO27C,GAAkBx7C,MAAMG,eAC7B6iD,EACA5iB,GACEob,GAAkBx7C,MAAMI,WAAW8iD,EAAoBhlD,MACvDO,EAAMxB,QAIZ,MAAMu8C,EAAYtyC,GAAQsD,EAAQ1F,MAAQ0F,EAAQ1F,KAAOgC,GAAa0D,EAAQ1F,MAC9E,IAAM00C,GAAW7sC,eAAgB6sC,GAAWY,iBAC1C,MAAM57C,EAAI+jB,IAAIumB,WAAWrqC,EAAMxB,MAAO,4BAExC,MAAMmmD,EAAkBh/C,EAAY4+C,GAC9BK,EAAqB7H,GAAkBx7C,MAAMC,SACjDu7C,GAAkBx7C,MAAME,cAAc,SACtC,CAACs7C,GAAkBx7C,MAAMG,eAAe,QAAS+iD,EAAoBjmD,MAAO,KAAM,MAAM,IACxFu+C,GAAkBx7C,MAAMK,aAAa,IACrC,KACAm7C,GAAkBx7C,MAAMI,WAAWgjD,IAWrC,OATAf,GAAuBj9C,IACrBoF,EAAQpK,WACR8iD,EAAoBjmD,MAAQu+C,GAAkBx7C,MAAMI,WAAWgjD,IAE7D5J,EAAU7sC,aACZ6sC,EAAU8J,YAAYD,GAEtB7J,EAAU+J,iBAAiB,OAAQF,GAE9B7H,GAAkBx7C,MAAMG,eAC7B6iD,EACA5iB,GAAqBob,GAAkBx7C,MAAMI,WAAWgjD,GAAkB3kD,EAAMxB,OAEpF,CAAO,GAAIu+C,GAAkBx7C,MAAMsiC,mBAAmB7jC,EAAMxB,OAAQ,CAClE,MAAMoF,EAAO5D,EAAMxB,MAAM4xB,SACzB,IAAK2sB,GAAkBx7C,MAAMwjD,cAAc/kD,EAAMxB,MAAM4xB,UACrD,OAAO2sB,GAAkBx7C,MAAMG,eAC7B6iD,EACAxH,GAAkBx7C,MAAMwb,iBACtBggC,GAAkBx7C,MAAMyjD,UAAUhlD,EAAMxB,MAAMoe,QAChC,eAAdhZ,EAAKxC,KAAwBugC,GAAqBob,GAAkBx7C,MAAMI,WAAWiC,EAAKnE,KAAO,UAAWmE,GAAQm5C,GAAkBx7C,MAAMu5B,iBAC1I,IACAiiB,GAAkBx7C,MAAMyjD,UAAUphD,GAClCm5C,GAAkBx7C,MAAME,cAAc,WAE1B,eAAdmC,EAAKxC,MAIb,CACA,MAAMrB,EAAI+jB,IAAIumB,WACZrqC,EAAMxB,MACN,oEAEJ,CACA,SAASgmD,GAA2BrjC,GAClC,MAAM8jC,EAAQ,QAAU9jC,EAAG1hB,KAC3B,OAAOs9C,GAAkBx7C,MAAMmoB,wBAC7B,CAACiY,GAAqBob,GAAkBx7C,MAAMI,WAAWsjD,GAAQ9jC,IACjE47B,GAAkBx7C,MAAMooB,eAAe,CACrCozB,GAAkBx7C,MAAM4L,oBACtB4vC,GAAkBx7C,MAAM25B,qBACtB,IACAyG,GAAqBob,GAAkBx7C,MAAMI,WAAWwf,EAAG1hB,MAAO0hB,GAClEwgB,GAAqBob,GAAkBx7C,MAAMI,WAAWsjD,GAAQ9jC,OAK1E,CAGwBzhB,EAAQ,yCAAhC,IAaIwlD,GAnuRJ,SAAyBC,GACvB,MAAMl7C,EAAS,CACbvJ,QAAS,CAAC,EACVtB,UAAW,CAAC,EACZP,QAAS,CAAC,EACVQ,UAAW,CAAC,GAEd,IAAK,MAAM+lD,KAASD,EAAW,CAC7B,MAAMvmD,EAAQwmD,EACR5mD,EAAQ2mD,EAAUvmD,GACpBJ,EAAMkC,UAASuJ,EAAOvJ,QAAQ9B,GAASJ,EAAMkC,SAC7ClC,EAAMY,YAAW6K,EAAO7K,UAAUR,GAASJ,EAAMY,WACjDZ,EAAMK,UAASoL,EAAOpL,QAAQD,GAASJ,EAAMK,SAC7CL,EAAMa,YAAW4K,EAAO5K,UAAUT,GAASJ,EAAMa,UACvD,CACA,OAAO4K,CACT,CAmtReo7C,CAAgB,CAC7BC,QAAS9nB,GACT7oB,SAAUmmC,GACVyK,qBAAsB/I,GACtBgJ,kBAAmBrK,GACnBsK,kBAAmB/K,GACnBgL,iBAAkBjL,GAClBkL,WAAYtL,GACZuL,UApBiB,CACjBvmD,UAAW,CACTsoB,IAAAA,CAAKqrB,GACCyI,GAAczI,KAClB/lB,GAAQ+lB,EAAK,GAAGA,EAAK7yC,KAAK3B,QAC1B6tB,GAAa2mB,GACbA,EAAK3xC,SACP,IAcFwkD,SAAUhC,GACViC,iBAAkBhK,GAClBiK,eAAgBlJ,GAChBmJ,aAAczL,KAEZr7C,GAAmB,CAAC,QACpBD,GAAY,QACZ,UAAEG,GAAS,QAAEP,GAAO,UAAEQ,IAAc6lD,GACpC/lD,GAAU,CACZ,C,yDAEE,IACKi7C,GACH15C,QAASwkD,GAASxkD,WAIxB,SAAS5B,GAAqBiJ,EAAQG,GACpC,MAAO,CACL,GAAG1I,EAAqBC,OAAOyI,EAAW,GAAK,YAAuB,SAAXH,EAAoB,OAAS,QAE5F,C","sources":["webpack:///../../node_modules/@marko/runtime-tags/dist/translator/index.js"],"sourcesContent":["\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name2 in all)\n    __defProp(target, name2, { get: all[name2], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/translator/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  analyze: () => analyze,\n  getRuntimeEntryFiles: () => getRuntimeEntryFiles,\n  internalEntryBuilder: () => entry_builder_default,\n  preferAPI: () => preferAPI,\n  tagDiscoveryDirs: () => tagDiscoveryDirs,\n  taglibs: () => taglibs,\n  transform: () => transform,\n  translate: () => translate\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// src/translator/util/runtime-info.ts\nvar import_package = require(\"../../package.json\");\nvar runtime_info_default = {\n  name: import_package.name,\n  taglibId: \"marko-core\"\n};\n\n// src/translator/core/attrs.ts\nvar import_compiler = require(\"@marko/compiler\");\nvar import_babel_utils = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/assert.ts\nfunction assertNoSpreadAttrs(tag) {\n  for (const attr2 of tag.get(\"attributes\")) {\n    if (attr2.isMarkoSpreadAttribute()) {\n      throw attr2.buildCodeFrameError(\n        `The \\`${tag.get(\"name\").node.value}\\` tag does not support \\`...spread\\` attributes.`\n      );\n    }\n  }\n}\nfunction assertNoBodyContent(tag) {\n  if (tag.node.body.body.length) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${tag.get(\"name\").node.value}\\` tag does not support body content.`\n    );\n  }\n}\n\n// src/translator/core/attrs.ts\nvar attrs_default = {\n  migrate: [\n    (tag) => {\n      (0, import_babel_utils.assertNoArgs)(tag);\n      (0, import_babel_utils.assertNoParams)(tag);\n      (0, import_babel_utils.assertNoAttributes)(tag);\n      assertNoBodyContent(tag);\n      (0, import_babel_utils.assertNoAttributeTags)(tag);\n      (0, import_babel_utils.diagnosticDeprecate)(tag, {\n        label: \"The `attrs` tag is deprecated, prefer destructuring `input` via the `const` tag.\",\n        fix() {\n          const tagVar = tag.node.var;\n          if (tagVar && !(tagVar.type === \"Identifier\" && tagVar.name === \"input\")) {\n            const constTag = import_compiler.types.markoTag(\n              import_compiler.types.stringLiteral(\"const\"),\n              [import_compiler.types.markoAttribute(\"value\", import_compiler.types.identifier(\"input\"))],\n              import_compiler.types.markoTagBody([])\n            );\n            constTag.var = tagVar;\n            tag.replaceWith(constTag);\n          } else {\n            tag.remove();\n          }\n        }\n      });\n    }\n  ],\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"attrs/{ ... }\",\n      description: \"Use to receive the attributes passed into this template.\",\n      snippet: \"attrs/{ $1 }$2\"\n    }\n  ]\n};\n\n// src/translator/core/await.ts\nvar import_compiler25 = require(\"@marko/compiler\");\nvar import_babel_utils18 = require(\"@marko/compiler/babel-utils\");\n\n// src/common/accessor.debug.ts\nvar AccessorPrefix = /* @__PURE__ */ ((AccessorPrefix4) => {\n  AccessorPrefix4[\"ClosureScopes\"] = \"ClosureScopes:\";\n  AccessorPrefix4[\"ClosureSignalIndex\"] = \"ClosureSignalIndex:\";\n  AccessorPrefix4[\"ConditionalRenderer\"] = \"ConditionalRenderer:\";\n  AccessorPrefix4[\"ConditionalScope\"] = \"ConditionalScope:\";\n  AccessorPrefix4[\"ControlledHandler\"] = \"ControlledHandler:\";\n  AccessorPrefix4[\"ControlledType\"] = \"ControlledType:\";\n  AccessorPrefix4[\"ControlledValue\"] = \"ControlledValue:\";\n  AccessorPrefix4[\"DynamicPlaceholderLastChild\"] = \"DynamicPlaceholderLastChild:\";\n  AccessorPrefix4[\"EventAttributes\"] = \"EventAttributes:\";\n  AccessorPrefix4[\"Getter\"] = \"Getter:\";\n  AccessorPrefix4[\"LifecycleAbortController\"] = \"LifecycleAbortController:\";\n  AccessorPrefix4[\"LoopScopeArray\"] = \"LoopScopeArray:\";\n  AccessorPrefix4[\"LoopScopeMap\"] = \"LoopScopeMap:\";\n  AccessorPrefix4[\"Promise\"] = \"Promise:\";\n  AccessorPrefix4[\"TagVariableChange\"] = \"TagVariableChange:\";\n  return AccessorPrefix4;\n})(AccessorPrefix || {});\nvar AccessorProp = /* @__PURE__ */ ((AccessorProp4) => {\n  AccessorProp4[\"Owner\"] = \"_\";\n  AccessorProp4[\"BranchAccessor\"] = \"#BranchAccessor\";\n  AccessorProp4[\"CatchContent\"] = \"#CatchContent\";\n  AccessorProp4[\"PlaceholderBranch\"] = \"#PlaceholderBranch\";\n  AccessorProp4[\"PlaceholderContent\"] = \"#PlaceholderContent\";\n  AccessorProp4[\"TagVariable\"] = \"#TagVariable\";\n  AccessorProp4[\"TagVariableChange\"] = \"#TagVariableChange\";\n  AccessorProp4[\"ClosestBranchId\"] = \"#ClosestBranchId\";\n  return AccessorProp4;\n})(AccessorProp || {});\n\n// src/translator/util/evaluate.ts\nvar import_babel_utils2 = require(\"@marko/compiler/babel-utils\");\nfunction evaluate(value) {\n  let { extra } = value;\n  if (!extra) {\n    extra = value.extra = {};\n  }\n  if (extra.confident === void 0) {\n    const computed = (0, import_babel_utils2.computeNode)(value);\n    if (computed) {\n      extra.computed = computed.value;\n      extra.confident = true;\n      extra.nullable = computed.value == null;\n    } else {\n      extra.computed = void 0;\n      extra.confident = false;\n      extra.nullable = isNullableExpr(value);\n    }\n  }\n  return extra;\n}\nfunction isNullableExpr(expr) {\n  switch (expr.type) {\n    case \"ArrayExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"BigIntLiteral\":\n    case \"BinaryExpression\":\n    case \"BooleanLiteral\":\n    case \"ClassExpression\":\n    case \"FunctionExpression\":\n    case \"NewExpression\":\n    case \"NumericLiteral\":\n    case \"ObjectExpression\":\n    case \"RegExpLiteral\":\n    case \"StringLiteral\":\n    case \"TemplateLiteral\":\n    case \"UpdateExpression\":\n      return false;\n    case \"AssignmentExpression\":\n      switch (expr.operator) {\n        case \"=\":\n          return isNullableExpr(expr.right);\n        case \"*=\":\n        case \"/=\":\n        case \"%=\":\n        case \"+=\":\n        case \"-=\":\n        case \"<<=\":\n        case \">>=\":\n        case \">>>=\":\n        case \"&=\":\n        case \"^=\":\n        case \"|=\":\n        case \"**=\":\n          return false;\n        case \"||=\":\n        case \"??=\":\n          return isNullableExpr(expr.right) || isNullableExpr(expr.left);\n        case \"&&=\":\n          return isNullableExpr(expr.left) && isNullableExpr(expr.right);\n        default:\n          return true;\n      }\n    case \"AwaitExpression\":\n      return isNullableExpr(expr.argument);\n    case \"ConditionalExpression\":\n      return isNullableExpr(expr.consequent) && isNullableExpr(expr.alternate);\n    case \"LogicalExpression\":\n      switch (expr.operator) {\n        case \"||\":\n        case \"??\":\n          return isNullableExpr(expr.right) || isNullableExpr(expr.left);\n        case \"&&\":\n          return isNullableExpr(expr.left) && isNullableExpr(expr.right);\n        default:\n          return true;\n      }\n    case \"ParenthesizedExpression\":\n      return isNullableExpr(expr.expression);\n    case \"SequenceExpression\":\n      return isNullableExpr(expr.expressions[expr.expressions.length - 1]);\n    case \"UnaryExpression\":\n      return expr.operator === \"void\";\n    default:\n      return true;\n  }\n}\n\n// src/translator/util/references.ts\nvar import_compiler24 = require(\"@marko/compiler\");\nvar import_babel_utils17 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/for-each-identifier.ts\nfunction forEachIdentifier(node, cb) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        switch (prop.type) {\n          case \"ObjectProperty\":\n            if (prop.value.type === \"AssignmentPattern\") {\n              forEachIdentifier(prop.value.left, cb);\n            } else {\n              forEachIdentifier(prop.value, cb);\n            }\n            break;\n          case \"RestElement\":\n            forEachIdentifier(prop.argument, cb);\n            break;\n        }\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const el of node.elements) {\n        if (el != null) {\n          switch (el.type) {\n            case \"RestElement\":\n              forEachIdentifier(el.argument, cb);\n              break;\n            case \"AssignmentPattern\":\n              forEachIdentifier(el.left, cb);\n              break;\n            default:\n              forEachIdentifier(el, cb);\n              break;\n          }\n        }\n      }\n      break;\n    case \"Identifier\":\n      cb(node);\n      break;\n  }\n}\n\n// src/translator/util/generate-uid.ts\nvar import_compiler3 = require(\"@marko/compiler\");\nvar import_babel_utils4 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-compile-stage.ts\nvar import_babel_utils3 = require(\"@marko/compiler/babel-utils\");\nfunction getCompileStage() {\n  return (0, import_babel_utils3.getFile)().___compileStage;\n}\nfunction isTranslate() {\n  return getCompileStage() === \"translate\" /* translate */;\n}\n\n// src/translator/util/traverse.ts\nvar import_compiler2 = require(\"@marko/compiler\");\nvar skip = Symbol(\"skip\");\nfunction traverseReplace(container, key, enter3) {\n  const node = container[key];\n  if (node) {\n    if (Array.isArray(node)) {\n      for (let i = node.length; i--; ) {\n        traverseReplace(node, i, enter3);\n      }\n    } else {\n      const keys = import_compiler2.types.VISITOR_KEYS[node.type];\n      for (let i = keys.length; i--; ) {\n        traverseReplace(node, keys[i], enter3);\n      }\n      const replacement = enter3(node, container, key);\n      if (replacement) container[key] = replacement;\n    }\n  }\n}\nfunction traverseContains(node, check) {\n  if (node) {\n    if (Array.isArray(node)) {\n      for (const item of node) {\n        if (traverseContains(item, check)) {\n          return true;\n        }\n      }\n    } else {\n      switch (check(node)) {\n        case true:\n          return true;\n        case skip:\n          return false;\n      }\n      for (const key of import_compiler2.types.VISITOR_KEYS[node.type]) {\n        if (traverseContains(node[key], check)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction traverse(visit2, node, parent, grandParent) {\n  if (node) {\n    if (Array.isArray(node)) {\n      for (const item of node) {\n        traverse(visit2, item, parent, grandParent);\n      }\n    } else if (visit2(node, parent, grandParent) !== skip) {\n      for (const key of import_compiler2.types.VISITOR_KEYS[node.type]) {\n        traverse(visit2, node[key], node, parent);\n      }\n    }\n  }\n}\n\n// src/translator/util/generate-uid.ts\nvar countsForFile = /* @__PURE__ */ new WeakMap();\nfunction generateUid(name2 = \"\") {\n  const file = (0, import_babel_utils4.getFile)();\n  let counts = countsForFile.get(file);\n  if (!counts) {\n    const { cache } = file.markoOpts;\n    const { filename } = file.opts;\n    const cacheKey = `uid-counts:${filename}`;\n    counts = cache.get(cacheKey);\n    if (counts) {\n      if (isTranslate()) {\n        counts = new Map(counts);\n      }\n    } else {\n      counts = getInitialCounts(file);\n      if (!isTranslate()) {\n        cache.set(cacheKey, counts);\n      }\n    }\n    countsForFile.set(file, counts);\n  }\n  name2 = name2.replace(/^[^a-z$_]|[^a-z$_0-9]/gi, \"\") || \"temp\";\n  name2 = /^\\$?(.*?)\\d*$/.exec(name2)?.[1] || name2;\n  const i = (counts.get(name2) || 0) + 1;\n  const uniqueName = `$${i > 1 ? name2 + i : name2}`;\n  counts.set(name2, i);\n  return uniqueName;\n}\nfunction generateUidIdentifier(name2) {\n  return import_compiler3.types.identifier(generateUid(name2));\n}\nvar sharedUIDsForFile = /* @__PURE__ */ new WeakMap();\nfunction getSharedUid(name2) {\n  const file = (0, import_babel_utils4.getFile)();\n  let sharedUIDs = sharedUIDsForFile.get(file);\n  if (!sharedUIDs) {\n    const { cache } = file.markoOpts;\n    const { filename } = file.opts;\n    const cacheKey = `uid-shared:${filename}`;\n    sharedUIDs = cache.get(cacheKey);\n    if (sharedUIDs) {\n      if (isTranslate()) {\n        sharedUIDs = new Map(sharedUIDs);\n      }\n    } else {\n      sharedUIDs = /* @__PURE__ */ new Map();\n      if (!isTranslate()) {\n        cache.set(cacheKey, sharedUIDs);\n      }\n    }\n    sharedUIDsForFile.set(file, sharedUIDs);\n  }\n  let uniqueName = sharedUIDs.get(name2);\n  if (!uniqueName) {\n    uniqueName = generateUid(name2);\n    sharedUIDs.set(name2, uniqueName);\n  }\n  return uniqueName;\n}\nfunction usedSharedUid(name2) {\n  return !!sharedUIDsForFile.get((0, import_babel_utils4.getFile)())?.has(name2);\n}\nfunction getInitialCounts(file) {\n  const counts = /* @__PURE__ */ new Map();\n  const program = file.path;\n  const countName = (name2) => {\n    const match = /^$(.*?)([1-9]\\d*)?$/.exec(name2);\n    if (match) {\n      const name3 = match[1];\n      const count = match[2] ? +match[2] + 1 : 1;\n      counts.set(name3, Math.max(counts.get(name3) || 0, count));\n    }\n  };\n  for (const name2 in program.scope.globals) {\n    countName(name2);\n  }\n  traverse((node, parent, grandParent) => {\n    if (node.type === \"Identifier\" && import_compiler3.types.isBinding(node, parent, grandParent)) {\n      countName(node.name);\n    }\n  }, program.node);\n  return counts;\n}\n\n// src/common/accessor.ts\nvar AccessorPrefix2 = /* @__PURE__ */ ((AccessorPrefix4) => {\n  AccessorPrefix4[\"ClosureScopes\"] = \"a\";\n  AccessorPrefix4[\"ClosureSignalIndex\"] = \"b\";\n  AccessorPrefix4[\"ConditionalRenderer\"] = \"c\";\n  AccessorPrefix4[\"ConditionalScope\"] = \"d\";\n  AccessorPrefix4[\"ControlledHandler\"] = \"e\";\n  AccessorPrefix4[\"ControlledType\"] = \"f\";\n  AccessorPrefix4[\"ControlledValue\"] = \"g\";\n  AccessorPrefix4[\"DynamicPlaceholderLastChild\"] = \"h\";\n  AccessorPrefix4[\"EventAttributes\"] = \"i\";\n  AccessorPrefix4[\"Getter\"] = \"j\";\n  AccessorPrefix4[\"LifecycleAbortController\"] = \"k\";\n  AccessorPrefix4[\"LoopScopeArray\"] = \"l\";\n  AccessorPrefix4[\"LoopScopeMap\"] = \"m\";\n  AccessorPrefix4[\"Promise\"] = \"n\";\n  AccessorPrefix4[\"TagVariableChange\"] = \"o\";\n  return AccessorPrefix4;\n})(AccessorPrefix2 || {});\nvar AccessorProp2 = /* @__PURE__ */ ((AccessorProp4) => {\n  AccessorProp4[\"Owner\"] = \"_\";\n  AccessorProp4[\"BranchAccessor\"] = \"a\";\n  AccessorProp4[\"CatchContent\"] = \"b\";\n  AccessorProp4[\"PlaceholderBranch\"] = \"c\";\n  AccessorProp4[\"PlaceholderContent\"] = \"d\";\n  AccessorProp4[\"TagVariable\"] = \"e\";\n  AccessorProp4[\"TagVariableChange\"] = \"f\";\n  AccessorProp4[\"ClosestBranchId\"] = \"g\";\n  return AccessorProp4;\n})(AccessorProp2 || {});\n\n// src/translator/util/marko-config.ts\nvar import_babel_utils5 = require(\"@marko/compiler/babel-utils\");\nfunction isOutputHTML() {\n  return getMarkoOpts().output === \"html\";\n}\nfunction isOutputDOM() {\n  return !isOutputHTML();\n}\nfunction getMarkoOpts() {\n  return (0, import_babel_utils5.getFile)().markoOpts;\n}\nfunction isOptimize() {\n  return getMarkoOpts().optimize;\n}\n\n// src/translator/util/get-accessor-char.ts\nfunction getAccessorPrefix() {\n  return isOptimize() ? AccessorPrefix2 : AccessorPrefix;\n}\nfunction getAccessorProp() {\n  return isOptimize() ? AccessorProp2 : AccessorProp;\n}\n\n// src/translator/util/get-root.ts\nfunction getMarkoRoot(path5) {\n  let curPath = path5;\n  do\n    curPath = curPath.parentPath;\n  while (curPath && !isMarko(curPath));\n  return curPath;\n}\nfunction getExprRoot(path5) {\n  let curPath = path5;\n  while (!isMarko(curPath.parentPath)) {\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction getFnRoot(path5) {\n  let curPath = path5;\n  let fnPath;\n  if (curPath.isProgram()) return;\n  while (!isMarko(curPath)) {\n    if (isFunction(curPath)) {\n      fnPath = curPath;\n    } else {\n      switch (curPath.type) {\n        case \"CallExpression\":\n        case \"NewExpression\":\n          fnPath = void 0;\n          break;\n      }\n    }\n    curPath = curPath.parentPath;\n  }\n  return fnPath;\n}\nfunction isMarko(path5) {\n  switch (path5.type) {\n    case \"MarkoTag\":\n    case \"MarkoTagBody\":\n    case \"MarkoAttribute\":\n    case \"MarkoSpreadAttribute\":\n    case \"MarkoPlaceholder\":\n    case \"MarkoScriptlet\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isFunction(path5) {\n  switch (path5.type) {\n    case \"FunctionDeclaration\":\n      return !path5.node.declare;\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ObjectMethod\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// src/translator/util/is-invoked-function.ts\nvar import_compiler4 = require(\"@marko/compiler\");\nfunction isInvokedFunction(expr) {\n  let curPath = expr;\n  while (curPath) {\n    const { parent, node } = curPath;\n    switch (parent.type) {\n      case \"CallExpression\":\n        return parent.callee === node;\n      case \"TSNonNullExpression\":\n        curPath = curPath.parentPath;\n        break;\n      default:\n        return false;\n    }\n  }\n  return false;\n}\n\n// src/translator/util/optional.ts\nvar Sorted = class {\n  constructor(compare) {\n    this.compare = compare;\n  }\n  add(data, item) {\n    return data ? Array.isArray(data) ? addSorted(this.compare, data, item) : joinRepeatable(this.compare, data, item) : item;\n  }\n  union(a, b) {\n    if (a) {\n      if (Array.isArray(a)) {\n        if (b) {\n          if (Array.isArray(b)) {\n            return unionSortedRepeatable(this.compare, a, b);\n          } else {\n            return addSorted(this.compare, a, b);\n          }\n        }\n        return a;\n      }\n      if (b) {\n        if (Array.isArray(b)) {\n          return addSorted(this.compare, [...b], a);\n        }\n        return joinRepeatable(this.compare, b, a);\n      }\n      return a;\n    }\n    return b;\n  }\n  find(data, item) {\n    if (data) {\n      if (Array.isArray(data)) {\n        return findSorted(this.compare, data, item);\n      } else if (this.compare(data, item) === 0) {\n        return data;\n      }\n    }\n  }\n  findIndex(data, item) {\n    if (data) {\n      if (Array.isArray(data)) {\n        return findIndexSorted(this.compare, data, item);\n      } else if (this.compare(data, item) === 0) {\n        return 0;\n      }\n    }\n    return -1;\n  }\n  isSuperset(superset, subset) {\n    if (!subset) {\n      return true;\n    }\n    if (!Array.isArray(subset)) {\n      return this.findIndex(superset, subset) !== -1;\n    }\n    if (!Array.isArray(superset)) {\n      return false;\n    }\n    const subLen = subset.length;\n    const supLen = superset.length;\n    if (subLen > supLen) {\n      return false;\n    }\n    for (let i = subLen; i--; ) {\n      const supIndex = this.findIndex(superset, subset[i]);\n      if (supIndex === -1 || supLen - supIndex <= i) return false;\n    }\n    return true;\n  }\n};\nfunction push(data, item) {\n  if (data) {\n    if (Array.isArray(data)) {\n      data.push(item);\n      return data;\n    }\n    return [data, item];\n  }\n  return item;\n}\nfunction concat(a, b) {\n  if (a) {\n    if (b) {\n      if (Array.isArray(a)) {\n        return a.concat(b);\n      } else if (Array.isArray(b)) {\n        return [a, ...b];\n      } else {\n        return [a, b];\n      }\n    }\n    return a;\n  }\n  return b;\n}\nfunction filter(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      const len = data.length;\n      let result;\n      let i = 0;\n      while (i < len) {\n        let item = data[i++];\n        if (cb(item)) {\n          result = item;\n          while (i < len) {\n            item = data[i++];\n            if (cb(item)) {\n              result = [result, item];\n              while (i < len) {\n                item = data[i++];\n                if (cb(item)) {\n                  result.push(item);\n                }\n              }\n              return result;\n            }\n          }\n          return result;\n        }\n      }\n      return result;\n    }\n    if (cb(data)) {\n      return data;\n    }\n  }\n  return void 0;\n}\nfunction forEach(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      let i = 0;\n      for (const item of data) {\n        cb(item, i++);\n      }\n    } else {\n      cb(data, 0);\n    }\n  }\n}\nfunction fromIter(data) {\n  let one;\n  let many;\n  for (const item of data) {\n    if (many) {\n      many.push(item);\n    } else if (one) {\n      many = [one, item];\n    } else {\n      one = item;\n    }\n  }\n  return many || one;\n}\nfunction find(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      return data.find(cb);\n    }\n    if (cb(data, 0)) {\n      return data;\n    }\n  }\n}\nfunction toArray(data, cb) {\n  return data ? Array.isArray(data) ? data.map(cb) : [cb(data, 0)] : [];\n}\nfunction filterMap(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      const len = data.length;\n      let result;\n      let i = 0;\n      while (i < len) {\n        let item = cb(data[i++]);\n        if (item) {\n          result = item;\n          while (i < len) {\n            item = cb(data[i++]);\n            if (item) {\n              result = [result, item];\n              while (i < len) {\n                item = cb(data[i++]);\n                if (item) {\n                  result.push(item);\n                }\n              }\n              return result;\n            }\n          }\n          return result;\n        }\n      }\n      return result;\n    } else {\n      return cb(data);\n    }\n  }\n}\nfunction findSorted(compare, data, item) {\n  let max = data.length;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const cur = data[mid];\n    const compareResult = compare(cur, item);\n    if (compareResult === 0) return cur;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n}\nfunction findIndexSorted(compare, data, item) {\n  let max = data.length;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(data[mid], item);\n    if (compareResult === 0) return mid;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n  return -1;\n}\nfunction addSorted(compare, data, item) {\n  const len = data.length;\n  let max = len;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(data[mid], item);\n    if (compareResult === 0) return data;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n  const result = new Array(len + 1);\n  for (let i = 0; i < pos; i++) {\n    result[i] = data[i];\n  }\n  let cur = item;\n  while (pos < len) {\n    const next = cur;\n    cur = data[pos];\n    result[pos++] = next;\n  }\n  result[len] = cur;\n  return result;\n}\nfunction unionSortedRepeatable(compare, a, b) {\n  const aLen = a.length;\n  const bLen = b.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  const result = [];\n  while (aIndex < aLen && bIndex < bLen) {\n    const aValue = a[aIndex];\n    const bValue = b[bIndex];\n    const delta = compare(aValue, bValue);\n    if (delta === 0) {\n      aIndex++;\n      bIndex++;\n      result.push(aValue);\n    } else if (delta < 0) {\n      aIndex++;\n      result.push(aValue);\n    } else {\n      bIndex++;\n      result.push(bValue);\n    }\n  }\n  if (aLen === bLen && aIndex === aLen) {\n    return a;\n  }\n  while (aIndex < aLen) {\n    result.push(a[aIndex++]);\n  }\n  while (bIndex < bLen) {\n    result.push(b[bIndex++]);\n  }\n  return result;\n}\nfunction joinRepeatable(compare, a, b) {\n  const compareResult = compare(a, b);\n  return compareResult === 0 ? a : compareResult < 0 ? [a, b] : [b, a];\n}\n\n// src/translator/util/scope-read.ts\nvar import_compiler23 = require(\"@marko/compiler\");\n\n// src/translator/visitors/program/index.ts\nvar import_compiler22 = require(\"@marko/compiler\");\nvar import_babel_utils16 = require(\"@marko/compiler/babel-utils\");\nvar import_path2 = __toESM(require(\"path\"));\n\n// src/translator/util/binding-has-downstream-expressions.ts\nfunction bindingHasDownstreamExpressions(binding) {\n  if (binding.downstreamExpressions.size) return true;\n  for (const alias of binding.aliases) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  return false;\n}\n\n// src/translator/util/entry-builder.ts\nvar import_compiler5 = require(\"@marko/compiler\");\nvar import_babel_utils6 = require(\"@marko/compiler/babel-utils\");\nvar kState = Symbol();\nvar entry_builder_default = {\n  build(entryFile) {\n    const state = entryFile[kState];\n    if (!state) {\n      throw entryFile.path.buildCodeFrameError(\n        \"Unable to build hydrate code, no files were visited before finalizing the build\"\n      );\n    }\n    const body = state.imports.map(\n      (it) => import_compiler5.types.importDeclaration([], import_compiler5.types.stringLiteral(it))\n    );\n    if (state.init) {\n      body.unshift(\n        import_compiler5.types.importDeclaration(\n          [import_compiler5.types.importSpecifier(import_compiler5.types.identifier(\"init\"), import_compiler5.types.identifier(\"init\"))],\n          import_compiler5.types.stringLiteral(\n            `${runtime_info_default.name}/${entryFile.markoOpts.optimize ? \"\" : \"debug/\"}dom`\n          )\n        )\n      );\n      body.push(\n        import_compiler5.types.expressionStatement(import_compiler5.types.callExpression(import_compiler5.types.identifier(\"init\"), []))\n      );\n    }\n    return body;\n  },\n  visit(file, entryFile, visitChild) {\n    const state = entryFile[kState] ||= {\n      imports: [],\n      init: false\n    };\n    const { analyzedTags } = file.metadata.marko;\n    state.imports.push(\n      (0, import_babel_utils6.resolveRelativePath)(entryFile, file.opts.filename)\n    );\n    state.init ||= file.path.node.extra.hasInteractiveChild || file.path.node.extra.isInteractive || false;\n    for (const tag of analyzedTags || []) {\n      visitChild(tag);\n    }\n  }\n};\n\n// src/translator/util/get-known-attr-values.ts\nfunction getKnownAttrValues(tag) {\n  const attrs2 = {};\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      attrs2[attr2.name] = attr2.value;\n    }\n  }\n  return attrs2;\n}\n\n// src/translator/util/is-core-tag.ts\nvar import_babel_utils7 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-tag-name.ts\nfunction getTagName(tag) {\n  return tag.node.name.value;\n}\n\n// src/translator/util/is-core-tag.ts\nvar { taglibId } = runtime_info_default;\nvar htmlTaglibId = \"marko-html\";\nvar interopTaglibId = \"@marko/translator-interop-class-tags\";\nfunction isCoreTag(tag) {\n  if (tag.isMarkoTag()) {\n    const tagDef = (0, import_babel_utils7.getTagDef)(tag);\n    if (tagDef) {\n      switch (tagDef.taglibId) {\n        case taglibId:\n        case interopTaglibId:\n          return true;\n        case htmlTaglibId:\n          switch (tagDef.name) {\n            case \"script\":\n            case \"style\":\n              return true;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\nfunction isCoreTagName(tag, name2) {\n  return isCoreTag(tag) && getTagName(tag) === name2;\n}\nfunction isConditionTag(tag) {\n  if (isCoreTag(tag)) {\n    switch (getTagName(tag)) {\n      case \"if\":\n      case \"else-if\":\n      case \"else\":\n        return true;\n    }\n  }\n  return false;\n}\nfunction isControlFlowTag(tag) {\n  if (isCoreTag(tag)) {\n    switch (getTagName(tag)) {\n      case \"if\":\n      case \"else-if\":\n      case \"else\":\n      case \"for\":\n      case \"await\":\n      case \"try\":\n        return true;\n    }\n  }\n  return false;\n}\n\n// src/translator/util/runtime.ts\nvar import_compiler7 = require(\"@marko/compiler\");\nvar import_babel_utils8 = require(\"@marko/compiler/babel-utils\");\n\n// src/common/attr-tag.ts\nvar rest = false ? Symbol(\"Attribute Tag\") : Symbol();\n\n// src/common/helpers.ts\nfunction classValue(classValue2) {\n  return toDelimitedString(classValue2, \" \", stringifyClassObject);\n}\nfunction stringifyClassObject(name2, value) {\n  return value ? name2 : \"\";\n}\nfunction styleValue(styleValue2) {\n  return toDelimitedString(styleValue2, \";\", stringifyStyleObject);\n}\nfunction stringifyStyleObject(name2, value) {\n  return value || value === 0 ? `${name2}:${value && typeof value === \"number\" && !/^(--|ta|or|li|z)|cou|nk|it|ag|we|do|w$/.test(name2) ? value + \"px\" : value}` : \"\";\n}\nfunction toDelimitedString(val, delimiter, stringify) {\n  let str = \"\";\n  let sep = \"\";\n  let part;\n  if (val) {\n    if (typeof val !== \"object\") {\n      str += val;\n    } else if (Array.isArray(val)) {\n      for (const v of val) {\n        part = toDelimitedString(v, delimiter, stringify);\n        if (part) {\n          str += sep + part;\n          sep = delimiter;\n        }\n      }\n    } else {\n      for (const name2 in val) {\n        part = stringify(name2, val[name2]);\n        if (part) {\n          str += sep + part;\n          sep = delimiter;\n        }\n      }\n    }\n  }\n  return str;\n}\nfunction isEventHandler(name2) {\n  return /^on[A-Z-]/.test(name2);\n}\nfunction getEventHandlerName(name2) {\n  return name2[2] === \"-\" ? name2.slice(3) : name2.slice(2).toLowerCase();\n}\nfunction isVoid(value) {\n  return value == null || value === false;\n}\n\n// src/html/content.ts\nfunction toString(val) {\n  return val ? val + \"\" : val === 0 ? \"0\" : \"\";\n}\nvar unsafeXMLReg = /[<&]/g;\nvar replaceUnsafeXML = (c) => c === \"&\" ? \"&amp;\" : \"&lt;\";\nvar escapeXMLStr = (str) => unsafeXMLReg.test(str) ? str.replace(unsafeXMLReg, replaceUnsafeXML) : str;\nfunction escapeXML(val) {\n  return val ? escapeXMLStr(val + \"\") : val === 0 ? \"0\" : \"&zwj;\";\n}\nvar unsafeScriptReg = /<\\/script/g;\nvar escapeScriptStr = (str) => unsafeScriptReg.test(str) ? str.replace(unsafeScriptReg, \"\\\\x3C/script\") : str;\nfunction escapeScript(val) {\n  return val ? escapeScriptStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\nvar unsafeStyleReg = /<\\/style/g;\nvar escapeStyleStr = (str) => unsafeStyleReg.test(str) ? str.replace(unsafeStyleReg, \"\\\\3C/style\") : str;\nfunction escapeStyle(val) {\n  return val ? escapeStyleStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\n\n// src/html/serializer.ts\nvar kTouchedIterator = Symbol();\nvar { hasOwnProperty } = {};\nvar Generator = function* () {\n}().constructor;\nvar AsyncGenerator = async function* () {\n}().constructor;\npatchIteratorNext(Generator.prototype);\npatchIteratorNext(AsyncGenerator.prototype);\nvar KNOWN_SYMBOLS = (() => {\n  const KNOWN_SYMBOLS2 = /* @__PURE__ */ new Map();\n  for (const name2 of Object.getOwnPropertyNames(Symbol)) {\n    const symbol = Symbol[name2];\n    if (typeof symbol === \"symbol\") {\n      KNOWN_SYMBOLS2.set(symbol, \"Symbol.\" + name2);\n    }\n  }\n  return KNOWN_SYMBOLS2;\n})();\nvar KNOWN_FUNCTIONS = /* @__PURE__ */ new Map([\n  // This is by no means an exhaustive list,\n  // but it should cover most of the built-in functions.\n  [AggregateError, \"AggregateError\"],\n  [Array, \"Array\"],\n  [Array.from, \"Array.from\"],\n  [Array.isArray, \"Array.isArray\"],\n  [Array.of, \"Array.of\"],\n  [ArrayBuffer, \"ArrayBuffer\"],\n  [ArrayBuffer.isView, \"ArrayBuffer.isView\"],\n  [Atomics.add, \"Atomics.add\"],\n  [Atomics.and, \"Atomics.and\"],\n  [Atomics.compareExchange, \"Atomics.compareExchange\"],\n  [Atomics.exchange, \"Atomics.exchange\"],\n  [Atomics.isLockFree, \"Atomics.isLockFree\"],\n  [Atomics.load, \"Atomics.load\"],\n  [Atomics.notify, \"Atomics.notify\"],\n  [Atomics.or, \"Atomics.or\"],\n  [Atomics.store, \"Atomics.store\"],\n  [Atomics.sub, \"Atomics.sub\"],\n  [Atomics.wait, \"Atomics.wait\"],\n  [BigInt, \"BigInt\"],\n  [BigInt.asIntN, \"BigInt.asIntN\"],\n  [BigInt.asUintN, \"BigInt.asUintN\"],\n  [BigInt64Array, \"BigInt64Array\"],\n  [BigInt64Array.from, \"BigInt64Array.from\"],\n  [BigInt64Array.of, \"BigInt64Array.of\"],\n  [BigUint64Array, \"BigUint64Array\"],\n  [BigUint64Array.from, \"BigUint64Array.from\"],\n  [BigUint64Array.of, \"BigUint64Array.of\"],\n  [Boolean, \"Boolean\"],\n  [console.assert, \"console.assert\"],\n  [console.clear, \"console.clear\"],\n  [console.count, \"console.count\"],\n  [console.countReset, \"console.countReset\"],\n  [console.debug, \"console.debug\"],\n  [console.dir, \"console.dir\"],\n  [console.dirxml, \"console.dirxml\"],\n  [console.error, \"console.error\"],\n  [console.group, \"console.group\"],\n  [console.groupCollapsed, \"console.groupCollapsed\"],\n  [console.groupEnd, \"console.groupEnd\"],\n  [console.info, \"console.info\"],\n  [console.log, \"console.log\"],\n  [console.table, \"console.table\"],\n  [console.time, \"console.time\"],\n  [console.timeEnd, \"console.timeEnd\"],\n  [console.timeLog, \"console.timeLog\"],\n  [console.timeStamp, \"console.timeStamp\"],\n  [console.trace, \"console.trace\"],\n  [console.warn, \"console.warn\"],\n  [DataView, \"DataView\"],\n  [Date, \"Date\"],\n  [Date.now, \"Date.now\"],\n  [Date.parse, \"Date.parse\"],\n  [Date.UTC, \"Date.UTC\"],\n  [decodeURI, \"decodeURI\"],\n  [decodeURIComponent, \"decodeURIComponent\"],\n  [encodeURI, \"encodeURI\"],\n  [encodeURIComponent, \"encodeURIComponent\"],\n  [Error, \"Error\"],\n  [EvalError, \"EvalError\"],\n  [Float32Array, \"Float32Array\"],\n  [Float32Array.from, \"Float32Array.from\"],\n  [Float32Array.of, \"Float32Array.of\"],\n  [Float64Array, \"Float64Array\"],\n  [Float64Array.from, \"Float64Array.from\"],\n  [Float64Array.of, \"Float64Array.of\"],\n  [Function, \"Function\"],\n  [globalThis.atob, \"atob\"],\n  [globalThis.btoa, \"btoa\"],\n  [globalThis.clearImmediate, \"clearImmediate\"],\n  [globalThis.clearInterval, \"clearInterval\"],\n  [globalThis.clearTimeout, \"clearTimeout\"],\n  [globalThis.crypto?.getRandomValues, \"crypto.getRandomValues\"],\n  [globalThis.crypto?.randomUUID, \"crypto.randomUUID\"],\n  [globalThis.fetch, \"fetch\"],\n  [globalThis.performance?.now, \"performance.now\"],\n  [globalThis.queueMicrotask, \"queueMicrotask\"],\n  [globalThis.setImmediate, \"setImmediate\"],\n  [globalThis.setInterval, \"setInterval\"],\n  [globalThis.setTimeout, \"setTimeout\"],\n  [globalThis.structuredClone, \"structuredClone\"],\n  [globalThis.URL, \"URL\"],\n  [globalThis.URLSearchParams, \"URLSearchParams\"],\n  [globalThis.WritableStream, \"WritableStream\"],\n  [Int16Array, \"Int16Array\"],\n  [Int16Array.from, \"Int16Array.from\"],\n  [Int16Array.of, \"Int16Array.of\"],\n  [Int32Array, \"Int32Array\"],\n  [Int32Array.from, \"Int32Array.from\"],\n  [Int32Array.of, \"Int32Array.of\"],\n  [Int8Array, \"Int8Array\"],\n  [Int8Array.from, \"Int8Array.from\"],\n  [Int8Array.of, \"Int8Array.of\"],\n  [Intl.Collator, \"Intl.Collator\"],\n  [Intl.DateTimeFormat, \"Intl.DateTimeFormat\"],\n  [Intl.DisplayNames, \"Intl.DisplayNames\"],\n  [Intl.getCanonicalLocales, \"Intl.getCanonicalLocales\"],\n  [Intl.ListFormat, \"Intl.ListFormat\"],\n  [Intl.Locale, \"Intl.Locale\"],\n  [Intl.NumberFormat, \"Intl.NumberFormat\"],\n  [Intl.PluralRules, \"Intl.PluralRules\"],\n  [Intl.RelativeTimeFormat, \"Intl.RelativeTimeFormat\"],\n  [Intl.Segmenter, \"Intl.Segmenter\"],\n  [Intl.supportedValuesOf, \"Intl.supportedValuesOf\"],\n  [isFinite, \"isFinite\"],\n  [isNaN, \"isNaN\"],\n  [JSON.parse, \"JSON.parse\"],\n  [JSON.stringify, \"JSON.stringify\"],\n  [Map, \"Map\"],\n  [Map.groupBy, \"Map.groupBy\"],\n  [Math.abs, \"Math.abs\"],\n  [Math.acos, \"Math.acos\"],\n  [Math.acosh, \"Math.acosh\"],\n  [Math.asin, \"Math.asin\"],\n  [Math.asinh, \"Math.asinh\"],\n  [Math.atan, \"Math.atan\"],\n  [Math.atan2, \"Math.atan2\"],\n  [Math.atanh, \"Math.atanh\"],\n  [Math.cbrt, \"Math.cbrt\"],\n  [Math.ceil, \"Math.ceil\"],\n  [Math.clz32, \"Math.clz32\"],\n  [Math.cos, \"Math.cos\"],\n  [Math.cosh, \"Math.cosh\"],\n  [Math.exp, \"Math.exp\"],\n  [Math.expm1, \"Math.expm1\"],\n  [Math.floor, \"Math.floor\"],\n  [Math.fround, \"Math.fround\"],\n  [Math.hypot, \"Math.hypot\"],\n  [Math.imul, \"Math.imul\"],\n  [Math.log, \"Math.log\"],\n  [Math.log10, \"Math.log10\"],\n  [Math.log1p, \"Math.log1p\"],\n  [Math.log2, \"Math.log2\"],\n  [Math.max, \"Math.max\"],\n  [Math.min, \"Math.min\"],\n  [Math.pow, \"Math.pow\"],\n  [Math.random, \"Math.random\"],\n  [Math.round, \"Math.round\"],\n  [Math.sign, \"Math.sign\"],\n  [Math.sin, \"Math.sin\"],\n  [Math.sinh, \"Math.sinh\"],\n  [Math.sqrt, \"Math.sqrt\"],\n  [Math.tan, \"Math.tan\"],\n  [Math.tanh, \"Math.tanh\"],\n  [Math.trunc, \"Math.trunc\"],\n  [Number, \"Number\"],\n  [Number.isFinite, \"Number.isFinite\"],\n  [Number.isInteger, \"Number.isInteger\"],\n  [Number.isNaN, \"Number.isNaN\"],\n  [Number.isSafeInteger, \"Number.isSafeInteger\"],\n  [Number.parseFloat, \"Number.parseFloat\"],\n  [Number.parseInt, \"Number.parseInt\"],\n  [Object, \"Object\"],\n  [Object.assign, \"Object.assign\"],\n  [Object.create, \"Object.create\"],\n  [Object.defineProperties, \"Object.defineProperties\"],\n  [Object.defineProperty, \"Object.defineProperty\"],\n  [Object.entries, \"Object.entries\"],\n  [Object.freeze, \"Object.freeze\"],\n  [Object.fromEntries, \"Object.fromEntries\"],\n  [Object.getOwnPropertyDescriptor, \"Object.getOwnPropertyDescriptor\"],\n  [Object.getOwnPropertyDescriptors, \"Object.getOwnPropertyDescriptors\"],\n  [Object.getOwnPropertyNames, \"Object.getOwnPropertyNames\"],\n  [Object.getOwnPropertySymbols, \"Object.getOwnPropertySymbols\"],\n  [Object.getPrototypeOf, \"Object.getPrototypeOf\"],\n  [Object.is, \"Object.is\"],\n  [Object.isExtensible, \"Object.isExtensible\"],\n  [Object.isFrozen, \"Object.isFrozen\"],\n  [Object.isSealed, \"Object.isSealed\"],\n  [Object.keys, \"Object.keys\"],\n  [Object.preventExtensions, \"Object.preventExtensions\"],\n  [Object.seal, \"Object.seal\"],\n  [Object.setPrototypeOf, \"Object.setPrototypeOf\"],\n  [Object.values, \"Object.values\"],\n  [parseFloat, \"parseFloat\"],\n  [parseInt, \"parseInt\"],\n  [Promise, \"Promise\"],\n  [Proxy, \"Proxy\"],\n  [RangeError, \"RangeError\"],\n  [ReferenceError, \"ReferenceError\"],\n  [Reflect.apply, \"Reflect.apply\"],\n  [Reflect.construct, \"Reflect.construct\"],\n  [Reflect.defineProperty, \"Reflect.defineProperty\"],\n  [Reflect.deleteProperty, \"Reflect.deleteProperty\"],\n  [Reflect.get, \"Reflect.get\"],\n  [Reflect.getOwnPropertyDescriptor, \"Reflect.getOwnPropertyDescriptor\"],\n  [Reflect.getPrototypeOf, \"Reflect.getPrototypeOf\"],\n  [Reflect.has, \"Reflect.has\"],\n  [Reflect.isExtensible, \"Reflect.isExtensible\"],\n  [Reflect.ownKeys, \"Reflect.ownKeys\"],\n  [Reflect.preventExtensions, \"Reflect.preventExtensions\"],\n  [Reflect.set, \"Reflect.set\"],\n  [Reflect.setPrototypeOf, \"Reflect.setPrototypeOf\"],\n  [RegExp, \"RegExp\"],\n  [Set, \"Set\"],\n  [String, \"String\"],\n  [String.fromCharCode, \"String.fromCharCode\"],\n  [String.fromCodePoint, \"String.fromCodePoint\"],\n  [String.raw, \"String.raw\"],\n  [Symbol, \"Symbol\"],\n  [Symbol.for, \"Symbol.for\"],\n  [SyntaxError, \"SyntaxError\"],\n  [TypeError, \"TypeError\"],\n  [Uint16Array, \"Uint16Array\"],\n  [Uint16Array.from, \"Uint16Array.from\"],\n  [Uint16Array.of, \"Uint16Array.of\"],\n  [Uint32Array, \"Uint32Array\"],\n  [Uint32Array.from, \"Uint32Array.from\"],\n  [Uint32Array.of, \"Uint32Array.of\"],\n  [Uint8Array, \"Uint8Array\"],\n  [Uint8Array.from, \"Uint8Array.from\"],\n  [Uint8Array.of, \"Uint8Array.of\"],\n  [Uint8ClampedArray, \"Uint8ClampedArray\"],\n  [Uint8ClampedArray.from, \"Uint8ClampedArray.from\"],\n  [Uint8ClampedArray.of, \"Uint8ClampedArray.of\"],\n  [URIError, \"URIError\"],\n  [WeakMap, \"WeakMap\"],\n  [WeakSet, \"WeakSet\"]\n]);\nvar KNOWN_OBJECTS = /* @__PURE__ */ new Map([\n  [Atomics, \"Atomics\"],\n  [console, \"console\"],\n  [globalThis, \"globalThis\"],\n  [globalThis.crypto, \"crypto\"],\n  [Intl, \"Intl\"],\n  [JSON, \"JSON\"],\n  [Math, \"Math\"],\n  [Reflect, \"Reflect\"]\n]);\nfunction toAccess(accessor) {\n  const start = accessor[0];\n  return start === '\"' || start >= \"0\" && start <= \"9\" ? \"[\" + accessor + \"]\" : \".\" + accessor;\n}\nfunction patchIteratorNext(proto) {\n  const { next } = proto;\n  proto.next = function(value) {\n    this[kTouchedIterator] = 1;\n    return next.call(this, value);\n  };\n}\n\n// src/html/writer.ts\nvar K_SCOPE_ID = Symbol(\"Scope ID\");\nvar kPendingContexts = Symbol(\"Pending Contexts\");\nvar branchIdKey = Symbol();\nif (false) {\n  writeScope = /* @__PURE__ */ ((writeScope2) => (scopeId, partialScope, file, loc, vars) => {\n    const scope = writeScope2(scopeId, partialScope);\n    if (file && loc !== void 0) {\n      setDebugInfo(scope, file, loc, vars);\n    }\n    return scope;\n  })(writeScope);\n}\nvar tick = globalThis.setImmediate || globalThis.setTimeout || globalThis.queueMicrotask || ((cb) => Promise.resolve().then(cb));\n\n// src/html/attrs.ts\nfunction classAttr(value) {\n  return stringAttr(\"class\", classValue(value));\n}\nfunction styleAttr(value) {\n  return stringAttr(\"style\", styleValue(value));\n}\nvar kSelectedValue = Symbol(\"selectedValue\");\nfunction attr(name2, value) {\n  return isVoid(value) ? \"\" : nonVoidAttr(name2, value);\n}\nfunction stringAttr(name2, value) {\n  return value && \" \" + name2 + attrAssignment(value);\n}\nfunction nonVoidAttr(name2, value) {\n  switch (typeof value) {\n    case \"string\":\n      return \" \" + name2 + attrAssignment(value);\n    case \"boolean\":\n      return \" \" + name2;\n    case \"number\":\n      return \" \" + name2 + \"=\" + value;\n    case \"object\":\n      if (value instanceof RegExp) {\n        return \" \" + name2 + attrAssignment(value.source);\n      }\n      break;\n  }\n  return \" \" + name2 + attrAssignment(value + \"\");\n}\nvar singleQuoteAttrReplacements = /'|&(?=#?\\w+;)/g;\nvar doubleQuoteAttrReplacements = /\"|&(?=#?\\w+;)/g;\nvar needsQuotedAttr = /[\"'>\\s]|&#?\\w+;|\\/$/g;\nfunction attrAssignment(value) {\n  return value ? needsQuotedAttr.test(value) ? value[needsQuotedAttr.lastIndex - 1] === (needsQuotedAttr.lastIndex = 0, '\"') ? \"='\" + escapeSingleQuotedAttrValue(value) + \"'\" : '=\"' + escapeDoubleQuotedAttrValue(value) + '\"' : \"=\" + value : \"\";\n}\nfunction escapeSingleQuotedAttrValue(value) {\n  return singleQuoteAttrReplacements.test(value) ? value.replace(\n    singleQuoteAttrReplacements,\n    replaceUnsafeSingleQuoteAttrChar\n  ) : value;\n}\nfunction replaceUnsafeSingleQuoteAttrChar(match) {\n  return match === \"'\" ? \"&#39;\" : \"&amp;\";\n}\nfunction escapeDoubleQuotedAttrValue(value) {\n  return doubleQuoteAttrReplacements.test(value) ? value.replace(\n    doubleQuoteAttrReplacements,\n    replaceUnsafeDoubleQuoteAttrChar\n  ) : value;\n}\nfunction replaceUnsafeDoubleQuoteAttrChar(match) {\n  return match === '\"' ? \"&#34;\" : \"&amp;\";\n}\n\n// src/common/compat-meta.ts\nvar prefix = false ? \"$compat_\" : \"$C_\";\nvar RENDERER_REGISTER_ID = prefix + (false ? \"renderer\" : \"r\");\nvar SET_SCOPE_REGISTER_ID = prefix + (false ? \"setScope\" : \"s\");\nvar RENDER_BODY_ID = prefix + (false ? \"renderBody\" : \"b\");\n\n// src/html/compat.ts\nvar K_TAGS_API_STATE = Symbol();\n\n// src/translator/util/to-property-name.ts\nvar import_compiler6 = require(\"@marko/compiler\");\nfunction isValidPropertyIdentifier(name2) {\n  return /^[a-z_$][a-z0-9_$]*$/i.test(name2);\n}\nfunction toPropertyName(name2) {\n  if (isValidPropertyIdentifier(name2)) {\n    return import_compiler6.types.identifier(name2);\n  } else if (/^(?:0|[1-9][0-9]*)$/.test(name2)) {\n    return import_compiler6.types.numericLiteral(parseInt(name2, 10));\n  }\n  return import_compiler6.types.stringLiteral(name2);\n}\nfunction toObjectProperty(name2, value) {\n  return import_compiler6.types.objectProperty(toPropertyName(name2), value);\n}\nfunction toMemberExpression(object, key, optional) {\n  const prop = toPropertyName(key);\n  const computed = prop.type !== \"Identifier\";\n  return optional ? import_compiler6.types.optionalMemberExpression(object, prop, computed, true) : import_compiler6.types.memberExpression(object, prop, computed);\n}\n\n// src/translator/util/runtime.ts\nvar pureDOMFunctions = /* @__PURE__ */ new Set([\n  \"awaitTag\",\n  \"conditional\",\n  \"conditionalClosure\",\n  \"createTry\",\n  \"dynamicTag\",\n  \"createRenderer\",\n  \"createContent\",\n  \"createTemplate\",\n  \"dynamicClosure\",\n  \"dynamicClosureRead\",\n  \"intersection\",\n  \"loopClosure\",\n  \"loopIn\",\n  \"loopOf\",\n  \"loopTo\",\n  \"state\",\n  \"value\"\n]);\nfunction importRuntime(name2) {\n  const { output } = getMarkoOpts();\n  return toMemberExpression(\n    (0, import_babel_utils8.importStar)((0, import_babel_utils8.getFile)(), getRuntimePath(output), \"$\"),\n    name2\n  );\n}\nfunction callRuntime(name2, ...args) {\n  const callExpression2 = import_compiler7.types.callExpression(\n    importRuntime(name2),\n    filterArguments(args)\n  );\n  if (isOutputDOM() && pureDOMFunctions.has(name2)) {\n    callExpression2.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: ` @__PURE__ `\n      }\n    ];\n  }\n  return callExpression2;\n}\nfunction getHTMLRuntime() {\n  return {\n    escapeXML,\n    toString,\n    attr,\n    classAttr,\n    styleAttr,\n    escapeScript,\n    escapeStyle\n  };\n}\nfunction getRuntimePath(output) {\n  const { optimize } = getMarkoOpts();\n  return `${runtime_info_default.name}/${optimize ? \"\" : \"debug/\"}${output === \"html\" ? \"html\" : \"dom\"}`;\n}\nfunction filterArguments(args) {\n  const filteredArgs = [];\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (arg || filteredArgs.length) {\n      filteredArgs[i] = arg || import_compiler7.types.unaryExpression(\"void\", import_compiler7.types.numericLiteral(0));\n    }\n  }\n  return filteredArgs;\n}\nfunction getCompatRuntimeFile() {\n  const markoOpts = getMarkoOpts();\n  return `marko/src/runtime/helpers/tags-compat/${isOutputHTML() ? \"html\" : \"dom\"}${markoOpts.optimize ? \"\" : \"-debug\"}.${markoOpts.modules === \"esm\" ? \"mjs\" : \"js\"}`;\n}\n\n// src/translator/util/sections.ts\nvar import_compiler10 = require(\"@marko/compiler\");\nvar import_babel_utils11 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/serialize-reasons.ts\nvar import_compiler8 = require(\"@marko/compiler\");\nvar reasonExprs = /* @__PURE__ */ new WeakMap();\nvar keyedReasonExprs = /* @__PURE__ */ new WeakMap();\nvar serializeKeysByBinding = /* @__PURE__ */ new WeakMap();\nvar serializeKeyBySourceModifier = {};\nfunction forceOwnersSerialize(from, to, prop) {\n  let cur = from;\n  while (cur !== to && cur.parent) {\n    forceSectionSerialize(cur, prop);\n    cur = cur.parent;\n  }\n}\nfunction addOwnersSerializeReason(from, to, reason, prop) {\n  if (reason) {\n    let cur = from;\n    while (cur !== to && cur.parent) {\n      addSectionSerializeReason(cur, reason, prop);\n      cur = cur.parent;\n    }\n  }\n}\nfunction forceSectionSerialize(section, prop) {\n  if (prop) {\n    forceSerializeKey(section, getSectionPropSerializeReasonKey(section, prop));\n  } else if (section.serializeReason !== true) {\n    reasonExprs.delete(section);\n    setSectionSerializeReason(section, true);\n  }\n}\nfunction forceBindingSerialize(section, binding, prefix2) {\n  forceSerializeKey(section, getBindingSerializeReasonKey(binding, prefix2));\n}\nfunction forceSerializeKey(section, key) {\n  if (section.serializeReasons.get(key) !== true) {\n    setSectionKeyedSerializeReason(section, key, true);\n    keyedReasonExprs.get(section)?.delete(key);\n  }\n}\nfunction isBindingForceSerialized(section, binding, prefix2) {\n  return section.serializeReasons.get(\n    getBindingSerializeReasonKey(binding, prefix2)\n  ) === true;\n}\nfunction addSectionSerializeReasonExpr(section, expr, prop) {\n  if (expr) {\n    if (prop) {\n      addKeyedSerializeReasonExpr(\n        section,\n        getSectionPropSerializeReasonKey(section, prop),\n        expr\n      );\n    } else if (section.serializeReason !== true) {\n      if (expr === true) {\n        forceSectionSerialize(section);\n      } else {\n        const existingExpr = reasonExprs.get(section);\n        reasonExprs.set(\n          section,\n          existingExpr ? concat(existingExpr, expr) : expr\n        );\n      }\n    }\n  }\n}\nfunction addBindingSerializeReasonExpr(section, binding, expr, prefix2) {\n  const key = getBindingSerializeReasonKey(binding, prefix2);\n  if (expr && section.serializeReasons.get(key) !== true) {\n    addKeyedSerializeReasonExpr(section, key, expr);\n  }\n}\nfunction addKeyedSerializeReasonExpr(section, key, expr) {\n  if (expr === true) {\n    forceSerializeKey(section, key);\n  } else {\n    let existingExpr;\n    let keyedExprs = keyedReasonExprs.get(section);\n    if (keyedExprs) {\n      existingExpr = keyedExprs.get(key);\n    } else {\n      keyedExprs = /* @__PURE__ */ new Map();\n      keyedReasonExprs.set(section, keyedExprs);\n    }\n    keyedExprs.set(key, existingExpr ? concat(existingExpr, expr) : expr);\n  }\n}\nfunction addSectionSerializeReasonRef(section, ref, prop) {\n  if (ref) {\n    if (prop) {\n      addKeyedSerializeReasonRef(\n        section,\n        getSectionPropSerializeReasonKey(section, prop),\n        ref\n      );\n    } else {\n      const existingReason = section.serializeReason;\n      if (existingReason !== true) {\n        if (ref === true) {\n          forceSectionSerialize(section);\n        } else {\n          const reason = getSerializeSourcesForRef(ref);\n          if (reason === true) {\n            forceSectionSerialize(section);\n          } else {\n            setSectionSerializeReason(\n              section,\n              mergeSerializeReasons(existingReason, reason)\n            );\n          }\n        }\n      }\n    }\n  }\n}\nfunction addKeyedSerializeReasonRef(section, key, ref) {\n  const existingReason = section.serializeReasons.get(key);\n  if (existingReason !== true) {\n    if (ref === true) {\n      forceSerializeKey(section, key);\n    } else {\n      const reason = getSerializeSourcesForRef(ref);\n      if (reason === true) {\n        forceSerializeKey(section, key);\n      } else {\n        setSectionKeyedSerializeReason(\n          section,\n          key,\n          mergeSerializeReasons(existingReason, reason)\n        );\n      }\n    }\n  }\n}\nfunction addSectionSerializeReason(section, reason, prop) {\n  if (reason) {\n    if (prop) {\n      addKeyedSerializeReason(\n        section,\n        getSectionPropSerializeReasonKey(section, prop),\n        reason\n      );\n    } else {\n      const existingReason = section.serializeReason;\n      if (existingReason !== true) {\n        if (reason === true) {\n          forceSectionSerialize(section);\n        } else {\n          setSectionSerializeReason(\n            section,\n            mergeSerializeReasons(existingReason, reason)\n          );\n        }\n      }\n    }\n  }\n}\nfunction addBindingSerializeReason(section, binding, reason, prefix2) {\n  if (reason) {\n    addKeyedSerializeReason(\n      section,\n      getBindingSerializeReasonKey(binding, prefix2),\n      reason\n    );\n  }\n}\nfunction addKeyedSerializeReason(section, key, reason) {\n  const existingReason = section.serializeReasons.get(key);\n  if (existingReason !== true) {\n    if (reason === true) {\n      forceSerializeKey(section, key);\n    } else {\n      setSectionKeyedSerializeReason(\n        section,\n        key,\n        mergeSerializeReasons(existingReason, reason)\n      );\n    }\n  }\n}\nfunction getSectionSerializeReason(section, prop) {\n  return prop ? section.serializeReasons.get(\n    getSectionPropSerializeReasonKey(section, prop)\n  ) : section.serializeReason;\n}\nfunction getBindingSerializeReason(section, binding, prefix2) {\n  return section.serializeReasons.get(\n    getBindingSerializeReasonKey(binding, prefix2)\n  );\n}\nfunction getSectionPropSerializeReasonKey(section, prop) {\n  const keys = serializeKeyBySourceModifier[prop] ||= /* @__PURE__ */ new WeakMap();\n  let key = keys.get(section);\n  if (!key) {\n    keys.set(\n      section,\n      key = Symbol(\n        typeof prop === \"symbol\" ? `Symbol(${prop.description})` : prop\n      )\n    );\n  }\n  return key;\n}\nfunction getBindingSerializeReasonKey(binding, prefix2) {\n  const keys = prefix2 ? serializeKeyBySourceModifier[prefix2] ||= /* @__PURE__ */ new WeakMap() : serializeKeysByBinding;\n  let key = keys.get(binding);\n  if (!key) {\n    keys.set(\n      binding,\n      key = Symbol(\n        (prefix2 ? typeof prefix2 === \"symbol\" ? `Symbol(${prefix2.description})` : prefix2 : \"\") + binding.name\n      )\n    );\n  }\n  return key;\n}\nfunction applySerializeReasonExprs(section) {\n  const keyedExprs = keyedReasonExprs.get(section);\n  if (keyedExprs) {\n    keyedReasonExprs.delete(section);\n    for (const [key, exprs] of keyedExprs) {\n      const reason2 = getSerializeSourcesForExprs(exprs);\n      if (reason2) {\n        setSectionKeyedSerializeReason(\n          section,\n          key,\n          mergeSerializeReasons(section.serializeReasons.get(key), reason2)\n        );\n      }\n    }\n  }\n  const reason = getSerializeSourcesForExprs(reasonExprs.get(section));\n  if (reason) {\n    setSectionSerializeReason(\n      section,\n      mergeSerializeReasons(section.serializeReason, reason)\n    );\n  }\n  reasonExprs.delete(section);\n}\nfunction finalizeSectionSerializeReasons(section) {\n  let reason = section.serializeReason;\n  if (reason !== true) {\n    for (const [, keyedReason] of section.serializeReasons) {\n      if (keyedReason === true) {\n        reason = true;\n        break;\n      }\n      reason = mergeSerializeReasons(reason, keyedReason);\n    }\n    setSectionSerializeReason(section, reason);\n  }\n}\nfunction getSerializeSourcesForExpr(expr) {\n  if (isReferencedExtra(expr)) {\n    return getSerializeSourcesForRef(expr.referencedBindings);\n  }\n}\nfunction getSerializeSourcesForExprs(exprs) {\n  if (exprs) {\n    if (Array.isArray(exprs)) {\n      let serializeSource;\n      for (const expr of exprs) {\n        const exprSources = getSerializeSourcesForExpr(expr);\n        if (exprSources === true) return true;\n        serializeSource = bindingUtil.union(serializeSource, exprSources);\n      }\n      return serializeSource;\n    } else {\n      return getSerializeSourcesForExpr(exprs);\n    }\n  }\n}\nfunction getSerializeSourcesForRef(ref) {\n  if (ref) {\n    let allSerializeSources;\n    if (Array.isArray(ref)) {\n      for (const { serializeSources } of ref) {\n        if (serializeSources === true) return serializeSources;\n        allSerializeSources = bindingUtil.union(\n          allSerializeSources,\n          serializeSources\n        );\n      }\n      return allSerializeSources;\n    } else {\n      return ref.serializeSources;\n    }\n  }\n}\nfunction mergeSerializeReasons(a, b) {\n  if (a === true || b === true) return true;\n  return bindingUtil.union(a, b);\n}\nfunction setSectionSerializeReason(section, reason) {\n  section.serializeReason = reason;\n}\nfunction setSectionKeyedSerializeReason(section, key, reason) {\n  section.serializeReasons.set(key, reason);\n}\n\n// src/translator/util/state.ts\nvar import_babel_utils9 = require(\"@marko/compiler/babel-utils\");\nvar createProgramState = (init) => {\n  const map = /* @__PURE__ */ new WeakMap();\n  return [\n    () => {\n      let state = map.get((0, import_babel_utils9.getProgram)());\n      if (!state) {\n        map.set((0, import_babel_utils9.getProgram)(), state = init());\n      }\n      return state;\n    },\n    (value) => {\n      map.set((0, import_babel_utils9.getProgram)(), value);\n    }\n  ];\n};\nfunction createSectionState(key, init) {\n  return [\n    (section) => {\n      const arrayOfSectionData = (0, import_babel_utils9.getProgram)().state[key] ??= {};\n      const sectionData = arrayOfSectionData[section.id] ??= init && init(section);\n      return sectionData;\n    },\n    (section, value) => {\n      const arrayOfSectionData = (0, import_babel_utils9.getProgram)().state[key] ??= {};\n      arrayOfSectionData[section.id] = value;\n    }\n  ];\n}\n\n// src/translator/util/tag-name-type.ts\nvar import_compiler9 = require(\"@marko/compiler\");\nvar import_babel_utils10 = require(\"@marko/compiler/babel-utils\");\nvar MARKO_FILE_REG = /^<.*>$|\\.marko$/;\nfunction analyzeTagNameType(tag) {\n  const extra = tag.node.extra ??= {};\n  if (extra.tagNameType === void 0) {\n    const name2 = tag.get(\"name\");\n    if (name2.isStringLiteral()) {\n      extra.tagNameType = name2.node.value[0] === \"@\" ? 3 /* AttributeTag */ : (0, import_babel_utils10.isNativeTag)(tag) ? 0 /* NativeTag */ : 1 /* CustomTag */;\n      extra.tagNameNullable = extra.tagNameNullable = false;\n    } else if (name2.isIdentifier()) {\n      analyzeExpressionTagName(name2, extra);\n      if (extra.tagNameType === 0 /* NativeTag */) {\n        extra.tagNameType = 2 /* DynamicTag */;\n      }\n    } else if (name2.isTemplateLiteral() && !name2.node.expressions.length) {\n      extra.tagNameType = 0 /* NativeTag */;\n    } else {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n    if (extra.tagNameType === void 0) {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n    if (extra.tagNameType === 1 /* CustomTag */) {\n      const childFile = (0, import_babel_utils10.loadFileForTag)(tag);\n      if (!childFile) {\n        extra.tagNameType = 2 /* DynamicTag */;\n      } else if (childFile.ast.program.extra.featureType === \"class\") {\n        extra.tagNameType = 2 /* DynamicTag */;\n        extra.featureType = \"class\";\n        ((0, import_babel_utils10.getProgram)().node.extra ??= {}).needsCompat = true;\n      }\n    }\n  }\n  return extra.tagNameType;\n}\nfunction analyzeExpressionTagName(name2, extra) {\n  const pending = [name2];\n  let path5;\n  let type;\n  let nullable = false;\n  let tagNameImported;\n  while ((path5 = pending.pop()) && type !== 2 /* DynamicTag */) {\n    if (path5.isConditionalExpression()) {\n      pending.push(path5.get(\"consequent\"));\n      if (path5.node.alternate) {\n        pending.push(path5.get(\"alternate\"));\n      }\n    } else if (path5.isLogicalExpression()) {\n      if (path5.node.operator === \"||\") {\n        pending.push(path5.get(\"left\"));\n      } else {\n        nullable = true;\n      }\n      pending.push(path5.get(\"right\"));\n    } else if (path5.isAssignmentExpression()) {\n      pending.push(path5.get(\"right\"));\n    } else if (path5.isBinaryExpression()) {\n      type = path5.node.operator !== \"+\" || type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path5.isStringLiteral() || path5.isTemplateLiteral()) {\n      type = type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path5.isNullLiteral()) {\n      nullable = true;\n    } else if (path5.isIdentifier()) {\n      if (path5.node.name === \"undefined\") {\n        nullable = true;\n        continue;\n      }\n      const binding = path5.scope.getBinding(path5.node.name);\n      if (!binding) {\n        type = 2 /* DynamicTag */;\n        continue;\n      }\n      if (binding.kind === \"module\") {\n        const decl = binding.path.parent;\n        if (MARKO_FILE_REG.test(decl.source.value) && decl.specifiers.some((it) => import_compiler9.types.isImportDefaultSpecifier(it))) {\n          const resolvedImport = (0, import_babel_utils10.resolveTagImport)(name2, decl.source.value) || decl.source.value;\n          if (type === 0 /* NativeTag */ || tagNameImported && tagNameImported !== resolvedImport) {\n            type = 2 /* DynamicTag */;\n            tagNameImported = void 0;\n          } else {\n            type = 1 /* CustomTag */;\n            tagNameImported = resolvedImport;\n          }\n        } else {\n          type = 2 /* DynamicTag */;\n        }\n        continue;\n      }\n      const bindingTag = binding.path;\n      if (bindingTag.isMarkoTag() && binding.kind === \"local\") {\n        const bindingTagName = bindingTag.get(\"name\").node.value;\n        if (bindingTagName === \"const\") {\n          pending.push(\n            bindingTag.get(\"attributes\")[0].get(\"value\")\n          );\n          continue;\n        }\n        if (bindingTagName === \"let\") {\n          type = 2 /* DynamicTag */;\n          continue;\n        }\n        continue;\n      }\n      type = 2 /* DynamicTag */;\n    } else {\n      type = 2 /* DynamicTag */;\n    }\n  }\n  extra.tagNameType = type;\n  extra.tagNameNullable = nullable;\n  extra.tagNameDynamic = true;\n  if (type === 1 /* CustomTag */ && tagNameImported) {\n    extra.tagNameImported = tagNameImported;\n  }\n}\n\n// src/translator/util/sections.ts\nvar sectionUtil = new Sorted(function compareSections(a, b) {\n  return a.id - b.id;\n});\nfunction startSection(path5) {\n  const extra = path5.node.extra ??= {};\n  let section = extra.section;\n  if (!section && (path5.type === \"Program\" || path5.get(\"body\").length)) {\n    const parentSection = path5.parentPath ? getOrCreateSection(path5.parentPath) : void 0;\n    const sectionNamePath = path5.parentPath?.get(\n      \"name\"\n    );\n    const sectionName = path5.isProgram() ? \"\" : generateUid(sectionNamePath.toString() + \"_content\");\n    const programExtra = path5.hub.file.path.node.extra ??= {};\n    const sections = programExtra.sections ??= [];\n    section = extra.section = {\n      id: sections.length,\n      name: sectionName,\n      loc: sectionNamePath?.node.loc || void 0,\n      depth: parentSection ? parentSection.depth + 1 : 0,\n      parent: parentSection,\n      sectionAccessor: void 0,\n      params: void 0,\n      referencedClosures: void 0,\n      referencedHoists: void 0,\n      bindings: void 0,\n      hoisted: void 0,\n      isHoistThrough: void 0,\n      serializeReason: void 0,\n      serializeReasons: /* @__PURE__ */ new Map(),\n      content: getContentInfo(path5),\n      upstreamExpression: void 0,\n      downstreamBinding: void 0,\n      hasAbortSignal: false,\n      isBranch: false\n    };\n    sections.push(section);\n  }\n  return section;\n}\nfunction getOrCreateSection(path5) {\n  let cur = path5;\n  while (true) {\n    if (cur.type === \"Program\" || cur.type === \"MarkoTagBody\" && !cur.node.attributeTags && !isNativeNode(cur.parentPath)) {\n      return startSection(cur);\n    }\n    cur = cur.parentPath;\n  }\n}\nfunction getSectionForBody(body) {\n  return body.node.extra?.section;\n}\nfunction getSection(path5) {\n  let section;\n  let currentPath = path5;\n  while ((section = currentPath.node.extra?.section) === void 0) {\n    currentPath = currentPath.parentPath;\n  }\n  return section;\n}\nvar [getScopeIdIdentifier] = createSectionState(\n  \"scopeIdIdentifier\",\n  (section) => generateUidIdentifier(`scope${section.id}_id`)\n);\nvar [getSectionParentIsOwner, setSectionParentIsOwner] = createSectionState(\"parentIsOwner\", () => false);\nvar [_getScopeIdentifier] = createSectionState(\n  \"scopeIdentifier\",\n  () => import_compiler10.types.identifier(\"undefined\")\n);\nfunction forEachSection(fn) {\n  const { sections } = (0, import_babel_utils11.getProgram)().node.extra;\n  sections?.forEach(fn);\n}\nfunction forEachSectionReverse(fn) {\n  const { sections } = (0, import_babel_utils11.getProgram)().node.extra;\n  for (let i = sections.length; i--; ) {\n    fn(sections[i]);\n  }\n}\nfunction getContentInfo(path5) {\n  const body = path5.get(\"body\");\n  const contentInfo = {\n    startType: null,\n    endType: null,\n    singleChild: true\n  };\n  for (let endIndex = body.length; endIndex--; ) {\n    const endType = getNodeContentType(body[endIndex], \"endType\", contentInfo);\n    if (endType !== null) {\n      contentInfo.endType = endType;\n      if (endType === 1 /* Dynamic */) {\n        contentInfo.singleChild = false;\n      }\n      for (let startIndex = 0; startIndex < endIndex; startIndex++) {\n        const startType = getNodeContentType(body[startIndex], \"startType\");\n        if (startType !== null) {\n          contentInfo.startType = startType;\n          contentInfo.singleChild = false;\n          return contentInfo;\n        }\n      }\n      contentInfo.startType = getNodeContentType(body[endIndex], \"startType\");\n      return contentInfo;\n    }\n  }\n  return null;\n}\nfunction getNodeContentType(path5, extraMember, contentInfo) {\n  switch (path5.type) {\n    case \"MarkoText\":\n      return 4 /* Text */;\n    case \"MarkoPlaceholder\":\n      return 2 /* Placeholder */;\n    case \"MarkoScriptlet\":\n    case \"MarkoComment\":\n    case \"ImportDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportNamedDeclaration\":\n      return null;\n    case \"MarkoTag\": {\n      const tag = path5;\n      if (isCoreTag(tag)) {\n        switch (tag.node.name.value) {\n          case \"html-comment\":\n            return 0 /* Comment */;\n          case \"html-script\":\n          case \"html-style\":\n            return 3 /* Tag */;\n          case \"for\":\n          case \"if\":\n          case \"await\":\n          case \"try\":\n            return 1 /* Dynamic */;\n          default:\n            return null;\n        }\n      } else if ((0, import_babel_utils11.isNativeTag)(tag)) {\n        return 3 /* Tag */;\n      } else if ((0, import_babel_utils11.isAttributeTag)(tag)) {\n        return null;\n      } else if (import_compiler10.types.isStringLiteral(tag.node.name)) {\n        const tagSection = (0, import_babel_utils11.loadFileForTag)(tag)?.ast.program.extra.section;\n        if (tagSection) {\n          if (tagSection.content) {\n            if (contentInfo && !tagSection.content.singleChild) {\n              if (extraMember === \"endType\") {\n                contentInfo.startType = tagSection.content.startType;\n                contentInfo.singleChild = false;\n              }\n            }\n            return tagSection.content[extraMember];\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n  }\n  return 1 /* Dynamic */;\n}\nvar isSerializedSection = (section) => {\n  if (section.isBranch) return false;\n  const { downstreamBinding } = section;\n  if (downstreamBinding) {\n    return !!getBindingSerializeReason(\n      downstreamBinding.section,\n      downstreamBinding\n    );\n  }\n  return true;\n};\nfunction isImmediateOwner(section, binding) {\n  return section.parent?.id === binding.section.id;\n}\nfunction isDirectClosure(section, closure) {\n  return section.isBranch && isImmediateOwner(section, closure);\n}\nfunction isDynamicClosure(section, closure) {\n  return !isDirectClosure(section, closure);\n}\nfunction getDynamicClosureIndex(closure, closureSection) {\n  let index = 0;\n  find(closure.closureSections, (section) => {\n    if (section === closureSection) return true;\n    if (isDynamicClosure(section, closure)) {\n      index++;\n    }\n    return false;\n  });\n  return index;\n}\nfunction getDirectClosures(section) {\n  if (section.isBranch) {\n    return filter(\n      section.referencedClosures,\n      (closure) => isImmediateOwner(section, closure)\n    );\n  }\n}\nfunction isSameOrChildSection(section, other) {\n  do {\n    if (other === section) {\n      return true;\n    }\n  } while (other = other.parent);\n  return false;\n}\nfunction getCommonSection(section, other) {\n  let ancestor = section;\n  if (other.depth < section.depth) {\n    ancestor = other;\n    other = section;\n  }\n  while (ancestor) {\n    if (other === ancestor || !other.parent) {\n      return ancestor;\n    }\n    other = other.parent;\n    if (other.depth < ancestor.depth) {\n      ancestor = ancestor.parent;\n    }\n  }\n  throw new Error(\"No common section\");\n}\nfunction isNativeNode(tag) {\n  if (isCoreTag(tag)) {\n    switch (tag.node.name.value) {\n      case \"html-comment\":\n      case \"html-script\":\n      case \"html-style\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  return analyzeTagNameType(tag) === 0 /* NativeTag */;\n}\n\n// src/translator/visitors/program/dom.ts\nvar import_compiler21 = require(\"@marko/compiler\");\nvar import_babel_utils15 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-style-file.ts\nvar import_path = __toESM(require(\"path\"));\nfunction getStyleFile(file) {\n  const { filename } = file.opts;\n  const fs = file.markoOpts.fileSystem;\n  const base = getBase(filename);\n  const styleMatch = new RegExp(\n    `^(${escapeRegExp(base)}\\\\.${\"index\" === base ? \"|\" : \"\"})style\\\\.\\\\w+$`\n  );\n  for (const file2 of fs.readdirSync(import_path.default.dirname(filename)).sort()) {\n    if (styleMatch.test(file2)) {\n      return `./${file2}`;\n    }\n  }\n}\nfunction getBase(filename) {\n  const start = filename.lastIndexOf(import_path.default.sep) + 1;\n  const leftDot = filename.indexOf(\".\", start);\n  if (leftDot === -1) {\n    return filename.slice(start);\n  }\n  const rightDot = filename.lastIndexOf(\".\");\n  const closeBracket = leftDot - 1;\n  if (filename[closeBracket] === \"]\") {\n    const openBracket = filename.lastIndexOf(\"[\", closeBracket);\n    if (openBracket > start) {\n      return filename.slice(start, openBracket) + filename.slice(leftDot, rightDot);\n    }\n  }\n  return filename.slice(start, rightDot);\n}\nvar regexpCharsReg = /[\\\\^$.*+?()[\\]{}|]/g;\nfunction escapeRegExp(str) {\n  return str.replace(regexpCharsReg, \"\\\\$&\");\n}\n\n// src/translator/util/signals.ts\nvar import_compiler20 = require(\"@marko/compiler\");\nvar import_babel_utils14 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/core/return.ts\nvar import_compiler17 = require(\"@marko/compiler\");\nvar import_babel_utils13 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-parent-tag.ts\nfunction getParentTag(tag) {\n  const parent = tag.parent.type === \"MarkoTagBody\" ? tag.parentPath.parentPath : tag.parentPath;\n  if (parent.type === \"MarkoTag\") {\n    return parent;\n  }\n}\n\n// src/translator/util/plugin-hooks.ts\nvar import_compiler11 = require(\"@marko/compiler\");\nfunction enter(modulePlugin, path5) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path5;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (isFunctionPlugin(plugin)) {\n    plugin(path5, import_compiler11.types);\n  } else if (plugin.enter) {\n    plugin.enter(path5, import_compiler11.types);\n  }\n  return node !== path5.node;\n}\nfunction exit(modulePlugin, path5) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path5;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (!isFunctionPlugin(plugin) && plugin.exit) {\n    plugin.exit(path5, import_compiler11.types);\n  }\n  return node !== path5.node;\n}\nfunction isModulePlugin(plugin) {\n  return Boolean(plugin.default);\n}\nfunction isFunctionPlugin(plugin) {\n  return typeof plugin === \"function\";\n}\n\n// src/translator/util/visitors.ts\nfunction extractVisitors(visitors2) {\n  const result = {\n    migrate: {},\n    transform: {},\n    analyze: {},\n    translate: {}\n  };\n  for (const _name in visitors2) {\n    const name2 = _name;\n    const value = visitors2[name2];\n    if (value.migrate) result.migrate[name2] = value.migrate;\n    if (value.transform) result.transform[name2] = value.transform;\n    if (value.analyze) result.analyze[name2] = value.analyze;\n    if (value.translate) result.translate[name2] = value.translate;\n  }\n  return result;\n}\nfunction translateByTarget({\n  html,\n  dom\n}) {\n  return {\n    enter(path5) {\n      enter(isOutputHTML() ? html : dom, path5);\n    },\n    exit(path5) {\n      exit(isOutputHTML() ? html : dom, path5);\n    }\n  };\n}\n\n// src/translator/util/writer.ts\nvar import_compiler16 = require(\"@marko/compiler\");\n\n// src/translator/visitors/program/html.ts\nvar import_compiler13 = require(\"@marko/compiler\");\nvar import_babel_utils12 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/is-static.ts\nfunction isStatic(path5) {\n  return path5.isImportDeclaration() || path5.isExportDeclaration() || path5.isMarkoScriptlet({ static: true });\n}\n\n// src/translator/util/simplify-fn.ts\nvar import_compiler12 = require(\"@marko/compiler\");\nfunction simplifyFunction(fn) {\n  switch (fn.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return fn;\n    default:\n      return import_compiler12.types.functionExpression(\n        null,\n        fn.params,\n        fn.body,\n        fn.async,\n        fn.generator\n      );\n  }\n}\n\n// src/translator/visitors/program/html.ts\nfunction getTemplateContentName() {\n  return getSharedUid(\"content\");\n}\nfunction getExprIfSerialized(reason, expr) {\n  return reason ? reason === true ? expr : import_compiler13.types.logicalExpression(\n    \"&&\",\n    callRuntime(\n      \"serializeIf\",\n      import_compiler13.types.identifier(getSharedUid(\"serialize\")),\n      import_compiler13.types.numericLiteral(\n        resolveSerializeReasonId(\n          (0, import_babel_utils12.getProgram)().node.extra.inputSerializeReasons,\n          reason\n        )\n      )\n    ),\n    expr\n  ) : void 0;\n}\nfunction getSerializeGuard(reason) {\n  return callRuntime(\n    \"serializeGuard\",\n    import_compiler13.types.identifier(getSharedUid(\"serialize\")),\n    import_compiler13.types.numericLiteral(\n      resolveSerializeReasonId(\n        (0, import_babel_utils12.getProgram)().node.extra.inputSerializeReasons,\n        reason\n      )\n    )\n  );\n}\nvar html_default = {\n  translate: {\n    exit(program) {\n      flushInto(program);\n      writeHTMLResumeStatements(program);\n      traverseReplace(program.node, \"body\", replaceNode);\n      const renderContent = [];\n      for (const child of program.get(\"body\")) {\n        if (!isStatic(child)) {\n          renderContent.push(child.node);\n          child.remove();\n        } else if (child.isMarkoScriptlet()) {\n          if (child.node.target && child.node.target !== \"server\") {\n            child.remove();\n          } else {\n            child.replaceWithMultiple(child.node.body);\n          }\n        }\n      }\n      const serializeId = usedSharedUid(\"serialize\") && getSharedUid(\"serialize\");\n      const contentId = usedSharedUid(\"content\") && getTemplateContentName();\n      const contentFn = import_compiler13.types.arrowFunctionExpression(\n        serializeId ? [import_compiler13.types.identifier(\"input\"), import_compiler13.types.identifier(serializeId)] : [import_compiler13.types.identifier(\"input\")],\n        import_compiler13.types.blockStatement(renderContent)\n      );\n      const exportDefault = import_compiler13.types.exportDefaultDeclaration(\n        callRuntime(\n          \"createTemplate\",\n          import_compiler13.types.stringLiteral(program.hub.file.metadata.marko.id),\n          contentId ? import_compiler13.types.identifier(contentId) : contentFn\n        )\n      );\n      if (contentId) {\n        program.node.body.push(\n          import_compiler13.types.variableDeclaration(\"const\", [\n            import_compiler13.types.variableDeclarator(import_compiler13.types.identifier(contentId), contentFn)\n          ]),\n          exportDefault\n        );\n      } else {\n        program.node.body.push(exportDefault);\n      }\n    }\n  }\n};\nfunction replaceNode(node, container) {\n  return replaceBindingReadNode(node) || replaceRegisteredFunctionNode(node, container);\n}\nfunction replaceBindingReadNode(node) {\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\": {\n      const { extra } = node;\n      if (extra && !(extra.read && !extra.read.binding.declared || extra.binding && !extra.binding.declared)) {\n        return getReadReplacement(node);\n      }\n    }\n  }\n}\nfunction replaceRegisteredFunctionNode(node, container) {\n  switch (node.type) {\n    case \"ClassMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler13.types.classProperty(node.key, replacement);\n    }\n    case \"ClassPrivateMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler13.types.classPrivateProperty(node.key, replacement);\n    }\n    case \"ObjectMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler13.types.objectProperty(node.key, replacement);\n    }\n    case \"FunctionDeclaration\": {\n      const { extra } = node;\n      if (isRegisteredFnExtra(extra)) {\n        let registeredFnDeclarations = registeredFnDeclarationsByBody.get(\n          container\n        );\n        if (!registeredFnDeclarations) {\n          registeredFnDeclarationsByBody.set(\n            container,\n            registeredFnDeclarations = []\n          );\n        }\n        registeredFnDeclarations.push({\n          id: node.id.name,\n          registerId: extra.registerId\n        });\n      }\n      break;\n    }\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\": {\n      return getRegisteredFnExpression(node);\n    }\n    case \"BlockStatement\":\n    case \"MarkoScriptlet\":\n      addRegisteredDeclarations(node.body);\n      break;\n  }\n}\nvar registeredFnDeclarationsByBody = /* @__PURE__ */ new WeakMap();\nfunction addRegisteredDeclarations(body) {\n  const registeredFnDeclarations = registeredFnDeclarationsByBody.get(body);\n  if (registeredFnDeclarations) {\n    for (const { id, registerId } of registeredFnDeclarations) {\n      body.push(\n        import_compiler13.types.expressionStatement(\n          callRuntime(\n            \"register\",\n            import_compiler13.types.identifier(id),\n            import_compiler13.types.stringLiteral(registerId)\n          )\n        )\n      );\n    }\n  }\n}\nfunction getRegisteredFnExpression(node) {\n  const { extra } = node;\n  if (isRegisteredFnExtra(extra)) {\n    return callRuntime(\n      \"register\",\n      simplifyFunction(node),\n      import_compiler13.types.stringLiteral(extra.registerId),\n      (extra.referencedBindingsInFunction || extra.referencesScope) && getScopeIdIdentifier(extra.section)\n    );\n  }\n}\n\n// src/translator/util/normalize-string-expression.ts\nvar import_compiler14 = require(\"@marko/compiler\");\nfunction normalizeStringExpression(parts) {\n  const strs = [];\n  const exprs = [];\n  let curStr = parts[0];\n  for (let i = 1; i < parts.length; i++) {\n    let content = parts[i];\n    if (typeof content === \"object\") {\n      if (import_compiler14.types.isStringLiteral(content)) {\n        content = content.value;\n      } else if (import_compiler14.types.isTemplateLiteral(content)) {\n        let nextIndex = i + 1;\n        const exprLen = content.expressions.length;\n        shiftItems(parts, nextIndex, content.quasis.length + exprLen);\n        for (let j = 0; j < exprLen; j++) {\n          parts[nextIndex++] = content.quasis[j].value.raw;\n          parts[nextIndex++] = content.expressions[j];\n        }\n        parts[nextIndex] = content.quasis[exprLen].value.raw;\n        continue;\n      } else {\n        exprs.push(content);\n        strs.push(curStr);\n        curStr = \"\";\n        continue;\n      }\n    }\n    curStr += content;\n  }\n  if (exprs.length) {\n    if (exprs.length === 1 && !curStr && !strs[0]) {\n      return exprs[0];\n    }\n    strs.push(curStr);\n    return import_compiler14.types.templateLiteral(\n      strs.map((raw) => import_compiler14.types.templateElement({ raw })),\n      exprs\n    );\n  } else if (curStr) {\n    return import_compiler14.types.stringLiteral(curStr);\n  }\n}\nfunction appendLiteral(arr, str) {\n  arr[arr.length - 1] += str;\n}\nfunction shiftItems(list, start, offset) {\n  for (let i = list.length - 1; i >= start; i--) {\n    list[i + offset] = list[i];\n  }\n}\n\n// src/translator/util/walks.ts\nvar import_compiler15 = require(\"@marko/compiler\");\nvar [getWalks] = createSectionState(\n  \"walks\",\n  () => [\"\"]\n);\nvar [getWalkComment] = createSectionState(\n  \"walkComment\",\n  () => []\n);\nvar [getSteps] = createSectionState(\"steps\", () => []);\nvar walkCodeToName = {\n  [32 /* Get */]: \"get\",\n  [36 /* Inside */]: \"inside\",\n  [37 /* Replace */]: \"replace\",\n  [38 /* EndChild */]: \"endChild\",\n  [47 /* BeginChild */]: \"beginChild\",\n  [48 /* BeginChildWithVar */]: \"beginChildWithVar\",\n  [49 /* DynamicTagWithVar */]: \"dynamicTagWithVar\",\n  [67 /* Next */]: \"next\",\n  [97 /* Over */]: \"over\",\n  [107 /* Out */]: \"out\",\n  [117 /* Multiplier */]: \"multiplier\",\n  [91 /* NextEnd */]: \"nextEnd\",\n  [106 /* OverEnd */]: \"overEnd\",\n  [116 /* OutEnd */]: \"outEnd\",\n  [126 /* MultiplierEnd */]: \"multiplierEnd\"\n};\nfunction enter2(path5) {\n  getSteps(getSection(path5)).push(0 /* Enter */);\n}\nfunction exit2(path5) {\n  getSteps(getSection(path5)).push(1 /* Exit */);\n}\nfunction enterShallow(path5) {\n  getSteps(getSection(path5)).push(0 /* Enter */, 1 /* Exit */);\n}\nfunction injectWalks(tag, expr) {\n  const walks = getWalks(getSection(tag));\n  const walkComment = getWalkComment(getSection(tag));\n  walkComment.push(\n    `${walkCodeToName[tag.node.var ? 48 /* BeginChildWithVar */ : 47 /* BeginChild */]}`,\n    expr.name,\n    walkCodeToName[38 /* EndChild */]\n  );\n  appendLiteral(\n    walks,\n    String.fromCharCode(\n      tag.node.var ? 48 /* BeginChildWithVar */ : 47 /* BeginChild */\n    )\n  );\n  walks.push(expr, String.fromCharCode(38 /* EndChild */));\n}\nfunction visit(path5, code) {\n  if (isOutputHTML()) {\n    return;\n  }\n  const section = getSection(path5);\n  const steps = getSteps(section);\n  const walks = getWalks(section);\n  const walkComment = getWalkComment(section);\n  let walkString = \"\";\n  if (steps.length) {\n    const walkCodes = [];\n    let depth = 0;\n    for (const step of steps) {\n      if (step === 0 /* Enter */) {\n        depth++;\n        walkCodes.push(67 /* Next */);\n      } else {\n        depth--;\n        if (depth >= 0) {\n          walkCodes.length = walkCodes.lastIndexOf(67 /* Next */);\n          walkCodes.push(97 /* Over */);\n        } else {\n          walkCodes.length = walkCodes.lastIndexOf(107 /* Out */) + 1;\n          walkCodes.push(107 /* Out */);\n          depth = 0;\n        }\n      }\n    }\n    let current = walkCodes[0];\n    let count = 0;\n    for (const walk of walkCodes) {\n      if (walk !== current) {\n        walkComment.push(`${walkCodeToName[current]}(${count})`);\n        walkString += nCodeString(current, count);\n        current = walk;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n    walkComment.push(`${walkCodeToName[current]}(${count})`);\n    walkString += nCodeString(current, count);\n    steps.length = 0;\n  }\n  if (code !== void 0) {\n    if (code !== 32 /* Get */) {\n      writeTo(path5)`<!>`;\n    }\n    walkComment.push(`${walkCodeToName[code]}`);\n    walkString += String.fromCharCode(code);\n  }\n  appendLiteral(walks, walkString);\n}\nfunction nCodeString(code, number) {\n  switch (code) {\n    case 67 /* Next */:\n      return toCharString(number, code, 20 /* Next */);\n    case 97 /* Over */:\n      return toCharString(number, code, 10 /* Over */);\n    case 107 /* Out */:\n      return toCharString(number, code, 10 /* Out */);\n    default:\n      throw new Error(`Unexpected walk code: ${code}`);\n  }\n}\nfunction toCharString(number, startCode, rangeSize) {\n  let result = \"\";\n  if (number >= rangeSize) {\n    const multiplier = Math.floor(number / rangeSize);\n    result += toCharString(\n      multiplier,\n      117 /* Multiplier */,\n      10 /* Multiplier */\n    );\n    number -= multiplier * rangeSize;\n  }\n  result += String.fromCharCode(startCode + number);\n  return result;\n}\nfunction getWalkString(section) {\n  const prefix2 = section.content?.startType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const postfix = section.content?.endType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const walks = getWalks(section);\n  const walkLiteral = normalizeStringExpression([prefix2, ...walks, postfix]);\n  if (walkLiteral && walkLiteral.value !== \"\") {\n    walkLiteral.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: \" \" + getWalkComment(section).join(\", \") + \" \"\n      }\n    ];\n  }\n  return walkLiteral;\n}\n\n// src/translator/util/writer.ts\nvar [getWrites] = createSectionState(\n  \"writes\",\n  () => [\"\"]\n);\nvar [getTrailerWrites] = createSectionState(\n  \"trailerWrites\",\n  () => [\"\"]\n);\nfunction writeTo(path5, trailer) {\n  const section = getSection(path5);\n  const get = trailer ? getTrailerWrites : getWrites;\n  return (strs, ...exprs) => {\n    const exprsLen = exprs.length;\n    const writes = get(section);\n    appendLiteral(writes, strs[0]);\n    for (let i = 0; i < exprsLen; i++) {\n      writes.push(exprs[i], strs[i + 1]);\n    }\n  };\n}\nfunction consumeHTML(path5) {\n  const section = getSection(path5);\n  const writes = getWrites(section);\n  const trailers = getTrailerWrites(section);\n  const writeResult = normalizeStringExpression(writes);\n  const trailerResult = normalizeStringExpression(trailers);\n  writes.length = 0;\n  writes[0] = \"\";\n  trailers.length = 0;\n  trailers[0] = \"\";\n  if (writeResult && trailerResult) {\n    return import_compiler16.types.expressionStatement(\n      import_compiler16.types.sequenceExpression([\n        callRuntime(\"write\", writeResult),\n        callRuntime(\"writeTrailers\", trailerResult)\n      ])\n    );\n  } else if (writeResult) {\n    return import_compiler16.types.expressionStatement(callRuntime(\"write\", writeResult));\n  } else if (trailerResult) {\n    return import_compiler16.types.expressionStatement(callRuntime(\"writeTrailers\", trailerResult));\n  }\n}\nfunction flushBefore(path5) {\n  const expr = consumeHTML(path5);\n  if (expr) {\n    path5.insertBefore(expr)[0].skip();\n  }\n}\nfunction flushInto(path5) {\n  const target = path5.isProgram() ? path5 : path5.get(\"body\");\n  const expr = consumeHTML(target);\n  if (expr) {\n    target.node.body.push(expr);\n  }\n}\nfunction getSectionMeta(section) {\n  const writePrefix = section.content?.startType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writePostfix = section.content?.endType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writes = getWrites(section);\n  return {\n    setup: getSetup(section),\n    walks: getWalkString(section),\n    writes: normalizeStringExpression([writePrefix, ...writes, writePostfix])\n  };\n}\nfunction markNode(path5, nodeBinding, reason) {\n  if (nodeBinding.type !== 0 /* dom */) {\n    throw path5.buildCodeFrameError(\n      \"Tried to mark a node that was not determined to need a mark during analyze.\"\n    );\n  }\n  if (isOutputHTML()) {\n    if (reason) {\n      const section = getSection(path5);\n      writeTo(path5)`${callRuntime(\n        \"markResumeNode\",\n        getScopeIdIdentifier(section),\n        getScopeAccessorLiteral(nodeBinding),\n        reason === true ? void 0 : getSerializeGuard(reason)\n      )}`;\n    }\n  }\n}\n\n// src/translator/core/return.ts\nvar tagsWithReturn = /* @__PURE__ */ new WeakSet();\nvar [getSectionReturnValueIdentifier, setReturnValueIdentifier] = createSectionState(\"returnValue\");\nvar return_default = {\n  analyze(tag) {\n    (0, import_babel_utils13.assertNoArgs)(tag);\n    (0, import_babel_utils13.assertNoVar)(tag);\n    (0, import_babel_utils13.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils13.assertAllowedAttributes)(tag, [\"value\", \"valueChange\"]);\n    const parentTag = getParentTag(tag);\n    if (parentTag) {\n      if ((0, import_babel_utils13.isNativeTag)(parentTag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The `return` tag can not be used in a native tag.\"\n        );\n      } else if (isControlFlowTag(parentTag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          `The \\`return\\` tag can not be used under an \\`${parentTag.get(\"name\").toString()}\\` tag.`\n        );\n      }\n    }\n    if (tagsWithReturn.has(tag.parentPath)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        `Cannot have multiple \\`return\\` tags ${tag.parent.type === \"Program\" ? \"for the template\" : \"within a tag's body content\"}.`\n      );\n    } else {\n      tagsWithReturn.add(tag.parentPath);\n    }\n    const attrs2 = getKnownAttrValues(tag.node);\n    if (!attrs2.value) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `return` tag requires a value.\");\n    }\n    if (attrs2.valueChange) {\n      forceSectionSerialize(\n        getOrCreateSection(tag),\n        getAccessorProp().TagVariableChange\n      );\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      exit(tag) {\n        const section = getSection(tag);\n        const attrs2 = getKnownAttrValues(tag.node);\n        flushBefore(tag);\n        if (attrs2.valueChange) {\n          setSectionSerializedValue(\n            section,\n            getAccessorProp().TagVariableChange,\n            attrs2.valueChange\n          );\n        }\n        if (attrs2.value) {\n          const returnId = generateUidIdentifier(\"return\");\n          setReturnValueIdentifier(section, returnId);\n          tag.replaceWith(\n            import_compiler17.types.variableDeclaration(\"const\", [\n              import_compiler17.types.variableDeclarator(returnId, attrs2.value)\n            ])\n          )[0].skip();\n        }\n      }\n    },\n    dom: {\n      exit(tag) {\n        const section = getSection(tag);\n        const attrs2 = getKnownAttrValues(tag.node);\n        if (attrs2.value) {\n          addValue(\n            section,\n            attrs2.value.extra?.referencedBindings,\n            {\n              identifier: importRuntime(\"tagVarSignal\"),\n              hasDownstreamIntersections: () => true\n            },\n            attrs2.value\n          );\n        }\n        if (attrs2.valueChange) {\n          addValue(\n            section,\n            attrs2.valueChange.extra?.referencedBindings,\n            {\n              identifier: importRuntime(\"setTagVarChange\"),\n              hasDownstreamIntersections: () => false\n            },\n            attrs2.valueChange\n          );\n        }\n        tag.remove();\n      }\n    }\n  }),\n  parseOptions: {\n    openTagOnly: true\n  },\n  autocomplete: [\n    {\n      displayText: \"return=<value>\",\n      description: \"Provides a value for use in a parent template.\",\n      snippet: \"return=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#return\"\n    }\n  ]\n};\n\n// src/translator/util/get-defined-binding-expression.ts\nvar import_compiler18 = require(\"@marko/compiler\");\nfunction getDeclaredBindingExpression(binding) {\n  if (binding.declared || !binding.upstreamAlias) {\n    return import_compiler18.types.identifier(binding.name);\n  } else if (binding.property !== void 0) {\n    return toMemberExpression(\n      getDeclaredBindingExpression(binding.upstreamAlias),\n      binding.property,\n      binding.upstreamAlias.nullable\n    );\n  } else {\n    return getDeclaredBindingExpression(binding.upstreamAlias);\n  }\n}\n\n// src/translator/util/to-first-expression-or-block.ts\nvar import_compiler19 = require(\"@marko/compiler\");\nfunction toFirstExpressionOrBlock(stmts) {\n  if (stmts.length === 1 && import_compiler19.types.isExpressionStatement(stmts[0])) {\n    const { expression } = stmts[0];\n    switch (expression.type) {\n      case \"ObjectExpression\":\n      case \"AssignmentExpression\":\n        return toParenthesizedExpressionIfNeeded(expression);\n      default:\n        return expression;\n    }\n  }\n  return import_compiler19.types.blockStatement(stmts);\n}\nfunction toParenthesizedExpressionIfNeeded(expr) {\n  switch (expr.type) {\n    case \"ObjectExpression\":\n    case \"AssignmentExpression\":\n      return import_compiler19.types.parenthesizedExpression(expr);\n    default:\n      return expr;\n  }\n}\n\n// src/translator/util/signals.ts\nvar [getSignals] = createSectionState(\n  \"signals\",\n  () => /* @__PURE__ */ new Map()\n);\nvar [getClosureSignalBuilder, _setClosureSignalBuilder] = createSectionState(\"queue\");\nfunction setClosureSignalBuilder(tag, builder) {\n  _setClosureSignalBuilder(getSectionForBody(tag.get(\"body\")), builder);\n}\nvar [getSerializedAccessors] = createSectionState(\"serializedScopeProperties\", () => /* @__PURE__ */ new Map());\nfunction setSectionSerializedValue(section, prop, expression) {\n  const reason = getSectionSerializeReason(section, prop);\n  if (reason) {\n    getSerializedAccessors(section).set(prop, { expression, reason });\n  }\n}\nfunction setBindingSerializedValue(section, binding, expression, prefix2) {\n  const reason = getBindingSerializeReason(section, binding, prefix2);\n  if (reason) {\n    getSerializedAccessors(section).set(\n      (prefix2 || \"\") + getScopeAccessor(binding),\n      { expression, reason }\n    );\n  }\n}\nvar nonAnalyzedForceSerializedSection = /* @__PURE__ */ new WeakSet();\nfunction setSerializedValue(section, key, expression) {\n  nonAnalyzedForceSerializedSection.add(section);\n  getSerializedAccessors(section).set(key, { expression, reason: true });\n}\nvar [getSectionWriteScopeBuilder, setSectionWriteScopeBuilder] = createSectionState(\n  \"sectionWriteScopeBuilder\"\n);\nfunction addWriteScopeBuilder(section, builder) {\n  const prev = getSectionWriteScopeBuilder(section);\n  setSectionWriteScopeBuilder(\n    section,\n    prev ? (expr) => builder(prev(expr)) : builder\n  );\n}\nvar htmlDynamicClosureInstancesIdentifier = /* @__PURE__ */ new WeakMap();\nvar [getHTMLSectionStatements] = createSectionState(\n  \"htmlScopeStatements\",\n  () => []\n);\nvar [getHoistFunctionsIdsMap] = createSectionState(\"hoistFunctionsIdsMap\", () => /* @__PURE__ */ new Map());\nfunction getHoistFunctionIdentifier(hoistedBinding) {\n  const idsMap = getHoistFunctionsIdsMap(hoistedBinding.section);\n  let identifier = idsMap.get(hoistedBinding);\n  if (!identifier) {\n    idsMap.set(\n      hoistedBinding,\n      identifier = generateUidIdentifier(`get${hoistedBinding.name}`)\n    );\n  }\n  return identifier;\n}\nvar unimplementedBuild = () => {\n  return import_compiler20.types.stringLiteral(\"SIGNAL NOT INITIALIZED\");\n};\nfunction getSignal(section, referencedBindings, name2 = generateSignalName(referencedBindings)) {\n  const signals = getSignals(section);\n  let signal = signals.get(referencedBindings);\n  if (!signal) {\n    const exportName = referencedBindings ? !Array.isArray(referencedBindings) && referencedBindings.section === section && referencedBindings.export : !section.parent && (0, import_babel_utils14.getProgram)().node.extra.domExports?.setup;\n    signals.set(\n      referencedBindings,\n      signal = {\n        identifier: exportName ? import_compiler20.types.identifier(exportName) : generateUidIdentifier(name2 + section.name.replace(\"_\", \"$\")),\n        referencedBindings,\n        section,\n        values: [],\n        intersection: void 0,\n        render: [],\n        renderReferencedBindings: void 0,\n        effect: [],\n        effectReferencedBindings: void 0,\n        subscribers: [],\n        hasDownstreamIntersections: () => {\n          let hasDownstreamIntersections = !!signal.intersection;\n          if (!hasDownstreamIntersections) {\n            for (const value of signal.values) {\n              if (value.signal.hasDownstreamIntersections()) {\n                hasDownstreamIntersections = true;\n                break;\n              }\n            }\n          }\n          if (!hasDownstreamIntersections) {\n            if (!Array.isArray(referencedBindings) && referencedBindings) {\n              for (const alias of referencedBindings.aliases) {\n                if (getSignal(section, alias).hasDownstreamIntersections()) {\n                  hasDownstreamIntersections = true;\n                  break;\n                }\n              }\n              if (!hasDownstreamIntersections) {\n                for (const [, alias] of referencedBindings.propertyAliases) {\n                  if (getSignal(section, alias).hasDownstreamIntersections()) {\n                    hasDownstreamIntersections = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          signal.hasDownstreamIntersections = () => hasDownstreamIntersections;\n          return hasDownstreamIntersections;\n        },\n        build: unimplementedBuild,\n        export: !!exportName\n      }\n    );\n    if (isOutputHTML()) {\n      return signal;\n    } else if (!referencedBindings) {\n      signal.build = () => getSignalFn(signal);\n    } else if (Array.isArray(referencedBindings)) {\n      subscribe(referencedBindings, signal);\n      signal.build = () => {\n        const { id, scopeOffset } = intersectionMeta.get(referencedBindings);\n        return callRuntime(\n          \"intersection\",\n          import_compiler20.types.numericLiteral(id),\n          getSignalFn(signal),\n          scopeOffset || referencedBindings.length > 2 ? import_compiler20.types.numericLiteral(referencedBindings.length - 1) : void 0,\n          scopeOffset && getScopeAccessorLiteral(scopeOffset)\n        );\n      };\n    } else if (referencedBindings.section !== section && bindingUtil.find(section.referencedClosures, referencedBindings)) {\n      signal.build = () => {\n        const render = getSignalFn(signal);\n        const closureSignalBuilder = getClosureSignalBuilder(section);\n        return !closureSignalBuilder || isDynamicClosure(section, referencedBindings) ? callRuntime(\n          \"dynamicClosureRead\",\n          getScopeAccessorLiteral(referencedBindings),\n          render,\n          isImmediateOwner(section, referencedBindings) ? void 0 : import_compiler20.types.arrowFunctionExpression(\n            [scopeIdentifier],\n            getScopeExpression(section, referencedBindings.section)\n          )\n        ) : getClosureSignalBuilder(section)(referencedBindings, render);\n      };\n    }\n  }\n  return signal;\n}\nfunction initValue(binding, runtimeHelper = \"value\") {\n  const section = binding.section;\n  const signal = getSignal(section, binding);\n  signal.build = () => {\n    const fn = getSignalFn(signal);\n    const isParamBinding = !binding.upstreamAlias && (binding.type === 3 /* param */ || binding.type === 2 /* input */);\n    const isNakedAlias = binding.upstreamAlias && !binding.property;\n    const needsGuard = !isNakedAlias && (binding.downstreamExpressions.size || fn.type === \"ArrowFunctionExpression\" && fn.body.body.length > 0);\n    const needsCache = needsGuard || signal.intersection;\n    const needsMarks = isParamBinding || signal.intersection;\n    if (needsCache || needsMarks || binding.hoists.size) {\n      return callRuntime(\n        runtimeHelper,\n        getScopeAccessorLiteral(binding, runtimeHelper === \"state\"),\n        fn\n      );\n    } else {\n      return fn;\n    }\n  };\n  signal.valueAccessor = getScopeAccessorLiteral(binding);\n  for (const alias of binding.aliases) {\n    initValue(alias);\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    initValue(alias);\n  }\n  return signal;\n}\nfunction getSignalFn(signal) {\n  const section = signal.section;\n  const binding = signal.referencedBindings;\n  const params = [scopeIdentifier];\n  const isIntersection = Array.isArray(binding);\n  const isBinding = binding && !isIntersection;\n  const isValue = isBinding && binding.section === section;\n  let canUseCalleeDirectly = !signal.render.length;\n  if (isBinding && (signal.renderReferencedBindings || binding.aliases.size || binding.propertyAliases.size)) {\n    const valueParam = import_compiler20.types.identifier(binding.name);\n    if (binding.loc) {\n      valueParam.loc = binding.loc;\n      valueParam.start = binding.loc.start.index;\n      valueParam.end = binding.loc.end.index;\n    }\n    params.push(valueParam);\n  }\n  if (isValue) {\n    for (const alias of binding.aliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler20.types.expressionStatement(\n          import_compiler20.types.callExpression(aliasSignal.identifier, [\n            scopeIdentifier,\n            import_compiler20.types.identifier(binding.name),\n            ...getTranslatedExtraArgs(aliasSignal)\n          ])\n        )\n      );\n    }\n    for (const [key, alias] of binding.propertyAliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler20.types.expressionStatement(\n          import_compiler20.types.callExpression(aliasSignal.identifier, [\n            scopeIdentifier,\n            toMemberExpression(\n              import_compiler20.types.identifier(binding.name),\n              key,\n              binding.nullable\n            ),\n            ...getTranslatedExtraArgs(aliasSignal)\n          ])\n        )\n      );\n    }\n  }\n  for (const value of signal.values) {\n    signal.render.push(\n      import_compiler20.types.expressionStatement(\n        import_compiler20.types.callExpression(value.signal.identifier, [\n          value.scope,\n          value.value,\n          ...getTranslatedExtraArgs(value.signal)\n        ])\n      )\n    );\n  }\n  forEach(signal.intersection, (intersection) => {\n    signal.render.push(\n      import_compiler20.types.expressionStatement(import_compiler20.types.callExpression(intersection, [scopeIdentifier]))\n    );\n  });\n  if (isValue) {\n    let dynamicClosureArgs;\n    let dynamicClosureSignalIdentifier;\n    forEach(binding.closureSections, (closureSection) => {\n      if (binding.sources) {\n        if (isDynamicClosure(closureSection, binding)) {\n          if (!dynamicClosureArgs) {\n            dynamicClosureArgs = [];\n            dynamicClosureSignalIdentifier = generateUidIdentifier(\n              signal.identifier.name + \"_closure\"\n            );\n            signal.render.push(\n              import_compiler20.types.expressionStatement(\n                import_compiler20.types.callExpression(dynamicClosureSignalIdentifier, [\n                  scopeIdentifier\n                ])\n              )\n            );\n          }\n          dynamicClosureArgs.push(\n            getSignal(closureSection, binding).identifier\n          );\n        } else {\n          signal.render.push(\n            import_compiler20.types.expressionStatement(\n              import_compiler20.types.callExpression(getSignal(closureSection, binding).identifier, [\n                scopeIdentifier\n              ])\n            )\n          );\n        }\n      }\n    });\n    if (dynamicClosureSignalIdentifier) {\n      (signal.prependStatements ||= []).push(\n        import_compiler20.types.variableDeclaration(\"const\", [\n          import_compiler20.types.variableDeclarator(\n            dynamicClosureSignalIdentifier,\n            callRuntime(\"dynamicClosure\", ...dynamicClosureArgs)\n          )\n        ])\n      );\n    }\n  }\n  if (signal.effect.length) {\n    const effectIdentifier = import_compiler20.types.identifier(`${signal.identifier.name}_effect`);\n    signal.render.push(\n      import_compiler20.types.expressionStatement(\n        import_compiler20.types.callExpression(effectIdentifier, [scopeIdentifier])\n      )\n    );\n  }\n  if (isIntersection && signal.renderReferencedBindings) {\n    signal.render.unshift(\n      import_compiler20.types.variableDeclaration(\"const\", [\n        import_compiler20.types.variableDeclarator(\n          createScopeReadPattern(section, signal.renderReferencedBindings),\n          scopeIdentifier\n        )\n      ])\n    );\n  }\n  if (canUseCalleeDirectly && signal.render.length === 1) {\n    const render = signal.render[0];\n    if (render.type === \"ExpressionStatement\") {\n      const { expression } = render;\n      if (expression.type === \"CallExpression\") {\n        const args = expression.arguments;\n        if (params.length >= args.length) {\n          for (let i = args.length; i--; ) {\n            const param = params[i];\n            const arg = args[i];\n            if (arg.type !== \"Identifier\" || param.name !== arg.name) {\n              canUseCalleeDirectly = false;\n              break;\n            }\n          }\n          if (canUseCalleeDirectly) {\n            return expression.callee;\n          }\n        }\n      }\n    }\n  }\n  return import_compiler20.types.arrowFunctionExpression(params, import_compiler20.types.blockStatement(signal.render));\n}\nvar hasTranslatedExtraArgs = /* @__PURE__ */ new WeakSet();\nvar emptyExtraArgs = [];\nfunction getTranslatedExtraArgs(signal) {\n  if (signal.extraArgs) {\n    if (!hasTranslatedExtraArgs.has(signal)) {\n      hasTranslatedExtraArgs.add(signal);\n      traverseReplace(signal, \"extraArgs\", replaceRenderNode);\n    }\n    return signal.extraArgs;\n  }\n  return emptyExtraArgs;\n}\nfunction subscribe(provider, subscriber) {\n  if (Array.isArray(provider)) {\n    provider.forEach((p) => subscribe(p, subscriber));\n    return;\n  }\n  const providerSignal = getSignal(subscriber.section, provider);\n  providerSignal.intersection = push(\n    providerSignal.intersection,\n    subscriber.identifier\n  );\n}\nfunction generateSignalName(referencedBindings) {\n  let name2;\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      name2 = \"expr\";\n      for (const ref of referencedBindings) {\n        name2 += `_${ref.name}`;\n      }\n    } else {\n      name2 = referencedBindings.name;\n    }\n  } else {\n    name2 = \"setup\";\n  }\n  return name2;\n}\nfunction replaceNullishAndEmptyFunctionsWith0(args) {\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (!arg) {\n      args[i] = import_compiler20.types.numericLiteral(0);\n    } else if (import_compiler20.types.isArrowFunctionExpression(arg) && import_compiler20.types.isBlockStatement(arg.body)) {\n      const body = arg.body.body;\n      if (body.length === 0) {\n        args[i] = import_compiler20.types.numericLiteral(0);\n      } else if (body.length === 1 && import_compiler20.types.isExpressionStatement(body[0])) {\n        arg.body = toParenthesizedExpressionIfNeeded(body[0].expression);\n      }\n    } else if (import_compiler20.types.isNullLiteral(arg) || import_compiler20.types.isUnaryExpression(arg) && arg.operator === \"void\") {\n      args[i] = import_compiler20.types.numericLiteral(0);\n    }\n  }\n  for (let i = args.length - 1; import_compiler20.types.isNumericLiteral(args[i]) && args[i].value === 0; ) {\n    args.length = i--;\n  }\n  return args;\n}\nfunction addStatement(type, targetSection, referencedBindings, statement, usedReferences) {\n  const signal = getSignal(targetSection, referencedBindings);\n  const statements = signal[type] ??= [];\n  const add = type === \"effect\" ? addEffectReferences : addRenderReferences;\n  if (Array.isArray(statement)) {\n    statements.push(...statement);\n  } else {\n    statements.push(statement);\n  }\n  if (usedReferences !== false) {\n    if (usedReferences) {\n      for (const ref of usedReferences) {\n        add(signal, ref);\n      }\n    } else {\n      add(signal, referencedBindings);\n    }\n  }\n}\nfunction addEffectReferences(signal, referencedBindings) {\n  signal.effectReferencedBindings = bindingUtil.union(\n    signal.effectReferencedBindings,\n    referencedBindings\n  );\n}\nfunction addRenderReferences(signal, referencedBindings) {\n  signal.renderReferencedBindings = bindingUtil.union(\n    signal.renderReferencedBindings,\n    referencedBindings\n  );\n}\nfunction addValue(targetSection, referencedBindings, signal, value, scope = scopeIdentifier) {\n  const parentSignal = getSignal(targetSection, referencedBindings);\n  addRenderReferences(parentSignal, referencedBindings);\n  parentSignal.values.push({\n    signal,\n    value,\n    scope\n  });\n}\nfunction getResumeRegisterId(section, referencedBindings, type) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = (0, import_babel_utils14.getFile)();\n  let name2 = \"\";\n  if (referencedBindings) {\n    if (typeof referencedBindings === \"string\") {\n      name2 += `_${referencedBindings}`;\n    } else if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        name2 += `_${ref.name}`;\n      }\n    } else {\n      name2 += `_${referencedBindings.name}`;\n    }\n  }\n  return (0, import_babel_utils14.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}${name2}${type ? \"/\" + type : \"\"}`\n  );\n}\nvar usedRegisterIdsBySection = /* @__PURE__ */ new WeakMap();\nfunction getRegisterUID(section, name2) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = (0, import_babel_utils14.getFile)();\n  let used = usedRegisterIdsBySection.get(section);\n  if (!used) usedRegisterIdsBySection.set(section, used = /* @__PURE__ */ new Set());\n  const baseId = (0, import_babel_utils14.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}/${name2}`\n  );\n  let count = 0;\n  let id = baseId;\n  while (used.has(id)) {\n    id = baseId + \"_\" + ++count;\n  }\n  used.add(id);\n  return id;\n}\nfunction writeSignals(section) {\n  forEach(section.hoisted, (binding) => {\n    for (const hoistedBinding of binding.hoists.values()) {\n      const accessors = [\n        binding.type === 0 /* dom */ ? import_compiler20.types.stringLiteral(\n          getAccessorPrefix().Getter + getScopeAccessor(binding)\n        ) : getScopeAccessorLiteral(binding)\n      ];\n      let currentSection = section;\n      while (currentSection && currentSection !== hoistedBinding.section) {\n        const parentSection = currentSection.parent;\n        if (parentSection) {\n          accessors.push(getSectionInstancesAccessorLiteral(currentSection));\n        }\n        currentSection = parentSection;\n      }\n      const hoistIdentifier = getHoistFunctionIdentifier(hoistedBinding);\n      (0, import_babel_utils14.getProgram)().node.body.push(\n        import_compiler20.types.variableDeclaration(\"const\", [\n          import_compiler20.types.variableDeclarator(\n            hoistIdentifier,\n            hoistedBinding.downstreamExpressions.size ? callRuntime(\n              \"register\",\n              import_compiler20.types.stringLiteral(\n                getResumeRegisterId(\n                  hoistedBinding.section,\n                  hoistedBinding,\n                  \"hoist\"\n                )\n              ),\n              callRuntime(\"hoist\", ...accessors)\n            ) : callRuntime(\"hoist\", ...accessors)\n          )\n        ])\n      );\n      if (hoistedBinding.downstreamExpressions.size) {\n        addValue(\n          hoistedBinding.section,\n          void 0,\n          initValue(hoistedBinding),\n          import_compiler20.types.callExpression(hoistIdentifier, [scopeIdentifier])\n        );\n      }\n    }\n  });\n  const signals = [...getSignals(section).values()].sort(sortSignals);\n  for (const signal of signals) {\n    traverseReplace(signal, \"render\", replaceRenderNode);\n    for (const value2 of signal.values) {\n      traverseReplace(value2, \"value\", replaceRenderNode);\n    }\n    let effectDeclarator;\n    if (signal.effect.length) {\n      traverseReplace(signal, \"effect\", replaceEffectNode);\n      const effectIdentifier = import_compiler20.types.identifier(`${signal.identifier.name}_effect`);\n      const referencedBindings = signal.effectReferencedBindings;\n      const referencesScope = traverseContains(\n        signal.effect,\n        isScopeIdentifier\n      );\n      effectDeclarator = import_compiler20.types.variableDeclarator(\n        effectIdentifier,\n        callRuntime(\n          \"effect\",\n          import_compiler20.types.stringLiteral(\n            getResumeRegisterId(section, signal.referencedBindings)\n          ),\n          import_compiler20.types.arrowFunctionExpression(\n            referencedBindings ? referencesScope ? [\n              scopeIdentifier,\n              createScopeReadPattern(section, referencedBindings)\n            ] : [createScopeReadPattern(section, referencedBindings)] : referencesScope ? [scopeIdentifier] : [],\n            toFirstExpressionOrBlock(signal.effect)\n          )\n        )\n      );\n    }\n    let value = signal.build();\n    if (import_compiler20.types.isCallExpression(value)) {\n      replaceNullishAndEmptyFunctionsWith0(value.arguments);\n    }\n    if (signal.register) {\n      value = callRuntime(\n        \"registerBoundSignal\",\n        import_compiler20.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings, \"var\")\n        ),\n        value\n      );\n    }\n    const signalDeclarator = import_compiler20.types.variableDeclarator(signal.identifier, value);\n    let signalDeclaration = !section.parent && !signal.referencedBindings && (import_compiler20.types.isFunctionExpression(value) || import_compiler20.types.isArrowFunctionExpression(value)) ? import_compiler20.types.functionDeclaration(\n      signal.identifier,\n      value.params,\n      import_compiler20.types.isExpression(value.body) ? import_compiler20.types.blockStatement([import_compiler20.types.expressionStatement(value.body)]) : value.body\n    ) : import_compiler20.types.variableDeclaration(\"const\", [signalDeclarator]);\n    if (signal.export) {\n      signalDeclaration = import_compiler20.types.exportNamedDeclaration(signalDeclaration);\n    }\n    const signalStatements = signal.prependStatements || [];\n    if (effectDeclarator) {\n      signalStatements.push(import_compiler20.types.variableDeclaration(\"const\", [effectDeclarator]));\n    }\n    signalStatements.push(signalDeclaration);\n    (0, import_babel_utils14.getProgram)().node.body.push(...signalStatements);\n  }\n}\nfunction writeRegisteredFns() {\n  const registeredFns = registeredFnsForProgram.get((0, import_babel_utils14.getProgram)().node);\n  const statements = [];\n  if (registeredFns) {\n    for (const registeredFn of registeredFns) {\n      let fn;\n      const params = registeredFn.referencedBindings ? registeredFn.referencesScope ? [\n        scopeIdentifier,\n        import_compiler20.types.assignmentPattern(\n          createScopeReadPattern(\n            registeredFn.section,\n            registeredFn.referencedBindings\n          ),\n          scopeIdentifier\n        )\n      ] : [\n        createScopeReadPattern(\n          registeredFn.section,\n          registeredFn.referencedBindings\n        )\n      ] : registeredFn.referencesScope ? [scopeIdentifier] : void 0;\n      if (params) {\n        fn = import_compiler20.types.functionDeclaration(\n          import_compiler20.types.identifier(registeredFn.id),\n          params,\n          import_compiler20.types.blockStatement(toReturnedFunction(registeredFn.node))\n        );\n      } else if (registeredFn.node.type === \"FunctionDeclaration\" && registeredFn.node.id?.name === registeredFn.id) {\n        fn = registeredFn.node;\n      } else {\n        fn = import_compiler20.types.functionDeclaration(\n          import_compiler20.types.identifier(registeredFn.id),\n          registeredFn.node.params,\n          registeredFn.node.body.type === \"BlockStatement\" ? registeredFn.node.body : import_compiler20.types.blockStatement([import_compiler20.types.returnStatement(registeredFn.node.body)]),\n          registeredFn.node.generator,\n          registeredFn.node.async\n        );\n      }\n      statements.push(fn);\n    }\n    for (const registeredFn of registeredFns) {\n      statements.push(\n        import_compiler20.types.expressionStatement(\n          callRuntime(\n            \"register\",\n            import_compiler20.types.stringLiteral(registeredFn.registerId),\n            import_compiler20.types.identifier(registeredFn.id)\n          )\n        )\n      );\n    }\n    (0, import_babel_utils14.getProgram)().node.body.push(...statements);\n  }\n}\nfunction toReturnedFunction(rawFn) {\n  const fn = simplifyFunction(rawFn);\n  return fn.type === \"FunctionDeclaration\" ? [fn, import_compiler20.types.returnStatement(fn.id)] : [import_compiler20.types.returnStatement(fn)];\n}\nfunction sortSignals(a, b) {\n  const aReferencedBindings = getReferencedBindings(a);\n  const bReferencedBindings = getReferencedBindings(b);\n  for (let i = Math.max(aReferencedBindings.length, bReferencedBindings.length) - 1; i >= 0; i--) {\n    const diff = (bReferencedBindings[i] ?? -1) - (aReferencedBindings[i] ?? -1);\n    if (diff !== 0) return diff;\n  }\n  return 0;\n}\nfunction getReferencedBindings({ referencedBindings: reserve }) {\n  if (!reserve) {\n    return [];\n  } else if (Array.isArray(reserve)) {\n    return reserve.map(getMappedId).sort();\n  } else {\n    return [getMappedId(reserve)];\n  }\n}\nfunction getMappedId(reference) {\n  return (reference.type === 0 /* dom */ ? 1 : 0) * 1e4 + reference.id;\n}\nfunction addHTMLEffectCall(section, referencedBindings) {\n  addStatement(\"effect\", section, referencedBindings, void 0, false);\n}\nfunction writeHTMLResumeStatements(path5) {\n  const section = getSectionForBody(path5);\n  if (!section) return;\n  const body = path5.node.body;\n  const allSignals = Array.from(getSignals(section).values());\n  const scopeIdIdentifier = getScopeIdIdentifier(section);\n  forEach(section.referencedClosures, (closure) => {\n    if (closure.sources) {\n      if (isDynamicClosure(section, closure)) {\n        const closureSignal = getSignal(closure.section, closure);\n        let identifier = htmlDynamicClosureInstancesIdentifier.get(closureSignal);\n        if (!identifier) {\n          htmlDynamicClosureInstancesIdentifier.set(\n            closureSignal,\n            identifier = generateUidIdentifier(\n              closureSignal.identifier.name + \"_closures\"\n            )\n          );\n          getHTMLSectionStatements(closure.section).push(\n            import_compiler20.types.variableDeclaration(\"const\", [\n              import_compiler20.types.variableDeclarator(\n                identifier,\n                import_compiler20.types.newExpression(import_compiler20.types.identifier(\"Set\"), [])\n              )\n            ])\n          );\n          setBindingSerializedValue(\n            closure.section,\n            closure,\n            identifier,\n            getAccessorPrefix().ClosureScopes\n          );\n        }\n        setBindingSerializedValue(\n          section,\n          closure,\n          import_compiler20.types.numericLiteral(getDynamicClosureIndex(closure, section)),\n          getAccessorPrefix().ClosureSignalIndex\n        );\n        addWriteScopeBuilder(\n          section,\n          (expr) => callRuntime(\"writeSubscribe\", identifier, expr)\n        );\n      }\n    }\n  });\n  const sectionDynamicSubscribers = /* @__PURE__ */ new Set();\n  forEach(section.hoisted, (binding) => {\n    for (const hoistedBinding of binding.hoists.values()) {\n      if (hoistedBinding.downstreamExpressions.size) {\n        getHTMLSectionStatements(hoistedBinding.section).push(\n          import_compiler20.types.variableDeclaration(\"const\", [\n            import_compiler20.types.variableDeclarator(\n              import_compiler20.types.identifier(hoistedBinding.name),\n              callRuntime(\n                \"hoist\",\n                getScopeIdIdentifier(hoistedBinding.section),\n                import_compiler20.types.stringLiteral(\n                  getResumeRegisterId(\n                    hoistedBinding.section,\n                    hoistedBinding,\n                    \"hoist\"\n                  )\n                )\n              )\n            )\n          ])\n        );\n      }\n      let currentSection = section;\n      while (currentSection && currentSection !== hoistedBinding.section) {\n        const parentSection = currentSection.parent;\n        if (!currentSection.sectionAccessor && !sectionDynamicSubscribers.has(currentSection)) {\n          const subscribersIdentifier = generateUidIdentifier(\n            `${currentSection.name}_subscribers`\n          );\n          sectionDynamicSubscribers.add(currentSection);\n          getHTMLSectionStatements(parentSection).push(\n            import_compiler20.types.variableDeclaration(\"const\", [\n              import_compiler20.types.variableDeclarator(\n                subscribersIdentifier,\n                import_compiler20.types.newExpression(import_compiler20.types.identifier(\"Set\"), [])\n              )\n            ])\n          );\n          addWriteScopeBuilder(\n            currentSection,\n            (expr) => callRuntime(\"writeSubscribe\", subscribersIdentifier, expr)\n          );\n          setSerializedValue(\n            parentSection,\n            getSectionInstancesAccessor(currentSection),\n            subscribersIdentifier\n          );\n        }\n        currentSection = parentSection;\n      }\n    }\n    if (binding.hoists.size && binding.type !== 0 /* dom */) {\n      setBindingSerializedValue(\n        section,\n        binding,\n        getDeclaredBindingExpression(binding)\n      );\n    }\n  });\n  for (let i = allSignals.length; i--; ) {\n    if (allSignals[i].effect.length) {\n      const signalRefs = allSignals[i].referencedBindings;\n      body.push(\n        import_compiler20.types.expressionStatement(\n          callRuntime(\n            \"writeEffect\",\n            scopeIdIdentifier,\n            import_compiler20.types.stringLiteral(getResumeRegisterId(section, signalRefs))\n          )\n        )\n      );\n    }\n  }\n  const serializedLookup = getSerializedAccessors(section);\n  const serializedProperties = [];\n  const sectionSerializeReason = nonAnalyzedForceSerializedSection.has(section) ? true : section.serializeReason;\n  forEach(section.bindings, (binding) => {\n    if (binding.type === 0 /* dom */) return;\n    const reason = getBindingSerializeReason(section, binding);\n    if (!reason) return;\n    const accessor = getScopeAccessor(binding);\n    serializedLookup.delete(accessor);\n    serializedProperties.push(\n      toObjectProperty(\n        accessor,\n        sectionSerializeReason && (sectionSerializeReason === reason || sectionSerializeReason !== true && reason !== true && compareSerializeReasons(sectionSerializeReason, reason) === 0) ? getDeclaredBindingExpression(binding) : getExprIfSerialized(reason, getDeclaredBindingExpression(binding))\n      )\n    );\n  });\n  if (section.parent) {\n    const ownerAccessor = getAccessorProp().Owner;\n    const ownerReason = getSectionSerializeReason(section, ownerAccessor);\n    if (ownerReason) {\n      const getOwnerExpr = callRuntime(\n        \"ensureScopeWithId\",\n        getScopeIdIdentifier(section.parent)\n      );\n      serializedLookup.delete(ownerAccessor);\n      serializedProperties.push(\n        toObjectProperty(\n          ownerAccessor,\n          sectionSerializeReason && (sectionSerializeReason === ownerReason || sectionSerializeReason !== true && ownerReason !== true && compareSerializeReasons(sectionSerializeReason, ownerReason) === 0) ? getOwnerExpr : getExprIfSerialized(ownerReason, getOwnerExpr)\n        )\n      );\n    }\n  }\n  for (const [key, { expression, reason }] of serializedLookup) {\n    serializedProperties.push(\n      toObjectProperty(key, getExprIfSerialized(reason, expression))\n    );\n  }\n  const writeScopeBuilder = getSectionWriteScopeBuilder(section);\n  if (sectionSerializeReason) {\n    for (const prop of serializedProperties) {\n      if (prop.key.type === \"Identifier\" && prop.value.type === \"Identifier\" && prop.key.name === prop.value.name) {\n        prop.shorthand = true;\n      }\n    }\n    const writeScopeArgs = [\n      scopeIdIdentifier,\n      import_compiler20.types.objectExpression(serializedProperties)\n    ];\n    if (!isOptimize()) {\n      let debugVars;\n      forEach(section.bindings, (binding) => {\n        if (binding.type === 0 /* dom */) return;\n        const serializeReason = getBindingSerializeReason(section, binding);\n        if (!serializeReason) return;\n        let root = binding;\n        let access = \"\";\n        while (!(root.loc || root.declared) && root.upstreamAlias) {\n          if (root.property !== void 0) {\n            access = toAccess(root.property) + access;\n          }\n          root = root.upstreamAlias;\n        }\n        const locExpr = root.loc && import_compiler20.types.stringLiteral(\n          `${root.loc.start.line}:${root.loc.start.column + 1}`\n        );\n        (debugVars ||= []).push(\n          toObjectProperty(\n            getScopeAccessor(binding),\n            root !== binding ? import_compiler20.types.arrayExpression(\n              locExpr ? [import_compiler20.types.stringLiteral(root.name + access), locExpr] : [import_compiler20.types.stringLiteral(root.name + access)]\n            ) : locExpr || import_compiler20.types.numericLiteral(0)\n          )\n        );\n      });\n      writeScopeArgs.push(\n        import_compiler20.types.stringLiteral(path5.hub.file.opts.filenameRelative),\n        section.loc && section.loc.start.line != null ? import_compiler20.types.stringLiteral(\n          `${section.loc.start.line}:${section.loc.start.column + 1}`\n        ) : import_compiler20.types.numericLiteral(0)\n      );\n      if (debugVars) {\n        writeScopeArgs.push(import_compiler20.types.objectExpression(debugVars));\n      }\n    }\n    let writeScopeCall = writeScopeBuilder ? writeScopeBuilder(callRuntime(\"writeScope\", ...writeScopeArgs)) : callRuntime(\"writeScope\", ...writeScopeArgs);\n    if (sectionSerializeReason !== true) {\n      writeScopeCall = import_compiler20.types.logicalExpression(\n        \"&&\",\n        getSerializeGuard(sectionSerializeReason),\n        writeScopeCall\n      );\n    }\n    body.push(import_compiler20.types.expressionStatement(writeScopeCall));\n  }\n  const resumeClosestBranch2 = !section.isBranch && (section.hasAbortSignal || !!section.referencedClosures || !!find(section.bindings, (binding) => binding.type === 1 /* let */));\n  if (resumeClosestBranch2) {\n    body.push(\n      import_compiler20.types.expressionStatement(\n        callRuntime(\"resumeClosestBranch\", scopeIdIdentifier)\n      )\n    );\n  }\n  const additionalStatements = getHTMLSectionStatements(section);\n  if (body.length || additionalStatements.length) {\n    body.unshift(\n      import_compiler20.types.variableDeclaration(\"const\", [\n        import_compiler20.types.variableDeclarator(scopeIdIdentifier, callRuntime(\"nextScopeId\"))\n      ]),\n      ...additionalStatements\n    );\n  }\n  const returnIdentifier = getSectionReturnValueIdentifier(section);\n  if (returnIdentifier !== void 0) {\n    body.push(import_compiler20.types.returnStatement(returnIdentifier));\n  }\n}\nfunction getSetup(section) {\n  return getSignals(section).get(void 0)?.identifier;\n}\nfunction replaceRenderNode(node) {\n  return replaceAssignedNode(node) || replaceBindingReadNode2(node) || replaceRegisteredFunctionNode2(node);\n}\nfunction replaceEffectNode(node) {\n  return replaceAssignedNode(node) || replaceBindingReadNode2(node);\n}\nfunction replaceBindingReadNode2(node) {\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\": {\n      return getReadReplacement(node);\n    }\n  }\n}\nfunction replaceAssignedNode(node) {\n  switch (node.type) {\n    case \"UpdateExpression\": {\n      const { extra } = node.argument;\n      if (isAssignedBindingExtra(extra)) {\n        const { buildAssignment } = getSignal(\n          extra.assignment.section,\n          extra.assignment\n        );\n        if (buildAssignment) {\n          const replacement = buildAssignment(\n            extra.section,\n            import_compiler20.types.binaryExpression(\n              node.operator === \"++\" ? \"+\" : \"-\",\n              node.argument,\n              import_compiler20.types.numericLiteral(1)\n            )\n          );\n          if (!node.prefix) {\n            return import_compiler20.types.sequenceExpression([replacement, node.argument]);\n          }\n          return replacement;\n        }\n      }\n      break;\n    }\n    case \"AssignmentExpression\":\n      switch (node.left.type) {\n        case \"Identifier\": {\n          const { extra } = node.left;\n          if (isAssignedBindingExtra(extra)) {\n            const { buildAssignment } = getSignal(\n              extra.assignment.section,\n              extra.assignment\n            );\n            if (buildAssignment) {\n              return buildAssignment(\n                extra.section,\n                node.operator === \"=\" ? node.right : import_compiler20.types.binaryExpression(\n                  node.operator.slice(\n                    0,\n                    -1\n                  ),\n                  node.left,\n                  node.right\n                )\n              );\n            }\n          }\n          break;\n        }\n        case \"ArrayPattern\":\n        case \"ObjectPattern\": {\n          let params;\n          let assignments;\n          forEachIdentifier(node.left, (id) => {\n            const { extra } = id;\n            if (isAssignedBindingExtra(extra)) {\n              const signal = getSignal(\n                extra.assignment.section,\n                extra.assignment\n              );\n              if (signal?.buildAssignment) {\n                id.name = generateUid(id.name);\n                (params ||= []).push(import_compiler20.types.identifier(id.name));\n                (assignments ||= []).push(\n                  signal.buildAssignment(extra.section, import_compiler20.types.identifier(id.name))\n                );\n              }\n            }\n          });\n          if (params && assignments) {\n            const resultId = generateUid(\"result\");\n            return import_compiler20.types.callExpression(\n              import_compiler20.types.arrowFunctionExpression(\n                [import_compiler20.types.identifier(resultId), ...params],\n                import_compiler20.types.sequenceExpression([\n                  import_compiler20.types.assignmentExpression(\n                    \"=\",\n                    node.left,\n                    import_compiler20.types.identifier(resultId)\n                  ),\n                  ...assignments,\n                  import_compiler20.types.identifier(resultId)\n                ])\n              ),\n              [node.right]\n            );\n          }\n          break;\n        }\n      }\n      break;\n  }\n}\nvar registeredFnsForProgram = /* @__PURE__ */ new WeakMap();\nfunction replaceRegisteredFunctionNode2(node) {\n  switch (node.type) {\n    case \"ClassMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler20.types.classProperty(node.key, replacement);\n    }\n    case \"ClassPrivateMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler20.types.classPrivateProperty(node.key, replacement);\n    }\n    case \"ObjectMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler20.types.objectProperty(node.key, replacement);\n    }\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\": {\n      return getRegisteredFnExpression2(node);\n    }\n    case \"FunctionDeclaration\": {\n      const replacement = getRegisteredFnExpression2(node);\n      if (replacement) {\n        return import_compiler20.types.variableDeclaration(\"const\", [\n          import_compiler20.types.variableDeclarator(node.id, replacement)\n        ]);\n      }\n      break;\n    }\n  }\n}\nfunction getRegisteredFnExpression2(node) {\n  const { extra } = node;\n  if (isRegisteredFnExtra(extra)) {\n    const id = extra.name;\n    const referencesScope = extra.referencesScope;\n    const referencedBindings = extra.referencedBindingsInFunction;\n    let registedFns = registeredFnsForProgram.get((0, import_babel_utils14.getProgram)().node);\n    if (!registedFns) {\n      registeredFnsForProgram.set((0, import_babel_utils14.getProgram)().node, registedFns = []);\n    }\n    registedFns.push({\n      id,\n      node,\n      registerId: extra.registerId,\n      section: extra.section,\n      referencesScope,\n      referencedBindings\n    });\n    if (referencesScope || referencedBindings) {\n      return import_compiler20.types.callExpression(import_compiler20.types.identifier(id), [scopeIdentifier]);\n    } else {\n      return import_compiler20.types.identifier(id);\n    }\n  }\n}\n\n// src/translator/visitors/program/dom.ts\nvar dom_default = {\n  translate: {\n    exit(program) {\n      visit(program);\n      const section = getSectionForBody(program);\n      const { walks, writes, setup } = getSectionMeta(section);\n      const domExports = program.node.extra.domExports;\n      const templateIdentifier = import_compiler21.types.identifier(domExports.template);\n      const walksIdentifier = import_compiler21.types.identifier(domExports.walks);\n      const setupIdentifier = import_compiler21.types.identifier(domExports.setup);\n      const inputBinding = program.node.params[0].extra?.binding;\n      const programInputSignal = inputBinding && bindingHasDownstreamExpressions(inputBinding) ? initValue(inputBinding) : void 0;\n      const styleFile = getStyleFile(program.hub.file);\n      if (styleFile) {\n        (0, import_babel_utils15.importDefault)(program.hub.file, styleFile);\n      }\n      forEachSectionReverse((childSection) => {\n        if (childSection !== section) {\n          const tagParamsSignal = childSection.params && initValue(childSection.params);\n          const { walks: walks2, writes: writes2, setup: setup2 } = getSectionMeta(childSection);\n          const identifier = import_compiler21.types.identifier(childSection.name);\n          const referencedClosures = childSection.referencedClosures ? import_compiler21.types.arrowFunctionExpression(\n            [scopeIdentifier],\n            toFirstExpressionOrBlock(\n              toArray(childSection.referencedClosures, (closure) => {\n                const closureSignal = getSignal(childSection, closure);\n                return import_compiler21.types.expressionStatement(\n                  import_compiler21.types.callExpression(\n                    isDynamicClosure(childSection, closure) ? closureSignal.identifier : import_compiler21.types.memberExpression(\n                      closureSignal.identifier,\n                      import_compiler21.types.identifier(getAccessorProp().Owner)\n                    ),\n                    [scopeIdentifier]\n                  )\n                );\n              })\n            )\n          ) : void 0;\n          const renderer = getSectionParentIsOwner(childSection) ? callRuntime(\n            \"createRenderer\",\n            ...replaceNullishAndEmptyFunctionsWith0([\n              writes2,\n              walks2,\n              setup2,\n              tagParamsSignal?.identifier,\n              referencedClosures\n            ])\n          ) : callRuntime(\n            isSerializedSection(childSection) ? \"registerContent\" : \"createContent\",\n            import_compiler21.types.stringLiteral(getResumeRegisterId(childSection, \"renderer\")),\n            ...replaceNullishAndEmptyFunctionsWith0([\n              writes2,\n              walks2,\n              setup2,\n              tagParamsSignal?.identifier,\n              referencedClosures,\n              childSection.hoisted || childSection.isHoistThrough ? getSectionInstancesAccessorLiteral(childSection) : void 0\n            ])\n          );\n          writeSignals(childSection);\n          program.node.body.push(\n            import_compiler21.types.variableDeclaration(\"const\", [\n              import_compiler21.types.variableDeclarator(identifier, renderer)\n            ])\n          );\n        }\n      });\n      writeSignals(section);\n      writeRegisteredFns();\n      if (!setup) {\n        program.node.body.unshift(\n          import_compiler21.types.exportNamedDeclaration(\n            import_compiler21.types.variableDeclaration(\"const\", [\n              import_compiler21.types.variableDeclarator(\n                setupIdentifier,\n                import_compiler21.types.arrowFunctionExpression([], import_compiler21.types.blockStatement([]))\n              )\n            ])\n          )\n        );\n      }\n      program.node.body.unshift(\n        import_compiler21.types.exportNamedDeclaration(\n          import_compiler21.types.variableDeclaration(\"const\", [\n            import_compiler21.types.variableDeclarator(\n              templateIdentifier,\n              writes || import_compiler21.types.stringLiteral(\"\")\n            )\n          ])\n        ),\n        import_compiler21.types.exportNamedDeclaration(\n          import_compiler21.types.variableDeclaration(\"const\", [\n            import_compiler21.types.variableDeclarator(walksIdentifier, walks || import_compiler21.types.stringLiteral(\"\"))\n          ])\n        )\n      );\n      program.node.body.push(\n        import_compiler21.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            import_compiler21.types.stringLiteral(program.hub.file.metadata.marko.id),\n            templateIdentifier,\n            walksIdentifier,\n            setupIdentifier,\n            programInputSignal?.identifier\n          )\n        )\n      );\n    }\n  }\n};\n\n// src/translator/visitors/program/index.ts\nvar cleanIdentifier;\nvar scopeIdentifier;\nfunction isScopeIdentifier(node) {\n  return node === scopeIdentifier;\n}\nvar program_default = {\n  migrate: {\n    enter(program) {\n      program.node.params = [import_compiler22.types.identifier(\"input\")];\n    },\n    exit(program) {\n      program.scope.crawl();\n    }\n  },\n  analyze: {\n    enter(program) {\n      startSection(program);\n      trackParamsReferences(program, 2 /* input */);\n      const programExtra = program.node.extra ??= {};\n      const inputBinding = program.node.params[0].extra?.binding;\n      if (inputBinding) {\n        inputBinding.nullable = false;\n      }\n      programExtra.domExports = {\n        template: generateUid(\"template\"),\n        walks: generateUid(\"walks\"),\n        setup: generateUid(\"setup\"),\n        input: void 0\n        // TODO look into recursive components with fine grained params.\n      };\n      for (const child of program.get(\"body\")) {\n        if (isCoreTagName(child, \"return\")) {\n          const { value } = getKnownAttrValues(child.node);\n          if (value) {\n            programExtra.returnValueExpr = value.extra ??= {};\n          }\n          break;\n        }\n      }\n    },\n    exit(program) {\n      finalizeReferences();\n      const programExtra = program.node.extra;\n      const inputBinding = program.node.params[0].extra?.binding;\n      if (inputBinding && bindingHasDownstreamExpressions(inputBinding)) {\n        programExtra.domExports.input = buildTemplateExports(\n          inputBinding,\n          program\n        );\n      }\n    }\n  },\n  translate: {\n    enter(program) {\n      scopeIdentifier = isOutputDOM() ? generateUidIdentifier(\"scope\") : null;\n      cleanIdentifier = isOutputDOM() ? generateUidIdentifier(\"clean\") : null;\n      if (getMarkoOpts().output === \"hydrate\") {\n        const entryFile = program.hub.file;\n        const visitedFiles = /* @__PURE__ */ new Set([\n          (0, import_babel_utils16.resolveRelativePath)(entryFile, entryFile.opts.filename)\n        ]);\n        entry_builder_default.visit(entryFile, entryFile, function visitChild(resolved) {\n          if (!visitedFiles.has(resolved)) {\n            visitedFiles.add(resolved);\n            const file = (0, import_babel_utils16.loadFileForImport)(entryFile, resolved);\n            if (file) {\n              entry_builder_default.visit(\n                file,\n                entryFile,\n                (id) => visitChild(resolveRelativeToEntry(entryFile, file, id))\n              );\n            }\n          }\n        });\n        program.node.body = entry_builder_default.build(entryFile);\n        program.skip();\n        return;\n      }\n    },\n    exit(program) {\n      if (isOutputHTML()) {\n        html_default.translate.exit(program);\n      } else {\n        dom_default.translate.exit(program);\n      }\n      if (program.node.extra?.needsCompat) {\n        const compatFile = getCompatRuntimeFile();\n        const body = [void 0];\n        for (const child of program.node.body) {\n          if (child.type === \"ImportDeclaration\" && child.source.value === compatFile) {\n            body[0] = child;\n          } else {\n            body.push(child);\n          }\n        }\n        body[0] ??= import_compiler22.types.importDeclaration([], import_compiler22.types.stringLiteral(compatFile));\n        program.node.body = body;\n      }\n    }\n  }\n};\nfunction resolveSerializeReasonId(inputSerializeReasons, reason) {\n  const id = findIndexSorted(\n    compareSerializeReasons,\n    inputSerializeReasons,\n    reason\n  );\n  if (id === -1) {\n    throw new Error(\"Unable to resolve serialize reason against input\");\n  }\n  return id;\n}\nfunction resolveRelativeToEntry(entryFile, file, req) {\n  return file === entryFile ? (0, import_babel_utils16.resolveRelativePath)(file, req) : (0, import_babel_utils16.resolveRelativePath)(\n    entryFile,\n    req[0] === \".\" ? import_path2.default.join(file.opts.filename, \"..\", req) : req\n  );\n}\nfunction buildTemplateExports(binding, program) {\n  const templateExport = {\n    id: binding.export ??= generateUid(binding.name),\n    binding,\n    props: void 0\n  };\n  if (!(binding.aliases.size || binding.downstreamExpressions.size)) {\n    templateExport.props = {};\n    for (const [property, alias] of binding.propertyAliases) {\n      templateExport.props[property] = buildTemplateExports(alias, program);\n    }\n  }\n  return templateExport;\n}\n\n// src/translator/util/scope-read.ts\nfunction createScopeReadPattern(section, referencedBindings) {\n  const rootDepth = section.depth;\n  const rootPattern = import_compiler23.types.objectPattern([]);\n  let nestedPatterns;\n  forEach(referencedBindings, (ref) => {\n    const propertyValue = ref.name;\n    if (!isValidPropertyIdentifier(propertyValue)) return;\n    const propertyKey = getScopeAccessor(ref);\n    const isShorthand = propertyKey === propertyValue;\n    let pattern = rootPattern;\n    if (ref.section !== section) {\n      if (!nestedPatterns) nestedPatterns = [rootPattern];\n      const relativeDepth = rootDepth - ref.section.depth;\n      let i = nestedPatterns.length;\n      let prev = nestedPatterns[i - 1];\n      for (; i <= relativeDepth; i++) {\n        const nestedPattern = import_compiler23.types.objectPattern([]);\n        prev.properties.push(\n          import_compiler23.types.objectProperty(\n            import_compiler23.types.identifier(getAccessorProp().Owner),\n            nestedPattern\n          )\n        );\n        nestedPatterns.push(nestedPattern);\n        prev = nestedPattern;\n      }\n      pattern = nestedPatterns[relativeDepth];\n    }\n    pattern.properties.push(\n      import_compiler23.types.objectProperty(\n        toPropertyName(propertyKey),\n        import_compiler23.types.identifier(propertyValue),\n        false,\n        isShorthand\n      )\n    );\n  });\n  return rootPattern;\n}\nfunction getScopeExpression(section, targetSection) {\n  let scope = scopeIdentifier ?? import_compiler23.types.identifier(\"undefined\");\n  const diff = section.depth - targetSection.depth;\n  for (let i = 0; i < diff; i++) {\n    scope = import_compiler23.types.memberExpression(scope, import_compiler23.types.identifier(getAccessorProp().Owner));\n  }\n  if (diff < 0) {\n    throw new Error(\"Unable to find scope for reference.\");\n  }\n  return scope;\n}\nfunction createScopeReadExpression(section, reference) {\n  const propName = toPropertyName(getScopeAccessor(reference));\n  return import_compiler23.types.memberExpression(\n    getScopeExpression(section, reference.section),\n    propName,\n    propName.type !== \"Identifier\"\n  );\n}\n\n// src/translator/util/with-previous-location.ts\nfunction withPreviousLocation(newNode, originalNode) {\n  newNode.start = originalNode.start;\n  newNode.loc = originalNode.loc;\n  newNode.end = originalNode.end;\n  return newNode;\n}\n\n// src/translator/util/references.ts\nvar kIsInvoked = Symbol(\"hoist is invoked\");\nvar kBranchSerializeReason = Symbol(\"branch serialize reason\");\nvar [getBindings] = createProgramState(() => /* @__PURE__ */ new Set());\nvar [getNextBindingId, setNextBindingId] = createProgramState(() => 0);\nfunction createBinding(name2, type, section, upstreamAlias, property, loc = null, declared = false) {\n  const id = getNextBindingId();\n  const binding = {\n    id,\n    name: name2,\n    type,\n    loc,\n    section,\n    property,\n    declared,\n    closureSections: void 0,\n    assignmentSections: void 0,\n    excludeProperties: void 0,\n    serializeSources: void 0,\n    sources: void 0,\n    aliases: /* @__PURE__ */ new Set(),\n    hoists: /* @__PURE__ */ new Map(),\n    propertyAliases: /* @__PURE__ */ new Map(),\n    upstreamAlias,\n    downstreamExpressions: /* @__PURE__ */ new Set(),\n    scopeOffset: void 0,\n    export: void 0,\n    nullable: true\n  };\n  if (property) {\n    if (declared) upstreamAlias.nullable = false;\n    const propBinding = upstreamAlias.propertyAliases.get(property);\n    if (propBinding) {\n      binding.property = void 0;\n      binding.upstreamAlias = propBinding;\n      propBinding.aliases.add(binding);\n    } else {\n      upstreamAlias.propertyAliases.set(property, binding);\n    }\n  } else if (upstreamAlias) {\n    upstreamAlias.aliases.add(binding);\n  }\n  setNextBindingId(id + 1);\n  getBindings().add(binding);\n  return binding;\n}\nfunction trackVarReferences(tag, type, upstreamAlias) {\n  const tagVar = tag.node.var;\n  if (tagVar) {\n    const section = getOrCreateSection(tag);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    createBindingsAndTrackReferences(\n      tagVar,\n      upstreamAlias ? upstreamAlias.type : type,\n      tag.scope,\n      section,\n      canonicalUpstreamAlias,\n      void 0\n    );\n    return tagVar.extra?.binding;\n  }\n}\nfunction trackParamsReferences(body, type, upstreamAlias) {\n  const params = body.node.params;\n  if (body.node.body.length && params.length) {\n    const section = getOrCreateSection(body);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    const paramsBinding = canonicalUpstreamAlias || ((body.node.extra ??= {}).binding = createBinding(\n      generateUid(\"params\"),\n      type,\n      section,\n      canonicalUpstreamAlias,\n      void 0\n    ));\n    section.params = paramsBinding;\n    for (let i = 0; i < params.length; i++) {\n      createBindingsAndTrackReferences(\n        params[i],\n        type,\n        body.scope,\n        section,\n        paramsBinding,\n        i + \"\"\n      );\n    }\n    return paramsBinding;\n  }\n}\nfunction trackHoistedReference(referencePath, binding) {\n  const section = binding.section;\n  const referenceSection = getOrCreateSection(referencePath);\n  const hoistSection = getCommonSection(referenceSection, section);\n  const extra = referencePath.node.extra ??= {};\n  let hoistedBinding = binding.hoists.get(hoistSection);\n  if (!hoistedBinding) {\n    binding.hoists.set(\n      hoistSection,\n      hoistedBinding = createBinding(\n        generateUid(\"hoisted_\" + referencePath.node.name),\n        5 /* hoist */,\n        hoistSection,\n        void 0,\n        void 0,\n        binding.loc,\n        true\n      )\n    );\n    section.hoisted = bindingUtil.add(section.hoisted, binding);\n    let currentSection = section.parent;\n    while (currentSection && currentSection !== hoistSection) {\n      currentSection.isHoistThrough = true;\n      currentSection = currentSection.parent;\n    }\n  }\n  if (isInvokedFunction(referencePath)) {\n    extra.read = createRead(hoistedBinding, void 0);\n    extra.section = referenceSection;\n    extra[kIsInvoked] = true;\n  } else {\n    trackReference(referencePath, hoistedBinding);\n  }\n  referenceSection.referencedHoists = bindingUtil.add(\n    referenceSection.referencedHoists,\n    hoistedBinding\n  );\n}\nfunction trackReferencesForBinding(babelBinding, binding) {\n  const { referencePaths, constantViolations } = babelBinding;\n  for (const referencePath of referencePaths) {\n    const referenceSection = getOrCreateSection(referencePath);\n    if (isSameOrChildSection(binding.section, referenceSection)) {\n      trackReference(referencePath, binding);\n    } else {\n      trackHoistedReference(referencePath, binding);\n    }\n  }\n  for (const ref of constantViolations) {\n    if (ref.isUpdateExpression()) {\n      trackAssignment(ref.get(\"argument\"), binding);\n    } else if (ref.isAssignmentExpression()) {\n      trackAssignment(ref.get(\"left\"), binding);\n      if (ref.node.operator !== \"=\") {\n        const left = ref.get(\"left\");\n        if (left.isIdentifier()) {\n          trackReference(left, binding);\n        }\n      }\n    }\n  }\n}\nfunction trackAssignment(assignment, binding) {\n  const section = getOrCreateSection(assignment);\n  setReferencesScope(assignment);\n  forEachIdentifier(assignment.node, (id) => {\n    if (id.name === binding.name) {\n      const extra = id.extra ??= {};\n      binding.assignmentSections = sectionUtil.add(\n        binding.assignmentSections,\n        section\n      );\n      extra.assignment = binding;\n      extra.section = section;\n    }\n  });\n}\nfunction setReferencesScope(path5) {\n  const fnRoot = getFnRoot(path5);\n  if (fnRoot) {\n    (fnRoot.node.extra ??= {}).referencesScope = true;\n  }\n}\nfunction createBindingsAndTrackReferences(lVal, type, scope, section, upstreamAlias, property) {\n  switch (lVal.type) {\n    case \"Identifier\":\n      trackReferencesForBinding(\n        scope.getBinding(lVal.name),\n        (lVal.extra ??= {}).binding = createBinding(\n          lVal.name,\n          type,\n          section,\n          upstreamAlias,\n          property,\n          lVal.loc,\n          true\n        )\n      );\n      break;\n    case \"ObjectPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        generateUid(property || \"pattern\"),\n        type,\n        section,\n        upstreamAlias,\n        property,\n        lVal.loc\n      ));\n      for (const prop of lVal.properties) {\n        if (prop.type === \"RestElement\") {\n          createBindingsAndTrackReferences(\n            prop.argument,\n            type,\n            scope,\n            section,\n            patternBinding,\n            property\n          );\n        } else {\n          let key;\n          if (prop.key.type === \"Identifier\") {\n            key = prop.key.name;\n          } else if (prop.key.type === \"StringLiteral\") {\n            key = prop.key.value;\n          } else {\n            throw new Error(\"computed keys not supported in object pattern\");\n          }\n          createBindingsAndTrackReferences(\n            prop.value,\n            type,\n            scope,\n            section,\n            patternBinding,\n            key\n          );\n        }\n      }\n      break;\n    }\n    case \"ArrayPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        generateUid(property || \"pattern\"),\n        type,\n        section,\n        upstreamAlias,\n        property,\n        lVal.loc\n      ));\n      let i = -1;\n      for (const element of lVal.elements) {\n        i++;\n        if (element) {\n          if (element.type === \"RestElement\") {\n            createBindingsAndTrackReferences(\n              element.argument,\n              type,\n              scope,\n              section,\n              patternBinding,\n              property\n            );\n          } else {\n            createBindingsAndTrackReferences(\n              element,\n              type,\n              scope,\n              section,\n              patternBinding,\n              `${i}`\n            );\n          }\n        }\n      }\n      break;\n    }\n    case \"AssignmentPattern\":\n      createBindingsAndTrackReferences(\n        lVal.left,\n        type,\n        scope,\n        section,\n        upstreamAlias,\n        property\n      );\n      break;\n  }\n}\nfunction trackReference(referencePath, binding) {\n  let root = referencePath;\n  let reference = binding;\n  let propPath = binding.name;\n  while (true) {\n    const { parent } = root;\n    if (!import_compiler24.types.isMemberExpression(parent)) break;\n    const prop = getMemberExpressionPropString(parent);\n    if (prop === void 0) break;\n    if (reference.propertyAliases.has(prop)) {\n      root = root.parentPath;\n      reference = reference.propertyAliases.get(prop);\n      propPath = reference.name;\n      continue;\n    }\n    if (isInvokedFunction(root.parentPath) && !isEventOrChangeHandler(prop)) {\n      break;\n    }\n    root = root.parentPath;\n    reference = createBinding(\n      propPath += `_${prop.replace(/[^a-zA-Z0-9_$]/g, \"_\")}`,\n      reference.type,\n      reference.section,\n      reference,\n      prop\n    );\n  }\n  const fnRoot = getFnRoot(root);\n  const exprRoot = getExprRoot(fnRoot || root);\n  const { section } = addReadToExpression(exprRoot, reference, root.node);\n  if (fnRoot) {\n    const readsByFn = getReadsByFunction();\n    const fnExtra = fnRoot.node.extra ??= {};\n    fnExtra.section = section;\n    readsByFn.set(\n      fnExtra,\n      push(readsByFn.get(fnExtra), {\n        binding: reference,\n        node: root.node\n      })\n    );\n  }\n}\nvar [getMergedReferences] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction mergeReferences(section, target, nodes) {\n  const targetExtra = target.extra ??= {};\n  targetExtra.section = section;\n  getMergedReferences().set(target, nodes);\n  return targetExtra;\n}\nfunction compareSerializeReasons(a, b) {\n  return Array.isArray(a) ? Array.isArray(b) ? compareIntersections(a, b) : -1 : Array.isArray(b) ? 1 : bindingUtil.compare(a, b);\n}\nfunction compareIntersections(a, b) {\n  const len = a.length;\n  const lenDelta = len - b.length;\n  if (lenDelta !== 0) {\n    return lenDelta;\n  }\n  for (let i = 0; i < len; i++) {\n    const compareResult = bindingUtil.compare(a[i], b[i]);\n    if (compareResult !== 0) {\n      return compareResult;\n    }\n  }\n  return 0;\n}\nfunction finalizeReferences() {\n  const bindings = getBindings();\n  const readsByExpression = getReadsByExpression();\n  const readsByFn = getReadsByFunction();\n  const mergedReferences = getMergedReferences();\n  if (mergedReferences.size) {\n    for (const [target, nodes] of mergedReferences) {\n      const targetExtra = target.extra;\n      let reads = readsByExpression.get(targetExtra);\n      let { isEffect } = targetExtra;\n      for (const node of nodes) {\n        const extra = node?.extra;\n        if (isReferencedExtra(extra)) {\n          isEffect ||= extra.isEffect;\n          const additionalReads = readsByExpression.get(extra);\n          if (additionalReads) {\n            reads = concat(reads, additionalReads);\n            readsByExpression.delete(extra);\n          }\n        }\n      }\n      readsByExpression.set(targetExtra, reads);\n      targetExtra.isEffect = isEffect;\n    }\n  }\n  const intersectionsBySection = /* @__PURE__ */ new Map();\n  for (const [expr, reads] of readsByExpression) {\n    if (isReferencedExtra(expr)) {\n      expr.referencedBindings = resolveReferencedBindings(\n        expr,\n        reads,\n        intersectionsBySection\n      );\n      forEach(expr.referencedBindings, (binding) => {\n        binding.downstreamExpressions.add(expr);\n      });\n    }\n  }\n  for (const [fn, reads] of readsByFn) {\n    fn.referencedBindingsInFunction = resolveReferencedBindings(\n      fn,\n      reads,\n      intersectionsBySection\n    );\n    forEach(\n      fn.referencedBindingsInFunction,\n      (binding) => forceBindingSerialize(binding.section, binding)\n    );\n  }\n  for (const binding of bindings) {\n    if (binding.type !== 0 /* dom */ && !binding.upstreamAlias) {\n      pruneBinding(bindings, binding);\n    }\n  }\n  for (const binding of bindings) {\n    const { name: name2, section } = binding;\n    if (binding.type !== 0 /* dom */) {\n      resolveBindingSources(binding);\n      if (binding.hoists.size) {\n        forceBindingSerialize(binding.section, binding);\n      }\n      forEach(\n        binding.assignmentSections,\n        (assignedSection) => forceOwnersSerialize(assignedSection, section, getAccessorProp().Owner)\n      );\n      if (find(section.bindings, ({ name: name3 }) => name3 === binding.name)) {\n        binding.name = generateUid(name2);\n      }\n    }\n    section.bindings = bindingUtil.add(section.bindings, binding);\n    for (const {\n      referencedBindings,\n      isEffect,\n      section: section2\n    } of binding.downstreamExpressions) {\n      if (section2 !== binding.section) {\n        binding.closureSections = sectionUtil.add(\n          binding.closureSections,\n          section2\n        );\n        section2.referencedClosures = bindingUtil.add(\n          section2.referencedClosures,\n          binding\n        );\n        addOwnersSerializeReason(\n          section2,\n          binding.section,\n          binding.serializeSources,\n          getAccessorProp().Owner\n        );\n      }\n      if (isEffect) {\n        forEach(\n          referencedBindings,\n          (binding2) => forceBindingSerialize(binding2.section, binding2)\n        );\n      }\n    }\n  }\n  forEachSection((section) => {\n    if (section.isHoistThrough) {\n      forceSectionSerialize(section);\n    }\n    forEach(section.referencedHoists, (hoistedBinding) => {\n      forceOwnersSerialize(\n        section,\n        hoistedBinding.section,\n        getAccessorProp().Owner\n      );\n    });\n    if (section.parent && section.isBranch && section.sectionAccessor && section.upstreamExpression) {\n      addSectionSerializeReasonRef(\n        section,\n        !!(section.isHoistThrough || section.hoisted) || getDirectClosures(section),\n        kBranchSerializeReason\n      );\n      addSectionSerializeReasonExpr(\n        section,\n        section.upstreamExpression,\n        kBranchSerializeReason\n      );\n      addBindingSerializeReasonExpr(\n        section.parent,\n        section.sectionAccessor.binding,\n        section.upstreamExpression\n      );\n    }\n  });\n  forEachSection(applySerializeReasonExprs);\n  forEachSection((section) => {\n    const intersections = intersectionsBySection.get(section);\n    if (intersections) {\n      for (const intersection of intersections) {\n        const numReferences = intersection.length;\n        for (let i = 0; i < numReferences - 1; i++) {\n          for (let j = i + 1; j < numReferences; j++) {\n            const binding1 = intersection[i];\n            const binding2 = intersection[j];\n            if (!isBindingForceSerialized(section, binding1) && !bindingUtil.isSuperset(binding1.sources, binding2.sources)) {\n              addBindingSerializeReason(\n                section,\n                binding1,\n                binding2.serializeSources\n              );\n            }\n            if (!isBindingForceSerialized(section, binding2) && !bindingUtil.isSuperset(binding2.sources, binding1.sources)) {\n              addBindingSerializeReason(\n                section,\n                binding2,\n                binding1.serializeSources\n              );\n            }\n          }\n        }\n      }\n    }\n    forEach(section.referencedClosures, (closure) => {\n      if (!isBindingForceSerialized(closure.section, closure)) {\n        const sourceSection = closure.section;\n        let serializeReason;\n        let currentSection = section;\n        while (currentSection !== sourceSection) {\n          const upstreamReason = !currentSection.upstreamExpression || getSerializeSourcesForExpr(currentSection.upstreamExpression);\n          if (upstreamReason === true) {\n            serializeReason = true;\n            break;\n          }\n          serializeReason = mergeSerializeReasons(\n            serializeReason,\n            upstreamReason\n          );\n          currentSection = currentSection.parent;\n        }\n        addBindingSerializeReason(closure.section, closure, serializeReason);\n      }\n      if (closure.sources) {\n        addSectionSerializeReason(\n          closure.section,\n          getBindingSerializeReason(closure.section, closure)\n        );\n      }\n      if (closure.serializeSources && isDynamicClosure(section, closure)) {\n        addBindingSerializeReason(\n          closure.section,\n          closure,\n          closure.serializeSources,\n          getAccessorPrefix().ClosureScopes\n        );\n        addBindingSerializeReason(\n          section,\n          closure,\n          closure.serializeSources,\n          getAccessorPrefix().ClosureSignalIndex\n        );\n      }\n    });\n  });\n  let inputSerializeReasons;\n  forEachSection((section) => {\n    finalizeSectionSerializeReasons(section);\n    if (section.serializeReason && section.serializeReason !== true) {\n      inputSerializeReasons = inputSerializeReasons ? addSorted(\n        compareSerializeReasons,\n        inputSerializeReasons,\n        section.serializeReason\n      ) : [section.serializeReason];\n    }\n    for (const [, reason] of section.serializeReasons) {\n      if (reason !== true) {\n        inputSerializeReasons = inputSerializeReasons ? addSorted(compareSerializeReasons, inputSerializeReasons, reason) : [reason];\n      }\n    }\n  });\n  const programExtra = (0, import_babel_utils17.getProgram)().node.extra;\n  programExtra.returnSerializeReason = programExtra.returnValueExpr && getSerializeSourcesForExpr(programExtra.returnValueExpr);\n  programExtra.inputSerializeReasons = inputSerializeReasons;\n  forEachSection((section) => {\n    let intersectionIndex = 0;\n    const intersections = intersectionsBySection.get(section) || [];\n    const { id, bindings: bindings2 } = section;\n    const isOwnedBinding = ({ section: section2 }) => section2.id === id;\n    let lastBindingIndex = 0;\n    let intersection;\n    forEach(filter(bindings2, isOwnedBinding), (binding, bindingIndex) => {\n      binding.id = (lastBindingIndex = bindingIndex) + intersectionIndex;\n      while (intersectionIndex < intersections.length && (intersection = intersections[intersectionIndex]).filter(isOwnedBinding).at(-1) === binding) {\n        intersectionMeta.set(intersection, {\n          id: bindingIndex + ++intersectionIndex,\n          scopeOffset: getMaxOwnSourceOffset(intersection, section)\n        });\n      }\n    });\n    while (intersectionIndex < intersections.length) {\n      intersection = intersections[intersectionIndex];\n      intersectionMeta.set(intersection, {\n        id: lastBindingIndex + ++intersectionIndex,\n        scopeOffset: getMaxOwnSourceOffset(intersection, section)\n      });\n    }\n  });\n  mergedReferences.clear();\n  readsByExpression.clear();\n  readsByFn.clear();\n}\nfunction getMaxOwnSourceOffset(intersection, section) {\n  let scopeOffset;\n  for (const binding of intersection) {\n    if (binding.section === section) {\n      forEach(binding.sources, (source) => {\n        if (source.scopeOffset && (!scopeOffset || scopeOffset.id < source.scopeOffset.id)) {\n          scopeOffset = source.scopeOffset;\n        }\n      });\n    }\n  }\n  return scopeOffset;\n}\nvar intersectionMeta = /* @__PURE__ */ new WeakMap();\nfunction setBindingValueExpr(binding, valueExpr) {\n  bindingValueExprs.set(binding, valueExpr || false);\n}\nvar resolvedSources = /* @__PURE__ */ new WeakSet();\nvar bindingValueExprs = /* @__PURE__ */ new WeakMap();\nfunction resolveBindingSources(binding) {\n  if (resolvedSources.has(binding)) return;\n  resolvedSources.add(binding);\n  switch (binding.type) {\n    case 1 /* let */:\n      binding.sources = binding;\n      binding.serializeSources = true;\n      return;\n    case 2 /* input */:\n      binding.sources = binding;\n      binding.serializeSources = binding;\n      return;\n  }\n  let alias;\n  let source = binding;\n  while (alias = source.upstreamAlias) {\n    source = alias;\n  }\n  if (source === binding) {\n    resolveDerivedSources(binding);\n    return;\n  }\n  if (!resolvedSources.has(source)) {\n    resolvedSources.add(source);\n    resolveDerivedSources(source);\n  }\n  binding.sources = source.sources;\n  binding.serializeSources = source.serializeSources;\n}\nfunction resolveDerivedSources(binding) {\n  const exprs = bindingValueExprs.get(binding);\n  bindingValueExprs.delete(binding);\n  if (exprs === void 0 || exprs === true) {\n    binding.serializeSources = true;\n    binding.sources = binding;\n  } else if (exprs) {\n    const seen = /* @__PURE__ */ new Set();\n    let onlyInputSources = true;\n    let sources;\n    forEach(exprs, (expr) => {\n      if (isReferencedExtra(expr)) {\n        forEach(expr.referencedBindings, (ref) => {\n          if (!seen.has(ref)) {\n            seen.add(ref);\n            resolveBindingSources(ref);\n            sources = bindingUtil.union(sources, ref.sources);\n            onlyInputSources &&= ref.serializeSources !== true;\n          }\n        });\n      }\n    });\n    if (sources) {\n      binding.sources = sources;\n      binding.serializeSources = onlyInputSources ? sources : true;\n    }\n  }\n}\nvar bindingUtil = new Sorted(function compareBindings(a, b) {\n  return a.section.id - b.section.id || a.type !== b.type && (a.type === 0 /* dom */ || b.type === 0 /* dom */) ? a.type - b.type || a.id - b.id : a.id - b.id;\n});\nvar [getReadsByExpression] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nvar [getReadsByFunction] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction addReadToExpression(path5, binding, node) {\n  const exprExtra = path5.node.extra ??= {};\n  const readsByExpression = getReadsByExpression();\n  exprExtra.section = getOrCreateSection(path5);\n  readsByExpression.set(\n    exprExtra,\n    push(readsByExpression.get(exprExtra), { binding, node })\n  );\n  return exprExtra;\n}\nfunction dropReferences(node) {\n  if (Array.isArray(node)) {\n    for (const item of node) {\n      (item.extra ??= {}).pruned = true;\n    }\n  } else {\n    (node.extra ??= {}).pruned = true;\n  }\n}\nfunction getCanonicalBinding(binding) {\n  return binding && (binding.property ? binding : binding.upstreamAlias || binding);\n}\nfunction getAllTagReferenceNodes(tag, referenceNodes = []) {\n  if (tag.arguments) {\n    for (const arg of tag.arguments) {\n      referenceNodes.push(arg);\n    }\n  }\n  for (const attr2 of tag.attributes) {\n    referenceNodes.push(attr2.value);\n  }\n  for (const child of tag.body.attributeTags ? tag.body.body : tag.attributeTags) {\n    switch (child.type) {\n      case \"MarkoTag\":\n        getAllTagReferenceNodes(child, referenceNodes);\n        break;\n      case \"MarkoScriptlet\":\n        for (const statement of child.body) {\n          referenceNodes.push(statement);\n        }\n        break;\n    }\n  }\n  return referenceNodes;\n}\nfunction getScopeAccessorLiteral(binding, includeId) {\n  if (isOptimize()) {\n    return import_compiler24.types.numericLiteral(binding.id);\n  }\n  return import_compiler24.types.stringLiteral(\n    binding.name + (includeId || binding.type === 0 /* dom */ ? `/${binding.id}` : \"\")\n  );\n}\nfunction getScopeAccessor(binding, includeId) {\n  if (isOptimize()) {\n    return binding.id + \"\";\n  }\n  return binding.name + (includeId || binding.type === 0 /* dom */ ? `/${binding.id}` : \"\");\n}\nfunction getSectionInstancesAccessor(section) {\n  return section.sectionAccessor ? section.sectionAccessor.prefix + getScopeAccessor(section.sectionAccessor.binding) : getAccessorPrefix().ClosureScopes + section.id;\n}\nfunction getSectionInstancesAccessorLiteral(section) {\n  const accessor = getSectionInstancesAccessor(section);\n  return accessor ? typeof accessor === \"number\" ? import_compiler24.types.numericLiteral(accessor) : import_compiler24.types.stringLiteral(accessor) : void 0;\n}\nfunction getReadReplacement(node) {\n  const { extra } = node;\n  if (!extra) return;\n  let { binding, read } = extra;\n  let replacement;\n  if (read) {\n    if (read.props === void 0) {\n      binding = read.binding;\n      read = void 0;\n    } else {\n      binding = void 0;\n    }\n  }\n  if (binding) {\n    if (node.type === \"Identifier\") {\n      if (binding.type === 5 /* hoist */) {\n        replacement = node.extra?.[kIsInvoked] ? import_compiler24.types.callExpression(getHoistFunctionIdentifier(binding), [\n          getScopeExpression(node.extra.section, binding.section)\n        ]) : import_compiler24.types.identifier(getScopeAccessor(binding));\n      } else if (binding.name !== node.name) {\n        node.name = binding.name;\n      }\n    } else {\n      replacement = import_compiler24.types.identifier(binding.name);\n    }\n  } else if (read) {\n    replacement = toMemberExpression(\n      import_compiler24.types.identifier(read.binding.name),\n      Array.isArray(read.props) ? read.props[0] : read.props\n    );\n    if (Array.isArray(read.props)) {\n      for (let i = 1; i < read.props.length; i++) {\n        replacement = toMemberExpression(replacement, read.props[i]);\n      }\n    }\n  }\n  return replacement && withPreviousLocation(replacement, node);\n}\nfunction pruneBinding(bindings, binding) {\n  let shouldPrune = !binding.downstreamExpressions.size;\n  if (binding.hoists.size) {\n    shouldPrune = false;\n  }\n  for (const alias of binding.aliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.aliases.delete(alias);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  for (const [key, alias] of binding.propertyAliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.propertyAliases.delete(key);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  if (shouldPrune) {\n    bindings.delete(binding);\n  }\n  return shouldPrune;\n}\nfunction resolveReferencedBindings(expr, reads, intersectionsBySection) {\n  let referencedBindings;\n  if (Array.isArray(reads)) {\n    for (const read of reads) {\n      let { binding } = read;\n      if (read.node) {\n        const exprReference = (read.node.extra ??= {}).read ??= resolveExpressionReference(reads, binding, void 0);\n        ({ binding } = (read.node.extra ??= {}).read = exprReference);\n      }\n      referencedBindings = bindingUtil.add(referencedBindings, binding);\n    }\n  } else if (reads) {\n    if (reads.node) {\n      (reads.node.extra ??= {}).read = createRead(reads.binding, void 0);\n    }\n    referencedBindings = reads.binding;\n  }\n  if (Array.isArray(referencedBindings)) {\n    const intersections = intersectionsBySection.get(expr.section) || [];\n    const intersection = findSorted(\n      compareIntersections,\n      intersections,\n      referencedBindings\n    );\n    if (intersection) {\n      referencedBindings = intersection;\n    } else {\n      intersectionsBySection.set(\n        expr.section,\n        addSorted(compareIntersections, intersections, referencedBindings)\n      );\n    }\n  }\n  return referencedBindings;\n}\nfunction resolveExpressionReference(reads, readBinding, readProps) {\n  const { upstreamAlias } = readBinding;\n  if (upstreamAlias && Array.isArray(reads)) {\n    const prop = getCanonicalProperty(readBinding);\n    const aliasProps = prop === void 0 ? readProps : push(readProps, prop);\n    for (const { binding } of reads) {\n      if (binding !== readBinding) {\n        let alias = upstreamAlias;\n        while (alias) {\n          if (binding === alias) {\n            return resolveExpressionReference(reads, alias, aliasProps);\n          }\n          alias = alias.upstreamAlias;\n        }\n      }\n    }\n  }\n  return createRead(readBinding, readProps);\n}\nfunction getCanonicalProperty(binding) {\n  return binding.property ?? binding.upstreamAlias?.property;\n}\nfunction createRead(binding, props) {\n  return { binding, props };\n}\nfunction getMemberExpressionPropString(expr) {\n  switch (expr.property.type) {\n    case \"StringLiteral\":\n      return expr.property.value;\n    case \"NumericLiteral\":\n      return \"\" + expr.property.value;\n    case \"Identifier\":\n      if (expr.computed) return;\n      return expr.property.name;\n  }\n}\nfunction isEventOrChangeHandler(prop) {\n  return /^on[-A-Z][a-zA-Z0-9_$]|[a-zA-Z_$][a-zA-Z0-9_$]*Change$/.test(prop);\n}\nfunction isReferencedExtra(extra) {\n  return !!(extra && !extra.pruned && extra.section);\n}\nfunction isAssignedBindingExtra(extra) {\n  return isReferencedExtra(extra) && extra.assignment !== void 0;\n}\nfunction isRegisteredFnExtra(extra) {\n  return isReferencedExtra(extra) && extra.registerId !== void 0;\n}\n\n// src/translator/core/await.ts\nvar kDOMBinding = Symbol(\"await tag dom binding\");\nvar await_default = {\n  analyze(tag) {\n    (0, import_babel_utils18.assertNoVar)(tag);\n    (0, import_babel_utils18.assertNoArgs)(tag);\n    assertNoSpreadAttrs(tag);\n    (0, import_babel_utils18.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    const tagBody = tag.get(\"body\");\n    const section = getOrCreateSection(tag);\n    const [valueAttr] = node.attributes;\n    const tagExtra = tag.node.extra ??= {};\n    tagExtra[kDOMBinding] = createBinding(\"#text\", 0 /* dom */, section);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `await` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler25.types.isMarkoAttribute(valueAttr) || valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `await` tag only supports the `value` attribute.\"\n      );\n    }\n    if (!node.body.body.length) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `await` tag requires body content.\");\n    }\n    if (node.body.params.length && (node.body.params.length > 1 || import_compiler25.types.isSpreadElement(node.body.params[0]))) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `await` tag only supports a single parameter.\"\n      );\n    }\n    const bodySection = startSection(tagBody);\n    const valueExtra = evaluate(valueAttr.value);\n    getOrCreateSection(tag);\n    const paramsBinding = trackParamsReferences(tagBody, 3 /* param */);\n    if (paramsBinding) {\n      setBindingValueExpr(paramsBinding, valueExtra);\n    }\n    bodySection.upstreamExpression = valueAttr.value.extra;\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        flushBefore(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const [valueAttr] = node.attributes;\n        const tagExtra = node.extra;\n        const nodeRef2 = tagExtra[kDOMBinding];\n        const tagBody = tag.get(\"body\");\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const serializeReason = bodySection && getSectionSerializeReason(bodySection);\n        flushInto(tag);\n        writeHTMLResumeStatements(tagBody);\n        tag.replaceWith(\n          import_compiler25.types.expressionStatement(\n            callRuntime(\n              \"fork\",\n              getScopeIdIdentifier(section),\n              getScopeAccessorLiteral(nodeRef2),\n              valueAttr.value,\n              import_compiler25.types.arrowFunctionExpression(\n                node.body.params,\n                toFirstExpressionOrBlock(node.body.body)\n              ),\n              !serializeReason ? import_compiler25.types.numericLiteral(0) : serializeReason === true ? void 0 : getSerializeGuard(serializeReason)\n            )\n          )\n        )[0].skip();\n      }\n    },\n    dom: {\n      enter(tag) {\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        visit(tag, 37 /* Replace */);\n        enterShallow(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const nodeRef2 = tagExtra[kDOMBinding];\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tag.get(\"body\"));\n        const signal = getSignal(section, nodeRef2, \"await\");\n        signal.build = () => {\n          return callRuntime(\n            \"awaitTag\",\n            getScopeAccessorLiteral(nodeRef2),\n            import_compiler25.types.identifier(bodySection.name)\n          );\n        };\n        addValue(\n          section,\n          bodySection.upstreamExpression?.referencedBindings,\n          signal,\n          tag.node.attributes[0].value\n        );\n        tag.remove();\n      }\n    }\n  }),\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to consume asynchronous an data.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#await\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/await.d.marko\"\n};\n\n// src/translator/core/client.ts\nvar import_compiler26 = require(\"@marko/compiler\");\nvar import_babel_utils19 = require(\"@marko/compiler/babel-utils\");\nvar client_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^client\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils19.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler26.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler26.types.markoScriptlet(body, true, \"client\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"client <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the client.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#client-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/const.ts\nvar import_compiler28 = require(\"@marko/compiler\");\nvar import_babel_utils20 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/translate-var.ts\nvar import_compiler27 = require(\"@marko/compiler\");\nfunction translateVar(tag, initialValue, kind = \"const\") {\n  const {\n    node: { var: tagVar }\n  } = tag;\n  if (!tagVar) {\n    return;\n  }\n  tag.insertBefore(\n    import_compiler27.types.variableDeclaration(kind, [import_compiler27.types.variableDeclarator(tagVar, initialValue)])\n  );\n}\n\n// src/translator/core/const.ts\nvar const_default = {\n  analyze(tag) {\n    (0, import_babel_utils20.assertNoArgs)(tag);\n    (0, import_babel_utils20.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a tag variable.\");\n    }\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler28.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `const` tag only supports the `value` attribute.\"\n      );\n    }\n    const valueExtra = evaluate(valueAttr.value);\n    const upstreamAlias = import_compiler28.types.isIdentifier(valueAttr.value) ? tag.scope.getBinding(valueAttr.value.name)?.identifier.extra?.binding : void 0;\n    if (upstreamAlias) {\n      valueExtra.pruned = true;\n    }\n    const binding = trackVarReferences(tag, 4 /* derived */, upstreamAlias);\n    if (binding) {\n      if (!valueExtra.nullable) binding.nullable = false;\n      setBindingValueExpr(binding, valueExtra);\n    }\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      const { value } = valueAttr;\n      if (isOutputDOM()) {\n        const section = getSection(tag);\n        const varBinding = node.var.extra?.binding;\n        if (varBinding && !varBinding.upstreamAlias) {\n          const derivation = initValue(varBinding);\n          addValue(section, value.extra?.referencedBindings, derivation, value);\n        }\n      } else {\n        translateVar(tag, value);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an constant binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#const\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/const.d.marko\"\n};\n\n// src/translator/core/debug.ts\nvar import_compiler29 = require(\"@marko/compiler\");\nvar import_babel_utils21 = require(\"@marko/compiler/babel-utils\");\nvar debug_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils21.assertNoVar)(tag);\n    (0, import_babel_utils21.assertNoArgs)(tag);\n    (0, import_babel_utils21.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (tag.node.attributes.length > 1 || tag.node.attributes.length === 1 && (!import_compiler29.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\")) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `debug` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const referencedBindings = valueAttr?.value.extra?.referencedBindings;\n      const statement = withPreviousLocation(import_compiler29.types.debuggerStatement(), tag.node);\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Debug on value change.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#debug\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/debug.d.marko\"\n};\n\n// src/translator/core/define.ts\nvar import_compiler35 = require(\"@marko/compiler\");\nvar import_babel_utils27 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/nested-attribute-tags.ts\nvar import_compiler30 = require(\"@marko/compiler\");\nvar import_babel_utils22 = require(\"@marko/compiler/babel-utils\");\nvar attrTagToIdentifierLookup = /* @__PURE__ */ new WeakMap();\nfunction getAttrTagIdentifier(meta) {\n  let name2 = attrTagToIdentifierLookup.get(meta);\n  if (!name2) {\n    name2 = generateUid(meta.name);\n    attrTagToIdentifierLookup.set(meta, name2);\n  }\n  return import_compiler30.types.identifier(name2);\n}\nfunction analyzeAttributeTags(tag) {\n  if (tag.node.extra?.attributeTags) return tag.node.extra.attributeTags;\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  if (!attrTags2.length) return;\n  const tagExtra = tag.node.extra ??= {};\n  const lookup = tagExtra.attributeTags = {};\n  const attrTagNodesByName = {};\n  const sampleAttrTagsForControlFlow = /* @__PURE__ */ new Map();\n  for (const child of attrTags2) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils22.isAttributeTag)(child)) {\n        const name2 = getTagName(child);\n        lookup[name2] ||= createAttrTagMeta(name2, [name2]);\n        (attrTagNodesByName[name2] ||= []).push(child);\n        analyzeAttributeTags(child);\n      } else {\n        const isRepeated = (0, import_babel_utils22.isLoopTag)(child);\n        let curGroup;\n        for (const name2 of crawlAttrTags(child, attrTagNodesByName)) {\n          const oldMeta = lookup[name2];\n          if (oldMeta) {\n            if (!curGroup) {\n              curGroup = oldMeta.group;\n            } else if (curGroup !== oldMeta.group) {\n              for (const name3 of oldMeta.group) {\n                lookup[name3].group = curGroup;\n                curGroup.push(name3);\n              }\n            }\n          }\n          let attrTagMeta = lookup[name2];\n          if (!attrTagMeta) {\n            attrTagMeta = lookup[name2] = createAttrTagMeta(name2, []);\n            curGroup = attrTagMeta.group;\n            curGroup.push(name2);\n          }\n          attrTagMeta.dynamic = true;\n          if (isRepeated) {\n            attrTagMeta.repeated = true;\n          }\n          sampleAttrTagsForControlFlow.set(child, name2);\n        }\n      }\n    }\n  }\n  for (const [controlFlowTag, sampleAttrName] of sampleAttrTagsForControlFlow) {\n    (controlFlowTag.node.extra ??= {}).attributeTagGroup = lookup[sampleAttrName].group;\n  }\n  for (const name2 in attrTagNodesByName) {\n    const attrTagMeta = lookup[name2];\n    if (!attrTagMeta.repeated) {\n      const attrTagNodes = attrTagNodesByName[name2];\n      if (attrTagNodes.length > 1) {\n        attrTagMeta.repeated = !attrTagMeta.dynamic || hasRepeatedDynamicAttrTags(attrTagNodes);\n      }\n    }\n  }\n  return lookup;\n}\nfunction createAttrTagMeta(name2, group) {\n  return {\n    name: name2.slice(1),\n    dynamic: false,\n    repeated: false,\n    group\n  };\n}\nfunction crawlAttrTags(tag, attrTagNodesByName, attrTagNames = /* @__PURE__ */ new Set()) {\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  for (const child of attrTags2) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils22.isAttributeTag)(child)) {\n        const tagName = getTagName(child);\n        attrTagNames.add(tagName);\n        (attrTagNodesByName[tagName] ||= []).push(child);\n        analyzeAttributeTags(child);\n      } else {\n        crawlAttrTags(child, attrTagNodesByName, attrTagNames);\n      }\n    }\n  }\n  return attrTagNames;\n}\nfunction hasRepeatedDynamicAttrTags(attrTags2) {\n  let conditionRoot;\n  const seenBranches = /* @__PURE__ */ new Set();\n  for (const attrTag2 of attrTags2) {\n    const parentTag = getParentTag(attrTag2);\n    if (seenBranches.has(parentTag) || !isConditionTag(parentTag)) {\n      return true;\n    }\n    const curConditionRoot = getConditionRoot(parentTag);\n    if (curConditionRoot && curConditionRoot !== (conditionRoot ||= curConditionRoot)) {\n      return true;\n    }\n    seenBranches.add(parentTag);\n  }\n  return false;\n}\nfunction getConditionRoot(tag) {\n  if (getTagName(tag) === \"if\") return tag;\n  let prev = tag.getPrevSibling();\n  while (prev.node) {\n    if (prev.isMarkoTag() && getTagName(prev) === \"if\") {\n      return prev;\n    }\n    prev = prev.getPrevSibling();\n  }\n}\n\n// src/translator/util/translate-attrs.ts\nvar import_compiler34 = require(\"@marko/compiler\");\nvar import_babel_utils26 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/core/for.ts\nvar import_compiler33 = require(\"@marko/compiler\");\nvar import_babel_utils25 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/is-only-child-in-parent.ts\nvar import_compiler32 = require(\"@marko/compiler\");\nvar import_babel_utils24 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/visitors/tag/native-tag.ts\nvar import_compiler31 = require(\"@marko/compiler\");\nvar import_babel_utils23 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/css-px-props.ts\nvar css_px_props_default = /* @__PURE__ */ new Set([\n  \"background-size\",\n  \"baseline-shift\",\n  \"border-bottom-left-radius\",\n  \"border-bottom-right-radius\",\n  \"border-bottom-width\",\n  \"border-left-width\",\n  \"border-right-width\",\n  \"border-top-left-radius\",\n  \"border-top-right-radius\",\n  \"border-top-width\",\n  \"bottom\",\n  \"column-gap\",\n  \"column-rule-width\",\n  \"column-width\",\n  \"cx\",\n  \"cy\",\n  \"flex-basis\",\n  \"font-size\",\n  \"grid-auto-columns\",\n  \"grid-auto-rows\",\n  \"height\",\n  \"left\",\n  \"letter-spacing\",\n  \"margin-bottom\",\n  \"margin-left\",\n  \"margin-right\",\n  \"margin-top\",\n  \"max-height\",\n  \"max-width\",\n  \"min-height\",\n  \"min-width\",\n  \"offset-distance\",\n  \"outline-offset\",\n  \"outline-width\",\n  \"padding-bottom\",\n  \"padding-left\",\n  \"padding-right\",\n  \"padding-top\",\n  \"perspective\",\n  \"r\",\n  \"right\",\n  \"row-gap\",\n  \"rx\",\n  \"ry\",\n  \"shape-margin\",\n  \"stroke-dashoffset\",\n  \"stroke-width\",\n  \"text-indent\",\n  \"top\",\n  \"vertical-align\",\n  \"width\",\n  \"word-spacing\",\n  \"x\",\n  \"y\"\n]);\n\n// src/translator/visitors/tag/native-tag.ts\nvar kNativeTagBinding = Symbol(\"native tag binding\");\nvar kSkipMark = Symbol(\"skip native tag mark\");\nvar kGetterId = Symbol(\"node getter id\");\nvar htmlSelectArgs = /* @__PURE__ */ new WeakMap();\nvar native_tag_default = {\n  transform: {\n    enter(tag) {\n      const tagName = getTagName(tag);\n      if (tagName === \"textarea\" && tag.node.body.body.length) {\n        const parts = [];\n        for (const child of tag.node.body.body) {\n          if (child.type === \"MarkoText\" || child.type === \"MarkoPlaceholder\" && child.escape) {\n            parts.push(child.value);\n          } else {\n            throw tag.hub.file.hub.buildError(\n              child,\n              \"Unexpected content in textarea, only text and placeholders are supported.\",\n              SyntaxError\n            );\n          }\n        }\n        tag.node.attributes.push(\n          import_compiler31.types.markoAttribute(\n            \"value\",\n            normalizeStringExpression(parts) || buildUndefined()\n          )\n        );\n        tag.node.body.body = [];\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils23.assertNoArgs)(tag);\n      (0, import_babel_utils23.assertNoParams)(tag);\n      (0, import_babel_utils23.assertNoAttributeTags)(tag);\n      const { node } = tag;\n      if (node.var && !import_compiler31.types.isIdentifier(node.var)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"Tag variables on native elements cannot be destructured.\"\n        );\n      }\n      const tagName = getTagName(tag);\n      const seen = {};\n      const { attributes } = tag.node;\n      let hasDynamicAttributes = false;\n      let hasEventHandlers = false;\n      let relatedControllable;\n      let spreadReferenceNodes;\n      let attrExprExtras;\n      for (let i = attributes.length; i--; ) {\n        const attr2 = attributes[i];\n        const valueExtra = attr2.value.extra ??= {};\n        if (import_compiler31.types.isMarkoAttribute(attr2)) {\n          if (seen[attr2.name]) {\n            dropReferences(attr2.value);\n            continue;\n          }\n          seen[attr2.name] = attr2;\n          if (isEventHandler(attr2.name) || isChangeHandler(attr2.name)) {\n            valueExtra.isEffect = true;\n            hasEventHandlers = true;\n          } else if (!evaluate(attr2.value).confident) {\n            hasDynamicAttributes = true;\n          }\n        } else if (import_compiler31.types.isMarkoSpreadAttribute(attr2)) {\n          valueExtra.isEffect = true;\n          hasEventHandlers = true;\n          hasDynamicAttributes = true;\n        }\n        if (spreadReferenceNodes) {\n          spreadReferenceNodes.push(attr2.value);\n        } else if (import_compiler31.types.isMarkoSpreadAttribute(attr2)) {\n          spreadReferenceNodes = [attr2.value];\n          relatedControllable = getRelatedControllable(tagName, seen);\n        } else {\n          attrExprExtras = push(attrExprExtras, valueExtra);\n        }\n      }\n      assertExclusiveControllableGroups(tag, seen);\n      if (node.var || hasEventHandlers || hasDynamicAttributes) {\n        const tagExtra = node.extra ??= {};\n        const tagSection = getOrCreateSection(tag);\n        const nodeBinding = tagExtra[kNativeTagBinding] = createBinding(\n          \"#\" + (node.name.type === \"StringLiteral\" ? node.name.value : import_compiler31.types.toIdentifier(tag.get(\"name\"))),\n          0 /* dom */,\n          tagSection\n        );\n        (0, import_babel_utils23.getProgram)().node.extra.isInteractive ||= hasEventHandlers;\n        if (spreadReferenceNodes) {\n          if (relatedControllable && !relatedControllable.attrs.every(Boolean)) {\n            for (const attr2 of relatedControllable.attrs) {\n              if (attr2) {\n                spreadReferenceNodes.push(attr2.value);\n              }\n            }\n            relatedControllable = void 0;\n          }\n          mergeReferences(tagSection, tag.node, spreadReferenceNodes);\n        } else {\n          relatedControllable = getRelatedControllable(tagName, seen);\n        }\n        if (relatedControllable) {\n          mergeReferences(\n            tagSection,\n            relatedControllable.attrs.find(Boolean).value,\n            relatedControllable.attrs.map((it) => it?.value)\n          );\n        }\n        if (hasEventHandlers || spreadReferenceNodes) {\n          forceBindingSerialize(tagSection, nodeBinding);\n        }\n        if (node.var) {\n          forceBindingSerialize(tagSection, nodeBinding);\n          for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n            const refSection = getOrCreateSection(ref);\n            setReferencesScope(ref);\n            if (isSameOrChildSection(tagSection, refSection)) {\n              forceOwnersSerialize(\n                refSection,\n                tagSection,\n                getAccessorProp().Owner\n              );\n              if (!tagExtra[kGetterId] && !isInvokedFunction(ref)) {\n                tagExtra[kGetterId] = getRegisterUID(\n                  tagSection,\n                  nodeBinding.name\n                );\n              }\n            } else {\n              trackHoistedReference(\n                ref,\n                nodeBinding\n              );\n            }\n          }\n        }\n        addBindingSerializeReasonExpr(\n          tagSection,\n          nodeBinding,\n          push(attrExprExtras, tagExtra)\n        );\n      }\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        const tagName = getTagName(tag);\n        const tagExtra = tag.node.extra;\n        const nodeBinding = tagExtra[kNativeTagBinding];\n        const tagDef = (0, import_babel_utils23.getTagDef)(tag);\n        const write2 = writeTo(tag);\n        const tagSection = getSection(tag);\n        if (tagExtra.tagNameNullable) {\n          flushBefore(tag);\n        }\n        if (tag.node.var) {\n          const getterId = tagExtra[kGetterId];\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(tagSection),\n              getterId && import_compiler31.types.stringLiteral(getterId)\n            )\n          );\n        }\n        const visitAccessor = nodeBinding && getScopeAccessorLiteral(nodeBinding);\n        write2`<${tag.node.name}`;\n        const usedAttrs = getUsedAttrs(tagName, tag.node);\n        const { staticAttrs, staticControllable, skipExpression } = usedAttrs;\n        let { spreadExpression } = usedAttrs;\n        if (staticControllable) {\n          const { helper, attrs: attrs2 } = staticControllable;\n          if (tagName !== \"select\" && tagName !== \"textarea\") {\n            const values = attrs2.map((attr2) => attr2?.value);\n            write2`${callRuntime(helper, getScopeIdIdentifier(tagSection), visitAccessor, ...values)}`;\n          }\n          addHTMLEffectCall(tagSection, void 0);\n        }\n        let writeAtStartOfBody;\n        if (tagName === \"select\") {\n          if (staticControllable) {\n            htmlSelectArgs.set(tag.node, {\n              value: staticControllable.attrs[0]?.value || buildUndefined(),\n              valueChange: staticControllable.attrs[1]?.value || buildUndefined()\n            });\n          } else if (spreadExpression) {\n            const spreadIdentifier = generateUidIdentifier(\"select_input\");\n            tag.insertBefore(\n              import_compiler31.types.variableDeclaration(\"const\", [\n                import_compiler31.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            htmlSelectArgs.set(tag.node, {\n              value: import_compiler31.types.memberExpression(\n                spreadIdentifier,\n                import_compiler31.types.identifier(\"value\")\n              ),\n              valueChange: import_compiler31.types.memberExpression(\n                spreadIdentifier,\n                import_compiler31.types.identifier(\"valueChange\")\n              )\n            });\n            spreadExpression = spreadIdentifier;\n          }\n        } else if (tagName === \"textarea\") {\n          let value;\n          let valueChange;\n          if (staticControllable) {\n            value = staticControllable.attrs[0]?.value;\n            valueChange = staticControllable.attrs[1]?.value;\n          } else if (spreadExpression) {\n            const spreadIdentifier = generateUidIdentifier(\"textarea_input\");\n            tag.insertBefore(\n              import_compiler31.types.variableDeclaration(\"const\", [\n                import_compiler31.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            value = import_compiler31.types.memberExpression(spreadIdentifier, import_compiler31.types.identifier(\"value\"));\n            valueChange = import_compiler31.types.memberExpression(\n              spreadIdentifier,\n              import_compiler31.types.identifier(\"valueChange\")\n            );\n            spreadExpression = spreadIdentifier;\n          }\n          if (value || valueChange) {\n            writeAtStartOfBody = callRuntime(\n              \"controllable_textarea_value\",\n              getScopeIdIdentifier(getSection(tag)),\n              getScopeAccessorLiteral(nodeBinding),\n              value,\n              valueChange\n            );\n          }\n        }\n        for (const attr2 of staticAttrs) {\n          const { name: name2, value } = attr2;\n          const { confident, computed } = value.extra || {};\n          const valueReferences = value.extra?.referencedBindings;\n          if (tagName === \"option\" && name2 === \"value\") {\n            write2`${callRuntime(\"optionValueAttr\", value)}`;\n            continue;\n          }\n          switch (name2) {\n            case \"class\":\n            case \"style\": {\n              const helper = `${name2}Attr`;\n              if (confident) {\n                write2`${getHTMLRuntime()[helper](computed)}`;\n              } else {\n                write2`${callRuntime(helper, value)}`;\n              }\n              break;\n            }\n            default:\n              if (confident) {\n                write2`${getHTMLRuntime().attr(name2, computed)}`;\n              } else if (isEventHandler(name2)) {\n                addHTMLEffectCall(tagSection, valueReferences);\n              } else {\n                write2`${callRuntime(\"attr\", import_compiler31.types.stringLiteral(name2), value)}`;\n              }\n              break;\n          }\n        }\n        if (spreadExpression) {\n          addHTMLEffectCall(tagSection, tagExtra.referencedBindings);\n          if (skipExpression) {\n            write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(tagSection), tag.node.name)}`;\n          } else {\n            write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(tagSection), tag.node.name)}`;\n          }\n        }\n        if (tagDef && tagDef.parseOptions?.openTagOnly) {\n          switch (tagDef.htmlType) {\n            case \"svg\":\n            case \"math\":\n              write2`/>`;\n              break;\n            default:\n              write2`>`;\n              break;\n          }\n        } else {\n          write2`>`;\n        }\n        if (tagExtra.tagNameNullable) {\n          tag.insertBefore(\n            import_compiler31.types.ifStatement(tag.node.name, consumeHTML(tag))\n          )[0].skip();\n        }\n        if (writeAtStartOfBody) {\n          write2`${writeAtStartOfBody}`;\n        }\n      },\n      exit(tag) {\n        const tagExtra = tag.node.extra;\n        const nodeBinding = tagExtra[kNativeTagBinding];\n        const openTagOnly = (0, import_babel_utils23.getTagDef)(tag)?.parseOptions?.openTagOnly;\n        const selectArgs = htmlSelectArgs.get(tag.node);\n        const tagName = getTagName(tag);\n        const tagSection = getSection(tag);\n        if (tagExtra.tagNameNullable) {\n          flushInto(tag);\n        }\n        if (selectArgs) {\n          writeTo(tag)`</${tag.node.name}>`;\n          flushInto(tag);\n          tag.insertBefore(\n            import_compiler31.types.expressionStatement(\n              callRuntime(\n                \"controllable_select_value\",\n                getScopeIdIdentifier(getSection(tag)),\n                getScopeAccessorLiteral(nodeBinding),\n                selectArgs.value,\n                selectArgs.valueChange,\n                import_compiler31.types.arrowFunctionExpression(\n                  [],\n                  import_compiler31.types.blockStatement(tag.node.body.body)\n                )\n              )\n            )\n          );\n        } else {\n          tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n        }\n        const markerSerializeReason = nodeBinding && !tagExtra[kSkipMark] && getBindingSerializeReason(tagSection, nodeBinding);\n        if (!openTagOnly && !selectArgs) {\n          writeTo(\n            tag,\n            !markerSerializeReason && (tagName === \"html\" || tagName === \"body\")\n          )`</${tag.node.name}>`;\n        }\n        if (tagExtra.tagNameNullable) {\n          tag.insertBefore(\n            import_compiler31.types.ifStatement(tag.node.name, consumeHTML(tag))\n          )[0].skip();\n        }\n        if (markerSerializeReason) {\n          markNode(tag, nodeBinding, markerSerializeReason);\n        }\n        tag.remove();\n      }\n    },\n    dom: {\n      enter(tag) {\n        const tagName = getTagName(tag);\n        const tagExtra = tag.node.extra;\n        const nodeBinding = tagExtra[kNativeTagBinding];\n        const tagDef = (0, import_babel_utils23.getTagDef)(tag);\n        const write2 = writeTo(tag);\n        const tagSection = getSection(tag);\n        if (tag.node.var) {\n          const varName = tag.node.var.name;\n          const varBinding = tag.scope.getBinding(varName);\n          const getterId = tagExtra[kGetterId];\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);\n            (0, import_babel_utils23.getProgram)().node.body.push(\n              import_compiler31.types.variableDeclaration(\"const\", [\n                import_compiler31.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler31.types.stringLiteral(getterId),\n                    import_compiler31.types.stringLiteral(\n                      getAccessorPrefix().Getter + getScopeAccessorLiteral(nodeBinding).value\n                    )\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of varBinding.referencePaths) {\n            const referenceSection = getSection(reference);\n            if (isSameOrChildSection(tagSection, referenceSection)) {\n              if (isInvokedFunction(reference)) {\n                reference.parentPath.replaceWith(\n                  import_compiler31.types.expressionStatement(\n                    createScopeReadExpression(referenceSection, nodeBinding)\n                  )\n                );\n              } else if (getterFnIdentifier) {\n                reference.replaceWith(\n                  import_compiler31.types.callExpression(getterFnIdentifier, [\n                    getScopeExpression(referenceSection, getSection(tag))\n                  ])\n                );\n              } else {\n                reference.replaceWith(\n                  import_compiler31.types.expressionStatement(\n                    import_compiler31.types.memberExpression(\n                      getScopeExpression(tagSection, referenceSection),\n                      import_compiler31.types.stringLiteral(\n                        getAccessorPrefix().Getter + getScopeAccessorLiteral(nodeBinding).value\n                      ),\n                      true\n                    )\n                  )\n                );\n              }\n            }\n          }\n        }\n        const visitAccessor = nodeBinding && getScopeAccessorLiteral(nodeBinding);\n        if (visitAccessor) {\n          visit(tag, 32 /* Get */);\n        }\n        write2`<${tag.node.name}`;\n        const usedAttrs = getUsedAttrs(tagName, tag.node);\n        const { staticAttrs, staticControllable, skipExpression } = usedAttrs;\n        const { spreadExpression } = usedAttrs;\n        if (staticControllable) {\n          const { helper, attrs: attrs2 } = staticControllable;\n          const firstAttr = attrs2.find(Boolean);\n          const referencedBindings = firstAttr.value.extra?.referencedBindings;\n          const values = attrs2.map((attr2) => attr2?.value);\n          addStatement(\n            \"render\",\n            tagSection,\n            referencedBindings,\n            import_compiler31.types.expressionStatement(\n              callRuntime(helper, scopeIdentifier, visitAccessor, ...values)\n            )\n          );\n          addStatement(\n            \"effect\",\n            tagSection,\n            void 0,\n            import_compiler31.types.expressionStatement(\n              callRuntime(`${helper}_effect`, scopeIdentifier, visitAccessor)\n            )\n          );\n        }\n        for (const attr2 of staticAttrs) {\n          const { name: name2, value } = attr2;\n          const { confident, computed } = value.extra || {};\n          const valueReferences = value.extra?.referencedBindings;\n          switch (name2) {\n            case \"class\":\n            case \"style\": {\n              const helper = `${name2}Attr`;\n              if (confident) {\n                write2`${getHTMLRuntime()[helper](computed)}`;\n              } else {\n                const nodeExpr = import_compiler31.types.memberExpression(\n                  scopeIdentifier,\n                  visitAccessor,\n                  true\n                );\n                const meta = {\n                  staticItems: void 0,\n                  dynamicItems: void 0,\n                  dynamicValues: void 0\n                };\n                let stmt;\n                trackDelimitedAttrValue(value, meta);\n                if (meta.dynamicItems) {\n                  stmt = import_compiler31.types.expressionStatement(\n                    callRuntime(helper, nodeExpr, value)\n                  );\n                } else {\n                  if (meta.staticItems) {\n                    write2`${getHTMLRuntime()[helper](computed)}`;\n                  }\n                  if (meta.dynamicValues) {\n                    const keys = Object.keys(meta.dynamicValues);\n                    if (keys.length === 1) {\n                      const [key] = keys;\n                      const value2 = meta.dynamicValues[key];\n                      stmt = import_compiler31.types.expressionStatement(\n                        callRuntime(\n                          `${name2}Item`,\n                          nodeExpr,\n                          import_compiler31.types.stringLiteral(key),\n                          name2 === \"style\" && css_px_props_default.has(name2) ? callRuntime(\"styleItemValue\", value2) : value2\n                        )\n                      );\n                    } else {\n                      const props = [];\n                      for (const key of keys) {\n                        const value2 = meta.dynamicValues[key];\n                        props.push(\n                          import_compiler31.types.objectProperty(\n                            toPropertyName(key),\n                            name2 === \"style\" && css_px_props_default.has(name2) ? callRuntime(\"styleItemValue\", value2) : value2\n                          )\n                        );\n                      }\n                      stmt = import_compiler31.types.expressionStatement(\n                        callRuntime(\n                          `${name2}Items`,\n                          nodeExpr,\n                          import_compiler31.types.objectExpression(props)\n                        )\n                      );\n                    }\n                  }\n                }\n                if (stmt) {\n                  addStatement(\"render\", tagSection, valueReferences, stmt);\n                }\n              }\n              break;\n            }\n            default:\n              if (confident) {\n                write2`${getHTMLRuntime().attr(name2, computed)}`;\n              } else if (isEventHandler(name2)) {\n                addStatement(\n                  \"effect\",\n                  tagSection,\n                  valueReferences,\n                  import_compiler31.types.expressionStatement(\n                    callRuntime(\n                      \"on\",\n                      import_compiler31.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                      import_compiler31.types.stringLiteral(getEventHandlerName(name2)),\n                      value\n                    )\n                  )\n                );\n              } else {\n                addStatement(\n                  \"render\",\n                  tagSection,\n                  valueReferences,\n                  import_compiler31.types.expressionStatement(\n                    callRuntime(\n                      \"attr\",\n                      import_compiler31.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                      import_compiler31.types.stringLiteral(name2),\n                      value\n                    )\n                  )\n                );\n              }\n              break;\n          }\n        }\n        if (spreadExpression) {\n          if (skipExpression) {\n            addStatement(\n              \"render\",\n              tagSection,\n              tagExtra.referencedBindings,\n              import_compiler31.types.expressionStatement(\n                callRuntime(\n                  \"partialAttrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression,\n                  skipExpression\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              tagSection,\n              tagExtra.referencedBindings,\n              import_compiler31.types.expressionStatement(\n                callRuntime(\n                  \"attrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression\n                )\n              )\n            );\n          }\n          addStatement(\n            \"effect\",\n            tagSection,\n            tagExtra.referencedBindings,\n            import_compiler31.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            false\n          );\n        }\n        if (tagDef && tagDef.parseOptions?.openTagOnly) {\n          switch (tagDef.htmlType) {\n            case \"svg\":\n            case \"math\":\n              write2`/>`;\n              break;\n            default:\n              write2`>`;\n              break;\n          }\n        } else {\n          write2`>`;\n        }\n        enter2(tag);\n      },\n      exit(tag) {\n        const openTagOnly = (0, import_babel_utils23.getTagDef)(tag)?.parseOptions?.openTagOnly;\n        tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n        if (!openTagOnly) {\n          writeTo(tag)`</${tag.node.name}>`;\n        }\n        exit2(tag);\n        tag.remove();\n      }\n    }\n  })\n};\nfunction assertExclusiveControllableGroups(tag, attrs2) {\n  const exclusiveGroups = [\n    attrs2.open || attrs2.openChange,\n    attrs2.checked || attrs2.checkedChange,\n    attrs2.checkedValue || attrs2.checkedValueChange,\n    attrs2.valueChange\n  ].filter(Boolean);\n  if (exclusiveGroups.length > 1) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The attributes ${exclusiveGroups.map((attr2) => `\"${attr2.name}\"`).join(\", \")} are mutually exclusive.`\n    );\n  }\n}\nfunction getRelatedControllable(tagName, attrs2) {\n  switch (tagName) {\n    case \"input\":\n      if (attrs2.checked || attrs2.checkedChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_checked\",\n          attrs: [attrs2.checked, attrs2.checkedChange]\n        };\n      }\n      if (attrs2.checkedValue || attrs2.checkedValueChange) {\n        return {\n          special: true,\n          helper: \"controllable_input_checkedValue\",\n          attrs: [attrs2.checkedValue, attrs2.checkedValueChange, attrs2.value]\n        };\n      }\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"select\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_select_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"textarea\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_textarea_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"details\":\n    case \"dialog\":\n      if (attrs2.open || attrs2.openChange) {\n        return {\n          special: false,\n          helper: \"controllable_detailsOrDialog_open\",\n          attrs: [attrs2.open, attrs2.openChange]\n        };\n      }\n      break;\n  }\n}\nfunction getUsedAttrs(tagName, tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  let staticControllable;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler31.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n        staticControllable = getRelatedControllable(tagName, seen);\n        if (staticControllable && !staticControllable.attrs.every(Boolean)) {\n          for (const attr3 of staticControllable.attrs) {\n            if (attr3) {\n              spreadProps.push(toObjectProperty(attr3.name, attr3.value));\n              maybeStaticAttrs.delete(attr3);\n            }\n          }\n          staticControllable = void 0;\n        }\n      }\n      spreadProps.push(import_compiler31.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  if (!spreadProps) {\n    staticControllable = getRelatedControllable(tagName, seen);\n    if (staticControllable?.special === false && !staticControllable.attrs[1]) {\n      staticControllable = void 0;\n    }\n  }\n  if (staticControllable) {\n    for (const attr2 of staticControllable.attrs) {\n      if (attr2) {\n        maybeStaticAttrs.delete(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    if (staticControllable) {\n      for (const attr2 of staticControllable.attrs) {\n        if (attr2) {\n          (skipProps ||= []).push(\n            toObjectProperty(attr2.name, import_compiler31.types.numericLiteral(1))\n          );\n        }\n      }\n    }\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler31.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler31.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    staticControllable,\n    spreadExpression,\n    skipExpression\n  };\n}\nfunction trackDelimitedAttrValue(expr, meta) {\n  switch (expr.type) {\n    case \"ObjectExpression\":\n      trackDelimitedAttrObjectProperties(expr, meta);\n      break;\n    case \"ArrayExpression\":\n      trackDelimitedAttrArrayItems(expr, meta);\n      break;\n    default:\n      (meta.dynamicItems ||= []).push(expr);\n      break;\n  }\n}\nfunction trackDelimitedAttrArrayItems(arr, meta) {\n  for (const item of arr.elements) {\n    if (item) {\n      switch (item.type) {\n        case \"ArrayExpression\": {\n          trackDelimitedAttrArrayItems(item, meta);\n          break;\n        }\n        case \"ObjectExpression\": {\n          trackDelimitedAttrObjectProperties(item, meta);\n          break;\n        }\n        case \"SpreadElement\":\n          if (item.argument.type === \"ArrayExpression\") {\n            trackDelimitedAttrArrayItems(item.argument, meta);\n          } else {\n            (meta.dynamicItems ||= []).push(item);\n          }\n          break;\n        default: {\n          const evalItem = evaluate(item);\n          if (evalItem.confident) {\n            (meta.staticItems ||= []).push(evalItem.computed);\n          } else {\n            (meta.dynamicItems ||= []).push(item);\n          }\n          break;\n        }\n      }\n    }\n  }\n}\nfunction trackDelimitedAttrObjectProperties(obj, meta) {\n  let staticProps;\n  let dynamicProps;\n  for (const prop of obj.properties) {\n    if (prop.type !== \"ObjectProperty\" || prop.computed) {\n      (dynamicProps ||= []).push(prop);\n      continue;\n    }\n    let key;\n    if (prop.key.type === \"Identifier\") {\n      key = prop.key.name;\n    } else {\n      const keyEval = evaluate(prop.key);\n      if (keyEval.confident) {\n        key = keyEval.computed + \"\";\n      } else {\n        (dynamicProps ||= []).push(prop);\n        continue;\n      }\n    }\n    const value = prop.value;\n    const propEval = evaluate(value);\n    if (propEval.confident) {\n      (staticProps ||= {})[key] = propEval.computed;\n    } else {\n      (meta.dynamicValues ||= {})[key] = value;\n    }\n  }\n  if (staticProps) {\n    (meta.staticItems ||= []).push(staticProps);\n  }\n  if (dynamicProps) {\n    (meta.dynamicItems ||= []).push(import_compiler31.types.objectExpression(dynamicProps));\n  }\n}\nfunction isChangeHandler(propName) {\n  return /^(?:value|checked(?:Value)?|open)Change/.test(propName);\n}\nfunction buildUndefined() {\n  return import_compiler31.types.unaryExpression(\"void\", import_compiler31.types.numericLiteral(0));\n}\n\n// src/translator/util/is-only-child-in-parent.ts\nvar kOnlyChildInParent = Symbol(\"only child in parent\");\nvar kNodeRef = Symbol(\"potential only child node ref\");\nfunction isOnlyChildInParent(tag, branchSize = 1) {\n  const extra = tag.node.extra;\n  if (extra[kOnlyChildInParent] !== void 0) {\n    return extra[kOnlyChildInParent];\n  }\n  const parentTag = getParentTag(tag);\n  if (parentTag && (0, import_babel_utils24.getTagDef)(parentTag)?.html) {\n    return extra[kOnlyChildInParent] = tag.parent.body.length === branchSize;\n  }\n  return extra[kOnlyChildInParent] = false;\n}\nfunction getOptimizedOnlyChildNodeBinding(tag, section, branchSize = 1) {\n  if (isOnlyChildInParent(tag, branchSize)) {\n    const parentTag = getParentTag(tag).node;\n    const parentTagName = parentTag.name?.value;\n    return (parentTag.extra ??= {})[kNativeTagBinding] ??= createBinding(\n      \"#\" + parentTagName,\n      0 /* dom */,\n      section\n    );\n  } else {\n    return (tag.node.extra ??= {})[kNodeRef] ??= createBinding(\n      \"#text\",\n      0 /* dom */,\n      section\n    );\n  }\n}\n\n// src/translator/core/for.ts\nvar for_default = {\n  analyze(tag) {\n    const isAttrTag = tag.node.body.attributeTags;\n    let allowAttrs;\n    (0, import_babel_utils25.assertNoVar)(tag);\n    (0, import_babel_utils25.assertNoArgs)(tag);\n    assertNoSpreadAttrs(tag);\n    switch (getForType(tag.node)) {\n      case \"of\":\n        allowAttrs = [\"of\"];\n        break;\n      case \"in\":\n        allowAttrs = [\"in\"];\n        break;\n      case \"to\":\n        allowAttrs = [\"to\", \"from\", \"step\"];\n        break;\n      default:\n        throw tag.buildCodeFrameError(\n          \"Invalid `for` tag, missing an `of=`, `in=`, `to=` attribute.\"\n        );\n    }\n    if (!isAttrTag) {\n      allowAttrs.push(\"by\");\n    }\n    (0, import_babel_utils25.assertAllowedAttributes)(tag, allowAttrs);\n    if (isAttrTag) return;\n    const tagBody = tag.get(\"body\");\n    const bodySection = startSection(tagBody);\n    if (!bodySection) {\n      dropReferences(getAllTagReferenceNodes(tag.node));\n      return;\n    }\n    const tagSection = getOrCreateSection(tag);\n    const nodeBinding = getOptimizedOnlyChildNodeBinding(tag, tagSection);\n    const paramsBinding = trackParamsReferences(tagBody, 3 /* param */);\n    const tagExtra = mergeReferences(\n      tagSection,\n      tag.node,\n      getAllTagReferenceNodes(tag.node)\n    );\n    if (paramsBinding) {\n      setBindingValueExpr(paramsBinding, tagExtra);\n    }\n    bodySection.sectionAccessor = {\n      binding: nodeBinding,\n      prefix: getAccessorPrefix().LoopScopeMap\n    };\n    bodySection.upstreamExpression = tagExtra;\n    bodySection.isBranch = true;\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        if (!isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n        flushBefore(tag);\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const onlyChildInParentOptimization = isOnlyChildInParent(tag);\n        const nodeBinding = getOptimizedOnlyChildNodeBinding(tag, tagSection);\n        const forAttrs = getKnownAttrValues(node);\n        const forType = getForType(node);\n        const params = node.body.params;\n        const statements = [];\n        const bodyStatements = node.body.body;\n        const singleNodeOptimization = bodySection.content === null || bodySection.content.singleChild && bodySection.content.startType !== 4 /* Text */;\n        const branchSerializeReason = getSectionSerializeReason(\n          bodySection,\n          kBranchSerializeReason\n        );\n        const markerSerializeReason = getBindingSerializeReason(\n          tagSection,\n          nodeBinding\n        );\n        flushInto(tag);\n        writeHTMLResumeStatements(tagBody);\n        const forTagArgs = getBaseArgsInForTag(forType, forAttrs);\n        const forTagHTMLRuntime = branchSerializeReason ? forTypeToHTMLResumeRuntime(forType, singleNodeOptimization) : forTypeToRuntime(forType);\n        forTagArgs.push(\n          import_compiler33.types.arrowFunctionExpression(params, import_compiler33.types.blockStatement(bodyStatements))\n        );\n        if (branchSerializeReason) {\n          if (markerSerializeReason && onlyChildInParentOptimization) {\n            getParentTag(tag).node.extra[kSkipMark] = true;\n          }\n          forTagArgs.push(\n            forAttrs.by || import_compiler33.types.numericLiteral(0),\n            getScopeIdIdentifier(tagSection),\n            getScopeAccessorLiteral(nodeBinding),\n            branchSerializeReason === true ? markerSerializeReason === true && !onlyChildInParentOptimization ? void 0 : import_compiler33.types.numericLiteral(1) : getSerializeGuard(branchSerializeReason),\n            !markerSerializeReason ? import_compiler33.types.numericLiteral(0) : markerSerializeReason === true ? onlyChildInParentOptimization ? import_compiler33.types.numericLiteral(1) : void 0 : getSerializeGuard(markerSerializeReason)\n          );\n          if (onlyChildInParentOptimization) {\n            forTagArgs.push(import_compiler33.types.numericLiteral(1));\n          }\n        }\n        statements.push(\n          import_compiler33.types.expressionStatement(callRuntime(forTagHTMLRuntime, ...forTagArgs))\n        );\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        if (!isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const { referencedBindings } = tagExtra;\n        const nodeRef2 = getOptimizedOnlyChildNodeBinding(tag, tagSection);\n        setClosureSignalBuilder(tag, (closure, render) => {\n          return callRuntime(\n            \"loopClosure\",\n            getScopeAccessorLiteral(closure),\n            getScopeAccessorLiteral(nodeRef2),\n            render\n          );\n        });\n        const forType = getForType(node);\n        const signal = getSignal(tagSection, nodeRef2, \"for\");\n        signal.build = () => {\n          return callRuntime(\n            forTypeToDOMRuntime(forType),\n            getScopeAccessorLiteral(nodeRef2),\n            import_compiler33.types.identifier(bodySection.name)\n          );\n        };\n        const params = node.body.params;\n        signal.hasDownstreamIntersections = () => {\n          for (const param of params) {\n            const binding = param.extra?.binding;\n            if (binding) {\n              for (const {\n                referencedBindings: referencedBindings2\n              } of binding.downstreamExpressions) {\n                if (getSignal(\n                  bodySection,\n                  referencedBindings2\n                ).hasDownstreamIntersections()) {\n                  return true;\n                }\n              }\n            }\n          }\n          return false;\n        };\n        const forAttrs = getKnownAttrValues(node);\n        const loopArgs = getBaseArgsInForTag(forType, forAttrs);\n        if (forAttrs.by) {\n          loopArgs.push(forAttrs.by);\n        }\n        addValue(\n          tagSection,\n          referencedBindings,\n          signal,\n          import_compiler33.types.arrayExpression(loopArgs)\n        );\n        tag.remove();\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  attributes: {\n    of: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over a list of items.\"\n        }\n      ]\n    },\n    in: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over the keys and values of an object.\"\n        }\n      ]\n    },\n    to: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates up to the provided number (inclusive)\"\n        }\n      ]\n    },\n    from: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates starting from the provided number (inclusive)\"\n        }\n      ]\n    },\n    step: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"The amount to increment during each interation (with from/to)\"\n        }\n      ]\n    }\n  },\n  autocomplete: [\n    {\n      snippet: \"for|${1:value, index}| of=${3:array}\",\n      description: \"Use to iterate over lists, object properties, or between ranges.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-a-list\"\n    },\n    {\n      snippet: \"for|${1:name, value}| in=${3:object}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties\"\n    },\n    {\n      snippet: \"for|${1:index}| to=${2:number}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers\"\n    }\n  ]\n};\nfunction buildForRuntimeCall(type, attrs2, params, statements) {\n  return import_compiler33.types.expressionStatement(\n    callRuntime(\n      forTypeToRuntime(type),\n      ...getBaseArgsInForTag(type, attrs2),\n      import_compiler33.types.arrowFunctionExpression(params, import_compiler33.types.blockStatement(statements))\n    )\n  );\n}\nfunction getForType(tag) {\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      switch (attr2.name) {\n        case \"of\":\n        case \"in\":\n        case \"to\":\n          return attr2.name;\n      }\n    }\n  }\n}\nfunction forTypeToRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"forOf\";\n    case \"in\":\n      return \"forIn\";\n    case \"to\":\n      return \"forTo\";\n  }\n}\nfunction forTypeToHTMLResumeRuntime(type, singleNodeOptimization) {\n  if (singleNodeOptimization) {\n    switch (type) {\n      case \"of\":\n        return \"resumeSingleNodeForOf\";\n      case \"in\":\n        return \"resumeSingleNodeForIn\";\n      case \"to\":\n        return \"resumeSingleNodeForTo\";\n    }\n  } else {\n    switch (type) {\n      case \"of\":\n        return \"resumeForOf\";\n      case \"in\":\n        return \"resumeForIn\";\n      case \"to\":\n        return \"resumeForTo\";\n    }\n  }\n}\nfunction forTypeToDOMRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"loopOf\";\n    case \"in\":\n      return \"loopIn\";\n    case \"to\":\n      return \"loopTo\";\n  }\n}\nfunction getBaseArgsInForTag(type, attrs2) {\n  switch (type) {\n    case \"in\":\n      return [attrs2.in];\n    case \"of\":\n      return [attrs2.of];\n    case \"to\":\n      return [\n        attrs2.to,\n        attrs2.from || import_compiler33.types.numericLiteral(0),\n        attrs2.step || import_compiler33.types.numericLiteral(1)\n      ];\n  }\n}\n\n// src/translator/util/translate-attrs.ts\nvar contentProps = /* @__PURE__ */ new WeakSet();\nfunction translateAttrs(tag, templateExports, statements = [], contentKey = \"content\") {\n  const seen = /* @__PURE__ */ new Set();\n  const properties = [];\n  const attrTagLookup = tag.node.extra?.attributeTags;\n  if (attrTagLookup) {\n    for (const name2 in attrTagLookup) {\n      const attrTagMeta = attrTagLookup[name2];\n      if (usesExport(templateExports, attrTagMeta.name)) {\n        seen.add(attrTagMeta.name);\n        if (attrTagMeta.dynamic) {\n          statements.push(\n            import_compiler34.types.variableDeclaration(\"let\", [\n              import_compiler34.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta))\n            ])\n          );\n          properties.push(\n            toObjectProperty(\n              attrTagMeta.name,\n              getAttrTagIdentifier(attrTagMeta)\n            )\n          );\n        }\n      }\n    }\n    const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils26.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          if (attrTagMeta.dynamic) {\n            i = addDynamicAttrTagStatements(\n              attrTags2,\n              i,\n              attrTagLookup,\n              statements,\n              templateExports,\n              contentKey\n            );\n          } else {\n            const translatedAttrTag = translateAttrs(\n              child,\n              templateExports?.[attrTagMeta.name]?.props,\n              statements,\n              contentKey\n            );\n            if (attrTagMeta.repeated) {\n              const prevProp = findObjectProperty(attrTagMeta.name, properties);\n              if (prevProp) {\n                prevProp.value = callRuntime(\n                  \"attrTags\",\n                  prevProp.value,\n                  propsToExpression(translatedAttrTag.properties)\n                );\n              } else {\n                properties.push(\n                  toObjectProperty(\n                    attrTagMeta.name,\n                    callRuntime(\n                      \"attrTag\",\n                      propsToExpression(translatedAttrTag.properties)\n                    )\n                  )\n                );\n              }\n            } else {\n              properties.push(\n                toObjectProperty(\n                  attrTagMeta.name,\n                  callRuntime(\n                    \"attrTag\",\n                    propsToExpression(translatedAttrTag.properties)\n                  )\n                )\n              );\n            }\n          }\n        } else {\n          i = addDynamicAttrTagStatements(\n            attrTags2,\n            i,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        }\n      }\n    }\n  }\n  if (!seen.has(contentKey) && usesExport(templateExports, contentKey)) {\n    seen.add(contentKey);\n    const contentExpression = buildContent(tag.get(\"body\"));\n    if (contentExpression) {\n      const contentProp = import_compiler34.types.objectProperty(\n        import_compiler34.types.identifier(contentKey),\n        contentExpression\n      );\n      contentProps.add(contentProp);\n      properties.push(contentProp);\n    }\n  }\n  const { attributes } = tag.node;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler34.types.isMarkoSpreadAttribute(attr2)) {\n      properties.push(import_compiler34.types.spreadElement(value));\n    } else if (!seen.has(attr2.name) && usesExport(templateExports, attr2.name)) {\n      seen.add(attr2.name);\n      properties.push(toObjectProperty(attr2.name, value));\n    }\n  }\n  properties.reverse();\n  return { properties, statements };\n}\nfunction getTranslatedBodyContentProperty(props) {\n  for (const prop of props) {\n    if (contentProps.has(prop)) {\n      return prop;\n    }\n  }\n}\nfunction addDynamicAttrTagStatements(attrTags2, index, attrTagLookup, statements, templateExports, contentKey = \"content\") {\n  const tag = attrTags2[index];\n  if (tag.isMarkoTag()) {\n    if ((0, import_babel_utils26.isAttributeTag)(tag)) {\n      const attrTagMeta = attrTagLookup[getTagName(tag)];\n      if (usesExport(templateExports, attrTagMeta.name) && attrTagMeta.dynamic) {\n        const translatedAttrTag = translateAttrs(\n          tag,\n          templateExports?.[attrTagMeta.name]?.props,\n          statements,\n          contentKey\n        );\n        if (attrTagMeta.repeated) {\n          statements.push(\n            import_compiler34.types.expressionStatement(\n              import_compiler34.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTags\",\n                  getAttrTagIdentifier(attrTagMeta),\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        } else {\n          statements.push(\n            import_compiler34.types.expressionStatement(\n              import_compiler34.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTag\",\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        }\n      }\n    } else {\n      switch (getTagName(tag)) {\n        case \"if\":\n          return translateIfAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        case \"for\": {\n          return translateForAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        }\n      }\n    }\n  }\n  return index;\n}\nfunction propsToExpression(props) {\n  return props.length === 1 && import_compiler34.types.isSpreadElement(props[0]) ? props[0].argument : import_compiler34.types.objectExpression(props);\n}\nfunction translateForAttrTag(attrTags2, index, attrTagLookup, statements, templateExports, contentKey) {\n  const forTag = attrTags2[index];\n  const bodyStatements = [];\n  addAllAttrTagsAsDynamic(\n    forTag,\n    attrTagLookup,\n    bodyStatements,\n    templateExports,\n    contentKey\n  );\n  statements.push(\n    buildForRuntimeCall(\n      getForType(forTag.node),\n      getKnownAttrValues(forTag.node),\n      forTag.node.body.params,\n      bodyStatements\n    )\n  );\n  return index;\n}\nfunction translateIfAttrTag(attrTags2, index, attrTagLookup, statements, templateExports, contentKey) {\n  const ifTag = attrTags2[index];\n  const consequentStatements = [];\n  let ifStatement = import_compiler34.types.ifStatement(\n    getConditionTestValue(ifTag),\n    import_compiler34.types.blockStatement(consequentStatements)\n  );\n  statements.push(ifStatement);\n  addAllAttrTagsAsDynamic(\n    ifTag,\n    attrTagLookup,\n    consequentStatements,\n    templateExports,\n    contentKey\n  );\n  let nextIndex = index + 1;\n  while (nextIndex < attrTags2.length) {\n    const nextTag = attrTags2[nextIndex];\n    if (nextTag.isMarkoTag()) {\n      switch (getTagName(nextTag)) {\n        case \"else-if\":\n        case \"else\": {\n          const testValue = getConditionTestValue(nextTag);\n          const alternateStatements = [];\n          addAllAttrTagsAsDynamic(\n            nextTag,\n            attrTagLookup,\n            alternateStatements,\n            templateExports,\n            contentKey\n          );\n          if (testValue) {\n            ifStatement.alternate = ifStatement = import_compiler34.types.ifStatement(\n              testValue,\n              import_compiler34.types.blockStatement(alternateStatements)\n            );\n            nextIndex++;\n            continue;\n          } else {\n            ifStatement.alternate = import_compiler34.types.blockStatement(alternateStatements);\n            break;\n          }\n        }\n      }\n    }\n    break;\n  }\n  return nextIndex - 1;\n}\nfunction addAllAttrTagsAsDynamic(tag, attrTagLookup, statements, templateExports, contentKey) {\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  for (let i = 0; i < attrTags2.length; i++) {\n    i = addDynamicAttrTagStatements(\n      attrTags2,\n      i,\n      attrTagLookup,\n      statements,\n      templateExports,\n      contentKey\n    );\n  }\n}\nfunction usesExport(templateExports, name2) {\n  return !templateExports || !!templateExports[name2];\n}\nfunction findObjectProperty(name2, props) {\n  for (const prop of props) {\n    if (prop.type === \"ObjectProperty\") {\n      switch (prop.key.type) {\n        case \"StringLiteral\":\n          if (prop.key.value === name2) {\n            return prop;\n          }\n          break;\n        case \"Identifier\":\n          if (prop.key.name === name2) {\n            return prop;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\nfunction getConditionTestValue({\n  node: { attributes }\n}) {\n  return attributes.length === 1 ? attributes[0].value : void 0;\n}\nfunction buildContent(body) {\n  const bodySection = body.node.extra?.section;\n  if (bodySection) {\n    if (isOutputHTML()) {\n      const serialized = isSerializedSection(bodySection);\n      return callRuntime(\n        serialized ? \"registerContent\" : \"createContent\",\n        import_compiler34.types.stringLiteral(getResumeRegisterId(bodySection, \"renderer\")),\n        import_compiler34.types.arrowFunctionExpression(\n          body.node.params,\n          import_compiler34.types.blockStatement(body.node.body)\n        ),\n        serialized ? getScopeIdIdentifier(\n          getSection(\n            getNonAttributeTagParent(\n              body.parentPath\n            )\n          )\n        ) : void 0\n      );\n    } else {\n      return import_compiler34.types.callExpression(import_compiler34.types.identifier(bodySection.name), [\n        scopeIdentifier\n      ]);\n    }\n  }\n}\nfunction getNonAttributeTagParent(tag) {\n  let cur = tag;\n  while ((0, import_babel_utils26.isAttributeTag)(cur) || (0, import_babel_utils26.isTransparentTag)(cur)) {\n    cur = getParentTag(cur);\n  }\n  return cur;\n}\n\n// src/translator/core/define.ts\nvar define_default = {\n  analyze(tag) {\n    (0, import_babel_utils27.assertNoArgs)(tag);\n    if (!tag.node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `define` tag requires a tag variable.\");\n    }\n    const tagBody = tag.get(\"body\");\n    const bodySection = startSection(tagBody);\n    const varBinding = trackVarReferences(tag, 4 /* derived */);\n    if (bodySection) {\n      if (varBinding) {\n        bodySection.downstreamBinding = varBinding.propertyAliases.get(\"content\") || varBinding;\n      }\n    }\n    trackParamsReferences(tagBody, 3 /* param */);\n    analyzeAttributeTags(tag);\n    const tagExtra = mergeReferences(\n      getOrCreateSection(tag),\n      tag.node,\n      getAllTagReferenceNodes(tag.node)\n    );\n    if (varBinding) {\n      setBindingValueExpr(varBinding, tagExtra);\n    }\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const translatedAttrs = translateAttrs(tag);\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        tag.insertBefore(translatedAttrs.statements);\n        translateVar(tag, propsToExpression(translatedAttrs.properties));\n      } else {\n        const section = getSection(tag);\n        const referencedBindings = node.extra?.referencedBindings;\n        const derivation = initValue(tag.get(\"var\").node.extra.binding);\n        if (translatedAttrs.statements.length) {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            translatedAttrs.statements\n          );\n        }\n        addValue(\n          section,\n          referencedBindings,\n          derivation,\n          propsToExpression(translatedAttrs.properties)\n        );\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a constant object binding that can be rendered.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#define\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/define.d.marko\"\n};\n\n// src/translator/core/effect.ts\nvar import_compiler36 = require(\"@marko/compiler\");\nvar import_babel_utils28 = require(\"@marko/compiler/babel-utils\");\nvar effect_default = {\n  migrate: [\n    (tag) => {\n      (0, import_babel_utils28.assertNoArgs)(tag);\n      (0, import_babel_utils28.assertNoParams)(tag);\n      assertNoBodyContent(tag);\n      (0, import_babel_utils28.assertNoAttributeTags)(tag);\n      assertNoSpreadAttrs(tag);\n      (0, import_babel_utils28.assertAllowedAttributes)(tag, [\"value\"]);\n      (0, import_babel_utils28.diagnosticDeprecate)(tag, {\n        label: \"The 'effect' tag has been replaced by the 'script' tag.\",\n        fix() {\n          const { node } = tag;\n          tag.replaceWith(\n            import_compiler36.types.markoTag(\n              withPreviousLocation(import_compiler36.types.stringLiteral(\"script\"), node.name),\n              node.attributes,\n              node.body,\n              node.arguments,\n              node.var,\n              node.attributeTags\n            )\n          );\n        }\n      });\n    }\n  ],\n  attributes: {},\n  types: runtime_info_default.name + \"/tag-types/effect.d.marko\"\n};\n\n// src/translator/core/export.ts\nvar import_babel_utils29 = require(\"@marko/compiler/babel-utils\");\nvar export_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils29.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"export <value>\"\n    }\n  ]\n};\n\n// src/translator/core/html-comment.ts\nvar import_compiler37 = require(\"@marko/compiler\");\nvar import_babel_utils30 = require(\"@marko/compiler/babel-utils\");\nvar kNodeBinding = Symbol(\"comment tag binding\");\nvar kGetterId2 = Symbol(\"node getter id\");\nvar html_comment_default = {\n  analyze(tag) {\n    (0, import_babel_utils30.assertNoArgs)(tag);\n    (0, import_babel_utils30.assertNoParams)(tag);\n    (0, import_babel_utils30.assertNoAttributes)(tag);\n    const tagVar = tag.node.var;\n    let needsBinding = false;\n    let needsGetter = false;\n    if (tagVar) {\n      if (!import_compiler37.types.isIdentifier(tagVar)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"The `html-comment` tag variable cannot be destructured.\"\n        );\n      }\n      needsBinding = true;\n      for (const ref of tag.scope.getBinding(tagVar.name).referencePaths) {\n        if (!isInvokedFunction(ref)) {\n          needsGetter = true;\n          break;\n        }\n      }\n    }\n    const referenceNodes = [];\n    for (const child of tag.get(\"body\").get(\"body\")) {\n      if (child.isMarkoPlaceholder()) {\n        referenceNodes.push(child.node.value);\n        needsBinding = true;\n      } else if (!child.isMarkoText()) {\n        throw child.buildCodeFrameError(\n          \"Invalid child. Only text is allowed inside an html comment.\"\n        );\n      }\n    }\n    if (needsBinding) {\n      const tagSection = getOrCreateSection(tag);\n      const tagExtra = mergeReferences(tagSection, tag.node, referenceNodes);\n      const nodeBinding = tagExtra[kNodeBinding] = createBinding(\n        \"#comment\",\n        0 /* dom */,\n        tagSection\n      );\n      if (needsGetter) {\n        tagExtra[kGetterId2] = getRegisterUID(tagSection, \"comment\");\n      }\n      if (tagVar) {\n        forceBindingSerialize(tagSection, nodeBinding);\n      } else {\n        addBindingSerializeReasonExpr(tagSection, nodeBinding, tagExtra);\n      }\n    }\n    tag.skip();\n  },\n  translate: {\n    enter(tag) {\n      const tagExtra = tag.node.extra;\n      const nodeBinding = tagExtra[kNodeBinding];\n      const hasVar = !!tag.node.var;\n      if (hasVar) {\n        const getterId = tagExtra[kGetterId2];\n        if (isOutputHTML()) {\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(getSection(tag)),\n              getterId && import_compiler37.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);\n            (0, import_babel_utils30.getProgram)().node.body.push(\n              import_compiler37.types.variableDeclaration(\"const\", [\n                import_compiler37.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler37.types.stringLiteral(getterId),\n                    getScopeAccessorLiteral(nodeBinding)\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (isInvokedFunction(reference)) {\n              reference.parentPath.replaceWith(\n                import_compiler37.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, nodeBinding)\n                )\n              );\n            } else if (getterFnIdentifier) {\n              reference.replaceWith(\n                import_compiler37.types.callExpression(getterFnIdentifier, [\n                  getScopeExpression(referenceSection, getSection(tag))\n                ])\n              );\n            }\n          }\n        }\n      }\n      if (nodeBinding) {\n        visit(tag, 32 /* Get */);\n      }\n      enter2(tag);\n      writeTo(tag)`<!--`;\n    },\n    exit(tag) {\n      const tagSection = getSection(tag);\n      const tagExtra = tag.node.extra;\n      const nodeBinding = tagExtra[kNodeBinding];\n      const write2 = writeTo(tag);\n      if (isOutputHTML()) {\n        for (const child of tag.node.body.body) {\n          if (import_compiler37.types.isMarkoText(child)) {\n            write2`${child.value}`;\n          } else if (import_compiler37.types.isMarkoPlaceholder(child)) {\n            write2`${callRuntime(\"escapeXML\", child.value)}`;\n          }\n        }\n      } else {\n        const templateQuasis = [];\n        const templateExpressions = [];\n        let currentQuasi = \"\";\n        for (const child of tag.node.body.body) {\n          if (import_compiler37.types.isMarkoText(child)) {\n            currentQuasi += child.value;\n          } else if (import_compiler37.types.isMarkoPlaceholder(child)) {\n            templateQuasis.push(import_compiler37.types.templateElement({ raw: currentQuasi }));\n            templateExpressions.push(child.value);\n            currentQuasi = \"\";\n          }\n        }\n        if (templateExpressions.length === 0) {\n          write2`${currentQuasi}`;\n        } else {\n          templateQuasis.push(import_compiler37.types.templateElement({ raw: currentQuasi }));\n          addStatement(\n            \"render\",\n            getSection(tag),\n            tagExtra.referencedBindings,\n            import_compiler37.types.expressionStatement(\n              callRuntime(\n                \"data\",\n                import_compiler37.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(nodeBinding),\n                  true\n                ),\n                import_compiler37.types.templateLiteral(templateQuasis, templateExpressions)\n              )\n            )\n          );\n        }\n      }\n      exit2(tag);\n      write2`-->`;\n      if (nodeBinding) {\n        markNode(\n          tag,\n          nodeBinding,\n          getBindingSerializeReason(tagSection, nodeBinding)\n        );\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    text: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an html comment that is not stripped from the output.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#html-comment\"\n    }\n  ]\n};\n\n// src/translator/core/html-script.ts\nvar import_compiler38 = require(\"@marko/compiler\");\nvar import_babel_utils31 = require(\"@marko/compiler/babel-utils\");\nvar kNodeBinding2 = Symbol(\"script tag node binding\");\nvar kGetterId3 = Symbol(\"node getter id\");\nvar html_script_default = {\n  analyze(tag) {\n    (0, import_babel_utils31.assertNoArgs)(tag);\n    (0, import_babel_utils31.assertNoParams)(tag);\n    const { node } = tag;\n    if (node.var && !import_compiler38.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\n        \"Tag variables on native elements cannot be destructured.\"\n      );\n    }\n    const seen = {};\n    const { attributes } = tag.node;\n    let spreadReferenceNodes;\n    let attrExprExtras;\n    let hasEventHandlers = false;\n    let hasDynamicAttributes = false;\n    for (let i = attributes.length; i--; ) {\n      const attr2 = attributes[i];\n      const valueExtra = attr2.value.extra ??= {};\n      if (import_compiler38.types.isMarkoAttribute(attr2)) {\n        if (seen[attr2.name]) {\n          dropReferences(attr2.value);\n          continue;\n        }\n        seen[attr2.name] = attr2;\n        if (isEventHandler(attr2.name)) {\n          valueExtra.isEffect = true;\n          hasEventHandlers = true;\n        } else if (!evaluate(attr2.value).confident) {\n          hasDynamicAttributes = true;\n        }\n      } else if (import_compiler38.types.isMarkoSpreadAttribute(attr2)) {\n        valueExtra.isEffect = true;\n        hasEventHandlers = true;\n        hasDynamicAttributes = true;\n      }\n      if (spreadReferenceNodes) {\n        spreadReferenceNodes.push(attr2.value);\n      } else if (import_compiler38.types.isMarkoSpreadAttribute(attr2)) {\n        spreadReferenceNodes = [attr2.value];\n      } else {\n        attrExprExtras = push(attrExprExtras, valueExtra);\n      }\n    }\n    const bodyPlaceholderNodes = [];\n    let hasBodyPlaceholders = false;\n    for (const child of tag.node.body.body) {\n      if (import_compiler38.types.isMarkoPlaceholder(child)) {\n        bodyPlaceholderNodes.push(child.value);\n        hasBodyPlaceholders = true;\n      } else if (!import_compiler38.types.isMarkoText(child)) {\n        throw tag.hub.buildError(\n          child,\n          \"Invalid child. Only text is allowed inside an html-script.\"\n        );\n      }\n    }\n    if (node.var || hasEventHandlers || hasDynamicAttributes || hasBodyPlaceholders) {\n      const tagExtra = node.extra ??= {};\n      const tagSection = getOrCreateSection(tag);\n      const nodeBinding = tagExtra[kNodeBinding2] = createBinding(\n        \"#script\",\n        0 /* dom */,\n        tagSection\n      );\n      (0, import_babel_utils31.getProgram)().node.extra.isInteractive ||= hasEventHandlers;\n      if (spreadReferenceNodes) {\n        mergeReferences(tagSection, tag.node, spreadReferenceNodes);\n      }\n      if (bodyPlaceholderNodes.length > 1) {\n        mergeReferences(\n          tagSection,\n          bodyPlaceholderNodes[0],\n          bodyPlaceholderNodes.slice(1)\n        );\n      }\n      if (hasEventHandlers || spreadReferenceNodes) {\n        forceBindingSerialize(tagSection, nodeBinding);\n      }\n      if (node.var) {\n        forceBindingSerialize(tagSection, nodeBinding);\n        for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n          const refSection = getOrCreateSection(ref);\n          setReferencesScope(ref);\n          if (isSameOrChildSection(tagSection, refSection)) {\n            forceOwnersSerialize(\n              refSection,\n              tagSection,\n              getAccessorProp().Owner\n            );\n            if (!tagExtra[kGetterId3] && !isInvokedFunction(ref)) {\n              tagExtra[kGetterId3] = getRegisterUID(tagSection, \"#script\");\n            }\n          } else {\n            trackHoistedReference(ref, nodeBinding);\n          }\n        }\n      }\n      addBindingSerializeReasonExpr(\n        tagSection,\n        nodeBinding,\n        push(attrExprExtras, tagExtra)\n      );\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagExtra = tag.node.extra;\n      const nodeBinding = tagExtra[kNodeBinding2];\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(tag);\n      const tagSection = getSection(tag);\n      const hasVar = !!tag.node.var;\n      if (hasVar) {\n        const getterId = tagExtra[kGetterId3];\n        if (isHTML) {\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(tagSection),\n              getterId && import_compiler38.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);\n            (0, import_babel_utils31.getProgram)().node.body.push(\n              import_compiler38.types.variableDeclaration(\"const\", [\n                import_compiler38.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler38.types.stringLiteral(getterId),\n                    getScopeAccessorLiteral(nodeBinding)\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (isInvokedFunction(reference)) {\n              reference.parentPath.replaceWith(\n                import_compiler38.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, nodeBinding)\n                )\n              );\n            } else if (getterFnIdentifier) {\n              reference.replaceWith(\n                import_compiler38.types.callExpression(getterFnIdentifier, [\n                  getScopeExpression(referenceSection, getSection(tag))\n                ])\n              );\n            }\n          }\n        }\n      }\n      const visitAccessor = nodeBinding && getScopeAccessorLiteral(nodeBinding);\n      if (visitAccessor) {\n        visit(tag, 32 /* Get */);\n      }\n      write2`<script`;\n      const usedAttrs = getUsedAttrs2(tag.node);\n      const { staticAttrs, skipExpression, spreadExpression } = usedAttrs;\n      for (const attr2 of staticAttrs) {\n        const { name: name2, value } = attr2;\n        const { confident, computed } = value.extra || {};\n        const valueReferences = value.extra?.referencedBindings;\n        switch (name2) {\n          case \"class\":\n          case \"style\": {\n            const helper = `${name2}Attr`;\n            if (confident) {\n              write2`${getHTMLRuntime()[helper](computed)}`;\n            } else if (isHTML) {\n              write2`${callRuntime(helper, value)}`;\n            } else {\n              addStatement(\n                \"render\",\n                tagSection,\n                valueReferences,\n                import_compiler38.types.expressionStatement(\n                  callRuntime(\n                    helper,\n                    import_compiler38.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n          }\n          default:\n            if (confident) {\n              write2`${getHTMLRuntime().attr(name2, computed)}`;\n            } else if (isHTML) {\n              if (isEventHandler(name2)) {\n                addHTMLEffectCall(tagSection, valueReferences);\n              } else {\n                write2`${callRuntime(\"attr\", import_compiler38.types.stringLiteral(name2), value)}`;\n              }\n            } else if (isEventHandler(name2)) {\n              addStatement(\n                \"effect\",\n                tagSection,\n                valueReferences,\n                import_compiler38.types.expressionStatement(\n                  callRuntime(\n                    \"on\",\n                    import_compiler38.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler38.types.stringLiteral(getEventHandlerName(name2)),\n                    value\n                  )\n                )\n              );\n            } else {\n              addStatement(\n                \"render\",\n                tagSection,\n                valueReferences,\n                import_compiler38.types.expressionStatement(\n                  callRuntime(\n                    \"attr\",\n                    import_compiler38.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler38.types.stringLiteral(name2),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n        }\n      }\n      if (spreadExpression) {\n        if (isHTML) {\n          addHTMLEffectCall(tagSection, tagExtra.referencedBindings);\n          if (skipExpression) {\n            write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(tagSection), import_compiler38.types.stringLiteral(\"script\"))}`;\n          } else {\n            write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(tagSection), import_compiler38.types.stringLiteral(\"script\"))}`;\n          }\n        } else {\n          if (skipExpression) {\n            addStatement(\n              \"render\",\n              tagSection,\n              tagExtra.referencedBindings,\n              import_compiler38.types.expressionStatement(\n                callRuntime(\n                  \"partialAttrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression,\n                  skipExpression\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              tagSection,\n              tagExtra.referencedBindings,\n              import_compiler38.types.expressionStatement(\n                callRuntime(\n                  \"attrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression\n                )\n              )\n            );\n          }\n          addStatement(\n            \"effect\",\n            tagSection,\n            tagExtra.referencedBindings,\n            import_compiler38.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            false\n          );\n        }\n      }\n      write2`>`;\n      enter2(tag);\n    },\n    exit(tag) {\n      const tagSection = getSection(tag);\n      const tagExtra = tag.node.extra;\n      const nodeBinding = tagExtra[kNodeBinding2];\n      const write2 = writeTo(tag);\n      const visitAccessor = getScopeAccessorLiteral(nodeBinding);\n      if (isOutputHTML()) {\n        for (const child of tag.node.body.body) {\n          if (import_compiler38.types.isMarkoText(child)) {\n            write2`${child.value}`;\n          } else if (import_compiler38.types.isMarkoPlaceholder(child)) {\n            write2`${callRuntime(\"escapeScript\", child.value)}`;\n          }\n        }\n      } else {\n        const templateQuasis = [];\n        const templateExpressions = [];\n        let currentQuasi = \"\";\n        let referencePlaceholder;\n        for (const child of tag.node.body.body) {\n          if (import_compiler38.types.isMarkoText(child)) {\n            currentQuasi += child.value;\n          } else if (import_compiler38.types.isMarkoPlaceholder(child)) {\n            referencePlaceholder ||= child;\n            templateQuasis.push(import_compiler38.types.templateElement({ raw: currentQuasi }));\n            templateExpressions.push(child.value);\n            currentQuasi = \"\";\n          }\n        }\n        if (!referencePlaceholder) {\n          write2`${currentQuasi}`;\n        } else {\n          templateQuasis.push(import_compiler38.types.templateElement({ raw: currentQuasi }));\n          addStatement(\n            \"render\",\n            getSection(tag),\n            referencePlaceholder.value.extra?.referencedBindings,\n            import_compiler38.types.expressionStatement(\n              callRuntime(\n                \"textContent\",\n                import_compiler38.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                import_compiler38.types.templateLiteral(templateQuasis, templateExpressions)\n              )\n            )\n          );\n        }\n      }\n      write2`</script>`;\n      if (nodeBinding) {\n        markNode(\n          tag,\n          nodeBinding,\n          getBindingSerializeReason(tagSection, nodeBinding)\n        );\n      }\n      exit2(tag);\n      tag.remove();\n    }\n  },\n  \"@async\": \"#html-async\",\n  \"@crossorigin\": \"#html-crossorigin\",\n  \"@defer\": \"#html-defer\",\n  \"@integrity\": \"#html-integrity\",\n  \"@nomodule\": \"#html-nomodule\",\n  \"@nonce\": \"#html-nonce\",\n  \"@referrerpolicy\": \"#html-referrerpolicy\",\n  \"@src\": \"#html-src\",\n  \"@type\": \"#html-type\",\n  \"attribute-groups\": [\"html-attributes\"],\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  }\n};\nfunction getUsedAttrs2(tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler38.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n      }\n      spreadProps.push(import_compiler38.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler38.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler38.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    spreadExpression,\n    skipExpression\n  };\n}\n\n// src/translator/core/html-style.ts\nvar import_compiler39 = require(\"@marko/compiler\");\nvar import_babel_utils32 = require(\"@marko/compiler/babel-utils\");\nvar kNodeBinding3 = Symbol(\"style tag node binding\");\nvar kGetterId4 = Symbol(\"node getter id\");\nvar html_style_default = {\n  analyze(tag) {\n    (0, import_babel_utils32.assertNoArgs)(tag);\n    (0, import_babel_utils32.assertNoParams)(tag);\n    const { node } = tag;\n    if (node.var && !import_compiler39.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\n        \"Tag variables on native elements cannot be destructured.\"\n      );\n    }\n    const seen = {};\n    const { attributes } = tag.node;\n    let spreadReferenceNodes;\n    let attrExprExtras;\n    let hasEventHandlers = false;\n    let hasDynamicAttributes = false;\n    for (let i = attributes.length; i--; ) {\n      const attr2 = attributes[i];\n      const valueExtra = attr2.value.extra ??= {};\n      if (import_compiler39.types.isMarkoAttribute(attr2)) {\n        if (seen[attr2.name]) {\n          dropReferences(attr2.value);\n          continue;\n        }\n        seen[attr2.name] = attr2;\n        if (isEventHandler(attr2.name)) {\n          valueExtra.isEffect = true;\n          hasEventHandlers = true;\n        } else if (!evaluate(attr2.value).confident) {\n          hasDynamicAttributes = true;\n        }\n      } else if (import_compiler39.types.isMarkoSpreadAttribute(attr2)) {\n        valueExtra.isEffect = true;\n        hasEventHandlers = true;\n        hasDynamicAttributes = true;\n      }\n      if (spreadReferenceNodes) {\n        spreadReferenceNodes.push(attr2.value);\n      } else if (import_compiler39.types.isMarkoSpreadAttribute(attr2)) {\n        spreadReferenceNodes = [attr2.value];\n      } else {\n        attrExprExtras = push(attrExprExtras, valueExtra);\n      }\n    }\n    const bodyPlaceholderNodes = [];\n    let hasBodyPlaceholders = false;\n    for (const child of tag.node.body.body) {\n      if (import_compiler39.types.isMarkoPlaceholder(child)) {\n        bodyPlaceholderNodes.push(child.value);\n        hasBodyPlaceholders = true;\n      } else if (!import_compiler39.types.isMarkoText(child)) {\n        throw tag.hub.buildError(\n          child,\n          \"Invalid child. Only text is allowed inside an html-style.\"\n        );\n      }\n    }\n    if (node.var || hasEventHandlers || hasDynamicAttributes || hasBodyPlaceholders) {\n      const tagExtra = node.extra ??= {};\n      const tagSection = getOrCreateSection(tag);\n      const nodeBinding = tagExtra[kNodeBinding3] = createBinding(\n        \"#style\",\n        0 /* dom */,\n        tagSection\n      );\n      (0, import_babel_utils32.getProgram)().node.extra.isInteractive ||= hasEventHandlers;\n      if (spreadReferenceNodes) {\n        mergeReferences(tagSection, tag.node, spreadReferenceNodes);\n      }\n      if (bodyPlaceholderNodes.length > 1) {\n        mergeReferences(\n          tagSection,\n          bodyPlaceholderNodes[0],\n          bodyPlaceholderNodes.slice(1)\n        );\n      }\n      if (hasEventHandlers || spreadReferenceNodes) {\n        forceBindingSerialize(tagSection, nodeBinding);\n      }\n      if (node.var) {\n        forceBindingSerialize(tagSection, nodeBinding);\n        for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n          const refSection = getOrCreateSection(ref);\n          setReferencesScope(ref);\n          if (isSameOrChildSection(tagSection, refSection)) {\n            forceOwnersSerialize(\n              refSection,\n              tagSection,\n              getAccessorProp().Owner\n            );\n            if (!tagExtra[kGetterId4] && !isInvokedFunction(ref)) {\n              tagExtra[kGetterId4] = getRegisterUID(tagSection, \"#style\");\n            }\n          } else {\n            trackHoistedReference(ref, nodeBinding);\n          }\n        }\n      }\n      addBindingSerializeReasonExpr(\n        tagSection,\n        nodeBinding,\n        push(attrExprExtras, tagExtra)\n      );\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagExtra = tag.node.extra;\n      const nodeBinding = tagExtra[kNodeBinding3];\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(tag);\n      const tagSection = getSection(tag);\n      const hasVar = !!tag.node.var;\n      if (hasVar) {\n        const getterId = tagExtra[kGetterId4];\n        if (isHTML) {\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(tagSection),\n              getterId && import_compiler39.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);\n            (0, import_babel_utils32.getProgram)().node.body.push(\n              import_compiler39.types.variableDeclaration(\"const\", [\n                import_compiler39.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler39.types.stringLiteral(getterId),\n                    getScopeAccessorLiteral(nodeBinding)\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (isInvokedFunction(reference)) {\n              reference.parentPath.replaceWith(\n                import_compiler39.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, nodeBinding)\n                )\n              );\n            } else if (getterFnIdentifier) {\n              reference.replaceWith(\n                import_compiler39.types.callExpression(getterFnIdentifier, [\n                  getScopeExpression(referenceSection, getSection(tag))\n                ])\n              );\n            }\n          }\n        }\n      }\n      const visitAccessor = nodeBinding && getScopeAccessorLiteral(nodeBinding);\n      if (visitAccessor) {\n        visit(tag, 32 /* Get */);\n      }\n      write2`<style`;\n      const usedAttrs = getUsedAttrs3(tag.node);\n      const { staticAttrs, skipExpression, spreadExpression } = usedAttrs;\n      for (const attr2 of staticAttrs) {\n        const { name: name2, value } = attr2;\n        const { confident, computed } = value.extra || {};\n        const valueReferences = value.extra?.referencedBindings;\n        switch (name2) {\n          case \"class\":\n          case \"style\": {\n            const helper = `${name2}Attr`;\n            if (confident) {\n              write2`${getHTMLRuntime()[helper](computed)}`;\n            } else if (isHTML) {\n              write2`${callRuntime(helper, value)}`;\n            } else {\n              addStatement(\n                \"render\",\n                tagSection,\n                valueReferences,\n                import_compiler39.types.expressionStatement(\n                  callRuntime(\n                    helper,\n                    import_compiler39.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n          }\n          default:\n            if (confident) {\n              write2`${getHTMLRuntime().attr(name2, computed)}`;\n            } else if (isHTML) {\n              if (isEventHandler(name2)) {\n                addHTMLEffectCall(tagSection, valueReferences);\n              } else {\n                write2`${callRuntime(\"attr\", import_compiler39.types.stringLiteral(name2), value)}`;\n              }\n            } else if (isEventHandler(name2)) {\n              addStatement(\n                \"effect\",\n                tagSection,\n                valueReferences,\n                import_compiler39.types.expressionStatement(\n                  callRuntime(\n                    \"on\",\n                    import_compiler39.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler39.types.stringLiteral(getEventHandlerName(name2)),\n                    value\n                  )\n                )\n              );\n            } else {\n              addStatement(\n                \"render\",\n                tagSection,\n                valueReferences,\n                import_compiler39.types.expressionStatement(\n                  callRuntime(\n                    \"attr\",\n                    import_compiler39.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler39.types.stringLiteral(name2),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n        }\n      }\n      if (spreadExpression) {\n        if (isHTML) {\n          addHTMLEffectCall(tagSection, tagExtra.referencedBindings);\n          if (skipExpression) {\n            write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(tagSection), import_compiler39.types.stringLiteral(\"style\"))}`;\n          } else {\n            write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(tagSection), import_compiler39.types.stringLiteral(\"style\"))}`;\n          }\n        } else {\n          if (skipExpression) {\n            addStatement(\n              \"render\",\n              tagSection,\n              tagExtra.referencedBindings,\n              import_compiler39.types.expressionStatement(\n                callRuntime(\n                  \"partialAttrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression,\n                  skipExpression\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              tagSection,\n              tagExtra.referencedBindings,\n              import_compiler39.types.expressionStatement(\n                callRuntime(\n                  \"attrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression\n                )\n              )\n            );\n          }\n          addStatement(\n            \"effect\",\n            tagSection,\n            tagExtra.referencedBindings,\n            import_compiler39.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            false\n          );\n        }\n      }\n      write2`>`;\n      enter2(tag);\n    },\n    exit(tag) {\n      const tagSection = getSection(tag);\n      const tagExtra = tag.node.extra;\n      const nodeBinding = tagExtra[kNodeBinding3];\n      const write2 = writeTo(tag);\n      const visitAccessor = getScopeAccessorLiteral(nodeBinding);\n      if (isOutputHTML()) {\n        for (const child of tag.node.body.body) {\n          if (import_compiler39.types.isMarkoText(child)) {\n            write2`${child.value}`;\n          } else if (import_compiler39.types.isMarkoPlaceholder(child)) {\n            write2`${callRuntime(\"escapeStyle\", child.value)}`;\n          }\n        }\n      } else {\n        const templateQuasis = [];\n        const templateExpressions = [];\n        let currentQuasi = \"\";\n        let referencePlaceholder;\n        for (const child of tag.node.body.body) {\n          if (import_compiler39.types.isMarkoText(child)) {\n            currentQuasi += child.value;\n          } else if (import_compiler39.types.isMarkoPlaceholder(child)) {\n            referencePlaceholder ||= child;\n            templateQuasis.push(import_compiler39.types.templateElement({ raw: currentQuasi }));\n            templateExpressions.push(child.value);\n            currentQuasi = \"\";\n          }\n        }\n        if (!referencePlaceholder) {\n          write2`${currentQuasi}`;\n        } else {\n          templateQuasis.push(import_compiler39.types.templateElement({ raw: currentQuasi }));\n          addStatement(\n            \"render\",\n            getSection(tag),\n            referencePlaceholder.value.extra?.referencedBindings,\n            import_compiler39.types.expressionStatement(\n              callRuntime(\n                \"textContent\",\n                import_compiler39.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                import_compiler39.types.templateLiteral(templateQuasis, templateExpressions)\n              )\n            )\n          );\n        }\n      }\n      write2`</style>`;\n      if (nodeBinding) {\n        markNode(\n          tag,\n          nodeBinding,\n          getBindingSerializeReason(tagSection, nodeBinding)\n        );\n      }\n      exit2(tag);\n      tag.remove();\n    }\n  },\n  \"@disabled\": \"#html-disabled\",\n  \"@media\": \"#html-media\",\n  \"@nonce\": \"#html-nonce\",\n  \"@type\": \"#html-type\",\n  \"attribute-groups\": [\"html-attributes\"],\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  }\n};\nfunction getUsedAttrs3(tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler39.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n      }\n      spreadProps.push(import_compiler39.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler39.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler39.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    spreadExpression,\n    skipExpression\n  };\n}\n\n// src/translator/core/id.ts\nvar import_compiler40 = require(\"@marko/compiler\");\nvar import_babel_utils33 = require(\"@marko/compiler/babel-utils\");\nvar id_default = {\n  analyze(tag) {\n    (0, import_babel_utils33.assertNoArgs)(tag);\n    (0, import_babel_utils33.assertNoParams)(tag);\n    (0, import_babel_utils33.assertNoAttributes)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils33.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `id` tag requires a tag variable.\");\n    }\n    if (!import_compiler40.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `id` tag cannot be destructured\");\n    }\n    const binding = trackVarReferences(tag, 4 /* derived */);\n    if (binding) {\n      setBindingValueExpr(binding, false);\n    }\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const id = isOutputHTML() ? callRuntime(\"nextTagId\") : callRuntime(\"nextTagId\", scopeIdentifier);\n      if (isOutputHTML()) {\n        tag.replaceWith(\n          import_compiler40.types.variableDeclaration(\"const\", [import_compiler40.types.variableDeclarator(node.var, id)])\n        );\n      } else {\n        const source = initValue(node.var.extra.binding);\n        addValue(getSection(tag), void 0, source, id);\n        tag.remove();\n      }\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"id/<name>\",\n      description: \"Use to create a unique identifier.\",\n      snippet: \"id/${1:name}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#id\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/id.d.marko\"\n};\n\n// src/translator/core/if.ts\nvar import_compiler42 = require(\"@marko/compiler\");\nvar import_babel_utils34 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/to-first-statement-or-block.ts\nvar import_compiler41 = require(\"@marko/compiler\");\nfunction toFirstStatementOrBlock(body) {\n  if (Array.isArray(body)) {\n    if (body.length === 1) {\n      return body[0];\n    }\n    return import_compiler41.types.blockStatement(body);\n  }\n  return body;\n}\n\n// src/translator/core/if.ts\nvar BRANCHES_LOOKUP = /* @__PURE__ */ new WeakMap();\nvar IfTag = {\n  analyze(tag) {\n    assertValidCondition(tag);\n    if (tag.node.body.attributeTags) return;\n    if (isLastBranch(tag)) {\n      const branches = getBranches(tag);\n      const [ifTag] = branches[0];\n      const ifTagSection = getOrCreateSection(ifTag);\n      const ifTagExtra = ifTag.node.extra ??= {};\n      const mergeReferenceNodes = [];\n      const nodeBinding = getOptimizedOnlyChildNodeBinding(\n        ifTag,\n        ifTagSection,\n        branches.length\n      );\n      const sectionAccessor = {\n        binding: nodeBinding,\n        prefix: getAccessorPrefix().ConditionalScope\n      };\n      let singleNodeOptimization = true;\n      for (const [branchTag, branchBodySection] of branches) {\n        if (branchBodySection) {\n          singleNodeOptimization &&= branchBodySection.content === null || branchBodySection.content?.singleChild && branchBodySection.content.startType !== 4 /* Text */;\n          branchBodySection.isBranch = true;\n          branchBodySection.upstreamExpression = ifTagExtra;\n          branchBodySection.sectionAccessor = sectionAccessor;\n        }\n        if (branchTag.node.attributes.length) {\n          mergeReferenceNodes.push(branchTag.node.attributes[0].value);\n        }\n      }\n      mergeReferences(ifTagSection, ifTag.node, mergeReferenceNodes);\n      ifTagExtra.singleNodeOptimization = singleNodeOptimization;\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (isRoot(tag) && !isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n        flushBefore(tag);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (bodySection) {\n          flushInto(tag);\n          writeHTMLResumeStatements(tagBody);\n        }\n        if (isLastBranch(tag)) {\n          const branches = getBranches(tag);\n          const [ifTag] = branches[0];\n          const ifTagSection = getSection(ifTag);\n          const ifTagExtra = ifTag.node.extra;\n          const singleNodeOptimization = ifTagExtra.singleNodeOptimization;\n          const nodeBinding = getOptimizedOnlyChildNodeBinding(\n            ifTag,\n            ifTagSection\n          );\n          const onlyChildInParentOptimization = isOnlyChildInParent(ifTag);\n          const markerSerializeReason = getBindingSerializeReason(\n            ifTagSection,\n            nodeBinding\n          );\n          const nextTag = tag.getNextSibling();\n          let branchSerializeReasons;\n          let statement;\n          for (let i = branches.length; i--; ) {\n            const [branchTag, branchBody] = branches[i];\n            const bodyStatements = branchTag.node.body.body;\n            if (branchBody) {\n              const branchSerializeReason = getSectionSerializeReason(\n                branchBody,\n                kBranchSerializeReason\n              );\n              if (branchSerializeReason) {\n                if (branchSerializeReasons !== true) {\n                  if (branchSerializeReason === true) {\n                    branchSerializeReasons = true;\n                  } else if (branchSerializeReasons) {\n                    branchSerializeReasons = addSorted(\n                      compareSerializeReasons,\n                      branchSerializeReasons,\n                      branchSerializeReason\n                    );\n                  } else {\n                    branchSerializeReasons = [branchSerializeReason];\n                  }\n                }\n                bodyStatements.push(\n                  import_compiler42.types.returnStatement(import_compiler42.types.numericLiteral(i))\n                );\n              }\n            }\n            const [testAttr] = branchTag.node.attributes;\n            const curStatement = toFirstStatementOrBlock(bodyStatements);\n            if (testAttr) {\n              statement = import_compiler42.types.ifStatement(\n                testAttr.value,\n                curStatement,\n                statement\n              );\n            } else {\n              statement = curStatement;\n            }\n            branchTag.remove();\n          }\n          if (branchSerializeReasons) {\n            if (onlyChildInParentOptimization && markerSerializeReason) {\n              getParentTag(ifTag).node.extra[kSkipMark] = true;\n            }\n            const cbNode = import_compiler42.types.arrowFunctionExpression(\n              [],\n              import_compiler42.types.blockStatement([statement])\n            );\n            statement = import_compiler42.types.expressionStatement(\n              singleNodeOptimization ? callRuntime(\n                \"resumeSingleNodeConditional\",\n                cbNode,\n                getScopeIdIdentifier(ifTagSection),\n                getScopeAccessorLiteral(nodeBinding),\n                branchSerializeReasons === true ? markerSerializeReason === true && !onlyChildInParentOptimization ? void 0 : import_compiler42.types.numericLiteral(1) : getSerializeGuardForAny(branchSerializeReasons),\n                !markerSerializeReason ? import_compiler42.types.numericLiteral(0) : markerSerializeReason === true ? onlyChildInParentOptimization ? import_compiler42.types.numericLiteral(1) : void 0 : getSerializeGuard(markerSerializeReason),\n                onlyChildInParentOptimization && import_compiler42.types.numericLiteral(1)\n              ) : callRuntime(\n                \"resumeConditional\",\n                cbNode,\n                getScopeIdIdentifier(ifTagSection),\n                getScopeAccessorLiteral(nodeBinding),\n                branchSerializeReasons === true ? markerSerializeReason === true ? void 0 : import_compiler42.types.numericLiteral(1) : getSerializeGuardForAny(branchSerializeReasons),\n                !markerSerializeReason ? import_compiler42.types.numericLiteral(0) : markerSerializeReason === true ? void 0 : getSerializeGuard(markerSerializeReason)\n              )\n            );\n          }\n          nextTag.insertBefore(statement);\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n        }\n        if (isRoot(tag) && !isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        if (isLastBranch(tag)) {\n          const branches = getBranches(tag);\n          const [ifTag] = branches[0];\n          const ifTagSection = getSection(ifTag);\n          const ifTagExtra = branches[0][0].node.extra;\n          const nodeRef2 = getOptimizedOnlyChildNodeBinding(ifTag, ifTagSection);\n          const rendererIdentifiers = [];\n          let expr = import_compiler42.types.numericLiteral(branches.length);\n          for (let i = branches.length; i--; ) {\n            const [branchTag, branchBodySection] = branches[i];\n            const [testAttr] = branchTag.node.attributes;\n            const consequent = import_compiler42.types.numericLiteral(branchBodySection ? i : -1);\n            if (branchBodySection) {\n              rendererIdentifiers.push(import_compiler42.types.identifier(branchBodySection.name));\n              setClosureSignalBuilder(branchTag, (closure, render) => {\n                return callRuntime(\n                  \"conditionalClosure\",\n                  getScopeAccessorLiteral(closure),\n                  getScopeAccessorLiteral(nodeRef2),\n                  import_compiler42.types.numericLiteral(i),\n                  render\n                );\n              });\n            }\n            branchTag.remove();\n            expr = testAttr ? import_compiler42.types.conditionalExpression(testAttr.value, consequent, expr) : consequent;\n          }\n          const signal = getSignal(ifTagSection, nodeRef2, \"if\");\n          signal.build = () => {\n            return callRuntime(\n              \"conditional\",\n              getScopeAccessorLiteral(nodeRef2),\n              ...rendererIdentifiers.reverse()\n            );\n          };\n          addValue(ifTagSection, ifTagExtra.referencedBindings, signal, expr);\n        }\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  autocomplete: [\n    {\n      snippet: \"if=${1:condition}\",\n      description: \"Use to display content only if the condition is met.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseIfTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      snippet: \"else-if=${1:condition}\",\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nfunction assertValidCondition(tag) {\n  (0, import_babel_utils34.assertNoVar)(tag);\n  (0, import_babel_utils34.assertNoArgs)(tag);\n  (0, import_babel_utils34.assertNoParams)(tag);\n  assertHasBody(tag);\n  assertNoSpreadAttrs(tag);\n  switch (getTagName(tag)) {\n    case \"if\":\n      assertHasValueAttribute(tag);\n      break;\n    case \"else-if\":\n      assertHasValueAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n    case \"else\":\n      assertOptionalIfAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n  }\n}\nfunction assertHasPrecedingCondition(tag) {\n  let prev = tag.getPrevSibling();\n  while (prev.node && prev.isMarkoComment()) prev = prev.getPrevSibling();\n  if (!isConditionTag(prev) || getTagName(prev) !== \"else\" && !prev.node.attributes.length) {\n    throw tag.buildCodeFrameError(\n      `The \\`<${getTagName(tag)}>\\` must have a preceding \\`<if=cond>\\`, \\`<else-if=cond>\\`, or \\`<else if=cond>\\`.`\n    );\n  }\n}\nfunction assertHasBody(tag) {\n  if (!(tag.node.body.body.length || tag.node.attributeTags.length)) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${getTagName(tag)}\\` tag requires body content.`\n    );\n  }\n}\nfunction assertHasValueAttribute(tag) {\n  const { node } = tag;\n  const [valueAttr] = node.attributes;\n  if (!import_compiler42.types.isMarkoAttribute(valueAttr) || !valueAttr.default) {\n    throw tag.get(\"name\").buildCodeFrameError(`The \\`${getTagName(tag)}\\` tag requires a value.`);\n  }\n  if (node.attributes.length > 1) {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports the \\`value\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction assertOptionalIfAttribute(tag) {\n  const { node } = tag;\n  const [ifAttr] = node.attributes;\n  if (node.attributes.length > 1 || ifAttr && ifAttr.name !== \"if\") {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports an \\`if=\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction getBranches(tag) {\n  let branches = BRANCHES_LOOKUP.get(tag);\n  if (!branches) {\n    let curTag = tag;\n    branches = [];\n    do {\n      BRANCHES_LOOKUP.set(curTag, branches);\n      branches.push([\n        curTag,\n        startSection(curTag.get(\"body\"))\n      ]);\n      while ((curTag = curTag.getNextSibling()).isMarkoComment()) ;\n    } while (isCoreTagName(curTag, \"else\") || isCoreTagName(curTag, \"else-if\"));\n  }\n  return branches;\n}\nfunction getSerializeGuardForAny(reasons) {\n  let expr = getSerializeGuard(reasons[0]);\n  for (let i = 1; i < reasons.length; i++) {\n    expr = import_compiler42.types.logicalExpression(\"||\", expr, getSerializeGuard(reasons[i]));\n  }\n  return expr;\n}\nfunction isLastBranch(tag) {\n  const branches = getBranches(tag);\n  return branches[branches.length - 1][0] === tag;\n}\nfunction isRoot(tag) {\n  return isCoreTagName(tag, \"if\");\n}\n\n// src/translator/core/import.ts\nvar import_babel_utils35 = require(\"@marko/compiler/babel-utils\");\nvar import_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils35.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: 'import <scope> from \"<path>\"',\n      description: \"Use to import external modules, follows the same syntax as JavaScript imports.\",\n      snippet: 'import ${2} from \"${1:path}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#importing-external-files\"\n    }\n  ]\n};\n\n// src/translator/core/let.ts\nvar import_compiler43 = require(\"@marko/compiler\");\nvar import_babel_utils36 = require(\"@marko/compiler/babel-utils\");\nvar let_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    let valueAttr;\n    let valueChangeAttr;\n    for (const attr2 of node.attributes) {\n      if (import_compiler43.types.isMarkoAttribute(attr2)) {\n        if (attr2.name === \"value\") {\n          valueAttr = attr2;\n        } else if (attr2.name === \"valueChange\") {\n          valueChangeAttr = attr2;\n        } else {\n          const start = attr2.loc?.start;\n          const end = attr2.loc?.end;\n          const msg = \"The `let` tag only supports the `value` attribute and its change handler.\";\n          if (start == null || end == null) {\n            throw tag.get(\"name\").buildCodeFrameError(msg);\n          } else {\n            throw tag.hub.buildError(\n              { loc: { start, end } },\n              msg,\n              Error\n            );\n          }\n        }\n      }\n    }\n    (0, import_babel_utils36.assertNoArgs)(tag);\n    (0, import_babel_utils36.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    if (!tagVar) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `let` tag requires a tag variable.\");\n    }\n    if (!import_compiler43.types.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `let` tag variable cannot be destructured.\");\n    }\n    if (valueChangeAttr && (0, import_babel_utils36.computeNode)(valueChangeAttr.value)) {\n      throw tag.get(\"attributes\").find((attr2) => attr2.node === valueChangeAttr).get(\"value\").buildCodeFrameError(\n        \"The `let` tag `valueChange` attribute must be a function.\"\n      );\n    }\n    const tagSection = getOrCreateSection(tag);\n    const binding = trackVarReferences(tag, 1 /* let */);\n    setBindingValueExpr(\n      binding,\n      mergeReferences(tagSection, tag.node, [\n        valueAttr?.value,\n        valueChangeAttr?.value\n      ])\n    );\n    if (valueChangeAttr) {\n      forceBindingSerialize(\n        tagSection,\n        binding,\n        getAccessorPrefix().TagVariableChange\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const tagVar = node.var;\n      const valueAttr = node.attributes.find(\n        (attr2) => import_compiler43.types.isMarkoAttribute(attr2) && (attr2.default || attr2.name === \"value\")\n      ) ?? import_compiler43.types.markoAttribute(\"value\", import_compiler43.types.identifier(\"undefined\"));\n      const valueChangeAttr = node.attributes.find(\n        (attr2) => import_compiler43.types.isMarkoAttribute(attr2) && attr2.name === \"valueChange\"\n      );\n      const section = getSection(tag);\n      const binding = tagVar.extra.binding;\n      if (isOutputDOM()) {\n        const signal = initValue(binding, \"state\");\n        const referencedBindings = tag.node.extra.referencedBindings;\n        addValue(section, referencedBindings, signal, valueAttr.value);\n        if (valueChangeAttr) {\n          signal.extraArgs = [valueChangeAttr.value];\n        }\n        signal.buildAssignment = (valueSection, value) => {\n          const scope = getScopeExpression(valueSection, signal.section);\n          return import_compiler43.types.callExpression(signal.identifier, [scope, value]);\n        };\n      } else {\n        translateVar(tag, valueAttr.value, \"let\");\n        if (valueChangeAttr) {\n          setBindingSerializedValue(\n            section,\n            binding,\n            valueChangeAttr.value,\n            getAccessorPrefix().TagVariableChange\n          );\n        }\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a mutable binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#let\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/let.d.marko\"\n};\n\n// src/translator/core/lifecycle.ts\nvar import_compiler44 = require(\"@marko/compiler\");\nvar import_babel_utils37 = require(\"@marko/compiler/babel-utils\");\nvar kRef = Symbol(\"lifecycle attrs reference\");\nvar lifecycle_default = {\n  analyze(tag) {\n    (0, import_babel_utils37.assertNoArgs)(tag);\n    (0, import_babel_utils37.assertNoVar)(tag);\n    (0, import_babel_utils37.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const section = getOrCreateSection(tag);\n    const tagExtra = mergeReferences(\n      section,\n      tag.node,\n      getAllTagReferenceNodes(tag.node)\n    );\n    tagExtra[kRef] = createBinding(\n      generateUid(\"lifecycle\"),\n      4 /* derived */,\n      section\n    );\n    if (node.attributes.length === 0) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `lifecycle` tag requires at least one attribute.\"\n      );\n    }\n    for (const attr2 of node.attributes) {\n      if (import_compiler44.types.isMarkoSpreadAttribute(attr2)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The `lifecycle` tag does not support `...spread` attributes.\"\n        );\n      }\n      (attr2.value.extra ??= {}).isEffect = true;\n    }\n    ((0, import_babel_utils37.getProgram)().node.extra ??= {}).isInteractive = true;\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const section = getSection(tag);\n      const tagExtra = node.extra;\n      const { referencedBindings } = tagExtra;\n      const lifecycleAttrsRef = tagExtra[kRef];\n      if (isOutputDOM()) {\n        const translatedAttrs = translateAttrs(tag);\n        translatedAttrs.statements.push(\n          import_compiler44.types.expressionStatement(\n            callRuntime(\n              \"lifecycle\",\n              scopeIdentifier,\n              getScopeAccessorLiteral(lifecycleAttrsRef),\n              propsToExpression(translatedAttrs.properties)\n            )\n          )\n        );\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          translatedAttrs.statements\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/lifecycle.d.marko\"\n};\n\n// src/translator/core/log.ts\nvar import_compiler45 = require(\"@marko/compiler\");\nvar import_babel_utils38 = require(\"@marko/compiler/babel-utils\");\nvar log_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils38.assertNoArgs)(tag);\n    (0, import_babel_utils38.assertNoVar)(tag);\n    (0, import_babel_utils38.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `log` tag requires a value.\");\n    }\n    if (tag.node.attributes.length > 1 || !import_compiler45.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `log` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      const statement = import_compiler45.types.expressionStatement(\n        import_compiler45.types.callExpression(\n          import_compiler45.types.memberExpression(import_compiler45.types.identifier(\"console\"), import_compiler45.types.identifier(\"log\")),\n          [value]\n        )\n      );\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to log a value to the console.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#log\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/log.d.marko\"\n};\n\n// src/translator/core/script.ts\nvar import_compiler46 = require(\"@marko/compiler\");\nvar import_babel_utils39 = require(\"@marko/compiler/babel-utils\");\nvar htmlScriptTagAlternateMsg = \" For a native html `script` tag use the `html-script` core tag instead.\";\nvar script_default = {\n  parse(tag) {\n    const { node } = tag;\n    const { body } = node.body;\n    if (body.length) {\n      let code = \"\";\n      for (const child of body) {\n        if (child.type !== \"MarkoText\") {\n          throw tag.hub.file.hub.buildError(\n            child,\n            \"Unexpected content in `script` tag. Only javascript and typescript is supported.\" + htmlScriptTagAlternateMsg,\n            SyntaxError\n          );\n        }\n        code += child.value;\n      }\n      const start = body[0]?.start;\n      const end = body[body.length - 1]?.end;\n      const bodyStatements = (0, import_babel_utils39.parseStatements)(tag.hub.file, code, start, end);\n      const valueFn = import_compiler46.types.arrowFunctionExpression(\n        [],\n        import_compiler46.types.blockStatement(bodyStatements),\n        traverseContains(bodyStatements, isAwaitExpression)\n      );\n      node.attributes.push(import_compiler46.types.markoAttribute(\"value\", valueFn));\n      node.body.body = [];\n    }\n  },\n  analyze(tag) {\n    const { node } = tag;\n    (0, import_babel_utils39.assertNoArgs)(tag);\n    (0, import_babel_utils39.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils39.assertNoAttributeTags)(tag);\n    if (node.var) {\n      throw tag.hub.buildError(\n        node.var,\n        \"The `script` tag does not support a tag variable reference.\" + htmlScriptTagAlternateMsg\n      );\n    }\n    let seenValueAttr = false;\n    for (const attr2 of node.attributes) {\n      if (attr2.type === \"MarkoAttribute\" && attr2.name === \"value\") {\n        if (seenValueAttr) {\n          throw tag.hub.buildError(attr2, \"Invalid duplicate value attribute.\");\n        }\n        seenValueAttr = true;\n        (attr2.value.extra ??= {}).isEffect = true;\n        ((0, import_babel_utils39.getProgram)().node.extra ??= {}).isInteractive = true;\n      } else {\n        throw tag.hub.buildError(\n          attr2,\n          \"The `script` tag does not support html attributes.\" + htmlScriptTagAlternateMsg\n        );\n      }\n    }\n    if (!seenValueAttr) {\n      dropReferences(getAllTagReferenceNodes(node));\n    }\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      if (!valueAttr) {\n        tag.remove();\n        return;\n      }\n      const section = getSection(tag);\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      if (isOutputDOM()) {\n        const { value: value2 } = valueAttr;\n        const isFunction2 = import_compiler46.types.isFunctionExpression(value2) || import_compiler46.types.isArrowFunctionExpression(value2);\n        let inlineBody = null;\n        if (isFunction2 && !(value2.async || value2.generator)) {\n          if (import_compiler46.types.isBlockStatement(value2.body)) {\n            let hasDeclaration = false;\n            for (const child of value2.body.body) {\n              if (import_compiler46.types.isDeclaration(child)) {\n                hasDeclaration = true;\n                break;\n              }\n            }\n            inlineBody = hasDeclaration ? value2.body : value2.body.body;\n          } else {\n            inlineBody = import_compiler46.types.expressionStatement(value2.body);\n          }\n        }\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          inlineBody || import_compiler46.types.expressionStatement(\n            import_compiler46.types.callExpression(value2, isFunction2 ? [] : [scopeIdentifier])\n          )\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  html: false,\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#script\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/script.d.marko\"\n};\nfunction isAwaitExpression(node) {\n  switch (node.type) {\n    case \"ForOfStatement\":\n      return node.await;\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ObjectMethod\":\n    case \"ClassPrivateMethod\":\n      return skip;\n    case \"AwaitExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// src/translator/core/server.ts\nvar import_compiler47 = require(\"@marko/compiler\");\nvar import_babel_utils40 = require(\"@marko/compiler/babel-utils\");\nvar server_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^server\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils40.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler47.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler47.types.markoScriptlet(body, true, \"server\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"server <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the server.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#server-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/static.ts\nvar import_compiler48 = require(\"@marko/compiler\");\nvar import_babel_utils41 = require(\"@marko/compiler/babel-utils\");\nvar static_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^static\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils41.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler48.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler48.types.markoScriptlet(body, true));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"static <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#static-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/style.ts\nvar import_compiler49 = require(\"@marko/compiler\");\nvar import_babel_utils42 = require(\"@marko/compiler/babel-utils\");\nvar import_magic_string = __toESM(require(\"magic-string\"));\nvar import_path3 = __toESM(require(\"path\"));\nvar STYLE_EXT_REG = /^style((?:\\.[a-zA-Z0-9$_-]+)+)?/;\nvar htmlStyleTagAlternateMsg = \" For a native html `style` tag use the `html-style` core tag instead.\";\nvar style_default = {\n  analyze(tag) {\n    (0, import_babel_utils42.assertNoArgs)(tag);\n    (0, import_babel_utils42.assertNoParams)(tag);\n    (0, import_babel_utils42.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    const ext = STYLE_EXT_REG.exec(node.rawValue || \"\")?.[1]?.slice(1);\n    for (const attr2 of node.attributes) {\n      if (attr2.start == null && attr2.type === \"MarkoAttribute\" && attr2.name === \"class\" && attr2.value.type === \"StringLiteral\" && attr2.value.value === ext) {\n        continue;\n      }\n      throw tag.hub.buildError(\n        attr2.value,\n        \"The `style` does not support html attributes.\" + htmlStyleTagAlternateMsg\n      );\n    }\n    for (const child of node.body.body) {\n      if (child.type !== \"MarkoText\") {\n        throw tag.hub.buildError(\n          child,\n          \"The `style` tag currently only supports static content.\" + htmlStyleTagAlternateMsg\n        );\n      }\n    }\n    if (node.body.body.length > 1) {\n      throw tag.hub.buildError(\n        node.name,\n        \"The `style` tag currently only supports static content.\" + htmlStyleTagAlternateMsg\n      );\n    }\n  },\n  translate(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const { filename, sourceMaps } = file.opts;\n    let ext = STYLE_EXT_REG.exec(node.rawValue || \"\")?.[1] || \".css\";\n    if (node.var && !/\\.module\\./.test(ext)) {\n      ext = \".module\" + ext;\n    }\n    const markoText = node.body.body[0];\n    const { resolveVirtualDependency } = getMarkoOpts();\n    const start = (0, import_babel_utils42.getStart)(file, markoText);\n    const end = (0, import_babel_utils42.getEnd)(file, markoText);\n    let code = markoText.value;\n    let map;\n    if (resolveVirtualDependency && sourceMaps && start !== null && end !== null) {\n      const magicString = new import_magic_string.default(file.code, { filename });\n      magicString.remove(0, start);\n      magicString.remove(end, file.code.length);\n      map = magicString.generateMap({\n        source: filename,\n        includeContent: true\n      });\n      if (sourceMaps === \"inline\" || sourceMaps === \"both\") {\n        code += `\n/*# sourceMappingURL=${map.toUrl()}*/`;\n        if (sourceMaps === \"inline\") {\n          map = void 0;\n        }\n      }\n    }\n    const importPath = resolveVirtualDependency?.(filename, {\n      virtualPath: `./${import_path3.default.basename(filename) + ext}`,\n      code,\n      map\n    });\n    if (importPath) {\n      if (!node.var) {\n        (0, import_babel_utils42.getProgram)().node.body.push(\n          import_compiler49.types.importDeclaration([], import_compiler49.types.stringLiteral(importPath))\n        );\n      } else if (import_compiler49.types.isIdentifier(node.var)) {\n        (0, import_babel_utils42.getProgram)().node.body.push(\n          import_compiler49.types.importDeclaration(\n            [import_compiler49.types.importDefaultSpecifier(node.var)],\n            import_compiler49.types.stringLiteral(importPath)\n          )\n        );\n      } else {\n        (0, import_babel_utils42.getProgram)().node.body.push(\n          import_compiler49.types.variableDeclaration(\"const\", [\n            import_compiler49.types.variableDeclarator(\n              node.var,\n              (0, import_babel_utils42.importDefault)(file, importPath, \"style\")\n            )\n          ])\n        );\n      }\n    }\n    tag.remove();\n  },\n  parseOptions: {\n    html: false,\n    text: true,\n    rawOpenTag: true,\n    preserveWhitespace: true\n  },\n  attributes: {}\n};\n\n// src/translator/core/try.ts\nvar import_compiler50 = require(\"@marko/compiler\");\nvar import_babel_utils43 = require(\"@marko/compiler/babel-utils\");\nvar kDOMBinding2 = Symbol(\"try tag dom binding\");\nvar try_default = {\n  analyze(tag) {\n    (0, import_babel_utils43.assertNoVar)(tag);\n    (0, import_babel_utils43.assertNoArgs)(tag);\n    (0, import_babel_utils43.assertNoParams)(tag);\n    (0, import_babel_utils43.assertNoAttributes)(tag);\n    assertNoSpreadAttrs(tag);\n    analyzeAttributeTags(tag);\n    const section = getOrCreateSection(tag);\n    const tagExtra = mergeReferences(\n      section,\n      tag.node,\n      getAllTagReferenceNodes(tag.node)\n    );\n    tagExtra[kDOMBinding2] = createBinding(\"#text\", 0 /* dom */, section);\n    if (!tag.node.body.body.length) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `try` tag requires body content.\");\n    }\n    startSection(tag.get(\"body\"));\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (!getSectionForBody(tag.get(\"body\"))) {\n          tag.remove();\n          return;\n        }\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        setSectionParentIsOwner(bodySection, true);\n        flushBefore(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const section = getSection(tag);\n        const tagExtra = node.extra;\n        const tagBody = tag.get(\"body\");\n        const translatedAttrs = translateAttrs(tag);\n        const nodeRef2 = tagExtra[kDOMBinding2];\n        const contentProp = getTranslatedBodyContentProperty(\n          translatedAttrs.properties\n        );\n        if (contentProp) {\n          translatedAttrs.properties.splice(\n            translatedAttrs.properties.indexOf(contentProp),\n            1\n          );\n        }\n        flushInto(tag);\n        writeHTMLResumeStatements(tagBody);\n        tag.insertBefore(translatedAttrs.statements);\n        tag.replaceWith(\n          import_compiler50.types.expressionStatement(\n            callRuntime(\n              \"tryContent\",\n              getScopeIdIdentifier(section),\n              getScopeAccessorLiteral(nodeRef2),\n              contentProp?.value,\n              propsToExpression(translatedAttrs.properties)\n            )\n          )\n        )[0].skip();\n      }\n    },\n    dom: {\n      enter(tag) {\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        setSectionParentIsOwner(bodySection, true);\n        visit(tag, 37 /* Replace */);\n        enterShallow(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const nodeRef2 = tagExtra[kDOMBinding2];\n        const referencedBindings = tagExtra.referencedBindings;\n        const translatedAttrs = translateAttrs(tag);\n        const contentProp = getTranslatedBodyContentProperty(\n          translatedAttrs.properties\n        );\n        if (contentProp) {\n          translatedAttrs.properties.splice(\n            translatedAttrs.properties.indexOf(contentProp),\n            1\n          );\n        }\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tag.get(\"body\"));\n        const signal = getSignal(section, nodeRef2, \"try\");\n        signal.build = () => {\n          return callRuntime(\n            \"createTry\",\n            getScopeAccessorLiteral(nodeRef2),\n            import_compiler50.types.identifier(bodySection.name)\n          );\n        };\n        if (translatedAttrs.statements.length) {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            translatedAttrs.statements\n          );\n        }\n        (0, import_babel_utils43.getProgram)().node.body.push(\n          import_compiler50.types.expressionStatement(callRuntime(\"enableCatch\"))\n        );\n        addValue(\n          section,\n          referencedBindings,\n          signal,\n          propsToExpression(translatedAttrs.properties)\n        );\n        signal.hasDownstreamIntersections = () => true;\n        tag.remove();\n      }\n    }\n  }),\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Used to capture errors and display placeholders for nested content.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#try\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/try.d.marko\"\n};\n\n// src/translator/core/index.ts\nvar core_default = {\n  taglibId: runtime_info_default.taglibId,\n  \"<attrs>\": attrs_default,\n  \"<await>\": await_default,\n  \"<client>\": client_default,\n  \"<const>\": const_default,\n  \"<debug>\": debug_default,\n  \"<define>\": define_default,\n  \"<effect>\": effect_default,\n  \"<else-if>\": ElseIfTag,\n  \"<else>\": ElseTag,\n  \"<export>\": export_default,\n  \"<for>\": for_default,\n  \"<html-comment>\": html_comment_default,\n  \"<html-script>\": html_script_default,\n  \"<html-style>\": html_style_default,\n  \"<id>\": id_default,\n  \"<if>\": IfTag,\n  \"<import>\": import_default,\n  \"<let>\": let_default,\n  \"<lifecycle>\": lifecycle_default,\n  \"<log>\": log_default,\n  \"<return>\": return_default,\n  \"<script>\": script_default,\n  \"<server>\": server_default,\n  \"<static>\": static_default,\n  \"<style>\": style_default,\n  \"<try>\": try_default\n};\n\n// src/translator/visitors/cdata.ts\nvar cdata_default = {\n  translate: {\n    enter(cdata) {\n      throw cdata.buildCodeFrameError(\n        \"CDATA sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/translator/visitors/comment.ts\nvar comment_default = {\n  translate: {\n    exit(comment) {\n      comment.remove();\n    }\n  }\n};\n\n// src/translator/visitors/declaration.ts\nvar declaration_default = {\n  translate: {\n    enter(decl) {\n      throw decl.buildCodeFrameError(\n        \"XML declarations sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/translator/visitors/document-type.ts\nvar document_type_default = {\n  translate: {\n    exit(documentType) {\n      if (isOutputHTML()) {\n        writeTo(documentType)`<!${documentType.node.value}>`;\n      }\n      documentType.remove();\n    }\n  }\n};\n\n// src/translator/visitors/function.ts\nvar import_compiler51 = require(\"@marko/compiler\");\nvar import_babel_utils44 = require(\"@marko/compiler/babel-utils\");\nvar function_default = {\n  analyze(fn) {\n    if (fn !== getFnRoot(fn)) {\n      return;\n    }\n    const markoRoot = getMarkoRoot(fn);\n    if (markoRoot && (markoRoot.isMarkoPlaceholder() || markoRoot.isMarkoScriptlet() && markoRoot.node.target === \"server\")) {\n      return;\n    }\n    if (isMarkoAttribute(markoRoot) && ((0, import_babel_utils44.isNativeTag)(markoRoot.parentPath) && /^on[A-Z-]/.test(markoRoot.node.name) || isCoreTagName(markoRoot.parentPath, \"script\") || isCoreTagName(markoRoot.parentPath, \"lifecycle\") || isCoreTagName(markoRoot.parentPath, \"for\"))) {\n      return;\n    }\n    const { node } = fn;\n    const section = getSection(fn);\n    const extra = node.extra ??= {};\n    const {\n      markoOpts,\n      opts: { filename }\n    } = (0, import_babel_utils44.getFile)();\n    const name2 = extra.name = generateUid(\n      fn.node.id?.name || (isMarkoAttribute(markoRoot) ? markoRoot.node.default ? import_compiler51.types.toIdentifier(\n        markoRoot.parentPath.has(\"var\") ? markoRoot.parentPath.get(\"var\") : markoRoot.parentPath.get(\"name\")\n      ) : markoRoot.node.name : import_compiler51.types.isVariableDeclarator(fn.parent) && import_compiler51.types.isIdentifier(fn.parent.id) ? fn.parent.id.name : import_compiler51.types.isObjectMethod(node) && import_compiler51.types.isIdentifier(node.key) ? node.key.name : \"anonymous\")\n    );\n    extra.section = section;\n    extra.registerId = (0, import_babel_utils44.getTemplateId)(\n      markoOpts,\n      filename,\n      `${section.id}/${name2.slice(1)}`\n    );\n  }\n};\nfunction isMarkoAttribute(path5) {\n  return path5 ? path5.isMarkoAttribute() : false;\n}\n\n// src/translator/visitors/import-declaration.ts\nvar import_babel_utils45 = require(\"@marko/compiler/babel-utils\");\nvar import_declaration_default = {\n  analyze(importDecl) {\n    const { node } = importDecl;\n    const { source } = node;\n    const { value } = source;\n    const tagImport = (0, import_babel_utils45.resolveTagImport)(importDecl, value);\n    if (tagImport) {\n      node.extra ??= {};\n      node.extra.tagImport = tagImport;\n      const tags = importDecl.hub.file.metadata.marko.tags;\n      if (!tags.includes(tagImport)) {\n        tags.push(tagImport);\n      }\n    }\n  },\n  translate: {\n    exit(importDecl) {\n      const { node } = importDecl;\n      const { extra } = node;\n      const tagImport = extra?.tagImport;\n      if (tagImport) {\n        node.source.value = tagImport;\n      }\n    }\n  }\n};\n\n// src/translator/visitors/placeholder.ts\nvar import_compiler53 = require(\"@marko/compiler\");\n\n// src/translator/util/is-non-html-text.ts\nvar import_compiler52 = require(\"@marko/compiler\");\nfunction isNonHTMLText(placeholder) {\n  const parentTag = placeholder.parentPath.isMarkoTagBody() && placeholder.parentPath.parentPath;\n  if (parentTag && isCoreTag(parentTag)) {\n    switch (parentTag.node.name.value) {\n      case \"html-comment\":\n      case \"html-script\":\n      case \"html-style\":\n        return true;\n    }\n  }\n  return false;\n}\n\n// src/translator/visitors/placeholder.ts\nvar kNodeBinding4 = Symbol(\"placeholder node binding\");\nvar kSiblingText = Symbol(\"placeholder has sibling text\");\nvar placeholder_default = {\n  analyze(placeholder) {\n    if (isNonHTMLText(placeholder)) return;\n    const { node } = placeholder;\n    const valueExtra = evaluate(node.value);\n    const { confident, computed } = valueExtra;\n    if (!(confident && (node.escape || isVoid2(computed)))) {\n      const section = getOrCreateSection(placeholder);\n      const nodeBinding = (node.extra ??= {})[kNodeBinding4] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section\n      );\n      analyzeSiblingText(placeholder);\n      addBindingSerializeReasonExpr(section, nodeBinding, valueExtra);\n    }\n  },\n  translate: {\n    exit(placeholder) {\n      if (isNonHTMLText(placeholder)) return;\n      const { node } = placeholder;\n      const { value } = node;\n      const valueExtra = evaluate(value);\n      const { confident, computed } = valueExtra;\n      if (confident && isVoid2(computed)) {\n        placeholder.remove();\n        return;\n      }\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(placeholder);\n      const extra = node.extra || {};\n      const nodeBinding = extra[kNodeBinding4];\n      const canWriteHTML = isHTML || confident && node.escape;\n      const method = canWriteHTML ? node.escape ? \"escapeXML\" : \"toString\" : node.escape ? \"data\" : \"html\";\n      const section = getSection(placeholder);\n      const markerSerializeReason = nodeBinding && getBindingSerializeReason(section, nodeBinding);\n      const siblingText = extra[kSiblingText];\n      if (confident && canWriteHTML) {\n        write2`${getHTMLRuntime()[method](computed)}`;\n      } else {\n        if (siblingText === 1 /* Before */) {\n          if (isHTML && markerSerializeReason) {\n            if (markerSerializeReason === true) {\n              write2`<!>`;\n            } else {\n              write2`${callRuntime(\"commentSeparator\", getSerializeGuard(markerSerializeReason))}`;\n            }\n          }\n          visit(placeholder, 37 /* Replace */);\n        } else if (siblingText === 2 /* After */) {\n          visit(placeholder, 37 /* Replace */);\n        } else {\n          if (!isHTML) write2` `;\n          visit(placeholder, 32 /* Get */);\n        }\n        if (isHTML) {\n          write2`${callRuntime(method, value)}`;\n          if (nodeBinding) {\n            markNode(placeholder, nodeBinding, markerSerializeReason);\n          }\n        } else {\n          addStatement(\n            \"render\",\n            getSection(placeholder),\n            valueExtra.referencedBindings,\n            import_compiler53.types.expressionStatement(\n              method === \"data\" ? callRuntime(\n                \"data\",\n                import_compiler53.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(nodeBinding),\n                  true\n                ),\n                value\n              ) : callRuntime(\n                \"html\",\n                scopeIdentifier,\n                value,\n                getScopeAccessorLiteral(nodeBinding)\n              )\n            )\n          );\n        }\n      }\n      enterShallow(placeholder);\n      placeholder.remove();\n    }\n  }\n};\nfunction analyzeSiblingText(placeholder) {\n  const placeholderExtra = placeholder.node.extra;\n  let prev = placeholder.getPrevSibling();\n  while (prev.node) {\n    const contentType = getNodeContentType(\n      prev,\n      \"endType\"\n    );\n    if (contentType === null) {\n      prev = prev.getPrevSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 1 /* Before */;\n    } else {\n      break;\n    }\n  }\n  if (!prev.node && import_compiler53.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 1 /* Before */;\n  }\n  let next = placeholder.getNextSibling();\n  while (next.node) {\n    const contentType = getNodeContentType(\n      next,\n      \"startType\"\n    );\n    if (contentType === null) {\n      next = next.getNextSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 2 /* After */;\n    } else {\n      break;\n    }\n  }\n  if (!next.node && import_compiler53.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 2 /* After */;\n  }\n  return placeholderExtra[kSiblingText] = 0 /* None */;\n}\nfunction isVoid2(value) {\n  return value == null || value === false;\n}\n\n// src/translator/visitors/referenced-identifier.ts\nvar import_compiler54 = require(\"@marko/compiler\");\nvar abortIdsByExpressionForSection = /* @__PURE__ */ new WeakMap();\nvar referenced_identifier_default = {\n  migrate(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    switch (name2) {\n      case \"out\":\n        if (import_compiler54.types.isMemberExpression(identifier.parent) && import_compiler54.types.isIdentifier(identifier.parent.property) && identifier.parent.property.name === \"global\") {\n          identifier.parentPath.replaceWith(import_compiler54.types.identifier(\"$global\"));\n        } else {\n          throw identifier.buildCodeFrameError(\n            \"Only `out.global` is supported for compatibility.\"\n          );\n        }\n        break;\n    }\n  },\n  analyze(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    if (name2 === \"$global\") {\n      setReferencesScope(identifier);\n    } else if (name2 === \"$signal\") {\n      const section = getOrCreateSection(identifier);\n      section.hasAbortSignal = true;\n      setReferencesScope(identifier);\n    }\n  },\n  translate(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    switch (name2) {\n      case \"$global\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler54.types.callExpression(importRuntime(\"$global\"), [])\n          );\n        } else {\n          identifier.replaceWith(\n            import_compiler54.types.memberExpression(scopeIdentifier, import_compiler54.types.identifier(\"$global\"))\n          );\n        }\n        break;\n      case \"$signal\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler54.types.callExpression(\n              import_compiler54.types.arrowFunctionExpression(\n                [],\n                import_compiler54.types.blockStatement([\n                  import_compiler54.types.throwStatement(\n                    import_compiler54.types.newExpression(import_compiler54.types.identifier(\"Error\"), [\n                      import_compiler54.types.stringLiteral(\"Cannot use $signal in a server render.\")\n                    ])\n                  )\n                ])\n              ),\n              []\n            )\n          );\n        } else {\n          const section = getSection(identifier);\n          const exprRoot = getExprRoot(identifier);\n          let abortIdsByExpression = abortIdsByExpressionForSection.get(section);\n          let exprId;\n          if (abortIdsByExpression) {\n            exprId = abortIdsByExpression.get(exprRoot);\n          } else {\n            abortIdsByExpression = /* @__PURE__ */ new Map();\n            abortIdsByExpressionForSection.set(section, abortIdsByExpression);\n          }\n          if (!exprId) {\n            exprId = abortIdsByExpression.size;\n            abortIdsByExpression.set(exprRoot, exprId);\n            addStatement(\n              \"render\",\n              section,\n              exprRoot.node.extra?.referencedBindings,\n              import_compiler54.types.expressionStatement(\n                import_compiler54.types.callExpression(importRuntime(\"resetAbortSignal\"), [\n                  scopeIdentifier,\n                  import_compiler54.types.numericLiteral(exprId)\n                ])\n              ),\n              false\n            );\n          }\n          identifier.replaceWith(\n            import_compiler54.types.callExpression(importRuntime(\"getAbortSignal\"), [\n              scopeIdentifier,\n              import_compiler54.types.numericLiteral(exprId)\n            ])\n          );\n        }\n    }\n  }\n};\n\n// src/translator/visitors/scriptlet.ts\nvar scriptlet_default = {\n  analyze(scriptlet) {\n    if (!scriptlet.node.static) {\n      throw scriptlet.buildCodeFrameError(\n        \"Scriptlets are not supported when using the tags api.\"\n      );\n    }\n    mergeReferences(\n      getOrCreateSection(scriptlet),\n      scriptlet.node,\n      scriptlet.node.body\n    );\n  },\n  translate: {\n    exit(scriptlet) {\n      const { node } = scriptlet;\n      const isHTML = isOutputHTML();\n      if (node.target && node.target !== (isHTML ? \"server\" : \"client\")) {\n        scriptlet.remove();\n        return;\n      }\n      if (isHTML) {\n      } else {\n        traverseReplace(node, \"body\", replaceRegisteredFunctionNode2);\n        scriptlet.replaceWithMultiple(node.body);\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/index.ts\nvar import_compiler58 = require(\"@marko/compiler\");\nvar import_babel_utils49 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/visitors/tag/attribute-tag.ts\nvar import_compiler55 = require(\"@marko/compiler\");\nvar import_babel_utils46 = require(\"@marko/compiler/babel-utils\");\nvar attribute_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils46.assertNoVar)(tag);\n      (0, import_babel_utils46.assertNoArgs)(tag);\n      const body = tag.get(\"body\");\n      startSection(body);\n      trackParamsReferences(body, 3 /* param */);\n      if (!(0, import_babel_utils46.findParentTag)(tag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags must be nested within another tag.\");\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/custom-tag.ts\nvar import_compiler56 = require(\"@marko/compiler\");\nvar import_babel_utils47 = require(\"@marko/compiler/babel-utils\");\nvar import_path4 = __toESM(require(\"path\"));\nvar kChildScopeBinding = Symbol(\"custom tag child scope\");\nvar kChildOffsetScopeBinding = Symbol(\"custom tag scope offset\");\nvar kChildInputSerializePropIds = Symbol(\n  \"custom tag child serialize reasons\"\n);\nvar custom_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils47.assertAttributesOrSingleArg)(tag);\n      analyzeAttributeTags(tag);\n      const templateFile = (0, import_babel_utils47.getTagTemplate)(tag);\n      if (!templateFile) {\n        const tagName = getTagName(tag);\n        if (tagName && tag.scope.hasBinding(tagName)) {\n          throw tag.get(\"name\").buildCodeFrameError(\n            `Local variables must be in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n          );\n        }\n        throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n      }\n      const section = getOrCreateSection(tag);\n      const tagBody = tag.get(\"body\");\n      const tagExtra = tag.node.extra ??= {};\n      const childScopeBinding = tagExtra[kChildScopeBinding] = createBinding(\n        \"#childScope\",\n        0 /* dom */,\n        section\n      );\n      const attrExprs = /* @__PURE__ */ new Set([tagExtra]);\n      startSection(tagBody);\n      trackParamsReferences(tagBody, 3 /* param */);\n      const childFile = (0, import_babel_utils47.loadFileForTag)(tag);\n      if (!childFile) {\n        throw tag.get(\"name\").buildCodeFrameError(\"Unable to resolve file for tag.\");\n      }\n      const varBinding = trackVarReferences(tag, 4 /* derived */);\n      if (varBinding) {\n        varBinding.scopeOffset = tagExtra[kChildOffsetScopeBinding] = createBinding(\"#scopeOffset\", 0 /* dom */, section);\n      }\n      if (childFile.opts.filename === tag.hub.file.opts.filename) {\n        mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n        if (varBinding) {\n          const varSerializeReason = (0, import_babel_utils47.getProgram)().node.extra.returnValueExpr;\n          setBindingValueExpr(varBinding, varSerializeReason);\n          addBindingSerializeReasonExpr(\n            section,\n            childScopeBinding,\n            varSerializeReason\n          );\n        }\n      } else {\n        const childProgram = childFile.ast.program;\n        const childExtra = childProgram.extra;\n        const childInputBinding = childProgram.params[0].extra?.binding;\n        const inputExpr = {};\n        analyzeAttrs(\n          tagExtra,\n          section,\n          tag,\n          childExtra?.domExports.input,\n          attrExprs,\n          inputExpr\n        );\n        if (varBinding) {\n          const varSerializeReason = mapChildReasonToLocalReason(\n            childExtra.returnSerializeReason,\n            childInputBinding,\n            inputExpr\n          );\n          setBindingValueExpr(varBinding, varSerializeReason);\n          addBindingSerializeReasonExpr(\n            section,\n            childScopeBinding,\n            varSerializeReason\n          );\n        }\n        if (childExtra.inputSerializeReasons) {\n          const childInputSerializePropIds = tagExtra[kChildInputSerializePropIds] = [];\n          for (const reason of childExtra.inputSerializeReasons) {\n            const propId = Symbol();\n            childInputSerializePropIds.push(propId);\n            addBindingSerializeReasonExpr(\n              section,\n              childScopeBinding,\n              mapChildReasonToLocalReason(reason, childInputBinding, inputExpr),\n              propId\n            );\n          }\n        }\n        (0, import_babel_utils47.getProgram)().node.extra.hasInteractiveChild = childExtra?.isInteractive || childExtra?.hasInteractiveChild || false;\n      }\n      addBindingSerializeReasonExpr(\n        section,\n        childScopeBinding,\n        fromIter(attrExprs)\n      );\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML(tag);\n      } else {\n        translateDOM(tag);\n      }\n    }\n  }\n};\nfunction translateHTML(tag) {\n  const tagBody = tag.get(\"body\");\n  const { node } = tag;\n  const tagExtra = node.extra;\n  let tagIdentifier;\n  flushInto(tag);\n  writeHTMLResumeStatements(tagBody);\n  if (import_compiler56.types.isStringLiteral(node.name)) {\n    const relativePath = getTagRelativePath(tag);\n    tagIdentifier = isCircularRequest(tag.hub.file, relativePath) ? import_compiler56.types.identifier(getTemplateContentName()) : (0, import_babel_utils47.importDefault)(tag.hub.file, relativePath, getTagName(tag));\n  } else {\n    tagIdentifier = node.name;\n  }\n  const tagVar = node.var;\n  const section = getSection(tag);\n  const childProgram = (0, import_babel_utils47.loadFileForTag)(tag).ast.program;\n  const childExtra = childProgram.extra;\n  const inputExport = childExtra.domExports?.input;\n  const { properties, statements } = inputExport ? translateAttrs(tag, inputExport.props) : {\n    properties: [],\n    statements: []\n  };\n  const childScopeBinding = tagExtra[kChildScopeBinding];\n  const childScopeSerializeReason = getBindingSerializeReason(\n    section,\n    childScopeBinding\n  );\n  const childSerializeReasonIds = tagExtra[kChildInputSerializePropIds];\n  let childSerializeReasonExpr;\n  if (childSerializeReasonIds) {\n    if (childSerializeReasonIds.length === 1) {\n      const reason = getBindingSerializeReason(\n        section,\n        childScopeBinding,\n        childSerializeReasonIds[0]\n      );\n      childSerializeReasonExpr = !reason ? void 0 : reason == true ? import_compiler56.types.numericLiteral(1) : getSerializeGuard(reason);\n    } else {\n      const props = [];\n      let hasDynamicReasons = false;\n      let hasSkippedReasons = false;\n      for (let i = 0; i < childSerializeReasonIds.length; i++) {\n        const reason = getBindingSerializeReason(\n          section,\n          childScopeBinding,\n          childSerializeReasonIds[i]\n        );\n        if (reason) {\n          hasDynamicReasons ||= reason !== true;\n          props.push(\n            import_compiler56.types.objectProperty(\n              import_compiler56.types.numericLiteral(i),\n              reason === true ? import_compiler56.types.numericLiteral(1) : getSerializeGuard(reason)\n            )\n          );\n        } else {\n          hasSkippedReasons = true;\n        }\n      }\n      if (props.length) {\n        childSerializeReasonExpr = hasDynamicReasons || hasSkippedReasons ? import_compiler56.types.objectExpression(props) : import_compiler56.types.numericLiteral(1);\n      }\n    }\n  }\n  if (childScopeSerializeReason) {\n    const peekScopeId = generateUidIdentifier(childScopeBinding?.name);\n    tag.insertBefore(\n      import_compiler56.types.variableDeclaration(\"const\", [\n        import_compiler56.types.variableDeclarator(peekScopeId, callRuntime(\"peekNextScopeId\"))\n      ])\n    );\n    setBindingSerializedValue(\n      section,\n      childScopeBinding,\n      callRuntime(\"writeExistingScope\", peekScopeId)\n    );\n    if (tagVar) {\n      statements.push(\n        import_compiler56.types.expressionStatement(\n          callRuntime(\n            \"setTagVar\",\n            getScopeIdIdentifier(section),\n            getScopeAccessorLiteral(tag.node.extra[kChildOffsetScopeBinding]),\n            peekScopeId,\n            import_compiler56.types.stringLiteral(\n              getResumeRegisterId(\n                section,\n                node.var.extra?.binding,\n                // TODO: node.var is not always an identifier.\n                \"var\"\n              )\n            )\n          )\n        )\n      );\n    }\n  }\n  if (node.extra.tagNameNullable) {\n    const contentProp = getTranslatedBodyContentProperty(properties);\n    let contentId = void 0;\n    if (contentProp) {\n      const contentExpression = contentProp.value;\n      contentProp.value = contentId = generateUidIdentifier(\"content\");\n      const [contentPath] = tag.insertBefore(\n        import_compiler56.types.variableDeclaration(\"const\", [\n          import_compiler56.types.variableDeclarator(\n            contentId,\n            // TODO: only register if needed (child template analysis)\n            contentExpression\n          )\n        ])\n      );\n      contentPath.skip();\n    }\n    let renderTagExpr = callExpression(\n      tagIdentifier,\n      propsToExpression(properties),\n      childSerializeReasonExpr\n    );\n    if (tagVar) {\n      translateVar(tag, import_compiler56.types.unaryExpression(\"void\", import_compiler56.types.numericLiteral(0)), \"let\");\n      renderTagExpr = import_compiler56.types.assignmentExpression(\"=\", tagVar, renderTagExpr);\n    }\n    statements.push(\n      import_compiler56.types.ifStatement(\n        tagIdentifier,\n        import_compiler56.types.expressionStatement(renderTagExpr),\n        contentId && callStatement(contentId)\n      )\n    );\n  } else if (tagVar) {\n    translateVar(\n      tag,\n      callExpression(\n        tagIdentifier,\n        propsToExpression(properties),\n        childSerializeReasonExpr\n      )\n    );\n  } else {\n    statements.push(\n      callStatement(\n        tagIdentifier,\n        propsToExpression(properties),\n        childSerializeReasonExpr\n      )\n    );\n  }\n  for (const replacement of tag.replaceWithMultiple(statements)) {\n    replacement.skip();\n  }\n}\nfunction translateDOM(tag) {\n  const tagSection = getSection(tag);\n  const { node } = tag;\n  const extra = node.extra;\n  const childScopeBinding = extra[kChildScopeBinding];\n  const write2 = writeTo(tag);\n  const { file } = tag.hub;\n  const tagName = import_compiler56.types.isIdentifier(node.name) ? node.name.name : import_compiler56.types.isStringLiteral(node.name) ? node.name.value : \"tag\";\n  const relativePath = getTagRelativePath(tag);\n  const childFile = (0, import_babel_utils47.loadFileForTag)(tag);\n  const childExports = childFile.ast.program.extra.domExports;\n  const tagIdentifier = importOrSelfReferenceName(\n    file,\n    relativePath,\n    childExports.setup,\n    tagName\n  );\n  const inputExport = childExports.input;\n  if (inputExport) {\n    writeAttrsToExports(tag, inputExport, `${getTagName(tag) || \"tag\"}_input`, {\n      circular: childFile.opts.filename === file.opts.filename,\n      tagSection,\n      relativePath,\n      childScopeBinding,\n      attrTagCallsByTag: void 0\n    });\n  }\n  write2`${(0, import_babel_utils47.importNamed)(file, relativePath, childExports.template, `${tagName}_template`)}`;\n  injectWalks(\n    tag,\n    (0, import_babel_utils47.importNamed)(file, relativePath, childExports.walks, `${tagName}_walks`)\n  );\n  if (node.var) {\n    const source = initValue(\n      // TODO: support destructuring\n      node.var.extra.binding\n    );\n    source.register = true;\n    source.buildAssignment = (valueSection, value) => {\n      return import_compiler56.types.callExpression(importRuntime(\"tagVarSignalChange\"), [\n        createScopeReadExpression(valueSection, childScopeBinding),\n        value\n      ]);\n    };\n    addStatement(\n      \"render\",\n      tagSection,\n      void 0,\n      import_compiler56.types.expressionStatement(\n        callRuntime(\n          \"setTagVar\",\n          scopeIdentifier,\n          getScopeAccessorLiteral(childScopeBinding),\n          source.identifier\n        )\n      )\n    );\n  }\n  addStatement(\n    \"render\",\n    tagSection,\n    void 0,\n    import_compiler56.types.expressionStatement(\n      import_compiler56.types.callExpression(tagIdentifier, [\n        createScopeReadExpression(tagSection, childScopeBinding)\n      ])\n    )\n  );\n  tag.remove();\n}\nfunction getTagRelativePath(tag) {\n  const {\n    node,\n    hub: { file }\n  } = tag;\n  let relativePath;\n  if (import_compiler56.types.isStringLiteral(node.name)) {\n    const template = (0, import_babel_utils47.getTagTemplate)(tag);\n    relativePath = template && (0, import_babel_utils47.resolveRelativePath)(file, template);\n  } else if (node.extra?.tagNameImported) {\n    relativePath = node.extra.tagNameImported;\n  }\n  if (!relativePath) {\n    const tagName = getTagName(tag);\n    if (tagName && tag.scope.hasBinding(tagName)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        `Local variables must be in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n      );\n    }\n    throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n  }\n  return relativePath;\n}\nfunction analyzeAttrs(rootTagExtra, section, tag, templateExport, rootAttrExprs, inputExpr) {\n  if (!templateExport) {\n    dropReferences(getAllTagReferenceNodes(tag.node));\n    return;\n  }\n  if (!templateExport.props || tag.node.arguments?.length) {\n    inputExpr.value = mergeReferences(\n      section,\n      tag.node,\n      getAllTagReferenceNodes(tag.node)\n    );\n    return;\n  }\n  const known = inputExpr.known = {};\n  const attrTagLookup = analyzeAttributeTags(tag);\n  const seen = /* @__PURE__ */ new Set();\n  if (attrTagLookup) {\n    const nodeReferencesByGroup = /* @__PURE__ */ new Map();\n    const analyzeDynamicChildGroup = (group, child) => {\n      const referenceNodes = getAllTagReferenceNodes(child.node);\n      const groupReferences = nodeReferencesByGroup.get(group);\n      if (groupReferences) {\n        groupReferences.referenceNodes = groupReferences.referenceNodes.concat(referenceNodes);\n      } else {\n        nodeReferencesByGroup.set(group, {\n          firstTag: child,\n          referenceNodes\n        });\n      }\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n    for (const child of attrTags2) {\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils47.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExports = templateExport.props[attrTagMeta.name];\n          if (childAttrExports) {\n            if (childAttrExports.props && !attrTagMeta.dynamic) {\n              analyzeAttrs(\n                rootTagExtra,\n                section,\n                child,\n                childAttrExports,\n                rootAttrExprs,\n                known[attrTagMeta.name] = {}\n              );\n            } else {\n              analyzeDynamicChildGroup(attrTagMeta.group, child);\n            }\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        } else {\n          const group = child.node.extra.attributeTagGroup;\n          let childUsesGroupProp = false;\n          for (const name2 of group) {\n            if (templateExport.props[attrTagLookup[name2].name]) {\n              childUsesGroupProp = true;\n              break;\n            }\n          }\n          if (childUsesGroupProp) {\n            analyzeDynamicChildGroup(group, child);\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        }\n      }\n    }\n    for (const [\n      group,\n      {\n        firstTag: { node },\n        referenceNodes\n      }\n    ] of nodeReferencesByGroup) {\n      const groupExtra = mergeReferences(section, node, referenceNodes);\n      const groupKnownValue = { value: groupExtra };\n      rootAttrExprs.add(groupExtra);\n      for (const name2 of group) {\n        known[attrTagLookup[name2].name] = groupKnownValue;\n      }\n    }\n  }\n  if (!seen.has(\"content\")) {\n    const bodySection = getSectionForBody(tag.get(\"body\"));\n    if (bodySection) {\n      seen.add(\"content\");\n      known.content = { value: void 0 };\n      bodySection.downstreamBinding = (templateExport.props.content || templateExport.props).binding;\n    }\n  }\n  const { attributes } = tag.node;\n  let spreadReferenceNodes;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler56.types.isMarkoAttribute(attr2)) {\n      if (seen.has(attr2.name) || !templateExport.props[attr2.name]) {\n        dropReferences(attr2.value);\n        continue;\n      }\n      seen.add(attr2.name);\n    }\n    if (spreadReferenceNodes) {\n      spreadReferenceNodes.push(attr2.value);\n    } else if (import_compiler56.types.isMarkoSpreadAttribute(attr2)) {\n      spreadReferenceNodes = [attr2.value];\n    } else {\n      const attrValueExtra = attr2.value.extra ??= {};\n      known[attr2.name] = { value: attrValueExtra };\n      rootAttrExprs.add(attrValueExtra);\n    }\n  }\n  if (spreadReferenceNodes) {\n    inputExpr.value = mergeReferences(section, tag.node, spreadReferenceNodes);\n  }\n}\nfunction writeAttrsToExports(tag, templateExport, importAlias, info) {\n  if (tag.node.arguments?.length) {\n    const [arg] = tag.node.arguments;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    addValue(\n      info.tagSection,\n      // technically this should be `arg.extra?.referencedBindings`\n      // but we should probably ensure all other references are dropped in this case before we do that.\n      tag.node.extra?.referencedBindings,\n      identifierToSignal(tagInputIdentifier),\n      import_compiler56.types.isSpreadElement(arg) ? import_compiler56.types.memberExpression(arg.argument, import_compiler56.types.numericLiteral(0), true) : arg,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding)\n    );\n    return;\n  }\n  if (!templateExport.props || info.circular) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    const translatedAttrs = translateAttrs(tag);\n    if (translatedAttrs.statements.length) {\n      addStatement(\n        \"render\",\n        info.tagSection,\n        referencedBindings,\n        translatedAttrs.statements\n      );\n    }\n    let translatedProps = propsToExpression(translatedAttrs.properties);\n    if ((0, import_babel_utils47.isAttributeTag)(tag)) {\n      const attrTagName = getTagName(tag);\n      const parentTag = tag.parentPath;\n      const repeated = analyzeAttributeTags(parentTag)?.[attrTagName]?.repeated;\n      if (repeated) {\n        let attrTagCallsForTag = (info.attrTagCallsByTag ||= /* @__PURE__ */ new Map()).get(\n          parentTag\n        );\n        if (!attrTagCallsForTag) {\n          info.attrTagCallsByTag.set(\n            parentTag,\n            attrTagCallsForTag = /* @__PURE__ */ new Map()\n          );\n        }\n        const attrTagCall = attrTagCallsForTag.get(attrTagName);\n        if (attrTagCall) {\n          attrTagCall.expression = callRuntime(\n            \"attrTags\",\n            attrTagCall.expression,\n            translatedProps\n          );\n          return;\n        } else {\n          attrTagCallsForTag.set(\n            attrTagName,\n            translatedProps = import_compiler56.types.parenthesizedExpression(\n              callRuntime(\"attrTag\", translatedProps)\n            )\n          );\n        }\n      } else {\n        translatedProps = callRuntime(\"attrTag\", translatedProps);\n      }\n    }\n    addValue(\n      info.tagSection,\n      referencedBindings,\n      identifierToSignal(tagInputIdentifier),\n      translatedProps,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding)\n    );\n    return;\n  }\n  const seen = /* @__PURE__ */ new Set();\n  const attrTagLookup = analyzeAttributeTags(tag);\n  if (attrTagLookup) {\n    const attrTags2 = tag.get(\"attributeTags\");\n    const statementsByGroup = /* @__PURE__ */ new Map();\n    const translateDynamicAttrTagChildInGroup = (group, index) => {\n      const child = attrTags2[index];\n      let statements = statementsByGroup.get(group)?.statements;\n      if (!statements) {\n        statements = [];\n        statementsByGroup.set(group, {\n          referencedBindings: child.node.extra?.referencedBindings,\n          statements\n        });\n      }\n      return addDynamicAttrTagStatements(\n        attrTags2,\n        index,\n        attrTagLookup,\n        statements,\n        templateExport.props\n      );\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils47.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExport = templateExport.props[attrTagMeta.name];\n          if (childAttrExport) {\n            if (attrTagMeta.dynamic) {\n              i = translateDynamicAttrTagChildInGroup(attrTagMeta.group, i);\n            } else {\n              writeAttrsToExports(\n                child,\n                childAttrExport,\n                `${importAlias}_${attrTagMeta.name}`,\n                info\n              );\n            }\n          }\n        } else if (child.node.extra?.attributeTagGroup) {\n          i = translateDynamicAttrTagChildInGroup(\n            child.node.extra.attributeTagGroup,\n            i\n          );\n        }\n      }\n    }\n    for (const [\n      group,\n      { referencedBindings, statements }\n    ] of statementsByGroup) {\n      const decls = [];\n      for (const name2 of group) {\n        const attrTagMeta = attrTagLookup[name2];\n        const childAttrExports = templateExport.props[attrTagMeta.name];\n        if (!childAttrExports) continue;\n        const attrExportIdentifier = importOrSelfReferenceName(\n          tag.hub.file,\n          info.relativePath,\n          childAttrExports.id,\n          `${importAlias}_${attrTagMeta.name}`\n        );\n        decls.push(import_compiler56.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta)));\n        addValue(\n          info.tagSection,\n          referencedBindings,\n          identifierToSignal(attrExportIdentifier),\n          getAttrTagIdentifier(attrTagMeta),\n          createScopeReadExpression(info.tagSection, info.childScopeBinding)\n        );\n      }\n      addStatement(\"render\", info.tagSection, referencedBindings, [\n        import_compiler56.types.variableDeclaration(\"let\", decls),\n        ...statements\n      ]);\n    }\n  }\n  const bodySection = tag.node.body.extra?.section;\n  if (bodySection && !seen.has(\"content\")) {\n    seen.add(\"content\");\n    if (templateExport.props.content) {\n      const contentExportIdentifier = (0, import_babel_utils47.importNamed)(\n        tag.hub.file,\n        info.relativePath,\n        templateExport.props.content.id,\n        `${importAlias}_content`\n      );\n      addValue(\n        info.tagSection,\n        void 0,\n        // TODO: pretty sure content needs to have the reference group of it's param defaults.\n        identifierToSignal(contentExportIdentifier),\n        import_compiler56.types.callExpression(import_compiler56.types.identifier(bodySection.name), [scopeIdentifier]),\n        createScopeReadExpression(info.tagSection, info.childScopeBinding)\n      );\n    }\n  }\n  const { attributes } = tag.node;\n  const staticAttrs = [];\n  let spreadProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler56.types.isMarkoAttribute(attr2)) {\n      const childAttrExports = templateExport.props[attr2.name];\n      if (!childAttrExports || seen.has(attr2.name)) continue;\n      seen.add(attr2.name);\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n        continue;\n      }\n      staticAttrs.push(attr2);\n    } else if (spreadProps) {\n      spreadProps.push(import_compiler56.types.spreadElement(attr2.value));\n    } else {\n      spreadProps = [import_compiler56.types.spreadElement(attr2.value)];\n    }\n  }\n  for (const attr2 of staticAttrs.reverse()) {\n    const childAttrExports = templateExport.props[attr2.name];\n    const attrExportIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      childAttrExports.id,\n      `${importAlias}_${attr2.name}`\n    );\n    addValue(\n      info.tagSection,\n      attr2.value.extra?.referencedBindings,\n      identifierToSignal(attrExportIdentifier),\n      attr2.value,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding)\n    );\n  }\n  const missing = new Set(Object.keys(templateExport.props));\n  for (const name2 of seen) missing.delete(name2);\n  if (missing.size) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    let getMissingPropValue = buildUndefined2;\n    if (spreadProps) {\n      const spreadId = generateUidIdentifier(`${importAlias}_spread`);\n      spreadProps.reverse();\n      getMissingPropValue = (name2) => toMemberExpression(spreadId, name2);\n      addStatement(\"render\", info.tagSection, referencedBindings, [\n        import_compiler56.types.variableDeclaration(\"const\", [\n          import_compiler56.types.variableDeclarator(spreadId, propsToExpression(spreadProps))\n        ])\n      ]);\n    }\n    for (const name2 of missing) {\n      const childAttrExports = templateExport.props[name2];\n      const attrExportIdentifier = importOrSelfReferenceName(\n        tag.hub.file,\n        info.relativePath,\n        childAttrExports.id,\n        `${importAlias}_${name2}`\n      );\n      addValue(\n        info.tagSection,\n        referencedBindings,\n        identifierToSignal(attrExportIdentifier),\n        getMissingPropValue(name2),\n        createScopeReadExpression(info.tagSection, info.childScopeBinding)\n      );\n    }\n  }\n}\nfunction importOrSelfReferenceName(file, request, name2, nameHint) {\n  if (isCircularRequest(file, request)) {\n    return import_compiler56.types.identifier(name2);\n  }\n  return (0, import_babel_utils47.importNamed)(file, request, name2, nameHint);\n}\nfunction mapChildReasonToLocalReason(childReason, childInputBinding, inputExpr) {\n  if (childReason) {\n    if (childReason === true) return true;\n    return filterMap(\n      childReason,\n      (inputBinding) => resolveChildInputExpr(childInputBinding, inputBinding, inputExpr)\n    );\n  }\n}\nfunction resolveChildInputExpr(inputBinding, propBinding, expr) {\n  if (expr) {\n    let curExpr = expr;\n    if (inputBinding !== propBinding) {\n      const props = [propBinding.property];\n      let curBinding = propBinding;\n      while (inputBinding !== (curBinding = curBinding.upstreamAlias)) {\n        props.push(curBinding.property);\n      }\n      for (let i = props.length; i--; ) {\n        const nestedExpr = curExpr.known?.[props[i]];\n        if (nestedExpr) {\n          curExpr = nestedExpr;\n        } else {\n          break;\n        }\n      }\n    }\n    return curExpr.value;\n  }\n}\nfunction isCircularRequest(file, request) {\n  const { filename } = file.opts;\n  return request === filename || request[0] === \".\" && import_path4.default.resolve(filename, \"..\", request) === filename;\n}\nfunction callStatement(id, ...args) {\n  return import_compiler56.types.expressionStatement(callExpression(id, ...args));\n}\nfunction callExpression(id, ...args) {\n  return import_compiler56.types.callExpression(id, args.filter(Boolean));\n}\nfunction identifierToSignal(identifier) {\n  return {\n    identifier,\n    hasDownstreamIntersections: always\n  };\n}\nfunction buildUndefined2() {\n  return import_compiler56.types.unaryExpression(\"void\", import_compiler56.types.numericLiteral(0));\n}\nfunction always() {\n  return true;\n}\n\n// src/translator/visitors/tag/dynamic-tag.ts\nvar import_compiler57 = require(\"@marko/compiler\");\nvar import_babel_utils48 = require(\"@marko/compiler/babel-utils\");\nvar kDOMBinding3 = Symbol(\"dynamic tag dom binding\");\nvar kChildOffsetScopeBinding2 = Symbol(\"custom tag scope offset\");\nvar dynamic_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils48.assertAttributesOrArgs)(tag);\n      analyzeAttributeTags(tag);\n      const tagSection = getOrCreateSection(tag);\n      const tagExtra = mergeReferences(tagSection, tag.node, [\n        tag.node.name,\n        ...getAllTagReferenceNodes(tag.node)\n      ]);\n      const tagBody = tag.get(\"body\");\n      const isClassAPI = tagExtra.featureType === \"class\";\n      const hasVar = !!tag.node.var;\n      const nodeBinding = tagExtra[kDOMBinding3] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        tagSection\n      );\n      if (hasVar) {\n        trackVarReferences(tag, 4 /* derived */);\n        tag.node.var.extra.binding.scopeOffset = tagExtra[kChildOffsetScopeBinding2] = createBinding(\"#scopeOffset\", 0 /* dom */, tagSection);\n      }\n      startSection(tagBody);\n      trackParamsReferences(tagBody, 3 /* param */);\n      addBindingSerializeReasonExpr(\n        tagSection,\n        nodeBinding,\n        isClassAPI || hasVar || tagExtra\n      );\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(\n        tag,\n        tag.node.var ? 49 /* DynamicTagWithVar */ : 37 /* Replace */\n      );\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const tagExtra = node.extra;\n      const nodeBinding = tagExtra[kDOMBinding3];\n      const tagSection = getSection(tag);\n      const isClassAPI = tagExtra.featureType === \"class\";\n      let tagExpression = node.name;\n      if (import_compiler57.types.isStringLiteral(tagExpression)) {\n        tagExpression = (0, import_babel_utils48.importDefault)(\n          tag.hub.file,\n          getTagRelativePath(tag),\n          tagExpression.value\n        );\n      }\n      if (isClassAPI) {\n        if (isOutputHTML()) {\n          (0, import_babel_utils48.getProgram)().node.body.push(\n            import_compiler57.types.markoScriptlet(\n              [\n                import_compiler57.types.expressionStatement(\n                  import_compiler57.types.callExpression(\n                    (0, import_babel_utils48.importNamed)(tag.hub.file, getCompatRuntimeFile(), \"s\"),\n                    [\n                      import_compiler57.types.identifier(tagExpression.name),\n                      import_compiler57.types.stringLiteral((0, import_babel_utils48.loadFileForTag)(tag).metadata.marko.id)\n                    ]\n                  )\n                )\n              ],\n              true\n            )\n          );\n        } else {\n          (0, import_babel_utils48.getProgram)().node.body.push(\n            import_compiler57.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                import_compiler57.types.stringLiteral((0, import_babel_utils48.loadFileForTag)(tag).metadata.marko.id),\n                import_compiler57.types.identifier(tagExpression.name)\n              )\n            )\n          );\n        }\n      }\n      const { properties, statements } = translateAttrs(\n        tag,\n        void 0,\n        void 0,\n        isClassAPI ? \"renderBody\" : \"content\"\n      );\n      const args = [];\n      let hasTagArgs = false;\n      if (node.arguments) {\n        hasTagArgs = true;\n        args.push(...node.arguments);\n        if (properties.length) {\n          args.push(propsToExpression(properties));\n        }\n      } else {\n        const contentProp = getTranslatedBodyContentProperty(properties);\n        if (contentProp) {\n          properties.splice(properties.indexOf(contentProp), 1);\n          args.push(propsToExpression(properties), contentProp.value);\n        } else {\n          args.push(propsToExpression(properties));\n        }\n      }\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        const serializeReason = getBindingSerializeReason(\n          tagSection,\n          nodeBinding\n        );\n        const serializeArg = !serializeReason ? import_compiler57.types.numericLiteral(0) : serializeReason === true ? void 0 : getSerializeGuard(serializeReason);\n        const dynamicTagExpr = hasTagArgs ? callRuntime(\n          \"dynamicTag\",\n          getScopeIdIdentifier(tagSection),\n          getScopeAccessorLiteral(nodeBinding),\n          tagExpression,\n          import_compiler57.types.arrayExpression(args),\n          import_compiler57.types.numericLiteral(0),\n          import_compiler57.types.numericLiteral(1),\n          serializeArg\n        ) : callRuntime(\n          \"dynamicTag\",\n          getScopeIdIdentifier(tagSection),\n          getScopeAccessorLiteral(nodeBinding),\n          tagExpression,\n          args[0],\n          args[1] || (serializeArg ? import_compiler57.types.numericLiteral(0) : void 0),\n          serializeArg ? import_compiler57.types.numericLiteral(0) : void 0,\n          serializeArg\n        );\n        if (node.var) {\n          const dynamicScopeIdentifier = generateUidIdentifier(\n            tag.get(\"name\").toString() + \"_scope\"\n          );\n          statements.push(\n            import_compiler57.types.variableDeclaration(\"const\", [\n              import_compiler57.types.variableDeclarator(\n                dynamicScopeIdentifier,\n                callRuntime(\"peekNextScopeId\")\n              )\n            ])\n          );\n          statements.push(\n            import_compiler57.types.variableDeclaration(\"const\", [\n              import_compiler57.types.variableDeclarator(node.var, dynamicTagExpr)\n            ]),\n            import_compiler57.types.expressionStatement(\n              callRuntime(\n                \"setTagVar\",\n                getScopeIdIdentifier(tagSection),\n                getScopeAccessorLiteral(\n                  tag.node.extra[kChildOffsetScopeBinding2]\n                ),\n                dynamicScopeIdentifier,\n                import_compiler57.types.stringLiteral(\n                  getResumeRegisterId(\n                    tagSection,\n                    node.var.extra?.binding,\n                    // TODO: node.var is not always an identifier.\n                    \"var\"\n                  )\n                )\n              )\n            )\n          );\n        } else {\n          statements.push(import_compiler57.types.expressionStatement(dynamicTagExpr));\n        }\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      } else {\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tag.get(\"body\"));\n        const signal = getSignal(section, nodeBinding, \"dynamicTag\");\n        let tagVarSignal;\n        if (tag.node.var) {\n          tagVarSignal = initValue(\n            // TODO: support destructuring\n            tag.node.var.extra.binding\n          );\n          tagVarSignal.register = true;\n          tagVarSignal.buildAssignment = (valueSection, value) => {\n            return import_compiler57.types.callExpression(importRuntime(\"tagVarSignalChange\"), [\n              import_compiler57.types.memberExpression(\n                getScopeExpression(tagVarSignal.section, valueSection),\n                import_compiler57.types.stringLiteral(\n                  getAccessorPrefix().ConditionalScope + getScopeAccessor(nodeBinding)\n                ),\n                true\n              ),\n              value\n            ]);\n          };\n        }\n        signal.build = () => {\n          return callRuntime(\n            \"dynamicTag\",\n            getScopeAccessorLiteral(nodeBinding),\n            bodySection && import_compiler57.types.identifier(bodySection.name),\n            tagVarSignal ? import_compiler57.types.arrowFunctionExpression([], tagVarSignal.identifier) : void 0,\n            hasTagArgs && import_compiler57.types.numericLiteral(1)\n          );\n        };\n        if (args.length) {\n          const argsOrInput = hasTagArgs ? import_compiler57.types.arrayExpression(args) : args[0];\n          if (!import_compiler57.types.isObjectExpression(argsOrInput) || argsOrInput.properties.length) {\n            signal.extraArgs = [\n              import_compiler57.types.arrowFunctionExpression(\n                [],\n                statements.length ? import_compiler57.types.blockStatement(\n                  statements.concat(import_compiler57.types.returnStatement(argsOrInput))\n                ) : argsOrInput\n              )\n            ];\n          }\n        }\n        signal.hasDownstreamIntersections = () => true;\n        addValue(section, tagExtra.referencedBindings, signal, tagExpression);\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/index.ts\nvar TAG_NAME_IDENTIFIER_REG = /^[A-Z][a-zA-Z0-9_$]*$/;\nvar BINDING_CHANGE_HANDLER = /* @__PURE__ */ new WeakMap();\nvar tag_default = {\n  transform: {\n    enter(tag) {\n      const { node } = tag;\n      const { name: name2, attributes } = tag.node;\n      let crawl = false;\n      if (import_compiler58.types.isStringLiteral(name2)) {\n        const tagName = name2.value;\n        if (tag.scope.getBinding(tagName) && TAG_NAME_IDENTIFIER_REG.test(tagName)) {\n          node.name = withPreviousLocation(import_compiler58.types.identifier(tagName), name2);\n          crawl = true;\n        }\n      }\n      for (let i = 0; i < attributes.length; i++) {\n        const attr2 = attributes[i];\n        if (import_compiler58.types.isMarkoAttribute(attr2) && attr2.bound) {\n          attr2.bound = false;\n          attributes.splice(++i, 0, getChangeHandler(tag, attr2));\n          crawl = true;\n        }\n      }\n      if (crawl) {\n        tag.scope.crawl();\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils49.getTagDef)(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        enter(hook, tag);\n        return;\n      }\n      if (type === 0 /* NativeTag */) {\n        native_tag_default.analyze.enter(tag);\n        return;\n      }\n      switch (type) {\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.analyze.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.analyze.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const hook = (0, import_babel_utils49.getTagDef)(tag)?.analyzer?.hook;\n      if (hook) {\n        exit(hook, tag);\n        return;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils49.getTagDef)(tag);\n      const extra = tag.node.extra;\n      if (tagDef?.translator) {\n        if (tagDef.translator.path) {\n          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);\n        }\n        enter(tagDef.translator.hook, tag);\n        return;\n      }\n      for (const attr2 of tag.get(\"attributes\")) {\n        if (attr2.isMarkoAttribute()) {\n          if (attr2.node.arguments) {\n            throw attr2.buildCodeFrameError(\n              `Unsupported arguments on the \\`${attr2.node.name}\\` attribute.`\n            );\n          }\n          if (attr2.node.modifier) {\n            if ((0, import_babel_utils49.isNativeTag)(attr2.parentPath)) {\n              attr2.node.name += `:${attr2.node.modifier}`;\n            } else {\n              throw attr2.buildCodeFrameError(\n                `Unsupported modifier \\`${attr2.node.modifier}\\`.`\n              );\n            }\n          }\n        }\n      }\n      if (extra.tagNameDynamic && extra.tagNameNullable && !tag.get(\"name\").isIdentifier() && isOutputHTML()) {\n        const tagNameId = generateUidIdentifier(\"tagName\");\n        const [tagNameVarPath] = tag.insertBefore(\n          import_compiler58.types.variableDeclaration(\"const\", [\n            import_compiler58.types.variableDeclarator(tagNameId, tag.node.name)\n          ])\n        );\n        tagNameVarPath.skip();\n        tag.set(\"name\", tagNameId);\n      }\n      switch (extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const translator = (0, import_babel_utils49.getTagDef)(tag)?.translator;\n      if (translator) {\n        exit(translator.hook, tag);\n        return;\n      }\n      switch (tag.node.extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.exit(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.exit(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.exit(tag);\n          break;\n      }\n    }\n  }\n};\nfunction getChangeHandler(tag, attr2) {\n  const attrName = attr2.name;\n  const changeAttrName = attrName + \"Change\";\n  if (import_compiler58.types.isIdentifier(attr2.value)) {\n    const binding = tag.scope.getBinding(attr2.value.name);\n    if (!binding)\n      return import_compiler58.types.markoAttribute(\n        changeAttrName,\n        buildChangeHandlerFunction(attr2.value)\n      );\n    const existingChangedAttr = BINDING_CHANGE_HANDLER.get(binding.identifier);\n    if (!existingChangedAttr) {\n      const changeHandlerAttr = import_compiler58.types.markoAttribute(\n        changeAttrName,\n        buildChangeHandlerFunction(attr2.value)\n      );\n      BINDING_CHANGE_HANDLER.set(binding.identifier, changeHandlerAttr);\n      return changeHandlerAttr;\n    }\n    if (existingChangedAttr.type === \"Identifier\") {\n      return import_compiler58.types.markoAttribute(\n        changeAttrName,\n        withPreviousLocation(\n          import_compiler58.types.identifier(existingChangedAttr.name),\n          attr2.value\n        )\n      );\n    }\n    const markoRoot = isMarko(binding.path) ? binding.path : getMarkoRoot(binding.path);\n    if (!(markoRoot?.isMarkoTag() || markoRoot?.isMarkoTagBody())) {\n      throw tag.hub.buildError(attr2.value, \"Unable to bind to value.\");\n    }\n    const changeHandlerId = generateUid(changeAttrName);\n    const changeHandlerConst = import_compiler58.types.markoTag(\n      import_compiler58.types.stringLiteral(\"const\"),\n      [import_compiler58.types.markoAttribute(\"value\", existingChangedAttr.value, null, null, true)],\n      import_compiler58.types.markoTagBody([]),\n      null,\n      import_compiler58.types.identifier(changeHandlerId)\n    );\n    BINDING_CHANGE_HANDLER.set(\n      binding.identifier,\n      existingChangedAttr.value = import_compiler58.types.identifier(changeHandlerId)\n    );\n    if (markoRoot.isMarkoTag()) {\n      markoRoot.insertAfter(changeHandlerConst);\n    } else {\n      markoRoot.unshiftContainer(\"body\", changeHandlerConst);\n    }\n    return import_compiler58.types.markoAttribute(\n      changeAttrName,\n      withPreviousLocation(import_compiler58.types.identifier(changeHandlerId), attr2.value)\n    );\n  } else if (import_compiler58.types.isMemberExpression(attr2.value)) {\n    const prop = attr2.value.property;\n    if (!import_compiler58.types.isPrivateName(attr2.value.property)) {\n      return import_compiler58.types.markoAttribute(\n        changeAttrName,\n        import_compiler58.types.memberExpression(\n          import_compiler58.types.cloneNode(attr2.value.object),\n          prop.type === \"Identifier\" ? withPreviousLocation(import_compiler58.types.identifier(prop.name + \"Change\"), prop) : import_compiler58.types.binaryExpression(\n            \"+\",\n            import_compiler58.types.cloneNode(prop),\n            import_compiler58.types.stringLiteral(\"Change\")\n          ),\n          prop.type !== \"Identifier\"\n        )\n      );\n    }\n  }\n  throw tag.hub.buildError(\n    attr2.value,\n    \"Attributes may only be bound to identifiers or member expressions\"\n  );\n}\nfunction buildChangeHandlerFunction(id) {\n  const newId = \"_new_\" + id.name;\n  return import_compiler58.types.arrowFunctionExpression(\n    [withPreviousLocation(import_compiler58.types.identifier(newId), id)],\n    import_compiler58.types.blockStatement([\n      import_compiler58.types.expressionStatement(\n        import_compiler58.types.assignmentExpression(\n          \"=\",\n          withPreviousLocation(import_compiler58.types.identifier(id.name), id),\n          withPreviousLocation(import_compiler58.types.identifier(newId), id)\n        )\n      )\n    ])\n  );\n}\n\n// src/translator/visitors/text.ts\nvar import_compiler59 = require(\"@marko/compiler\");\nvar text_default = {\n  translate: {\n    exit(text) {\n      if (isNonHTMLText(text)) return;\n      writeTo(text)`${text.node.value}`;\n      enterShallow(text);\n      text.remove();\n    }\n  }\n};\n\n// src/translator/index.ts\nvar visitors = extractVisitors({\n  Program: program_default,\n  Function: function_default,\n  ReferencedIdentifier: referenced_identifier_default,\n  ImportDeclaration: import_declaration_default,\n  MarkoDocumentType: document_type_default,\n  MarkoDeclaration: declaration_default,\n  MarkoCDATA: cdata_default,\n  MarkoText: text_default,\n  MarkoTag: tag_default,\n  MarkoPlaceholder: placeholder_default,\n  MarkoScriptlet: scriptlet_default,\n  MarkoComment: comment_default\n});\nvar tagDiscoveryDirs = [\"tags\"];\nvar preferAPI = \"tags\";\nvar { transform, analyze, translate } = visitors;\nvar taglibs = [\n  [\n    __dirname,\n    {\n      ...core_default,\n      migrate: visitors.migrate\n    }\n  ]\n];\nfunction getRuntimeEntryFiles(output, optimize) {\n  return [\n    `${runtime_info_default.name}${optimize ? \"\" : \"/debug\"}/${output === \"html\" ? \"html\" : \"dom\"}`\n  ];\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  analyze,\n  getRuntimeEntryFiles,\n  internalEntryBuilder,\n  preferAPI,\n  tagDiscoveryDirs,\n  taglibs,\n  transform,\n  translate\n});\n"],"names":["mod","__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__copyProps","to","from","except","desc","key","call","get","enumerable","__toESM","isNodeMode","target","__esModule","value","index_exports","__export","all","name2","analyze","getRuntimeEntryFiles","internalEntryBuilder","entry_builder_default","preferAPI","tagDiscoveryDirs","taglibs","transform","translate","module","exports","runtime_info_default","name","require","taglibId","import_compiler","import_babel_utils","assertNoSpreadAttrs","tag","attr2","isMarkoSpreadAttribute","buildCodeFrameError","node","assertNoBodyContent","body","length","AccessorPrefix4","AccessorProp4","attrs_default","migrate","assertNoArgs","assertNoParams","assertNoAttributes","assertNoAttributeTags","diagnosticDeprecate","label","fix","tagVar","var","type","remove","constTag","types","markoTag","stringLiteral","markoAttribute","identifier","markoTagBody","replaceWith","attributes","autocomplete","displayText","description","snippet","import_compiler25","import_babel_utils18","AccessorPrefix","AccessorProp","import_babel_utils2","evaluate","extra","confident","computed","computeNode","nullable","isNullableExpr","expr","operator","right","left","argument","consequent","alternate","expression","expressions","import_compiler24","import_babel_utils17","forEachIdentifier","cb","prop","properties","el","elements","import_compiler3","import_babel_utils4","import_babel_utils3","isTranslate","getFile","___compileStage","import_compiler2","skip","Symbol","traverseReplace","container","enter3","Array","isArray","i","keys","VISITOR_KEYS","replacement","traverseContains","check","item","traverse","visit2","parent","grandParent","countsForFile","WeakMap","generateUid","file","counts","cache","markoOpts","filename","opts","cacheKey","Map","program","path","countName","match","exec","name3","count","set","Math","max","scope","globals","isBinding","getInitialCounts","replace","uniqueName","generateUidIdentifier","sharedUIDsForFile","getSharedUid","sharedUIDs","usedSharedUid","has","AccessorPrefix2","AccessorProp2","import_babel_utils5","isOutputHTML","getMarkoOpts","output","isOutputDOM","isOptimize","optimize","getAccessorPrefix","getAccessorProp","getMarkoRoot","path5","curPath","parentPath","isMarko","getExprRoot","getFnRoot","fnPath","isProgram","isFunction","declare","isInvokedFunction","callee","Sorted","constructor","compare","this","add","data","addSorted","joinRepeatable","union","a","b","aLen","bLen","aIndex","bIndex","result","aValue","bValue","delta","push","unionSortedRepeatable","find","findSorted","findIndex","findIndexSorted","isSuperset","superset","subset","subLen","supLen","supIndex","concat","filter","len","forEach","pos","mid","cur","compareResult","next","import_compiler23","import_compiler22","import_babel_utils16","import_path2","bindingHasDownstreamExpressions","binding","downstreamExpressions","size","alias","aliases","propertyAliases","values","import_compiler5","import_babel_utils6","kState","build","entryFile","state","imports","map","it","importDeclaration","init","unshift","importSpecifier","expressionStatement","callExpression","visit","visitChild","analyzedTags","metadata","marko","resolveRelativePath","hasInteractiveChild","isInteractive","getKnownAttrValues","attrs2","import_babel_utils7","getTagName","isCoreTag","isMarkoTag","tagDef","getTagDef","isCoreTagName","isConditionTag","import_compiler7","import_babel_utils8","stringifyClassObject","stringifyStyleObject","test","toDelimitedString","val","delimiter","stringify","part","str","sep","v","isEventHandler","getEventHandlerName","slice","toLowerCase","toString","unsafeXMLReg","replaceUnsafeXML","c","escapeXML","unsafeScriptReg","escapeScript","unsafeStyleReg","escapeStyle","kTouchedIterator","Generator","AsyncGenerator","async","toAccess","accessor","start","patchIteratorNext","proto","classAttr","stringAttr","styleAttr","attr","isVoid","attrAssignment","RegExp","source","nonVoidAttr","KNOWN_SYMBOLS2","symbol","AggregateError","of","ArrayBuffer","isView","Atomics","and","compareExchange","exchange","isLockFree","load","notify","or","store","sub","wait","BigInt","asIntN","asUintN","BigInt64Array","BigUint64Array","Boolean","console","assert","clear","countReset","debug","dir","dirxml","error","group","groupCollapsed","groupEnd","info","log","table","time","timeEnd","timeLog","timeStamp","trace","warn","DataView","Date","now","parse","UTC","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","Error","EvalError","Float32Array","Float64Array","Function","globalThis","atob","btoa","clearImmediate","clearInterval","clearTimeout","crypto","getRandomValues","randomUUID","fetch","performance","queueMicrotask","setImmediate","setInterval","setTimeout","structuredClone","URL","URLSearchParams","WritableStream","Int16Array","Int32Array","Int8Array","Intl","Collator","DateTimeFormat","DisplayNames","getCanonicalLocales","ListFormat","Locale","NumberFormat","PluralRules","RelativeTimeFormat","Segmenter","supportedValuesOf","isFinite","isNaN","JSON","groupBy","abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","floor","fround","hypot","imul","log10","log1p","log2","min","pow","random","round","sign","sin","sinh","sqrt","tan","tanh","trunc","Number","isInteger","isSafeInteger","parseFloat","parseInt","assign","defineProperties","entries","freeze","fromEntries","getOwnPropertyDescriptors","getOwnPropertySymbols","is","isExtensible","isFrozen","isSealed","preventExtensions","seal","setPrototypeOf","Promise","Proxy","RangeError","ReferenceError","Reflect","apply","construct","deleteProperty","ownKeys","Set","String","fromCharCode","fromCodePoint","raw","for","SyntaxError","TypeError","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","URIError","WeakSet","singleQuoteAttrReplacements","doubleQuoteAttrReplacements","needsQuotedAttr","lastIndex","replaceUnsafeSingleQuoteAttrChar","escapeSingleQuotedAttrValue","replaceUnsafeDoubleQuoteAttrChar","escapeDoubleQuotedAttrValue","import_compiler6","isValidPropertyIdentifier","toPropertyName","numericLiteral","toObjectProperty","objectProperty","toMemberExpression","object","optional","optionalMemberExpression","memberExpression","pureDOMFunctions","importRuntime","importStar","getRuntimePath","callRuntime","args","callExpression2","filteredArgs","arg","unaryExpression","filterArguments","leadingComments","getHTMLRuntime","getCompatRuntimeFile","modules","import_compiler10","import_babel_utils11","reasonExprs","keyedReasonExprs","serializeKeysByBinding","serializeKeyBySourceModifier","forceOwnersSerialize","forceSectionSerialize","addOwnersSerializeReason","reason","addSectionSerializeReason","section","forceSerializeKey","getSectionPropSerializeReasonKey","serializeReason","delete","setSectionSerializeReason","forceBindingSerialize","prefix2","getBindingSerializeReasonKey","serializeReasons","setSectionKeyedSerializeReason","isBindingForceSerialized","addBindingSerializeReasonExpr","addKeyedSerializeReasonExpr","existingExpr","keyedExprs","addKeyedSerializeReason","existingReason","mergeSerializeReasons","addBindingSerializeReason","getSectionSerializeReason","getBindingSerializeReason","applySerializeReasonExprs","exprs","reason2","getSerializeSourcesForExprs","getSerializeSourcesForExpr","isReferencedExtra","getSerializeSourcesForRef","referencedBindings","serializeSource","exprSources","bindingUtil","ref","allSerializeSources","serializeSources","import_babel_utils9","createProgramState","getProgram","createSectionState","arrayOfSectionData","id","import_compiler9","import_babel_utils10","MARKO_FILE_REG","analyzeTagNameType","tagNameType","isStringLiteral","isNativeTag","tagNameNullable","isIdentifier","pending","tagNameImported","pop","isConditionalExpression","isLogicalExpression","isAssignmentExpression","isBinaryExpression","isTemplateLiteral","isNullLiteral","getBinding","kind","decl","specifiers","some","isImportDefaultSpecifier","resolvedImport","resolveTagImport","bindingTag","bindingTagName","tagNameDynamic","analyzeExpressionTagName","childFile","loadFileForTag","ast","featureType","needsCompat","sectionUtil","startSection","parentSection","getOrCreateSection","sectionNamePath","sectionName","programExtra","hub","sections","loc","depth","sectionAccessor","params","referencedClosures","referencedHoists","bindings","hoisted","isHoistThrough","content","getContentInfo","upstreamExpression","downstreamBinding","hasAbortSignal","isBranch","attributeTags","isNativeNode","getSectionForBody","getSection","currentPath","getScopeIdIdentifier","getSectionParentIsOwner","setSectionParentIsOwner","_getScopeIdentifier","forEachSection","fn","contentInfo","startType","endType","singleChild","endIndex","getNodeContentType","startIndex","extraMember","isAttributeTag","tagSection","isSerializedSection","isImmediateOwner","isDynamicClosure","closure","isDirectClosure","isSameOrChildSection","other","import_compiler21","import_babel_utils15","import_path","regexpCharsReg","import_compiler20","import_babel_utils14","import_compiler17","import_babel_utils13","getParentTag","import_compiler11","enter","modulePlugin","plugin","isModulePlugin","default","isFunctionPlugin","exit","translateByTarget","html","dom","import_compiler16","import_compiler13","import_babel_utils12","import_compiler12","simplifyFunction","functionExpression","generator","getTemplateContentName","getExprIfSerialized","logicalExpression","resolveSerializeReasonId","inputSerializeReasons","getSerializeGuard","html_default","flushInto","writeHTMLResumeStatements","replaceNode","renderContent","child","isImportDeclaration","isExportDeclaration","isMarkoScriptlet","static","replaceWithMultiple","serializeId","contentId","contentFn","arrowFunctionExpression","blockStatement","exportDefault","exportDefaultDeclaration","variableDeclaration","variableDeclarator","read","declared","getReadReplacement","replaceBindingReadNode","getRegisteredFnExpression","classProperty","classPrivateProperty","isRegisteredFnExtra","registeredFnDeclarations","registeredFnDeclarationsByBody","registerId","addRegisteredDeclarations","replaceRegisteredFunctionNode","referencedBindingsInFunction","referencesScope","import_compiler14","normalizeStringExpression","parts","strs","curStr","nextIndex","exprLen","shiftItems","quasis","j","templateLiteral","templateElement","appendLiteral","arr","list","offset","getWalks","getWalkComment","getSteps","walkCodeToName","enter2","exit2","enterShallow","code","steps","walks","walkComment","walkString","walkCodes","step","lastIndexOf","current","walk","nCodeString","writeTo","number","toCharString","startCode","rangeSize","multiplier","getWalkString","postfix","walkLiteral","join","getWrites","getTrailerWrites","trailer","exprsLen","writes","consumeHTML","trailers","writeResult","trailerResult","sequenceExpression","flushBefore","insertBefore","getSectionMeta","writePrefix","writePostfix","setup","getSetup","markNode","nodeBinding","getScopeAccessorLiteral","tagsWithReturn","getSectionReturnValueIdentifier","setReturnValueIdentifier","return_default","assertNoVar","assertAllowedAttributes","parentTag","isControlFlowTag","valueChange","TagVariableChange","getSerializedAccessors","setSectionSerializedValue","returnId","addValue","hasDownstreamIntersections","parseOptions","openTagOnly","descriptionMoreURL","import_compiler18","getDeclaredBindingExpression","upstreamAlias","property","import_compiler19","toFirstExpressionOrBlock","stmts","isExpressionStatement","toParenthesizedExpressionIfNeeded","parenthesizedExpression","getSignals","getClosureSignalBuilder","_setClosureSignalBuilder","setClosureSignalBuilder","builder","setBindingSerializedValue","getScopeAccessor","nonAnalyzedForceSerializedSection","setSerializedValue","getSectionWriteScopeBuilder","setSectionWriteScopeBuilder","addWriteScopeBuilder","prev","htmlDynamicClosureInstancesIdentifier","getHTMLSectionStatements","getHoistFunctionsIdsMap","getHoistFunctionIdentifier","hoistedBinding","idsMap","unimplementedBuild","getSignal","generateSignalName","signals","signal","exportName","export","domExports","intersection","render","renderReferencedBindings","effect","effectReferencedBindings","subscribers","subscribe","scopeOffset","intersectionMeta","getSignalFn","scopeIdentifier","getScopeExpression","initValue","runtimeHelper","isParamBinding","needsCache","needsMarks","hoists","valueAccessor","isIntersection","isValue","canUseCalleeDirectly","valueParam","index","end","aliasSignal","getTranslatedExtraArgs","dynamicClosureArgs","dynamicClosureSignalIdentifier","closureSections","closureSection","sources","prependStatements","effectIdentifier","createScopeReadPattern","arguments","param","hasTranslatedExtraArgs","emptyExtraArgs","extraArgs","replaceRenderNode","provider","subscriber","p","providerSignal","replaceNullishAndEmptyFunctionsWith0","isArrowFunctionExpression","isBlockStatement","isUnaryExpression","isNumericLiteral","addStatement","targetSection","statement","usedReferences","statements","addEffectReferences","addRenderReferences","parentSignal","getResumeRegisterId","getTemplateId","usedRegisterIdsBySection","getRegisterUID","used","baseId","writeSignals","accessors","Getter","currentSection","getSectionInstancesAccessorLiteral","hoistIdentifier","sort","sortSignals","value2","effectDeclarator","replaceEffectNode","isScopeIdentifier","isCallExpression","register","signalDeclarator","signalDeclaration","isFunctionExpression","functionDeclaration","isExpression","exportNamedDeclaration","signalStatements","toReturnedFunction","rawFn","returnStatement","aReferencedBindings","getReferencedBindings","bReferencedBindings","diff","reserve","getMappedId","reference","addHTMLEffectCall","allSignals","scopeIdIdentifier","closureSignal","newExpression","ClosureScopes","getDynamicClosureIndex","ClosureSignalIndex","sectionDynamicSubscribers","subscribersIdentifier","getSectionInstancesAccessor","signalRefs","serializedLookup","serializedProperties","sectionSerializeReason","compareSerializeReasons","ownerAccessor","Owner","ownerReason","getOwnerExpr","writeScopeBuilder","shorthand","writeScopeArgs","objectExpression","debugVars","root","access","locExpr","line","column","arrayExpression","filenameRelative","writeScopeCall","additionalStatements","returnIdentifier","replaceAssignedNode","replaceBindingReadNode2","replaceRegisteredFunctionNode2","isAssignedBindingExtra","buildAssignment","assignment","binaryExpression","prefix","assignments","resultId","assignmentExpression","registeredFnsForProgram","getRegisteredFnExpression2","registedFns","dom_default","templateIdentifier","template","walksIdentifier","setupIdentifier","inputBinding","programInputSignal","styleFile","fs","fileSystem","base","leftDot","indexOf","rightDot","closeBracket","openBracket","getBase","styleMatch","file2","readdirSync","dirname","getStyleFile","importDefault","forEachSectionReverse","childSection","tagParamsSignal","walks2","writes2","setup2","renderer","registeredFns","registeredFn","assignmentPattern","writeRegisteredFns","program_default","crawl","trackParamsReferences","input","returnValueExpr","getBindings","readsByExpression","getReadsByExpression","readsByFn","getReadsByFunction","mergedReferences","getMergedReferences","nodes","targetExtra","reads","isEffect","additionalReads","intersectionsBySection","resolveReferencedBindings","pruneBinding","resolveBindingSources","assignmentSections","assignedSection","section2","binding2","addKeyedSerializeReasonRef","addSectionSerializeReasonRef","getDirectClosures","kBranchSerializeReason","addSectionSerializeReasonExpr","intersections","numReferences","binding1","sourceSection","upstreamReason","keyedReason","finalizeSectionSerializeReasons","returnSerializeReason","intersectionIndex","bindings2","isOwnedBinding","lastBindingIndex","bindingIndex","at","getMaxOwnSourceOffset","finalizeReferences","buildTemplateExports","visitedFiles","resolved","loadFileForImport","req","resolveRelativeToEntry","compatFile","templateExport","props","rootDepth","rootPattern","objectPattern","nestedPatterns","propertyValue","propertyKey","isShorthand","pattern","relativeDepth","nestedPattern","createScopeReadExpression","propName","withPreviousLocation","newNode","originalNode","kIsInvoked","getNextBindingId","setNextBindingId","createBinding","excludeProperties","propBinding","trackVarReferences","canonicalUpstreamAlias","getCanonicalBinding","createBindingsAndTrackReferences","paramsBinding","trackHoistedReference","referencePath","referenceSection","hoistSection","ancestor","getCommonSection","createRead","trackReference","trackAssignment","setReferencesScope","fnRoot","lVal","babelBinding","referencePaths","constantViolations","isUpdateExpression","trackReferencesForBinding","patternBinding","element","propPath","isMemberExpression","getMemberExpressionPropString","isEventOrChangeHandler","exprRoot","exprExtra","addReadToExpression","fnExtra","mergeReferences","compareIntersections","lenDelta","setBindingValueExpr","valueExpr","bindingValueExprs","resolvedSources","resolveDerivedSources","seen","onlyInputSources","dropReferences","pruned","getAllTagReferenceNodes","referenceNodes","includeId","shouldPrune","exprReference","resolveExpressionReference","readBinding","readProps","aliasProps","kDOMBinding","await_default","tagBody","valueAttr","isMarkoAttribute","isSpreadElement","bodySection","valueExtra","nodeRef2","import_compiler26","import_babel_utils19","client_default","rawValue","trim","parseStatements","markoScriptlet","rawOpenTag","import_compiler28","import_babel_utils20","import_compiler27","translateVar","initialValue","const_default","varBinding","derivation","import_compiler29","import_babel_utils21","debug_default","debuggerStatement","import_babel_utils27","import_compiler30","import_babel_utils22","attrTagToIdentifierLookup","getAttrTagIdentifier","meta","analyzeAttributeTags","attrTags2","lookup","attrTagNodesByName","sampleAttrTagsForControlFlow","createAttrTagMeta","isRepeated","isLoopTag","curGroup","crawlAttrTags","oldMeta","attrTagMeta","dynamic","repeated","controlFlowTag","sampleAttrName","attributeTagGroup","attrTagNodes","hasRepeatedDynamicAttrTags","attrTagNames","tagName","conditionRoot","seenBranches","attrTag2","curConditionRoot","getConditionRoot","getPrevSibling","import_compiler34","import_babel_utils26","import_compiler33","import_babel_utils25","import_babel_utils24","import_compiler31","import_babel_utils23","css_px_props_default","kNativeTagBinding","kSkipMark","kGetterId","htmlSelectArgs","native_tag_default","escape","buildError","buildUndefined","relatedControllable","spreadReferenceNodes","attrExprExtras","hasDynamicAttributes","hasEventHandlers","getRelatedControllable","exclusiveGroups","open","openChange","checked","checkedChange","checkedValue","checkedValueChange","assertExclusiveControllableGroups","tagExtra","toIdentifier","attrs","every","refSection","write2","getterId","visitAccessor","usedAttrs","getUsedAttrs","staticAttrs","staticControllable","skipExpression","writeAtStartOfBody","spreadExpression","helper","spreadIdentifier","valueReferences","htmlType","ifStatement","selectArgs","markerSerializeReason","varName","getterFnIdentifier","firstAttr","nodeExpr","staticItems","dynamicItems","dynamicValues","stmt","trackDelimitedAttrValue","special","maybeStaticAttrs","spreadProps","skipProps","attr3","spreadElement","reverse","propsToExpression","trackDelimitedAttrObjectProperties","trackDelimitedAttrArrayItems","evalItem","obj","staticProps","dynamicProps","keyEval","propEval","kOnlyChildInParent","kNodeRef","isOnlyChildInParent","branchSize","getOptimizedOnlyChildNodeBinding","parentTagName","for_default","isAttrTag","allowAttrs","getForType","LoopScopeMap","onlyChildInParentOptimization","forAttrs","forType","bodyStatements","singleNodeOptimization","branchSerializeReason","forTagArgs","getBaseArgsInForTag","forTagHTMLRuntime","forTypeToHTMLResumeRuntime","forTypeToRuntime","by","forTypeToDOMRuntime","referencedBindings2","loopArgs","controlFlow","in","contentProps","translateAttrs","templateExports","contentKey","attrTagLookup","usesExport","addDynamicAttrTagStatements","translatedAttrTag","prevProp","findObjectProperty","contentExpression","serialized","isTransparentTag","getNonAttributeTagParent","buildContent","contentProp","getTranslatedBodyContentProperty","ifTag","consequentStatements","getConditionTestValue","addAllAttrTagsAsDynamic","nextTag","testValue","alternateStatements","translateIfAttrTag","forTag","buildForRuntimeCall","translateForAttrTag","define_default","translatedAttrs","import_compiler36","import_babel_utils28","effect_default","import_babel_utils29","export_default","import_compiler37","import_babel_utils30","kNodeBinding","kGetterId2","html_comment_default","needsBinding","needsGetter","isMarkoPlaceholder","isMarkoText","references","templateQuasis","templateExpressions","currentQuasi","text","import_compiler38","import_babel_utils31","kNodeBinding2","kGetterId3","html_script_default","bodyPlaceholderNodes","hasBodyPlaceholders","isHTML","getUsedAttrs2","referencePlaceholder","preserveWhitespace","import_compiler39","import_babel_utils32","kNodeBinding3","kGetterId4","html_style_default","getUsedAttrs3","import_compiler40","import_babel_utils33","id_default","import_compiler42","import_babel_utils34","import_compiler41","BRANCHES_LOOKUP","IfTag","assertHasBody","assertHasValueAttribute","assertHasPrecedingCondition","ifAttr","msg","assertOptionalIfAttribute","assertValidCondition","isLastBranch","branches","getBranches","ifTagSection","ifTagExtra","mergeReferenceNodes","ConditionalScope","branchTag","branchBodySection","isRoot","getNextSibling","branchSerializeReasons","branchBody","testAttr","curStatement","cbNode","getSerializeGuardForAny","rendererIdentifiers","conditionalExpression","ElseIfTag","ElseTag","isMarkoComment","curTag","reasons","import_babel_utils35","import_default","import_compiler43","import_babel_utils36","let_default","valueChangeAttr","valueSection","import_compiler44","import_babel_utils37","kRef","lifecycle_default","lifecycleAttrsRef","import_compiler45","import_babel_utils38","log_default","import_compiler46","import_babel_utils39","htmlScriptTagAlternateMsg","script_default","valueFn","isAwaitExpression","seenValueAttr","isFunction2","inlineBody","hasDeclaration","isDeclaration","await","import_compiler47","import_babel_utils40","server_default","import_compiler48","import_babel_utils41","static_default","import_compiler49","import_babel_utils42","import_magic_string","import_path3","STYLE_EXT_REG","htmlStyleTagAlternateMsg","style_default","ext","sourceMaps","markoText","resolveVirtualDependency","getStart","getEnd","magicString","generateMap","includeContent","toUrl","importPath","virtualPath","basename","importDefaultSpecifier","import_compiler50","import_babel_utils43","kDOMBinding2","try_default","splice","core_default","cdata_default","cdata","comment_default","comment","declaration_default","document_type_default","documentType","import_compiler51","import_babel_utils44","function_default","markoRoot","isVariableDeclarator","isObjectMethod","import_babel_utils45","import_declaration_default","importDecl","tagImport","tags","includes","import_compiler53","isNonHTMLText","placeholder","isMarkoTagBody","kNodeBinding4","kSiblingText","placeholder_default","isVoid2","placeholderExtra","contentType","analyzeSiblingText","canWriteHTML","method","siblingText","import_compiler54","abortIdsByExpressionForSection","referenced_identifier_default","hasBinding","throwStatement","exprId","abortIdsByExpression","scriptlet_default","scriptlet","import_compiler58","import_babel_utils49","import_babel_utils46","attribute_tag_default","findParentTag","import_compiler56","import_babel_utils47","import_path4","kChildScopeBinding","kChildOffsetScopeBinding","kChildInputSerializePropIds","custom_tag_default","assertAttributesOrSingleArg","getTagTemplate","charAt","toUpperCase","childScopeBinding","attrExprs","varSerializeReason","childProgram","childExtra","childInputBinding","inputExpr","analyzeAttrs","mapChildReasonToLocalReason","childInputSerializePropIds","propId","one","many","fromIter","tagIdentifier","relativePath","getTagRelativePath","isCircularRequest","inputExport","childScopeSerializeReason","childSerializeReasonIds","childSerializeReasonExpr","hasDynamicReasons","hasSkippedReasons","peekScopeId","contentPath","renderTagExpr","callStatement","translateHTML","childExports","importOrSelfReferenceName","writeAttrsToExports","circular","attrTagCallsByTag","importNamed","injectWalks","translateDOM","rootTagExtra","rootAttrExprs","known","nodeReferencesByGroup","analyzeDynamicChildGroup","groupReferences","firstTag","attrTagName","childAttrExports","childUsesGroupProp","groupExtra","groupKnownValue","attrValueExtra","importAlias","tagInputIdentifier","identifierToSignal","translatedProps","attrTagCallsForTag","attrTagCall","statementsByGroup","translateDynamicAttrTagChildInGroup","childAttrExport","decls","attrExportIdentifier","contentExportIdentifier","missing","getMissingPropValue","buildUndefined2","spreadId","request","nameHint","childReason","filterMap","curExpr","curBinding","nestedExpr","resolveChildInputExpr","resolve","always","import_compiler57","import_babel_utils48","kDOMBinding3","kChildOffsetScopeBinding2","dynamic_tag_default","assertAttributesOrArgs","isClassAPI","hasVar","tagExpression","hasTagArgs","serializeArg","dynamicTagExpr","dynamicScopeIdentifier","tagVarSignal","argsOrInput","isObjectExpression","TAG_NAME_IDENTIFIER_REG","BINDING_CHANGE_HANDLER","tag_default","bound","getChangeHandler","hook","analyzer","translator","watchFiles","modifier","tagNameId","tagNameVarPath","changeAttrName","buildChangeHandlerFunction","existingChangedAttr","changeHandlerAttr","changeHandlerId","changeHandlerConst","insertAfter","unshiftContainer","isPrivateName","cloneNode","newId","visitors","visitors2","_name","extractVisitors","Program","ReferencedIdentifier","ImportDeclaration","MarkoDocumentType","MarkoDeclaration","MarkoCDATA","MarkoText","MarkoTag","MarkoPlaceholder","MarkoScriptlet","MarkoComment"],"sourceRoot":""}