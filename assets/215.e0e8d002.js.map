{"version":3,"file":"215.e0e8d002.js","mappings":"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","sources":["webpack:///../../node_modules/@marko/translator-tags/dist/index.js"],"sourcesContent":["\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  analyze: () => analyze2,\n  getRuntimeEntryFiles: () => getRuntimeEntryFiles,\n  internalEntryBuilder: () => entry_builder_default,\n  taglibs: () => taglibs,\n  transform: () => transform,\n  translate: () => translate2\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/util/is-core-tag.ts\nvar import_babel_utils = require(\"@marko/babel-utils\");\nvar taglibId = \"marko-core\";\nvar interopTaglibId = \"@marko/translator-interop-class-tags\";\nfunction isCoreTag(tag) {\n  const id = tag.isMarkoTag() && (0, import_babel_utils.getTagDef)(tag)?.taglibId;\n  return id === taglibId || id === interopTaglibId;\n}\nfunction isCoreTagName(tag, name) {\n  return isCoreTag(tag) && tag.node.name.value === name;\n}\n\n// src/core/__flush_here_and_after__.ts\nvar import_babel_utils2 = require(\"@marko/babel-utils\");\nvar flush_here_and_after_default = {\n  transform: [\n    (tag) => {\n      if ((0, import_babel_utils2.getTagDef)(tag)?.renderer) {\n        return;\n      }\n      tag.replaceWithMultiple(tag.node.body.body);\n    }\n  ]\n};\n\n// src/core/attrs.ts\nvar import_compiler = require(\"@marko/compiler\");\nvar attrs_default = {\n  migrate: [\n    (tag) => {\n      const tagVar = tag.node.var;\n      if (tagVar && !(tagVar.type === \"Identifier\" && tagVar.name === \"input\")) {\n        const constTag = import_compiler.types.markoTag(\n          import_compiler.types.stringLiteral(\"const\"),\n          [import_compiler.types.markoAttribute(\"value\", import_compiler.types.identifier(\"input\"))],\n          import_compiler.types.markoTagBody([])\n        );\n        constTag.var = tagVar;\n        tag.replaceWith(constTag);\n      } else {\n        tag.remove();\n      }\n    }\n  ],\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"attrs/{ ... }\",\n      description: \"Use to receive the attributes passed into this template.\",\n      snippet: \"attrs/{ $1 }$2\"\n    }\n  ]\n};\n\n// src/core/client.ts\nvar import_babel_utils3 = require(\"@marko/babel-utils\");\nvar import_compiler2 = require(\"@marko/compiler\");\nvar client_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^client\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils3.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler2.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler2.types.markoScriptlet(body, true, \"client\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"client <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the client.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#client-javascript\"\n    }\n  ]\n};\n\n// src/core/condition/else.ts\nvar import_babel_utils12 = require(\"@marko/babel-utils\");\n\n// src/core/condition/if.ts\nvar import_babel_utils11 = require(\"@marko/babel-utils\");\nvar import_compiler18 = require(\"@marko/compiler\");\n\n// src/util/references.ts\nvar import_compiler16 = require(\"@marko/compiler\");\n\n// src/visitors/program/index.ts\nvar import_babel_utils10 = require(\"@marko/babel-utils\");\nvar import_compiler15 = require(\"@marko/compiler\");\nvar import_path = __toESM(require(\"path\"));\n\n// src/util/binding-has-downstream-expressions.ts\nfunction bindingHasDownstreamExpressions(binding) {\n  if (binding.downstreamExpressions.size) return true;\n  for (const alias of binding.aliases) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  return false;\n}\n\n// src/util/entry-builder.ts\nvar import_babel_utils4 = require(\"@marko/babel-utils\");\nvar import_compiler3 = require(\"@marko/compiler\");\nvar kState = Symbol();\nvar entry_builder_default = {\n  build(entryFile) {\n    const state = entryFile[kState];\n    if (!state) {\n      throw entryFile.path.buildCodeFrameError(\n        \"Unable to build hydrate code, no files were visited before finalizing the build\"\n      );\n    }\n    const body = state.imports.map(\n      (it) => import_compiler3.types.importDeclaration([], import_compiler3.types.stringLiteral(it))\n    );\n    if (state.init) {\n      body.unshift(\n        import_compiler3.types.importDeclaration(\n          [import_compiler3.types.importSpecifier(import_compiler3.types.identifier(\"init\"), import_compiler3.types.identifier(\"init\"))],\n          import_compiler3.types.stringLiteral(\n            `@marko/runtime-tags/${entryFile.markoOpts.optimize ? \"\" : \"debug/\"}dom`\n          )\n        )\n      );\n      body.push(\n        import_compiler3.types.expressionStatement(import_compiler3.types.callExpression(import_compiler3.types.identifier(\"init\"), []))\n      );\n    }\n    return body;\n  },\n  visit(file, entryFile, visitChild) {\n    const state = entryFile[kState] ||= {\n      imports: [],\n      init: false\n    };\n    const { analyzedTags } = file.metadata.marko;\n    state.imports.push(\n      (0, import_babel_utils4.resolveRelativePath)(entryFile, file.opts.filename)\n    );\n    state.init ||= file.path.node.extra.hasInteractiveChild || file.path.node.extra.isInteractive || false;\n    for (const tag of analyzedTags || []) {\n      visitChild(tag);\n    }\n  }\n};\n\n// src/util/marko-config.ts\nfunction isOutputHTML() {\n  return getMarkoOpts().output === \"html\";\n}\nfunction isOutputDOM() {\n  return !isOutputHTML();\n}\nfunction getMarkoOpts() {\n  return currentProgramPath.hub.file.markoOpts;\n}\nfunction isOptimize() {\n  return getMarkoOpts().optimize;\n}\n\n// src/util/sections.ts\nvar import_babel_utils6 = require(\"@marko/babel-utils\");\nvar import_compiler5 = require(\"@marko/compiler\");\n\n// src/util/state.ts\nvar createProgramState = (init) => {\n  const map = /* @__PURE__ */ new WeakMap();\n  return [\n    () => {\n      let state = map.get(currentProgramPath);\n      if (!state) {\n        map.set(currentProgramPath, state = init());\n      }\n      return state;\n    },\n    (value) => {\n      map.set(currentProgramPath, value);\n    }\n  ];\n};\nfunction createSectionState(key, init) {\n  return [\n    (section) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      const sectionData = arrayOfSectionData[section.id] ??= init && init(section);\n      return sectionData;\n    },\n    (section, value) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      arrayOfSectionData[section.id] = value;\n    }\n  ];\n}\n\n// src/util/tag-name-type.ts\nvar import_babel_utils5 = require(\"@marko/babel-utils\");\nvar import_compiler4 = require(\"@marko/compiler\");\n\n// src/util/with-previous-location.ts\nfunction withPreviousLocation(newNode, originalNode) {\n  newNode.start = originalNode.start;\n  newNode.loc = originalNode.loc;\n  newNode.end = originalNode.end;\n  return newNode;\n}\n\n// src/util/tag-name-type.ts\nvar MARKO_FILE_REG = /^<.*>$|\\.marko$/;\nvar TAG_NAME_IDENTIFIER_REG = /^[A-Z][a-zA-Z0-9_$]*$/;\nfunction analyzeTagNameType(tag) {\n  const extra = tag.node.extra ??= {};\n  if (extra.tagNameType === void 0) {\n    const name = tag.get(\"name\");\n    if (name.isStringLiteral()) {\n      extra.tagNameType = name.node.value[0] === \"@\" ? 3 /* AttributeTag */ : (0, import_babel_utils5.isNativeTag)(tag) ? 0 /* NativeTag */ : 1 /* CustomTag */;\n      if (extra.tagNameType === 1 /* CustomTag */) {\n        const bindingName = name.node.value;\n        const bindingIdentifier = tag.scope.getBinding(bindingName)?.identifier;\n        if (bindingIdentifier && TAG_NAME_IDENTIFIER_REG.test(bindingIdentifier.name)) {\n          const tagIdentifier = withPreviousLocation(\n            import_compiler4.types.identifier(bindingName),\n            name.node\n          );\n          tagIdentifier.extra = {\n            referencedBindings: bindingIdentifier.extra?.binding\n          };\n          analyzeExpressionTagName(name.replaceWith(tagIdentifier)[0], extra);\n        } else {\n          const childFile = (0, import_babel_utils5.loadFileForTag)(tag);\n          const childProgram = childFile?.ast.program;\n          if (childProgram?.extra.featureType === \"class\") {\n            extra.tagNameType = 2 /* DynamicTag */;\n            extra.featureType = \"class\";\n          }\n        }\n      }\n      extra.tagNameNullable = extra.tagNameNullable = false;\n    } else {\n      analyzeExpressionTagName(name, extra);\n    }\n    if (extra.tagNameType === void 0) {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n  }\n  return extra.tagNameType;\n}\nfunction analyzeExpressionTagName(name, extra) {\n  const pending = [name];\n  let path3;\n  let type;\n  let nullable = false;\n  let tagNameImported;\n  while ((path3 = pending.pop()) && type !== 2 /* DynamicTag */) {\n    if (path3.isConditionalExpression()) {\n      pending.push(path3.get(\"consequent\"));\n      if (path3.node.alternate) {\n        pending.push(path3.get(\"alternate\"));\n      }\n    } else if (path3.isLogicalExpression()) {\n      if (path3.node.operator === \"||\") {\n        pending.push(path3.get(\"left\"));\n      } else {\n        nullable = true;\n      }\n      pending.push(path3.get(\"right\"));\n    } else if (path3.isAssignmentExpression()) {\n      pending.push(path3.get(\"right\"));\n    } else if (path3.isBinaryExpression()) {\n      type = path3.node.operator !== \"+\" || type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path3.isStringLiteral() || path3.isTemplateLiteral()) {\n      type = type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path3.isNullLiteral()) {\n      nullable = true;\n    } else if (path3.isIdentifier()) {\n      if (path3.node.name === \"undefined\") {\n        nullable = true;\n        continue;\n      }\n      const binding = path3.scope.getBinding(path3.node.name);\n      if (!binding) {\n        type = 2 /* DynamicTag */;\n        continue;\n      }\n      if (binding.kind === \"module\") {\n        const decl = binding.path.parent;\n        if (MARKO_FILE_REG.test(decl.source.value) && decl.specifiers.some((it) => import_compiler4.types.isImportDefaultSpecifier(it))) {\n          const resolvedImport = (0, import_babel_utils5.resolveTagImport)(name, decl.source.value) || decl.source.value;\n          if (type === 0 /* NativeTag */ || tagNameImported && tagNameImported !== resolvedImport) {\n            type = 2 /* DynamicTag */;\n            tagNameImported = void 0;\n          } else {\n            type = 1 /* CustomTag */;\n            tagNameImported = resolvedImport;\n          }\n        } else {\n          type = 2 /* DynamicTag */;\n        }\n        continue;\n      }\n      const bindingTag = binding.path;\n      if (bindingTag.isMarkoTag() && binding.kind === \"local\") {\n        const bindingTagName = bindingTag.get(\"name\").node.value;\n        if (bindingTagName === \"const\") {\n          pending.push(\n            bindingTag.get(\"attributes\")[0].get(\"value\")\n          );\n          continue;\n        }\n        if (bindingTagName === \"let\") {\n          type = 2 /* DynamicTag */;\n          continue;\n        }\n        continue;\n      }\n      type = 2 /* DynamicTag */;\n    } else {\n      type = 2 /* DynamicTag */;\n    }\n  }\n  extra.tagNameType = type;\n  extra.tagNameNullable = nullable;\n  extra.tagNameDynamic = true;\n  if (type === 1 /* CustomTag */ && tagNameImported) {\n    extra.tagNameImported = tagNameImported;\n  }\n}\n\n// src/util/sections.ts\nfunction startSection(path3) {\n  const extra = path3.node.extra ??= {};\n  let section = extra.section;\n  if (!section && (path3.type === \"Program\" || path3.get(\"body\").length)) {\n    const parentSection = path3.parentPath ? getOrCreateSection(path3.parentPath) : void 0;\n    const sectionNamePath = path3.parentPath?.get(\n      \"name\"\n    );\n    const sectionName = path3.isProgram() ? \"\" : currentProgramPath.scope.generateUid(\n      sectionNamePath.toString() + \"Body\"\n    );\n    const programExtra = path3.hub.file.path.node.extra ??= {};\n    const sections = programExtra.sections ??= [];\n    section = extra.section = {\n      id: sections.length,\n      name: sectionName,\n      depth: parentSection ? parentSection.depth + 1 : 0,\n      parent: parentSection,\n      closures: /* @__PURE__ */ new Set(),\n      bindings: /* @__PURE__ */ new Set(),\n      content: getContentInfo(path3),\n      upstreamExpression: void 0,\n      hasCleanup: false\n    };\n    sections.push(section);\n  }\n  return section;\n}\nfunction getOrCreateSection(path3) {\n  let cur = path3;\n  while (true) {\n    if (cur.type === \"Program\" || cur.type === \"MarkoTagBody\" && analyzeTagNameType(cur.parentPath) !== 0 /* NativeTag */ && cur.parent.name.value !== \"html-comment\") {\n      return startSection(cur);\n    }\n    cur = cur.parentPath;\n  }\n}\nfunction hasSection(path3) {\n  return path3.node.extra?.section !== void 0;\n}\nfunction getSection(path3) {\n  let section;\n  let currentPath = path3;\n  while ((section = currentPath.node.extra?.section) === void 0) {\n    currentPath = currentPath.parentPath;\n  }\n  _setSectionPath(\n    section,\n    currentPath\n  );\n  return section;\n}\nvar [getScopeIdIdentifier] = createSectionState(\n  \"scopeIdIdentifier\",\n  (section) => currentProgramPath.scope.generateUidIdentifier(`scope${section.id}_id`)\n);\nvar [getSectionParentIsOwner, setSectionParentIsOwner] = createSectionState(\"parentIsOwner\", () => false);\nvar [getSectionPath, _setSectionPath] = createSectionState(\"sectionPath\");\nvar [_getScopeIdentifier] = createSectionState(\n  \"scopeIdentifier\",\n  () => import_compiler5.types.identifier(\"undefined\")\n);\nvar getScopeIdentifier = (section, ignoreDefault) => {\n  const scopeId = _getScopeIdentifier(section);\n  if (!ignoreDefault && scopeId.name === \"undefined\") {\n    scopeId.name = currentProgramPath.scope.generateUid(`scope${section.id}_`);\n  }\n  return scopeId;\n};\nfunction forEachSection(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  sections?.forEach(fn);\n}\nfunction forEachSectionReverse(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  for (let i = sections.length; i--; ) {\n    fn(sections[i]);\n  }\n}\nfunction getContentInfo(path3) {\n  const body = path3.get(\"body\");\n  const contentInfo = {\n    startType: null,\n    endType: null,\n    singleChild: true\n  };\n  for (let endIndex = body.length; endIndex--; ) {\n    const endType = getNodeContentType(body[endIndex], \"endType\", contentInfo);\n    if (endType !== null) {\n      contentInfo.endType = endType;\n      for (let startIndex = 0; startIndex < endIndex; startIndex++) {\n        const startType = getNodeContentType(body[startIndex], \"startType\");\n        if (startType !== null) {\n          contentInfo.startType = startType;\n          contentInfo.singleChild = false;\n          return contentInfo;\n        }\n      }\n      contentInfo.startType = getNodeContentType(body[endIndex], \"startType\");\n      return contentInfo;\n    }\n  }\n  return null;\n}\nfunction getNodeContentType(path3, extraMember, contentInfo) {\n  if (import_compiler5.types.isMarkoText(path3)) {\n    return 4 /* Text */;\n  }\n  if (import_compiler5.types.isMarkoPlaceholder(path3)) {\n    return 2 /* Placeholder */;\n  }\n  if (import_compiler5.types.isMarkoScriptlet(path3) || import_compiler5.types.isMarkoComment(path3)) {\n    return null;\n  }\n  if (import_compiler5.types.isMarkoTag(path3.node)) {\n    const tag = path3;\n    if ((0, import_babel_utils6.isNativeTag)(tag)) {\n      return 3 /* Tag */;\n    }\n    if ((0, import_babel_utils6.isAttributeTag)(tag)) {\n      return null;\n    }\n    if (import_compiler5.types.isStringLiteral(path3.node.name)) {\n      switch (path3.node.name.value) {\n        case \"html-comment\":\n          return 0 /* Comment */;\n        case \"let\":\n        case \"const\":\n        case \"attrs\":\n        case \"effect\":\n        case \"lifecycle\":\n        case \"return\":\n        case \"id\":\n        case \"define\":\n          return null;\n      }\n      const tagSection = (0, import_babel_utils6.loadFileForTag)(tag)?.ast.program.extra.section;\n      if (tagSection) {\n        if (tagSection.content) {\n          if (contentInfo && !tagSection.content.singleChild) {\n            if (extraMember === \"endType\") {\n              contentInfo.startType = tagSection.content.startType;\n              contentInfo.singleChild = false;\n            }\n          }\n          return tagSection.content[extraMember];\n        } else {\n          return null;\n        }\n      }\n    }\n  }\n  return 1 /* Dynamic */;\n}\nvar isStatefulSection = (section) => {\n  const upstreamExpression = section.upstreamExpression;\n  return !upstreamExpression || isStatefulReferences(upstreamExpression.referencedBindings);\n};\nvar checkStatefulClosures = (section, immediateOnly) => {\n  for (const binding of section.closures) {\n    if ((!immediateOnly || section.parent === binding.section) && isStatefulReferences(binding)) {\n      return true;\n    }\n  }\n};\n\n// src/visitors/program/dom.ts\nvar import_compiler13 = require(\"@marko/compiler\");\n\n// src/util/runtime.ts\nvar import_babel_utils7 = require(\"@marko/babel-utils\");\nvar import_compiler7 = require(\"@marko/compiler\");\n\n// ../runtime-tags/src/common/helpers.ts\nfunction classValue(value) {\n  return toDelimitedString(value, \" \", stringifyClassObject);\n}\nfunction stringifyClassObject(name, value) {\n  return value ? name : \"\";\n}\nfunction styleValue(value) {\n  return toDelimitedString(value, \";\", stringifyStyleObject);\n}\nvar NON_DIMENSIONAL = /^(--|ta|or|li|z)|n-c|i(do|nk|m|t)|w$|we/;\nfunction stringifyStyleObject(name, value) {\n  return value || value === 0 ? `${name}:${typeof value === \"number\" && value && !NON_DIMENSIONAL.test(name) ? value + \"px\" : value}` : \"\";\n}\nfunction toDelimitedString(val, delimiter, stringify) {\n  switch (typeof val) {\n    case \"string\":\n      return val;\n    case \"object\":\n      if (val !== null) {\n        let result = \"\";\n        let curDelimiter = \"\";\n        if (Array.isArray(val)) {\n          for (const v of val) {\n            const part = toDelimitedString(v, delimiter, stringify);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        } else {\n          for (const name in val) {\n            const v = val[name];\n            const part = stringify(name, v);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        }\n        return result;\n      }\n  }\n  return \"\";\n}\nfunction isVoid(value) {\n  return value == null || value === false;\n}\n\n// ../runtime-tags/src/html/serializer.ts\nvar { hasOwnProperty } = {};\nvar Generator = function* () {\n}().constructor;\nvar AsyncGenerator = async function* () {\n}().constructor;\nvar KNOWN_SYMBOLS = (() => {\n  const KNOWN_SYMBOLS2 = /* @__PURE__ */ new Map();\n  for (const name of Object.getOwnPropertyNames(Symbol)) {\n    const symbol = Symbol[name];\n    if (typeof symbol === \"symbol\") {\n      KNOWN_SYMBOLS2.set(symbol, \"Symbol.\" + name);\n    }\n  }\n  return KNOWN_SYMBOLS2;\n})();\nvar KNOWN_FUNCTIONS = /* @__PURE__ */ new Map([\n  // This is by no means an exhaustive list,\n  // but it should cover most of the built-in functions.\n  [AggregateError, \"AggregateError\"],\n  [Array, \"Array\"],\n  [Array.from, \"Array.from\"],\n  [Array.isArray, \"Array.isArray\"],\n  [Array.of, \"Array.of\"],\n  [ArrayBuffer, \"ArrayBuffer\"],\n  [ArrayBuffer.isView, \"ArrayBuffer.isView\"],\n  [Atomics.add, \"Atomics.add\"],\n  [Atomics.and, \"Atomics.and\"],\n  [Atomics.compareExchange, \"Atomics.compareExchange\"],\n  [Atomics.exchange, \"Atomics.exchange\"],\n  [Atomics.isLockFree, \"Atomics.isLockFree\"],\n  [Atomics.load, \"Atomics.load\"],\n  [Atomics.notify, \"Atomics.notify\"],\n  [Atomics.or, \"Atomics.or\"],\n  [Atomics.store, \"Atomics.store\"],\n  [Atomics.sub, \"Atomics.sub\"],\n  [Atomics.wait, \"Atomics.wait\"],\n  [BigInt, \"BigInt\"],\n  [BigInt.asIntN, \"BigInt.asIntN\"],\n  [BigInt.asUintN, \"BigInt.asUintN\"],\n  [BigInt64Array, \"BigInt64Array\"],\n  [BigInt64Array.from, \"BigInt64Array.from\"],\n  [BigInt64Array.of, \"BigInt64Array.of\"],\n  [BigUint64Array, \"BigUint64Array\"],\n  [BigUint64Array.from, \"BigUint64Array.from\"],\n  [BigUint64Array.of, \"BigUint64Array.of\"],\n  [Boolean, \"Boolean\"],\n  [console.assert, \"console.assert\"],\n  [console.clear, \"console.clear\"],\n  [console.count, \"console.count\"],\n  [console.countReset, \"console.countReset\"],\n  [console.debug, \"console.debug\"],\n  [console.dir, \"console.dir\"],\n  [console.dirxml, \"console.dirxml\"],\n  [console.error, \"console.error\"],\n  [console.group, \"console.group\"],\n  [console.groupCollapsed, \"console.groupCollapsed\"],\n  [console.groupEnd, \"console.groupEnd\"],\n  [console.info, \"console.info\"],\n  [console.log, \"console.log\"],\n  [console.table, \"console.table\"],\n  [console.time, \"console.time\"],\n  [console.timeEnd, \"console.timeEnd\"],\n  [console.timeLog, \"console.timeLog\"],\n  [console.timeStamp, \"console.timeStamp\"],\n  [console.trace, \"console.trace\"],\n  [console.warn, \"console.warn\"],\n  [DataView, \"DataView\"],\n  [Date, \"Date\"],\n  [Date.now, \"Date.now\"],\n  [Date.parse, \"Date.parse\"],\n  [Date.UTC, \"Date.UTC\"],\n  [decodeURI, \"decodeURI\"],\n  [decodeURIComponent, \"decodeURIComponent\"],\n  [encodeURI, \"encodeURI\"],\n  [encodeURIComponent, \"encodeURIComponent\"],\n  [Error, \"Error\"],\n  [EvalError, \"EvalError\"],\n  [Float32Array, \"Float32Array\"],\n  [Float32Array.from, \"Float32Array.from\"],\n  [Float32Array.of, \"Float32Array.of\"],\n  [Float64Array, \"Float64Array\"],\n  [Float64Array.from, \"Float64Array.from\"],\n  [Float64Array.of, \"Float64Array.of\"],\n  [Function, \"Function\"],\n  [globalThis.atob, \"atob\"],\n  [globalThis.btoa, \"btoa\"],\n  [globalThis.clearImmediate, \"clearImmediate\"],\n  [globalThis.clearInterval, \"clearInterval\"],\n  [globalThis.clearTimeout, \"clearTimeout\"],\n  [globalThis.crypto?.getRandomValues, \"crypto.getRandomValues\"],\n  [globalThis.crypto?.randomUUID, \"crypto.randomUUID\"],\n  [globalThis.fetch, \"fetch\"],\n  [globalThis.performance?.now, \"performance.now\"],\n  [globalThis.queueMicrotask, \"queueMicrotask\"],\n  [globalThis.setImmediate, \"setImmediate\"],\n  [globalThis.setInterval, \"setInterval\"],\n  [globalThis.setTimeout, \"setTimeout\"],\n  [globalThis.structuredClone, \"structuredClone\"],\n  [globalThis.URL, \"URL\"],\n  [globalThis.URLSearchParams, \"URLSearchParams\"],\n  [globalThis.WritableStream, \"WritableStream\"],\n  [Int16Array, \"Int16Array\"],\n  [Int16Array.from, \"Int16Array.from\"],\n  [Int16Array.of, \"Int16Array.of\"],\n  [Int32Array, \"Int32Array\"],\n  [Int32Array.from, \"Int32Array.from\"],\n  [Int32Array.of, \"Int32Array.of\"],\n  [Int8Array, \"Int8Array\"],\n  [Int8Array.from, \"Int8Array.from\"],\n  [Int8Array.of, \"Int8Array.of\"],\n  [Intl.Collator, \"Intl.Collator\"],\n  [Intl.DateTimeFormat, \"Intl.DateTimeFormat\"],\n  [Intl.DisplayNames, \"Intl.DisplayNames\"],\n  [Intl.getCanonicalLocales, \"Intl.getCanonicalLocales\"],\n  [Intl.ListFormat, \"Intl.ListFormat\"],\n  [Intl.Locale, \"Intl.Locale\"],\n  [Intl.NumberFormat, \"Intl.NumberFormat\"],\n  [Intl.PluralRules, \"Intl.PluralRules\"],\n  [Intl.RelativeTimeFormat, \"Intl.RelativeTimeFormat\"],\n  [Intl.Segmenter, \"Intl.Segmenter\"],\n  [Intl.supportedValuesOf, \"Intl.supportedValuesOf\"],\n  [isFinite, \"isFinite\"],\n  [isNaN, \"isNaN\"],\n  [JSON.parse, \"JSON.parse\"],\n  [JSON.stringify, \"JSON.stringify\"],\n  [Map, \"Map\"],\n  [Map.groupBy, \"Map.groupBy\"],\n  [Math.abs, \"Math.abs\"],\n  [Math.acos, \"Math.acos\"],\n  [Math.acosh, \"Math.acosh\"],\n  [Math.asin, \"Math.asin\"],\n  [Math.asinh, \"Math.asinh\"],\n  [Math.atan, \"Math.atan\"],\n  [Math.atan2, \"Math.atan2\"],\n  [Math.atanh, \"Math.atanh\"],\n  [Math.cbrt, \"Math.cbrt\"],\n  [Math.ceil, \"Math.ceil\"],\n  [Math.clz32, \"Math.clz32\"],\n  [Math.cos, \"Math.cos\"],\n  [Math.cosh, \"Math.cosh\"],\n  [Math.exp, \"Math.exp\"],\n  [Math.expm1, \"Math.expm1\"],\n  [Math.floor, \"Math.floor\"],\n  [Math.fround, \"Math.fround\"],\n  [Math.hypot, \"Math.hypot\"],\n  [Math.imul, \"Math.imul\"],\n  [Math.log, \"Math.log\"],\n  [Math.log10, \"Math.log10\"],\n  [Math.log1p, \"Math.log1p\"],\n  [Math.log2, \"Math.log2\"],\n  [Math.max, \"Math.max\"],\n  [Math.min, \"Math.min\"],\n  [Math.pow, \"Math.pow\"],\n  [Math.random, \"Math.random\"],\n  [Math.round, \"Math.round\"],\n  [Math.sign, \"Math.sign\"],\n  [Math.sin, \"Math.sin\"],\n  [Math.sinh, \"Math.sinh\"],\n  [Math.sqrt, \"Math.sqrt\"],\n  [Math.tan, \"Math.tan\"],\n  [Math.tanh, \"Math.tanh\"],\n  [Math.trunc, \"Math.trunc\"],\n  [Number, \"Number\"],\n  [Number.isFinite, \"Number.isFinite\"],\n  [Number.isInteger, \"Number.isInteger\"],\n  [Number.isNaN, \"Number.isNaN\"],\n  [Number.isSafeInteger, \"Number.isSafeInteger\"],\n  [Number.parseFloat, \"Number.parseFloat\"],\n  [Number.parseInt, \"Number.parseInt\"],\n  [Object, \"Object\"],\n  [Object.assign, \"Object.assign\"],\n  [Object.create, \"Object.create\"],\n  [Object.defineProperties, \"Object.defineProperties\"],\n  [Object.defineProperty, \"Object.defineProperty\"],\n  [Object.entries, \"Object.entries\"],\n  [Object.freeze, \"Object.freeze\"],\n  [Object.fromEntries, \"Object.fromEntries\"],\n  [Object.getOwnPropertyDescriptor, \"Object.getOwnPropertyDescriptor\"],\n  [Object.getOwnPropertyDescriptors, \"Object.getOwnPropertyDescriptors\"],\n  [Object.getOwnPropertyNames, \"Object.getOwnPropertyNames\"],\n  [Object.getOwnPropertySymbols, \"Object.getOwnPropertySymbols\"],\n  [Object.getPrototypeOf, \"Object.getPrototypeOf\"],\n  [Object.is, \"Object.is\"],\n  [Object.isExtensible, \"Object.isExtensible\"],\n  [Object.isFrozen, \"Object.isFrozen\"],\n  [Object.isSealed, \"Object.isSealed\"],\n  [Object.keys, \"Object.keys\"],\n  [Object.preventExtensions, \"Object.preventExtensions\"],\n  [Object.seal, \"Object.seal\"],\n  [Object.setPrototypeOf, \"Object.setPrototypeOf\"],\n  [Object.values, \"Object.values\"],\n  [parseFloat, \"parseFloat\"],\n  [parseInt, \"parseInt\"],\n  [Promise, \"Promise\"],\n  [Proxy, \"Proxy\"],\n  [RangeError, \"RangeError\"],\n  [ReferenceError, \"ReferenceError\"],\n  [Reflect.apply, \"Reflect.apply\"],\n  [Reflect.construct, \"Reflect.construct\"],\n  [Reflect.defineProperty, \"Reflect.defineProperty\"],\n  [Reflect.deleteProperty, \"Reflect.deleteProperty\"],\n  [Reflect.get, \"Reflect.get\"],\n  [Reflect.getOwnPropertyDescriptor, \"Reflect.getOwnPropertyDescriptor\"],\n  [Reflect.getPrototypeOf, \"Reflect.getPrototypeOf\"],\n  [Reflect.has, \"Reflect.has\"],\n  [Reflect.isExtensible, \"Reflect.isExtensible\"],\n  [Reflect.ownKeys, \"Reflect.ownKeys\"],\n  [Reflect.preventExtensions, \"Reflect.preventExtensions\"],\n  [Reflect.set, \"Reflect.set\"],\n  [Reflect.setPrototypeOf, \"Reflect.setPrototypeOf\"],\n  [RegExp, \"RegExp\"],\n  [Set, \"Set\"],\n  [String, \"String\"],\n  [String.fromCharCode, \"String.fromCharCode\"],\n  [String.fromCodePoint, \"String.fromCodePoint\"],\n  [String.raw, \"String.raw\"],\n  [Symbol, \"Symbol\"],\n  [Symbol.for, \"Symbol.for\"],\n  [SyntaxError, \"SyntaxError\"],\n  [TypeError, \"TypeError\"],\n  [Uint16Array, \"Uint16Array\"],\n  [Uint16Array.from, \"Uint16Array.from\"],\n  [Uint16Array.of, \"Uint16Array.of\"],\n  [Uint32Array, \"Uint32Array\"],\n  [Uint32Array.from, \"Uint32Array.from\"],\n  [Uint32Array.of, \"Uint32Array.of\"],\n  [Uint8Array, \"Uint8Array\"],\n  [Uint8Array.from, \"Uint8Array.from\"],\n  [Uint8Array.of, \"Uint8Array.of\"],\n  [Uint8ClampedArray, \"Uint8ClampedArray\"],\n  [Uint8ClampedArray.from, \"Uint8ClampedArray.from\"],\n  [Uint8ClampedArray.of, \"Uint8ClampedArray.of\"],\n  [URIError, \"URIError\"],\n  [WeakMap, \"WeakMap\"],\n  [WeakSet, \"WeakSet\"]\n]);\nvar KNOWN_OBJECTS = /* @__PURE__ */ new Map([\n  [Atomics, \"Atomics\"],\n  [console, \"console\"],\n  [globalThis, \"globalThis\"],\n  [globalThis.crypto, \"crypto\"],\n  [Intl, \"Intl\"],\n  [JSON, \"JSON\"],\n  [Math, \"Math\"],\n  [Reflect, \"Reflect\"]\n]);\n\n// ../runtime-tags/src/html/writer.ts\nvar K_SCOPE_ID = Symbol(\"Scope ID\");\nvar tick = globalThis.setImmediate || globalThis.setTimeout || globalThis.queueMicrotask || ((cb) => Promise.resolve().then(cb));\n\n// ../runtime-tags/src/html/attrs.ts\nfunction classAttr(val) {\n  return stringAttr(\"class\", classValue(val));\n}\nfunction styleAttr(val) {\n  return stringAttr(\"style\", styleValue(val));\n}\nfunction attr(name, val) {\n  return isVoid(val) ? \"\" : nonVoidAttr(name, val);\n}\nfunction stringAttr(name, val) {\n  return val && ` ${name}=${escapeAttrValue(val)}`;\n}\nfunction nonVoidAttr(name, val) {\n  switch (typeof val) {\n    case \"string\":\n      return ` ${name + attrAssignment(val)}`;\n    case \"boolean\":\n      return ` ${name}`;\n    case \"number\":\n      return ` ${name}=${val}`;\n    case \"object\":\n      if (val instanceof RegExp) {\n        return ` ${name + attrAssignment(val.source)}`;\n      }\n      break;\n  }\n  return ` ${name + attrAssignment(val + \"\")}`;\n}\nfunction attrAssignment(val) {\n  return val ? `=${escapeAttrValue(val)}` : \"\";\n}\nvar unsafeAttrChars = /[\"'>\\s]/g;\nfunction escapeAttrValue(str) {\n  if (unsafeAttrChars.test(str)) {\n    const c = str[unsafeAttrChars.lastIndex - 1];\n    unsafeAttrChars.lastIndex = 0;\n    return c === '\"' ? `'${str.replace(/'/g, \"&#39;\")}'` : `\"${str.replace(/\"/g, \"&#34;\")}\"`;\n  }\n  return str;\n}\n\n// ../runtime-tags/src/common/compat-meta.ts\nvar prefix = false ? \"$compat_\" : \"$C_\";\nvar RENDERER_REGISTER_ID = prefix + (false ? \"renderer\" : \"r\");\nvar SET_SCOPE_REGISTER_ID = prefix + (false ? \"setScope\" : \"s\");\n\n// ../runtime-tags/src/html/compat.ts\nvar K_TAGS_API_STATE = Symbol();\n\n// ../runtime-tags/src/html/content.ts\nfunction toString(val) {\n  return val ? val + \"\" : val === 0 ? \"0\" : \"\";\n}\nvar unsafeXMLReg = /[<&]/g;\nvar replaceUnsafeXML = (c) => c === \"&\" ? \"&amp;\" : \"&lt;\";\nvar escapeXMLStr = (str) => unsafeXMLReg.test(str) ? str.replace(unsafeXMLReg, replaceUnsafeXML) : str;\nfunction escapeXML(val) {\n  return val ? escapeXMLStr(val + \"\") : val === 0 ? \"0\" : \"&zwj;\";\n}\nvar unsafeScriptReg = /<\\/script/g;\nvar escapeScriptStr = (str) => unsafeScriptReg.test(str) ? str.replace(unsafeScriptReg, \"\\\\x3C/script\") : str;\nfunction escapeScript(val) {\n  return val ? escapeScriptStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\nvar unsafeStyleReg = /<\\/style/g;\nvar escapeStyleStr = (str) => unsafeStyleReg.test(str) ? str.replace(unsafeStyleReg, \"\\\\3C/style\") : str;\nfunction escapeStyle(val) {\n  return val ? escapeStyleStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\n\n// src/util/scope-read.ts\nvar import_compiler6 = require(\"@marko/compiler\");\n\n// src/util/optional.ts\nvar Sorted = class {\n  constructor(compare) {\n    this.compare = compare;\n  }\n  add(data, item) {\n    return data ? Array.isArray(data) ? addSorted(this.compare, data, item) : joinRepeatable(this.compare, data, item) : item;\n  }\n  union(a, b) {\n    if (a) {\n      if (Array.isArray(a)) {\n        if (b) {\n          if (Array.isArray(b)) {\n            return unionSortedRepeatable(this.compare, a, b);\n          } else {\n            return addSorted(this.compare, a, b);\n          }\n        }\n        return a;\n      }\n      if (b) {\n        if (Array.isArray(b)) {\n          return addSorted(this.compare, b, a);\n        }\n        return joinRepeatable(this.compare, b, a);\n      }\n      return a;\n    }\n    return b;\n  }\n  find(data, item) {\n    if (data) {\n      if (Array.isArray(data)) {\n        return findSorted(this.compare, data, item);\n      } else if (this.compare(data, item) === 0) {\n        return data;\n      }\n    }\n  }\n};\nfunction push(data, item) {\n  if (data) {\n    if (Array.isArray(data)) {\n      data.push(item);\n      return data;\n    }\n    return [data, item];\n  }\n  return item;\n}\nfunction size(data) {\n  return data ? Array.isArray(data) ? data.length : 1 : 0;\n}\nfunction forEach(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      for (const item of data) {\n        cb(item);\n      }\n    } else {\n      cb(data);\n    }\n  }\n}\nfunction findSorted(compare, data, item) {\n  let max = data.length;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const cur = data[mid];\n    const compareResult = compare(cur, item);\n    if (compareResult === 0) return cur;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n}\nfunction addSorted(compare, data, item) {\n  const len = data.length;\n  let max = len;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(data[mid], item);\n    if (compareResult === 0) return data;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n  const result = new Array(len + 1);\n  for (let i = 0; i < pos; i++) {\n    result[i] = data[i];\n  }\n  let cur = item;\n  while (pos < len) {\n    const next = cur;\n    cur = data[pos];\n    result[pos++] = next;\n  }\n  result[len] = cur;\n  return result;\n}\nfunction unionSortedRepeatable(compare, a, b) {\n  const aLen = a.length;\n  const bLen = b.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  const result = [\n    compare(a[aIndex], b[bIndex]) <= 0 ? a[aIndex++] : b[bIndex++],\n    compare(a[aIndex], b[bIndex]) <= 0 ? a[aIndex++] : b[bIndex++]\n  ];\n  while (aIndex < aLen && bIndex < bLen) {\n    result.push(compare(a[aIndex], b[bIndex]) <= 0 ? a[aIndex++] : b[bIndex++]);\n  }\n  if (aLen === bLen && aIndex === aLen) {\n    return a;\n  }\n  while (aIndex < aLen) {\n    result.push(a[aIndex++]);\n  }\n  while (bIndex < bLen) {\n    result.push(b[bIndex++]);\n  }\n  return result;\n}\nfunction joinRepeatable(compare, a, b) {\n  const compareResult = compare(a, b);\n  return compareResult === 0 ? a : compareResult < 0 ? [a, b] : [b, a];\n}\n\n// src/util/scope-read.ts\nfunction createScopeReadPattern(section, referencedBindings) {\n  const rootDepth = section.depth;\n  const rootPattern = import_compiler6.types.objectPattern([]);\n  let nestedPatterns;\n  forEach(referencedBindings, (ref) => {\n    if (ref.name.includes(\"#\")) return;\n    const propertyKey = getScopeAccessorLiteral(ref);\n    const propertyValue = import_compiler6.types.identifier(ref.name);\n    const isShorthand = propertyKey.value === propertyValue.name;\n    let pattern = rootPattern;\n    if (ref.section !== section) {\n      if (!nestedPatterns) nestedPatterns = [rootPattern];\n      const relativeDepth = rootDepth - ref.section.depth;\n      let i = nestedPatterns.length;\n      let prev = nestedPatterns[i - 1];\n      for (; i <= relativeDepth; i++) {\n        const nestedPattern = import_compiler6.types.objectPattern([]);\n        prev.properties.push(\n          import_compiler6.types.objectProperty(import_compiler6.types.identifier(\"_\"), nestedPattern)\n        );\n        nestedPatterns.push(nestedPattern);\n        prev = nestedPattern;\n      }\n      pattern = nestedPatterns[relativeDepth];\n    }\n    pattern.properties.push(\n      import_compiler6.types.objectProperty(\n        isShorthand ? propertyValue : propertyKey,\n        propertyValue,\n        false,\n        isShorthand\n      )\n    );\n  });\n  return rootPattern;\n}\nfunction getScopeExpression(section, targetSection) {\n  let scope = scopeIdentifier ?? import_compiler6.types.identifier(\"undefined\");\n  const diff = section.depth - targetSection.depth;\n  for (let i = 0; i < diff; i++) {\n    scope = import_compiler6.types.memberExpression(scope, import_compiler6.types.identifier(\"_\"));\n  }\n  if (diff < 0) {\n    throw new Error(\"Unable to find scope for reference.\");\n  }\n  return scope;\n}\nfunction createScopeReadExpression(section, reference) {\n  return import_compiler6.types.memberExpression(\n    getScopeExpression(section, reference.section),\n    getScopeAccessorLiteral(reference),\n    true\n  );\n}\n\n// src/util/runtime.ts\nvar pureFunctions = [\n  \"createTemplate\",\n  \"createRenderer\",\n  \"createRendererWithOwner\",\n  \"value\",\n  \"intersection\",\n  \"closure\",\n  \"dynamicClosure\",\n  \"loopOf\",\n  \"loopIn\",\n  \"loopTo\",\n  \"conditional\"\n];\nfunction importRuntime(name) {\n  const { output } = getMarkoOpts();\n  return (0, import_babel_utils7.importNamed)(currentProgramPath.hub.file, getRuntimePath(output), name);\n}\nfunction callRuntime(name, ...args) {\n  const callExpression2 = import_compiler7.types.callExpression(\n    importRuntime(name),\n    filterArguments(args)\n  );\n  if (pureFunctions.includes(\n    name\n  )) {\n    callExpression2.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: ` @__PURE__ `\n      }\n    ];\n  }\n  return callExpression2;\n}\nfunction getHTMLRuntime() {\n  return {\n    escapeXML,\n    toString,\n    attr,\n    classAttr,\n    styleAttr,\n    escapeScript,\n    escapeStyle\n  };\n}\nfunction getRuntimePath(output) {\n  const { optimize } = getMarkoOpts();\n  return `@marko/runtime-tags/${optimize ? \"\" : \"debug/\"}${output === \"html\" ? \"html\" : \"dom\"}`;\n}\nfunction filterArguments(args) {\n  const filteredArgs = [];\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (arg || filteredArgs.length) {\n      filteredArgs[i] = arg || import_compiler7.types.unaryExpression(\"void\", import_compiler7.types.numericLiteral(0));\n    }\n  }\n  return filteredArgs;\n}\n\n// src/util/signals.ts\nvar import_babel_utils9 = require(\"@marko/babel-utils\");\nvar import_compiler12 = require(\"@marko/compiler\");\n\n// src/core/return.ts\nvar import_babel_utils8 = require(\"@marko/babel-utils\");\nvar import_compiler11 = require(\"@marko/compiler\");\n\n// src/util/assert.ts\nfunction assertNoSpreadAttrs(tag) {\n  for (const attr2 of tag.get(\"attributes\")) {\n    if (attr2.isMarkoSpreadAttribute()) {\n      throw attr2.buildCodeFrameError(\n        `The \\`${tag.get(\"name\").node.value}\\` tag does not support \\`...spread\\` attributes.`\n      );\n    }\n  }\n}\nfunction assertNoBodyContent(tag) {\n  if (tag.node.body.body.length) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${tag.get(\"name\").node.value}\\` tag does not support body content.`\n    );\n  }\n}\n\n// src/util/writer.ts\nvar import_compiler10 = require(\"@marko/compiler\");\n\n// src/util/to-template-string-or-literal.ts\nvar import_compiler8 = require(\"@marko/compiler\");\nfunction toTemplateOrStringLiteral(parts) {\n  const strs = [];\n  const exprs = [];\n  let curStr = parts[0];\n  for (let i = 1; i < parts.length; i++) {\n    let content = parts[i];\n    if (typeof content === \"object\") {\n      if (import_compiler8.types.isStringLiteral(content)) {\n        content = content.value;\n      } else if (import_compiler8.types.isTemplateLiteral(content)) {\n        let nextIndex = i + 1;\n        const exprLen = content.expressions.length;\n        shiftItems(parts, nextIndex, content.quasis.length + exprLen);\n        for (let j = 0; j < exprLen; j++) {\n          parts[nextIndex++] = content.quasis[j].value.raw;\n          parts[nextIndex++] = content.expressions[j];\n        }\n        parts[nextIndex] = content.quasis[exprLen].value.raw;\n        continue;\n      } else {\n        exprs.push(content);\n        strs.push(curStr);\n        curStr = \"\";\n        continue;\n      }\n    }\n    curStr += content;\n  }\n  if (exprs.length) {\n    strs.push(curStr);\n    return import_compiler8.types.templateLiteral(\n      strs.map((raw) => import_compiler8.types.templateElement({ raw })),\n      exprs\n    );\n  } else if (curStr) {\n    return import_compiler8.types.stringLiteral(curStr);\n  }\n}\nfunction appendLiteral(arr, str) {\n  arr[arr.length - 1] += str;\n}\nfunction shiftItems(list, start, offset) {\n  for (let i = list.length - 1; i >= start; i--) {\n    list[i + offset] = list[i];\n  }\n}\n\n// src/util/walks.ts\nvar import_compiler9 = require(\"@marko/compiler\");\nvar [getWalks] = createSectionState(\n  \"walks\",\n  () => [\"\"]\n);\nvar [getWalkComment] = createSectionState(\n  \"walkComment\",\n  () => []\n);\nvar [getSteps] = createSectionState(\"steps\", () => []);\nvar walkCodeToName = {\n  [32 /* Get */]: \"get\",\n  [36 /* Inside */]: \"inside\",\n  [37 /* Replace */]: \"replace\",\n  [38 /* EndChild */]: \"endChild\",\n  [47 /* BeginChild */]: \"beginChild\",\n  [67 /* Next */]: \"next\",\n  [97 /* Over */]: \"over\",\n  [107 /* Out */]: \"out\",\n  [117 /* Multiplier */]: \"multiplier\",\n  [91 /* NextEnd */]: \"nextEnd\",\n  [106 /* OverEnd */]: \"overEnd\",\n  [116 /* OutEnd */]: \"outEnd\",\n  [126 /* MultiplierEnd */]: \"multiplierEnd\"\n};\nfunction enter(path3) {\n  getSteps(getSection(path3)).push(0 /* Enter */);\n}\nfunction exit(path3) {\n  getSteps(getSection(path3)).push(1 /* Exit */);\n}\nfunction enterShallow(path3) {\n  getSteps(getSection(path3)).push(0 /* Enter */, 1 /* Exit */);\n}\nfunction injectWalks(path3, expr) {\n  const walks = getWalks(getSection(path3));\n  const walkComment = getWalkComment(getSection(path3));\n  walkComment.push(\n    `${walkCodeToName[47 /* BeginChild */]}`,\n    expr.name,\n    walkCodeToName[38 /* EndChild */]\n  );\n  appendLiteral(walks, String.fromCharCode(47 /* BeginChild */));\n  walks.push(expr, String.fromCharCode(38 /* EndChild */));\n}\nfunction visit(path3, code) {\n  if (isOutputHTML()) {\n    return;\n  }\n  const section = getSection(path3);\n  const steps = getSteps(section);\n  const walks = getWalks(section);\n  const walkComment = getWalkComment(section);\n  let walkString = \"\";\n  if (steps.length) {\n    const walkCodes = [];\n    let depth = 0;\n    for (const step of steps) {\n      if (step === 0 /* Enter */) {\n        depth++;\n        walkCodes.push(67 /* Next */);\n      } else {\n        depth--;\n        if (depth >= 0) {\n          walkCodes.length = walkCodes.lastIndexOf(67 /* Next */);\n          walkCodes.push(97 /* Over */);\n        } else {\n          walkCodes.length = walkCodes.lastIndexOf(107 /* Out */) + 1;\n          walkCodes.push(107 /* Out */);\n          depth = 0;\n        }\n      }\n    }\n    let current = walkCodes[0];\n    let count = 0;\n    for (const walk of walkCodes) {\n      if (walk !== current) {\n        walkComment.push(`${walkCodeToName[current]}(${count})`);\n        walkString += nCodeString(current, count);\n        current = walk;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n    walkComment.push(`${walkCodeToName[current]}(${count})`);\n    walkString += nCodeString(current, count);\n    steps.length = 0;\n  }\n  if (code !== void 0) {\n    if (code !== 32 /* Get */) {\n      writeTo(path3)`<!>`;\n    }\n    walkComment.push(`${walkCodeToName[code]}`);\n    walkString += String.fromCharCode(code);\n  }\n  appendLiteral(walks, walkString);\n}\nfunction nCodeString(code, number) {\n  switch (code) {\n    case 67 /* Next */:\n      return toCharString(number, code, 20 /* Next */);\n    case 97 /* Over */:\n      return toCharString(number, code, 10 /* Over */);\n    case 107 /* Out */:\n      return toCharString(number, code, 10 /* Out */);\n    default:\n      throw new Error(`Unexpected walk code: ${code}`);\n  }\n}\nfunction toCharString(number, startCode, rangeSize) {\n  let result = \"\";\n  if (number >= rangeSize) {\n    const multiplier = Math.floor(number / rangeSize);\n    result += toCharString(\n      multiplier,\n      117 /* Multiplier */,\n      10 /* Multiplier */\n    );\n    number -= multiplier * rangeSize;\n  }\n  result += String.fromCharCode(startCode + number);\n  return result;\n}\nfunction getWalkString(section) {\n  const prefix2 = section.content?.startType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const postfix = section.content?.endType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const walks = getWalks(section);\n  const walkLiteral = toTemplateOrStringLiteral([prefix2, ...walks, postfix]) || import_compiler9.types.stringLiteral(\"\");\n  if (walkLiteral.value !== \"\") {\n    walkLiteral.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: \" \" + getWalkComment(section).join(\", \") + \" \"\n      }\n    ];\n  }\n  return walkLiteral;\n}\n\n// src/util/writer.ts\nvar [getWrites] = createSectionState(\n  \"writes\",\n  () => [\"\"]\n);\nfunction writeTo(path3) {\n  const section = getSection(path3);\n  return (strs, ...exprs) => {\n    const exprsLen = exprs.length;\n    const writes = getWrites(section);\n    appendLiteral(writes, strs[0]);\n    for (let i = 0; i < exprsLen; i++) {\n      writes.push(exprs[i], strs[i + 1]);\n    }\n  };\n}\nfunction consumeHTML(path3) {\n  const writes = getWrites(getSection(path3));\n  const result = toTemplateOrStringLiteral(writes);\n  writes.length = 0;\n  writes[0] = \"\";\n  if (result) {\n    return import_compiler10.types.expressionStatement(callRuntime(\"write\", result));\n  }\n}\nfunction flushBefore(path3) {\n  const expr = consumeHTML(path3);\n  if (expr) {\n    path3.insertBefore(expr)[0].skip();\n  }\n}\nfunction flushInto(path3) {\n  const target = path3.isProgram() ? path3 : path3.get(\"body\");\n  const expr = consumeHTML(target);\n  if (expr) {\n    target.pushContainer(\"body\", expr)[0].skip();\n  }\n}\nfunction getSectionMeta(section) {\n  const writePrefix = section.content?.startType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writePostfix = section.content?.endType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writes = getWrites(section);\n  return {\n    setup: getSetup(section),\n    walks: getWalkString(section),\n    writes: toTemplateOrStringLiteral([writePrefix, ...writes, writePostfix]) || import_compiler10.types.stringLiteral(\"\")\n  };\n}\nfunction markNode(path3, binding) {\n  const section = getSection(path3);\n  if (binding.type !== 0 /* dom */) {\n    throw path3.buildCodeFrameError(\n      \"Tried to mark a node that was not determined to need a mark during analyze.\"\n    );\n  }\n  if (isOutputHTML()) {\n    writeTo(path3)`${callRuntime(\n      \"markResumeNode\",\n      getScopeIdIdentifier(section),\n      getScopeAccessorLiteral(binding)\n    )}`;\n  }\n}\n\n// src/core/return.ts\nvar [returnId, _setReturnId] = createSectionState(\n  \"returnId\"\n);\nvar usedTag = /* @__PURE__ */ new WeakSet();\nvar return_default = {\n  analyze(tag) {\n    (0, import_babel_utils8.assertNoArgs)(tag);\n    (0, import_babel_utils8.assertNoVar)(tag);\n    (0, import_babel_utils8.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    if (usedTag.has(tag.hub)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `return` tag can only be used once per template.\"\n      );\n    }\n    usedTag.add(tag.hub);\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    if (!import_compiler11.types.isMarkoAttribute(valueAttr) || !valueAttr.default) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `return` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 && node.attributes[1].name !== \"valueChange\") {\n      const start = node.attributes[1].loc?.start;\n      const end = node.attributes[node.attributes.length - 1].loc?.end;\n      const msg = \"The `return` tag only supports the `value` attribute.\";\n      if (start == null || end == null) {\n        throw tag.get(\"name\").buildCodeFrameError(msg);\n      } else {\n        throw tag.hub.buildError(\n          { loc: { start, end } },\n          msg,\n          Error\n        );\n      }\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const {\n        node: {\n          attributes: [{ value }]\n        },\n        hub: { file }\n      } = tag;\n      if (isOutputHTML()) {\n        flushBefore(tag);\n        const returnId2 = file.path.scope.generateUidIdentifier(\"return\");\n        _setReturnId(section, returnId2);\n        tag.replaceWith(\n          import_compiler11.types.variableDeclaration(\"const\", [\n            import_compiler11.types.variableDeclarator(returnId2, value)\n          ])\n        )[0].skip();\n      } else {\n        addValue(\n          section,\n          value.extra?.referencedBindings,\n          {\n            identifier: importRuntime(\"tagVarSignal\"),\n            hasDownstreamIntersections: () => true\n          },\n          value\n        );\n        tag.remove();\n      }\n    }\n  },\n  autocomplete: [\n    {\n      displayText: \"return=<value>\",\n      description: \"Provides a value for use in a parent template.\",\n      snippet: \"return=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#return\"\n    }\n  ]\n};\n\n// src/util/signals.ts\nvar [getSignals] = createSectionState(\n  \"signals\",\n  () => /* @__PURE__ */ new Map()\n);\nvar [getSubscribeBuilder, _setSubscribeBuilder] = createSectionState(\"queue\");\nfunction setSubscriberBuilder(tag, builder) {\n  _setSubscribeBuilder(getSection(tag.get(\"body\")), builder);\n}\nvar [getClosures] = createSectionState(\n  \"closures\",\n  () => []\n);\nvar addClosure = (fromSection, toSection, closure) => {\n  let currentSection = fromSection;\n  while (currentSection !== void 0 && currentSection !== toSection) {\n    getClosures(currentSection).push(closure);\n    currentSection = currentSection.parent;\n  }\n};\nvar [forceResumeScope, _setForceResumeScope] = createSectionState(\"forceResumeScope\");\nfunction setForceResumeScope(section) {\n  _setForceResumeScope(section, true);\n}\nvar [getSerializedScopeProperties] = createSectionState(\"serializedScopeProperties\", () => /* @__PURE__ */ new Map());\nvar unimplementedBuild = () => {\n  return import_compiler12.types.stringLiteral(\"SIGNAL NOT INITIALIZED\");\n};\nfunction getSignal(section, referencedBindings, name = generateSignalName(referencedBindings)) {\n  const signals = getSignals(section);\n  let signal = signals.get(referencedBindings);\n  if (!signal) {\n    const exportName = referencedBindings ? !Array.isArray(referencedBindings) && referencedBindings.section === section && referencedBindings.export : !section.parent && currentProgramPath.node.extra.domExports?.setup;\n    signals.set(\n      referencedBindings,\n      signal = {\n        identifier: exportName ? import_compiler12.types.identifier(exportName) : currentProgramPath.scope.generateUidIdentifier(\n          name + section.name.replace(\"_\", \"$\")\n        ),\n        referencedBindings,\n        section,\n        values: [],\n        intersection: void 0,\n        render: [],\n        effect: [],\n        effectInlineReferences: void 0,\n        subscribers: [],\n        closures: /* @__PURE__ */ new Map(),\n        hasDownstreamIntersections: () => {\n          let hasDownstreamIntersections = !!(signal.intersection || signal.closures.size);\n          if (!hasDownstreamIntersections) {\n            for (const value of signal.values) {\n              if (value.signal.hasDownstreamIntersections()) {\n                hasDownstreamIntersections = true;\n                break;\n              }\n            }\n          }\n          if (!hasDownstreamIntersections) {\n            if (!Array.isArray(referencedBindings) && referencedBindings) {\n              for (const alias of referencedBindings.aliases) {\n                if (getSignal(section, alias).hasDownstreamIntersections()) {\n                  hasDownstreamIntersections = true;\n                  break;\n                }\n              }\n              if (!hasDownstreamIntersections) {\n                for (const [, alias] of referencedBindings.propertyAliases) {\n                  if (getSignal(section, alias).hasDownstreamIntersections()) {\n                    hasDownstreamIntersections = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          signal.hasDownstreamIntersections = () => hasDownstreamIntersections;\n          return hasDownstreamIntersections;\n        },\n        build: unimplementedBuild,\n        export: !!exportName\n      }\n    );\n    if (isOutputHTML()) {\n      return signal;\n    } else if (!referencedBindings) {\n      signal.build = () => getSignalFn(signal, [scopeIdentifier]);\n    } else if (Array.isArray(referencedBindings)) {\n      subscribe(referencedBindings, signal);\n      signal.build = () => {\n        return callRuntime(\n          \"intersection\",\n          import_compiler12.types.numericLiteral(referencedBindings.length),\n          getSignalFn(signal, [scopeIdentifier], referencedBindings),\n          buildSignalIntersections(signal)\n        );\n      };\n    } else if (referencedBindings.section !== section) {\n      const provider = getSignal(\n        referencedBindings.section,\n        referencedBindings\n      );\n      addClosure(\n        section,\n        section.parent,\n        signal.identifier\n      );\n      provider.closures.set(section, signal);\n      signal.build = () => {\n        const builder = getSubscribeBuilder(section);\n        const ownerScope = getScopeExpression(\n          section,\n          referencedBindings.section\n        );\n        const isImmediateOwner = ownerScope.object === scopeIdentifier;\n        const isDynamicClosure = signal.isDynamicClosure = !(isImmediateOwner && builder);\n        return callRuntime(\n          isDynamicClosure ? \"dynamicClosure\" : \"closure\",\n          getScopeAccessorLiteral(referencedBindings),\n          getSignalFn(signal, [\n            scopeIdentifier,\n            import_compiler12.types.identifier(referencedBindings.name)\n          ]),\n          isImmediateOwner ? null : import_compiler12.types.arrowFunctionExpression([scopeIdentifier], ownerScope),\n          buildSignalIntersections(signal)\n        );\n      };\n    }\n  }\n  return signal;\n}\nfunction initValue(binding) {\n  const valueAccessor = getScopeAccessorLiteral(binding);\n  const section = binding.section;\n  const signal = getSignal(section, binding);\n  signal.build = () => {\n    const fn = getSignalFn(signal, [\n      scopeIdentifier,\n      import_compiler12.types.identifier(binding.name)\n    ]);\n    const intersections = buildSignalIntersections(signal);\n    const isParamBinding = !binding.upstreamAlias && (binding.type === 3 /* param */ || binding.type === 2 /* input */);\n    const isNakedAlias = binding.upstreamAlias && !binding.property;\n    const needsGuard = !isNakedAlias && (binding.downstreamExpressions.size || fn.body.body.length > 0);\n    const needsCache = needsGuard || intersections;\n    const needsMarks = isParamBinding || intersections;\n    if (needsCache || needsMarks) {\n      return callRuntime(\"value\", valueAccessor, fn, intersections);\n    } else {\n      return fn;\n    }\n  };\n  signal.valueAccessor = valueAccessor;\n  for (const alias of binding.aliases) {\n    initValue(alias);\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    initValue(alias);\n  }\n  return signal;\n}\nfunction getSignalFn(signal, params, referencedBindings) {\n  const section = signal.section;\n  const binding = signal.referencedBindings;\n  if (binding && !Array.isArray(binding) && binding.section === section) {\n    const [scopeIdentifier2, valueIdentifier] = params;\n    for (const alias of binding.aliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler12.types.expressionStatement(\n          import_compiler12.types.callExpression(aliasSignal.callee || aliasSignal.identifier, [\n            scopeIdentifier2,\n            valueIdentifier\n          ])\n        )\n      );\n    }\n    for (const [key, alias] of binding.propertyAliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler12.types.expressionStatement(\n          import_compiler12.types.callExpression(aliasSignal.callee || aliasSignal.identifier, [\n            scopeIdentifier2,\n            toMemberExpression(valueIdentifier, key)\n          ])\n        )\n      );\n    }\n  }\n  for (const value of signal.values) {\n    signal.render.push(\n      import_compiler12.types.expressionStatement(\n        import_compiler12.types.callExpression(value.signal.callee || value.signal.identifier, [\n          value.scope,\n          value.value\n        ])\n      )\n    );\n  }\n  if (referencedBindings) {\n    signal.render.unshift(\n      import_compiler12.types.variableDeclaration(\"const\", [\n        import_compiler12.types.variableDeclarator(\n          createScopeReadPattern(section, referencedBindings),\n          scopeIdentifier\n        )\n      ])\n    );\n  }\n  return import_compiler12.types.arrowFunctionExpression(params, import_compiler12.types.blockStatement(signal.render));\n}\nfunction buildSignalIntersections(signal) {\n  const section = signal.section;\n  let intersections = signal.intersection;\n  const binding = signal.referencedBindings;\n  if (binding && !Array.isArray(binding) && binding.section === signal.section) {\n    for (const alias of binding.aliases) {\n      const signal2 = getSignal(alias.section, alias);\n      if (signal2.hasDownstreamIntersections()) {\n        intersections = push(\n          intersections,\n          import_compiler12.types.identifier(signal2.identifier.name)\n        );\n      }\n    }\n    for (const [, alias] of binding.propertyAliases) {\n      const signal2 = getSignal(alias.section, alias);\n      if (signal2.hasDownstreamIntersections()) {\n        intersections = push(\n          intersections,\n          import_compiler12.types.identifier(signal2.identifier.name)\n        );\n      }\n    }\n  }\n  for (const value of signal.values) {\n    if (value.signal.hasDownstreamIntersections()) {\n      intersections = push(\n        intersections,\n        value.intersectionExpression ?? import_compiler12.types.identifier(value.signal.identifier.name)\n      );\n    }\n  }\n  const closureEntries = Array.from(signal.closures.entries()).sort(\n    ([a], [b]) => a.id - b.id\n  );\n  for (const [closureSection, closureSignal] of closureEntries) {\n    const builder = getSubscribeBuilder(closureSection);\n    const isImmediateOwner = closureSection.parent === section;\n    if (builder && isImmediateOwner) {\n      intersections = push(intersections, builder(closureSignal.identifier));\n    } else if (!signal.hasDynamicSubscribers) {\n      signal.hasDynamicSubscribers = true;\n    }\n  }\n  if (signal.hasDynamicSubscribers) {\n    signal.hasDynamicSubscribers = true;\n    intersections = push(\n      intersections,\n      callRuntime(\"dynamicSubscribers\", signal.valueAccessor)\n    );\n  }\n  return intersections && import_compiler12.types.arrowFunctionExpression(\n    [],\n    Array.isArray(intersections) ? callRuntime(\"intersections\", import_compiler12.types.arrayExpression(intersections)) : intersections\n  );\n}\nfunction subscribe(provider, subscriber) {\n  if (Array.isArray(provider)) {\n    provider.forEach((p) => subscribe(p, subscriber));\n    return;\n  }\n  const providerSignal = getSignal(subscriber.section, provider);\n  providerSignal.intersection = push(\n    providerSignal.intersection,\n    subscriber.identifier\n  );\n}\nfunction generateSignalName(referencedBindings) {\n  let name;\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      name = \"expr\";\n      for (const ref of referencedBindings) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name = referencedBindings.name;\n    }\n  } else {\n    name = \"setup\";\n  }\n  return name;\n}\nfunction queueSource(source, value, targetSection, changeBinding) {\n  if (!changeBinding) {\n    return callRuntime(\n      \"queueSource\",\n      getScopeExpression(targetSection, source.section),\n      source.identifier,\n      value\n    );\n  }\n  const changeBindingId = import_compiler12.types.identifier(changeBinding.name);\n  if (changeBinding.upstreamExpression?.static) {\n    return import_compiler12.types.callExpression(changeBindingId, [value]);\n  }\n  return callRuntime(\n    \"queueControllableSource\",\n    getScopeExpression(targetSection, source.section),\n    source.identifier,\n    changeBindingId,\n    value\n  );\n}\nfunction finalizeSignalArgs(args) {\n  for (let i = args.length - 1; i >= 0; i--) {\n    const arg = args[i];\n    if (import_compiler12.types.isArrowFunctionExpression(arg)) {\n      const body = arg.body.body;\n      if (body) {\n        if (body.length === 0) {\n          args[i] = import_compiler12.types.nullLiteral();\n        } else if (body.length === 1 && import_compiler12.types.isExpressionStatement(body[0])) {\n          arg.body = body[0].expression;\n        }\n      }\n    }\n  }\n  for (let i = args.length - 1; import_compiler12.types.isNullLiteral(args[i]); ) {\n    args.length = i--;\n  }\n}\nfunction addStatement(type, targetSection, referencedBindings, statement, originalNodes, isInlined) {\n  const signal = getSignal(targetSection, referencedBindings);\n  const statements = signal[type] ??= [];\n  if (Array.isArray(statement)) {\n    statements.push(...statement);\n  } else {\n    statements.push(statement);\n  }\n  if (type === \"effect\") {\n    if (Array.isArray(originalNodes)) {\n      for (const node of originalNodes) {\n        if (isInlined || !import_compiler12.types.isFunction(node)) {\n          addEffectReferences(signal, node);\n        }\n      }\n    } else {\n      if (isInlined || !import_compiler12.types.isFunction(originalNodes)) {\n        addEffectReferences(signal, originalNodes);\n      }\n    }\n  }\n}\nfunction addValue(targetSection, referencedBindings, signal, value, scope = scopeIdentifier, intersectionExpression) {\n  getSignal(targetSection, referencedBindings).values.push({\n    signal,\n    value,\n    scope,\n    intersectionExpression\n  });\n}\nfunction addEffectReferences(signal, expression) {\n  signal.effectInlineReferences = bindingUtil.union(\n    signal.effectInlineReferences,\n    expression.extra?.referencedBindings\n  );\n}\nfunction getResumeRegisterId(section, referencedBindings, type) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let name = \"\";\n  if (referencedBindings) {\n    if (typeof referencedBindings === \"string\") {\n      name += `_${referencedBindings}`;\n    } else if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name += `_${referencedBindings.name}`;\n    }\n  }\n  return (0, import_babel_utils9.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}${name}${type ? \"/\" + type : \"\"}`\n  );\n}\nvar usedRegisterIdsBySection = /* @__PURE__ */ new WeakMap();\nfunction getRegisterUID(section, name) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let used = usedRegisterIdsBySection.get(section);\n  if (!used) usedRegisterIdsBySection.set(section, used = /* @__PURE__ */ new Set());\n  const baseId = (0, import_babel_utils9.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}/${name}`\n  );\n  let count = 0;\n  let id = baseId;\n  while (used.has(id)) {\n    id = baseId + \"_\" + ++count;\n  }\n  used.add(id);\n  return id;\n}\nfunction renameBindings() {\n  import_compiler12.types.traverseFast(currentProgramPath.node, (node) => {\n    if (import_compiler12.types.isIdentifier(node)) {\n      const binding = node.extra && (node.extra.source || node.extra.binding);\n      if (binding && binding.name !== node.name) {\n        node.name = binding.name;\n      }\n    }\n  });\n}\nfunction replaceAssignments() {\n  if (currentProgramPath.node.extra.assignments) {\n    for (const [valueSection, assignment] of currentProgramPath.node.extra.assignments) {\n      const { node } = assignment;\n      if (node.type === \"UpdateExpression\") {\n        const binding = node.argument.extra?.source;\n        if (binding) {\n          const { buildAssignment } = getSignal(binding.section, binding);\n          if (buildAssignment) {\n            const replacement = buildAssignment(\n              valueSection,\n              import_compiler12.types.binaryExpression(\n                node.operator === \"++\" ? \"+\" : \"-\",\n                node.argument,\n                import_compiler12.types.numericLiteral(1)\n              )\n            );\n            assignment.replaceWith(\n              node.prefix || assignment.parentPath.isExpressionStatement() ? replacement : import_compiler12.types.sequenceExpression([replacement, node.argument])\n            );\n          }\n        }\n      } else {\n        if (node.left.type === \"ObjectPattern\" || node.left.type === \"ArrayPattern\") {\n          handleDestructure(assignment, node.left, valueSection);\n        } else if (node.left.type === \"Identifier\") {\n          const binding = node.left.extra?.source;\n          if (binding) {\n            const { buildAssignment } = getSignal(binding.section, binding);\n            if (buildAssignment) {\n              const replacement = buildAssignment(\n                valueSection,\n                node.operator === \"=\" ? node.right : import_compiler12.types.binaryExpression(\n                  node.operator.slice(\n                    0,\n                    -1\n                  ),\n                  node.left,\n                  node.right\n                )\n              );\n              assignment.replaceWith(replacement);\n            }\n          }\n        }\n      }\n    }\n  }\n}\nfunction writeSignals(section) {\n  const signals = [...getSignals(section).values()].sort(sortSignals);\n  for (const signal of signals) {\n    let effectDeclarator;\n    if (signal.effect.length) {\n      const effectIdentifier = import_compiler12.types.identifier(`${signal.identifier.name}_effect`);\n      if (signal.effectInlineReferences) {\n        signal.effect.unshift(\n          import_compiler12.types.variableDeclaration(\"const\", [\n            import_compiler12.types.variableDeclarator(\n              createScopeReadPattern(section, signal.effectInlineReferences),\n              scopeIdentifier\n            )\n          ])\n        );\n      }\n      effectDeclarator = import_compiler12.types.variableDeclarator(\n        effectIdentifier,\n        callRuntime(\n          \"register\",\n          import_compiler12.types.stringLiteral(\n            getResumeRegisterId(section, signal.referencedBindings)\n          ),\n          import_compiler12.types.arrowFunctionExpression(\n            [scopeIdentifier],\n            signal.effect.length === 1 && import_compiler12.types.isExpressionStatement(signal.effect[0]) ? signal.effect[0].expression : import_compiler12.types.blockStatement(signal.effect)\n          )\n        )\n      );\n      signal.render.push(\n        import_compiler12.types.expressionStatement(\n          callRuntime(\"queueEffect\", scopeIdentifier, effectIdentifier)\n        )\n      );\n    }\n    let value = signal.build();\n    if (import_compiler12.types.isCallExpression(value)) {\n      finalizeSignalArgs(value.arguments);\n    }\n    if (signal.register) {\n      value = callRuntime(\n        \"registerBoundSignal\",\n        import_compiler12.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings)\n        ),\n        value\n      );\n    }\n    if (signal.isDynamicClosure && isStatefulReferences(signal.referencedBindings)) {\n      value = callRuntime(\n        \"registerSubscriber\",\n        import_compiler12.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings, \"subscriber\")\n        ),\n        value\n      );\n    }\n    const signalDeclarator = import_compiler12.types.variableDeclarator(signal.identifier, value);\n    let signalDeclaration = !section.parent && !signal.referencedBindings && (import_compiler12.types.isFunctionExpression(value) || import_compiler12.types.isArrowFunctionExpression(value)) ? import_compiler12.types.functionDeclaration(\n      signal.identifier,\n      value.params,\n      import_compiler12.types.isExpression(value.body) ? import_compiler12.types.blockStatement([import_compiler12.types.expressionStatement(value.body)]) : value.body\n    ) : import_compiler12.types.variableDeclaration(\"const\", [signalDeclarator]);\n    if (signal.export) {\n      signalDeclaration = import_compiler12.types.exportNamedDeclaration(signalDeclaration);\n    }\n    const roots = currentProgramPath.pushContainer(\n      \"body\",\n      effectDeclarator ? [\n        import_compiler12.types.variableDeclaration(\"const\", [effectDeclarator]),\n        signalDeclaration\n      ] : signalDeclaration\n    );\n    for (const root of roots) {\n      root.traverse(bindFunctionsVisitor, { root, section });\n    }\n  }\n}\nfunction sortSignals(a, b) {\n  const aReferencedBindings = getReferencedBindings(a);\n  const bReferencedBindings = getReferencedBindings(b);\n  for (let i = Math.max(aReferencedBindings.length, bReferencedBindings.length) - 1; i >= 0; i--) {\n    const diff = (bReferencedBindings[i] ?? -1) - (aReferencedBindings[i] ?? -1);\n    if (diff !== 0) return diff;\n  }\n  return 0;\n}\nfunction getReferencedBindings({ referencedBindings: reserve }) {\n  if (!reserve) {\n    return [];\n  } else if (Array.isArray(reserve)) {\n    return reserve.map(getMappedId).sort();\n  } else {\n    return [getMappedId(reserve)];\n  }\n}\nfunction getMappedId(reference) {\n  return (reference.type === 0 /* dom */ ? 1 : 0) * 1e4 + reference.id;\n}\nfunction addHTMLEffectCall(section, referencedBindings) {\n  addStatement(\"effect\", section, referencedBindings, void 0, []);\n}\nfunction writeHTMLResumeStatements(path3, tagVarIdentifier) {\n  if (!hasSection(path3)) return;\n  const section = getSection(path3);\n  const allSignals = Array.from(getSignals(section).values());\n  const scopeIdIdentifier = getScopeIdIdentifier(section);\n  for (const closure of section.closures) {\n    if (isStatefulReferences(closure)) {\n      let currentSection = section;\n      while (currentSection !== closure.section) {\n        getSerializedScopeProperties(currentSection).set(\n          import_compiler12.types.stringLiteral(\"_\"),\n          callRuntime(\n            \"ensureScopeWithId\",\n            getScopeIdIdentifier(currentSection = currentSection.parent)\n          )\n        );\n      }\n      setForceResumeScope(closure.section);\n      const isImmediateOwner = section.parent?.id === closure.section.id;\n      const isDynamicClosure = !getSubscribeBuilder(section) || !isImmediateOwner;\n      if (isDynamicClosure) {\n        path3.pushContainer(\n          \"body\",\n          import_compiler12.types.expressionStatement(\n            callRuntime(\n              \"writeEffect\",\n              scopeIdIdentifier,\n              import_compiler12.types.stringLiteral(\n                getResumeRegisterId(section, closure, \"subscriber\")\n              )\n            )\n          )\n        );\n      }\n    }\n  }\n  for (let i = allSignals.length; i--; ) {\n    if (allSignals[i].effect.length) {\n      const signalRefs = allSignals[i].referencedBindings;\n      path3.pushContainer(\n        \"body\",\n        import_compiler12.types.expressionStatement(\n          callRuntime(\n            \"writeEffect\",\n            scopeIdIdentifier,\n            import_compiler12.types.stringLiteral(getResumeRegisterId(section, signalRefs))\n          )\n        )\n      );\n    }\n  }\n  const accessors = /* @__PURE__ */ new Set();\n  const additionalProperties = getSerializedScopeProperties(section);\n  const serializedProperties = [];\n  for (const binding of section.bindings) {\n    if (binding.serialize && binding.type !== 0 /* dom */) {\n      const accessor = getScopeAccessorLiteral(binding);\n      serializedProperties.push(\n        import_compiler12.types.objectProperty(accessor, import_compiler12.types.identifier(binding.name))\n      );\n      accessors.add(accessor.value);\n    }\n  }\n  if (tagVarIdentifier && returnId(section) !== void 0) {\n    serializedProperties.push(\n      import_compiler12.types.objectProperty(\n        import_compiler12.types.stringLiteral(\"/\" /* TagVariable */),\n        tagVarIdentifier\n      )\n    );\n  }\n  for (const [key, value] of additionalProperties) {\n    if (!accessors.has(key.value)) {\n      serializedProperties.push(\n        import_compiler12.types.objectProperty(key, value, !import_compiler12.types.isLiteral(key))\n      );\n      accessors.add(key.value);\n    }\n  }\n  if (serializedProperties.length || forceResumeScope(section)) {\n    path3.pushContainer(\n      \"body\",\n      import_compiler12.types.expressionStatement(\n        callRuntime(\n          \"writeScope\",\n          scopeIdIdentifier,\n          import_compiler12.types.objectExpression(serializedProperties)\n        )\n      )\n    );\n  }\n  if (path3.get(\"body\").length) {\n    path3.unshiftContainer(\n      \"body\",\n      import_compiler12.types.variableDeclaration(\"const\", [\n        import_compiler12.types.variableDeclarator(scopeIdIdentifier, callRuntime(\"nextScopeId\"))\n      ])\n    );\n  }\n}\nvar bindFunctionsVisitor = {\n  FunctionExpression: { exit: bindFunction },\n  ArrowFunctionExpression: { exit: bindFunction }\n};\nfunction handleDestructure(assignment, node, section, ctx, replace) {\n  if (!ctx) {\n    ctx = {\n      statement: assignment.getStatementParent(),\n      end: assignment.getStatementParent()\n    };\n  }\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        handleDestructure(assignment, prop, section, ctx);\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const i in node.elements) {\n        if (node.elements[i] === null) continue;\n        handleDestructure(\n          assignment,\n          node.elements[i],\n          section,\n          ctx,\n          (id) => node.elements[i] = id\n        );\n      }\n      break;\n    case \"RestElement\":\n      handleDestructure(\n        assignment,\n        node.argument,\n        section,\n        ctx,\n        (id) => node.argument = id\n      );\n      break;\n    case \"ObjectProperty\":\n      handleDestructure(\n        assignment,\n        node.value,\n        section,\n        ctx,\n        (id) => node.value = id\n      );\n      break;\n    case \"Identifier\":\n      {\n        const binding = node.extra?.source;\n        if (binding) {\n          const { buildAssignment } = getSignal(binding.section, binding);\n          if (buildAssignment) {\n            const valueId = ctx.statement.scope.generateUidIdentifier(\n              node.name\n            );\n            ctx.statement.insertBefore(\n              import_compiler12.types.variableDeclaration(\"let\", [import_compiler12.types.variableDeclarator(valueId)])\n            );\n            replace?.(valueId);\n            [ctx.end] = ctx.end.insertAfter(\n              import_compiler12.types.expressionStatement(buildAssignment(section, valueId))\n            );\n          }\n        }\n      }\n      break;\n  }\n}\nfunction bindFunction(fn, { root, section }) {\n  const { node } = fn;\n  const { extra } = node;\n  if (!extra?.referencedBindings) return;\n  const { name, referencedBindings } = extra;\n  const fnId = fn.hub.file.path.scope.generateUidIdentifier(name);\n  root.insertBefore(\n    import_compiler12.types.variableDeclaration(\"const\", [\n      import_compiler12.types.variableDeclarator(\n        fnId,\n        import_compiler12.types.arrowFunctionExpression(\n          [scopeIdentifier],\n          referencedBindings ? import_compiler12.types.blockStatement([\n            import_compiler12.types.variableDeclaration(\"const\", [\n              import_compiler12.types.variableDeclarator(\n                createScopeReadPattern(section, referencedBindings),\n                scopeIdentifier\n              )\n            ]),\n            import_compiler12.types.returnStatement(node)\n          ]) : node\n        )\n      )\n    ])\n  )[0].skip();\n  fn.replaceWith(import_compiler12.types.callExpression(fnId, [scopeIdentifier]))[0].skip();\n}\nfunction getSetup(section) {\n  return getSignals(section).get(void 0)?.identifier;\n}\nfunction toMemberExpression(value, key) {\n  const keyLiteral = keyToNode(key);\n  return import_compiler12.types.memberExpression(\n    value,\n    keyLiteral,\n    keyLiteral.type !== \"Identifier\"\n  );\n}\nfunction keyToNode(key) {\n  if (/^[a-z_$][a-z0-9_$]*$/i.test(key)) {\n    return import_compiler12.types.identifier(key);\n  } else if (/^(?:0|[1-9][0-9]*)$/.test(key)) {\n    return import_compiler12.types.numericLiteral(parseInt(key, 10));\n  }\n  return import_compiler12.types.stringLiteral(key);\n}\n\n// src/visitors/program/dom.ts\nvar dom_default = {\n  translate: {\n    exit(program) {\n      visit(program);\n      const section = getSection(program);\n      const { walks, writes, setup } = getSectionMeta(section);\n      const domExports = program.node.extra.domExports;\n      const templateIdentifier = import_compiler13.types.identifier(domExports.template);\n      const walksIdentifier = import_compiler13.types.identifier(domExports.walks);\n      const setupIdentifier = import_compiler13.types.identifier(domExports.setup);\n      const closuresIdentifier = import_compiler13.types.identifier(domExports.closures);\n      const paramsBinding = program.node.extra.binding;\n      const programParamsSignal = paramsBinding && bindingHasDownstreamExpressions(paramsBinding) ? initValue(paramsBinding) : void 0;\n      replaceAssignments();\n      forEachSectionReverse((childSection) => {\n        if (childSection !== section) {\n          const sectionPath = getSectionPath(childSection);\n          const sectionParamsBinding = sectionPath.node.extra?.binding;\n          const tagParamsSignal = sectionParamsBinding && initValue(sectionParamsBinding);\n          const { walks: walks2, writes: writes2, setup: setup2 } = getSectionMeta(childSection);\n          const closures2 = getClosures(childSection);\n          const identifier = import_compiler13.types.identifier(childSection.name);\n          const renderer = callRuntime(\n            getSectionParentIsOwner(childSection) ? \"createRenderer\" : \"createRendererWithOwner\",\n            writes2,\n            walks2,\n            setup2,\n            closures2.length && import_compiler13.types.arrowFunctionExpression([], import_compiler13.types.arrayExpression(closures2)),\n            void 0,\n            tagParamsSignal?.identifier && import_compiler13.types.arrowFunctionExpression([], tagParamsSignal.identifier)\n          );\n          writeSignals(childSection);\n          program.node.body.push(\n            import_compiler13.types.variableDeclaration(\"const\", [\n              import_compiler13.types.variableDeclarator(\n                identifier,\n                isStatefulSection(childSection) ? callRuntime(\n                  \"register\",\n                  import_compiler13.types.stringLiteral(\n                    getResumeRegisterId(childSection, \"renderer\")\n                  ),\n                  renderer\n                ) : renderer\n              )\n            ])\n          );\n        }\n      });\n      const closures = getClosures(section);\n      writeSignals(section);\n      renameBindings();\n      if (!setup) {\n        program.node.body.unshift(\n          import_compiler13.types.exportNamedDeclaration(\n            import_compiler13.types.variableDeclaration(\"const\", [\n              import_compiler13.types.variableDeclarator(\n                setupIdentifier,\n                import_compiler13.types.arrowFunctionExpression([], import_compiler13.types.blockStatement([]))\n              )\n            ])\n          )\n        );\n      }\n      program.node.body.unshift(\n        import_compiler13.types.exportNamedDeclaration(\n          import_compiler13.types.variableDeclaration(\"const\", [\n            import_compiler13.types.variableDeclarator(\n              templateIdentifier,\n              writes || import_compiler13.types.stringLiteral(\"\")\n            )\n          ])\n        ),\n        import_compiler13.types.exportNamedDeclaration(\n          import_compiler13.types.variableDeclaration(\"const\", [\n            import_compiler13.types.variableDeclarator(walksIdentifier, walks || import_compiler13.types.stringLiteral(\"\"))\n          ])\n        )\n      );\n      if (closures.length) {\n        program.node.body.push(\n          import_compiler13.types.exportNamedDeclaration(\n            import_compiler13.types.variableDeclaration(\"const\", [\n              import_compiler13.types.variableDeclarator(\n                closuresIdentifier,\n                import_compiler13.types.arrayExpression(closures)\n              )\n            ])\n          )\n        );\n      }\n      program.node.body.push(\n        import_compiler13.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            callRuntime(\n              \"createRenderer\",\n              templateIdentifier,\n              walksIdentifier,\n              setupIdentifier,\n              closures.length && import_compiler13.types.arrowFunctionExpression([], closuresIdentifier),\n              void 0,\n              programParamsSignal?.identifier && import_compiler13.types.arrowFunctionExpression([], programParamsSignal.identifier)\n            ),\n            import_compiler13.types.stringLiteral(program.hub.file.metadata.marko.id)\n          )\n        )\n      );\n    }\n  }\n};\n\n// src/visitors/program/html.ts\nvar import_compiler14 = require(\"@marko/compiler\");\n\n// src/util/is-static.ts\nfunction isStatic(path3) {\n  return path3.isImportDeclaration() || path3.isExportDeclaration() || path3.isMarkoScriptlet({ static: true });\n}\n\n// src/visitors/program/html.ts\nvar html_default = {\n  translate: {\n    exit(program) {\n      const section = getSection(program);\n      const tagVarIdentifier = program.scope.generateUidIdentifier(\"tagVar\");\n      flushInto(program);\n      writeHTMLResumeStatements(program, tagVarIdentifier);\n      renameBindings();\n      const returnIdentifier = returnId(section);\n      if (returnIdentifier !== void 0) {\n        program.pushContainer(\"body\", import_compiler14.types.returnStatement(returnIdentifier));\n      }\n      const renderContent = [];\n      for (const child of program.get(\"body\")) {\n        if (!isStatic(child)) {\n          renderContent.push(child.node);\n          child.remove();\n        } else if (child.isMarkoScriptlet()) {\n          if (child.node.target && child.node.target !== \"server\") {\n            child.remove();\n          } else {\n            child.replaceWithMultiple(child.node.body);\n          }\n        }\n      }\n      const rendererId = program.scope.generateUidIdentifier(\"renderer\");\n      program.pushContainer(\"body\", [\n        import_compiler14.types.variableDeclaration(\"const\", [\n          import_compiler14.types.variableDeclarator(\n            rendererId,\n            callRuntime(\n              \"createRenderer\",\n              import_compiler14.types.arrowFunctionExpression(\n                [import_compiler14.types.identifier(\"input\"), tagVarIdentifier],\n                import_compiler14.types.blockStatement(renderContent)\n              )\n            )\n          )\n        ]),\n        import_compiler14.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            rendererId,\n            import_compiler14.types.stringLiteral(program.hub.file.metadata.marko.id)\n          )\n        )\n      ]);\n    }\n  }\n};\n\n// src/visitors/program/index.ts\nvar currentProgramPath;\nvar scopeIdentifier;\nvar cleanIdentifier;\nvar previousProgramPath = /* @__PURE__ */ new WeakMap();\nvar program_default = {\n  migrate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      program.node.params = [import_compiler15.types.identifier(\"input\")];\n      currentProgramPath = program;\n    },\n    exit() {\n      currentProgramPath.scope.crawl();\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  analyze: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      startSection(program);\n      trackParamsReferences(program, 2 /* input */);\n      const { scope } = program;\n      (program.node.extra ??= {}).domExports = {\n        template: scope.generateUid(\"template_\"),\n        walks: scope.generateUid(\"walks_\"),\n        setup: scope.generateUid(\"setup_\"),\n        params: void 0,\n        // TODO look into recursive components with fine grained params.\n        closures: scope.generateUid(\"closures_\")\n      };\n    },\n    exit(program) {\n      finalizeReferences();\n      const {\n        scope,\n        node: { extra }\n      } = program;\n      if (extra.binding && bindingHasDownstreamExpressions(extra.binding)) {\n        extra.domExports.params = recurseAndBuildExportTree(\n          extra.binding,\n          scope\n        );\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  translate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      scopeIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"scope\") : null;\n      cleanIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"clean\") : null;\n      if (getMarkoOpts().output === \"hydrate\") {\n        const entryFile = program.hub.file;\n        const visitedFiles = /* @__PURE__ */ new Set([\n          (0, import_babel_utils10.resolveRelativePath)(entryFile, entryFile.opts.filename)\n        ]);\n        entry_builder_default.visit(entryFile, entryFile, function visitChild(resolved) {\n          if (!visitedFiles.has(resolved)) {\n            visitedFiles.add(resolved);\n            const file = (0, import_babel_utils10.loadFileForImport)(entryFile, resolved);\n            if (file) {\n              entry_builder_default.visit(\n                file,\n                entryFile,\n                (id) => visitChild(resolveRelativeToEntry(entryFile, file, id))\n              );\n            }\n          }\n        });\n        program.node.body = entry_builder_default.build(entryFile);\n        program.skip();\n        return;\n      }\n    },\n    exit(program) {\n      if (isOutputHTML()) {\n        html_default.translate.exit(program);\n      } else {\n        dom_default.translate.exit(program);\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  }\n};\nfunction resolveRelativeToEntry(entryFile, file, req) {\n  return file === entryFile ? (0, import_babel_utils10.resolveRelativePath)(file, req) : (0, import_babel_utils10.resolveRelativePath)(\n    entryFile,\n    req[0] === \".\" ? import_path.default.join(file.opts.filename, \"..\", req) : req\n  );\n}\nfunction recurseAndBuildExportTree(binding, scope) {\n  const exportTree = {\n    id: binding.export ??= scope.generateUid(binding.name + \"_\"),\n    props: void 0\n  };\n  const { aliases, propertyAliases, downstreamExpressions } = binding;\n  if (!downstreamExpressions.size) {\n    exportTree.props = {};\n    for (const [property, alias] of propertyAliases) {\n      exportTree.props[property] = recurseAndBuildExportTree(alias, scope);\n    }\n    for (const alias of aliases) {\n      const exports2 = recurseAndBuildExportTree(alias, scope);\n      if (exports2.props) {\n        exportTree.props = { ...exportTree.props, ...exports2.props };\n      } else {\n        exportTree.props = void 0;\n        return exportTree;\n      }\n    }\n  }\n  return exportTree;\n}\n\n// src/util/get-root.ts\nfunction getMarkoRoot(path3) {\n  let curPath = path3;\n  do\n    curPath = curPath.parentPath;\n  while (curPath && !isMarko(curPath));\n  return curPath;\n}\nfunction getExprRoot(path3) {\n  let curPath = path3;\n  while (!isMarko(curPath.parentPath)) {\n    curPath = curPath.parentPath;\n    if (curPath.type === \"AssignmentExpression\") {\n      const destructRoot = getDestructureRoot(curPath);\n      if (isMarko(destructRoot.parentPath)) {\n        curPath = curPath.get(\"right\");\n        break;\n      }\n      curPath = destructRoot.parentPath;\n    }\n  }\n  return curPath;\n}\nfunction getFnRoot(path3) {\n  let curPath = path3;\n  if (curPath.isProgram()) return;\n  while (!isFunctionExpression(curPath)) {\n    if (isMarko(curPath)) return;\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction isMarko(path3) {\n  switch (path3.type) {\n    case \"MarkoTag\":\n    case \"MarkoTagBody\":\n    case \"MarkoAttribute\":\n    case \"MarkoSpreadAttribute\":\n    case \"MarkoPlaceholder\":\n    case \"MarkoScriptlet\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isFunctionExpression(path3) {\n  switch (path3.type) {\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction getDestructureRoot(path3) {\n  switch (path3.parent.type) {\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"ObjectProperty\":\n      return getDestructureRoot(path3.parentPath);\n    default:\n      return path3;\n  }\n}\n\n// src/util/references.ts\nvar [getBindings] = createProgramState(() => /* @__PURE__ */ new Set());\nvar [getNextBindingId, setNextBindingId] = createProgramState(() => 0);\nfunction createBinding(name, type, section, upstreamAlias, upstreamExpression, property) {\n  const id = getNextBindingId();\n  const binding = {\n    id,\n    name,\n    type,\n    section,\n    property,\n    excludeProperties: void 0,\n    serialize: false,\n    aliases: /* @__PURE__ */ new Set(),\n    propertyAliases: /* @__PURE__ */ new Map(),\n    upstreamAlias,\n    upstreamExpression,\n    downstreamExpressions: /* @__PURE__ */ new Set(),\n    export: void 0\n  };\n  if (property) {\n    const propBinding = upstreamAlias.propertyAliases.get(property);\n    if (propBinding) {\n      binding.property = void 0;\n      binding.upstreamAlias = propBinding;\n      propBinding.aliases.add(binding);\n    } else {\n      upstreamAlias.propertyAliases.set(property, binding);\n    }\n  } else if (upstreamAlias) {\n    upstreamAlias.aliases.add(binding);\n  }\n  setNextBindingId(id + 1);\n  getBindings().add(binding);\n  return binding;\n}\nfunction trackVarReferences(tag, type, upstreamAlias, upstreamExpression, changeBinding) {\n  const tagVar = tag.node.var;\n  if (tagVar) {\n    const section = getOrCreateSection(tag);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    upstreamAlias?.downstreamExpressions.delete(upstreamExpression);\n    createBindingsAndTrackReferences(\n      tagVar,\n      type,\n      tag.scope,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0,\n      changeBinding\n    );\n  }\n}\nfunction trackParamsReferences(body, type, upstreamAlias, upstreamExpression) {\n  const params = body.node.params;\n  if (body.get(\"body\").length && params.length) {\n    upstreamAlias?.downstreamExpressions.delete(upstreamExpression);\n    const section = getOrCreateSection(body);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    const paramsBinding = canonicalUpstreamAlias || ((body.node.extra ??= {}).binding = createBinding(\n      body.scope.generateUid(\"params_\"),\n      type,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0\n    ));\n    for (let i = 0; i < params.length; i++) {\n      createBindingsAndTrackReferences(\n        params[i],\n        type,\n        body.scope,\n        section,\n        paramsBinding,\n        void 0,\n        i + \"\"\n      );\n    }\n  }\n}\nfunction trackReferencesForBinding(babelBinding, changeBinding) {\n  const { identifier, referencePaths, constantViolations } = babelBinding;\n  const binding = identifier.extra.binding;\n  for (const referencePath of referencePaths) {\n    trackReference(referencePath, binding);\n  }\n  for (const referencePath of constantViolations) {\n    const node = referencePath.node;\n    if (import_compiler16.types.isAssignmentExpression(node)) {\n      assignBinding(node.left, binding);\n    }\n    if (import_compiler16.types.isUpdateExpression(node)) {\n      assignBinding(node.argument, binding);\n    }\n    if (import_compiler16.types.isAssignmentExpression(node) && import_compiler16.types.isIdentifier(node.left) && node.operator !== \"=\") {\n      trackReference(\n        referencePath.get(\n          \"left\"\n        ),\n        binding\n      );\n    }\n    if (changeBinding) {\n      if (referencePath.isUpdateExpression()) {\n        trackReference(\n          referencePath.get(\"argument\"),\n          changeBinding\n        );\n      } else if (referencePath.isAssignmentExpression()) {\n        trackReference(\n          referencePath.get(\"left\"),\n          changeBinding\n        );\n      }\n    }\n  }\n}\nfunction assignBinding(node, binding) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        assignBinding(prop, binding);\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const element of node.elements) {\n        if (element !== null) {\n          assignBinding(element, binding);\n        }\n      }\n      break;\n    case \"RestElement\":\n      assignBinding(node.argument, binding);\n      break;\n    case \"ObjectProperty\":\n      assignBinding(node.value, binding);\n      break;\n    case \"Identifier\":\n      if (node.name === binding.name) {\n        (node.extra ??= {}).source = binding;\n      }\n      break;\n  }\n}\nfunction createBindingsAndTrackReferences(lVal, type, scope, section, upstreamAlias, upstreamExpression, property, changeBinding) {\n  switch (lVal.type) {\n    case \"Identifier\":\n      (lVal.extra ??= {}).binding = createBinding(\n        lVal.name,\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      );\n      trackReferencesForBinding(scope.getBinding(lVal.name), changeBinding);\n      break;\n    case \"ObjectPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        scope.generateUid(\"pattern_\"),\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      ));\n      for (const prop of lVal.properties) {\n        if (prop.type === \"RestElement\") {\n          createBindingsAndTrackReferences(\n            prop.argument,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            property\n          );\n        } else {\n          let key;\n          if (prop.key.type === \"Identifier\") {\n            key = prop.key.name;\n          } else if (prop.key.type === \"StringLiteral\") {\n            key = prop.key.value;\n          } else {\n            throw new Error(\"computed keys not supported in object pattern\");\n          }\n          createBindingsAndTrackReferences(\n            prop.value,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            key\n          );\n        }\n      }\n      break;\n    }\n    case \"ArrayPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        scope.generateUid(\"pattern_\"),\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      ));\n      let i = -1;\n      for (const element of lVal.elements) {\n        i++;\n        if (element) {\n          if (element.type === \"RestElement\") {\n            createBindingsAndTrackReferences(\n              element.argument,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              property\n            );\n          } else {\n            createBindingsAndTrackReferences(\n              element,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              `${i}`\n            );\n          }\n        }\n      }\n      break;\n    }\n    case \"AssignmentPattern\":\n      createBindingsAndTrackReferences(\n        lVal.left,\n        type,\n        scope,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      );\n      break;\n  }\n}\nfunction trackReference(referencePath, binding) {\n  const fnRoot = getFnRoot(referencePath.scope.path);\n  const exprRoot = getExprRoot(fnRoot || referencePath);\n  const section = getOrCreateSection(exprRoot);\n  const reference = binding;\n  const exprExtra = exprRoot.node.extra ??= {};\n  addReferenceToExpression(exprRoot, binding);\n  assignBinding(referencePath.node, binding);\n  if (fnRoot) {\n    let fnExtra = exprExtra;\n    if (fnRoot !== exprRoot) {\n      fnExtra = fnRoot.node.extra ??= {};\n      fnExtra.referencedBindings = addReference(\n        section,\n        fnExtra.referencedBindings,\n        reference\n      );\n    }\n  }\n}\nvar [getMergedReferences] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction mergeReferences(target, nodes) {\n  getMergedReferences().set(target, nodes);\n}\nfunction compareIntersections(a, b) {\n  const len = a.length;\n  const lenDelta = len - b.length;\n  if (lenDelta !== 0) {\n    return lenDelta;\n  }\n  for (let i = 0; i < len; i++) {\n    const compareResult = bindingUtil.compare(a[i], b[i]);\n    if (compareResult !== 0) {\n      return compareResult;\n    }\n  }\n  return 0;\n}\nfunction finalizeReferences() {\n  const mergedReferences = getMergedReferences();\n  if (mergedReferences.size) {\n    for (const [target, nodes] of mergedReferences) {\n      const targetExtra = target.node.extra ??= {};\n      let { referencedBindings, isEffect } = targetExtra;\n      for (const node of nodes) {\n        const extra = node?.extra;\n        if (extra) {\n          const additionalBindings = extra.referencedBindings;\n          isEffect ||= extra.isEffect;\n          if (additionalBindings) {\n            referencedBindings = bindingUtil.union(\n              referencedBindings,\n              additionalBindings\n            );\n            forEach(additionalBindings, ({ downstreamExpressions }) => {\n              downstreamExpressions.delete(extra);\n              downstreamExpressions.add(targetExtra);\n            });\n          }\n        }\n      }\n      referencedBindings = findReferences(\n        getOrCreateSection(target),\n        referencedBindings\n      );\n      targetExtra.referencedBindings = referencedBindings;\n      targetExtra.isEffect = isEffect;\n    }\n    mergedReferences.clear();\n  }\n  const bindings = getBindings();\n  for (const binding of bindings) {\n    if (binding.type !== 0 /* dom */ && !binding.upstreamAlias) {\n      if (pruneBinding(bindings, binding)) {\n        const { upstreamExpression } = binding;\n        if (upstreamExpression) {\n          forEach(\n            upstreamExpression.referencedBindings,\n            (referencedBinding) => {\n              referencedBinding.downstreamExpressions.delete(\n                upstreamExpression\n              );\n              pruneBinding(bindings, referencedBinding);\n            }\n          );\n        }\n      }\n    }\n  }\n  const intersections = /* @__PURE__ */ new Set();\n  for (const binding of bindings) {\n    const { name, section } = binding;\n    if (binding.type !== 0 /* dom */) {\n      for (const existingBinding of section.bindings) {\n        if (existingBinding.name === binding.name) {\n          binding.name = currentProgramPath.scope.generateUid(name);\n          break;\n        }\n      }\n    }\n    section.bindings.add(binding);\n    for (const {\n      referencedBindings,\n      isEffect\n    } of binding.downstreamExpressions) {\n      if (Array.isArray(referencedBindings)) {\n        intersections.add(referencedBindings);\n      }\n      forEach(referencedBindings, (bindingReference) => {\n        if (isEffect) {\n          bindingReference.serialize = true;\n        }\n      });\n    }\n  }\n  for (const intersection of intersections) {\n    const numReferences = intersection.length;\n    for (let i = 0; i < numReferences - 1; i++) {\n      for (let j = i + 1; j < numReferences; j++) {\n        const binding1 = intersection[i];\n        const binding2 = intersection[j];\n        const sources1 = getSourceBindings(binding1);\n        const sources2 = getSourceBindings(binding2);\n        if (!binding1.serialize && !isSuperset(sources1, sources2)) {\n          binding1.serialize = true;\n        }\n        if (!binding2.serialize && !isSuperset(sources2, sources1)) {\n          binding2.serialize = true;\n        }\n      }\n    }\n  }\n  forEachSection((section) => {\n    for (const binding of section.closures) {\n      if (!binding.serialize) {\n        let serialize = false;\n        const sourceSection = binding.section;\n        let currentSection = section;\n        while (currentSection !== sourceSection && !(serialize = !currentSection.upstreamExpression || isStatefulReferences(\n          currentSection.upstreamExpression.referencedBindings\n        ))) {\n          currentSection = currentSection.parent;\n        }\n        binding.serialize = serialize;\n      }\n    }\n  });\n  forEachSection(({ id, bindings: bindings2 }) => {\n    const sortedBindings = [...bindings2].filter((b) => b.section.id === id).sort(bindingUtil.compare);\n    for (let i = sortedBindings.length; i--; ) {\n      const binding = sortedBindings[i];\n      binding.id = i;\n    }\n  });\n}\nfunction isSuperset(set, subset) {\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getSourceBindings(binding) {\n  const derived = /* @__PURE__ */ new Set();\n  const sources = /* @__PURE__ */ new Set();\n  crawl(binding);\n  return sources;\n  function crawl(binding2) {\n    if (binding2.type === 4 /* derived */ || binding2.type === 3 /* param */) {\n      let alias;\n      let curBinding = binding2;\n      while (alias = curBinding.upstreamAlias) {\n        curBinding = alias;\n      }\n      if (curBinding.upstreamExpression) {\n        if (derived.has(curBinding)) return;\n        derived.add(curBinding);\n        forEach(curBinding.upstreamExpression.referencedBindings, crawl);\n      } else {\n        sources.add(curBinding);\n      }\n    } else {\n      sources.add(binding2);\n    }\n  }\n}\nvar bindingUtil = new Sorted(function compareBindings(a, b) {\n  return a.section.id - b.section.id || a.type !== b.type && (a.type === 0 /* dom */ || b.type === 0 /* dom */) ? a.type - b.type || a.id - b.id : a.id - b.id;\n});\nvar [getIntersections, setIntersections] = createSectionState(\n  \"intersections\",\n  () => []\n);\nfunction addReferenceToExpression(path3, binding) {\n  const exprExtra = path3.node.extra ??= {};\n  const section = getOrCreateSection(path3);\n  exprExtra.referencedBindings = addReference(\n    section,\n    exprExtra.referencedBindings,\n    binding\n  );\n  binding.downstreamExpressions.add(exprExtra);\n}\nfunction getCanonicalBinding(binding) {\n  return binding && (binding.property ? binding : binding.upstreamAlias || binding);\n}\nfunction addReference(section, referencedBindings, binding) {\n  if (section !== binding.section) {\n    section.closures.add(binding);\n  }\n  const newIntersection = bindingUtil.add(referencedBindings, binding);\n  return findReferences(section, newIntersection);\n}\nfunction findReferences(section, referencedBindings) {\n  if (!referencedBindings || !Array.isArray(referencedBindings)) {\n    return referencedBindings;\n  }\n  const intersections = getIntersections(section);\n  let intersection = findSorted(\n    compareIntersections,\n    intersections,\n    referencedBindings\n  );\n  if (!intersection) {\n    setIntersections(\n      section,\n      addSorted(compareIntersections, intersections, referencedBindings)\n    );\n    intersection = referencedBindings;\n  }\n  return intersection;\n}\nfunction getScopeAccessorLiteral(binding) {\n  if (isOptimize()) {\n    return import_compiler16.types.numericLiteral(binding.id);\n  }\n  return import_compiler16.types.stringLiteral(\n    binding.name + (binding.type === 0 /* dom */ ? `/${binding.id}` : \"\")\n  );\n}\nfunction pruneBinding(bindings, binding) {\n  let shouldPrune = !binding.downstreamExpressions.size;\n  for (const alias of binding.aliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.aliases.delete(alias);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  for (const [key, alias] of binding.propertyAliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.propertyAliases.delete(key);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  if (shouldPrune) {\n    bindings.delete(binding);\n  }\n  return shouldPrune;\n}\n\n// src/util/is-stateful.ts\nfunction isStatefulReferences(referencedBindings) {\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        if (isStatefulBinding(ref)) {\n          return true;\n        }\n      }\n    } else {\n      return isStatefulBinding(referencedBindings);\n    }\n  }\n  return false;\n}\nfunction isStatefulBinding(binding) {\n  switch (binding.type) {\n    case 1 /* let */:\n    case 2 /* input */:\n      return true;\n    default:\n      return !binding.upstreamExpression || isStatefulReferences(binding.upstreamExpression.referencedBindings);\n  }\n}\n\n// src/util/to-first-statement-or-block.ts\nvar import_compiler17 = require(\"@marko/compiler\");\nfunction toFirstStatementOrBlock(body) {\n  const nodes = body.body;\n  if (nodes.length === 1) {\n    return nodes[0];\n  }\n  if (import_compiler17.types.isBlockStatement(body)) {\n    return body;\n  }\n  return import_compiler17.types.blockStatement(nodes);\n}\n\n// src/core/condition/if.ts\nvar kBinding = Symbol(\"if node binding\");\nvar if_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const [testAttr] = node.attributes;\n    (0, import_babel_utils11.assertNoArgs)(tag);\n    (0, import_babel_utils11.assertNoVar)(tag);\n    (0, import_babel_utils11.assertNoParams)(tag);\n    if (!import_compiler18.types.isMarkoAttribute(testAttr) || !testAttr.default) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `if` tag requires a value.\");\n    }\n    if (node.body.body.length === 0) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `if` tag requires body content.\");\n    }\n    if (node.attributes.length > 1) {\n      const start = node.attributes[1].loc?.start;\n      const end = node.attributes[node.attributes.length - 1].loc?.end;\n      const msg = \"The `if` tag only supports the `value` attribute.\";\n      if (start == null || end == null) {\n        throw tag.get(\"name\").buildCodeFrameError(msg);\n      } else {\n        throw tag.hub.buildError(\n          { loc: { start, end } },\n          msg,\n          Error\n        );\n      }\n    }\n    const tagBody = tag.get(\"body\");\n    const section = getOrCreateSection(tag);\n    const tagExtra = tag.node.extra ??= {};\n    startSection(tagBody);\n    tagExtra[kBinding] = createBinding(\n      \"#text\",\n      0 /* dom */,\n      section,\n      void 0,\n      tagExtra\n    );\n    analyze(tag);\n  },\n  translate: {\n    enter(tag) {\n      visit(tag, 37 /* Replace */);\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n      translate.enter(tag);\n    },\n    exit(tag) {\n      translate.exit(tag);\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      snippet: \"if=${1:condition}\",\n      description: \"Use to display content only if the condition is met.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar BRANCHES_LOOKUP = /* @__PURE__ */ new WeakMap();\nfunction getBranches(tag, bodySection) {\n  const branches = BRANCHES_LOOKUP.get(tag) ?? [];\n  const nextTag = tag.getNextSibling();\n  const isLast = !(isCoreTagName(nextTag, \"else\") || isCoreTagName(nextTag, \"else-if\"));\n  branches.push({\n    tag,\n    section: bodySection\n  });\n  if (!isLast) {\n    BRANCHES_LOOKUP.set(nextTag, branches);\n  }\n  return [isLast, branches];\n}\nfunction getRoot(tag) {\n  if (isCoreTagName(tag, \"if\")) {\n    return tag;\n  }\n  return BRANCHES_LOOKUP.get(tag)[0].tag;\n}\nfunction analyze(tag) {\n  const tagBody = tag.get(\"body\");\n  const bodySection = getOrCreateSection(tagBody);\n  const [isLast, branches] = getBranches(tag, bodySection);\n  if (isLast) {\n    const rootTag = branches[0].tag;\n    const rootExtra = rootTag.node.extra;\n    mergeReferences(\n      rootTag,\n      branches.map(({ tag: tag2 }) => tag2.node.attributes[0]?.value)\n    );\n    rootExtra.singleNodeOptimization = branches.every(({ section }) => {\n      return section.content === null || section.content.singleChild;\n    });\n    branches.forEach(({ section }) => {\n      section.upstreamExpression = rootExtra;\n    });\n  }\n}\nvar translate = {\n  enter(tag) {\n    const tagBody = tag.get(\"body\");\n    const bodySection = getSection(tagBody);\n    const rootExtra = getRoot(tag).node.extra;\n    const isStateful = isStatefulReferences(rootExtra.referencedBindings);\n    const singleNodeOptimization = rootExtra.singleNodeOptimization;\n    if (isOutputHTML() && isStateful && !singleNodeOptimization) {\n      writeTo(tagBody)`${callRuntime(\n        \"markResumeScopeStart\",\n        getScopeIdIdentifier(bodySection)\n      )}`;\n    }\n  },\n  exit(tag) {\n    const tagBody = tag.get(\"body\");\n    const section = getSection(tag);\n    const bodySection = getSection(tagBody);\n    const [isLast, branches] = getBranches(tag, bodySection);\n    const rootExtra = branches[0].tag.node.extra;\n    const nodeRef2 = rootExtra[kBinding];\n    const isStateful = isStatefulReferences(rootExtra.referencedBindings);\n    const singleNodeOptimization = rootExtra.singleNodeOptimization;\n    const hasStatefulClosures = checkStatefulClosures(bodySection, true);\n    setSectionParentIsOwner(bodySection, true);\n    if (isOutputHTML()) {\n      if (isStateful || hasStatefulClosures) {\n        setForceResumeScope(bodySection);\n      }\n      flushInto(tag);\n      setSubscriberBuilder(tag, () => {\n      });\n      writeHTMLResumeStatements(tagBody);\n    }\n    if (isLast) {\n      const extra = branches[0].tag.node.extra;\n      if (isOutputDOM()) {\n        let expr = import_compiler18.types.nullLiteral();\n        for (let i = branches.length; i--; ) {\n          const { tag: tag2, section: section2 } = branches[i];\n          const [testAttr] = tag2.node.attributes;\n          const id = import_compiler18.types.identifier(section2.name);\n          setSubscriberBuilder(tag2, (subscriber) => {\n            return callRuntime(\n              \"inConditionalScope\",\n              subscriber,\n              getScopeAccessorLiteral(nodeRef2)\n              /*t.identifier(section.name)*/\n            );\n          });\n          tag2.remove();\n          if (testAttr) {\n            expr = import_compiler18.types.conditionalExpression(testAttr.value, id, expr);\n          } else {\n            expr = id;\n          }\n        }\n        const signal = getSignal(section, nodeRef2, \"if\");\n        signal.build = () => {\n          return callRuntime(\n            \"conditional\",\n            getScopeAccessorLiteral(nodeRef2),\n            getSignalFn(signal, [scopeIdentifier])\n          );\n        };\n        signal.hasDownstreamIntersections = () => branches.some((b) => getClosures(b.section).length > 0);\n        addValue(section, extra.referencedBindings, signal, expr);\n      } else {\n        const write2 = writeTo(tag);\n        const nextTag = tag.getNextSibling();\n        const ifScopeIdIdentifier = tag.scope.generateUidIdentifier(\"ifScopeId\");\n        const ifRendererIdentifier = tag.scope.generateUidIdentifier(\"ifRenderer\");\n        let statement;\n        for (let i = branches.length; i--; ) {\n          const { tag: tag2, section: section2 } = branches[i];\n          const branchHasStatefulClosures = checkStatefulClosures(\n            section2,\n            true\n          );\n          if (isStateful) {\n            tag2.node.body.body.push(\n              import_compiler18.types.expressionStatement(\n                callRuntime(\n                  \"register\",\n                  import_compiler18.types.assignmentExpression(\n                    \"=\",\n                    ifRendererIdentifier,\n                    callRuntime(\n                      \"createRenderer\",\n                      import_compiler18.types.arrowFunctionExpression([], import_compiler18.types.blockStatement([]))\n                    )\n                  ),\n                  import_compiler18.types.stringLiteral(getResumeRegisterId(section2, \"renderer\"))\n                )\n              )\n            );\n          }\n          if (isStateful || branchHasStatefulClosures) {\n            tag2.node.body.body.push(\n              import_compiler18.types.expressionStatement(\n                import_compiler18.types.assignmentExpression(\n                  \"=\",\n                  ifScopeIdIdentifier,\n                  getScopeIdIdentifier(section2)\n                )\n              )\n            );\n          }\n          const [testAttr] = tag2.node.attributes;\n          const curStatement = toFirstStatementOrBlock(tag2.node.body);\n          if (testAttr) {\n            statement = import_compiler18.types.ifStatement(testAttr.value, curStatement, statement);\n          } else {\n            statement = curStatement;\n          }\n          tag2.remove();\n        }\n        if (!isStateful && !hasStatefulClosures) {\n          nextTag.insertBefore(statement);\n        } else {\n          nextTag.insertBefore([\n            import_compiler18.types.variableDeclaration(\n              \"let\",\n              [\n                import_compiler18.types.variableDeclarator(ifScopeIdIdentifier),\n                isStateful && import_compiler18.types.variableDeclarator(ifRendererIdentifier)\n              ].filter(Boolean)\n            ),\n            statement\n          ]);\n          if (isStateful) {\n            if (singleNodeOptimization) {\n              write2`${callRuntime(\n                \"markResumeControlSingleNodeEnd\",\n                getScopeIdIdentifier(section),\n                getScopeAccessorLiteral(nodeRef2),\n                ifScopeIdIdentifier\n              )}`;\n            } else {\n              write2`${callRuntime(\n                \"markResumeControlEnd\",\n                getScopeIdIdentifier(section),\n                getScopeAccessorLiteral(nodeRef2)\n              )}`;\n            }\n            getSerializedScopeProperties(section).set(\n              import_compiler18.types.stringLiteral(\n                getScopeAccessorLiteral(nodeRef2).value + \"(\" /* ConditionalRenderer */\n              ),\n              ifRendererIdentifier\n            );\n          }\n          getSerializedScopeProperties(section).set(\n            import_compiler18.types.stringLiteral(\n              getScopeAccessorLiteral(nodeRef2).value + \"!\" /* ConditionalScope */\n            ),\n            callRuntime(\"getScopeById\", ifScopeIdIdentifier)\n          );\n        }\n      }\n    }\n  }\n};\n\n// src/core/condition/else.ts\nvar else_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const [testAttr] = node.attributes;\n    (0, import_babel_utils12.assertNoVar)(tag);\n    (0, import_babel_utils12.assertNoArgs)(tag);\n    (0, import_babel_utils12.assertNoParams)(tag);\n    if (node.body.body.length === 0) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `else` tag requires body content.\");\n    }\n    if (node.attributes.length > 1 || testAttr && testAttr.name !== \"if\") {\n      const start = node.attributes[1].loc?.start;\n      const end = node.attributes[node.attributes.length - 1].loc?.end;\n      const msg = \"The `else` tag only supports an `if=` attribute.\";\n      if (start == null || end == null) {\n        throw tag.get(\"name\").buildCodeFrameError(msg);\n      } else {\n        throw tag.hub.buildError(\n          { loc: { start, end } },\n          msg,\n          Error\n        );\n      }\n    }\n    analyze(tag);\n  },\n  translate,\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\n\n// src/core/condition/else-if.ts\nvar import_babel_utils13 = require(\"@marko/babel-utils\");\nvar import_compiler19 = require(\"@marko/compiler\");\nvar else_if_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    (0, import_babel_utils13.assertNoArgs)(tag);\n    (0, import_babel_utils13.assertNoVar)(tag);\n    (0, import_babel_utils13.assertNoParams)(tag);\n    if (!import_compiler19.types.isMarkoAttribute(valueAttr) || !valueAttr.default) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `else-if` tag requires a value.\");\n    }\n    if (node.body.body.length === 0) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `else-if` tag requires body content.\");\n    }\n    if (node.attributes.length > 1) {\n      const start = node.attributes[1].loc?.start;\n      const end = node.attributes[node.attributes.length - 1].loc?.end;\n      const msg = \"The `else-if` tag only supports the `value` attribute.\";\n      if (start == null || end == null) {\n        throw tag.get(\"name\").buildCodeFrameError(msg);\n      } else {\n        throw tag.hub.buildError(\n          { loc: { start, end } },\n          msg,\n          Error\n        );\n      }\n    }\n    analyze(tag);\n  },\n  translate,\n  attributes: {},\n  autocomplete: [\n    {\n      snippet: \"else-if=${1:condition}\",\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\n\n// src/core/const.ts\nvar import_babel_utils14 = require(\"@marko/babel-utils\");\nvar import_compiler21 = require(\"@marko/compiler\");\n\n// src/util/translate-var.ts\nvar import_compiler20 = require(\"@marko/compiler\");\nfunction translateVar(tag, initialValue, kind = \"const\") {\n  const {\n    node: { var: tagVar }\n  } = tag;\n  if (!tagVar) {\n    return;\n  }\n  tag.insertBefore(\n    import_compiler20.types.variableDeclaration(kind, [import_compiler20.types.variableDeclarator(tagVar, initialValue)])\n  );\n}\n\n// src/core/const.ts\nvar const_default = {\n  analyze(tag) {\n    (0, import_babel_utils14.assertNoArgs)(tag);\n    (0, import_babel_utils14.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a tag variable.\");\n    }\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler21.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `const` tag only supports the `value` attribute.\"\n      );\n    }\n    const upstreamAlias = import_compiler21.types.isIdentifier(valueAttr.value) ? tag.scope.getBinding(valueAttr.value.name)?.identifier.extra?.binding : void 0;\n    trackVarReferences(\n      tag,\n      4 /* derived */,\n      upstreamAlias,\n      valueAttr.value.extra ??= {}\n    );\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      const { value } = valueAttr;\n      if (isOutputDOM()) {\n        const section = getSection(tag);\n        const varBinding = node.var.extra?.binding;\n        if (varBinding && !varBinding.upstreamAlias) {\n          const derivation = initValue(varBinding);\n          addValue(section, value.extra?.referencedBindings, derivation, value);\n        }\n      } else {\n        translateVar(tag, value);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an constant binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#const\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/const.d.marko\"\n};\n\n// src/core/debug.ts\nvar import_babel_utils15 = require(\"@marko/babel-utils\");\nvar import_compiler22 = require(\"@marko/compiler\");\nvar debug_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils15.assertNoVar)(tag);\n    (0, import_babel_utils15.assertNoArgs)(tag);\n    (0, import_babel_utils15.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (tag.node.attributes.length > 1 || tag.node.attributes.length === 1 && (!import_compiler22.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\")) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `debug` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const referencedBindings = valueAttr?.value.extra?.referencedBindings;\n      const statement = withPreviousLocation(import_compiler22.types.debuggerStatement(), tag.node);\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Debug on value change.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#debug\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/debug.d.marko\"\n};\n\n// src/core/define.ts\nvar import_babel_utils17 = require(\"@marko/babel-utils\");\nvar import_compiler25 = require(\"@marko/compiler\");\n\n// src/util/attrs-to-object.ts\nvar import_babel_utils16 = require(\"@marko/babel-utils\");\nvar import_compiler24 = require(\"@marko/compiler\");\n\n// src/util/to-property-name.ts\nvar import_compiler23 = require(\"@marko/compiler\");\nvar IDENTIFIER_REG = /^[0-9A-Z_$]+$/i;\nfunction toPropertyName(name) {\n  return IDENTIFIER_REG.test(name) ? import_compiler23.types.identifier(name) : import_compiler23.types.stringLiteral(name);\n}\n\n// src/util/attrs-to-object.ts\nvar renderBodyProps = /* @__PURE__ */ new WeakMap();\nfunction attrsToObject(tag, withRenderBody = false) {\n  const { node } = tag;\n  let result = import_compiler24.types.objectExpression([]);\n  const resultExtra = result.extra = {};\n  for (const attr2 of tag.get(\"attributes\")) {\n    const value = attr2.node.value;\n    if (attr2.isMarkoSpreadAttribute()) {\n      result.properties.push(import_compiler24.types.spreadElement(value));\n    } else {\n      result.properties.push(\n        import_compiler24.types.objectProperty(\n          toPropertyName(attr2.node.name),\n          value\n        )\n      );\n    }\n  }\n  if (withRenderBody) {\n    const { body, params } = node.body;\n    let hoistedControlFlows = node.extra.hoistedControlFlows;\n    if (hoistedControlFlows) {\n      for (const child of tag.get(\"body\").get(\"body\")) {\n        tag.insertBefore(child.node);\n        child.remove();\n        if (child.isConditional() || child.isLoop()) {\n          if (!--hoistedControlFlows) {\n            break;\n          }\n        }\n      }\n    }\n    if (body.length) {\n      const renderBodySection = getSection(tag.get(\"body\"));\n      const renderBodyExpression = import_compiler24.types.arrowFunctionExpression(\n        params,\n        import_compiler24.types.blockStatement(body)\n      );\n      renderBodyProps.set(result, renderBodyExpression);\n      if (isOutputHTML()) {\n        result.properties.push(\n          import_compiler24.types.objectProperty(\n            import_compiler24.types.identifier(\"renderBody\"),\n            callRuntime(\n              \"register\",\n              callRuntime(\"createRenderer\", renderBodyExpression),\n              import_compiler24.types.stringLiteral(\n                getResumeRegisterId(renderBodySection, \"renderer\")\n              ),\n              getScopeIdIdentifier(getSection(getNonAttributeTagParent(tag)))\n            )\n          )\n        );\n      } else {\n        result.properties.push(\n          import_compiler24.types.objectProperty(import_compiler24.types.identifier(\"renderBody\"), renderBodyExpression)\n        );\n      }\n    }\n  }\n  if (result.properties.length) {\n    if (result.properties.length === 1) {\n      const [prop] = result.properties;\n      if (import_compiler24.types.isSpreadElement(prop)) {\n        result = prop.argument;\n        result.extra = resultExtra;\n      }\n    }\n  }\n  if (node.arguments?.length) {\n    if (result.properties.length) {\n      result = import_compiler24.types.arrayExpression([...node.arguments, result]);\n    } else if (node.arguments.length == 1) {\n      const arg = node.arguments[0];\n      result = import_compiler24.types.isSpreadElement(arg) ? arg.argument : arg;\n    } else {\n      result = import_compiler24.types.arrayExpression(node.arguments);\n    }\n  }\n  return result;\n}\nfunction getRenderBodyProp(attrsObject) {\n  if (import_compiler24.types.isObjectExpression(attrsObject)) {\n    const lastProp = attrsObject.properties[attrsObject.properties.length - 1];\n    if (import_compiler24.types.isObjectProperty(lastProp) && lastProp.key.name === \"renderBody\") {\n      return renderBodyProps.get(attrsObject);\n    }\n  }\n}\nfunction getNonAttributeTagParent(tag) {\n  let cur = tag;\n  while (cur.node && (0, import_babel_utils16.isAttributeTag)(cur) || (0, import_babel_utils16.isTransparentTag)(cur)) {\n    cur = cur.parentPath.parentPath;\n  }\n  return cur;\n}\n\n// src/core/define.ts\nvar define_default = {\n  analyze(tag) {\n    (0, import_babel_utils17.assertNoArgs)(tag);\n    if (!tag.node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `define` tag requires a tag variable.\");\n    }\n    const tagBody = tag.get(\"body\");\n    startSection(tagBody);\n    trackVarReferences(tag, 4 /* derived */);\n    trackParamsReferences(tagBody, 3 /* param */);\n    mergeReferences(\n      tag,\n      tag.node.attributes.map((attr2) => attr2.value)\n    );\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        const attrs2 = attrsToObject(tag, true);\n        translateVar(tag, attrs2);\n      } else {\n        const section = getSection(tag);\n        const tagBody = tag.get(\"body\");\n        const tagBodySection = getSection(tagBody);\n        const referencedBindings = node.extra?.referencedBindings;\n        const derivation = initValue(tag.get(\"var\").node.extra.binding);\n        let attrsObject = attrsToObject(tag);\n        if (tagBodySection !== section) {\n          attrsObject ??= import_compiler25.types.objectExpression([]);\n          attrsObject.properties.push(\n            import_compiler25.types.objectProperty(\n              import_compiler25.types.identifier(\"renderBody\"),\n              import_compiler25.types.callExpression(import_compiler25.types.identifier(tagBodySection.name), [\n                scopeIdentifier\n              ])\n            )\n          );\n        }\n        addValue(section, referencedBindings, derivation, attrsObject);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a constant object binding that can be rendered.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#define\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/define.d.marko\"\n};\n\n// src/core/do.ts\nvar import_babel_utils18 = require(\"@marko/babel-utils\");\nvar import_compiler26 = require(\"@marko/compiler\");\nvar do_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils18.assertNoArgs)(tag);\n    (0, import_babel_utils18.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils18.assertNoVar)(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `do` tag requires a value.\");\n    }\n    if (tag.node.attributes.length > 1 || !import_compiler26.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `do` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      let statement = null;\n      if (import_compiler26.types.isFunctionExpression(value) || import_compiler26.types.isArrowFunctionExpression(value)) {\n        if (import_compiler26.types.isBlockStatement(value.body)) {\n          let hasDeclaration = false;\n          for (const child of value.body.body) {\n            if (import_compiler26.types.isDeclaration(child)) {\n              hasDeclaration = true;\n              break;\n            }\n          }\n          statement = hasDeclaration ? value.body : value.body.body;\n        } else {\n          statement = import_compiler26.types.expressionStatement(value.body);\n        }\n      }\n      if (isOutputHTML()) {\n        if (statement) {\n          tag.insertBefore(statement);\n        } else {\n          tag.insertBefore(import_compiler26.types.expressionStatement(import_compiler26.types.callExpression(value, [])));\n        }\n      } else {\n        addStatement(\n          \"render\",\n          section,\n          referencedBindings,\n          statement ?? import_compiler26.types.expressionStatement(import_compiler26.types.callExpression(value, [scopeIdentifier]))\n        );\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to run a function on render.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#do\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/do.d.marko\"\n};\n\n// src/core/effect.ts\nvar import_babel_utils19 = require(\"@marko/babel-utils\");\nvar import_compiler27 = require(\"@marko/compiler\");\nvar effect_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    (0, import_babel_utils19.assertNoArgs)(tag);\n    (0, import_babel_utils19.assertNoVar)(tag);\n    (0, import_babel_utils19.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `effect` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler27.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `effect` tag only supports the `value` attribute.\"\n      );\n    }\n    (valueAttr.value.extra ??= {}).isEffect = true;\n    (currentProgramPath.node.extra ??= {}).isInteractive = true;\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      const section = getSection(tag);\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      if (isOutputDOM()) {\n        const { value: value2 } = valueAttr;\n        let inlineBody = null;\n        if (import_compiler27.types.isFunctionExpression(value2) || import_compiler27.types.isArrowFunctionExpression(value2)) {\n          if (import_compiler27.types.isBlockStatement(value2.body)) {\n            let hasDeclaration = false;\n            for (const child of value2.body.body) {\n              if (import_compiler27.types.isDeclaration(child)) {\n                hasDeclaration = true;\n                break;\n              }\n            }\n            inlineBody = hasDeclaration ? value2.body : value2.body.body;\n          } else {\n            inlineBody = import_compiler27.types.expressionStatement(value2.body);\n          }\n        }\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          inlineBody || import_compiler27.types.expressionStatement(import_compiler27.types.callExpression(value2, [scopeIdentifier])),\n          value2,\n          !!inlineBody\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/effect.d.marko\"\n};\n\n// src/core/export.ts\nvar import_babel_utils20 = require(\"@marko/babel-utils\");\nvar export_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils20.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"export <value>\"\n    }\n  ]\n};\n\n// src/core/for.ts\nvar import_babel_utils24 = require(\"@marko/babel-utils\");\nvar import_compiler29 = require(\"@marko/compiler\");\n\n// src/util/nested-attribute-tags.ts\nvar import_babel_utils21 = require(\"@marko/babel-utils\");\nfunction analyzeAttributeTags(tag) {\n  const extra = tag.node.extra ??= {};\n  extra.nestedAttributeTags = {};\n  extra.hoistedControlFlows = 0;\n  analyzeChildren(extra, false, false, tag);\n}\nfunction analyzeChildren(rootExtra, repeated, dynamic, tag) {\n  let hasAttributeTags = false;\n  for (const child of tag.get(\"body\").get(\"body\")) {\n    if (child.isMarkoTag()) {\n      if (analyzeChild(rootExtra, repeated, dynamic, child)) {\n        hasAttributeTags = true;\n      }\n    }\n  }\n  return hasAttributeTags;\n}\nfunction analyzeChild(rootExtra, repeated, dynamic, tag) {\n  if ((0, import_babel_utils21.isTransparentTag)(tag)) {\n    if (analyzeChildren(rootExtra, repeated || (0, import_babel_utils21.isLoopTag)(tag), true, tag)) {\n      if (!(0, import_babel_utils21.isTransparentTag)(tag.parentPath.parentPath)) {\n        rootExtra.hoistedControlFlows++;\n      }\n      return true;\n    }\n  } else if ((0, import_babel_utils21.isAttributeTag)(tag)) {\n    const attrName = tag.node.name.value.slice(1);\n    const lookup = rootExtra.nestedAttributeTags;\n    const existing = lookup[attrName];\n    const info = existing || (lookup[attrName] = {\n      dynamic: false,\n      repeated: false\n    });\n    info.dynamic ||= dynamic;\n    info.repeated ||= repeated || existing !== void 0;\n    return true;\n  }\n  return false;\n}\n\n// src/visitors/tag/native-tag.ts\nvar import_babel_utils23 = require(\"@marko/babel-utils\");\nvar import_compiler28 = require(\"@marko/compiler\");\n\n// src/util/evaluate.ts\nvar import_babel_utils22 = require(\"@marko/babel-utils\");\nfunction evaluate(path3) {\n  let { extra } = path3.node;\n  if (!extra) {\n    extra = path3.node.extra = {};\n  }\n  if (extra.confident === void 0) {\n    const computed = (0, import_babel_utils22.computeNode)(path3.node.value);\n    if (computed) {\n      extra.computed = computed.value;\n      extra.confident = true;\n    } else {\n      extra.computed = void 0;\n      extra.confident = false;\n    }\n  }\n  return extra;\n}\n\n// src/visitors/tag/native-tag.ts\nvar kNativeTagBinding = Symbol(\"native tag binding\");\nvar kSerializeMarker = Symbol(\"serialize marker\");\nvar kGetterId = Symbol(\"node getter id\");\nvar native_tag_default = {\n  analyze: {\n    enter(tag) {\n      const { node } = tag;\n      const attrs2 = tag.get(\"attributes\");\n      const tagVar = tag.node.var;\n      let hasEventHandlers = false;\n      let hasDynamicAttributes = false;\n      for (const attr2 of attrs2) {\n        if (isSpreadAttr(attr2)) {\n          (attr2.node.value.extra ??= {}).isEffect = true;\n          hasEventHandlers = true;\n          hasDynamicAttributes = true;\n          mergeReferences(\n            tag,\n            attrs2.map((attr3) => attr3.node.value)\n          );\n        } else if (isEventHandler(attr2.node.name)) {\n          (attr2.node.value.extra ??= {}).isEffect = true;\n          hasEventHandlers = true;\n        } else if (!evaluate(attr2).confident) {\n          hasDynamicAttributes = true;\n        }\n      }\n      if (tagVar || hasEventHandlers || hasDynamicAttributes) {\n        currentProgramPath.node.extra.isInteractive ||= hasEventHandlers;\n        const section = getOrCreateSection(tag);\n        const tagName = node.name.type === \"StringLiteral\" ? node.name.value : import_compiler28.types.toIdentifier(tag.get(\"name\"));\n        const tagExtra = node.extra ??= {};\n        const bindingName = \"#\" + tagName;\n        tagExtra[kSerializeMarker] = !!tagVar || hasEventHandlers;\n        tagExtra[kNativeTagBinding] = createBinding(\n          bindingName,\n          0 /* dom */,\n          section\n        );\n        if (tagVar) {\n          if (import_compiler28.types.isIdentifier(tagVar)) {\n            for (const ref of tag.scope.getBinding(tagVar.name).referencePaths) {\n              if (!ref.parentPath?.isCallExpression()) {\n                tagExtra[kGetterId] = getRegisterUID(section, bindingName);\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      (0, import_babel_utils23.assertNoArgs)(tag);\n      const extra = tag.node.extra;\n      const nodeRef2 = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const name = tag.get(\"name\");\n      const attrs2 = tag.get(\"attributes\");\n      const tagDef = (0, import_babel_utils23.getTagDef)(tag);\n      const hasSpread = attrs2.some((attr2) => attr2.isMarkoSpreadAttribute());\n      const write2 = writeTo(tag);\n      const section = getSection(tag);\n      if (isHTML && extra.tagNameNullable) {\n        flushBefore(tag);\n      }\n      if (tag.has(\"var\")) {\n        const getterId = extra[kGetterId];\n        if (isHTML) {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          for (const reference of references) {\n            let currentSection = getSection(reference);\n            while (currentSection !== section && currentSection.parent) {\n              getSerializedScopeProperties(currentSection).set(\n                import_compiler28.types.stringLiteral(\"_\"),\n                callRuntime(\n                  \"ensureScopeWithId\",\n                  getScopeIdIdentifier(\n                    currentSection = currentSection.parent\n                  )\n                )\n              );\n            }\n          }\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(section),\n              getterId && import_compiler28.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n              `get_${varName}`\n            );\n            currentProgramPath.pushContainer(\n              \"body\",\n              import_compiler28.types.variableDeclaration(\"const\", [\n                import_compiler28.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler28.types.stringLiteral(getterId),\n                    getScopeAccessorLiteral(nodeRef2)\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (reference.parentPath?.isCallExpression()) {\n              reference.parentPath.replaceWith(\n                import_compiler28.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, nodeRef2)\n                )\n              );\n            } else if (getterFnIdentifier) {\n              reference.replaceWith(\n                import_compiler28.types.callExpression(getterFnIdentifier, [\n                  getScopeExpression(referenceSection, getSection(tag))\n                ])\n              );\n            }\n          }\n        }\n      }\n      let visitAccessor;\n      if (nodeRef2) {\n        visitAccessor = getScopeAccessorLiteral(nodeRef2);\n        visit(tag, 32 /* Get */);\n      }\n      write2`<${name.node}`;\n      if (hasSpread) {\n        const attrsObj = attrsToObject(tag);\n        if (isHTML) {\n          addHTMLEffectCall(section, extra.referencedBindings);\n          write2`${callRuntime(\"attrs\", attrsObj, visitAccessor, getScopeIdIdentifier(section))}`;\n        } else {\n          addStatement(\n            \"render\",\n            section,\n            extra.referencedBindings,\n            import_compiler28.types.expressionStatement(\n              callRuntime(\"attrs\", scopeIdentifier, visitAccessor, attrsObj)\n            )\n          );\n          addStatement(\n            \"effect\",\n            section,\n            extra.referencedBindings,\n            import_compiler28.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            attrsObj\n          );\n        }\n      } else {\n        for (const attr2 of attrs2) {\n          const name2 = attr2.node.name;\n          const value = attr2.get(\"value\");\n          const { confident, computed } = attr2.node.extra ?? {};\n          const valueReferences = value.node.extra?.referencedBindings;\n          switch (name2) {\n            case \"class\":\n            case \"style\": {\n              const helper = `${name2}Attr`;\n              if (confident) {\n                write2`${getHTMLRuntime()[helper](computed)}`;\n              } else if (isHTML) {\n                write2`${callRuntime(helper, value.node)}`;\n              } else {\n                addStatement(\n                  \"render\",\n                  section,\n                  valueReferences,\n                  import_compiler28.types.expressionStatement(\n                    callRuntime(\n                      helper,\n                      import_compiler28.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                      value.node\n                    )\n                  )\n                );\n              }\n              break;\n            }\n            default:\n              if (confident) {\n                write2`${getHTMLRuntime().attr(name2, computed)}`;\n              } else if (isHTML) {\n                if (isEventHandler(name2)) {\n                  addHTMLEffectCall(section, valueReferences);\n                } else {\n                  write2`${callRuntime(\n                    \"attr\",\n                    import_compiler28.types.stringLiteral(name2),\n                    value.node\n                  )}`;\n                }\n              } else if (isEventHandler(name2)) {\n                addStatement(\n                  \"effect\",\n                  section,\n                  valueReferences,\n                  import_compiler28.types.expressionStatement(\n                    callRuntime(\n                      \"on\",\n                      import_compiler28.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                      import_compiler28.types.stringLiteral(getEventHandlerName(name2)),\n                      value.node\n                    )\n                  ),\n                  value.node\n                );\n              } else {\n                addStatement(\n                  \"render\",\n                  section,\n                  valueReferences,\n                  import_compiler28.types.expressionStatement(\n                    callRuntime(\n                      \"attr\",\n                      import_compiler28.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                      import_compiler28.types.stringLiteral(name2),\n                      value.node\n                    )\n                  )\n                );\n              }\n              break;\n          }\n        }\n      }\n      if (tagDef && tagDef.parseOptions?.openTagOnly) {\n        switch (tagDef.htmlType) {\n          case \"svg\":\n          case \"math\":\n            write2`/>`;\n            break;\n          default:\n            write2`>`;\n            break;\n        }\n      } else {\n        write2`>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(import_compiler28.types.ifStatement(name.node, consumeHTML(tag)))[0].skip();\n      }\n      enter(tag);\n    },\n    exit(tag) {\n      const extra = tag.node.extra;\n      const nodeRef2 = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const openTagOnly = (0, import_babel_utils23.getTagDef)(tag)?.parseOptions?.openTagOnly;\n      if (isHTML && extra.tagNameNullable) {\n        flushInto(tag);\n      }\n      tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n      if (!openTagOnly) {\n        writeTo(tag)`</${tag.node.name}>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(\n          import_compiler28.types.ifStatement(tag.node.name, consumeHTML(tag))\n        )[0].skip();\n      }\n      if (nodeRef2 && (extra[kSerializeMarker] || tag.node.attributes.some(\n        (attr2) => isStatefulReferences(attr2.value.extra?.referencedBindings)\n      ))) {\n        markNode(tag, nodeRef2);\n      }\n      exit(tag);\n      tag.remove();\n    }\n  }\n};\nfunction isSpreadAttr(attr2) {\n  return attr2.type === \"MarkoSpreadAttribute\";\n}\nfunction isEventHandler(propName) {\n  return /^on[A-Z-]/.test(propName);\n}\nfunction getEventHandlerName(propName) {\n  return propName.charAt(2) === \"-\" ? propName.slice(3) : propName.charAt(2).toLowerCase() + propName.slice(3);\n}\n\n// src/core/for.ts\nvar kForMarkerBinding = Symbol(\"for marker binding\");\nvar kForScopeStartIndex = Symbol(\"for scope start index\");\nvar for_default = {\n  analyze(tag) {\n    validateFor(tag);\n    const isOnlyChild = checkOnlyChild(tag);\n    const tagExtra = tag.node.extra ??= {};\n    const tagBody = tag.get(\"body\");\n    const section = getOrCreateSection(tag);\n    const bodySection = startSection(tagBody);\n    if (isOnlyChild) {\n      const parentTag = tag.parentPath.parent;\n      const parentTagName = parentTag.name?.value;\n      (parentTag.extra ??= {})[kNativeTagBinding] ??= createBinding(\n        \"#\" + parentTagName,\n        0 /* dom */,\n        section\n      );\n    } else {\n      tagExtra[kForMarkerBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section\n      );\n    }\n    trackParamsReferences(tagBody, 3 /* param */, void 0, tagExtra);\n    analyzeAttributeTags(tag);\n    mergeReferences(\n      tag,\n      tag.node.attributes.map((attr2) => attr2.value)\n    );\n    bodySection.upstreamExpression = tagExtra;\n  },\n  translate: {\n    enter(tag) {\n      const tagBody = tag.get(\"body\");\n      const bodySection = getSection(tagBody);\n      const tagExtra = tag.node.extra;\n      const { isOnlyChild } = tagExtra;\n      const isStateful = isStatefulReferences(tagExtra.referencedBindings);\n      const hasNestedAttributeTags = tagExtra.nestedAttributeTags && Object.keys(tagExtra.nestedAttributeTags).length > 0;\n      setSectionParentIsOwner(bodySection, true);\n      if (!isOnlyChild) {\n        visit(tag, 37 /* Replace */);\n        enterShallow(tag);\n      }\n      if (isOutputHTML()) {\n        flushBefore(tag);\n        if (isStateful && !bodySection.content?.singleChild && !hasNestedAttributeTags) {\n          tagExtra[kForScopeStartIndex] = tag.scope.generateUidIdentifier(\"k\");\n          writeTo(tagBody)`${callRuntime(\n            \"markResumeScopeStart\",\n            getScopeIdIdentifier(bodySection),\n            import_compiler29.types.updateExpression(\"++\", tagExtra[kForScopeStartIndex])\n          )}`;\n        }\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML.exit(tag);\n      } else {\n        translateDOM.exit(tag);\n      }\n    }\n  },\n  attributes: {\n    of: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over a list of items.\"\n        }\n      ]\n    },\n    in: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over the keys and values of an object.\"\n        }\n      ]\n    },\n    to: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates up to the provided number (inclusive)\"\n        }\n      ]\n    },\n    from: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates starting from the provided number (inclusive)\"\n        }\n      ]\n    },\n    step: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"The amount to increment during each interation (with from/to)\"\n        }\n      ]\n    }\n  },\n  autocomplete: [\n    {\n      snippet: \"for|${1:value, index}| of=${3:array}\",\n      description: \"Use to iterate over lists, object properties, or between ranges.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-a-list\"\n    },\n    {\n      snippet: \"for|${1:name, value}| in=${3:object}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties\"\n    },\n    {\n      snippet: \"for|${1:index}| from=${2:number} to=${3:number} step=${4:number}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers\"\n    }\n  ]\n};\nvar translateDOM = {\n  exit(tag) {\n    const tagBody = tag.get(\"body\");\n    const tagSection = getSection(tag);\n    const bodySection = getSection(tagBody);\n    const { node } = tag;\n    const { attributes } = node;\n    const { isOnlyChild, referencedBindings } = node.extra;\n    const nodeRef2 = isOnlyChild ? tag.parentPath.parent.extra[kNativeTagBinding] : tag.node.extra[kForMarkerBinding];\n    setSubscriberBuilder(tag, (signal2) => {\n      return callRuntime(\n        \"inLoopScope\",\n        signal2,\n        getScopeAccessorLiteral(nodeRef2)\n      );\n    });\n    tag.remove();\n    const rendererId = import_compiler29.types.identifier(bodySection.name);\n    const ofAttr = findName(attributes, \"of\");\n    const toAttr = findName(attributes, \"to\");\n    const inAttr = findName(attributes, \"in\");\n    const loopArgs = [];\n    let loopKind;\n    if (ofAttr) {\n      loopKind = \"loopOf\";\n      loopArgs.push(ofAttr.value);\n    } else if (inAttr) {\n      loopKind = \"loopIn\";\n      loopArgs.push(inAttr.value);\n    } else if (toAttr) {\n      const fromAttr = findName(attributes, \"from\");\n      const stepAttr = findName(attributes, \"step\");\n      loopKind = \"loopTo\";\n      loopArgs.push(\n        toAttr.value,\n        fromAttr ? fromAttr.value : import_compiler29.types.numericLiteral(0),\n        stepAttr ? stepAttr.value : import_compiler29.types.numericLiteral(1)\n      );\n    }\n    const byAttr = findName(attributes, \"by\");\n    if (byAttr) {\n      loopArgs.push(byAttr.value);\n    }\n    const signal = getSignal(tagSection, nodeRef2, \"for\");\n    signal.build = () => {\n      return callRuntime(\n        loopKind,\n        getScopeAccessorLiteral(nodeRef2),\n        rendererId\n      );\n    };\n    const paramIdentifiers = Object.values(\n      tagBody.getBindingIdentifiers()\n    );\n    signal.hasDownstreamIntersections = () => {\n      if (getClosures(bodySection).length > 0) {\n        return true;\n      }\n      if (paramIdentifiers.length) {\n        const binding = paramIdentifiers[0].extra.binding;\n        for (const { referencedBindings: referencedBindings2 } of binding.downstreamExpressions) {\n          if (getSignal(\n            bodySection,\n            referencedBindings2\n          ).hasDownstreamIntersections()) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    addValue(\n      tagSection,\n      referencedBindings,\n      signal,\n      import_compiler29.types.arrayExpression(loopArgs)\n    );\n  }\n};\nvar translateHTML = {\n  exit(tag) {\n    const tagBody = tag.get(\"body\");\n    const tagSection = getSection(tag);\n    const bodySection = getSection(tagBody);\n    const { node } = tag;\n    const {\n      attributes,\n      body: { body, params }\n    } = node;\n    const tagExtra = node.extra;\n    const { isOnlyChild } = tagExtra;\n    const isStateful = isStatefulReferences(tagExtra.referencedBindings);\n    const hasNestedAttributeTags = tagExtra.nestedAttributeTags && Object.keys(tagExtra.nestedAttributeTags).length > 0;\n    const nodeRef2 = isOnlyChild ? tag.parentPath.parent.extra[kNativeTagBinding] : tag.node.extra[kForMarkerBinding];\n    const ofAttr = findName(attributes, \"of\");\n    const inAttr = findName(attributes, \"in\");\n    const toAttr = findName(attributes, \"to\");\n    const byAttr = findName(attributes, \"by\");\n    const block = import_compiler29.types.blockStatement(body);\n    const write2 = writeTo(tag);\n    const replacement = [];\n    const hasStatefulClosures = checkStatefulClosures(bodySection, true);\n    let byParams;\n    let keyExpression = import_compiler29.types.identifier(\"NOO\");\n    if (isStateful && isOnlyChild) {\n      tag.parentPath.parent.extra[kSerializeMarker] = true;\n    }\n    if (isStateful || hasStatefulClosures) {\n      setForceResumeScope(bodySection);\n    }\n    if (byAttr && isStateful) {\n      const byIdentifier = currentProgramPath.scope.generateUidIdentifier(\"by\");\n      replacement.push(\n        import_compiler29.types.variableDeclaration(\"const\", [\n          import_compiler29.types.variableDeclarator(byIdentifier, byAttr.value)\n        ])\n      );\n      byParams = [];\n      keyExpression = import_compiler29.types.callExpression(byIdentifier, byParams);\n    }\n    if (inAttr) {\n      const [keyParam, valParam] = params;\n      keyExpression = keyParam;\n      if (valParam) {\n        block.body.unshift(\n          import_compiler29.types.variableDeclaration(\"const\", [\n            import_compiler29.types.variableDeclarator(\n              valParam,\n              import_compiler29.types.memberExpression(inAttr.value, keyParam, true)\n            )\n          ])\n        );\n      }\n      replacement.push(\n        import_compiler29.types.forInStatement(\n          import_compiler29.types.variableDeclaration(\"const\", [import_compiler29.types.variableDeclarator(keyParam)]),\n          inAttr.value,\n          block\n        )\n      );\n    } else if (ofAttr) {\n      let ofAttrValue = ofAttr.value;\n      let [valParam, indexParam, loopParam] = params;\n      if (!import_compiler29.types.isIdentifier(valParam) && byParams) {\n        const tempValParam = currentProgramPath.scope.generateUidIdentifier(\"v\");\n        block.body.unshift(\n          import_compiler29.types.variableDeclaration(\"const\", [\n            import_compiler29.types.variableDeclarator(valParam, tempValParam)\n          ])\n        );\n        valParam = tempValParam;\n      }\n      if (indexParam || isStateful || hasStatefulClosures) {\n        indexParam ??= currentProgramPath.scope.generateUidIdentifier(\"i\");\n        const indexName = tag.scope.generateUidIdentifierBasedOnNode(\n          indexParam,\n          \"i\"\n        );\n        replacement.push(\n          import_compiler29.types.variableDeclaration(\"let\", [\n            import_compiler29.types.variableDeclarator(indexName, import_compiler29.types.numericLiteral(0))\n          ])\n        );\n        block.body.unshift(\n          import_compiler29.types.variableDeclaration(\"let\", [\n            import_compiler29.types.variableDeclarator(\n              indexParam,\n              import_compiler29.types.updateExpression(\"++\", indexName)\n            )\n          ])\n        );\n      }\n      if (loopParam) {\n        if (import_compiler29.types.isIdentifier(loopParam)) {\n          ofAttrValue = loopParam;\n        }\n        replacement.push(\n          import_compiler29.types.variableDeclaration(\"const\", [\n            import_compiler29.types.variableDeclarator(loopParam, ofAttr.value)\n          ])\n        );\n      }\n      if (byParams) {\n        byParams.push(valParam, indexParam);\n      } else {\n        keyExpression = indexParam;\n      }\n      replacement.push(\n        import_compiler29.types.forOfStatement(\n          import_compiler29.types.variableDeclaration(\"const\", [import_compiler29.types.variableDeclarator(valParam)]),\n          ofAttrValue,\n          block\n        )\n      );\n    } else if (toAttr) {\n      const stepValue = findName(attributes, \"step\")?.value ?? import_compiler29.types.numericLiteral(1);\n      const fromValue = findName(attributes, \"from\")?.value ?? import_compiler29.types.numericLiteral(0);\n      let [indexParam] = params;\n      const stepsName = tag.scope.generateUidIdentifier(\"steps\");\n      const indexName = tag.scope.generateUidIdentifier(\"i\");\n      const stepName = tag.scope.generateUidIdentifier(\"step\");\n      const fromName = tag.scope.generateUidIdentifier(\"from\");\n      if (indexParam || isStateful || hasStatefulClosures) {\n        indexParam ??= currentProgramPath.scope.generateUidIdentifier(\"i\");\n        keyExpression = indexParam;\n        block.body.unshift(\n          import_compiler29.types.variableDeclaration(\"const\", [\n            import_compiler29.types.variableDeclarator(\n              indexParam,\n              import_compiler29.types.binaryExpression(\n                \"+\",\n                fromName,\n                import_compiler29.types.binaryExpression(\"*\", indexName, stepName)\n              )\n            )\n          ])\n        );\n      }\n      replacement.push(\n        import_compiler29.types.forStatement(\n          import_compiler29.types.variableDeclaration(\"let\", [\n            import_compiler29.types.variableDeclarator(\n              fromName,\n              import_compiler29.types.logicalExpression(\"??\", fromValue, import_compiler29.types.numericLiteral(0))\n            ),\n            import_compiler29.types.variableDeclarator(\n              stepName,\n              import_compiler29.types.logicalExpression(\"??\", stepValue, import_compiler29.types.numericLiteral(1))\n            ),\n            import_compiler29.types.variableDeclarator(\n              stepsName,\n              import_compiler29.types.binaryExpression(\n                \"/\",\n                import_compiler29.types.binaryExpression(\"-\", toAttr.value, fromName),\n                stepName\n              )\n            ),\n            import_compiler29.types.variableDeclarator(indexName, import_compiler29.types.numericLiteral(0))\n          ]),\n          import_compiler29.types.binaryExpression(\"<=\", indexName, stepsName),\n          import_compiler29.types.updateExpression(\"++\", indexName),\n          block\n        )\n      );\n    }\n    if (tagExtra[kForScopeStartIndex]) {\n      replacement.unshift(\n        import_compiler29.types.variableDeclaration(\"let\", [\n          import_compiler29.types.variableDeclarator(\n            tagExtra[kForScopeStartIndex],\n            import_compiler29.types.numericLiteral(0)\n          )\n        ])\n      );\n    }\n    if ((isStateful || hasStatefulClosures) && !hasNestedAttributeTags) {\n      const singleNodeOptimization = bodySection.content === null || bodySection.content.singleChild;\n      const forScopeIdsIdentifier = tag.scope.generateUidIdentifier(\"forScopeIds\");\n      const forScopesIdentifier = getScopeIdentifier(bodySection);\n      replacement.unshift(\n        import_compiler29.types.variableDeclaration(\n          \"const\",\n          [\n            isStateful && singleNodeOptimization && import_compiler29.types.variableDeclarator(\n              forScopeIdsIdentifier,\n              import_compiler29.types.arrayExpression([])\n            ),\n            import_compiler29.types.variableDeclarator(\n              forScopesIdentifier,\n              import_compiler29.types.newExpression(import_compiler29.types.identifier(\"Map\"), [])\n            )\n          ].filter(Boolean)\n        )\n      );\n      if (isStateful) {\n        if (singleNodeOptimization) {\n          block.body.push(\n            import_compiler29.types.expressionStatement(\n              import_compiler29.types.callExpression(\n                import_compiler29.types.memberExpression(forScopeIdsIdentifier, import_compiler29.types.identifier(\"push\")),\n                [getScopeIdIdentifier(bodySection)]\n              )\n            )\n          );\n          write2`${callRuntime(\n            \"markResumeControlSingleNodeEnd\",\n            getScopeIdIdentifier(tagSection),\n            getScopeAccessorLiteral(nodeRef2),\n            forScopeIdsIdentifier\n          )}`;\n        } else {\n          write2`${callRuntime(\n            \"markResumeControlEnd\",\n            getScopeIdIdentifier(tagSection),\n            getScopeAccessorLiteral(nodeRef2)\n          )}`;\n        }\n      }\n      getSerializedScopeProperties(tagSection).set(\n        import_compiler29.types.stringLiteral(\n          getScopeAccessorLiteral(nodeRef2).value + \"(\" /* LoopScopeMap */\n        ),\n        import_compiler29.types.conditionalExpression(\n          import_compiler29.types.memberExpression(forScopesIdentifier, import_compiler29.types.identifier(\"size\")),\n          forScopesIdentifier,\n          import_compiler29.types.identifier(\"undefined\")\n        )\n      );\n    }\n    flushInto(tag);\n    setSubscriberBuilder(tag, () => {\n    });\n    writeHTMLResumeStatements(tagBody);\n    if (isStateful || hasStatefulClosures) {\n      tag.node.body.body.push(\n        import_compiler29.types.expressionStatement(\n          import_compiler29.types.callExpression(\n            import_compiler29.types.memberExpression(\n              getScopeIdentifier(bodySection),\n              import_compiler29.types.identifier(\"set\")\n            ),\n            [\n              keyExpression,\n              callRuntime(\"getScopeById\", getScopeIdIdentifier(bodySection))\n            ]\n          )\n        )\n      );\n    }\n    tag.replaceWithMultiple(replacement);\n  }\n};\nfunction findName(arr, value) {\n  return arr.find((obj) => import_compiler29.types.isMarkoAttribute(obj) && obj.name === value);\n}\nfunction validateFor(tag) {\n  const attrs2 = tag.node.attributes;\n  const hasParams = tag.node.body.params.length > 0;\n  (0, import_babel_utils24.assertNoVar)(tag);\n  if (findName(attrs2, \"of\")) {\n    (0, import_babel_utils24.assertAllowedAttributes)(tag, [\"of\", \"by\"]);\n    if (!hasParams) {\n      throw tag.buildCodeFrameError(\n        \"Invalid `for of` tag, missing `|value, index|` params.\"\n      );\n    }\n  } else if (findName(attrs2, \"in\")) {\n    (0, import_babel_utils24.assertAllowedAttributes)(tag, [\"in\", \"by\"]);\n    if (!hasParams) {\n      throw tag.buildCodeFrameError(\n        \"Invalid `for in` tag, missing `|key, value|` params.\"\n      );\n    }\n  } else if (findName(attrs2, \"to\")) {\n    (0, import_babel_utils24.assertAllowedAttributes)(tag, [\"from\", \"to\", \"step\", \"by\"]);\n  } else {\n    throw tag.buildCodeFrameError(\n      \"Invalid `for` tag, missing an `of=`, `in=` or `to=` attribute.\"\n    );\n  }\n}\nfunction checkOnlyChild(tag) {\n  const extra = tag.node.extra;\n  if (import_compiler29.types.isMarkoTag(tag.parentPath?.parent) && (0, import_babel_utils24.getTagDef)(tag.parentPath.parentPath)?.html) {\n    return extra.isOnlyChild = tag.parent.body.length === 1;\n  }\n  return extra.isOnlyChild = false;\n}\n\n// src/core/html-comment.ts\nvar import_babel_utils25 = require(\"@marko/babel-utils\");\nvar import_compiler30 = require(\"@marko/compiler\");\nvar kCommentTagBinding = Symbol(\"comment tag binding\");\nvar kGetterId2 = Symbol(\"node getter id\");\nvar html_comment_default = {\n  analyze(tag) {\n    (0, import_babel_utils25.assertNoArgs)(tag);\n    (0, import_babel_utils25.assertNoParams)(tag);\n    (0, import_babel_utils25.assertNoAttributes)(tag);\n    const tagVar = tag.node.var;\n    let needsBinding = false;\n    let needsGetter = false;\n    if (tagVar) {\n      if (!import_compiler30.types.isIdentifier(tagVar)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"The `html-comment` tag variable cannot be destructured.\"\n        );\n      }\n      needsBinding = true;\n      for (const ref of tag.scope.getBinding(tagVar.name).referencePaths) {\n        if (!ref.parentPath?.isCallExpression()) {\n          needsGetter = true;\n          break;\n        }\n      }\n    }\n    const referenceNodes = [];\n    for (const child of tag.get(\"body\").get(\"body\")) {\n      if (child.isMarkoPlaceholder()) {\n        referenceNodes.push(child.node.value);\n        needsBinding = true;\n      } else if (!child.isMarkoText()) {\n        throw child.buildCodeFrameError(\n          \"Invalid child. Only text is allowed inside an html comment.\"\n        );\n      }\n    }\n    if (needsBinding) {\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      if (needsGetter) {\n        tagExtra[kGetterId2] = getRegisterUID(section, \"comment\");\n      }\n      tagExtra[kCommentTagBinding] = createBinding(\n        \"#comment\",\n        0 /* dom */,\n        section\n      );\n      mergeReferences(tag, referenceNodes);\n    }\n    tag.skip();\n  },\n  translate(tag) {\n    const tagExtra = tag.node.extra;\n    const commentBinding = tagExtra[kCommentTagBinding];\n    const hasVar = !!tag.node.var;\n    if (hasVar) {\n      const getterId = tagExtra[kGetterId2];\n      if (isOutputHTML()) {\n        translateVar(\n          tag,\n          callRuntime(\n            \"nodeRef\",\n            getterId && getScopeIdIdentifier(getSection(tag)),\n            getterId && import_compiler30.types.stringLiteral(getterId)\n          )\n        );\n      } else {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        let getterFnIdentifier;\n        if (getterId) {\n          getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n            `get_${varName}`\n          );\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler30.types.variableDeclaration(\"const\", [\n              import_compiler30.types.variableDeclarator(\n                getterFnIdentifier,\n                callRuntime(\n                  \"nodeRef\",\n                  import_compiler30.types.stringLiteral(getterId),\n                  getScopeAccessorLiteral(commentBinding)\n                )\n              )\n            ])\n          );\n        }\n        for (const reference of references) {\n          const referenceSection = getSection(reference);\n          if (reference.parentPath?.isCallExpression()) {\n            reference.parentPath.replaceWith(\n              import_compiler30.types.expressionStatement(\n                createScopeReadExpression(referenceSection, commentBinding)\n              )\n            );\n          } else if (getterFnIdentifier) {\n            reference.replaceWith(\n              import_compiler30.types.callExpression(getterFnIdentifier, [\n                getScopeExpression(referenceSection, getSection(tag))\n              ])\n            );\n          }\n        }\n      }\n    }\n    if (tagExtra[kCommentTagBinding]) {\n      visit(tag, 32 /* Get */);\n    }\n    const write2 = writeTo(tag);\n    enter(tag);\n    write2`<!--`;\n    if (isOutputHTML()) {\n      for (const child of tag.node.body.body) {\n        if (import_compiler30.types.isMarkoText(child)) {\n          write2`${child.value}`;\n        } else if (import_compiler30.types.isMarkoPlaceholder(child)) {\n          write2`${callRuntime(\"escapeXML\", child.value)}`;\n        }\n      }\n    } else {\n      const templateQuasis = [];\n      const templateExpressions = [];\n      let currentQuasi = \"\";\n      for (const child of tag.node.body.body) {\n        if (import_compiler30.types.isMarkoText(child)) {\n          currentQuasi += child.value;\n        } else if (import_compiler30.types.isMarkoPlaceholder(child)) {\n          templateQuasis.push(import_compiler30.types.templateElement({ raw: currentQuasi }));\n          templateExpressions.push(child.value);\n          currentQuasi = \"\";\n        }\n      }\n      if (templateExpressions.length === 0) {\n        write2`${currentQuasi}`;\n      } else {\n        templateQuasis.push(import_compiler30.types.templateElement({ raw: currentQuasi }));\n        addStatement(\n          \"render\",\n          getSection(tag),\n          tagExtra.referencedBindings,\n          import_compiler30.types.expressionStatement(\n            callRuntime(\n              \"data\",\n              import_compiler30.types.memberExpression(\n                scopeIdentifier,\n                getScopeAccessorLiteral(commentBinding),\n                true\n              ),\n              import_compiler30.types.templateLiteral(templateQuasis, templateExpressions)\n            )\n          )\n        );\n      }\n    }\n    exit(tag);\n    write2`-->`;\n    if (commentBinding) {\n      markNode(tag, commentBinding);\n    }\n    tag.remove();\n  },\n  parseOptions: {\n    // TODO: fix the types for Tag or parseOptions or something\n    text: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an html comment that is not stripped from the output.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#html-comment\"\n    }\n  ]\n};\n\n// src/core/id.ts\nvar import_babel_utils26 = require(\"@marko/babel-utils\");\nvar import_compiler31 = require(\"@marko/compiler\");\nvar id_default = {\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const { var: tagVar } = node;\n      const id = isOutputHTML() ? callRuntime(\"nextTagId\") : callRuntime(\"nextTagId\", scopeIdentifier);\n      (0, import_babel_utils26.assertNoArgs)(tag);\n      (0, import_babel_utils26.assertNoAttributes)(tag);\n      assertNoBodyContent(tag);\n      (0, import_babel_utils26.assertNoParams)(tag);\n      if (!node.var) {\n        throw tag.get(\"name\").buildCodeFrameError(\"The `id` tag requires a tag variable.\");\n      }\n      if (!import_compiler31.types.isIdentifier(tagVar)) {\n        throw tag.get(\"var\").buildCodeFrameError(\"The `id` tag cannot be destructured\");\n      }\n      if (isOutputHTML()) {\n        tag.replaceWith(\n          import_compiler31.types.variableDeclaration(\"const\", [import_compiler31.types.variableDeclarator(node.var, id)])\n        );\n      } else {\n        const source = initValue(tagVar.extra.binding);\n        addValue(getSection(tag), void 0, source, id);\n        tag.remove();\n      }\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"id/<name>\",\n      description: \"Use to create a unique identifier.\",\n      snippet: \"id/${1:name}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#id\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/id.d.marko\"\n};\n\n// src/core/import.ts\nvar import_babel_utils27 = require(\"@marko/babel-utils\");\nvar import_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils27.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: 'import <scope> from \"<path>\"',\n      description: \"Use to import external modules, follows the same syntax as JavaScript imports.\",\n      snippet: 'import ${2} from \"${1:path}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#importing-external-files\"\n    }\n  ]\n};\n\n// src/core/let.ts\nvar import_babel_utils28 = require(\"@marko/babel-utils\");\nvar import_compiler32 = require(\"@marko/compiler\");\nvar let_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    const { optimize } = getMarkoOpts();\n    let valueAttr;\n    let valueChangeAttr;\n    for (const attr2 of node.attributes) {\n      if (import_compiler32.types.isMarkoAttribute(attr2)) {\n        if (attr2.name === \"value\") {\n          valueAttr = attr2;\n        } else if (attr2.name === \"valueChange\") {\n          valueChangeAttr = attr2;\n        } else {\n          const start = attr2.loc?.start;\n          const end = attr2.loc?.end;\n          const msg = \"The `let` tag only supports the `value` attribute and its change handler.\";\n          if (start == null || end == null) {\n            throw tag.get(\"name\").buildCodeFrameError(msg);\n          } else {\n            throw tag.hub.buildError(\n              { loc: { start, end } },\n              msg,\n              Error\n            );\n          }\n        }\n      }\n    }\n    (0, import_babel_utils28.assertNoArgs)(tag);\n    (0, import_babel_utils28.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    if (!tagVar) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `let` tag requires a tag variable.\");\n    }\n    if (!import_compiler32.types.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `let` tag variable cannot be destructured.\");\n    }\n    if (valueChangeAttr && (0, import_babel_utils28.computeNode)(valueChangeAttr.value)) {\n      throw tag.get(\"attributes\").find((attr2) => attr2.node === valueChangeAttr).get(\"value\").buildCodeFrameError(\n        \"The `let` tag `valueChange` attribute must be a function.\"\n      );\n    }\n    if (valueChangeAttr) {\n      const valueChangeReferences = (valueChangeAttr.value.extra ??= {})?.referencedBindings;\n      valueChangeAttr.value.extra.static = import_compiler32.types.isFunction(valueChangeAttr.value);\n      if (optimize && import_compiler32.types.isIdentifier(valueChangeAttr.value) && size(valueChangeReferences) === 1) {\n        valueChangeAttr.value.extra.binding = valueChangeReferences;\n      } else {\n        valueChangeAttr.value.extra.binding = createBinding(\n          tag.scope.generateUid(tagVar.name + \"_change\"),\n          1 /* let */,\n          getSection(tag),\n          void 0,\n          valueChangeAttr.value.extra\n        );\n      }\n    }\n    const upstreamExpressionExtra = valueAttr ? valueAttr.value.extra ??= {} : void 0;\n    trackVarReferences(\n      tag,\n      1 /* let */,\n      void 0,\n      upstreamExpressionExtra,\n      valueChangeAttr?.value.extra?.binding\n    );\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const tagVar = node.var;\n      const { optimize } = getMarkoOpts();\n      const valueAttr = node.attributes.find(\n        (attr2) => import_compiler32.types.isMarkoAttribute(attr2) && (attr2.default || attr2.name === \"value\")\n      ) ?? import_compiler32.types.markoAttribute(\"value\", import_compiler32.types.identifier(\"undefined\"));\n      const valueChangeAttr = node.attributes.find(\n        (attr2) => import_compiler32.types.isMarkoAttribute(attr2) && attr2.name === \"valueChange\"\n      );\n      const valueChangeBinding = valueChangeAttr?.value.extra?.binding;\n      if (isOutputDOM()) {\n        const section = getSection(tag);\n        const binding = tagVar.extra.binding;\n        const signal = initValue(binding);\n        const referencedBindings = valueAttr.value.extra?.referencedBindings;\n        const isSetup = !referencedBindings;\n        if (valueChangeBinding && (!optimize || !import_compiler32.types.isIdentifier(valueChangeAttr.value))) {\n          const valueChangeSource = initValue(valueChangeBinding);\n          if (!optimize && !import_compiler32.types.isFunction(valueChangeAttr.value)) {\n            const build = valueChangeSource.build;\n            valueChangeSource.build = () => {\n              const fn = build();\n              return callRuntime(\n                \"changeHandler\",\n                getScopeAccessorLiteral(valueChangeBinding),\n                fn\n              );\n            };\n          }\n          addValue(\n            section,\n            valueChangeAttr.value.extra?.referencedBindings,\n            valueChangeSource,\n            valueChangeAttr.value\n          );\n        }\n        addValue(section, referencedBindings, signal, valueAttr.value);\n        if (!isSetup && !valueChangeAttr?.value.extra?.static) {\n          let calleeExpression;\n          Object.defineProperty(signal, \"callee\", {\n            get() {\n              if (!calleeExpression) {\n                const initValueId = tag.scope.generateUidIdentifier(\n                  signal.identifier.name + \"_init\"\n                );\n                calleeExpression = valueChangeBinding ? import_compiler32.types.conditionalExpression(\n                  createScopeReadExpression(section, valueChangeBinding),\n                  signal.identifier,\n                  initValueId\n                ) : initValueId;\n                currentProgramPath.pushContainer(\n                  \"body\",\n                  import_compiler32.types.variableDeclaration(\"const\", [\n                    import_compiler32.types.variableDeclarator(\n                      initValueId,\n                      callRuntime(\n                        \"initValue\",\n                        getScopeAccessorLiteral(binding),\n                        signal.identifier\n                      )\n                    )\n                  ])\n                );\n              }\n              return calleeExpression;\n            }\n          });\n        }\n        signal.buildAssignment = (valueSection, value) => {\n          return queueSource(signal, value, valueSection, valueChangeBinding);\n        };\n      } else {\n        translateVar(tag, valueAttr.value);\n        if (valueChangeBinding) {\n          tag.insertBefore(\n            import_compiler32.types.variableDeclaration(\"const\", [\n              import_compiler32.types.variableDeclarator(\n                import_compiler32.types.identifier(valueChangeBinding.name),\n                valueChangeAttr.value\n              )\n            ])\n          );\n        }\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a mutable binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#let\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/let.d.marko\"\n};\n\n// src/core/lifecycle.ts\nvar import_babel_utils29 = require(\"@marko/babel-utils\");\nvar import_compiler33 = require(\"@marko/compiler\");\nvar kRef = Symbol(\"lifecycle attrs reference\");\nvar supportedAttrNames = /* @__PURE__ */ new Set([\"onMount\", \"onUpdate\", \"onDestroy\"]);\nvar lifecycle_default = {\n  analyze(tag) {\n    (0, import_babel_utils29.assertNoArgs)(tag);\n    (0, import_babel_utils29.assertNoVar)(tag);\n    (0, import_babel_utils29.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const tagExtra = node.extra ??= {};\n    tagExtra[kRef] = createBinding(\n      tag.scope.generateUid(\"lifecycle\"),\n      4 /* derived */,\n      getOrCreateSection(tag),\n      void 0,\n      tagExtra\n    );\n    if (node.attributes.length === 0) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `lifecycle` tag requires at least one attribute.\"\n      );\n    }\n    for (const attr2 of node.attributes) {\n      if (import_compiler33.types.isMarkoSpreadAttribute(attr2)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The `lifecycle` tag does not support `...spread` attributes.\"\n        );\n      } else if (!supportedAttrNames.has(attr2.name)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          `The \\`lifecycle\\` tag does not support the \\`${attr2.name}\\` attribute.`\n        );\n      }\n      (attr2.value.extra ??= {}).isEffect = true;\n    }\n    (currentProgramPath.node.extra ??= {}).isInteractive = true;\n    mergeReferences(\n      tag,\n      tag.node.attributes.map((attr2) => attr2.value)\n    );\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const section = getSection(tag);\n      const tagExtra = node.extra;\n      const { referencedBindings } = tagExtra;\n      const lifecycleAttrsRef = tagExtra[kRef];\n      if (isOutputDOM()) {\n        const attrsObject = attrsToObject(tag);\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          import_compiler33.types.expressionStatement(\n            callRuntime(\n              \"lifecycle\",\n              scopeIdentifier,\n              getScopeAccessorLiteral(lifecycleAttrsRef),\n              attrsObject\n            )\n          ),\n          node.attributes.map((a) => a.value)\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/lifecycle.d.marko\"\n};\n\n// src/core/log.ts\nvar import_babel_utils30 = require(\"@marko/babel-utils\");\nvar import_compiler34 = require(\"@marko/compiler\");\nvar log_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils30.assertNoArgs)(tag);\n    (0, import_babel_utils30.assertNoVar)(tag);\n    (0, import_babel_utils30.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `log` tag requires a value.\");\n    }\n    if (tag.node.attributes.length > 1 || !import_compiler34.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `log` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      const statement = import_compiler34.types.expressionStatement(\n        import_compiler34.types.callExpression(\n          import_compiler34.types.memberExpression(import_compiler34.types.identifier(\"console\"), import_compiler34.types.identifier(\"log\")),\n          [value]\n        )\n      );\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to log a value to the console.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#log\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/log.d.marko\"\n};\n\n// src/core/noop.ts\nvar noop_default = {\n  migrate: [(tag) => tag.remove()]\n};\n\n// src/core/server.ts\nvar import_babel_utils31 = require(\"@marko/babel-utils\");\nvar import_compiler35 = require(\"@marko/compiler\");\nvar server_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^server\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils31.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler35.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler35.types.markoScriptlet(body, true, \"server\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"server <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the server.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#server-javascript\"\n    }\n  ]\n};\n\n// src/core/static.ts\nvar import_babel_utils32 = require(\"@marko/babel-utils\");\nvar import_compiler36 = require(\"@marko/compiler\");\nvar static_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^static\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils32.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler36.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler36.types.markoScriptlet(body, true));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"static <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#static-javascript\"\n    }\n  ]\n};\n\n// src/core/style.ts\nvar import_babel_utils33 = require(\"@marko/babel-utils\");\nvar import_compiler37 = require(\"@marko/compiler\");\n\n// ../../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs\nvar comma = \",\".charCodeAt(0);\nvar semicolon = \";\".charCodeAt(0);\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar intToChar = new Uint8Array(64);\nvar charToInt = new Uint8Array(128);\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\nfunction encodeInteger(builder, num, relative) {\n  let delta = num - relative;\n  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;\n  do {\n    let clamped = delta & 31;\n    delta >>>= 5;\n    if (delta > 0)\n      clamped |= 32;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n  return num;\n}\nvar bufLength = 1024 * 16;\nvar td = typeof TextDecoder !== \"undefined\" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== \"undefined\" ? {\n  decode(buf) {\n    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n    return out.toString();\n  }\n} : {\n  decode(buf) {\n    let out = \"\";\n    for (let i = 0; i < buf.length; i++) {\n      out += String.fromCharCode(buf[i]);\n    }\n    return out;\n  }\n};\nvar StringWriter = class {\n  constructor() {\n    this.pos = 0;\n    this.out = \"\";\n    this.buffer = new Uint8Array(bufLength);\n  }\n  write(v) {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n  flush() {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n};\nfunction encode(decoded) {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0)\n      writer.write(semicolon);\n    if (line.length === 0)\n      continue;\n    let genColumn = 0;\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0)\n        writer.write(comma);\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n      if (segment.length === 1)\n        continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n      if (segment.length === 4)\n        continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n  return writer.flush();\n}\n\n// ../../node_modules/magic-string/dist/magic-string.es.mjs\nvar BitSet = class _BitSet {\n  constructor(arg) {\n    this.bits = arg instanceof _BitSet ? arg.bits.slice() : [];\n  }\n  add(n2) {\n    this.bits[n2 >> 5] |= 1 << (n2 & 31);\n  }\n  has(n2) {\n    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));\n  }\n};\nvar Chunk2 = class _Chunk {\n  constructor(start, end, content) {\n    this.start = start;\n    this.end = end;\n    this.original = content;\n    this.intro = \"\";\n    this.outro = \"\";\n    this.content = content;\n    this.storeName = false;\n    this.edited = false;\n    {\n      this.previous = null;\n      this.next = null;\n    }\n  }\n  appendLeft(content) {\n    this.outro += content;\n  }\n  appendRight(content) {\n    this.intro = this.intro + content;\n  }\n  clone() {\n    const chunk = new _Chunk(this.start, this.end, this.original);\n    chunk.intro = this.intro;\n    chunk.outro = this.outro;\n    chunk.content = this.content;\n    chunk.storeName = this.storeName;\n    chunk.edited = this.edited;\n    return chunk;\n  }\n  contains(index) {\n    return this.start < index && index < this.end;\n  }\n  eachNext(fn) {\n    let chunk = this;\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.next;\n    }\n  }\n  eachPrevious(fn) {\n    let chunk = this;\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.previous;\n    }\n  }\n  edit(content, storeName, contentOnly) {\n    this.content = content;\n    if (!contentOnly) {\n      this.intro = \"\";\n      this.outro = \"\";\n    }\n    this.storeName = storeName;\n    this.edited = true;\n    return this;\n  }\n  prependLeft(content) {\n    this.outro = content + this.outro;\n  }\n  prependRight(content) {\n    this.intro = content + this.intro;\n  }\n  reset() {\n    this.intro = \"\";\n    this.outro = \"\";\n    if (this.edited) {\n      this.content = this.original;\n      this.storeName = false;\n      this.edited = false;\n    }\n  }\n  split(index) {\n    const sliceIndex = index - this.start;\n    const originalBefore = this.original.slice(0, sliceIndex);\n    const originalAfter = this.original.slice(sliceIndex);\n    this.original = originalBefore;\n    const newChunk = new _Chunk(index, this.end, originalAfter);\n    newChunk.outro = this.outro;\n    this.outro = \"\";\n    this.end = index;\n    if (this.edited) {\n      newChunk.edit(\"\", false);\n      this.content = \"\";\n    } else {\n      this.content = originalBefore;\n    }\n    newChunk.next = this.next;\n    if (newChunk.next) newChunk.next.previous = newChunk;\n    newChunk.previous = this;\n    this.next = newChunk;\n    return newChunk;\n  }\n  toString() {\n    return this.intro + this.content + this.outro;\n  }\n  trimEnd(rx) {\n    this.outro = this.outro.replace(rx, \"\");\n    if (this.outro.length) return true;\n    const trimmed = this.content.replace(rx, \"\");\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        this.split(this.start + trimmed.length).edit(\"\", void 0, true);\n        if (this.edited) {\n          this.edit(trimmed, this.storeName, true);\n        }\n      }\n      return true;\n    } else {\n      this.edit(\"\", void 0, true);\n      this.intro = this.intro.replace(rx, \"\");\n      if (this.intro.length) return true;\n    }\n  }\n  trimStart(rx) {\n    this.intro = this.intro.replace(rx, \"\");\n    if (this.intro.length) return true;\n    const trimmed = this.content.replace(rx, \"\");\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        const newChunk = this.split(this.end - trimmed.length);\n        if (this.edited) {\n          newChunk.edit(trimmed, this.storeName, true);\n        }\n        this.edit(\"\", void 0, true);\n      }\n      return true;\n    } else {\n      this.edit(\"\", void 0, true);\n      this.outro = this.outro.replace(rx, \"\");\n      if (this.outro.length) return true;\n    }\n  }\n};\nfunction getBtoa() {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));\n  } else if (typeof Buffer === \"function\") {\n    return (str) => Buffer.from(str, \"utf-8\").toString(\"base64\");\n  } else {\n    return () => {\n      throw new Error(\"Unsupported environment: `window.btoa` or `Buffer` should be supported.\");\n    };\n  }\n}\nvar btoa = /* @__PURE__ */ getBtoa();\nvar SourceMap = class {\n  constructor(properties) {\n    this.version = 3;\n    this.file = properties.file;\n    this.sources = properties.sources;\n    this.sourcesContent = properties.sourcesContent;\n    this.names = properties.names;\n    this.mappings = encode(properties.mappings);\n    if (typeof properties.x_google_ignoreList !== \"undefined\") {\n      this.x_google_ignoreList = properties.x_google_ignoreList;\n    }\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  toUrl() {\n    return \"data:application/json;charset=utf-8;base64,\" + btoa(this.toString());\n  }\n};\nfunction guessIndent(code) {\n  const lines = code.split(\"\\n\");\n  const tabbed = lines.filter((line) => /^\\t+/.test(line));\n  const spaced = lines.filter((line) => /^ {2,}/.test(line));\n  if (tabbed.length === 0 && spaced.length === 0) {\n    return null;\n  }\n  if (tabbed.length >= spaced.length) {\n    return \"\t\";\n  }\n  const min = spaced.reduce((previous, current) => {\n    const numSpaces = /^ +/.exec(current)[0].length;\n    return Math.min(numSpaces, previous);\n  }, Infinity);\n  return new Array(min + 1).join(\" \");\n}\nfunction getRelativePath(from, to) {\n  const fromParts = from.split(/[/\\\\]/);\n  const toParts = to.split(/[/\\\\]/);\n  fromParts.pop();\n  while (fromParts[0] === toParts[0]) {\n    fromParts.shift();\n    toParts.shift();\n  }\n  if (fromParts.length) {\n    let i = fromParts.length;\n    while (i--) fromParts[i] = \"..\";\n  }\n  return fromParts.concat(toParts).join(\"/\");\n}\nvar toString2 = Object.prototype.toString;\nfunction isObject(thing) {\n  return toString2.call(thing) === \"[object Object]\";\n}\nfunction getLocator(source) {\n  const originalLines = source.split(\"\\n\");\n  const lineOffsets = [];\n  for (let i = 0, pos = 0; i < originalLines.length; i++) {\n    lineOffsets.push(pos);\n    pos += originalLines[i].length + 1;\n  }\n  return function locate(index) {\n    let i = 0;\n    let j = lineOffsets.length;\n    while (i < j) {\n      const m = i + j >> 1;\n      if (index < lineOffsets[m]) {\n        j = m;\n      } else {\n        i = m + 1;\n      }\n    }\n    const line = i - 1;\n    const column = index - lineOffsets[line];\n    return { line, column };\n  };\n}\nvar wordRegex = /\\w/;\nvar Mappings = class {\n  constructor(hires) {\n    this.hires = hires;\n    this.generatedCodeLine = 0;\n    this.generatedCodeColumn = 0;\n    this.raw = [];\n    this.rawSegments = this.raw[this.generatedCodeLine] = [];\n    this.pending = null;\n  }\n  addEdit(sourceIndex, content, loc, nameIndex) {\n    if (content.length) {\n      const contentLengthMinusOne = content.length - 1;\n      let contentLineEnd = content.indexOf(\"\\n\", 0);\n      let previousContentLineEnd = -1;\n      while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {\n        const segment2 = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n        if (nameIndex >= 0) {\n          segment2.push(nameIndex);\n        }\n        this.rawSegments.push(segment2);\n        this.generatedCodeLine += 1;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n        this.generatedCodeColumn = 0;\n        previousContentLineEnd = contentLineEnd;\n        contentLineEnd = content.indexOf(\"\\n\", contentLineEnd + 1);\n      }\n      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n      if (nameIndex >= 0) {\n        segment.push(nameIndex);\n      }\n      this.rawSegments.push(segment);\n      this.advance(content.slice(previousContentLineEnd + 1));\n    } else if (this.pending) {\n      this.rawSegments.push(this.pending);\n      this.advance(content);\n    }\n    this.pending = null;\n  }\n  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n    let originalCharIndex = chunk.start;\n    let first = true;\n    let charInHiresBoundary = false;\n    while (originalCharIndex < chunk.end) {\n      if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n        const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n        if (this.hires === \"boundary\") {\n          if (wordRegex.test(original[originalCharIndex])) {\n            if (!charInHiresBoundary) {\n              this.rawSegments.push(segment);\n              charInHiresBoundary = true;\n            }\n          } else {\n            this.rawSegments.push(segment);\n            charInHiresBoundary = false;\n          }\n        } else {\n          this.rawSegments.push(segment);\n        }\n      }\n      if (original[originalCharIndex] === \"\\n\") {\n        loc.line += 1;\n        loc.column = 0;\n        this.generatedCodeLine += 1;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n        this.generatedCodeColumn = 0;\n        first = true;\n      } else {\n        loc.column += 1;\n        this.generatedCodeColumn += 1;\n        first = false;\n      }\n      originalCharIndex += 1;\n    }\n    this.pending = null;\n  }\n  advance(str) {\n    if (!str) return;\n    const lines = str.split(\"\\n\");\n    if (lines.length > 1) {\n      for (let i = 0; i < lines.length - 1; i++) {\n        this.generatedCodeLine++;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n      }\n      this.generatedCodeColumn = 0;\n    }\n    this.generatedCodeColumn += lines[lines.length - 1].length;\n  }\n};\nvar n = \"\\n\";\nvar warned = {\n  insertLeft: false,\n  insertRight: false,\n  storeName: false\n};\nvar MagicString = class _MagicString {\n  constructor(string, options = {}) {\n    const chunk = new Chunk2(0, string.length, string);\n    Object.defineProperties(this, {\n      original: { writable: true, value: string },\n      outro: { writable: true, value: \"\" },\n      intro: { writable: true, value: \"\" },\n      firstChunk: { writable: true, value: chunk },\n      lastChunk: { writable: true, value: chunk },\n      lastSearchedChunk: { writable: true, value: chunk },\n      byStart: { writable: true, value: {} },\n      byEnd: { writable: true, value: {} },\n      filename: { writable: true, value: options.filename },\n      indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n      sourcemapLocations: { writable: true, value: new BitSet() },\n      storedNames: { writable: true, value: {} },\n      indentStr: { writable: true, value: void 0 },\n      ignoreList: { writable: true, value: options.ignoreList }\n    });\n    this.byStart[0] = chunk;\n    this.byEnd[string.length] = chunk;\n  }\n  addSourcemapLocation(char) {\n    this.sourcemapLocations.add(char);\n  }\n  append(content) {\n    if (typeof content !== \"string\") throw new TypeError(\"outro content must be a string\");\n    this.outro += content;\n    return this;\n  }\n  appendLeft(index, content) {\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byEnd[index];\n    if (chunk) {\n      chunk.appendLeft(content);\n    } else {\n      this.intro += content;\n    }\n    return this;\n  }\n  appendRight(index, content) {\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byStart[index];\n    if (chunk) {\n      chunk.appendRight(content);\n    } else {\n      this.outro += content;\n    }\n    return this;\n  }\n  clone() {\n    const cloned = new _MagicString(this.original, { filename: this.filename });\n    let originalChunk = this.firstChunk;\n    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();\n    while (originalChunk) {\n      cloned.byStart[clonedChunk.start] = clonedChunk;\n      cloned.byEnd[clonedChunk.end] = clonedChunk;\n      const nextOriginalChunk = originalChunk.next;\n      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n      if (nextClonedChunk) {\n        clonedChunk.next = nextClonedChunk;\n        nextClonedChunk.previous = clonedChunk;\n        clonedChunk = nextClonedChunk;\n      }\n      originalChunk = nextOriginalChunk;\n    }\n    cloned.lastChunk = clonedChunk;\n    if (this.indentExclusionRanges) {\n      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n    }\n    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n    cloned.intro = this.intro;\n    cloned.outro = this.outro;\n    return cloned;\n  }\n  generateDecodedMap(options) {\n    options = options || {};\n    const sourceIndex = 0;\n    const names = Object.keys(this.storedNames);\n    const mappings = new Mappings(options.hires);\n    const locate = getLocator(this.original);\n    if (this.intro) {\n      mappings.advance(this.intro);\n    }\n    this.firstChunk.eachNext((chunk) => {\n      const loc = locate(chunk.start);\n      if (chunk.intro.length) mappings.advance(chunk.intro);\n      if (chunk.edited) {\n        mappings.addEdit(\n          sourceIndex,\n          chunk.content,\n          loc,\n          chunk.storeName ? names.indexOf(chunk.original) : -1\n        );\n      } else {\n        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n      }\n      if (chunk.outro.length) mappings.advance(chunk.outro);\n    });\n    return {\n      file: options.file ? options.file.split(/[/\\\\]/).pop() : void 0,\n      sources: [\n        options.source ? getRelativePath(options.file || \"\", options.source) : options.file || \"\"\n      ],\n      sourcesContent: options.includeContent ? [this.original] : void 0,\n      names,\n      mappings: mappings.raw,\n      x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0\n    };\n  }\n  generateMap(options) {\n    return new SourceMap(this.generateDecodedMap(options));\n  }\n  _ensureindentStr() {\n    if (this.indentStr === void 0) {\n      this.indentStr = guessIndent(this.original);\n    }\n  }\n  _getRawIndentString() {\n    this._ensureindentStr();\n    return this.indentStr;\n  }\n  getIndentString() {\n    this._ensureindentStr();\n    return this.indentStr === null ? \"\t\" : this.indentStr;\n  }\n  indent(indentStr, options) {\n    const pattern = /^[^\\r\\n]/gm;\n    if (isObject(indentStr)) {\n      options = indentStr;\n      indentStr = void 0;\n    }\n    if (indentStr === void 0) {\n      this._ensureindentStr();\n      indentStr = this.indentStr || \"\t\";\n    }\n    if (indentStr === \"\") return this;\n    options = options || {};\n    const isExcluded = {};\n    if (options.exclude) {\n      const exclusions = typeof options.exclude[0] === \"number\" ? [options.exclude] : options.exclude;\n      exclusions.forEach((exclusion) => {\n        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n          isExcluded[i] = true;\n        }\n      });\n    }\n    let shouldIndentNextCharacter = options.indentStart !== false;\n    const replacer = (match) => {\n      if (shouldIndentNextCharacter) return `${indentStr}${match}`;\n      shouldIndentNextCharacter = true;\n      return match;\n    };\n    this.intro = this.intro.replace(pattern, replacer);\n    let charIndex = 0;\n    let chunk = this.firstChunk;\n    while (chunk) {\n      const end = chunk.end;\n      if (chunk.edited) {\n        if (!isExcluded[charIndex]) {\n          chunk.content = chunk.content.replace(pattern, replacer);\n          if (chunk.content.length) {\n            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === \"\\n\";\n          }\n        }\n      } else {\n        charIndex = chunk.start;\n        while (charIndex < end) {\n          if (!isExcluded[charIndex]) {\n            const char = this.original[charIndex];\n            if (char === \"\\n\") {\n              shouldIndentNextCharacter = true;\n            } else if (char !== \"\\r\" && shouldIndentNextCharacter) {\n              shouldIndentNextCharacter = false;\n              if (charIndex === chunk.start) {\n                chunk.prependRight(indentStr);\n              } else {\n                this._splitChunk(chunk, charIndex);\n                chunk = chunk.next;\n                chunk.prependRight(indentStr);\n              }\n            }\n          }\n          charIndex += 1;\n        }\n      }\n      charIndex = chunk.end;\n      chunk = chunk.next;\n    }\n    this.outro = this.outro.replace(pattern, replacer);\n    return this;\n  }\n  insert() {\n    throw new Error(\n      \"magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)\"\n    );\n  }\n  insertLeft(index, content) {\n    if (!warned.insertLeft) {\n      console.warn(\n        \"magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead\"\n      );\n      warned.insertLeft = true;\n    }\n    return this.appendLeft(index, content);\n  }\n  insertRight(index, content) {\n    if (!warned.insertRight) {\n      console.warn(\n        \"magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead\"\n      );\n      warned.insertRight = true;\n    }\n    return this.prependRight(index, content);\n  }\n  move(start, end, index) {\n    if (index >= start && index <= end) throw new Error(\"Cannot move a selection inside itself\");\n    this._split(start);\n    this._split(end);\n    this._split(index);\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n    const oldLeft = first.previous;\n    const oldRight = last.next;\n    const newRight = this.byStart[index];\n    if (!newRight && last === this.lastChunk) return this;\n    const newLeft = newRight ? newRight.previous : this.lastChunk;\n    if (oldLeft) oldLeft.next = oldRight;\n    if (oldRight) oldRight.previous = oldLeft;\n    if (newLeft) newLeft.next = first;\n    if (newRight) newRight.previous = last;\n    if (!first.previous) this.firstChunk = last.next;\n    if (!last.next) {\n      this.lastChunk = first.previous;\n      this.lastChunk.next = null;\n    }\n    first.previous = newLeft;\n    last.next = newRight || null;\n    if (!newLeft) this.firstChunk = first;\n    if (!newRight) this.lastChunk = last;\n    return this;\n  }\n  overwrite(start, end, content, options) {\n    options = options || {};\n    return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n  }\n  update(start, end, content, options) {\n    if (typeof content !== \"string\") throw new TypeError(\"replacement content must be a string\");\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (end > this.original.length) throw new Error(\"end is out of bounds\");\n    if (start === end)\n      throw new Error(\n        \"Cannot overwrite a zero-length range \\u2013 use appendLeft or prependRight instead\"\n      );\n    this._split(start);\n    this._split(end);\n    if (options === true) {\n      if (!warned.storeName) {\n        console.warn(\n          \"The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string\"\n        );\n        warned.storeName = true;\n      }\n      options = { storeName: true };\n    }\n    const storeName = options !== void 0 ? options.storeName : false;\n    const overwrite = options !== void 0 ? options.overwrite : false;\n    if (storeName) {\n      const original = this.original.slice(start, end);\n      Object.defineProperty(this.storedNames, original, {\n        writable: true,\n        value: true,\n        enumerable: true\n      });\n    }\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n    if (first) {\n      let chunk = first;\n      while (chunk !== last) {\n        if (chunk.next !== this.byStart[chunk.end]) {\n          throw new Error(\"Cannot overwrite across a split point\");\n        }\n        chunk = chunk.next;\n        chunk.edit(\"\", false);\n      }\n      first.edit(content, storeName, !overwrite);\n    } else {\n      const newChunk = new Chunk2(start, end, \"\").edit(content, storeName);\n      last.next = newChunk;\n      newChunk.previous = last;\n    }\n    return this;\n  }\n  prepend(content) {\n    if (typeof content !== \"string\") throw new TypeError(\"outro content must be a string\");\n    this.intro = content + this.intro;\n    return this;\n  }\n  prependLeft(index, content) {\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byEnd[index];\n    if (chunk) {\n      chunk.prependLeft(content);\n    } else {\n      this.intro = content + this.intro;\n    }\n    return this;\n  }\n  prependRight(index, content) {\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byStart[index];\n    if (chunk) {\n      chunk.prependRight(content);\n    } else {\n      this.outro = content + this.outro;\n    }\n    return this;\n  }\n  remove(start, end) {\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (start === end) return this;\n    if (start < 0 || end > this.original.length) throw new Error(\"Character is out of bounds\");\n    if (start > end) throw new Error(\"end must be greater than start\");\n    this._split(start);\n    this._split(end);\n    let chunk = this.byStart[start];\n    while (chunk) {\n      chunk.intro = \"\";\n      chunk.outro = \"\";\n      chunk.edit(\"\");\n      chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n    }\n    return this;\n  }\n  reset(start, end) {\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (start === end) return this;\n    if (start < 0 || end > this.original.length) throw new Error(\"Character is out of bounds\");\n    if (start > end) throw new Error(\"end must be greater than start\");\n    this._split(start);\n    this._split(end);\n    let chunk = this.byStart[start];\n    while (chunk) {\n      chunk.reset();\n      chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n    }\n    return this;\n  }\n  lastChar() {\n    if (this.outro.length) return this.outro[this.outro.length - 1];\n    let chunk = this.lastChunk;\n    do {\n      if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n      if (chunk.content.length) return chunk.content[chunk.content.length - 1];\n      if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n    } while (chunk = chunk.previous);\n    if (this.intro.length) return this.intro[this.intro.length - 1];\n    return \"\";\n  }\n  lastLine() {\n    let lineIndex = this.outro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n    let lineStr = this.outro;\n    let chunk = this.lastChunk;\n    do {\n      if (chunk.outro.length > 0) {\n        lineIndex = chunk.outro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.outro + lineStr;\n      }\n      if (chunk.content.length > 0) {\n        lineIndex = chunk.content.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.content + lineStr;\n      }\n      if (chunk.intro.length > 0) {\n        lineIndex = chunk.intro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.intro + lineStr;\n      }\n    } while (chunk = chunk.previous);\n    lineIndex = this.intro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n    return this.intro + lineStr;\n  }\n  slice(start = 0, end = this.original.length) {\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    let result = \"\";\n    let chunk = this.firstChunk;\n    while (chunk && (chunk.start > start || chunk.end <= start)) {\n      if (chunk.start < end && chunk.end >= end) {\n        return result;\n      }\n      chunk = chunk.next;\n    }\n    if (chunk && chunk.edited && chunk.start !== start)\n      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n    const startChunk = chunk;\n    while (chunk) {\n      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n        result += chunk.intro;\n      }\n      const containsEnd = chunk.start < end && chunk.end >= end;\n      if (containsEnd && chunk.edited && chunk.end !== end)\n        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n      const sliceStart = startChunk === chunk ? start - chunk.start : 0;\n      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n      result += chunk.content.slice(sliceStart, sliceEnd);\n      if (chunk.outro && (!containsEnd || chunk.end === end)) {\n        result += chunk.outro;\n      }\n      if (containsEnd) {\n        break;\n      }\n      chunk = chunk.next;\n    }\n    return result;\n  }\n  // TODO deprecate this? not really very useful\n  snip(start, end) {\n    const clone = this.clone();\n    clone.remove(0, start);\n    clone.remove(end, clone.original.length);\n    return clone;\n  }\n  _split(index) {\n    if (this.byStart[index] || this.byEnd[index]) return;\n    let chunk = this.lastSearchedChunk;\n    const searchForward = index > chunk.end;\n    while (chunk) {\n      if (chunk.contains(index)) return this._splitChunk(chunk, index);\n      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n    }\n  }\n  _splitChunk(chunk, index) {\n    if (chunk.edited && chunk.content.length) {\n      const loc = getLocator(this.original)(index);\n      throw new Error(\n        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \\u2013 \"${chunk.original}\")`\n      );\n    }\n    const newChunk = chunk.split(index);\n    this.byEnd[index] = chunk;\n    this.byStart[index] = newChunk;\n    this.byEnd[newChunk.end] = newChunk;\n    if (chunk === this.lastChunk) this.lastChunk = newChunk;\n    this.lastSearchedChunk = chunk;\n    return true;\n  }\n  toString() {\n    let str = this.intro;\n    let chunk = this.firstChunk;\n    while (chunk) {\n      str += chunk.toString();\n      chunk = chunk.next;\n    }\n    return str + this.outro;\n  }\n  isEmpty() {\n    let chunk = this.firstChunk;\n    do {\n      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())\n        return false;\n    } while (chunk = chunk.next);\n    return true;\n  }\n  length() {\n    let chunk = this.firstChunk;\n    let length = 0;\n    do {\n      length += chunk.intro.length + chunk.content.length + chunk.outro.length;\n    } while (chunk = chunk.next);\n    return length;\n  }\n  trimLines() {\n    return this.trim(\"[\\\\r\\\\n]\");\n  }\n  trim(charType) {\n    return this.trimStart(charType).trimEnd(charType);\n  }\n  trimEndAborted(charType) {\n    const rx = new RegExp((charType || \"\\\\s\") + \"+$\");\n    this.outro = this.outro.replace(rx, \"\");\n    if (this.outro.length) return true;\n    let chunk = this.lastChunk;\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimEnd(rx);\n      if (chunk.end !== end) {\n        if (this.lastChunk === chunk) {\n          this.lastChunk = chunk.next;\n        }\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n      if (aborted) return true;\n      chunk = chunk.previous;\n    } while (chunk);\n    return false;\n  }\n  trimEnd(charType) {\n    this.trimEndAborted(charType);\n    return this;\n  }\n  trimStartAborted(charType) {\n    const rx = new RegExp(\"^\" + (charType || \"\\\\s\") + \"+\");\n    this.intro = this.intro.replace(rx, \"\");\n    if (this.intro.length) return true;\n    let chunk = this.firstChunk;\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimStart(rx);\n      if (chunk.end !== end) {\n        if (chunk === this.lastChunk) this.lastChunk = chunk.next;\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n      if (aborted) return true;\n      chunk = chunk.next;\n    } while (chunk);\n    return false;\n  }\n  trimStart(charType) {\n    this.trimStartAborted(charType);\n    return this;\n  }\n  hasChanged() {\n    return this.original !== this.toString();\n  }\n  _replaceRegexp(searchValue, replacement) {\n    function getReplacement(match, str) {\n      if (typeof replacement === \"string\") {\n        return replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n          if (i === \"$\") return \"$\";\n          if (i === \"&\") return match[0];\n          const num = +i;\n          if (num < match.length) return match[+i];\n          return `$${i}`;\n        });\n      } else {\n        return replacement(...match, match.index, str, match.groups);\n      }\n    }\n    function matchAll(re, str) {\n      let match;\n      const matches = [];\n      while (match = re.exec(str)) {\n        matches.push(match);\n      }\n      return matches;\n    }\n    if (searchValue.global) {\n      const matches = matchAll(searchValue, this.original);\n      matches.forEach((match) => {\n        if (match.index != null) {\n          const replacement2 = getReplacement(match, this.original);\n          if (replacement2 !== match[0]) {\n            this.overwrite(\n              match.index,\n              match.index + match[0].length,\n              replacement2\n            );\n          }\n        }\n      });\n    } else {\n      const match = this.original.match(searchValue);\n      if (match && match.index != null) {\n        const replacement2 = getReplacement(match, this.original);\n        if (replacement2 !== match[0]) {\n          this.overwrite(\n            match.index,\n            match.index + match[0].length,\n            replacement2\n          );\n        }\n      }\n    }\n    return this;\n  }\n  _replaceString(string, replacement) {\n    const { original } = this;\n    const index = original.indexOf(string);\n    if (index !== -1) {\n      this.overwrite(index, index + string.length, replacement);\n    }\n    return this;\n  }\n  replace(searchValue, replacement) {\n    if (typeof searchValue === \"string\") {\n      return this._replaceString(searchValue, replacement);\n    }\n    return this._replaceRegexp(searchValue, replacement);\n  }\n  _replaceAllString(string, replacement) {\n    const { original } = this;\n    const stringLength = string.length;\n    for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {\n      const previous = original.slice(index, index + stringLength);\n      if (previous !== replacement)\n        this.overwrite(index, index + stringLength, replacement);\n    }\n    return this;\n  }\n  replaceAll(searchValue, replacement) {\n    if (typeof searchValue === \"string\") {\n      return this._replaceAllString(searchValue, replacement);\n    }\n    if (!searchValue.global) {\n      throw new TypeError(\n        \"MagicString.prototype.replaceAll called with a non-global RegExp argument\"\n      );\n    }\n    return this._replaceRegexp(searchValue, replacement);\n  }\n};\n\n// src/core/style.ts\nvar import_path2 = __toESM(require(\"path\"));\nvar style_default = {\n  translate(tag) {\n    const {\n      hub: { file }\n    } = tag;\n    const { filename, sourceMaps } = file.opts;\n    (0, import_babel_utils33.assertNoParams)(tag);\n    assertNoSpreadAttrs(tag);\n    let type = \"text/css\";\n    const attrs2 = tag.get(\"attributes\");\n    const base = import_path2.default.basename(filename);\n    const typeAttr = attrs2.find(\n      (attr2) => attr2.isMarkoAttribute() && attr2.node.name === \"type\"\n    );\n    const classAttr2 = attrs2.find(\n      (attr2) => attr2.isMarkoAttribute() && attr2.node.name === \"class\"\n    );\n    if (typeAttr && classAttr2) {\n      throw classAttr2.buildCodeFrameError(\n        \"The `style` tag must only use `type` or `class` and not both.\"\n      );\n    } else if (typeAttr) {\n      const typeValue = typeAttr.get(\"value\");\n      if (typeValue.isStringLiteral()) {\n        type = typeValue.node.value;\n      } else {\n        throw typeValue.buildCodeFrameError(\n          \"The `style` tag `type` attribute can only be a string literal.\"\n        );\n      }\n    } else if (classAttr2) {\n      const classValue2 = classAttr2.get(\"value\");\n      if (classValue2.isStringLiteral()) {\n        type = classValue2.node.value;\n      } else {\n        throw classValue2.buildCodeFrameError(\n          \"The `style` tag `class` attribute can only be a string literal.\"\n        );\n      }\n    }\n    if (type === \"text/css\") {\n      type = \"css\";\n    }\n    if (tag.node.var && !type.startsWith(\"module\")) {\n      type = \"module.\" + type;\n    }\n    const body = tag.get(\"body\").get(\"body\");\n    const markoText = body[0];\n    if (body.length !== 1 || !markoText.isMarkoText()) {\n      throw (markoText.isMarkoText() ? body[1] : body[0]).buildCodeFrameError(\n        \"The `style` tag currently only supports static content.\"\n      );\n    }\n    const { resolveVirtualDependency } = getMarkoOpts();\n    const start = (0, import_babel_utils33.getStart)(file, markoText.node);\n    const end = (0, import_babel_utils33.getEnd)(file, markoText.node);\n    let code = markoText.node.value;\n    let map;\n    if (resolveVirtualDependency && sourceMaps && start !== null && end !== null) {\n      const magicString = new MagicString(file.code, { filename });\n      magicString.remove(0, start);\n      magicString.remove(end, file.code.length);\n      map = magicString.generateMap({\n        source: filename,\n        includeContent: true\n      });\n      if (sourceMaps === \"inline\" || sourceMaps === \"both\") {\n        code += `\n/*# sourceMappingURL=${map.toUrl()}*/`;\n        if (sourceMaps === \"inline\") {\n          map = void 0;\n        }\n      }\n    }\n    const importPath = resolveVirtualDependency?.(filename, {\n      virtualPath: `./${base}.${type}`,\n      code,\n      map\n    });\n    if (importPath) {\n      if (!tag.node.var) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler37.types.importDeclaration([], import_compiler37.types.stringLiteral(importPath))\n        );\n      } else if (import_compiler37.types.isIdentifier(tag.node.var)) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler37.types.importDeclaration(\n            [import_compiler37.types.importDefaultSpecifier(tag.node.var)],\n            import_compiler37.types.stringLiteral(importPath)\n          )\n        );\n      } else {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler37.types.variableDeclaration(\"const\", [\n            import_compiler37.types.variableDeclarator(\n              tag.node.var,\n              (0, import_babel_utils33.importDefault)(file, importPath, \"style\")\n            )\n          ])\n        );\n      }\n    }\n    tag.remove();\n  },\n  attributes: {}\n};\n\n// src/core/index.ts\nvar core_default = {\n  taglibId,\n  \"<import>\": import_default,\n  \"<export>\": export_default,\n  \"<attrs>\": attrs_default,\n  \"<if>\": if_default,\n  \"<else-if>\": else_if_default,\n  \"<else>\": else_default,\n  \"<for>\": for_default,\n  \"<let>\": let_default,\n  \"<const>\": const_default,\n  \"<define>\": define_default,\n  \"<effect>\": effect_default,\n  \"<do>\": do_default,\n  \"<log>\": log_default,\n  \"<debug>\": debug_default,\n  \"<lifecycle>\": lifecycle_default,\n  \"<id>\": id_default,\n  \"<html-comment>\": html_comment_default,\n  \"<return>\": return_default,\n  \"<style>\": style_default,\n  \"<await-reorderer>\": noop_default,\n  \"<init-widgets>\": noop_default,\n  \"<init-components>\": noop_default,\n  \"<static>\": static_default,\n  \"<server>\": server_default,\n  \"<client>\": client_default,\n  \"<__flush_here_and_after__>\": flush_here_and_after_default\n};\n\n// src/visitors/assignment-expression.ts\nvar import_compiler38 = require(\"@marko/compiler\");\nvar assignment_expression_default = {\n  translate: {\n    exit(assignment) {\n      if (isOutputDOM()) {\n        handleDestructure2(assignment, assignment.node.left);\n      }\n    }\n  }\n};\nfunction handleDestructure2(assignment, node) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        handleDestructure2(assignment, prop);\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const i in node.elements) {\n        if (node.elements[i] === null) continue;\n        handleDestructure2(assignment, node.elements[i]);\n      }\n      break;\n    case \"RestElement\":\n      handleDestructure2(assignment, node.argument);\n      break;\n    case \"ObjectProperty\":\n      handleDestructure2(assignment, node.value);\n      break;\n    case \"Identifier\": {\n      const source = node.extra?.source;\n      if (source) {\n        const section = getSection(assignment);\n        (currentProgramPath.node.extra.assignments ??= []).push([\n          section,\n          assignment\n        ]);\n      }\n      break;\n    }\n  }\n}\n\n// src/visitors/cdata.ts\nvar cdata_default = {\n  translate: {\n    enter(path3) {\n      throw path3.buildCodeFrameError(\n        \"CDATA sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/visitors/comment.ts\nvar comment_default = {\n  translate: {\n    exit(comment) {\n      comment.remove();\n    }\n  }\n};\n\n// src/visitors/declaration.ts\nvar declaration_default = {\n  translate: {\n    exit(declaration) {\n      if (isOutputHTML()) {\n        writeTo(declaration)`<?${declaration.node.value}?>`;\n      }\n      declaration.remove();\n    }\n  }\n};\n\n// src/visitors/document-type.ts\nvar document_type_default = {\n  translate: {\n    exit(documentType) {\n      if (isOutputHTML()) {\n        writeTo(documentType)`<!${documentType.node.value}>`;\n      }\n      documentType.remove();\n    }\n  }\n};\n\n// src/visitors/function.ts\nvar import_babel_utils34 = require(\"@marko/babel-utils\");\nvar import_compiler39 = require(\"@marko/compiler\");\nvar functionIdsBySection = /* @__PURE__ */ new WeakMap();\nvar registeredFunctions = /* @__PURE__ */ new WeakSet();\nvar function_default = {\n  analyze(fn) {\n    const markoRoot = getMarkoRoot(fn);\n    const isStatic2 = !markoRoot || markoRoot.isMarkoScriptlet({ static: true });\n    if (!isFunction(fn, isStatic2)) return;\n    if (markoRoot && (markoRoot.isMarkoPlaceholder() || markoRoot.isMarkoScriptlet({ target: \"server\" }))) {\n      return;\n    }\n    const { node } = fn;\n    const extra = node.extra ??= {};\n    const name = extra.name = fn.node.id?.name || (markoRoot?.isMarkoAttribute() ? markoRoot.node.default ? import_compiler39.types.toIdentifier(\n      markoRoot.parentPath.parentPath.get(\n        \"name\"\n      )\n    ) : markoRoot.node.name : \"anonymous\");\n    if (markoRoot && markoRoot.isMarkoAttribute() && ((0, import_babel_utils34.isNativeTag)(markoRoot.parentPath) || isCoreTagName(markoRoot.parentPath, \"effect\") || isCoreTagName(markoRoot.parentPath, \"lifecycle\") || isCoreTagName(markoRoot.parentPath, \"for\") || isCoreTagName(markoRoot.parentPath, \"do\"))) {\n      return;\n    }\n    const {\n      markoOpts,\n      opts: { filename }\n    } = currentProgramPath.hub.file;\n    const section = getSection(fn);\n    let functionNameCounts = functionIdsBySection.get(section);\n    if (!functionNameCounts) {\n      functionNameCounts = /* @__PURE__ */ new Map();\n      functionIdsBySection.set(section, functionNameCounts);\n    }\n    const index = functionNameCounts.get(name);\n    let id = \"\";\n    if (index === void 0) {\n      functionNameCounts.set(name, 0);\n    } else {\n      id = `_${index}`;\n    }\n    extra.registerId = (0, import_babel_utils34.getTemplateId)(\n      markoOpts,\n      filename,\n      `${section.id}/${name + id}`\n    );\n  },\n  translate: {\n    exit(fn) {\n      const markoRoot = getMarkoRoot(fn);\n      const isStatic2 = !markoRoot || markoRoot.isMarkoScriptlet({ static: true });\n      if (!isFunction(fn, isStatic2)) return;\n      const { node } = fn;\n      const { extra } = node;\n      if (!extra?.registerId) return;\n      if (registeredFunctions.has(node)) return;\n      const section = getSection(fn);\n      if (!section) return;\n      registeredFunctions.add(node);\n      if (isOutputHTML()) {\n        const serializedScopeProperties = getSerializedScopeProperties(section);\n        forEach(extra.referencedBindings, (ref) => {\n          serializedScopeProperties.set(\n            getScopeAccessorLiteral(ref),\n            import_compiler39.types.identifier(ref.name)\n          );\n        });\n        if (import_compiler39.types.isFunctionDeclaration(node)) {\n          currentProgramPath.unshiftContainer(\n            \"body\",\n            import_compiler39.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                node.id,\n                import_compiler39.types.stringLiteral(extra.registerId),\n                isStatic2 ? void 0 : getScopeIdIdentifier(section)\n              )\n            )\n          )[0].skip();\n        } else {\n          const replacement = callRuntime(\n            \"register\",\n            node,\n            import_compiler39.types.stringLiteral(extra.registerId),\n            isStatic2 ? void 0 : getScopeIdIdentifier(section)\n          );\n          if (isMarko(fn.parentPath)) {\n            replacement.extra = node.extra;\n          }\n          fn.replaceWith(replacement)[0].skip();\n        }\n      } else {\n        const { referencedBindings } = extra;\n        const fnId = currentProgramPath.scope.generateUidIdentifier(extra.name);\n        if (import_compiler39.types.isFunctionDeclaration(node)) {\n          currentProgramPath.unshiftContainer(\n            \"body\",\n            import_compiler39.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                import_compiler39.types.stringLiteral(extra.registerId),\n                node.id\n              )\n            )\n          )[0].skip();\n        } else if (isStatic2) {\n          const replacement = callRuntime(\n            \"register\",\n            import_compiler39.types.stringLiteral(extra.registerId),\n            node\n          );\n          if (isMarko(fn.parentPath)) {\n            replacement.extra = node.extra;\n          }\n          fn.replaceWith(replacement)[0].skip();\n        } else {\n          const replacement = import_compiler39.types.callExpression(fnId, [scopeIdentifier]);\n          if (isMarko(fn.parentPath)) {\n            replacement.extra = node.extra;\n          }\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler39.types.variableDeclaration(\"const\", [\n              import_compiler39.types.variableDeclarator(\n                fnId,\n                callRuntime(\n                  \"register\",\n                  import_compiler39.types.stringLiteral(extra.registerId),\n                  import_compiler39.types.arrowFunctionExpression(\n                    [scopeIdentifier],\n                    referencedBindings ? import_compiler39.types.blockStatement([\n                      import_compiler39.types.variableDeclaration(\"const\", [\n                        import_compiler39.types.variableDeclarator(\n                          createScopeReadPattern(\n                            section,\n                            referencedBindings\n                          ),\n                          scopeIdentifier\n                        )\n                      ]),\n                      import_compiler39.types.returnStatement(node)\n                    ]) : node\n                  )\n                )\n              )\n            ])\n          )[0].skip();\n          fn.replaceWith(replacement)[0].skip();\n        }\n      }\n    }\n  }\n};\nfunction isFunction(fn, isStatic2) {\n  switch (fn.node.type) {\n    case \"FunctionDeclaration\":\n      return isStatic2;\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// src/visitors/import-declaration.ts\nvar import_babel_utils35 = require(\"@marko/babel-utils\");\nvar import_declaration_default = {\n  analyze(importDecl) {\n    const { node } = importDecl;\n    const { source } = node;\n    const { value } = source;\n    const tagImport = (0, import_babel_utils35.resolveTagImport)(importDecl, value);\n    if (tagImport) {\n      node.extra ??= {};\n      node.extra.tagImport = tagImport;\n      const tags = importDecl.hub.file.metadata.marko.tags;\n      if (!tags.includes(tagImport)) {\n        tags.push(tagImport);\n      }\n    }\n  },\n  translate: {\n    exit(importDecl) {\n      const { node } = importDecl;\n      const { extra } = node;\n      const tagImport = extra?.tagImport;\n      if (tagImport) {\n        node.source.value = tagImport;\n      }\n    }\n  }\n};\n\n// src/visitors/placeholder.ts\nvar import_babel_utils36 = require(\"@marko/babel-utils\");\nvar import_compiler40 = require(\"@marko/compiler\");\nvar kBinding2 = Symbol(\"placeholder node binding\");\nvar kSiblingText = Symbol(\"placeholder has sibling text\");\nvar ESCAPE_TYPES = {\n  script: \"escapeScript\",\n  style: \"escapeStyle\"\n};\nvar placeholder_default = {\n  analyze(placeholder) {\n    const { node } = placeholder;\n    const { confident, computed } = evaluate(placeholder);\n    if (!(confident && (node.escape || !computed))) {\n      (node.extra ??= {})[kBinding2] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        getOrCreateSection(placeholder),\n        void 0,\n        node.value.extra\n      );\n      analyzeSiblingText(placeholder);\n    }\n  },\n  translate: {\n    exit(placeholder) {\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(placeholder);\n      const { node } = placeholder;\n      const { value } = node;\n      const extra = node.extra;\n      const { confident, computed } = extra;\n      const nodeBinding = extra[kBinding2];\n      const canWriteHTML = isHTML || confident && (node.escape || !computed);\n      const method = canWriteHTML ? node.escape ? ESCAPE_TYPES[getParentTagName(placeholder)] || \"escapeXML\" : \"toString\" : node.escape ? \"data\" : \"html\";\n      const isStateful = isStatefulReferences(value.extra?.referencedBindings);\n      const siblingText = extra[kSiblingText];\n      if (confident && canWriteHTML) {\n        write2`${getHTMLRuntime()[method](computed)}`;\n      } else {\n        if (siblingText === 1 /* Before */) {\n          if (isHTML && isStateful) {\n            write2`<!>`;\n          }\n          visit(placeholder, 37 /* Replace */);\n        } else if (siblingText === 2 /* After */) {\n          visit(placeholder, 37 /* Replace */);\n        } else {\n          if (!isHTML) write2` `;\n          visit(placeholder, 32 /* Get */);\n        }\n        if (isHTML) {\n          write2`${callRuntime(method, value)}`;\n          if (isStateful) {\n            markNode(placeholder, nodeBinding);\n          }\n        } else {\n          addStatement(\n            \"render\",\n            getSection(placeholder),\n            value.extra?.referencedBindings,\n            import_compiler40.types.expressionStatement(\n              method === \"data\" ? callRuntime(\n                \"data\",\n                import_compiler40.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(nodeBinding),\n                  true\n                ),\n                value\n              ) : callRuntime(\n                \"html\",\n                scopeIdentifier,\n                value,\n                getScopeAccessorLiteral(nodeBinding)\n              )\n            )\n          );\n        }\n      }\n      enterShallow(placeholder);\n      placeholder.remove();\n    }\n  }\n};\nfunction getParentTagName({ parentPath }) {\n  return parentPath.isMarkoTag() && (0, import_babel_utils36.isNativeTag)(parentPath) && parentPath.node.name.value || \"\";\n}\nfunction analyzeSiblingText(placeholder) {\n  const placeholderExtra = placeholder.node.extra;\n  let prev = placeholder.getPrevSibling();\n  while (prev.node) {\n    const contentType = getNodeContentType(\n      prev,\n      \"endType\"\n    );\n    if (contentType === null) {\n      prev = prev.getPrevSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 1 /* Before */;\n    } else {\n      break;\n    }\n  }\n  if (!prev.node && import_compiler40.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 1 /* Before */;\n  }\n  let next = placeholder.getNextSibling();\n  while (next.node) {\n    const contentType = getNodeContentType(\n      next,\n      \"startType\"\n    );\n    if (contentType === null) {\n      next = next.getNextSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 2 /* After */;\n    } else {\n      break;\n    }\n  }\n  if (!next.node && import_compiler40.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 2 /* After */;\n  }\n  return placeholderExtra[kSiblingText] = 0 /* None */;\n}\n\n// src/visitors/referenced-identifier.ts\nvar import_compiler41 = require(\"@marko/compiler\");\nvar abortIdsByExpressionForSection = /* @__PURE__ */ new WeakMap();\nvar referenced_identifier_default = {\n  migrate(identifier) {\n    const { name } = identifier.node;\n    if (identifier.scope.hasBinding(name)) return;\n    switch (name) {\n      case \"out\":\n        if (import_compiler41.types.isMemberExpression(identifier.parent) && import_compiler41.types.isIdentifier(identifier.parent.property) && identifier.parent.property.name === \"global\") {\n          identifier.parentPath.replaceWith(import_compiler41.types.identifier(\"$global\"));\n        } else {\n          throw identifier.buildCodeFrameError(\n            \"Only `out.global` is supported for compatibility.\"\n          );\n        }\n        break;\n    }\n  },\n  translate(identifier) {\n    const { name } = identifier.node;\n    if (identifier.scope.hasBinding(name)) return;\n    switch (name) {\n      case \"$global\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler41.types.memberExpression(\n              import_compiler41.types.callExpression(importRuntime(\"getStreamData\"), []),\n              import_compiler41.types.identifier(\"global\")\n            )\n          );\n        } else {\n          identifier.replaceWith(\n            import_compiler41.types.memberExpression(scopeIdentifier, import_compiler41.types.identifier(\"$global\"))\n          );\n        }\n        break;\n      case \"$signal\":\n        if (isOutputHTML()) {\n          const section = getSection(identifier);\n          if (!section.hasCleanup) {\n            section.hasCleanup = true;\n            const exprRoot = getExprRoot(identifier);\n            const write2 = writeTo(exprRoot);\n            write2`${callRuntime(\"markResumeCleanup\", getScopeIdIdentifier(section))}`;\n          }\n          identifier.replaceWith(\n            import_compiler41.types.callExpression(\n              import_compiler41.types.arrowFunctionExpression(\n                [],\n                import_compiler41.types.blockStatement([\n                  import_compiler41.types.throwStatement(\n                    import_compiler41.types.newExpression(import_compiler41.types.identifier(\"Error\"), [\n                      import_compiler41.types.stringLiteral(\"Cannot use $signal in a server render.\")\n                    ])\n                  )\n                ])\n              ),\n              []\n            )\n          );\n        } else {\n          const section = getSection(identifier);\n          const exprRoot = getExprRoot(identifier);\n          let abortIdsByExpression = abortIdsByExpressionForSection.get(section);\n          let exprId;\n          if (abortIdsByExpression) {\n            exprId = abortIdsByExpression.get(exprRoot);\n          } else {\n            abortIdsByExpression = /* @__PURE__ */ new Map();\n            abortIdsByExpressionForSection.set(section, abortIdsByExpression);\n          }\n          if (!exprId) {\n            exprId = abortIdsByExpression.size;\n            abortIdsByExpression.set(exprRoot, exprId);\n            addStatement(\n              \"render\",\n              section,\n              exprRoot.node.extra?.referencedBindings,\n              import_compiler41.types.expressionStatement(\n                import_compiler41.types.callExpression(importRuntime(\"resetAbortSignal\"), [\n                  scopeIdentifier,\n                  import_compiler41.types.numericLiteral(exprId)\n                ])\n              )\n            );\n          }\n          identifier.replaceWith(\n            import_compiler41.types.callExpression(importRuntime(\"getAbortSignal\"), [\n              scopeIdentifier,\n              import_compiler41.types.numericLiteral(exprId)\n            ])\n          );\n        }\n    }\n  }\n};\n\n// src/visitors/scriptlet.ts\nvar scriptlet_default = {\n  analyze(scriptlet) {\n    mergeReferences(scriptlet, scriptlet.node.body);\n  },\n  translate: {\n    exit(scriptlet) {\n      const { node } = scriptlet;\n      if (isOutputHTML()) {\n        if (node.static) return;\n        scriptlet.replaceWithMultiple(node.body);\n      } else {\n        if (node.target && node.target !== \"client\") {\n          scriptlet.remove();\n        } else if (node.static) {\n          scriptlet.replaceWithMultiple(node.body);\n        } else {\n          addStatement(\n            \"render\",\n            getSection(scriptlet),\n            node.extra?.referencedBindings,\n            node.body\n          );\n          scriptlet.remove();\n        }\n      }\n    }\n  }\n};\n\n// src/visitors/tag/index.ts\nvar import_babel_utils40 = require(\"@marko/babel-utils\");\nvar import_compiler47 = require(\"@marko/compiler\");\n\n// src/util/plugin-hooks.ts\nvar import_compiler42 = require(\"@marko/compiler\");\nfunction enter2(modulePlugin, path3) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path3;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (isFunctionPlugin(plugin)) {\n    plugin(path3, import_compiler42.types);\n  } else if (plugin.enter) {\n    plugin.enter(path3, import_compiler42.types);\n  }\n  return node !== path3.node;\n}\nfunction exit2(modulePlugin, path3) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path3;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (!isFunctionPlugin(plugin) && plugin.exit) {\n    plugin.exit(path3, import_compiler42.types);\n  }\n  return node !== path3.node;\n}\nfunction isModulePlugin(plugin) {\n  return Boolean(plugin.default);\n}\nfunction isFunctionPlugin(plugin) {\n  return typeof plugin === \"function\";\n}\n\n// src/visitors/tag/attribute-tag.ts\nvar import_babel_utils37 = require(\"@marko/babel-utils\");\nvar import_compiler43 = require(\"@marko/compiler\");\nvar attribute_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils37.assertNoVar)(tag);\n      (0, import_babel_utils37.assertNoArgs)(tag);\n      startSection(tag.get(\"body\"));\n    }\n  },\n  translate: {\n    exit(tag) {\n      const parentTag = (0, import_babel_utils37.findParentTag)(tag);\n      if (!parentTag) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags must be nested within another tag.\");\n      }\n      const parentExtra = parentTag.node.extra;\n      if (parentExtra.tagNameType === 0 /* NativeTag */) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags cannot be nested under native tags.\");\n      }\n      if (isOutputHTML()) {\n        flushInto(tag);\n      } else {\n        tag.node.attributes.push(\n          import_compiler43.types.markoAttribute(\n            \"renderBody\",\n            import_compiler43.types.callExpression(import_compiler43.types.identifier(getSection(tag.get(\"body\")).name), [\n              scopeIdentifier\n            ])\n          )\n        );\n      }\n      const attrName = tag.node.name.value.slice(1);\n      const info = parentExtra.nestedAttributeTags[attrName];\n      const attrsObject = attrsToObject(tag, true);\n      if (info.dynamic) {\n        if (!info.identifier) {\n          info.identifier = parentTag.scope.generateUidIdentifier(attrName);\n          parentTag.insertBefore(\n            info.repeated ? import_compiler43.types.variableDeclaration(\"const\", [\n              import_compiler43.types.variableDeclarator(info.identifier, import_compiler43.types.arrayExpression([]))\n            ]) : import_compiler43.types.variableDeclaration(\"let\", [\n              import_compiler43.types.variableDeclarator(info.identifier)\n            ])\n          );\n          parentTag.pushContainer(\n            \"attributes\",\n            import_compiler43.types.markoAttribute(attrName, info.identifier)\n          );\n        }\n        tag.replaceWith(\n          import_compiler43.types.expressionStatement(\n            info.repeated ? import_compiler43.types.callExpression(\n              import_compiler43.types.memberExpression(info.identifier, import_compiler43.types.identifier(\"push\")),\n              [attrsObject]\n            ) : import_compiler43.types.assignmentExpression(\"=\", info.identifier, attrsObject)\n          )\n        );\n      } else if (info.repeated) {\n        const existingAttr = parentTag.get(\"attributes\").find((attr2) => attr2.node.name === attrName);\n        if (existingAttr) {\n          existingAttr.get(\"value\").pushContainer(\"elements\", attrsObject);\n        } else {\n          parentTag.pushContainer(\n            \"attributes\",\n            import_compiler43.types.markoAttribute(attrName, import_compiler43.types.arrayExpression([attrsObject]))\n          );\n        }\n        tag.remove();\n      } else {\n        parentTag.pushContainer(\n          \"attributes\",\n          import_compiler43.types.markoAttribute(attrName, attrsObject)\n        );\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/visitors/tag/custom-tag.ts\nvar import_babel_utils38 = require(\"@marko/babel-utils\");\nvar import_compiler44 = require(\"@marko/compiler\");\nvar kChildScopeBinding = Symbol(\"custom tag child scope\");\nvar custom_tag_default = {\n  analyze: {\n    enter(tag) {\n      const section = getOrCreateSection(tag);\n      const tagBody = tag.get(\"body\");\n      startSection(tagBody);\n      trackVarReferences(tag, 4 /* derived */);\n      trackParamsReferences(tagBody, 3 /* param */);\n      if ((0, import_babel_utils38.getTagTemplate)(tag)) {\n        const tagExtra = tag.node.extra ??= {};\n        tagExtra[kChildScopeBinding] = createBinding(\n          \"#childScope\",\n          0 /* dom */,\n          section,\n          void 0,\n          tagExtra\n        );\n      }\n      const childFile = (0, import_babel_utils38.loadFileForTag)(tag);\n      const childProgramExtra = childFile?.ast.program.extra;\n      const hasInteractiveChild = childProgramExtra?.isInteractive || childProgramExtra?.hasInteractiveChild;\n      const inputExport = childProgramExtra?.domExports?.params?.props?.[0];\n      if (!inputExport?.props || tag.node.attributes.find((attr2) => import_compiler44.types.isMarkoSpreadAttribute(attr2))) {\n        mergeReferences(\n          tag,\n          tag.node.attributes.map((attr2) => attr2.value)\n        );\n      }\n      if (hasInteractiveChild) {\n        (currentProgramPath.node.extra ?? {}).hasInteractiveChild = true;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      (0, import_babel_utils38.assertAttributesOrSingleArg)(tag);\n      visit(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML2(tag);\n      } else {\n        translateDOM2(tag);\n      }\n    }\n  }\n};\nfunction translateHTML2(tag) {\n  const tagBody = tag.get(\"body\");\n  const { node } = tag;\n  let tagIdentifier;\n  flushInto(tag);\n  writeHTMLResumeStatements(tagBody);\n  if (import_compiler44.types.isStringLiteral(node.name)) {\n    const { file } = tag.hub;\n    const tagName = node.name.value;\n    const relativePath = getTagRelativePath(tag);\n    tagIdentifier = (0, import_babel_utils38.importDefault)(file, relativePath, tagName);\n  } else {\n    tagIdentifier = node.name;\n  }\n  const tagVar = node.var;\n  const attrsObject = attrsToObject(tag, true);\n  const renderBodyProp = getRenderBodyProp(attrsObject);\n  const section = getSection(tag);\n  const childScopeBinding = node.extra[kChildScopeBinding];\n  const peekScopeId = tag.scope.generateUidIdentifier(childScopeBinding?.name);\n  tag.insertBefore(\n    import_compiler44.types.variableDeclaration(\"const\", [\n      import_compiler44.types.variableDeclarator(peekScopeId, callRuntime(\"peekNextScope\"))\n    ])\n  );\n  getSerializedScopeProperties(section).set(\n    getScopeAccessorLiteral(childScopeBinding),\n    callRuntime(\"writeExistingScope\", peekScopeId)\n  );\n  if (node.extra.tagNameNullable) {\n    let renderBodyId = void 0;\n    let renderTagExpr = callExpression(\n      tagIdentifier,\n      attrsToObject(tag)\n    );\n    if (renderBodyProp) {\n      renderBodyId = tag.scope.generateUidIdentifier(\"renderBody\");\n      const renderBodySection = getSection(tag.get(\"body\"));\n      const [renderBodyPath] = tag.insertBefore(\n        import_compiler44.types.variableDeclaration(\"const\", [\n          import_compiler44.types.variableDeclarator(\n            renderBodyId,\n            // TODO: only register if needed (child template analysis)\n            callRuntime(\n              \"register\",\n              callRuntime(\n                \"createRenderer\",\n                import_compiler44.types.arrowFunctionExpression(\n                  renderBodyProp.params,\n                  renderBodyProp.body\n                )\n              ),\n              import_compiler44.types.stringLiteral(\n                getResumeRegisterId(renderBodySection, \"renderer\")\n              ),\n              getScopeIdIdentifier(renderBodySection.parent)\n            )\n          )\n        ])\n      );\n      renderBodyPath.skip();\n      attrsObject.properties[attrsObject.properties.length - 1] = import_compiler44.types.objectProperty(import_compiler44.types.identifier(\"renderBody\"), renderBodyId);\n    }\n    if (tagVar) {\n      translateVar(tag, import_compiler44.types.unaryExpression(\"void\", import_compiler44.types.numericLiteral(0)), \"let\");\n      renderTagExpr = import_compiler44.types.assignmentExpression(\"=\", tagVar, renderTagExpr);\n    }\n    tag.replaceWith(\n      import_compiler44.types.ifStatement(\n        tagIdentifier,\n        import_compiler44.types.expressionStatement(renderTagExpr),\n        renderBodyId && callStatement(renderBodyId)\n      )\n    )[0].skip();\n  } else if (tagVar) {\n    translateVar(\n      tag,\n      callExpression(\n        tagIdentifier,\n        attrsObject,\n        callRuntime(\n          \"register\",\n          import_compiler44.types.arrowFunctionExpression([], import_compiler44.types.blockStatement([])),\n          import_compiler44.types.stringLiteral(\n            getResumeRegisterId(\n              section,\n              node.var.extra?.binding\n              // TODO: node.var is not always an identifier.\n            )\n          ),\n          getScopeIdIdentifier(section)\n        )\n      )\n    );\n    setForceResumeScope(section);\n    tag.remove();\n  } else {\n    tag.replaceWith(callStatement(tagIdentifier, attrsObject))[0].skip();\n  }\n}\nfunction translateDOM2(tag) {\n  const tagSection = getSection(tag);\n  const tagBody = tag.get(\"body\");\n  const tagBodySection = getSection(tagBody);\n  const { node } = tag;\n  const extra = node.extra;\n  const childScopeBinding = extra[kChildScopeBinding];\n  const write2 = writeTo(tag);\n  const { file } = tag.hub;\n  const tagName = import_compiler44.types.isIdentifier(node.name) ? node.name.name : import_compiler44.types.isStringLiteral(node.name) ? node.name.value : \"tag\";\n  const relativePath = getTagRelativePath(tag);\n  const childFile = (0, import_babel_utils38.loadFileForTag)(tag);\n  const childProgram = childFile.ast.program;\n  const tagIdentifier = (0, import_babel_utils38.importNamed)(\n    file,\n    relativePath,\n    childProgram.extra.domExports.setup,\n    tagName\n  );\n  const inputExport = childProgram.extra.domExports.params?.props?.[0];\n  if (inputExport) {\n    if (!inputExport.props || tag.node.attributes.some((attr2) => import_compiler44.types.isMarkoSpreadAttribute(attr2))) {\n      let attrsObject = attrsToObject(tag);\n      if (tagBodySection !== tagSection) {\n        attrsObject ??= import_compiler44.types.objectExpression([]);\n        attrsObject.properties.push(\n          import_compiler44.types.objectProperty(\n            import_compiler44.types.identifier(\"renderBody\"),\n            import_compiler44.types.callExpression(import_compiler44.types.identifier(tagBodySection.name), [\n              scopeIdentifier\n            ])\n          )\n        );\n      }\n      const tagAttrsIdentifier = (0, import_babel_utils38.importNamed)(\n        file,\n        relativePath,\n        inputExport.id,\n        `${tagName}_input`\n      );\n      addValue(\n        tagSection,\n        extra.referencedBindings,\n        {\n          identifier: tagAttrsIdentifier,\n          hasDownstreamIntersections: () => true\n        },\n        attrsObject,\n        createScopeReadExpression(tagSection, childScopeBinding),\n        callRuntime(\n          \"inChild\",\n          getScopeAccessorLiteral(childScopeBinding),\n          import_compiler44.types.identifier(tagAttrsIdentifier.name)\n        )\n      );\n    } else {\n      for (const attrPath of tag.get(\n        \"attributes\"\n      )) {\n        const attr2 = attrPath.node;\n        const attrExport = inputExport.props[attr2.name];\n        if (attrExport) {\n          const attrExportIdentifier = (0, import_babel_utils38.importNamed)(\n            file,\n            relativePath,\n            attrExport.id,\n            `${tagName}_${attrExport.id}`\n          );\n          const attrReferences = attr2.value.extra?.referencedBindings;\n          addValue(\n            tagSection,\n            attrReferences,\n            {\n              identifier: attrExportIdentifier,\n              hasDownstreamIntersections: () => true\n            },\n            attr2.value,\n            createScopeReadExpression(tagSection, childScopeBinding),\n            callRuntime(\n              \"inChild\",\n              getScopeAccessorLiteral(childScopeBinding),\n              import_compiler44.types.identifier(attrExportIdentifier.name)\n            )\n          );\n        }\n      }\n      if (inputExport.props.renderBody && tagBodySection !== tagSection) {\n        const renderBodyExportIdentifier = (0, import_babel_utils38.importNamed)(\n          file,\n          relativePath,\n          inputExport.props.renderBody.id,\n          `${tagName}_renderBody`\n        );\n        addValue(\n          tagSection,\n          void 0,\n          {\n            identifier: renderBodyExportIdentifier,\n            hasDownstreamIntersections: () => true\n          },\n          import_compiler44.types.callExpression(import_compiler44.types.identifier(tagBodySection.name), [\n            scopeIdentifier\n          ]),\n          createScopeReadExpression(tagSection, childScopeBinding),\n          callRuntime(\n            \"inChild\",\n            getScopeAccessorLiteral(childScopeBinding),\n            import_compiler44.types.identifier(renderBodyExportIdentifier.name)\n          )\n        );\n      }\n    }\n  }\n  write2`${(0, import_babel_utils38.importNamed)(file, relativePath, childProgram.extra.domExports.template, `${tagName}_template`)}`;\n  injectWalks(\n    tag,\n    (0, import_babel_utils38.importNamed)(\n      file,\n      relativePath,\n      childProgram.extra.domExports.walks,\n      `${tagName}_walks`\n    )\n  );\n  if (node.var) {\n    const source = initValue(\n      // TODO: support destructuring\n      node.var.extra.binding\n    );\n    source.register = true;\n    addStatement(\n      \"render\",\n      tagSection,\n      void 0,\n      import_compiler44.types.expressionStatement(\n        callRuntime(\n          \"setTagVar\",\n          scopeIdentifier,\n          getScopeAccessorLiteral(childScopeBinding),\n          source.identifier\n        )\n      )\n    );\n  }\n  addStatement(\n    \"render\",\n    tagSection,\n    void 0,\n    import_compiler44.types.expressionStatement(\n      import_compiler44.types.callExpression(tagIdentifier, [\n        createScopeReadExpression(tagSection, childScopeBinding)\n      ])\n    )\n  );\n  tag.remove();\n}\nfunction getTagRelativePath(tag) {\n  const {\n    node,\n    hub: { file }\n  } = tag;\n  const nameIsString = import_compiler44.types.isStringLiteral(node.name);\n  let relativePath;\n  if (nameIsString) {\n    const template = (0, import_babel_utils38.getTagTemplate)(tag);\n    relativePath = template && (0, import_babel_utils38.resolveRelativePath)(file, template);\n  } else if (node.extra?.tagNameImported) {\n    relativePath = node.extra.tagNameImported;\n  }\n  if (!relativePath) {\n    const nodeName = nameIsString ? node.name.value : node.name;\n    if (nameIsString && tag.scope.getBinding(nodeName)) {\n      const str = nodeName;\n      throw tag.get(\"name\").buildCodeFrameError(\n        `Local variables must in a dynamic tag unless they are PascalCase. Use \\`<\\${${str}}/>\\` or rename to \\`${str.charAt(0).toUpperCase() + str.slice(1)}\\`.`\n      );\n    }\n    throw tag.get(\"name\").buildCodeFrameError(\n      `Unable to find entry point for custom tag \\`${nodeName}\\`.`\n    );\n  }\n  const tags = file.metadata.marko.tags;\n  if (!tags.includes(relativePath)) {\n    tags.push(relativePath);\n  }\n  return relativePath;\n}\nfunction callStatement(id, ...args) {\n  return import_compiler44.types.expressionStatement(callExpression(id, ...args));\n}\nfunction callExpression(id, ...args) {\n  return import_compiler44.types.callExpression(id, args.filter(Boolean));\n}\n\n// src/visitors/tag/dynamic-tag.ts\nvar import_babel_utils39 = require(\"@marko/babel-utils\");\nvar import_compiler46 = require(\"@marko/compiler\");\n\n// src/util/to-first-expression-or-block.ts\nvar import_compiler45 = require(\"@marko/compiler\");\nfunction toFirstExpressionOrBlock(body) {\n  const nodes = body.body;\n  if (nodes.length === 1 && import_compiler45.types.isExpressionStatement(nodes[0])) {\n    return nodes[0].expression;\n  }\n  if (import_compiler45.types.isBlockStatement(body)) {\n    return body;\n  }\n  return import_compiler45.types.blockStatement(nodes);\n}\n\n// src/visitors/tag/dynamic-tag.ts\nvar kDOMBinding = Symbol(\"dynamic tag dom binding\");\nvar dynamic_tag_default = {\n  analyze: {\n    enter(tag) {\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      const tagBody = tag.get(\"body\");\n      const domBinding = tagExtra[kDOMBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section,\n        void 0,\n        tagExtra\n      );\n      startSection(tagBody);\n      trackVarReferences(tag, 4 /* derived */);\n      trackParamsReferences(tagBody, 3 /* param */);\n      const referenceNodes = [];\n      if (tag.node.arguments) {\n        for (const arg of tag.node.arguments) {\n          referenceNodes.push(arg);\n        }\n      }\n      for (const attr2 of tag.node.attributes) {\n        referenceNodes.push(attr2.value);\n      }\n      mergeReferences(tag, referenceNodes);\n      addReferenceToExpression(tag, domBinding);\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag, 37 /* Replace */);\n      (0, import_babel_utils39.assertAttributesOrArgs)(tag);\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const extra = node.extra;\n      const nodeRef2 = extra[kDOMBinding];\n      let tagExpression = node.name;\n      if (import_compiler46.types.isStringLiteral(tagExpression)) {\n        const { file } = tag.hub;\n        const relativePath = getTagRelativePath(tag);\n        tagExpression = (0, import_babel_utils39.importDefault)(file, relativePath, tagExpression.value);\n      }\n      if (extra.featureType === \"class\") {\n        const { markoOpts } = tag.hub.file;\n        const compatRuntimeFile = `marko/src/runtime/helpers/tags-compat/${isOutputHTML() ? \"html\" : \"dom\"}${markoOpts.optimize ? \"\" : \"-debug\"}.${markoOpts.modules === \"esm\" ? \"mjs\" : \"js\"}`;\n        (0, import_babel_utils39.importDefault)(tag.hub.file, compatRuntimeFile);\n        if (isOutputHTML()) {\n          const serialized5to6 = (0, import_babel_utils39.importNamed)(\n            tag.hub.file,\n            compatRuntimeFile,\n            \"s\"\n          );\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler46.types.expressionStatement(\n              import_compiler46.types.callExpression(serialized5to6, [\n                import_compiler46.types.identifier(tagExpression.name),\n                import_compiler46.types.stringLiteral((0, import_babel_utils39.loadFileForTag)(tag).metadata.marko.id)\n              ])\n            )\n          );\n        } else {\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler46.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                import_compiler46.types.stringLiteral((0, import_babel_utils39.loadFileForTag)(tag).metadata.marko.id),\n                import_compiler46.types.identifier(tagExpression.name)\n              )\n            )\n          );\n        }\n      }\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        const section = getSection(tag);\n        const write2 = writeTo(tag);\n        const attrsObject = attrsToObject(tag, true);\n        const renderBodyProp = getRenderBodyProp(attrsObject);\n        const dynamicScopeIdentifier = currentProgramPath.scope.generateUidIdentifier(\"dynamicScope\");\n        const args = [\n          dynamicScopeIdentifier,\n          tagExpression,\n          attrsObject\n        ];\n        if (import_compiler46.types.isObjectExpression(attrsObject) && renderBodyProp) {\n          const renderBodySection = getSection(tag.get(\"body\"));\n          attrsObject.properties.pop();\n          args.push(\n            // TODO: omit register if dynamic tag is string only\n            callRuntime(\n              \"register\",\n              callRuntime(\n                \"createRenderer\",\n                import_compiler46.types.arrowFunctionExpression(\n                  renderBodyProp.params,\n                  toFirstExpressionOrBlock(renderBodyProp.body)\n                )\n              ),\n              import_compiler46.types.stringLiteral(\n                getResumeRegisterId(renderBodySection, \"renderer\")\n              ),\n              renderBodySection.closures.size && getScopeIdIdentifier(renderBodySection.parent)\n            )\n          );\n        }\n        if (node.var) {\n          if (args.length === 3) {\n            args.push(import_compiler46.types.unaryExpression(\"void\", import_compiler46.types.numericLiteral(0)));\n          }\n          args.push(\n            callRuntime(\n              \"register\",\n              import_compiler46.types.arrowFunctionExpression([], import_compiler46.types.blockStatement([])),\n              import_compiler46.types.stringLiteral(\n                getResumeRegisterId(\n                  section,\n                  node.var.extra?.binding\n                  // TODO: node.var is not always an identifier.\n                )\n              ),\n              getScopeIdIdentifier(section)\n            )\n          );\n        }\n        const dynamicTagExpr = import_compiler46.types.isArrayExpression(attrsObject) ? callRuntime(\"dynamicTagArgs\", ...args) : callRuntime(\"dynamicTagInput\", ...args);\n        tag.insertBefore(\n          import_compiler46.types.variableDeclaration(\"const\", [\n            import_compiler46.types.variableDeclarator(\n              dynamicScopeIdentifier,\n              callRuntime(\"peekNextScope\")\n            )\n          ])\n        )[0].skip();\n        if (node.var) {\n          translateVar(tag, dynamicTagExpr);\n        } else {\n          tag.insertBefore(import_compiler46.types.expressionStatement(dynamicTagExpr));\n        }\n        tag.remove();\n        write2`${callRuntime(\n          \"markResumeControlEnd\",\n          getScopeIdIdentifier(section),\n          getScopeAccessorLiteral(nodeRef2)\n        )}`;\n        getSerializedScopeProperties(section).set(\n          import_compiler46.types.stringLiteral(\n            getScopeAccessorLiteral(nodeRef2).value + \"!\" /* ConditionalScope */\n          ),\n          callRuntime(\"writeExistingScope\", dynamicScopeIdentifier)\n        );\n        getSerializedScopeProperties(section).set(\n          import_compiler46.types.stringLiteral(\n            getScopeAccessorLiteral(nodeRef2).value + \"(\" /* ConditionalRenderer */\n          ),\n          callRuntime(\n            \"normalizeDynamicRenderer\",\n            import_compiler46.types.isIdentifier(tagExpression) ? import_compiler46.types.identifier(tagExpression.name) : tagExpression\n          )\n        );\n      } else {\n        const section = getSection(tag);\n        const bodySection = getSection(tag.get(\"body\"));\n        const hasBody = section !== bodySection;\n        const renderBodyIdentifier = hasBody && import_compiler46.types.identifier(bodySection.name);\n        const signal = getSignal(section, nodeRef2, \"dynamicTagName\");\n        signal.build = () => {\n          return callRuntime(\n            \"conditional\",\n            getScopeAccessorLiteral(nodeRef2),\n            getSignalFn(signal, [scopeIdentifier]),\n            buildSignalIntersections(signal)\n          );\n        };\n        signal.hasDownstreamIntersections = () => true;\n        addValue(\n          section,\n          node.name.extra?.referencedBindings,\n          signal,\n          renderBodyIdentifier ? import_compiler46.types.logicalExpression(\n            \"||\",\n            tagExpression,\n            import_compiler46.types.callExpression(renderBodyIdentifier, [scopeIdentifier])\n          ) : tagExpression\n        );\n        if (tag.node.var) {\n          const source = initValue(\n            // TODO: support destructuring\n            tag.node.var.extra.binding\n          );\n          source.register = true;\n          addStatement(\n            \"render\",\n            section,\n            nodeRef2,\n            import_compiler46.types.expressionStatement(\n              callRuntime(\n                \"setTagVar\",\n                scopeIdentifier,\n                import_compiler46.types.stringLiteral(\n                  getScopeAccessorLiteral(extra[kDOMBinding]).value + \"!\" /* ConditionalScope */\n                ),\n                source.identifier\n              )\n            )\n          );\n        }\n        const attrsObject = attrsToObject(tag, true);\n        const emptyAttrs = import_compiler46.types.isObjectExpression(attrsObject) && !attrsObject.properties.length;\n        if (!emptyAttrs || renderBodyIdentifier) {\n          const attrsGetter = import_compiler46.types.arrowFunctionExpression([], attrsObject);\n          const id = currentProgramPath.scope.generateUidIdentifier(\n            tag.get(\"name\").toString() + \"_input\"\n          );\n          let added = false;\n          addValue(\n            section,\n            node.extra?.referencedBindings,\n            {\n              get identifier() {\n                if (!added) {\n                  currentProgramPath.pushContainer(\n                    \"body\",\n                    import_compiler46.types.variableDeclaration(\"const\", [\n                      import_compiler46.types.variableDeclarator(\n                        id,\n                        callRuntime(\n                          \"dynamicTagAttrs\",\n                          getScopeAccessorLiteral(nodeRef2),\n                          renderBodyIdentifier,\n                          import_compiler46.types.isArrayExpression(attrsObject) ? import_compiler46.types.booleanLiteral(true) : false\n                        )\n                      )\n                    ])\n                  );\n                  added = true;\n                }\n                return id;\n              },\n              hasDownstreamIntersections: () => true\n            },\n            attrsGetter\n          );\n        }\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/visitors/tag/index.ts\nvar tag_default = {\n  transform: {\n    enter(tag) {\n      const attrs2 = tag.get(\"attributes\");\n      for (let i = 0; i < attrs2.length; i++) {\n        const attr2 = attrs2[i];\n        if (import_compiler47.types.isMarkoAttribute(attr2.node) && attr2.node.bound) {\n          attr2.node.bound = false;\n          const changeValue = getChangeHandler(tag, attr2);\n          if (changeValue === null) {\n            throw attr2.buildCodeFrameError(\n              \"Attributes may only be bound to identifiers or member expressions\"\n            );\n          }\n          tag.node.attributes.splice(\n            ++i,\n            0,\n            import_compiler47.types.markoAttribute(attr2.node.name + \"Change\", changeValue)\n          );\n          tag.scope.crawl();\n        }\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils40.getTagDef)(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        enter2(hook, tag);\n        return;\n      }\n      if (type === 0 /* NativeTag */) {\n        native_tag_default.analyze.enter(tag);\n        return;\n      }\n      analyzeAttributeTags(tag);\n      switch (type) {\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.analyze.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.analyze.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const hook = (0, import_babel_utils40.getTagDef)(tag)?.analyzer?.hook;\n      if (hook) {\n        exit2(hook, tag);\n        return;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils40.getTagDef)(tag);\n      const extra = tag.node.extra;\n      if (tagDef?.translator) {\n        if (tagDef.translator.path) {\n          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);\n        }\n        enter2(tagDef.translator.hook, tag);\n        return;\n      }\n      for (const attr2 of tag.get(\"attributes\")) {\n        if (attr2.isMarkoAttribute()) {\n          if (attr2.node.arguments) {\n            throw attr2.buildCodeFrameError(\n              `Unsupported arguments on the \\`${attr2.node.name}\\` attribute.`\n            );\n          }\n          if (attr2.node.modifier) {\n            if ((0, import_babel_utils40.isNativeTag)(attr2.parentPath)) {\n              attr2.node.name += `:${attr2.node.modifier}`;\n            } else {\n              throw attr2.buildCodeFrameError(\n                `Unsupported modifier \\`${attr2.node.modifier}\\`.`\n              );\n            }\n          }\n        }\n      }\n      if (extra.tagNameDynamic && extra.tagNameNullable && !tag.get(\"name\").isIdentifier() && isOutputHTML()) {\n        const tagNameId = tag.scope.generateUidIdentifier(\"tagName\");\n        const [tagNameVarPath] = tag.insertBefore(\n          import_compiler47.types.variableDeclaration(\"const\", [\n            import_compiler47.types.variableDeclarator(tagNameId, tag.node.name)\n          ])\n        );\n        tagNameVarPath.skip();\n        tag.set(\"name\", tagNameId);\n      }\n      switch (extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const translator = (0, import_babel_utils40.getTagDef)(tag)?.translator;\n      if (translator) {\n        exit2(translator.hook, tag);\n        return;\n      }\n      switch (tag.node.extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.exit(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.exit(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.exit(tag);\n          break;\n      }\n    }\n  }\n};\nfunction getChangeHandler(tag, attr2) {\n  if (import_compiler47.types.isIdentifier(attr2.node.value)) {\n    const valueId = tag.scope.generateUidIdentifier(\n      \"new_\" + attr2.node.value.name\n    );\n    return import_compiler47.types.functionExpression(\n      null,\n      [valueId],\n      import_compiler47.types.blockStatement([\n        import_compiler47.types.expressionStatement(\n          import_compiler47.types.assignmentExpression(\"=\", attr2.node.value, valueId)\n        )\n      ])\n    );\n  } else if (import_compiler47.types.isMemberExpression(attr2.node.value)) {\n    const prop = attr2.node.value.property;\n    if (import_compiler47.types.isPrivateName(prop)) return null;\n    if (import_compiler47.types.isIdentifier(prop)) {\n      return import_compiler47.types.memberExpression(\n        import_compiler47.types.cloneNode(attr2.node.value.object),\n        import_compiler47.types.identifier(prop.name + \"Change\")\n      );\n    } else {\n      return import_compiler47.types.memberExpression(\n        import_compiler47.types.cloneNode(attr2.node.value.object),\n        import_compiler47.types.binaryExpression(\"+\", import_compiler47.types.cloneNode(prop), import_compiler47.types.stringLiteral(\"Change\")),\n        true\n      );\n    }\n  }\n  return null;\n}\n\n// src/visitors/text.ts\nvar import_compiler48 = require(\"@marko/compiler\");\nvar text_default = {\n  translate: {\n    exit(text) {\n      writeTo(text)`${text.node.value}`;\n      enterShallow(text);\n      text.remove();\n    }\n  }\n};\n\n// src/visitors/update-expression.ts\nvar import_compiler49 = require(\"@marko/compiler\");\nvar update_expression_default = {\n  translate: {\n    exit(assignment) {\n      if (isOutputDOM()) {\n        const source = assignment.node.argument.extra?.source;\n        if (source) {\n          const section = getSection(assignment);\n          (currentProgramPath.node.extra.assignments ??= []).push([\n            section,\n            assignment\n          ]);\n        }\n      }\n    }\n  }\n};\n\n// src/index.ts\nvar visitors = {\n  Program: program_default,\n  Function: function_default,\n  AssignmentExpression: assignment_expression_default,\n  UpdateExpression: update_expression_default,\n  ReferencedIdentifier: referenced_identifier_default,\n  ImportDeclaration: import_declaration_default,\n  MarkoDocumentType: document_type_default,\n  MarkoDeclaration: declaration_default,\n  MarkoCDATA: cdata_default,\n  MarkoText: text_default,\n  MarkoTag: tag_default,\n  MarkoPlaceholder: placeholder_default,\n  MarkoScriptlet: scriptlet_default,\n  MarkoComment: comment_default\n};\nvar getVisitorOfType = (typename) => Object.entries(visitors).reduce((visitor, [name, value]) => {\n  if (typename in value) {\n    visitor[name] = value[typename];\n  }\n  return visitor;\n}, {});\nvar transform = getVisitorOfType(\"transform\");\nvar analyze2 = getVisitorOfType(\"analyze\");\nvar translate2 = getVisitorOfType(\"translate\");\nvar taglibs = [\n  [\n    __dirname,\n    {\n      ...core_default,\n      migrate: getVisitorOfType(\"migrate\")\n    }\n  ]\n];\nfunction getRuntimeEntryFiles(output, optimize) {\n  return [\n    `@marko/runtime-tags${optimize ? \"\" : \"/debug\"}/${output === \"html\" ? \"html\" : \"dom\"}`\n  ];\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  analyze,\n  getRuntimeEntryFiles,\n  internalEntryBuilder,\n  taglibs,\n  transform,\n  translate\n});\n"],"names":["mod","__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__copyProps","to","from","except","desc","key","call","get","enumerable","__toESM","isNodeMode","target","__esModule","value","src_exports","__export","all","name","analyze","analyze2","getRuntimeEntryFiles","internalEntryBuilder","entry_builder_default","taglibs","transform","translate","translate2","module","exports","import_babel_utils","require","taglibId","isCoreTagName","tag","id","isMarkoTag","getTagDef","isCoreTag","node","import_babel_utils2","flush_here_and_after_default","renderer","replaceWithMultiple","body","import_compiler","attrs_default","migrate","tagVar","var","type","remove","constTag","types","markoTag","stringLiteral","markoAttribute","identifier","markoTagBody","replaceWith","attributes","autocomplete","displayText","description","snippet","import_babel_utils3","import_compiler2","client_default","parse","hub","file","rawValue","code","replace","trim","start","length","parseStatements","isBlockStatement","markoScriptlet","parseOptions","statement","rawOpenTag","descriptionMoreURL","import_babel_utils12","import_babel_utils11","import_compiler18","import_compiler16","import_babel_utils10","import_compiler15","import_path","bindingHasDownstreamExpressions","binding","downstreamExpressions","size","alias","aliases","propertyAliases","values","import_babel_utils4","import_compiler3","kState","Symbol","build","entryFile","state","path","buildCodeFrameError","imports","map","it","importDeclaration","init","unshift","importSpecifier","markoOpts","optimize","push","expressionStatement","callExpression","visit","visitChild","analyzedTags","metadata","marko","resolveRelativePath","opts","filename","extra","hasInteractiveChild","isInteractive","isOutputHTML","getMarkoOpts","output","isOutputDOM","currentProgramPath","import_babel_utils6","import_compiler5","createProgramState","WeakMap","set","createSectionState","section","arrayOfSectionData","import_babel_utils5","import_compiler4","withPreviousLocation","newNode","originalNode","loc","end","MARKO_FILE_REG","TAG_NAME_IDENTIFIER_REG","analyzeTagNameType","tagNameType","isStringLiteral","isNativeTag","bindingName","bindingIdentifier","scope","getBinding","test","tagIdentifier","referencedBindings","analyzeExpressionTagName","childFile","loadFileForTag","childProgram","ast","program","featureType","tagNameNullable","pending","path3","tagNameImported","nullable","pop","isConditionalExpression","alternate","isLogicalExpression","operator","isAssignmentExpression","isBinaryExpression","isTemplateLiteral","isNullLiteral","isIdentifier","kind","decl","parent","source","specifiers","some","isImportDefaultSpecifier","resolvedImport","resolveTagImport","bindingTag","bindingTagName","tagNameDynamic","startSection","parentSection","parentPath","getOrCreateSection","sectionNamePath","sectionName","isProgram","generateUid","toString","programExtra","sections","depth","closures","Set","bindings","content","getContentInfo","upstreamExpression","hasCleanup","cur","getSection","currentPath","_setSectionPath","getScopeIdIdentifier","generateUidIdentifier","getSectionParentIsOwner","setSectionParentIsOwner","getSectionPath","_getScopeIdentifier","getScopeIdentifier","ignoreDefault","scopeId","forEachSection","fn","forEach","contentInfo","startType","endType","singleChild","endIndex","getNodeContentType","startIndex","extraMember","isMarkoText","isMarkoPlaceholder","isMarkoScriptlet","isMarkoComment","isAttributeTag","tagSection","isStatefulSection","isStatefulReferences","checkStatefulClosures","immediateOnly","import_compiler13","import_babel_utils7","import_compiler7","stringifyClassObject","NON_DIMENSIONAL","stringifyStyleObject","toDelimitedString","val","delimiter","stringify","result","curDelimiter","Array","isArray","v","part","classAttr","stringAttr","styleAttr","attr","attrAssignment","RegExp","nonVoidAttr","escapeAttrValue","constructor","async","KNOWN_SYMBOLS2","Map","symbol","AggregateError","of","ArrayBuffer","isView","Atomics","add","and","compareExchange","exchange","isLockFree","load","notify","or","store","sub","wait","BigInt","asIntN","asUintN","BigInt64Array","BigUint64Array","Boolean","console","assert","clear","count","countReset","debug","dir","dirxml","error","group","groupCollapsed","groupEnd","info","log","table","time","timeEnd","timeLog","timeStamp","trace","warn","DataView","Date","now","UTC","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","Error","EvalError","Float32Array","Float64Array","Function","globalThis","atob","btoa","clearImmediate","clearInterval","clearTimeout","crypto","getRandomValues","randomUUID","fetch","performance","queueMicrotask","setImmediate","setInterval","setTimeout","structuredClone","URL","URLSearchParams","WritableStream","Int16Array","Int32Array","Int8Array","Intl","Collator","DateTimeFormat","DisplayNames","getCanonicalLocales","ListFormat","Locale","NumberFormat","PluralRules","RelativeTimeFormat","Segmenter","supportedValuesOf","isFinite","isNaN","JSON","groupBy","Math","abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","floor","fround","hypot","imul","log10","log1p","log2","max","min","pow","random","round","sign","sin","sinh","sqrt","tan","tanh","trunc","Number","isInteger","isSafeInteger","parseFloat","parseInt","assign","defineProperties","entries","freeze","fromEntries","getOwnPropertyDescriptors","getOwnPropertySymbols","is","isExtensible","isFrozen","isSealed","keys","preventExtensions","seal","setPrototypeOf","Promise","Proxy","RangeError","ReferenceError","Reflect","apply","construct","deleteProperty","has","ownKeys","String","fromCharCode","fromCodePoint","raw","for","SyntaxError","TypeError","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","URIError","WeakSet","unsafeAttrChars","str","c","lastIndex","unsafeXMLReg","replaceUnsafeXML","escapeXML","unsafeScriptReg","escapeScript","unsafeStyleReg","escapeStyle","import_compiler6","data","item","cb","findSorted","compare","pos","mid","compareResult","addSorted","len","i","next","joinRepeatable","a","b","createScopeReadPattern","rootDepth","rootPattern","objectPattern","nestedPatterns","ref","includes","propertyKey","getScopeAccessorLiteral","propertyValue","isShorthand","pattern","relativeDepth","prev","nestedPattern","properties","objectProperty","getScopeExpression","targetSection","scopeIdentifier","diff","memberExpression","createScopeReadExpression","reference","pureFunctions","importRuntime","importNamed","getRuntimePath","callRuntime","args","callExpression2","filteredArgs","arg","unaryExpression","numericLiteral","filterArguments","leadingComments","getHTMLRuntime","import_babel_utils9","import_compiler12","import_babel_utils8","import_compiler11","assertNoSpreadAttrs","attr2","isMarkoSpreadAttribute","assertNoBodyContent","import_compiler10","import_compiler8","toTemplateOrStringLiteral","parts","strs","exprs","curStr","nextIndex","exprLen","expressions","shiftItems","quasis","j","templateLiteral","templateElement","appendLiteral","arr","list","offset","import_compiler9","getWalks","getWalkComment","getSteps","walkCodeToName","enter","exit","enterShallow","steps","walks","walkComment","walkString","walkCodes","step","lastIndexOf","current","walk","nCodeString","writeTo","number","toCharString","startCode","rangeSize","multiplier","getWalkString","prefix2","postfix","walkLiteral","join","getWrites","exprsLen","writes","consumeHTML","flushBefore","expr","insertBefore","skip","flushInto","pushContainer","getSectionMeta","writePrefix","writePostfix","setup","getSetup","markNode","returnId","_setReturnId","usedTag","return_default","assertNoArgs","assertNoVar","assertNoParams","valueAttr","isMarkoAttribute","default","msg","buildError","returnId2","variableDeclaration","variableDeclarator","addValue","hasDownstreamIntersections","getSignals","getSubscribeBuilder","_setSubscribeBuilder","setSubscriberBuilder","builder","getClosures","addClosure","fromSection","toSection","closure","currentSection","forceResumeScope","_setForceResumeScope","setForceResumeScope","getSerializedScopeProperties","unimplementedBuild","getSignal","generateSignalName","signals","signal","exportName","export","domExports","intersection","render","effect","effectInlineReferences","subscribers","subscribe","getSignalFn","buildSignalIntersections","provider","ownerScope","isImmediateOwner","object","isDynamicClosure","arrowFunctionExpression","initValue","valueAccessor","intersections","isParamBinding","upstreamAlias","property","params","scopeIdentifier2","valueIdentifier","aliasSignal","callee","toMemberExpression","blockStatement","signal2","intersectionExpression","closureEntries","sort","closureSection","closureSignal","hasDynamicSubscribers","arrayExpression","subscriber","p","providerSignal","finalizeSignalArgs","isArrowFunctionExpression","nullLiteral","isExpressionStatement","expression","addStatement","originalNodes","isInlined","statements","isFunction","addEffectReferences","bindingUtil","union","getResumeRegisterId","getTemplateId","usedRegisterIdsBySection","getRegisterUID","used","baseId","renameBindings","traverseFast","writeSignals","sortSignals","effectDeclarator","effectIdentifier","isCallExpression","arguments","register","signalDeclarator","signalDeclaration","isFunctionExpression","functionDeclaration","isExpression","exportNamedDeclaration","roots","root","traverse","bindFunctionsVisitor","aReferencedBindings","getReferencedBindings","bReferencedBindings","reserve","getMappedId","addHTMLEffectCall","writeHTMLResumeStatements","tagVarIdentifier","hasSection","allSignals","scopeIdIdentifier","signalRefs","accessors","additionalProperties","serializedProperties","serialize","accessor","isLiteral","objectExpression","unshiftContainer","FunctionExpression","bindFunction","ArrowFunctionExpression","handleDestructure","assignment","ctx","getStatementParent","prop","elements","argument","buildAssignment","valueId","insertAfter","fnId","returnStatement","keyLiteral","keyToNode","dom_default","templateIdentifier","template","walksIdentifier","setupIdentifier","closuresIdentifier","paramsBinding","programParamsSignal","assignments","valueSection","replacement","binaryExpression","prefix","sequenceExpression","left","right","slice","replaceAssignments","forEachSectionReverse","childSection","sectionPath","sectionParamsBinding","tagParamsSignal","walks2","writes2","setup2","closures2","exportDefaultDeclaration","import_compiler14","html_default","returnIdentifier","renderContent","child","isImportDeclaration","isExportDeclaration","static","rendererId","previousProgramPath","program_default","crawl","trackParamsReferences","mergedReferences","getMergedReferences","nodes","targetExtra","isEffect","additionalBindings","delete","findReferences","getBindings","pruneBinding","referencedBinding","existingBinding","bindingReference","numReferences","binding1","binding2","sources1","getSourceBindings","sources2","isSuperset","sourceSection","bindings2","sortedBindings","filter","finalizeReferences","recurseAndBuildExportTree","visitedFiles","resolved","loadFileForImport","req","resolveRelativeToEntry","exportTree","props","exports2","getMarkoRoot","curPath","isMarko","getExprRoot","destructRoot","getDestructureRoot","getNextBindingId","setNextBindingId","createBinding","excludeProperties","propBinding","trackVarReferences","changeBinding","canonicalUpstreamAlias","getCanonicalBinding","createBindingsAndTrackReferences","assignBinding","element","lVal","babelBinding","referencePaths","constantViolations","referencePath","trackReference","isUpdateExpression","trackReferencesForBinding","patternBinding","fnRoot","getFnRoot","exprRoot","exprExtra","addReferenceToExpression","fnExtra","addReference","mergeReferences","compareIntersections","lenDelta","subset","elem","derived","sources","curBinding","this","aLen","bLen","aIndex","bIndex","unionSortedRepeatable","find","getIntersections","setIntersections","shouldPrune","isStatefulBinding","import_compiler17","toFirstStatementOrBlock","kBinding","if_default","testAttr","tagBody","tagExtra","BRANCHES_LOOKUP","getBranches","bodySection","branches","nextTag","getNextSibling","isLast","rootTag","rootExtra","tag2","singleNodeOptimization","every","getRoot","isStateful","nodeRef2","hasStatefulClosures","section2","conditionalExpression","write2","ifScopeIdIdentifier","ifRendererIdentifier","branchHasStatefulClosures","assignmentExpression","curStatement","ifStatement","else_default","import_babel_utils13","import_compiler19","else_if_default","import_babel_utils14","import_compiler21","import_compiler20","translateVar","initialValue","const_default","varBinding","derivation","import_babel_utils15","import_compiler22","debug_default","debuggerStatement","import_babel_utils17","import_compiler25","import_babel_utils16","import_compiler24","import_compiler23","IDENTIFIER_REG","renderBodyProps","attrsToObject","withRenderBody","resultExtra","spreadElement","hoistedControlFlows","isConditional","isLoop","renderBodySection","renderBodyExpression","isTransparentTag","getNonAttributeTagParent","isSpreadElement","getRenderBodyProp","attrsObject","isObjectExpression","lastProp","isObjectProperty","define_default","tagBodySection","import_babel_utils18","import_compiler26","do_default","hasDeclaration","isDeclaration","import_babel_utils19","import_compiler27","effect_default","value2","inlineBody","import_babel_utils20","export_default","import_babel_utils24","import_compiler29","import_babel_utils21","analyzeAttributeTags","nestedAttributeTags","analyzeChildren","repeated","dynamic","hasAttributeTags","analyzeChild","isLoopTag","attrName","lookup","existing","import_babel_utils23","import_compiler28","import_babel_utils22","evaluate","confident","computed","computeNode","kNativeTagBinding","kSerializeMarker","kGetterId","native_tag_default","attrs2","hasEventHandlers","hasDynamicAttributes","isSpreadAttr","attr3","isEventHandler","tagName","toIdentifier","isHTML","tagDef","hasSpread","getterId","varName","references","getterFnIdentifier","referenceSection","visitAccessor","attrsObj","name2","valueReferences","helper","propName","charAt","toLowerCase","openTagOnly","htmlType","kForMarkerBinding","kForScopeStartIndex","for_default","hasParams","findName","assertAllowedAttributes","validateFor","isOnlyChild","html","checkOnlyChild","parentTag","parentTagName","hasNestedAttributeTags","updateExpression","translateHTML","translateDOM","in","ofAttr","toAttr","inAttr","loopArgs","loopKind","fromAttr","stepAttr","byAttr","paramIdentifiers","getBindingIdentifiers","referencedBindings2","block","byParams","keyExpression","byIdentifier","keyParam","valParam","forInStatement","ofAttrValue","indexParam","loopParam","tempValParam","indexName","generateUidIdentifierBasedOnNode","forOfStatement","stepValue","fromValue","stepsName","stepName","fromName","forStatement","logicalExpression","forScopeIdsIdentifier","forScopesIdentifier","newExpression","obj","import_babel_utils25","import_compiler30","kCommentTagBinding","kGetterId2","html_comment_default","assertNoAttributes","needsBinding","needsGetter","referenceNodes","commentBinding","templateQuasis","templateExpressions","currentQuasi","text","import_babel_utils26","import_compiler31","id_default","import_babel_utils27","import_default","import_babel_utils28","import_compiler32","let_default","valueChangeAttr","valueChangeReferences","valueChangeBinding","isSetup","valueChangeSource","calleeExpression","initValueId","changeBindingId","queueSource","import_babel_utils29","import_compiler33","kRef","supportedAttrNames","lifecycle_default","lifecycleAttrsRef","import_babel_utils30","import_compiler34","log_default","noop_default","import_babel_utils31","import_compiler35","server_default","import_babel_utils32","import_compiler36","static_default","import_babel_utils33","import_compiler37","comma","charCodeAt","semicolon","intToChar","charToInt","chars","encodeInteger","num","relative","delta","clamped","write","td","TextDecoder","Buffer","decode","buf","buffer","byteOffset","byteLength","out","StringWriter","flush","subarray","BitSet","_BitSet","bits","n2","Chunk2","_Chunk","original","intro","outro","storeName","edited","previous","appendLeft","appendRight","clone","chunk","contains","index","eachNext","eachPrevious","edit","contentOnly","prependLeft","prependRight","reset","split","sliceIndex","originalBefore","originalAfter","newChunk","trimEnd","rx","trimmed","trimStart","unescape","SourceMap","version","sourcesContent","names","mappings","decoded","writer","sourcesIndex","sourceLine","sourceColumn","namesIndex","line","genColumn","segment","encode","x_google_ignoreList","toUrl","getRelativePath","fromParts","toParts","shift","concat","toString2","getLocator","originalLines","lineOffsets","m","column","wordRegex","Mappings","hires","generatedCodeLine","generatedCodeColumn","rawSegments","addEdit","sourceIndex","nameIndex","contentLengthMinusOne","contentLineEnd","indexOf","previousContentLineEnd","segment2","advance","addUneditedChunk","sourcemapLocations","originalCharIndex","first","charInHiresBoundary","lines","n","warned","insertLeft","insertRight","MagicString","_MagicString","string","options","writable","firstChunk","lastChunk","lastSearchedChunk","byStart","byEnd","indentExclusionRanges","storedNames","indentStr","ignoreList","addSourcemapLocation","char","append","_split","cloned","originalChunk","clonedChunk","nextOriginalChunk","nextClonedChunk","generateDecodedMap","locate","includeContent","generateMap","_ensureindentStr","tabbed","spaced","reduce","numSpaces","exec","Infinity","guessIndent","_getRawIndentString","getIndentString","indent","thing","isExcluded","exclude","exclusion","shouldIndentNextCharacter","indentStart","replacer","match","charIndex","_splitChunk","insert","move","last","oldLeft","oldRight","newRight","newLeft","overwrite","update","prepend","lastChar","lastLine","lineIndex","substr","lineStr","startChunk","containsEnd","sliceStart","sliceEnd","snip","searchForward","isEmpty","trimLines","charType","trimEndAborted","aborted","trimStartAborted","hasChanged","_replaceRegexp","searchValue","getReplacement","_","groups","global","re","matches","matchAll","replacement2","_replaceString","_replaceAllString","stringLength","replaceAll","import_path2","core_default","sourceMaps","base","basename","typeAttr","classAttr2","typeValue","classValue2","startsWith","markoText","resolveVirtualDependency","getStart","getEnd","magicString","importPath","virtualPath","importDefaultSpecifier","importDefault","assignment_expression_default","handleDestructure2","cdata_default","comment_default","comment","declaration_default","declaration","document_type_default","documentType","import_babel_utils34","import_compiler39","functionIdsBySection","registeredFunctions","function_default","markoRoot","functionNameCounts","registerId","isStatic2","serializedScopeProperties","isFunctionDeclaration","import_babel_utils35","import_declaration_default","importDecl","tagImport","tags","import_babel_utils36","import_compiler40","kBinding2","kSiblingText","ESCAPE_TYPES","script","style","placeholder_default","placeholder","escape","placeholderExtra","getPrevSibling","contentType","analyzeSiblingText","nodeBinding","canWriteHTML","method","getParentTagName","siblingText","import_compiler41","abortIdsByExpressionForSection","referenced_identifier_default","hasBinding","isMemberExpression","throwStatement","exprId","abortIdsByExpression","scriptlet_default","scriptlet","import_babel_utils40","import_compiler47","import_compiler42","enter2","modulePlugin","plugin","isModulePlugin","isFunctionPlugin","exit2","import_babel_utils37","import_compiler43","attribute_tag_default","findParentTag","parentExtra","existingAttr","import_babel_utils38","import_compiler44","kChildScopeBinding","custom_tag_default","getTagTemplate","childProgramExtra","inputExport","assertAttributesOrSingleArg","relativePath","getTagRelativePath","renderBodyProp","childScopeBinding","peekScopeId","renderBodyId","renderTagExpr","renderBodyPath","callStatement","translateHTML2","tagAttrsIdentifier","attrPath","attrExport","attrExportIdentifier","attrReferences","renderBody","renderBodyExportIdentifier","injectWalks","translateDOM2","nameIsString","nodeName","toUpperCase","import_babel_utils39","import_compiler46","import_compiler45","kDOMBinding","dynamic_tag_default","domBinding","assertAttributesOrArgs","tagExpression","compatRuntimeFile","modules","serialized5to6","dynamicScopeIdentifier","toFirstExpressionOrBlock","dynamicTagExpr","isArrayExpression","renderBodyIdentifier","attrsGetter","added","booleanLiteral","tag_default","bound","changeValue","getChangeHandler","splice","hook","analyzer","translator","watchFiles","modifier","tagNameId","tagNameVarPath","functionExpression","isPrivateName","cloneNode","text_default","visitors","Program","AssignmentExpression","UpdateExpression","ReferencedIdentifier","ImportDeclaration","MarkoDocumentType","MarkoDeclaration","MarkoCDATA","MarkoText","MarkoTag","MarkoPlaceholder","MarkoScriptlet","MarkoComment","getVisitorOfType","typename","visitor"],"sourceRoot":""}