{"version":3,"file":"664.d796a0d3.js","mappings":"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","sources":["webpack:///../components/repl/components/file-tabs.marko","webpack:///../components/repl/components/pane.marko","webpack:///../components/repl/components/controllable-select.marko","webpack:///../components/repl/components/playground-link.marko","webpack:///../components/repl/components/match-media.marko","webpack:///../components/repl/components/resizable-panes.marko","webpack:///../components/repl/index.marko","webpack:///./playground/components/hash-value.marko","webpack:///../../browser-shims/v6/translator.js","webpack:///./playground/v6/components/playground-6.marko","webpack:///./playground/v6/index.marko","webpack:///../../browser-shims/compiler/dist/babel-types/index.js","webpack:///../../browser-shims/compiler/index.js","webpack:///../../browser-shims/fs.js","webpack:///../../browser-shims/module.js","webpack:///../../browser-shims/process.js","webpack:///../components/app-layout/components/layout-header/component-browser.js","webpack:///../components/app-layout/components/layout-header/events.js","webpack:///../components/app-layout/components/layout-sidebar/component-browser.js","webpack:///../components/app-layout/components/layout-sidebar/components/version-switcher/component-browser.js","webpack:///../components/app-footer/ebay.svg","webpack:///../components/app-footer/openjsf.svg","webpack:///../components/app-footer/osi.svg","webpack:///../components/app-layout/favicon.png","webpack:///../logos/discord.svg","webpack:///../logos/marko.svg"],"sourcesContent":["<attrs/{ files: externalFiles, selectedIndex: externalSelected }/>\n\n<let/files := externalFiles/>\n<let/selectedIndex := externalSelected/>\n\n<const/selectedFile = files[selectedIndex]/>\n\n<div.file-tabs>\n  <let/nextId = 1/>\n  <for|file, index| of=files>\n    <let/editing = false/>\n    <const/selected = selectedFile === file/>\n    <const/mutable = (index > 0)/>\n    <div.file-tab class={ selected } onClick() { \n      if (selected) {\n        editing = true;\n      } else {\n        editing = false;\n        selectedIndex = index;\n      }\n    }>\n      <if=(!editing || !selected || !mutable)>\n        ${file.name}\n      </if>\n      <else>\n        <let/name = file.name/>\n        <const/finishRename() {\n          const modifiedFile = { ...file, name, path: file.path.replace(file.name, name) };\n          files = [\n            ...files.slice(0, index), \n            modifiedFile,\n            ...files.slice(index+1)\n          ];\n          editing = false;\n        }/>\n        <input/nameInput \n          type=\"text\" \n          size=name.length \n          value:=name \n          onBlur=finishRename\n          onKeydown(e) {\n            if (e.code === \"Enter\") {\n              finishRename();\n            }\n          }/>\n        <lifecycle onMount() { \n          nameInput().focus();\n          nameInput().setSelectionRange(0, name.indexOf(\".\"));\n        }/>\n      </else>\n      <if=mutable>\n        <button.file-close onClick(e) { \n          if (window.confirm(`Delete ${file.path}?`)) {\n            if (selectedIndex >= index) {\n              selectedIndex--;\n            }\n            files = [...files.slice(0, index), ...files.slice(index+1)];\n          }\n          e.stopPropagation();\n        }>\n          &times;\n        </button>\n      </if>\n    </div>\n  </for>\n  <button.new-file onClick() { \n    const newFile = { name:`Component${nextId}.marko`, path:`/components/Component${nextId}.marko`, content:\"\" };\n    const newIndex = files.length;\n    files = files.concat(newFile);\n    selectedIndex = newIndex;\n    nextId++;\n  }>\n    +\n  </button>\n</div>\n<style>\n  .file-tabs {\n    display:flex;\n    overflow-x: auto;\n    width:100%;\n    height:100%;\n  }\n  .file-tab {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: 100%;\n    padding:0 1em;\n    flex-shrink: 0;\n    border-bottom: 2px solid transparent;\n    cursor:pointer;\n  }\n  .file-tab:not(.selected):hover {\n    background: rgba(255,255,255,0.1);\n  }\n  .file-tab.selected {\n    border-bottom: 2px solid #09bcf8;\n  }\n  .file-close {\n    padding:0.5em;\n    background: transparent;\n    margin-right:-0.5em;\n    color:#fff;\n    cursor: pointer;\n    line-height: normal;\n    border: 0;\n  }\n  .file-close:hover {\n    color:#f1195b;\n  }\n  .new-file {\n    padding:0 1em;\n    font-size: 1.5em;\n    background: transparent;\n    color:#999;\n    cursor: pointer;\n    line-height: normal;\n    border: 0;\n  }\n  .new-file:hover {\n    color: #09bcf8;\n  }\n</style>","<attrs/{ actions, body }/>\n\n<div.pane>\n  <div.pane-actions>\n    <${actions.renderBody}/>\n  </div>\n  <div.pane-divider/>\n  <div.pane-body>\n    <${body.renderBody}/>\n  </div>\n</div>\n\n<style>\n  .pane {\n    display:flex;\n    flex-direction: column;\n    flex:1;\n  }\n  .pane-actions {\n    height: 3em;\n  }\n  .pane-divider {\n    height:1px;\n    background: rgba(0,0,0,0.2);\n  }\n  .pane-body {\n    flex:1;\n    flex-basis: 0;\n    overflow: auto;\n  }\n</style>\n","<attrs/{ value, valueChange, renderBody, class:className }/>\n<select/el class=className onChange(e) { valueChange(e.target.value); }>\n  <${renderBody}/>\n</select>\n<effect() {\n  el().value = value;\n  // TODO: this should not be necessary\n  // but re-rendering the parent component causes new closures\n  // to be passed for renderBody and valueChange which causes\n  // this component to re-render.  Morphdom sets the <select>\n  // back to the original value.  So we track those values as well,\n  // so we can re-set the <select>'s value.\n  renderBody; valueChange;\n}/>","import { compressToEncodedURIComponent } from \"lz-string\";\n\n<attrs/{ files, ...attrs }/>\n<a.playground-link ...attrs\n  href=`/playground/#${compressToEncodedURIComponent(JSON.stringify(files))}`\n  target=\"_top\">\n  <span>Open in playground </span>\n</a>\n\n<style>\n  .playground-link {\n    float:right;\n    padding: 0.8em 1em;\n    display:block;\n    position: relative;\n  }\n  .playground-link span {\n    display:none;\n    position:absolute;\n    right: 1em;\n    width: 10em;\n  }\n  .playground-link:hover span {\n    display:inline;\n  }\n</style>\n\n","<attrs/{ default: query, fallback }/>\n<let/isMatch = typeof window !== \"undefined\" ? window.matchMedia(query).matches : fallback/>\n\n<effect() {\n  const mq = window.matchMedia(query);\n  const listener = () => isMatch = !!mq.matches;\n  mq.addEventListener(\"change\", listener);\n  isMatch = !!mq.matches;\n  return () => mq.removeEventListener(\"change\", listener);\n}/>\n\n<return=isMatch/>","<attrs/{ left, right }/>\n\n<let/editorSize=0.5/>\n<let/resizing = false/>\n<match-media/isVertical = \"(max-aspect-ratio: 1/1)\"/>\n\n<div/container class=[\"panes\", resizing && \"resizing\"]>\n  <div ...left style=`flex-grow:${editorSize}`>\n    <${left.renderBody}/>\n  </div>\n  <div.divider>\n    <div.inner\n      onMousedown(e) {\n        resizing = true;\n        e.preventDefault();\n        e.stopPropagation();\n      }/>\n  </div>\n  <div ...right style=`flex-grow:${1-editorSize}`>\n    <${right.renderBody}/>\n  </div>\n</div>\n<if=resizing>\n  <effect() {\n    const handler = (e) => {\n      if (e.buttons || e.which) {\n        const rect = container().getBoundingClientRect();\n        const fraction = isVertical \n          ? (e.clientY - rect.top) / rect.height \n          : (e.clientX - rect.left) / rect.width;\n        if (fraction > 0) {\n          // it seems a drag event with no position is fired when we stop\n          // so we'll ignore that value\n          editorSize = Math.min(0.8, Math.max(0.2, fraction));\n        }\n      } else {\n        resizing = false;\n      }\n    };\n    window.addEventListener(\"mousemove\", handler);\n    return () => window.removeEventListener(\"mousemove\", handler);\n  }/>\n</if>\n\n<style>\n  .panes {\n    display:flex;\n    flex:1;\n    width: 100%;\n  }\n  .panes > div {\n    overflow:hidden;\n    display: flex;\n    flex-basis:0;\n  }\n  .panes.resizing {\n    cursor: col-resize;\n  }\n  .panes.resizing > div:not(.divider) {\n    pointer-events: none;\n  }\n  .divider {\n    min-height: 2px;\n    min-width: 2px;\n    position:relative;\n    background:#eee;\n    cursor: col-resize;\n  }\n  .divider:hover {\n    background:#ccc;\n  }\n  .divider .inner {\n    position: absolute;\n    top:-10px; left: -10px; bottom:-10px; right:-10px;\n    opacity: 0;\n    z-index:1000;\n  }\n  @media (max-aspect-ratio: 1/1) {\n    .panes {\n      flex-direction: column;\n    }\n    .panes.resizing,\n    .divider:hover {\n      cursor: row-resize;\n    }\n  }\n</style>","<attrs/{ getTranslator, files }/>\n<let/selectedIndex = 0/>\n<let/previewType = \"preview\"/>\n<let/debounce = false/>\n<const/selectedFile = files[selectedIndex]/>\n\n<style>\n  .editor-container {\n    background: #202134;\n    color: #fff;\n  }\n</style>\n\n<resizable-panes>\n  <@left class=\"editor-container\">\n    <pane>\n      <@actions>\n        <file-tabs files:=files selectedIndex:=selectedIndex/>\n      </@actions>\n      <@body>\n        <let/activeEditor = null/>\n        <activeEditor\n          value=selectedFile.content \n          filename=selectedFile.path \n          valueChange(content) {\n            const modifiedFile = { ...selectedFile, content };\n            files = [\n              ...files.slice(0, selectedIndex), \n              modifiedFile,\n              ...files.slice(selectedIndex+1)\n            ];\n            debounce = true;\n          }/>\n        <lifecycle onMount = (async () => { \n          const e = await import(\"./components/editor\");\n          await e.loading;\n          activeEditor = e;\n        })/>\n      </@body>\n    </pane>\n  </@left>\n  <@right>\n    <pane>\n      <@actions>\n        <controllable-select.preview-select \n          value=previewType \n          valueChange(value) {\n            previewType = value;\n            debounce = false;\n          }>\n          <option value=\"preview\">App Preview</option>\n          <option value=\"compiled-html\">Compiled (HTML)</option>\n          <option value=\"compiled-vdom\">Compiled (DOM)</option>\n        </controllable-select>\n        <playground-link files=files/>\n        <style>\n          .preview-select {\n            border:0;\n            height:100%;\n            font-size: 100%;\n            padding:0 1em;\n          }\n        </style>\n      </@actions>\n      <@body>\n        <let/preview = null/>\n        <${preview} \n          type=previewType\n          files=files\n          selectedFile=selectedFile\n          getTranslator=getTranslator\n          debounce=debounce/>\n        <lifecycle onMount = (async () => { \n          preview = await import(\"./components/preview\");\n        })/>\n      </@body>\n    </pane>\n  </@right>\n</resizable-panes>","import { compressToEncodedURIComponent, decompressFromEncodedURIComponent } from \"lz-string\";\n\n<attrs/{ default:defaultValue }/>\n<let/value = (\n  (() => { \n    try {\n      if (typeof window !== \"undefined\") {\n        return JSON.parse(decompressFromEncodedURIComponent(window.location.hash.slice(1)));\n      }\n    } catch(e) {\n      console.error(e);\n    }\n  })() \n  || defaultValue\n)/>\n<lifecycle \n  onMount() {\n    window.addEventListener(\"hashchange\", this.handler = () => {\n      try {\n        if (!this.isUpdating) {\n          value = JSON.parse(decompressFromEncodedURIComponent(window.location.hash.slice(1)));\n        } else {\n          this.isUpdating = false;\n        }\n      } catch(e) {\n        console.error(e);\n      }\n    });\n  } \n  onUpdate() {\n    this.isUpdating = true;\n    window.location.hash = compressToEncodedURIComponent(JSON.stringify(value));\n  }\n  onDestroy() {\n    window.removevEventListener(\"hashchange\", this.handler);\n  }/>\n<return:=value/>","var __require = /* @__PURE__ */ ((x) => typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => a[b]\n}) : x)(function(x) {\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\n// src/visitors/program/index.ts\nimport { types as t10 } from \"@marko/compiler\";\n\n// src/util/marko-config.ts\nfunction isOutputHTML() {\n  return getMarkoOpts().output === \"html\";\n}\nfunction isOutputDOM() {\n  return !isOutputHTML();\n}\nfunction getMarkoOpts() {\n  return currentProgramPath.hub.file.markoOpts;\n}\n\n// src/visitors/program/html.ts\nimport { types as t8 } from \"@marko/compiler\";\n\n// src/util/apply-hydrate.ts\nimport { types as t4 } from \"@marko/compiler\";\n\n// src/util/references.ts\nimport { types as t2 } from \"@marko/compiler\";\n\n// src/util/sorted-arr.ts\nfunction insertInArray(compare, arr, val) {\n  const len = arr.length;\n  let max = len;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(arr[mid], val);\n    if (compareResult === 0)\n      return arr;\n    if (compareResult > 0)\n      max = mid;\n    else\n      pos = mid + 1;\n  }\n  let cur = val;\n  while (pos < len) {\n    const next = cur;\n    cur = arr[pos];\n    arr[pos++] = next;\n  }\n  arr[len] = cur;\n  return arr;\n}\nfunction findIndex(compare, arr, val) {\n  let max = arr.length;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(arr[mid], val);\n    if (compareResult === 0)\n      return mid;\n    if (compareResult > 0)\n      max = mid;\n    else\n      pos = mid + 1;\n  }\n  return -1;\n}\nfunction createSortedCollection(compare) {\n  return {\n    insert(data, val, immutable = false) {\n      if (data) {\n        if (Array.isArray(data)) {\n          return insertInArray(compare, immutable ? [...data] : data, val);\n        } else {\n          const compareResult = compare(data, val);\n          if (compareResult !== 0) {\n            return compareResult < 0 ? [data, val] : [val, data];\n          }\n        }\n      }\n      return val;\n    },\n    find(data, val) {\n      if (data) {\n        if (Array.isArray(data)) {\n          return data[findIndex(compare, data, val)];\n        } else {\n          return data === val ? data : void 0;\n        }\n      }\n    }\n  };\n}\n\n// src/util/tag-name-type.ts\nimport { types as t } from \"@marko/compiler\";\nimport { isNativeTag } from \"@marko/babel-utils\";\nvar MARKO_FILE_REG = /^<.*>$|\\.marko$/;\nfunction analyzeTagNameType(tag) {\n  const extra = tag.node.extra ??= {};\n  if (extra.tagNameType === void 0) {\n    const name = tag.get(\"name\");\n    if (name.isStringLiteral()) {\n      extra.tagNameType = name.node.value[0] === \"@\" ? 3 /* AttributeTag */ : isNativeTag(tag) ? 0 /* NativeTag */ : 1 /* CustomTag */;\n      extra.tagNameNullable = extra.tagNameNullable = false;\n    } else {\n      const pending = [name];\n      let path3;\n      let type = void 0;\n      let nullable = false;\n      while ((path3 = pending.pop()) && type !== 2 /* DynamicTag */) {\n        if (path3.isConditionalExpression()) {\n          pending.push(path3.get(\"consequent\"));\n          if (path3.node.alternate) {\n            pending.push(path3.get(\"alternate\"));\n          }\n        } else if (path3.isLogicalExpression()) {\n          if (path3.node.operator === \"||\") {\n            pending.push(path3.get(\"left\"));\n          } else {\n            nullable = true;\n          }\n          pending.push(path3.get(\"right\"));\n        } else if (path3.isAssignmentExpression()) {\n          pending.push(path3.get(\"right\"));\n        } else if (path3.isBinaryExpression()) {\n          type = path3.node.operator !== \"+\" || type !== void 0 && type !== 0 /* NativeTag */ ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n        } else if (path3.isStringLiteral() || path3.isTemplateLiteral()) {\n          type = type !== void 0 && type !== 0 /* NativeTag */ ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n        } else if (path3.isNullLiteral()) {\n          nullable = true;\n        } else if (path3.isIdentifier()) {\n          if (path3.node.name === \"undefined\") {\n            nullable = true;\n            continue;\n          }\n          const binding = path3.scope.getBinding(path3.node.name);\n          if (!binding) {\n            type = 2 /* DynamicTag */;\n            continue;\n          }\n          if (binding.kind === \"module\") {\n            const decl = binding.path.parent;\n            if (MARKO_FILE_REG.test(decl.source.value) && decl.specifiers.some((it) => t.isImportDefaultSpecifier(it))) {\n              type = type !== void 0 && type !== 1 /* CustomTag */ ? 2 /* DynamicTag */ : 1 /* CustomTag */;\n            } else {\n              type = 2 /* DynamicTag */;\n            }\n            continue;\n          }\n          const bindingTag = binding.path;\n          if (bindingTag.isMarkoTag() && binding.kind === \"local\") {\n            const bindingTagName = bindingTag.get(\"name\").node.value;\n            if (bindingTagName === \"tag\") {\n              type = type !== void 0 && type !== 1 /* CustomTag */ ? 2 /* DynamicTag */ : 1 /* CustomTag */;\n              continue;\n            }\n            if (bindingTagName === \"const\") {\n              pending.push(bindingTag.get(\"attributes\")[0].get(\"value\"));\n              continue;\n            }\n            if (bindingTagName === \"let\") {\n              const defaultAttr = bindingTag.get(\"attributes\")[0];\n              if (defaultAttr.node) {\n                pending.push(defaultAttr.get(\"value\"));\n              } else {\n                nullable = true;\n              }\n              const assignments = binding.constantViolations;\n              for (let i = assignments.length; i--; ) {\n                const assignment = assignments[i];\n                const { operator } = assignment.node;\n                if (operator === \"=\") {\n                  pending.push(assignment.get(\"right\"));\n                } else if (operator === \"+=\") {\n                  type = type !== void 0 && type !== 0 /* NativeTag */ ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n                } else {\n                  type = 2 /* DynamicTag */;\n                  break;\n                }\n              }\n            }\n            continue;\n          }\n          type = 2 /* DynamicTag */;\n        } else {\n          type = 2 /* DynamicTag */;\n        }\n      }\n      extra.tagNameType = type;\n      extra.tagNameNullable = nullable;\n      extra.tagNameDynamic = true;\n    }\n  }\n  return extra.tagNameType;\n}\n\n// src/util/sections.ts\nfunction startSection(path3) {\n  const extra = path3.node.extra ??= {};\n  let sectionId = extra.sectionId;\n  if (sectionId === void 0) {\n    const programExtra = path3.hub.file.path.node.extra ??= {};\n    const sectionNameNode = path3.parent?.name;\n    const sectionName = sectionNameNode?.value ?? sectionNameNode?.name ?? \"dynamic\";\n    sectionId = extra.sectionId = programExtra.nextSectionId || 0;\n    programExtra.nextSectionId = sectionId + 1;\n    programExtra.sectionNames = programExtra.sectionNames ?? [];\n    programExtra.sectionNames[sectionId] = currentProgramPath.scope.generateUid(sectionName + \"Body\");\n  }\n  return sectionId;\n}\nfunction getOrCreateSectionId(path3) {\n  let cur = path3;\n  while (true) {\n    if (cur.type === \"Program\" || cur.type === \"MarkoTagBody\" && analyzeTagNameType(cur.parentPath) !== 0 /* NativeTag */) {\n      return startSection(cur);\n    }\n    cur = cur.parentPath;\n  }\n}\nfunction getSectionId(path3) {\n  let sectionId;\n  let currentPath = path3;\n  while ((sectionId = currentPath.node.extra?.sectionId) === void 0) {\n    currentPath = currentPath.parentPath;\n  }\n  return sectionId;\n}\nfunction createSectionState(key, init) {\n  return [\n    (sectionId) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= [];\n      const sectionData = arrayOfSectionData[sectionId] ??= init && init(sectionId);\n      return sectionData;\n    },\n    (sectionId, value) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= [];\n      arrayOfSectionData[sectionId] = value;\n    }\n  ];\n}\nfunction forEachSectionId(fn) {\n  const { nextSectionId } = currentProgramPath.node.extra;\n  for (let sectionId = 0; sectionId < nextSectionId; sectionId++) {\n    fn(sectionId);\n  }\n}\nfunction forEachSectionIdReverse(fn) {\n  const { nextSectionId } = currentProgramPath.node.extra;\n  for (let sectionId = nextSectionId; sectionId--; ) {\n    fn(sectionId);\n  }\n}\n\n// src/util/reserve.ts\nvar [getReservesByType] = createSectionState(\"reservesByType\", () => [void 0, void 0, void 0]);\nfunction reserveScope(type, sectionId, node, name, size = 0) {\n  const extra = node.extra ??= {};\n  if (extra.reserve) {\n    const reserve2 = extra.reserve;\n    if (size && reserve2.size) {\n      throw new Error(\"Unable to reserve multiple scopes for a node\");\n    } else {\n      reserve2.size = size;\n      reserve2.name += \"_\" + name;\n    }\n    return reserve2;\n  }\n  const reservesByType = getReservesByType(sectionId);\n  const reserve = extra.reserve = {\n    id: 0,\n    type,\n    size,\n    name,\n    sectionId\n  };\n  if (reservesByType[type]) {\n    reserve.id = reservesByType[type].push(reserve) - 1;\n  } else {\n    reservesByType[type] = [reserve];\n  }\n  return reserve;\n}\nfunction assignFinalIds() {\n  forEachSectionId((sectionId) => {\n    let curIndex = 0;\n    for (const reserves of getReservesByType(sectionId)) {\n      if (reserves) {\n        for (const reserve of reserves) {\n          reserve.id = curIndex;\n          curIndex += reserve.size + 1;\n        }\n      }\n    }\n  });\n}\nfunction compareReserves(a, b) {\n  return a.sectionId - b.sectionId || a.type - b.type || a.id - b.id;\n}\nvar { insert: insertReserve } = createSortedCollection(compareReserves);\n\n// src/util/references.ts\nvar [getReferenceGroups] = createSectionState(\"apply\", () => [\n  {\n    sectionId: 0,\n    index: 0,\n    count: 0,\n    references: void 0,\n    apply: t2.identifier(\"\"),\n    hydrate: t2.identifier(\"\")\n  }\n]);\nfunction trackReferences(tag) {\n  if (tag.has(\"var\")) {\n    trackReferencesForBindings(getOrCreateSectionId(tag), tag.get(\"var\"));\n  }\n  const body = tag.get(\"body\");\n  if (body.get(\"body\").length && body.get(\"params\").length) {\n    trackReferencesForBindings(getOrCreateSectionId(body), body);\n  }\n}\nfunction trackReferencesForBindings(sectionId, path3, reserveType = 1 /* Store */) {\n  const scope = path3.scope;\n  const bindings = path3.getBindingIdentifiers();\n  for (const name in bindings) {\n    const references = scope.getBinding(name).referencePaths;\n    const identifier = bindings[name];\n    const binding = reserveScope(reserveType, sectionId, identifier, name);\n    insertReferenceGroup(getReferenceGroups(sectionId), {\n      sectionId,\n      index: 0,\n      count: 0,\n      references: binding,\n      apply: t2.identifier(\"\"),\n      hydrate: t2.identifier(\"\")\n    });\n    for (const reference of references) {\n      const fnRoot = getFnRoot(reference.scope.path);\n      const exprRoot = getExprRoot(fnRoot || reference);\n      const markoRoot = exprRoot.parentPath;\n      if (fnRoot) {\n        const name2 = fnRoot.node.id?.name;\n        if (!name2) {\n          if (markoRoot.isMarkoAttribute() && !markoRoot.node.default) {\n            (fnRoot.node.extra ??= {}).name = markoRoot.node.name;\n          }\n        }\n        updateReferenceGroup(fnRoot, \"references\", binding);\n      }\n      updateReferenceGroup(markoRoot, `${exprRoot.listKey || exprRoot.key}References`, binding);\n    }\n  }\n}\nfunction updateReferenceGroup(path3, extraKey, newBinding) {\n  const sectionId = getOrCreateSectionId(path3);\n  const currentGroup = (path3.node.extra ??= {})[extraKey];\n  const newReferences = insertReserve(currentGroup?.references, newBinding, true);\n  if (currentGroup) {\n    currentGroup.count--;\n  }\n  getOrCreateReferenceGroup(sectionId, newBinding);\n  path3.node.extra[extraKey] = getOrCreateReferenceGroup(sectionId, newReferences);\n}\nfunction mergeReferenceGroups(sectionId, groupEntries) {\n  let newReferences;\n  for (const [extra, key] of groupEntries) {\n    const group = extra[key];\n    const references = group.references;\n    delete extra[key];\n    group.count--;\n    sectionId = group.sectionId;\n    if (references) {\n      if (Array.isArray(references)) {\n        for (const binding of references) {\n          newReferences = insertReserve(newReferences, binding);\n        }\n      } else {\n        newReferences = insertReserve(newReferences, references);\n      }\n    }\n  }\n  return getOrCreateReferenceGroup(sectionId, newReferences);\n}\nfunction getOrCreateReferenceGroup(sectionId, references) {\n  const newGroup = {\n    sectionId,\n    index: 0,\n    count: 1,\n    references,\n    apply: t2.identifier(\"\"),\n    hydrate: t2.identifier(\"\")\n  };\n  const referenceGroups = getReferenceGroups(sectionId);\n  const existingGroup = findReferenceGroup(referenceGroups, newGroup);\n  if (existingGroup) {\n    existingGroup.count++;\n  } else {\n    insertReferenceGroup(referenceGroups, newGroup);\n  }\n  return existingGroup ?? newGroup;\n}\nfunction getExprRoot(path3) {\n  let curPath = path3;\n  while (!isMarkoPath(curPath.parentPath)) {\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction getFnRoot(path3) {\n  let curPath = path3;\n  if (curPath.isProgram())\n    return;\n  while (!isFunctionExpression(curPath)) {\n    if (isMarkoPath(curPath))\n      return;\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction isMarkoPath(path3) {\n  switch (path3.type) {\n    case \"MarkoTag\":\n    case \"MarkoTagBody\":\n    case \"MarkoAttribute\":\n    case \"MarkoSpreadAttribute\":\n    case \"MarkoPlaceholder\":\n    case \"MarkoScriptlet\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isFunctionExpression(path3) {\n  switch (path3.type) {\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\nvar { insert: insertReferenceGroup, find: findReferenceGroup } = createSortedCollection(function compareReferenceGroups({ references: a }, { references: b }) {\n  if (a) {\n    if (b) {\n      if (Array.isArray(a)) {\n        if (Array.isArray(b)) {\n          const len = a.length;\n          const lenDelta = len - b.length;\n          if (lenDelta !== 0) {\n            return lenDelta;\n          }\n          for (let i = 0; i < len; i++) {\n            const compareResult = compareReserves(a[i], b[i]);\n            if (compareResult !== 0) {\n              return compareResult;\n            }\n          }\n          return 0;\n        } else {\n          return 1;\n        }\n      } else if (Array.isArray(b)) {\n        return -1;\n      } else {\n        return compareReserves(a, b);\n      }\n    } else {\n      return 1;\n    }\n  } else {\n    return b ? -1 : 0;\n  }\n});\nfunction finalizeReferences() {\n  const allReferenceGroups = [];\n  forEachSectionId((sectionId) => {\n    const referenceGroups = getReferenceGroups(sectionId).filter((g) => g.count > 0 || !Array.isArray(g.references));\n    referenceGroups.forEach((g, i) => {\n      g.index = i;\n      g.apply.name = generateReferenceGroupName(\"apply\", sectionId, g.references);\n      g.hydrate.name = generateReferenceGroupName(\"hydrate\", sectionId, g.references);\n    });\n    allReferenceGroups[sectionId] = referenceGroups;\n  });\n  (currentProgramPath.node.extra ??= {}).referenceGroups = allReferenceGroups;\n}\nfunction getReferenceGroup(sectionId, lookup, analyze2 = false) {\n  const referenceGroups = analyze2 ? getReferenceGroups(sectionId) : currentProgramPath.node.extra.referenceGroups[sectionId];\n  let found;\n  if (typeof lookup === \"number\") {\n    found = referenceGroups[lookup];\n  } else {\n    found = findReferenceGroup(referenceGroups, {\n      references: lookup\n    });\n  }\n  if (!found) {\n    throw new Error(`Reference group not found for section ${sectionId}: ${lookup}`);\n  }\n  return found;\n}\nfunction generateReferenceGroupName(type, sectionId, references) {\n  let name = type + (sectionId ? currentProgramPath.node.extra.sectionNames[sectionId].replace(\"_\", \"$\") : \"\");\n  if (references) {\n    if (Array.isArray(references)) {\n      name += \"With\";\n      for (const ref of references) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name += `_${references.name}`;\n    }\n  }\n  return currentProgramPath.scope.generateUid(name);\n}\n\n// src/util/runtime.ts\nimport { types as t3 } from \"@marko/compiler\";\nimport { importNamed } from \"@marko/babel-utils\";\nfunction importRuntime(name) {\n  const { output } = getMarkoOpts();\n  return importNamed(currentProgramPath.hub.file, getRuntimePath(output), name);\n}\nfunction callRuntime(name, ...args) {\n  return t3.callExpression(importRuntime(name), args.filter(Boolean));\n}\nfunction getHTMLRuntime() {\n  return getRuntime(\"html\");\n}\nfunction getRuntime(output) {\n  return __require(getRuntimePath(output));\n}\nfunction getRuntimePath(output) {\n  const { optimize } = getMarkoOpts();\n  return `@marko/runtime-fluurt/${false ? \"src\" : optimize ? \"dist\" : \"dist/debug\"}/${output === \"html\" ? \"html\" : \"dom\"}`;\n}\nfunction callRead(reference, targetSectionId) {\n  return t3.memberExpression(getScopeExpression(reference, targetSectionId), t3.numericLiteral(reference.id), true);\n}\nfunction callQueue({ apply, index }, reference, value, targetSectionId) {\n  return callRuntime(\"queue\", getScopeExpression(reference, targetSectionId), apply, t3.numericLiteral(index - 1), value);\n}\nfunction getScopeExpression(reference, sectionId) {\n  const diff = reference.sectionId !== sectionId ? 1 : 0;\n  let scope = scopeIdentifier;\n  for (let i = 0; i < diff; i++) {\n    scope = t3.memberExpression(scope, t3.identifier(\"_\"));\n  }\n  return scope;\n}\n\n// src/util/apply-hydrate.ts\nimport { getTemplateId } from \"@marko/babel-utils\";\nvar [getApplyStatements] = createSectionState(\"applyStatements\", () => []);\nvar [getHydrateStatements] = createSectionState(\"hydrateStatements\", () => []);\nvar [getQueueBuilder, _setQueueBuilder] = createSectionState(\"queue\");\nfunction setQueueBuilder(tag, builder) {\n  _setQueueBuilder(getSectionId(tag.get(\"body\")), builder);\n}\nfunction addStatement(type, targetSectionId, references, statement) {\n  const statementsIndex = references?.index ?? 0;\n  const allStatements = type === \"apply\" ? getApplyStatements(targetSectionId) : getHydrateStatements(targetSectionId);\n  const statements = allStatements[statementsIndex] ??= [];\n  if (Array.isArray(statement)) {\n    statements.push(...statement);\n  } else {\n    statements.push(statement);\n  }\n}\nfunction getHydrateRegisterId(sectionId, references) {\n  const {\n    markoOpts: { optimize },\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let name = \"\";\n  if (references) {\n    if (Array.isArray(references)) {\n      for (const ref of references) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name += `_${references.name}`;\n    }\n  }\n  return getTemplateId(optimize, `${filename}_${sectionId}${name}`);\n}\nfunction writeAllStatementGroups() {\n  forEachSectionIdReverse((sectionId) => {\n    writeHydrateGroups(sectionId);\n    writeApplyGroups(sectionId);\n  });\n}\nvar [getClosurePriorities] = createSectionState(\"closurePriorities\", () => []);\nfunction writeApplyGroups(sectionId) {\n  const allStatements = getApplyStatements(sectionId);\n  const numReferenceGroups = currentProgramPath.node.extra.referenceGroups[sectionId].length;\n  if (!numReferenceGroups)\n    return;\n  for (let i = numReferenceGroups; i--; ) {\n    const statements = allStatements[i] ?? [];\n    if (i === 0 && !statements.length)\n      continue;\n    const referenceGroup = getReferenceGroup(sectionId, i);\n    const { references, apply: identifier } = referenceGroup;\n    const queuePriority = t4.numericLiteral(i - 1);\n    let params;\n    let body;\n    if (references) {\n      if (Array.isArray(references)) {\n        params = references.map((binding) => t4.assignmentPattern(t4.identifier(binding.name), callRead(binding, sectionId)));\n        body = t4.blockStatement(statements);\n        for (const binding of references) {\n          addStatement(\"apply\", sectionId, getReferenceGroup(sectionId, binding), t4.expressionStatement(callRuntime(\"queue\", scopeIdentifier, identifier, queuePriority)));\n        }\n      } else if (references.sectionId !== sectionId) {\n        params = [\n          t4.assignmentPattern(t4.identifier(references.name), callRead(references, sectionId))\n        ];\n        body = t4.blockStatement(statements);\n        const factory = getQueueBuilder(sectionId);\n        if (factory) {\n          const closurePriority = t4.numericLiteral(NaN);\n          getClosurePriorities(references.sectionId).push(closurePriority);\n          addStatement(\"apply\", references.sectionId, getReferenceGroup(references.sectionId, references), t4.expressionStatement(factory(referenceGroup, closurePriority)));\n          addStatement(\"apply\", sectionId, void 0, t4.expressionStatement(callRuntime(\"queue\", scopeIdentifier, identifier, queuePriority)));\n        }\n      } else {\n        const param = t4.identifier(references.name);\n        params = [param];\n        body = t4.blockStatement([\n          t4.ifStatement(callRuntime(\"write\", scopeIdentifier, t4.numericLiteral(references.id), param), t4.blockStatement(statements))\n        ]);\n      }\n    } else {\n      params = [];\n      body = t4.blockStatement(statements);\n    }\n    const [fnPath] = currentProgramPath.pushContainer(\"body\", t4.functionDeclaration(identifier, [scopeIdentifier, ...params], body));\n    fnPath.traverse(bindFunctionsVisitor, { root: fnPath, sectionId });\n  }\n  const closurePriorities = getClosurePriorities(sectionId);\n  for (let i = 0; i < closurePriorities.length; i++) {\n    closurePriorities[i].value = i + allStatements.length;\n  }\n}\nfunction writeHydrateGroups(sectionId) {\n  const allStatements = getHydrateStatements(sectionId);\n  for (let i = allStatements.length; i--; ) {\n    const statements = allStatements[i];\n    if (!statements?.length)\n      continue;\n    const referenceGroup = getReferenceGroup(sectionId, i);\n    const { references, hydrate: identifier } = referenceGroup;\n    const params = references ? (Array.isArray(references) ? references : [references]).map((binding) => t4.assignmentPattern(t4.identifier(binding.name), callRead(binding, sectionId))) : [];\n    const [fnPath] = currentProgramPath.pushContainer(\"body\", [\n      t4.functionDeclaration(identifier, [scopeIdentifier, ...params], t4.blockStatement(statements)),\n      t4.expressionStatement(callRuntime(\"register\", t4.stringLiteral(getHydrateRegisterId(sectionId, references)), identifier))\n    ]);\n    fnPath.traverse(bindFunctionsVisitor, { root: fnPath, sectionId });\n    addStatement(\"apply\", sectionId, getReferenceGroup(sectionId, references), t4.expressionStatement(callRuntime(\"queueHydrate\", scopeIdentifier, identifier)));\n  }\n}\nfunction addHTMLHydrateCall(sectionId, references) {\n  addStatement(\"hydrate\", sectionId, references, void 0);\n}\nfunction writeHTMLHydrateStatements(path3) {\n  const sectionId = getOrCreateSectionId(path3);\n  const allStatements = getHydrateStatements(sectionId);\n  path3.unshiftContainer(\"body\", t4.variableDeclaration(\"const\", [\n    t4.variableDeclarator(scopeIdentifier, callRuntime(\"nextScopeId\"))\n  ]));\n  if (!allStatements.length)\n    return;\n  const refs = [];\n  for (let i = allStatements.length; i--; ) {\n    if (allStatements[i]?.length) {\n      const { references } = getReferenceGroup(sectionId, i);\n      if (references) {\n        if (Array.isArray(references)) {\n          for (const ref of references) {\n            insertReserve(refs, ref);\n          }\n        } else {\n          insertReserve(refs, references);\n        }\n      }\n      path3.pushContainer(\"body\", t4.expressionStatement(callRuntime(\"writeHydrateCall\", scopeIdentifier, t4.stringLiteral(getHydrateRegisterId(sectionId, references)))));\n    }\n  }\n  path3.pushContainer(\"body\", t4.expressionStatement(callRuntime(\"writeHydrateScope\", scopeIdentifier, t4.objectExpression(refs.reduce((acc, ref) => {\n    acc.push(t4.objectProperty(t4.numericLiteral(ref.id), t4.identifier(ref.name)));\n    return acc;\n  }, [])))));\n}\nvar bindFunctionsVisitor = {\n  FunctionExpression: { exit: bindFunction },\n  ArrowFunctionExpression: { exit: bindFunction }\n};\nfunction bindFunction(fn, { root, sectionId }) {\n  const { node } = fn;\n  const { extra } = node;\n  const references = extra?.references?.references;\n  const program = fn.hub.file.path;\n  const functionIdentifier = program.scope.generateUidIdentifier(extra?.name);\n  if (references) {\n    if (node.body.type !== \"BlockStatement\") {\n      node.body = t4.blockStatement([t4.returnStatement(node.body)]);\n    }\n    node.body.body.unshift(t4.variableDeclaration(\"const\", (Array.isArray(references) ? references : [references]).map((binding) => t4.variableDeclarator(t4.identifier(binding.name), callRead(binding, sectionId)))));\n  }\n  root.insertBefore(t4.variableDeclaration(\"const\", [\n    t4.variableDeclarator(functionIdentifier, node)\n  ]));\n  node.params.unshift(scopeIdentifier);\n  fn.replaceWith(callRuntime(\"bind\", scopeIdentifier, functionIdentifier));\n}\nfunction getDefaultApply(sectionId) {\n  const [firstApplyStatements] = getApplyStatements(sectionId);\n  return firstApplyStatements ? getReferenceGroup(sectionId, 0).apply : t4.nullLiteral();\n}\n\n// src/util/writer.ts\nimport { types as t7 } from \"@marko/compiler\";\n\n// src/util/to-template-string-or-literal.ts\nimport { types as t5 } from \"@marko/compiler\";\nfunction toTemplateOrStringLiteral(parts) {\n  const strs = [];\n  const exprs = [];\n  let curStr = parts[0];\n  for (let i = 1; i < parts.length; i++) {\n    let content = parts[i];\n    if (typeof content === \"object\") {\n      if (t5.isStringLiteral(content)) {\n        content = content.value;\n      } else if (t5.isTemplateLiteral(content)) {\n        let nextIndex = i + 1;\n        const exprLen = content.expressions.length;\n        shiftItems(parts, nextIndex, content.quasis.length + exprLen);\n        for (let j = 0; j < exprLen; j++) {\n          parts[nextIndex++] = content.quasis[j].value.raw;\n          parts[nextIndex++] = content.expressions[j];\n        }\n        parts[nextIndex] = content.quasis[exprLen].value.raw;\n        continue;\n      } else {\n        exprs.push(content);\n        strs.push(curStr);\n        curStr = \"\";\n        continue;\n      }\n    }\n    curStr += content;\n  }\n  if (exprs.length) {\n    strs.push(curStr);\n    return t5.templateLiteral(strs.map((raw) => t5.templateElement({ raw })), exprs);\n  } else if (curStr) {\n    return t5.stringLiteral(curStr);\n  }\n}\nfunction appendLiteral(arr, str) {\n  arr[arr.length - 1] += str;\n}\nfunction shiftItems(list, start, offset) {\n  for (let i = list.length - 1; i >= start; i--) {\n    list[i + offset] = list[i];\n  }\n}\n\n// src/util/walks.ts\nimport { types as t6 } from \"@marko/compiler\";\nvar [getWalks] = createSectionState(\"walks\", () => [\"\"]);\nvar [getWalkComment] = createSectionState(\"walkComment\", () => []);\nvar [getSteps] = createSectionState(\"steps\", () => []);\nvar walkCodeToName = {\n  [32 /* Get */]: \"get\",\n  [33 /* Before */]: \"before\",\n  [35 /* After */]: \"after\",\n  [36 /* Inside */]: \"inside\",\n  [37 /* Replace */]: \"replace\",\n  [38 /* EndChild */]: \"endChild\",\n  [40 /* Skip */]: \"skip\",\n  [47 /* BeginChild */]: \"beginChild\",\n  [67 /* Next */]: \"next\",\n  [97 /* Over */]: \"over\",\n  [107 /* Out */]: \"out\",\n  [117 /* Multiplier */]: \"multiplier\",\n  [46 /* SkipEnd */]: \"skipEnd\",\n  [66 /* BeginChildEnd */]: \"beginChildEnd\",\n  [91 /* NextEnd */]: \"nextEnd\",\n  [106 /* OverEnd */]: \"overEnd\",\n  [116 /* OutEnd */]: \"outEnd\",\n  [126 /* MultiplierEnd */]: \"multiplierEnd\"\n};\nfunction enter(path3) {\n  getSteps(getSectionId(path3)).push(0 /* enter */);\n}\nfunction exit(path3) {\n  getSteps(getSectionId(path3)).push(1 /* exit */);\n}\nfunction enterShallow(path3) {\n  getSteps(getSectionId(path3)).push(0 /* enter */, 1 /* exit */);\n}\nfunction injectWalks(path3, childIndex, expr) {\n  const walks = getWalks(getSectionId(path3));\n  const walkComment = getWalkComment(getSectionId(path3));\n  walkComment.push(`${walkCodeToName[47 /* BeginChild */]}(${childIndex})`, expr.name, walkCodeToName[38 /* EndChild */]);\n  appendLiteral(walks, nCodeString(47 /* BeginChild */, childIndex));\n  walks.push(expr, String.fromCharCode(38 /* EndChild */));\n}\nfunction visit(path3, code) {\n  const { reserve } = path3.node.extra;\n  if (code && (!reserve || reserve.type !== 0 /* Visit */)) {\n    throw path3.buildCodeFrameError(\"Tried to visit a node that was not marked as needing to visit during analyze.\");\n  }\n  const sectionId = getSectionId(path3);\n  const steps = getSteps(sectionId);\n  const walks = getWalks(sectionId);\n  const walkComment = getWalkComment(sectionId);\n  if (code && isOutputHTML()) {\n    writeTo(path3)`${callRuntime(\"markHydrateNode\", scopeIdentifier, t6.numericLiteral(reserve.id))}`;\n  } else {\n    let walkString = \"\";\n    if (steps.length) {\n      const walks2 = [];\n      let depth = 0;\n      for (const step of steps) {\n        if (step === 0 /* enter */) {\n          depth++;\n          walks2.push(67 /* Next */);\n        } else {\n          depth--;\n          if (depth >= 0) {\n            walks2.length = walks2.lastIndexOf(67 /* Next */);\n            walks2.push(97 /* Over */);\n          } else {\n            walks2.length = walks2.lastIndexOf(107 /* Out */) + 1;\n            walks2.push(107 /* Out */);\n            depth = 0;\n          }\n        }\n      }\n      let current = walks2[0];\n      let count = 0;\n      for (const walk of walks2) {\n        if (walk !== current) {\n          walkComment.push(`${walkCodeToName[current]}(${count})`);\n          walkString += nCodeString(current, count);\n          current = walk;\n          count = 1;\n        } else {\n          count++;\n        }\n      }\n      walkComment.push(`${walkCodeToName[current]}(${count})`);\n      walkString += nCodeString(current, count);\n      steps.length = 0;\n    }\n    if (code !== void 0) {\n      if (code !== 32 /* Get */) {\n        writeTo(path3)`<!>`;\n      }\n      walkComment.push(`${walkCodeToName[code]}`);\n      walkString += String.fromCharCode(code);\n    }\n    if (reserve?.size) {\n      walkComment.push(`${walkCodeToName[40 /* Skip */]}(${reserve.size})`);\n      walkString += nCodeString(40 /* Skip */, reserve.size);\n    }\n    appendLiteral(walks, walkString);\n  }\n}\nfunction nCodeString(code, number) {\n  switch (code) {\n    case 67 /* Next */:\n      return toCharString(number, code, 20 /* Next */);\n    case 97 /* Over */:\n      return toCharString(number, code, 10 /* Over */);\n    case 107 /* Out */:\n      return toCharString(number, code, 10 /* Out */);\n    case 47 /* BeginChild */:\n      return toCharString(number, code, 20 /* BeginChild */);\n    case 40 /* Skip */:\n      return toCharString(number, code, 7 /* Skip */);\n    default:\n      throw new Error(`Unexpected walk code: ${code}`);\n  }\n}\nfunction toCharString(number, startCode, rangeSize) {\n  let result = \"\";\n  if (number >= rangeSize) {\n    const multiplier = Math.floor(number / rangeSize);\n    result += toCharString(multiplier, 117 /* Multiplier */, 10 /* Multiplier */);\n    number -= multiplier * rangeSize;\n  }\n  result += String.fromCharCode(startCode + number);\n  return result;\n}\nfunction getWalkString(sectionId) {\n  const walkLiteral = toTemplateOrStringLiteral(getWalks(sectionId)) || t6.stringLiteral(\"\");\n  if (walkLiteral.value !== \"\") {\n    walkLiteral.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: \" \" + getWalkComment(sectionId).join(\", \") + \" \"\n      }\n    ];\n  }\n  return walkLiteral;\n}\n\n// src/util/writer.ts\nvar [getRenderer] = createSectionState(\"renderer\", (sectionId) => {\n  const name = currentProgramPath.node.extra.sectionNames[sectionId];\n  return t7.identifier(name);\n});\nvar [getWrites] = createSectionState(\"writes\", () => [\"\"]);\nfunction writeTo(path3) {\n  const sectionId = getSectionId(path3);\n  return (strs, ...exprs) => {\n    const exprsLen = exprs.length;\n    const writes = getWrites(sectionId);\n    appendLiteral(writes, strs[0]);\n    for (let i = 0; i < exprsLen; i++) {\n      writes.push(exprs[i], strs[i + 1]);\n    }\n  };\n}\nfunction consumeHTML(path3) {\n  const writes = getWrites(getSectionId(path3));\n  const result = toTemplateOrStringLiteral(writes);\n  writes.length = 0;\n  writes[0] = \"\";\n  if (result) {\n    return t7.expressionStatement(callRuntime(\"write\", result));\n  }\n}\nfunction hasPendingHTML(path3) {\n  const writes = getWrites(getSectionId(path3));\n  return Boolean(writes.length > 1 || writes[0]);\n}\nfunction flushBefore(path3) {\n  const expr = consumeHTML(path3);\n  if (expr) {\n    path3.insertBefore(expr)[0].skip();\n  }\n}\nfunction flushInto(path3) {\n  const target = path3.isProgram() ? path3 : path3.get(\"body\");\n  const expr = consumeHTML(target);\n  if (expr) {\n    target.pushContainer(\"body\", expr)[0].skip();\n  }\n}\nfunction getSectionMeta(sectionId) {\n  const writes = getWrites(sectionId);\n  return {\n    apply: getDefaultApply(sectionId),\n    walks: getWalkString(sectionId),\n    writes: toTemplateOrStringLiteral(writes) || t7.stringLiteral(\"\")\n  };\n}\n\n// src/util/is-static.ts\nfunction isStatic(path3) {\n  return path3.isImportDeclaration() || path3.isExportDeclaration() || path3.isMarkoScriptlet({ static: true });\n}\n\n// src/visitors/program/html.ts\nvar html_default = {\n  translate: {\n    exit(program) {\n      flushInto(program);\n      writeHTMLHydrateStatements(program);\n      const renderContent = [];\n      for (const child of program.get(\"body\")) {\n        if (!isStatic(child)) {\n          renderContent.push(child.node);\n          child.remove();\n        } else if (child.isMarkoScriptlet()) {\n          child.replaceWithMultiple(child.node.body);\n        }\n      }\n      const rendererId = program.scope.generateUidIdentifier(\"renderer\");\n      const { attrs } = program.node.extra;\n      program.pushContainer(\"body\", [\n        t8.variableDeclaration(\"const\", [\n          t8.variableDeclarator(rendererId, t8.arrowFunctionExpression([attrs ? attrs.var : t8.identifier(\"input\")], t8.blockStatement(renderContent)))\n        ]),\n        t8.exportDefaultDeclaration(rendererId),\n        t8.exportNamedDeclaration(t8.variableDeclaration(\"const\", [\n          t8.variableDeclarator(t8.identifier(\"render\"), callRuntime(\"createRenderer\", rendererId))\n        ]))\n      ]);\n    }\n  }\n};\n\n// src/visitors/program/dom.ts\nimport { types as t9 } from \"@marko/compiler\";\nvar dom_default = {\n  translate: {\n    exit(program) {\n      visit(program);\n      const sectionId = getSectionId(program);\n      const templateIdentifier = t9.identifier(\"template\");\n      const walksIdentifier = t9.identifier(\"walks\");\n      const applyIdentifier = t9.identifier(\"apply\");\n      const applyAttrsIdentifier = t9.identifier(\"applyAttrs\");\n      const { attrs } = program.node.extra;\n      const { walks, writes, apply } = getSectionMeta(sectionId);\n      writeAllStatementGroups();\n      const childRendererDeclarators = [];\n      forEachSectionId((childSectionId) => {\n        if (childSectionId !== sectionId) {\n          const { walks: walks2, writes: writes2, apply: apply2 } = getSectionMeta(childSectionId);\n          const identifier = getRenderer(childSectionId);\n          childRendererDeclarators.push(t9.variableDeclarator(identifier, callRuntime(\"createRenderer\", writes2, walks2, apply2)));\n        }\n      });\n      if (attrs) {\n        const exportSpecifiers = [];\n        program.node.body.push(t9.exportNamedDeclaration(t9.variableDeclaration(\"const\", [\n          t9.variableDeclarator(applyAttrsIdentifier, t9.functionExpression(null, [scopeIdentifier, attrs.var], t9.blockStatement(Object.keys(attrs.bindings).map((name) => {\n            const bindingIdentifier = attrs.bindings[name];\n            const { apply: applyIdentifier2 } = getReferenceGroup(sectionId, bindingIdentifier.extra.reserve);\n            exportSpecifiers.push(t9.exportSpecifier(applyIdentifier2, bindingIdentifier.extra.reserve.exportIdentifier));\n            return t9.expressionStatement(t9.callExpression(applyIdentifier2, [\n              scopeIdentifier,\n              bindingIdentifier\n            ]));\n          }))))\n        ])), t9.exportNamedDeclaration(null, exportSpecifiers));\n      }\n      program.node.body.push(t9.exportNamedDeclaration(t9.variableDeclaration(\"const\", [\n        t9.variableDeclarator(templateIdentifier, writes || t9.stringLiteral(\"\"))\n      ])), t9.exportNamedDeclaration(t9.variableDeclaration(\"const\", [\n        t9.variableDeclarator(walksIdentifier, walks || t9.stringLiteral(\"\"))\n      ])), t9.exportNamedDeclaration(t9.variableDeclaration(\"const\", [\n        t9.variableDeclarator(applyIdentifier, t9.isNullLiteral(apply) ? t9.functionExpression(null, [], t9.blockStatement([])) : apply)\n      ])));\n      if (childRendererDeclarators.length) {\n        program.node.body.push(t9.variableDeclaration(\"const\", childRendererDeclarators));\n      }\n      program.node.body.push(t9.exportDefaultDeclaration(callRuntime(\"createRenderFn\", templateIdentifier, walksIdentifier, applyIdentifier, attrs && applyAttrsIdentifier)));\n    }\n  }\n};\n\n// src/visitors/program/index.ts\nvar currentProgramPath;\nvar scopeIdentifier;\nvar previousProgramPath = /* @__PURE__ */ new WeakMap();\nvar program_default = {\n  migrate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n    },\n    exit() {\n      currentProgramPath.scope.crawl();\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  analyze: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      startSection(program);\n    },\n    exit() {\n      assignFinalIds();\n      finalizeReferences();\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  translate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      scopeIdentifier = program.scope.generateUidIdentifier(\"scope\");\n      if (getMarkoOpts().output === \"hydrate\") {\n        program.skip();\n        program.node.body = [\n          t10.importDeclaration([], t10.stringLiteral(program.hub.file.opts.filename))\n        ];\n        if (program.node.extra.hasInteractiveChild || program.node.extra.isInteractive) {\n          program.node.body.push(t10.expressionStatement(callRuntime(\"init\")));\n        }\n        return;\n      }\n    },\n    exit(program) {\n      if (isOutputHTML()) {\n        html_default.translate.exit(program);\n      } else {\n        dom_default.translate.exit(program);\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  }\n};\n\n// src/visitors/import-declaration.ts\nimport { resolveTagImport } from \"@marko/babel-utils\";\nvar import_declaration_default = {\n  translate: {\n    exit(path3) {\n      const source = path3.get(\"source\");\n      const request = source.node.value;\n      source.node.value = resolveTagImport(source, request) || request;\n    }\n  }\n};\n\n// src/visitors/document-type.ts\nvar document_type_default = {\n  translate(documentType) {\n    if (isOutputHTML()) {\n      writeTo(documentType)`<!${documentType.node.value}>`;\n    }\n    documentType.remove();\n  }\n};\n\n// src/visitors/declaration.ts\nvar declaration_default = {\n  translate(declaration) {\n    if (isOutputHTML()) {\n      writeTo(declaration)`<?${declaration.node.value}?>`;\n    }\n    declaration.remove();\n  }\n};\n\n// src/visitors/cdata.ts\nvar cdata_default = {\n  translate(cdata) {\n    if (isOutputHTML()) {\n      writeTo(cdata)`<![CDATA[${cdata.node.value}]]>`;\n    }\n    cdata.remove();\n  }\n};\n\n// src/visitors/text.ts\nvar text_default = {\n  translate(text) {\n    writeTo(text)`${text.node.value}`;\n    enterShallow(text);\n    text.remove();\n  }\n};\n\n// src/visitors/tag/index.ts\nimport { types as t20 } from \"@marko/compiler\";\nimport {\n  assertNoArgs,\n  getTagDef as getTagDef3,\n  isNativeTag as isNativeTag2\n} from \"@marko/babel-utils\";\n\n// src/util/plugin-hooks.ts\nimport { types as t11 } from \"@marko/compiler\";\nfunction enter2(modulePlugin, path3) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path3;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (isFunctionPlugin(plugin)) {\n    plugin(path3, t11);\n  } else if (plugin.enter) {\n    plugin.enter(path3, t11);\n  }\n  return node !== path3.node;\n}\nfunction exit2(modulePlugin, path3) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path3;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (!isFunctionPlugin(plugin) && plugin.exit) {\n    plugin.exit(path3, t11);\n  }\n  return node !== path3.node;\n}\nfunction isModulePlugin(plugin) {\n  return Boolean(plugin.default);\n}\nfunction isFunctionPlugin(plugin) {\n  return typeof plugin === \"function\";\n}\n\n// src/visitors/tag/native-tag.ts\nimport { types as t15 } from \"@marko/compiler\";\nimport { getTagDef } from \"@marko/babel-utils\";\n\n// src/util/attrs-to-object.ts\nimport { types as t13 } from \"@marko/compiler\";\n\n// src/util/to-property-name.ts\nimport { types as t12 } from \"@marko/compiler\";\nvar IDENTIFIER_REG = /^[0-9A-Z_$]+$/i;\nfunction toPropertyName(name) {\n  return IDENTIFIER_REG.test(name) ? t12.identifier(name) : t12.stringLiteral(name);\n}\n\n// src/util/attrs-to-object.ts\nfunction attrsToObject(tag, withRenderBody = false) {\n  const { node } = tag;\n  let result = t13.objectExpression([]);\n  const resultExtra = result.extra = {};\n  for (const attr of node.attributes) {\n    const value = attr.value;\n    if (t13.isMarkoSpreadAttribute(attr)) {\n      result.properties.push(t13.spreadElement(value));\n    } else {\n      result.properties.push(t13.objectProperty(toPropertyName(attr.name), value));\n    }\n  }\n  if (withRenderBody) {\n    const { body, params } = node.body;\n    let hoistedControlFlows = node.extra.hoistedControlFlows;\n    if (hoistedControlFlows) {\n      for (const child of tag.get(\"body\").get(\"body\")) {\n        tag.insertBefore(child.node);\n        child.remove();\n        if (child.isConditional() || child.isLoop()) {\n          if (!--hoistedControlFlows) {\n            break;\n          }\n        }\n      }\n    }\n    if (body.length) {\n      result.properties.push(t13.objectMethod(\"method\", t13.identifier(\"renderBody\"), params, t13.blockStatement(body)));\n    }\n  }\n  if (result.properties.length) {\n    if (result.properties.length === 1) {\n      const [prop] = result.properties;\n      if (t13.isSpreadElement(prop)) {\n        result = prop.argument;\n        result.extra = resultExtra;\n      }\n    }\n    return result;\n  }\n}\nfunction getRenderBodyProp(attrsObject) {\n  if (t13.isObjectExpression(attrsObject)) {\n    const lastProp = attrsObject.properties[attrsObject.properties.length - 1];\n    if (t13.isObjectMethod(lastProp) && lastProp.key.name === \"renderBody\") {\n      return lastProp;\n    }\n  }\n}\n\n// src/util/translate-var.ts\nimport { types as t14 } from \"@marko/compiler\";\nfunction translateVar(tag, initialValue, kind = \"const\") {\n  const {\n    node: { var: tagVar }\n  } = tag;\n  if (!tagVar) {\n    return;\n  }\n  tag.get(\"var\").remove();\n  tag.insertBefore(t14.variableDeclaration(kind, [\n    t14.variableDeclarator(t14.cloneDeep(tagVar), initialValue)\n  ]));\n  tag.hub.file.path.scope.crawl();\n}\n\n// src/util/evaluate.ts\nfunction evaluate(path3) {\n  let { extra } = path3.node;\n  if (!extra) {\n    extra = path3.node.extra = {};\n  }\n  if (extra.confident === void 0) {\n    const value = path3.get(\"value\");\n    const { confident, value: computed } = value.evaluate();\n    extra.computed = computed;\n    extra.confident = confident;\n  }\n  return extra;\n}\n\n// src/visitors/tag/native-tag.ts\nvar native_tag_default = {\n  analyze: {\n    enter(tag) {\n      const { node } = tag;\n      const attrs = tag.get(\"attributes\");\n      let sectionId = tag.has(\"var\") ? getOrCreateSectionId(tag) : void 0;\n      if (attrs.some(isSpreadAttr)) {\n      } else {\n        for (const attr of attrs) {\n          const attrNode = attr.node;\n          const { name } = attrNode;\n          if (name.startsWith(\"on\")) {\n            sectionId ??= getOrCreateSectionId(tag);\n            (currentProgramPath.node.extra ?? {}).isInteractive = true;\n          } else if (!evaluate(attr).confident) {\n            sectionId ??= getOrCreateSectionId(tag);\n          }\n        }\n      }\n      if (sectionId !== void 0) {\n        reserveScope(0 /* Visit */, sectionId, node, node.name.value);\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { extra } = tag.node;\n      const isHTML = isOutputHTML();\n      const name = tag.get(\"name\");\n      const attrs = tag.get(\"attributes\");\n      const tagDef = getTagDef(tag);\n      const hasSpread = attrs.some((attr) => attr.isMarkoSpreadAttribute());\n      const write = writeTo(tag);\n      const sectionId = getSectionId(tag);\n      if (isHTML) {\n        if (extra.tagNameNullable) {\n          flushBefore(tag);\n        }\n        translateVar(tag, t15.unaryExpression(\"void\", t15.numericLiteral(0)));\n      }\n      let visitIndex;\n      if (extra.reserve) {\n        visitIndex = t15.numericLiteral(extra.reserve.id);\n        visit(tag, 32 /* Get */);\n      }\n      write`<${name.node}`;\n      if (hasSpread) {\n        const attrsCallExpr = callRuntime(\"attrs\", scopeIdentifier, attrsToObject(tag));\n        if (isHTML) {\n          write`${attrsCallExpr}`;\n        } else {\n          tag.insertBefore(t15.expressionStatement(attrsCallExpr));\n        }\n      } else {\n        for (const attr of attrs) {\n          const name2 = attr.node.name;\n          const extra2 = attr.node.extra ?? {};\n          const value = attr.get(\"value\");\n          const { confident, computed, valueReferences } = extra2;\n          switch (name2) {\n            case \"class\":\n            case \"style\": {\n              const helper = `${name2}Attr`;\n              if (confident) {\n                write`${getHTMLRuntime()[helper](computed)}`;\n              } else if (isHTML) {\n                write`${callRuntime(helper, value.node)}`;\n              } else {\n                addStatement(\"apply\", sectionId, valueReferences, t15.expressionStatement(callRuntime(helper, t15.memberExpression(scopeIdentifier, visitIndex, true), value.node)));\n              }\n              break;\n            }\n            default:\n              if (confident) {\n                write`${getHTMLRuntime().attr(name2, computed)}`;\n              } else if (isHTML) {\n                if (name2.startsWith(\"on\")) {\n                  addHTMLHydrateCall(sectionId, extra2.valueReferences);\n                } else {\n                  write`${callRuntime(\"attr\", t15.stringLiteral(name2), value.node)}`;\n                }\n              } else if (name2.startsWith(\"on\")) {\n                addStatement(\"hydrate\", sectionId, extra2.valueReferences, t15.expressionStatement(callRuntime(\"on\", t15.memberExpression(scopeIdentifier, visitIndex, true), t15.stringLiteral(name2.slice(2)), value.node)));\n              } else {\n                addStatement(\"apply\", sectionId, valueReferences, t15.expressionStatement(callRuntime(\"attr\", t15.memberExpression(scopeIdentifier, visitIndex, true), t15.stringLiteral(name2), value.node)));\n              }\n              break;\n          }\n        }\n      }\n      let emptyBody = false;\n      if (tagDef && tagDef.parseOptions?.openTagOnly) {\n        switch (tagDef.htmlType) {\n          case \"svg\":\n          case \"math\":\n            write`/>`;\n            break;\n          default:\n            write`>`;\n            break;\n        }\n        emptyBody = true;\n      } else if (tag.node.body.body.length) {\n        write`>`;\n      } else {\n        write`></${name.node}>`;\n        emptyBody = true;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(t15.ifStatement(name.node, consumeHTML(tag)))[0].skip();\n      }\n      if (emptyBody) {\n        enterShallow(tag);\n        tag.remove();\n      } else {\n        enter(tag);\n      }\n    },\n    exit(tag) {\n      const { extra } = tag.node;\n      const isHTML = isOutputHTML();\n      if (isHTML && extra.tagNameNullable) {\n        flushInto(tag);\n      }\n      tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n      writeTo(tag)`</${tag.node.name}>`;\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(t15.ifStatement(tag.node.name, consumeHTML(tag)))[0].skip();\n      }\n      exit(tag);\n      tag.remove();\n    }\n  }\n};\nfunction isSpreadAttr(attr) {\n  return attr.type === \"MarkoSpreadAttribute\";\n}\n\n// src/visitors/tag/custom-tag.ts\nimport { types as t16 } from \"@marko/compiler\";\nimport {\n  getTagDef as getTagDef2,\n  importNamed as importNamed2,\n  importDefault,\n  resolveRelativePath,\n  loadFileForTag\n} from \"@marko/babel-utils\";\nvar custom_tag_default = {\n  analyze: {\n    enter(tag) {\n      trackReferences(tag);\n      const body = tag.get(\"body\");\n      if (body.get(\"body\").length) {\n        startSection(body);\n      }\n      if (getTagDef2(tag)?.template) {\n        reserveScope(1 /* Store */, getOrCreateSectionId(tag), tag.node, \"child\");\n      }\n      const childFile = loadFileForTag(tag);\n      const childProgramExtra = childFile?.ast.program.extra;\n      const hasInteractiveChild = childProgramExtra?.isInteractive || childProgramExtra?.hasInteractiveChild;\n      if (hasInteractiveChild) {\n        (currentProgramPath.node.extra ?? {}).hasInteractiveChild = true;\n      }\n    },\n    exit(tag) {\n      const tagDef = getTagDef2(tag);\n      const template = tagDef?.template;\n      const sectionId = getOrCreateSectionId(tag);\n      if (template) {\n        tag.node.extra.attrsReferences = mergeReferenceGroups(sectionId, tag.node.attributes.filter((attr) => attr.extra?.valueReferences).map((attr) => [attr.extra, \"valueReferences\"]));\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const tagSectionId = getSectionId(tag);\n      const tagBody = tag.get(\"body\");\n      const tagBodySectionId = getSectionId(tagBody);\n      const isHTML = isOutputHTML();\n      const { node } = tag;\n      const write = writeTo(tag);\n      const binding = node.extra.reserve;\n      let tagIdentifier;\n      let tagAttrsIdentifier;\n      if (isHTML) {\n        flushInto(tag);\n        writeHTMLHydrateStatements(tagBody);\n      }\n      if (t16.isStringLiteral(node.name)) {\n        const { file } = tag.hub;\n        const tagName = node.name.value;\n        const tags = file.metadata.marko.tags;\n        const tagDef = getTagDef2(tag);\n        const template = tagDef?.template;\n        const relativePath = template && resolveRelativePath(file, template);\n        const childFile = loadFileForTag(tag);\n        const childProgram = childFile.ast.program;\n        if (!relativePath) {\n          throw tag.get(\"name\").buildCodeFrameError(`Unable to find entry point for custom tag <${tagName}>.`);\n        }\n        if (isHTML) {\n          tagIdentifier = importDefault(file, relativePath, tagName);\n        } else {\n          tagIdentifier = importNamed2(file, relativePath, \"apply\", tagName);\n          if (childProgram.extra.attrs) {\n            tagAttrsIdentifier = importNamed2(file, relativePath, \"applyAttrs\", `${tagName}_attrs`);\n          }\n          write`${importNamed2(file, relativePath, \"template\", `${tagName}_template`)}`;\n          injectWalks(tag, binding.id, importNamed2(file, relativePath, \"walks\", `${tagName}_walks`));\n        }\n        if (!tags.includes(relativePath)) {\n          tags.push(relativePath);\n        }\n      } else {\n        tagIdentifier = node.name;\n      }\n      const tagVar = node.var;\n      const attrsObject = attrsToObject(tag, true);\n      const renderBodyProp = getRenderBodyProp(attrsObject);\n      if (isHTML && node.extra.tagNameNullable) {\n        let renderBodyId = void 0;\n        let renderTagExpr = callExpression(tagIdentifier, attrsToObject(tag));\n        if (renderBodyProp) {\n          renderBodyId = tag.scope.generateUidIdentifier(\"renderBody\");\n          const [renderBodyPath] = tag.insertBefore(t16.functionDeclaration(renderBodyId, renderBodyProp.params, renderBodyProp.body));\n          renderBodyPath.skip();\n          attrsObject.properties[attrsObject.properties.length - 1] = t16.objectProperty(t16.identifier(\"renderBody\"), renderBodyId);\n        }\n        if (tagVar) {\n          translateVar(tag, t16.unaryExpression(\"void\", t16.numericLiteral(0)), \"let\");\n          renderTagExpr = t16.assignmentExpression(\"=\", tagVar, renderTagExpr);\n        }\n        tag.replaceWith(t16.ifStatement(tagIdentifier, t16.expressionStatement(renderTagExpr), renderBodyId && callStatement(renderBodyId)))[0].skip();\n      } else {\n        if (isHTML) {\n          if (tagVar) {\n            translateVar(tag, callExpression(tagIdentifier, attrsObject));\n            tag.remove();\n          } else {\n            tag.replaceWith(callStatement(tagIdentifier, attrsObject))[0].skip();\n          }\n        } else {\n          if (renderBodyProp) {\n            const { walks, writes } = getSectionMeta(tagBodySectionId);\n            attrsObject.properties.pop();\n            attrsObject.properties.push(t16.objectProperty(t16.identifier(\"renderBody\"), callRuntime(\"createRenderer\", writes || t16.stringLiteral(\"\"), walks || t16.stringLiteral(\"\"), t16.arrowFunctionExpression(renderBodyProp.params, renderBodyProp.body))));\n          }\n          addStatement(\"apply\", tagSectionId, void 0, t16.expressionStatement(t16.callExpression(tagIdentifier, [callRead(binding, tagSectionId)])));\n          if (attrsObject && tagAttrsIdentifier) {\n            addStatement(\"apply\", tagSectionId, tag.node.extra.attrsReferences, t16.expressionStatement(t16.callExpression(tagAttrsIdentifier, [\n              callRead(binding, tagSectionId),\n              attrsObject\n            ])));\n          }\n          tag.remove();\n        }\n      }\n    }\n  }\n};\nfunction callStatement(id, ...args) {\n  return t16.expressionStatement(callExpression(id, ...args));\n}\nfunction callExpression(id, ...args) {\n  return t16.callExpression(id, args.filter(Boolean));\n}\n\n// src/visitors/tag/dynamic-tag.ts\nimport { types as t18 } from \"@marko/compiler\";\n\n// src/util/to-first-expression-or-block.ts\nimport { types as t17 } from \"@marko/compiler\";\nfunction toFirstExpressionOrBlock(body) {\n  const nodes = body.body;\n  if (nodes.length === 1 && t17.isExpressionStatement(nodes[0])) {\n    return nodes[0].expression;\n  }\n  if (t17.isBlockStatement(body)) {\n    return body;\n  }\n  return t17.blockStatement(nodes);\n}\n\n// src/visitors/tag/dynamic-tag.ts\nvar dynamic_tag_default = {\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const tagBodySectionId = getSectionId(tag.get(\"body\"));\n      const attrsObject = attrsToObject(tag, true);\n      const renderBodyProp = getRenderBodyProp(attrsObject);\n      const args = [node.name, attrsObject || t18.nullLiteral()];\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      } else {\n        args.unshift(scopeIdentifier);\n      }\n      if (renderBodyProp) {\n        attrsObject.properties.pop();\n        let fnExpr = t18.arrowFunctionExpression(renderBodyProp.params, toFirstExpressionOrBlock(renderBodyProp.body));\n        if (isOutputDOM()) {\n          const { walks, writes } = getSectionMeta(tagBodySectionId);\n          fnExpr = callRuntime(\"createRenderer\", writes || t18.stringLiteral(\"\"), walks || t18.stringLiteral(\"\"), fnExpr);\n        }\n        args.push(fnExpr);\n      }\n      const dynamicTagExpr = callRuntime(\"dynamicTag\", ...args);\n      if (node.var) {\n        translateVar(tag, dynamicTagExpr);\n        tag.remove();\n      } else if (isOutputHTML()) {\n        tag.replaceWith(t18.expressionStatement(dynamicTagExpr))[0].skip();\n      } else {\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/visitors/tag/attribute-tag.ts\nimport { types as t19 } from \"@marko/compiler\";\nimport { findParentTag, assertNoVar } from \"@marko/babel-utils\";\nvar attribute_tag_default = {\n  translate: {\n    enter(tag) {\n      if (hasPendingHTML(tag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\"Dynamic @tags cannot be mixed with body content.\");\n      }\n    },\n    exit(tag) {\n      assertNoVar(tag);\n      flushInto(tag);\n      const parentTag = findParentTag(tag);\n      if (!parentTag) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags must be nested within another tag.\");\n      }\n      const parentExtra = parentTag.node.extra;\n      if (parentExtra.tagNameType === 0 /* NativeTag */) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags cannot be nested under native tags.\");\n      }\n      const attrName = tag.node.name.value.slice(1);\n      const info = parentExtra.nestedAttributeTags[attrName];\n      const attrsObject = attrsToObject(tag, true) || t19.objectExpression([]);\n      if (info.dynamic) {\n        if (!info.identifier) {\n          info.identifier = parentTag.scope.generateUidIdentifier(attrName);\n          parentTag.insertBefore(info.repeated ? t19.variableDeclaration(\"const\", [\n            t19.variableDeclarator(info.identifier, t19.arrayExpression([]))\n          ]) : t19.variableDeclaration(\"let\", [\n            t19.variableDeclarator(info.identifier)\n          ]));\n          parentTag.pushContainer(\"attributes\", t19.markoAttribute(attrName, info.identifier));\n        }\n        tag.replaceWith(t19.expressionStatement(info.repeated ? t19.callExpression(t19.memberExpression(info.identifier, t19.identifier(\"push\")), [attrsObject]) : t19.assignmentExpression(\"=\", info.identifier, attrsObject)));\n      } else if (info.repeated) {\n        const existingAttr = parentTag.get(\"attributes\").find((attr) => attr.node.name === attrName);\n        if (existingAttr) {\n          existingAttr.get(\"value\").pushContainer(\"elements\", attrsObject);\n        } else {\n          parentTag.pushContainer(\"attributes\", t19.markoAttribute(attrName, t19.arrayExpression([attrsObject])));\n        }\n        tag.remove();\n      } else {\n        parentTag.pushContainer(\"attributes\", t19.markoAttribute(attrName, attrsObject));\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/util/nested-attribute-tags.ts\nimport {\n  isAttributeTag,\n  isTransparentTag,\n  isLoopTag\n} from \"@marko/babel-utils\";\nfunction analyzeAttributeTags(tag) {\n  const { extra } = tag.node;\n  extra.nestedAttributeTags = {};\n  extra.hoistedControlFlows = 0;\n  analyzeChildren(extra, false, false, tag);\n}\nfunction analyzeChildren(rootExtra, repeated, dynamic, tag) {\n  let hasAttributeTags = false;\n  for (const child of tag.get(\"body\").get(\"body\")) {\n    if (child.isMarkoTag()) {\n      if (analyzeChild(rootExtra, repeated, dynamic, child)) {\n        hasAttributeTags = true;\n      }\n    }\n  }\n  return hasAttributeTags;\n}\nfunction analyzeChild(rootExtra, repeated, dynamic, tag) {\n  if (isTransparentTag(tag)) {\n    if (analyzeChildren(rootExtra, repeated || isLoopTag(tag), true, tag)) {\n      if (!isTransparentTag(tag.parentPath.parentPath)) {\n        rootExtra.hoistedControlFlows++;\n      }\n      return true;\n    }\n  } else if (isAttributeTag(tag)) {\n    const attrName = tag.node.name.value.slice(1);\n    const lookup = rootExtra.nestedAttributeTags;\n    const existing = lookup[attrName];\n    const info = existing || (lookup[attrName] = {\n      dynamic: false,\n      repeated: false\n    });\n    info.dynamic ||= dynamic;\n    info.repeated ||= repeated || existing !== void 0;\n    return true;\n  }\n  return false;\n}\n\n// src/visitors/tag/index.ts\nvar tag_default = {\n  analyze: {\n    enter(tag) {\n      const tagDef = getTagDef3(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        enter2(hook, tag);\n        return;\n      }\n      switch (analyzeTagNameType(tag)) {\n        case 0 /* NativeTag */:\n          native_tag_default.analyze.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          break;\n        case 2 /* DynamicTag */:\n          break;\n      }\n    },\n    exit(tag) {\n      const tagDef = getTagDef3(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        exit2(hook, tag);\n        return;\n      }\n      if (type === 0 /* NativeTag */) {\n        return;\n      }\n      analyzeAttributeTags(tag);\n      switch (type) {\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          break;\n        case 2 /* DynamicTag */:\n          break;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagDef = getTagDef3(tag);\n      const extra = tag.node.extra;\n      assertNoArgs(tag);\n      if (tagDef?.translator) {\n        if (tagDef.translator.path) {\n          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);\n        }\n        enter2(tagDef.translator.hook, tag);\n        return;\n      }\n      for (const attr of tag.get(\"attributes\")) {\n        if (attr.isMarkoAttribute()) {\n          if (attr.node.arguments) {\n            throw attr.buildCodeFrameError(`Unsupported arguments on the \"${attr.node.name}\" attribute.`);\n          }\n          if (attr.node.modifier) {\n            if (isNativeTag2(attr.parentPath)) {\n              attr.node.name += `:${attr.node.modifier}`;\n            } else {\n              throw attr.buildCodeFrameError(`Unsupported modifier \"${attr.node.modifier}\".`);\n            }\n          }\n        }\n      }\n      let { tagNameType } = extra;\n      if (extra.tagNameDynamic) {\n        if (extra.tagNameNullable && !tag.get(\"name\").isIdentifier()) {\n          const tagNameId = tag.scope.generateUidIdentifier(\"tagName\");\n          const [tagNameVarPath] = tag.insertBefore(t20.variableDeclaration(\"const\", [\n            t20.variableDeclarator(tagNameId, tag.node.name)\n          ]));\n          tagNameVarPath.skip();\n          tag.set(\"name\", tagNameId);\n        }\n        if (tagNameType !== 2 /* DynamicTag */ && !isOutputHTML()) {\n          tagNameType = 2 /* DynamicTag */;\n        }\n      }\n      switch (tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const translator = getTagDef3(tag)?.translator;\n      if (translator) {\n        exit2(translator.hook, tag);\n        return;\n      }\n      const { extra } = tag.node;\n      let { tagNameType } = extra;\n      if (extra.tagNameDynamic && tagNameType !== 2 /* DynamicTag */ && (!isOutputHTML() || tagNameType === void 0)) {\n        tagNameType = 2 /* DynamicTag */;\n      }\n      switch (tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.exit(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.exit(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.exit(tag);\n          break;\n      }\n    }\n  }\n};\n\n// src/visitors/placeholder.ts\nimport { types as t21 } from \"@marko/compiler\";\nimport { isNativeTag as isNativeTag3 } from \"@marko/babel-utils\";\n\n// src/util/is-core-tag.ts\nimport { getTagDef as getTagDef4 } from \"@marko/babel-utils\";\nvar taglibId = \"marko-core\";\nfunction isCoreTag(tag) {\n  return tag.isMarkoTag() && getTagDef4(tag)?.taglibId === taglibId;\n}\nfunction isCoreTagName(tag, name) {\n  return isCoreTag(tag) && tag.node.name.value === name;\n}\n\n// src/visitors/placeholder.ts\nvar ESCAPE_TYPES = {\n  script: \"escapeScript\",\n  style: \"escapeStyle\"\n};\nvar placeholder_default = {\n  analyze(placeholder) {\n    const { node } = placeholder;\n    const { confident, computed } = evaluate(placeholder);\n    if (!(confident && (node.escape || !computed))) {\n      reserveScope(0 /* Visit */, getOrCreateSectionId(placeholder), node, \"placeholder\");\n      needsMarker(placeholder);\n    }\n  },\n  translate(placeholder) {\n    const isHTML = isOutputHTML();\n    const write = writeTo(placeholder);\n    const extra = placeholder.node.extra;\n    const { confident, computed, valueReferences, reserve } = extra;\n    const canWriteHTML = isHTML || confident && (placeholder.node.escape || !computed);\n    const method = canWriteHTML ? placeholder.node.escape ? ESCAPE_TYPES[getParentTagName(placeholder)] || \"escapeXML\" : \"toString\" : placeholder.node.escape ? \"data\" : \"html\";\n    if (confident && canWriteHTML) {\n      write`${getHTMLRuntime()[method](computed)}`;\n    } else {\n      if (extra.needsMarker) {\n        visit(placeholder, 37 /* Replace */);\n      } else {\n        if (!isHTML)\n          write` `;\n        visit(placeholder, 32 /* Get */);\n      }\n      if (isHTML) {\n        write`${callRuntime(method, placeholder.node.value)}`;\n      } else {\n        addStatement(\"apply\", getSectionId(placeholder), valueReferences, t21.expressionStatement(callRuntime(method, t21.memberExpression(scopeIdentifier, t21.numericLiteral(reserve.id), true), placeholder.node.value)));\n      }\n    }\n    enterShallow(placeholder);\n    placeholder.remove();\n  }\n};\nfunction getParentTagName({ parentPath }) {\n  return parentPath.isMarkoTag() && isNativeTag3(parentPath) && parentPath.node.name.value || \"\";\n}\nfunction noOutput(path3) {\n  return t21.isMarkoComment(path3) || t21.isMarkoTag(path3) && isCoreTag(path3) && [\"let\", \"const\", \"effect\", \"lifecycle\", \"attrs\", \"get\", \"id\"].includes(path3.node.name.value);\n}\nfunction needsMarker(placeholder) {\n  let prev = placeholder.getPrevSibling();\n  while (prev.node && noOutput(prev)) {\n    prev = prev.getPrevSibling();\n  }\n  if ((prev.node || t21.isProgram(placeholder.parentPath)) && !(t21.isMarkoTag(prev) && isNativeTag3(prev))) {\n    return placeholder.node.extra.needsMarker = true;\n  }\n  let next = placeholder.getNextSibling();\n  while (next.node && noOutput(next)) {\n    next = next.getNextSibling();\n  }\n  if ((next.node || t21.isProgram(placeholder.parentPath)) && !(t21.isMarkoTag(next) && isNativeTag3(next))) {\n    return placeholder.node.extra.needsMarker = true;\n  }\n  return placeholder.node.extra.needsMarker = false;\n}\n\n// src/visitors/scriptlet.ts\nvar scriptlet_default = {\n  translate(scriptlet) {\n    if (isOutputHTML()) {\n      if (scriptlet.node.static)\n        return;\n      scriptlet.replaceWithMultiple(scriptlet.node.body);\n    } else {\n      if (scriptlet.node.static) {\n        scriptlet.replaceWithMultiple(scriptlet.node.body);\n      } else {\n        addStatement(\"apply\", getSectionId(scriptlet), scriptlet.node.extra?.bodyReferences, scriptlet.node.body);\n        scriptlet.remove();\n      }\n    }\n  }\n};\n\n// src/visitors/comment.ts\nvar ieConditionalCommentRegExp = /^\\[if |<!\\[endif\\]$/;\nvar comment_default = {\n  translate(comment) {\n    if (isOutputHTML()) {\n      const { value } = comment.node;\n      if (ieConditionalCommentRegExp.test(value)) {\n        writeTo(comment)`<!--${value}-->`;\n      }\n    }\n    comment.remove();\n  }\n};\n\n// src/core/import.ts\nimport { parseScript } from \"@marko/babel-utils\";\nvar import_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(parseScript(tag.hub.file, node.rawValue, node.start).body[0]);\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: 'import <scope> from \"<path>\"',\n      description: \"Use to import external modules, follows the same syntax as JavaScript imports.\",\n      snippet: 'import ${2} from \"${1:path}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#importing-external-files\"\n    }\n  ]\n};\n\n// src/core/export.ts\nimport { parseScript as parseScript2 } from \"@marko/babel-utils\";\nvar export_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(parseScript2(tag.hub.file, node.rawValue, node.start).body[0]);\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"export <value>\"\n    }\n  ]\n};\n\n// src/core/attrs.ts\nvar attrs_default = {\n  analyze(tag) {\n    if (tag.has(\"var\")) {\n      const varPath = tag.get(\"var\");\n      const bindings = varPath.getBindingIdentifiers();\n      const sectionId = getOrCreateSectionId(tag);\n      trackReferencesForBindings(sectionId, varPath, 2 /* Attr */);\n      for (const key in bindings) {\n        const binding = bindings[key].extra.reserve;\n        binding.exportIdentifier = getReferenceGroup(sectionId, binding, true).apply;\n      }\n      (currentProgramPath.node.extra ??= {}).attrs = {\n        bindings,\n        var: varPath.node\n      };\n    }\n  },\n  translate(tag) {\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"attrs/{ ... }\",\n      description: \"Use to receive the attributes passed into this template.\",\n      snippet: \"attrs/{ $1 }$2\"\n    }\n  ]\n};\n\n// src/core/condition/if.ts\nimport { types as t23 } from \"@marko/compiler\";\nimport { assertNoParams, assertNoVar as assertNoVar2 } from \"@marko/babel-utils\";\n\n// src/util/to-first-statement-or-block.ts\nimport { types as t22 } from \"@marko/compiler\";\nfunction toFirstStatementOrBlock(body) {\n  const nodes = body.body;\n  if (nodes.length === 1) {\n    return nodes[0];\n  }\n  if (t22.isBlockStatement(body)) {\n    return body;\n  }\n  return t22.blockStatement(nodes);\n}\n\n// src/core/condition/if.ts\nvar if_default = {\n  analyze: {\n    enter(tag) {\n      reserveScope(0 /* Visit */, getOrCreateSectionId(tag), tag.node, \"if\", 3);\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      analyzeAttributeTags(tag);\n      exitBranchAnalyze(tag);\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [testAttr] = node.attributes;\n      assertNoVar2(tag);\n      assertNoParams(tag);\n      if (!t23.isMarkoAttribute(testAttr) || !testAttr.default) {\n        throw tag.get(\"name\").buildCodeFrameError(`The '<if>' tag requires a default attribute like '<if=condition>'.`);\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<if>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n        }\n      }\n      visit(tag, 37 /* Replace */);\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      exitBranchTranslate(tag);\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      snippet: \"if=${1:condition}\",\n      description: \"Use to display content only if the condition is met.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar BRANCHES_LOOKUP = /* @__PURE__ */ new WeakMap();\nfunction getBranches(tag, bodySectionId) {\n  const branches = BRANCHES_LOOKUP.get(tag) ?? [];\n  const nextTag = tag.getNextSibling();\n  const isLast = !(isCoreTagName(nextTag, \"else\") || isCoreTagName(nextTag, \"else-if\"));\n  branches.push({\n    tag,\n    sectionId: bodySectionId\n  });\n  if (!isLast) {\n    BRANCHES_LOOKUP.set(nextTag, branches);\n  }\n  return [isLast, branches];\n}\nfunction exitBranchAnalyze(tag) {\n  const sectionId = getOrCreateSectionId(tag);\n  const tagBody = tag.get(\"body\");\n  const bodySectionId = getOrCreateSectionId(tagBody);\n  const [isLast, branches] = getBranches(tag, bodySectionId);\n  if (isLast) {\n    branches[0].tag.node.extra.conditionalReferences = mergeReferenceGroups(sectionId, branches.filter(({ tag: tag2 }) => tag2.node.attributes[0]?.extra?.valueReferences).map(({ tag: tag2 }) => [tag2.node.attributes[0].extra, \"valueReferences\"]));\n  }\n}\nfunction exitBranchTranslate(tag) {\n  const tagBody = tag.get(\"body\");\n  const bodySectionId = getSectionId(tagBody);\n  const [isLast, branches] = getBranches(tag, bodySectionId);\n  if (isOutputHTML()) {\n    flushInto(tag);\n    writeHTMLHydrateStatements(tagBody);\n  }\n  if (isLast) {\n    if (isOutputDOM()) {\n      const sectionId = getSectionId(tag);\n      const { extra } = branches[0].tag.node;\n      let expr = t23.nullLiteral();\n      for (let i = branches.length; i--; ) {\n        const { tag: tag2, sectionId: sectionId2 } = branches[i];\n        const [testAttr] = tag2.node.attributes;\n        const id = getRenderer(sectionId2);\n        setQueueBuilder(tag2, ({ apply, index }, closurePriority) => {\n          return callRuntime(\"queueInBranch\", scopeIdentifier, t23.numericLiteral(extra.reserve.id), getRenderer(sectionId2), apply, t23.numericLiteral(index), closurePriority);\n        });\n        tag2.remove();\n        if (testAttr) {\n          expr = t23.conditionalExpression(testAttr.value, id, expr);\n        } else {\n          expr = id;\n        }\n      }\n      addStatement(\"apply\", sectionId, extra.conditionalReferences, t23.expressionStatement(callRuntime(\"setConditionalRenderer\", scopeIdentifier, t23.numericLiteral(extra.reserve.id), expr)));\n    } else {\n      const nextTag = tag.getNextSibling();\n      let statement;\n      for (let i = branches.length; i--; ) {\n        const { tag: tag2 } = branches[i];\n        const [testAttr] = tag2.node.attributes;\n        const curStatement = toFirstStatementOrBlock(tag2.node.body);\n        if (testAttr) {\n          statement = t23.ifStatement(testAttr.value, curStatement, statement);\n        } else {\n          statement = curStatement;\n        }\n        tag2.remove();\n      }\n      nextTag.insertBefore(statement);\n    }\n  }\n}\n\n// src/core/condition/else-if.ts\nimport { types as t24 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams2, assertNoVar as assertNoVar3 } from \"@marko/babel-utils\";\nvar else_if_default = {\n  analyze: {\n    enter(tag) {\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      exitBranchAnalyze(tag);\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [defaultAttr] = node.attributes;\n      assertNoVar3(tag);\n      assertNoParams2(tag);\n      if (!t24.isMarkoAttribute(defaultAttr) || !defaultAttr.default) {\n        throw tag.get(\"name\").buildCodeFrameError(`The '<else-if>' tag requires a default attribute like '<else-if=condition>'.`);\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<else-if>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n        }\n      }\n    },\n    exit(tag) {\n      exitBranchTranslate(tag);\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      snippet: \"else-if=${1:condition}\",\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\n\n// src/core/condition/else.ts\nimport { assertNoParams as assertNoParams3, assertNoVar as assertNoVar4 } from \"@marko/babel-utils\";\nvar else_default = {\n  analyze: {\n    enter(tag) {\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      exitBranchAnalyze(tag);\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [testAttr] = node.attributes;\n      assertNoVar4(tag);\n      assertNoParams3(tag);\n      if (node.attributes.length > 1 || testAttr && testAttr.name !== \"if\") {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<else>' tag only supports an if attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n        }\n      }\n    },\n    exit(tag) {\n      exitBranchTranslate(tag);\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\n\n// src/core/const.ts\nimport { types as t25 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams4 } from \"@marko/babel-utils\";\n\n// src/util/assert.ts\nfunction assertNoSpreadAttrs(tag) {\n  for (const attr of tag.get(\"attributes\")) {\n    if (attr.isMarkoSpreadAttribute()) {\n      throw attr.buildCodeFrameError(`The <${tag.get(\"name\")}> tag does not support ...spread attributes.`);\n    }\n  }\n}\nfunction assertNoBodyContent(tag) {\n  if (tag.node.body.body.length) {\n    throw tag.get(\"name\").buildCodeFrameError(`The <${tag.get(\"name\")}> tag does not support body content.`);\n  }\n}\n\n// src/core/const.ts\nvar const_default = {\n  translate(tag) {\n    const { node } = tag;\n    const [defaultAttr] = node.attributes;\n    assertNoParams4(tag);\n    assertNoBodyContent(tag);\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'const' tag requires a tag variable.\");\n    }\n    if (!defaultAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'const' tag requires a default attribute.\");\n    }\n    if (node.attributes.length > 1 || !t25.isMarkoAttribute(defaultAttr) || !defaultAttr.default && defaultAttr.name !== \"default\") {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'const' tag only supports the 'default' attribute.\");\n    }\n    if (isOutputDOM()) {\n      const sectionId = getSectionId(tag);\n      const identifiers = Object.values(tag.get(\"var\").getBindingIdentifiers());\n      addStatement(\"apply\", sectionId, defaultAttr.extra?.valueReferences, identifiers.length === 1 ? t25.expressionStatement(t25.callExpression(getReferenceGroup(sectionId, identifiers[0].extra.reserve).apply, [scopeIdentifier, defaultAttr.value])) : [\n        t25.variableDeclaration(\"const\", [\n          t25.variableDeclarator(node.var, defaultAttr.value)\n        ]),\n        ...identifiers.map((identifier) => t25.expressionStatement(t25.callExpression(getReferenceGroup(sectionId, identifier.extra.reserve).apply, [t25.identifier(identifier.name)])))\n      ]);\n    } else {\n      translateVar(tag, defaultAttr.value);\n    }\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an constant binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#const\"\n    }\n  ]\n};\n\n// src/core/effect.ts\nimport { types as t26 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams5 } from \"@marko/babel-utils\";\nvar effect_default = {\n  analyze(tag) {\n    const sectionId = getSectionId(tag);\n    reserveScope(1 /* Store */, sectionId, tag.node, \"cleanup\");\n    (currentProgramPath.node.extra ?? {}).isInteractive = true;\n  },\n  translate(tag) {\n    const { node } = tag;\n    const [defaultAttr] = node.attributes;\n    assertNoParams5(tag);\n    assertNoBodyContent(tag);\n    if (!defaultAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'effect' tag requires a default attribute.\");\n    }\n    if (node.attributes.length > 1 || !t26.isMarkoAttribute(defaultAttr) || !defaultAttr.default && defaultAttr.name !== \"default\") {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'effect' tag only supports the 'default' attribute.\");\n    }\n    const sectionId = getSectionId(tag);\n    if (isOutputDOM()) {\n      const cleanupIndex = tag.node.extra.reserve.id;\n      const { value } = defaultAttr;\n      let inlineStatements = null;\n      if (t26.isFunctionExpression(value) || t26.isArrowFunctionExpression(value) && t26.isBlockStatement(value.body)) {\n        inlineStatements = value.body.body;\n        t26.traverse(value.body, (node2) => {\n          if (t26.isReturnStatement(node2)) {\n            inlineStatements = null;\n          }\n        });\n      }\n      addStatement(\"hydrate\", sectionId, defaultAttr.extra?.valueReferences, inlineStatements || t26.expressionStatement(callRuntime(\"userEffect\", scopeIdentifier, t26.numericLiteral(cleanupIndex), defaultAttr.value)));\n    } else {\n      addHTMLHydrateCall(sectionId, defaultAttr.extra?.valueReferences);\n    }\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ]\n};\n\n// src/core/for.ts\nimport { types as t27 } from \"@marko/compiler\";\nimport {\n  assertAllowedAttributes,\n  assertNoVar as assertNoVar5,\n  getTagDef as getTagDef5\n} from \"@marko/babel-utils\";\nvar for_default = {\n  analyze: {\n    enter(tag) {\n      const isOnlyChild = checkOnlyChild(tag);\n      reserveScope(0 /* Visit */, getOrCreateSectionId(tag), isOnlyChild ? tag.parentPath.parent : tag.node, \"for\", 3);\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      analyzeAttributeTags(tag);\n    }\n  },\n  translate: {\n    enter(tag) {\n      validateFor(tag);\n      if (!isOutputHTML() && Object.keys(tag.node.extra.nestedAttributeTags).length) {\n        tag.remove();\n        return;\n      }\n      const {\n        extra: { isOnlyChild }\n      } = tag.node;\n      if (!isOnlyChild) {\n        visit(tag, 37 /* Replace */);\n        enterShallow(tag);\n      }\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML.exit(tag);\n      } else {\n        translateDOM.exit(tag);\n      }\n    }\n  },\n  attributes: {\n    of: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over a list of items.\"\n        }\n      ]\n    },\n    in: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over the keys and values of an object.\"\n        }\n      ]\n    },\n    to: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates up to the provided number (inclusive)\"\n        }\n      ]\n    },\n    from: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates starting from the provided number (inclusive)\"\n        }\n      ]\n    },\n    step: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"The amount to increment during each interation (with from/to)\"\n        }\n      ]\n    }\n  },\n  autocomplete: [\n    {\n      snippet: \"for|${1:value, index}| of=${3:array}\",\n      description: \"Use to iterate over lists, object properties, or between ranges.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-a-list\"\n    },\n    {\n      snippet: \"for|${1:name, value}| in=${3:object}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties\"\n    },\n    {\n      snippet: \"for|${1:index}| from=${2:number} to=${3:number} step=${4:number}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers\"\n    }\n  ]\n};\nvar translateDOM = {\n  exit(tag) {\n    const bodySectionId = getSectionId(tag.get(\"body\"));\n    const sectionId = getSectionId(tag);\n    const { node } = tag;\n    const {\n      attributes,\n      body: { params },\n      extra: { isOnlyChild }\n    } = node;\n    const {\n      extra: { reserve }\n    } = isOnlyChild ? tag.parentPath.parent : tag.node;\n    const ofAttr = findName(attributes, \"of\");\n    const byAttr = findName(attributes, \"by\");\n    setQueueBuilder(tag, ({ apply, index }, closurePriority) => {\n      return callRuntime(\"queueForEach\", scopeIdentifier, t27.numericLiteral(reserve.id), apply, t27.numericLiteral(index), closurePriority);\n    });\n    if (ofAttr) {\n      const ofAttrValue = ofAttr.value;\n      const [valParam] = params;\n      if (!t27.isIdentifier(valParam)) {\n        throw tag.buildCodeFrameError(`Invalid 'for of' tag, |value| parameter must be an identifier.`);\n      }\n      const rendererId = getRenderer(bodySectionId);\n      tag.remove();\n      addStatement(\"apply\", sectionId, ofAttr.extra?.valueReferences, t27.expressionStatement(callRuntime(\"setLoopOf\", scopeIdentifier, t27.numericLiteral(reserve.id), ofAttrValue, rendererId, byAttr ? byAttr.value : t27.nullLiteral(), getReferenceGroup(bodySectionId, valParam.extra.reserve).apply)));\n    }\n  }\n};\nvar translateHTML = {\n  exit(tag) {\n    const tagBody = tag.get(\"body\");\n    const { node } = tag;\n    const {\n      attributes,\n      body: { body, params }\n    } = node;\n    const namePath = tag.get(\"name\");\n    const ofAttr = findName(attributes, \"of\");\n    const inAttr = findName(attributes, \"in\");\n    const fromAttr = findName(attributes, \"from\");\n    const toAttr = findName(attributes, \"to\");\n    const block = t27.blockStatement(body);\n    let forNode;\n    flushInto(tag);\n    writeHTMLHydrateStatements(tagBody);\n    if (inAttr) {\n      const [keyParam, valParam] = params;\n      if (valParam) {\n        block.body.unshift(t27.variableDeclaration(\"const\", [\n          t27.variableDeclarator(valParam, t27.memberExpression(inAttr.value, keyParam, true))\n        ]));\n      }\n      forNode = t27.forInStatement(t27.variableDeclaration(\"const\", [t27.variableDeclarator(keyParam)]), inAttr.value, block);\n    } else if (ofAttr) {\n      let ofAttrValue = ofAttr.value;\n      const [valParam, keyParam, loopParam] = params;\n      if (!valParam) {\n        throw namePath.buildCodeFrameError(\"Invalid 'for of' tag, missing |value, index| params.\");\n      }\n      forNode = [];\n      if (keyParam) {\n        const indexName = tag.scope.generateUidIdentifierBasedOnNode(keyParam, \"i\");\n        forNode.push(t27.variableDeclaration(\"let\", [\n          t27.variableDeclarator(indexName, t27.numericLiteral(0))\n        ]));\n        block.body.unshift(t27.variableDeclaration(\"let\", [\n          t27.variableDeclarator(keyParam, t27.updateExpression(\"++\", indexName))\n        ]));\n      }\n      if (loopParam) {\n        if (t27.isIdentifier(loopParam)) {\n          ofAttrValue = loopParam;\n        }\n        forNode.push(t27.variableDeclaration(\"const\", [\n          t27.variableDeclarator(loopParam, ofAttr.value)\n        ]));\n      }\n      forNode.push(t27.forOfStatement(t27.variableDeclaration(\"const\", [t27.variableDeclarator(valParam)]), ofAttrValue, block));\n    } else if (fromAttr && toAttr) {\n      const stepAttr = findName(attributes, \"step\") || {\n        value: t27.numericLiteral(1)\n      };\n      const stepValue = stepAttr ? stepAttr.value : t27.numericLiteral(1);\n      const [indexParam] = params;\n      const stepsName = tag.scope.generateUidIdentifier(\"steps\");\n      const stepName = tag.scope.generateUidIdentifier(\"step\");\n      if (indexParam) {\n        block.body.unshift(t27.variableDeclaration(\"const\", [\n          t27.variableDeclarator(indexParam, t27.binaryExpression(\"+\", fromAttr.value, t27.binaryExpression(\"*\", stepName, stepValue)))\n        ]));\n      }\n      forNode = t27.forStatement(t27.variableDeclaration(\"let\", [\n        t27.variableDeclarator(stepsName, t27.binaryExpression(\"/\", t27.binaryExpression(\"-\", toAttr.value, fromAttr.value), stepValue)),\n        t27.variableDeclarator(stepName, t27.numericLiteral(0))\n      ]), t27.binaryExpression(\"<=\", stepName, stepsName), t27.updateExpression(\"++\", stepName), block);\n    }\n    block.body.push(t27.expressionStatement(callRuntime(\"maybeFlush\")));\n    tag.replaceWithMultiple([].concat(forNode));\n  }\n};\nfunction findName(arr, value) {\n  return arr.find((obj) => t27.isMarkoAttribute(obj) && obj.name === value);\n}\nfunction validateFor(tag) {\n  const attrs = tag.node.attributes;\n  const hasParams = tag.node.body.params.length > 0;\n  assertNoVar5(tag);\n  if (findName(attrs, \"of\")) {\n    assertAllowedAttributes(tag, [\"of\", \"by\"]);\n    if (!hasParams) {\n      throw tag.buildCodeFrameError(`Invalid 'for of' tag, missing |value, index| params.`);\n    }\n  } else if (findName(attrs, \"in\")) {\n    assertAllowedAttributes(tag, [\"in\", \"by\"]);\n    if (!hasParams) {\n      throw tag.buildCodeFrameError(`Invalid 'for in' tag, missing |key, value| params.`);\n    }\n  } else if (findName(attrs, \"from\") && findName(attrs, \"to\")) {\n    assertAllowedAttributes(tag, [\"from\", \"to\", \"step\", \"by\"]);\n  } else {\n    throw tag.buildCodeFrameError(\"Invalid 'for' tag, missing an 'of', 'in' or 'to' attribute.\");\n  }\n}\nfunction checkOnlyChild(tag) {\n  tag.node.extra ??= {};\n  if (t27.isMarkoTag(tag.parentPath?.parent) && getTagDef5(tag.parentPath.parentPath)?.html) {\n    return tag.node.extra.isOnlyChild = tag.parent.body.length === 1;\n  }\n  return tag.node.extra.isOnlyChild = false;\n}\n\n// src/core/get.ts\nimport path from \"path\";\nimport { types as t28 } from \"@marko/compiler\";\nimport {\n  resolveTagImport as resolveTagImport2,\n  getTemplateId as getTemplateId2,\n  assertNoParams as assertNoParams6\n} from \"@marko/babel-utils\";\nvar get_default = {\n  translate(tag) {\n    assertNoParams6(tag);\n    assertNoBodyContent(tag);\n    flushBefore(tag);\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const [defaultAttr] = node.attributes;\n    let refId;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"<get> requires a variable to be defined, eg <get/NAME>.\");\n    }\n    if (defaultAttr === void 0) {\n      refId = \"$\";\n    } else {\n      if (!t28.isMarkoAttribute(defaultAttr) || !defaultAttr.default || !t28.isStringLiteral(defaultAttr.value)) {\n        throw tag.get(\"name\").buildCodeFrameError(`The '<get>' tag requires default attribute that is a string that resolves to a Marko file like '<get/val=\"../file.marko\">' or '<get/val=\"<tag-name>\">'.`);\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<get>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n        }\n      }\n      const defaultAttrValue = tag.get(\"attributes\")[0].get(\"value\");\n      if (defaultAttr.value.value === \".\") {\n        refId = file.metadata.marko.id;\n      } else {\n        const relativeReferencePath = resolveTagImport2(defaultAttrValue, defaultAttrValue.node.value);\n        if (!relativeReferencePath) {\n          throw defaultAttrValue.buildCodeFrameError(\"Unable to resolve template provided to '<get>' tag.\");\n        }\n        refId = getTemplateId2(file.markoOpts.optimize, path.resolve(file.opts.filename, \"..\", relativeReferencePath));\n      }\n    }\n    if (isOutputHTML()) {\n      tag.replaceWith(t28.variableDeclaration(\"const\", [\n        t28.variableDeclarator(node.var, callRuntime(\"getInContext\", t28.stringLiteral(refId)))\n      ]));\n    } else {\n      tag.remove();\n    }\n  },\n  autocomplete: [\n    {\n      displayText: 'get/<name>=\"<from>\"',\n      description: \"Gets a value provided from another template.\",\n      snippet: 'get/${1:name}=\"${2:from}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#get\"\n    }\n  ]\n};\n\n// src/core/html-comment.ts\nimport {\n  assertNoAttributeTags,\n  assertNoAttributes,\n  assertNoParams as assertNoParams7,\n  assertNoVar as assertNoVar6\n} from \"@marko/babel-utils\";\nvar html_comment_default = {\n  analyze() {\n  },\n  translate: {\n    enter(tag) {\n      enter(tag);\n      writeTo(tag)`<!--`;\n    },\n    exit(tag) {\n      assertNoVar6(tag);\n      assertNoParams7(tag);\n      assertNoAttributes(tag);\n      assertNoAttributeTags(tag);\n      exit(tag);\n      writeTo(tag)`-->`;\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    text: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an html comment that is not stripped from the output.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#html-comment\"\n    }\n  ]\n};\n\n// src/core/let.ts\nimport { types as t30 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams8 } from \"@marko/babel-utils\";\n\n// src/util/replace-assignments.ts\nimport { types as t29 } from \"@marko/compiler\";\nfunction replaceAssignments(binding, map) {\n  for (const assignment of binding.constantViolations) {\n    let value;\n    if (assignment.isUpdateExpression()) {\n      value = t29.binaryExpression(assignment.node.operator === \"++\" ? \"+\" : \"-\", binding.identifier, t29.numericLiteral(1));\n    } else if (assignment.isAssignmentExpression()) {\n      value = assignment.node.operator === \"=\" ? assignment.node.right : t29.binaryExpression(assignment.node.operator.slice(0, -1), binding.identifier, assignment.node.right);\n    }\n    if (value) {\n      assignment.parentPath.replaceWith(map(assignment, value));\n    }\n  }\n}\n\n// src/core/let.ts\nvar let_default = {\n  translate(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    const [defaultAttr] = node.attributes;\n    assertNoParams8(tag);\n    assertNoBodyContent(tag);\n    if (!tagVar) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'let' tag requires a tag variable.\");\n    }\n    if (!t30.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The 'let' cannot be destructured.\");\n    }\n    if (!defaultAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'let' tag requires a default attribute.\");\n    }\n    if (node.attributes.length > 1 || !t30.isMarkoAttribute(defaultAttr) || !defaultAttr.default && defaultAttr.name !== \"default\") {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'let' tag only supports the 'default' attribute.\");\n    }\n    if (isOutputDOM()) {\n      const sectionId = getSectionId(tag);\n      const binding = tagVar.extra.reserve;\n      const referenceGroup = getReferenceGroup(sectionId, binding);\n      addStatement(\"apply\", sectionId, defaultAttr.extra?.valueReferences, t30.expressionStatement(t30.callExpression(referenceGroup.apply, [\n        scopeIdentifier,\n        defaultAttr.value\n      ])));\n      replaceAssignments(tag.scope.getBinding(binding.name), (assignment, value) => callQueue(referenceGroup, binding, value, getSectionId(assignment)));\n    } else {\n      translateVar(tag, defaultAttr.value);\n    }\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a mutable binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#let\"\n    }\n  ]\n};\n\n// src/core/set.ts\nimport { types as t31 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams9, assertNoVar as assertNoVar7 } from \"@marko/babel-utils\";\nvar set_default = {\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n      const { node } = tag;\n      const [defaultAttr] = node.attributes;\n      if (!node.body.body.length) {\n        throw tag.buildCodeFrameError(`The '<set>' tag requires body content that the context is forwarded through.`);\n      }\n      if (!t31.isMarkoAttribute(defaultAttr) || !defaultAttr.default) {\n        throw tag.get(\"name\").buildCodeFrameError(`The '<set>' tag requires default attribute like '<set=val>'.`);\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<set>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n        }\n      }\n      tag.insertBefore(t31.expressionStatement(callRuntime(\"pushContext\", t31.stringLiteral(tag.hub.file.metadata.marko.id), defaultAttr.value)));\n    },\n    exit(tag) {\n      assertNoParams9(tag);\n      assertNoVar7(tag);\n      if (isOutputHTML()) {\n        flushInto(tag);\n      }\n      tag.insertAfter(t31.expressionStatement(callRuntime(\"popContext\")));\n      tag.replaceWithMultiple(tag.node.body.body);\n    }\n  },\n  autocomplete: [\n    {\n      displayText: \"set=<value>\",\n      description: \"Sets a value which can be read from a child template.\",\n      snippet: \"set=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#set\"\n    }\n  ]\n};\n\n// src/core/style.ts\nimport path2 from \"path\";\nimport { assertNoParams as assertNoParams10, assertNoVar as assertNoVar8 } from \"@marko/babel-utils\";\nimport { types as t32 } from \"@marko/compiler\";\nvar style_default = {\n  translate(tag) {\n    const {\n      hub: { file }\n    } = tag;\n    assertNoVar8(tag);\n    assertNoParams10(tag);\n    assertNoSpreadAttrs(tag);\n    let type = \"text/css\";\n    const attrs = tag.get(\"attributes\");\n    const base = path2.basename(file.opts.sourceFileName);\n    const typeAttr = attrs.find((attr) => attr.isMarkoAttribute() && attr.node.name === \"type\");\n    if (typeAttr) {\n      const typeValue = typeAttr.get(\"value\");\n      if (typeValue.isStringLiteral()) {\n        type = typeValue.node.value;\n      } else {\n        throw typeValue.buildCodeFrameError(`<style> \"type\" attribute can only be a string literal.`);\n      }\n    }\n    if (type === \"text/css\") {\n      type = \"css\";\n    }\n    const body = tag.get(\"body\").get(\"body\");\n    const markoText = body[0];\n    if (body.length !== 1 || !markoText.isMarkoText()) {\n      throw (markoText.isMarkoText() ? body[1] : body[0]).buildCodeFrameError(\"The '<style>' tag currently only supports static content.\");\n    }\n    const { resolveVirtualDependency } = getMarkoOpts();\n    if (resolveVirtualDependency) {\n      const importPath = resolveVirtualDependency(file.opts.filename, {\n        type,\n        code: markoText.node.value,\n        startPos: markoText.node.start,\n        endPos: markoText.node.end,\n        path: `./${base}`,\n        virtualPath: `./${base}.${type}`\n      });\n      currentProgramPath.pushContainer(\"body\", t32.importDeclaration([], t32.stringLiteral(importPath)));\n    }\n    tag.remove();\n  },\n  attributes: {\n    type: { enum: [\"css\", \"less\", \"scss\", \"text/css\"] }\n  }\n};\n\n// src/core/tag.ts\nimport { types as t33 } from \"@marko/compiler\";\nvar tag_default2 = {\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n      if (!tag.node.var) {\n        throw tag.get(\"name\").buildCodeFrameError(\"<tag> requires a variable to be defined, eg <tag/NAME>.\");\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        flushInto(tag);\n      }\n      tag.replaceWith(t33.variableDeclaration(\"const\", [\n        t33.variableDeclarator(tag.node.var, t33.arrowFunctionExpression(tag.node.body.params, toFirstExpressionOrBlock(tag.node.body)))\n      ]));\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"tag/<name>|<params>|\",\n      description: \"Creates a reusable fragment within the template.\",\n      snippet: \"tag/${1:name}|${2:param1, param2}|\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#tag\"\n    }\n  ]\n};\n\n// src/core/yield.ts\nimport { types as t34 } from \"@marko/compiler\";\nimport { assertNoVar as assertNoVar9, assertNoParams as assertNoParams11 } from \"@marko/babel-utils\";\nvar RETURN_IDENTIFIERS = /* @__PURE__ */ new WeakMap();\nvar yield_default = {\n  translate(tag) {\n    assertNoVar9(tag);\n    assertNoParams11(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    flushBefore(tag);\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const [defaultAttr, onNextAttr] = node.attributes;\n    if (!t34.isMarkoAttribute(defaultAttr) || !defaultAttr.default) {\n      throw tag.get(\"name\").buildCodeFrameError(`The '<yield>' tag requires default attribute like '<yield=VALUE>'.`);\n    }\n    if (onNextAttr && onNextAttr.name === \"onnext\") {\n      if (isOutputHTML()) {\n        tag.get(\"attributes\")[1].remove();\n      }\n    }\n    if (node.attributes.length > 1) {\n      const start = node.attributes[1].loc?.start;\n      const end = node.attributes[node.attributes.length - 1].loc?.end;\n      const msg = `The '<yield>' tag only supports a default attribute.`;\n      if (start == null || end == null) {\n        throw tag.get(\"name\").buildCodeFrameError(msg);\n      } else {\n        throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n      }\n    }\n    let returnId = RETURN_IDENTIFIERS.get(file);\n    if (!returnId) {\n      const program = file.path;\n      RETURN_IDENTIFIERS.set(file, returnId = program.scope.generateDeclaredUidIdentifier(\"return\"));\n      program.pushContainer(\"body\", t34.returnStatement(returnId))[0].skip();\n    }\n    if (isOutputHTML()) {\n      tag.replaceWith(t34.assignmentExpression(\"=\", returnId, defaultAttr.value))[0].skip();\n    }\n  },\n  autocomplete: [\n    {\n      displayText: \"yield=<value>\",\n      description: \"Provides a value for use in a parent template.\",\n      snippet: \"yield=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#yield\"\n    }\n  ]\n};\n\n// src/core/static.ts\nimport { types as t35 } from \"@marko/compiler\";\nimport { parseScript as parseScript3 } from \"@marko/babel-utils\";\nvar static_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^static\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let { body } = parseScript3(file, code, start);\n    if (body.length === 1 && t35.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(t35.markoScriptlet(body, true));\n  },\n  \"parse-options\": {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"static <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#static-javascript\"\n    }\n  ]\n};\n\n// src/core/noop.ts\nvar noop_default = {\n  migrate: [(tag) => tag.remove()]\n};\n\n// src/core/__flush_here_and_after__.ts\nvar flush_here_and_after_default = {\n  migrate: [\n    (tag) => {\n      tag.replaceWithMultiple(tag.node.body.body);\n      currentProgramPath.scope.crawl();\n    }\n  ]\n};\n\n// src/core/index.ts\nvar core_default = {\n  taglibId,\n  \"<import>\": import_default,\n  \"<export>\": export_default,\n  \"<attrs>\": attrs_default,\n  \"<if>\": if_default,\n  \"<else-if>\": else_if_default,\n  \"<else>\": else_default,\n  \"<for>\": for_default,\n  \"<let>\": let_default,\n  \"<const>\": const_default,\n  \"<effect>\": effect_default,\n  \"<html-comment>\": html_comment_default,\n  \"<tag>\": tag_default2,\n  \"<set>\": set_default,\n  \"<get>\": get_default,\n  \"<yield>\": yield_default,\n  \"<style>\": style_default,\n  \"<await-reorderer>\": noop_default,\n  \"<init-widgets>\": noop_default,\n  \"<init-components>\": noop_default,\n  \"<static>\": static_default,\n  \"<__flush_here_and_after__>\": flush_here_and_after_default\n};\n\n// src/visitors/referenced-identifier.ts\nimport { types as t36 } from \"@marko/compiler\";\nvar outGlobalIdentifiers = /* @__PURE__ */ new WeakMap();\nvar hasAttrsTag = /* @__PURE__ */ new WeakSet();\nvar referenced_identifier_default = {\n  migrate(identifier) {\n    const { name } = identifier.node;\n    if (identifier.scope.hasBinding(name))\n      return;\n    switch (identifier.node.name) {\n      case \"input\": {\n        if (!hasAttrsTag.has(currentProgramPath)) {\n          hasAttrsTag.add(currentProgramPath);\n          insertAfterStatic(t36.markoTag(t36.stringLiteral(\"attrs\"), void 0, t36.markoTagBody(), void 0, identifier.node));\n        }\n        break;\n      }\n      case \"out\":\n        if (t36.isMemberExpression(identifier.parent) && t36.isIdentifier(identifier.parent.property) && identifier.parent.property.name === \"global\") {\n          let globalIdentifier = outGlobalIdentifiers.get(currentProgramPath);\n          if (!globalIdentifier) {\n            globalIdentifier = currentProgramPath.scope.generateUidIdentifier(\"$global\");\n            outGlobalIdentifiers.set(currentProgramPath, globalIdentifier);\n            insertAfterStatic(t36.markoTag(t36.stringLiteral(\"get\"), void 0, t36.markoTagBody(), void 0, globalIdentifier));\n          }\n          identifier.parentPath.replaceWith(globalIdentifier);\n        } else {\n          throw identifier.buildCodeFrameError(\"Only out.global is supported for compatibility.\");\n        }\n        break;\n    }\n  }\n};\nfunction insertAfterStatic(node) {\n  for (const child of currentProgramPath.get(\"body\")) {\n    if (!isStatic(child)) {\n      child.insertBefore(node);\n      return;\n    }\n  }\n  currentProgramPath.unshiftContainer(\"body\", node);\n}\n\n// src/index.ts\nvar visitors = {\n  Program: program_default,\n  ReferencedIdentifier: referenced_identifier_default,\n  ImportDeclaration: import_declaration_default,\n  MarkoDocumentType: document_type_default,\n  MarkoDeclaration: declaration_default,\n  MarkoCDATA: cdata_default,\n  MarkoText: text_default,\n  MarkoTag: tag_default,\n  MarkoPlaceholder: placeholder_default,\n  MarkoScriptlet: scriptlet_default,\n  MarkoComment: comment_default\n};\nvar getVisitorOfType = (typename) => Object.entries(visitors).reduce((visitor, [name, value]) => {\n  if (typename in value) {\n    visitor[name] = value[typename];\n  }\n  return visitor;\n}, {});\nvar analyze = getVisitorOfType(\"analyze\");\nvar translate = getVisitorOfType(\"translate\");\nvar taglibs = [\n  [\n    __dirname,\n    {\n      ...core_default,\n      migrate: getVisitorOfType(\"migrate\")\n    }\n  ]\n];\nexport {\n  analyze,\n  taglibs,\n  translate\n};\n//# sourceMappingURL=index.esm.js.map\n","import * as fluurtTranslator from \"../../../../../browser-shims/v6/translator\"\n\n<hash-value/files = [{ \n  name:\"index.marko\", \n  path:\"/components/index.marko\", \n  content:\"<let/count=0/>\\n<button onclick() { count++ }>\\n  ${count}\\n</button>\"\n}]/>\n<repl getTranslator() { return fluurtTranslator } files:=files/>","import { register, init } from \"marko/dist/runtime/components/index.js\";\nimport \"../../../components/app-layout/style.css\";\nimport \"../../../components/app-layout/favicon.png\";\nimport \"../../../components/app-layout/components/skip-link/index.marko.css!=!/Users/dpiercey/dev/marko-js/website/node_modules/@marko/webpack/dist/loader/index.js!/Users/dpiercey/dev/marko-js/website/src/components/app-layout/components/skip-link/index.marko?virtual=./index.marko.css\";\nimport \"../../../components/app-layout/components/layout-header/style.css\";\nimport \"../../../logos/marko.svg\";\nimport \"../../../components/app-layout/components/layout-search/style.css\";\nimport component_0 from \"../../../components/app-layout/components/layout-header/component-browser.js\";\nregister(\"OIKmBXjW\", component_0);\nimport \"../../../components/app-layout/components/layout-sidebar/style.css\";\nimport component_1 from \"../../../components/app-layout/components/layout-sidebar/components/version-switcher/component-browser.js\";\nregister(\"07hv1F0+\", component_1);\nimport component_2 from \"../../../components/app-layout/components/layout-sidebar/component-browser.js\";\nregister(\"mFesaajv\", component_2);\nimport \"../../../components/app-footer/style.css\";\nimport \"../../../components/app-footer/openjsf.svg\";\nimport \"../../../components/app-footer/osi.svg\";\nimport \"../../../components/app-footer/ebay.svg\";\nimport \"../../../components/discord-link/index.marko.css!=!/Users/dpiercey/dev/marko-js/website/node_modules/@marko/webpack/dist/loader/index.js!/Users/dpiercey/dev/marko-js/website/src/components/discord-link/index.marko?virtual=./index.marko.css\";\nimport \"../../../logos/discord.svg\";\nimport \"./components/playground-6.marko\";\ninit();","module.exports = require(\"../../../../node_modules/@marko/compiler/dist/babel-types\");\n","// We don't bring in the full Marko compiler, but the ast types are needed.\nexports.types = require(\"./dist/babel-types\");\n","module.exports = require(\"memfs\");\n","const path = require(\"path\");\nconst resolve = require(\"resolve\");\nconst resolveExports = require(\"resolve.exports\");\n\nconst Module = {\n  _nodeModulePaths: nodeModulePaths,\n  _resolveFilename: function (target, fromModule) {\n    return resolve.sync(target, {\n      basedir: path.dirname(fromModule.filename),\n      paths: fromModule.paths,\n      extensions: [\".js\", \".json\", \".marko\", \".mjs\"],\n      pathFilter(pkg, _, relativePath) {\n        if (/^index(\\.[^/\\\\]+)?$/.test(relativePath)) {\n          try {\n            return resolveExports.legacy(pkg, Module._resolveExportsOptions);\n          } catch {}\n        } else {\n          try {\n            return resolveExports.resolve(\n              pkg,\n              relativePath,\n              Module._resolveExportsOptions\n            );\n          } catch {}\n        }\n\n        return relativePath;\n      },\n    });\n  },\n  _resolveExportsOptions: {\n    browser: true,\n  },\n};\n\nmodule.exports = Module;\n\nfunction nodeModulePaths(dir) {\n  const paths = [];\n\n  while (true) {\n    const parentDir = path.dirname(dir);\n    paths.push(path.join(dir, \"node_modules\"));\n\n    if (!parentDir || parentDir === dir) {\n      break;\n    }\n\n    dir = parentDir;\n  }\n\n  return paths;\n}\n","module.exports = {\n  env: {},\n  browser: true,\n  cwd() {\n    return \"/\"\n  }\n}","var siteHeaderEvents = require(\"./events\");\n\nvar classNames = {\n  base: \"headspace\",\n  fixed: \"headspace--fixed\",\n  hidden: \"headspace--hidden\"\n};\nvar debounce = cb => () => window.requestAnimationFrame(cb);\nvar tolerance = 3;\n\nmodule.exports = {\n  onMount() {\n    siteHeaderEvents.emit(\"create\", this);\n    var scrollLast = 0;\n    var startOffset = this.getEl('header').offsetHeight;\n    var bannerHeight = (this.getEl('banner') || { offsetHeight:0 }).offsetHeight;\n\n    var handleScroll = debounce(() => {\n      var scrollCurrent = window.pageYOffset;\n\n      if (scrollCurrent <= bannerHeight) {\n        this.reset();\n      } else if (!this.paused && scrollCurrent > startOffset) {\n        var toleanceReached = Math.abs(scrollCurrent - scrollLast) >= tolerance;\n        var scrollingDown = scrollCurrent > scrollLast;\n        var wasAtTop = scrollLast <= startOffset;\n        if (toleanceReached || (scrollingDown && wasAtTop)) {\n          scrollCurrent > scrollLast ? this.hide() : this.fix();\n        }\n      }\n\n      scrollLast = scrollCurrent;\n    });\n\n    handleScroll();\n    window.addEventListener(\"scroll\", handleScroll);\n  },\n  reset() {\n    this.removeClass(classNames.fixed);\n    this.removeClass(classNames.hidden);\n    siteHeaderEvents.emit(\"reset\");\n  },\n  fix() {\n    this.addClass(classNames.fixed);\n    this.removeClass(classNames.hidden);\n    siteHeaderEvents.emit(\"fix\");\n  },\n  hide() {\n    this.addClass(classNames.hidden);\n    siteHeaderEvents.emit(\"hide\");\n  },\n  addClass(cls) {\n    this.getEl('header').classList.add(cls);\n  },\n  removeClass(cls) {\n    this.getEl('header').classList.remove(cls);\n  },\n  pause() {\n    this.paused = true;\n  },\n  resume() {\n    setTimeout(() =>\n      window.requestAnimationFrame(() => {\n        this.paused = false;\n      })\n    );\n  },\n  toggleMenu () {\n    siteHeaderEvents.emit('toggle-menu');\n  }\n};\n","// TODO: remove this.\nvar EventEmitter = require(\"events\");\n\nmodule.exports = new EventEmitter();\n","var siteHeaderEvents = require(\"../layout-header/events\");\nvar forEach = [].forEach;\nvar filter = [].filter;\nvar slice = [].slice;\nvar siteHeaderComponent;\n\nmodule.exports = {\n  onMount() {\n    this.preventOverscroll();\n    this.listenForHeaderChanges();\n    this.initScrollSpy();\n  },\n\n  initScrollSpy() {\n    var headersSelector = [1, 2, 3, 4, 5, 6]\n      .map(n => \".doc-content h\" + n)\n      .join(\",\");\n    var headers = slice.call(document.querySelectorAll(headersSelector));\n    var waiting = false;\n\n    headers.length &&\n      this.subscribeTo(window).on(\"scroll\", () => {\n        if (!waiting) {\n          waiting = true;\n          setTimeout(() => {\n            var threshold = window.innerHeight / 3;\n            var closestHeader;\n            var closestTop;\n\n            headers.map(header => {\n              var top = header.getBoundingClientRect().top;\n              if (\n                closestTop == null ||\n                (top < threshold && Math.abs(top) < Math.abs(closestTop))\n              ) {\n                closestTop = top;\n                closestHeader = header;\n              }\n            });\n\n            var anchor = closestHeader.id;\n            var anchorEl =\n              this.el.querySelector('a[href=\"#' + anchor + '\"]') ||\n              this.el.querySelector(\"a.selected\");\n            var targetAnchor = anchorEl;\n            var childList = targetAnchor.nextSibling;\n\n            if (childList) {\n              forEach.call(childList.querySelectorAll(\"a[href^=\\\\#]\"), a =>\n                a.classList.remove(\"selected\")\n              );\n            }\n\n            while (targetAnchor) {\n              var parentList = targetAnchor.closest(\"ul\");\n              var siblings =\n                parentList &&\n                filter.call(\n                  parentList.querySelectorAll(\":scope > li > a[href^=\\\\#]\"),\n                  a => a !== targetAnchor\n                );\n              siblings && siblings.forEach(a => a.classList.remove(\"selected\"));\n              targetAnchor.classList.add(\"selected\");\n              targetAnchor = parentList && parentList.previousElementSibling;\n            }\n\n            this.scrollAnchorIntoView(anchorEl);\n\n            waiting = false;\n          }, 50);\n        }\n      });\n  },\n\n  listenForHeaderChanges() {\n    forEach.call(this.el.querySelectorAll(\"a[href^=\\\\#]\"), a => {\n      this.subscribeTo(a).on(\"click\", () => {\n        siteHeaderComponent.hide();\n        siteHeaderComponent.pause();\n        siteHeaderComponent.resume();\n        this.hide();\n      });\n    });\n\n    // handles nested selected links\n    var selectedLink = slice.call(this.el.querySelectorAll(\"a.selected\")).pop();\n\n    selectedLink &&\n      this.subscribeTo(selectedLink).on(\"click\", e => {\n        window.scrollTo(0, 0);\n        siteHeaderComponent.reset();\n        e.preventDefault();\n      });\n\n    this.subscribeTo(siteHeaderEvents)\n      .on(\"reset\", () => {\n        this.el.classList.remove(\"no-header\");\n        this.el.classList.remove(\"fixed\");\n        setTimeout(() => this.el.classList.remove(\"transition\"), 0);\n      })\n      .on(\"fix\", () => {\n        this.el.classList.remove(\"no-header\");\n        this.el.classList.add(\"fixed\");\n        setTimeout(() => this.el.classList.add(\"transition\"), 0);\n      })\n      .on(\"hide\", () => {\n        this.el.classList.add(\"no-header\");\n        this.el.classList.add(\"fixed\");\n        setTimeout(() => this.el.classList.add(\"transition\"), 0);\n      })\n      .on(\"toggle-menu\", () => {\n        if (this.el.classList.contains(\"show\")) {\n          this.el.classList.remove(\"show\");\n          document.body.style.overflow = \"\";\n        } else {\n          this.el.classList.add(\"show\");\n        }\n      })\n      .on(\"create\", _siteHeaderComponent => {\n        siteHeaderComponent = _siteHeaderComponent;\n\n        if (window.pageYOffset > siteHeaderComponent.el.offsetHeight) {\n          this.el.classList.add(\"no-header\");\n          this.el.classList.add(\"fixed\");\n        }\n      });\n  },\n\n  preventOverscroll() {\n    var sidebar = this.getEl(\"sidebar\");\n    this.subscribeTo(document.body).on(\"wheel\", e => {\n      var delta = e.deltaY;\n      var scrollTarget = sidebar.scrollTop + delta;\n      var topY = 0;\n      var bottomY = sidebar.scrollHeight - sidebar.offsetHeight;\n      var atTop = scrollTarget <= topY;\n      var atBottom = scrollTarget >= bottomY;\n\n      if ((delta < 0 && atTop) || (delta > 0 && atBottom)) {\n        if (e.target === sidebar || sidebar.contains(e.target)) {\n          if (atTop && sidebar.scrollTop != topY) {\n            sidebar.scrollTop = topY;\n          } else if (atBottom && sidebar.scrollTop != bottomY) {\n            sidebar.scrollTop = bottomY;\n          }\n          e.preventDefault();\n        }\n      }\n    });\n  },\n\n  scrollAnchorIntoView(anchorEl) {\n    var sidebar = this.getEl(\"sidebar\");\n    var anchorTop = anchorEl.offsetTop;\n    var sidebarScrollTop = sidebar.scrollTop;\n    var sidebarHeight = sidebar.offsetHeight;\n    var sidebarScrollBottom = sidebarScrollTop + sidebarHeight;\n\n    var targetList = anchorEl.closest(\"li\");\n    var parentList;\n\n    while (true) {\n      parentList = targetList.parentNode.closest(\"ul\");\n      if (parentList && parentList.offsetHeight < sidebarHeight) {\n        targetList = parentList;\n      } else {\n        break;\n      }\n    }\n\n    var targetTop = targetList.offsetTop;\n    var targetHeight = targetList.offsetHeight;\n    var targetBottom = targetTop + targetHeight;\n    var targetIsFullyVisible =\n      targetTop > sidebarScrollTop && targetBottom < sidebarScrollBottom;\n\n    if (!targetIsFullyVisible) {\n      sidebar.scrollTop = targetTop + targetHeight / 2 - sidebarHeight / 2;\n    }\n  },\n\n  hide() {\n    this.el.classList.remove(\"show\");\n    document.body.style.overflow = \"\";\n  }\n};\n","module.exports = {\n  switchVersion(e) {\n    var location = e.target.value;\n    if (location !== \"current\") {\n      e.target.value = \"current\";\n      window.location.href = location;\n    }\n  }\n};\n","export default __webpack_public_path__ + \"339b8a9e.svg\";","export default __webpack_public_path__ + \"6876aea9.svg\";","export default __webpack_public_path__ + \"1b70b500.svg\";","export default __webpack_public_path__ + \"d78b83f1.png\";","export default __webpack_public_path__ + \"78800ea4.svg\";","export default __webpack_public_path__ + \"91bc26e5.svg\";"],"names":["files","externalFiles","selectedIndex","externalSelected","selectedFile","nextId","file","index","editing","selected","mutable","d","name","finishRename","modifiedFile","path","replace","slice","nameInput","length","e","code","focus","setSelectionRange","indexOf","window","confirm","stopPropagation","newFile","content","newIndex","concat","actions","body","renderBody","value","valueChange","class","className","el","target","attrs","compressToEncodedURIComponent","JSON","stringify","default","query","fallback","isMatch","matchMedia","matches","mq","listener","addEventListener","removeEventListener","left","right","editorSize","resizing","isVertical","container","preventDefault","handler","buttons","which","rect","getBoundingClientRect","fraction","clientY","top","height","clientX","width","Math","min","max","getTranslator","previewType","debounce","activeEditor","async","loading","preview","defaultValue","parse","decompressFromEncodedURIComponent","location","hash","console","error","this","isUpdating","removevEventListener","x","__require","Error","Proxy","get","a","b","isOutputHTML","getMarkoOpts","output","isOutputDOM","currentProgramPath","hub","markoOpts","createSortedCollection","compare","insert","data","val","immutable","Array","isArray","arr","len","pos","mid","compareResult","cur","next","insertInArray","find","findIndex","MARKO_FILE_REG","analyzeTagNameType","tag","extra","node","tagNameType","isStringLiteral","isNativeTag","tagNameNullable","pending","path3","type","nullable","pop","isConditionalExpression","push","alternate","isLogicalExpression","operator","isAssignmentExpression","isBinaryExpression","isTemplateLiteral","isNullLiteral","isIdentifier","binding","scope","getBinding","kind","decl","parent","test","source","specifiers","some","it","t","bindingTag","isMarkoTag","bindingTagName","defaultAttr","assignments","constantViolations","i","assignment","tagNameDynamic","startSection","sectionId","programExtra","sectionNameNode","sectionName","nextSectionId","sectionNames","generateUid","getOrCreateSectionId","parentPath","getSectionId","currentPath","createSectionState","key","init","arrayOfSectionData","state","forEachSectionId","fn","getReservesByType","reserveScope","size","reserve","reserve2","reservesByType","id","compareReserves","insertReserve","getReferenceGroups","count","references","apply","t2","hydrate","trackReferencesForBindings","reserveType","bindings","getBindingIdentifiers","referencePaths","insertReferenceGroup","reference","fnRoot","getFnRoot","exprRoot","getExprRoot","markoRoot","name2","isMarkoAttribute","updateReferenceGroup","listKey","extraKey","newBinding","currentGroup","newReferences","getOrCreateReferenceGroup","mergeReferenceGroups","groupEntries","group","newGroup","referenceGroups","existingGroup","findReferenceGroup","curPath","isMarkoPath","isProgram","isFunctionExpression","lenDelta","getReferenceGroup","lookup","analyze2","found","generateReferenceGroupName","ref","importRuntime","importNamed","getRuntimePath","callRuntime","args","t3","filter","Boolean","getHTMLRuntime","optimize","callRead","targetSectionId","getScopeExpression","diff","scopeIdentifier","getApplyStatements","getHydrateStatements","getQueueBuilder","_setQueueBuilder","setQueueBuilder","builder","addStatement","statement","statementsIndex","allStatements","statements","getHydrateRegisterId","opts","filename","getTemplateId","getClosurePriorities","addHTMLHydrateCall","writeHTMLHydrateStatements","unshiftContainer","t4","refs","pushContainer","reduce","acc","bindFunctionsVisitor","FunctionExpression","exit","bindFunction","ArrowFunctionExpression","root","functionIdentifier","generateUidIdentifier","unshift","map","insertBefore","params","replaceWith","getDefaultApply","firstApplyStatements","toTemplateOrStringLiteral","parts","strs","exprs","curStr","t5","nextIndex","exprLen","expressions","shiftItems","quasis","j","raw","appendLiteral","str","list","start","offset","getWalks","getWalkComment","getSteps","walkCodeToName","enter","enterShallow","visit","buildCodeFrameError","steps","walks","walkComment","writeTo","t6","walkString","walks2","depth","step","lastIndexOf","current","walk","nCodeString","String","fromCharCode","number","toCharString","startCode","rangeSize","result","multiplier","floor","getWalkString","walkLiteral","leadingComments","join","getRenderer","t7","getWrites","exprsLen","writes","consumeHTML","flushBefore","expr","skip","flushInto","getSectionMeta","isStatic","isImportDeclaration","isExportDeclaration","isMarkoScriptlet","static","html_default","translate","program","renderContent","child","replaceWithMultiple","remove","rendererId","t8","var","dom_default","templateIdentifier","t9","walksIdentifier","applyIdentifier","applyAttrsIdentifier","forEachSectionIdReverse","referenceGroup","identifier","fnPath","traverse","writeHydrateGroups","numReferenceGroups","queuePriority","factory","closurePriority","NaN","param","closurePriorities","writeApplyGroups","childRendererDeclarators","childSectionId","writes2","apply2","exportSpecifiers","Object","keys","bindingIdentifier","applyIdentifier2","exportIdentifier","previousProgramPath","WeakMap","program_default","migrate","set","crawl","analyze","curIndex","reserves","allReferenceGroups","g","forEach","finalizeReferences","t10","hasInteractiveChild","isInteractive","import_declaration_default","request","resolveTagImport","document_type_default","documentType","declaration_default","declaration","cdata_default","cdata","text_default","text","enter2","modulePlugin","plugin","isModulePlugin","isFunctionPlugin","t11","exit2","IDENTIFIER_REG","toPropertyName","t12","attrsToObject","withRenderBody","t13","resultExtra","attr","attributes","properties","hoistedControlFlows","isConditional","isLoop","prop","argument","getRenderBodyProp","attrsObject","lastProp","translateVar","initialValue","tagVar","t14","evaluate","confident","computed","native_tag_default","has","isSpreadAttr","attrNode","startsWith","isHTML","tagDef","getTagDef","hasSpread","isMarkoSpreadAttribute","write","visitIndex","t15","attrsCallExpr","extra2","valueReferences","helper","emptyBody","parseOptions","openTagOnly","htmlType","custom_tag_default","trackReferences","getTagDef2","template","childProgramExtra","loadFileForTag","ast","attrsReferences","tagSectionId","tagBody","tagBodySectionId","tagIdentifier","tagAttrsIdentifier","t16","tagName","tags","metadata","marko","relativePath","resolveRelativePath","childProgram","importDefault","importNamed2","childIndex","injectWalks","includes","renderBodyProp","renderBodyId","renderTagExpr","callExpression","renderBodyPath","callStatement","toFirstExpressionOrBlock","nodes","t17","expression","dynamic_tag_default","t18","fnExpr","dynamicTagExpr","attribute_tag_default","hasPendingHTML","assertNoVar","parentTag","findParentTag","parentExtra","attrName","info","nestedAttributeTags","t19","dynamic","repeated","existingAttr","analyzeAttributeTags","analyzeChildren","rootExtra","hasAttributeTags","analyzeChild","isTransparentTag","isLoopTag","isAttributeTag","existing","tag_default","hook","getTagDef3","analyzer","assertNoArgs","translator","watchFiles","arguments","modifier","isNativeTag2","tagNameId","tagNameVarPath","t20","taglibId","isCoreTag","getTagDef4","isCoreTagName","ESCAPE_TYPES","script","style","placeholder_default","placeholder","escape","prev","getPrevSibling","noOutput","t21","isNativeTag3","needsMarker","getNextSibling","canWriteHTML","method","getParentTagName","scriptlet_default","scriptlet","bodyReferences","ieConditionalCommentRegExp","comment_default","comment","import_default","parseScript","rawValue","rawOpenTag","autocomplete","displayText","description","snippet","descriptionMoreURL","export_default","parseScript2","attrs_default","varPath","toFirstStatementOrBlock","t22","if_default","exitBranchAnalyze","testAttr","assertNoVar2","assertNoParams","t23","loc","end","msg","buildError","exitBranchTranslate","BRANCHES_LOOKUP","getBranches","bodySectionId","branches","nextTag","isLast","conditionalReferences","tag2","sectionId2","curStatement","else_if_default","assertNoVar3","assertNoParams2","t24","else_default","assertNoVar4","assertNoParams3","assertNoSpreadAttrs","assertNoBodyContent","const_default","assertNoParams4","t25","identifiers","values","effect_default","assertNoParams5","t26","cleanupIndex","inlineStatements","node2","for_default","isOnlyChild","t27","getTagDef5","html","checkOnlyChild","hasParams","assertNoVar5","findName","assertAllowedAttributes","validateFor","translateHTML","translateDOM","of","in","to","from","ofAttr","byAttr","ofAttrValue","valParam","namePath","inAttr","fromAttr","toAttr","block","forNode","keyParam","loopParam","indexName","generateUidIdentifierBasedOnNode","stepAttr","stepValue","indexParam","stepsName","stepName","obj","get_default","assertNoParams6","refId","t28","defaultAttrValue","relativeReferencePath","resolveTagImport2","getTemplateId2","html_comment_default","assertNoVar6","assertNoParams7","assertNoAttributes","assertNoAttributeTags","let_default","assertNoParams8","t30","isUpdateExpression","t29","replaceAssignments","callQueue","set_default","t31","assertNoParams9","assertNoVar7","insertAfter","style_default","assertNoVar8","assertNoParams10","base","path2","sourceFileName","typeAttr","typeValue","markoText","isMarkoText","resolveVirtualDependency","importPath","startPos","endPos","virtualPath","t32","enum","tag_default2","t33","RETURN_IDENTIFIERS","noop_default","core_default","assertNoVar9","assertNoParams11","onNextAttr","t34","returnId","generateDeclaredUidIdentifier","trim","parseScript3","t35","outGlobalIdentifiers","hasAttrsTag","WeakSet","insertAfterStatic","visitors","Program","ReferencedIdentifier","hasBinding","add","t36","property","globalIdentifier","ImportDeclaration","MarkoDocumentType","MarkoDeclaration","MarkoCDATA","MarkoText","MarkoTag","MarkoPlaceholder","MarkoScriptlet","MarkoComment","getVisitorOfType","typename","entries","visitor","taglibs","fluurtTranslator","register","module","exports","types","require","resolve","resolveExports","Module","_nodeModulePaths","dir","paths","parentDir","dirname","_resolveFilename","fromModule","sync","basedir","extensions","pathFilter","pkg","_","legacy","_resolveExportsOptions","browser","env","cwd","siteHeaderEvents","classNames","onMount","emit","cb","scrollLast","startOffset","getEl","offsetHeight","bannerHeight","handleScroll","scrollCurrent","pageYOffset","reset","paused","abs","hide","fix","requestAnimationFrame","removeClass","addClass","cls","classList","pause","resume","setTimeout","toggleMenu","EventEmitter","siteHeaderComponent","preventOverscroll","listenForHeaderChanges","initScrollSpy","headersSelector","n","headers","call","document","querySelectorAll","waiting","subscribeTo","on","closestHeader","closestTop","threshold","innerHeight","header","anchor","anchorEl","querySelector","targetAnchor","childList","nextSibling","parentList","closest","siblings","previousElementSibling","scrollAnchorIntoView","selectedLink","scrollTo","contains","overflow","_siteHeaderComponent","sidebar","delta","deltaY","scrollTarget","scrollTop","bottomY","scrollHeight","atTop","atBottom","sidebarScrollTop","offsetTop","sidebarHeight","sidebarScrollBottom","targetList","parentNode","targetTop","targetHeight","switchVersion","href"],"sourceRoot":""}