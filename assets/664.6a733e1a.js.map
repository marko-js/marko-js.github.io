{"version":3,"file":"664.6a733e1a.js","mappings":"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","sources":["webpack:///../components/repl/components/Users/mirawlings/dev/marko-js/website/src/components/repl/components/file-tabs.marko","webpack:///../components/repl/components/Users/mirawlings/dev/marko-js/website/src/components/repl/components/pane.marko","webpack:///../components/repl/components/Users/mirawlings/dev/marko-js/website/src/components/repl/components/controllable-select.marko","webpack:///../components/repl/components/Users/mirawlings/dev/marko-js/website/src/components/repl/components/playground-link.marko","webpack:///../components/repl/components/Users/mirawlings/dev/marko-js/website/src/components/repl/components/match-media.marko","webpack:///../components/repl/components/Users/mirawlings/dev/marko-js/website/src/components/repl/components/resizable-panes.marko","webpack:///../components/repl/Users/mirawlings/dev/marko-js/website/src/components/repl/index.marko","webpack:///./playground/components/Users/mirawlings/dev/marko-js/website/src/pages/playground/components/hash-value.marko","webpack:///../../browser-shims/v6/translator.js","webpack:///./playground/v6/components/Users/mirawlings/dev/marko-js/website/src/pages/playground/v6/components/playground-6.marko","webpack:///./playground/v6/index.marko","webpack:///../../browser-shims/compiler/dist/babel-types/index.js","webpack:///../../browser-shims/compiler/index.js","webpack:///../../browser-shims/fs.js","webpack:///../../browser-shims/module.js","webpack:///../../browser-shims/process.js","webpack:///../components/app-layout/components/layout-header/component-browser.js","webpack:///../components/app-layout/components/layout-header/events.js","webpack:///../components/app-layout/components/layout-sidebar/component-browser.js","webpack:///../components/app-layout/components/layout-sidebar/components/version-switcher/component-browser.js","webpack:///../components/app-footer/ebay.svg","webpack:///../components/app-footer/openjsf.svg","webpack:///../components/app-footer/osi.svg","webpack:///../components/app-layout/favicon.png","webpack:///../logos/discord.svg","webpack:///../logos/marko.svg"],"sourcesContent":["<attrs/{ files: externalFiles, selectedIndex: externalSelected }/>\n\n<let/files := externalFiles/>\n<let/selectedIndex := externalSelected/>\n\n<const/selectedFile = files[selectedIndex]/>\n\n<div.file-tabs>\n  <let/nextId = 1/>\n  <for|file, index| of=files>\n    <let/editing = false/>\n    <const/selected = selectedFile === file/>\n    <const/mutable = (index > 0)/>\n    <div.file-tab class={ selected } onClick() { \n      if (selected) {\n        editing = true;\n      } else {\n        editing = false;\n        selectedIndex = index;\n      }\n    }>\n      <if=(!editing || !selected || !mutable)>\n        ${file.name}\n      </if>\n      <else>\n        <let/name = file.name/>\n        <const/finishRename() {\n          const modifiedFile = { ...file, name, path: file.path.replace(file.name, name) };\n          files = [\n            ...files.slice(0, index), \n            modifiedFile,\n            ...files.slice(index+1)\n          ];\n          editing = false;\n        }/>\n        <input/nameInput \n          type=\"text\" \n          size=name.length \n          value:=name \n          onBlur=finishRename\n          onKeydown(e) {\n            if (e.code === \"Enter\") {\n              finishRename();\n            }\n          }/>\n        <lifecycle onMount() { \n          nameInput().focus();\n          nameInput().setSelectionRange(0, name.indexOf(\".\"));\n        }/>\n      </else>\n      <if=mutable>\n        <button.file-close onClick(e) { \n          if (window.confirm(`Delete ${file.path}?`)) {\n            if (selectedIndex >= index) {\n              selectedIndex--;\n            }\n            files = [...files.slice(0, index), ...files.slice(index+1)];\n          }\n          e.stopPropagation();\n        }>\n          &times;\n        </button>\n      </if>\n    </div>\n  </for>\n  <button.new-file onClick() { \n    const newFile = { name:`Component${nextId}.marko`, path:`/components/Component${nextId}.marko`, content:\"\" };\n    const newIndex = files.length;\n    files = files.concat(newFile);\n    selectedIndex = newIndex;\n    nextId++;\n  }>\n    +\n  </button>\n</div>\n<style>\n  .file-tabs {\n    display:flex;\n    overflow-x: auto;\n    width:100%;\n    height:100%;\n  }\n  .file-tab {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: 100%;\n    padding:0 1em;\n    flex-shrink: 0;\n    border-bottom: 2px solid transparent;\n    cursor:pointer;\n  }\n  .file-tab:not(.selected):hover {\n    background: rgba(255,255,255,0.1);\n  }\n  .file-tab.selected {\n    border-bottom: 2px solid #09bcf8;\n  }\n  .file-close {\n    padding:0.5em;\n    background: transparent;\n    margin-right:-0.5em;\n    color:#fff;\n    cursor: pointer;\n    line-height: normal;\n    border: 0;\n  }\n  .file-close:hover {\n    color:#f1195b;\n  }\n  .new-file {\n    padding:0 1em;\n    font-size: 1.5em;\n    background: transparent;\n    color:#999;\n    cursor: pointer;\n    line-height: normal;\n    border: 0;\n  }\n  .new-file:hover {\n    color: #09bcf8;\n  }\n</style>","<attrs/{ actions, body }/>\n\n<div.pane>\n  <div.pane-actions>\n    <${actions.renderBody}/>\n  </div>\n  <div.pane-divider/>\n  <div.pane-body>\n    <${body.renderBody}/>\n  </div>\n</div>\n\n<style>\n  .pane {\n    display:flex;\n    flex-direction: column;\n    flex:1;\n  }\n  .pane-actions {\n    height: 3em;\n  }\n  .pane-divider {\n    height:1px;\n    background: rgba(0,0,0,0.2);\n  }\n  .pane-body {\n    flex:1;\n    flex-basis: 0;\n    overflow: auto;\n  }\n</style>\n","<attrs/{ value, valueChange, renderBody, class:className }/>\n<select/el class=className onChange(e) { valueChange(e.target.value); }>\n  <${renderBody}/>\n</select>\n<effect() {\n  el().value = value;\n  // TODO: this should not be necessary\n  // but re-rendering the parent component causes new closures\n  // to be passed for renderBody and valueChange which causes\n  // this component to re-render.  Morphdom sets the <select>\n  // back to the original value.  So we track those values as well,\n  // so we can re-set the <select>'s value.\n  renderBody; valueChange;\n}/>","import { compressToEncodedURIComponent } from \"lz-string\";\n\n<attrs/{ files, ...attrs }/>\n<a.playground-link ...attrs\n  href=`/playground/#${compressToEncodedURIComponent(JSON.stringify(files))}`\n  target=\"_top\">\n  <span>Open in playground </span>↗\n</a>\n\n<style>\n  .playground-link {\n    float:right;\n    padding: 0.8em 1em;\n    display:block;\n    position: relative;\n  }\n  .playground-link span {\n    display:none;\n    position:absolute;\n    right: 1em;\n    width: 10em;\n  }\n  .playground-link:hover span {\n    display:inline;\n  }\n</style>\n\n","<attrs/{ value: query, fallback }/>\n<let/isMatch = typeof window !== \"undefined\" ? window.matchMedia(query).matches : fallback/>\n\n<effect() {\n  const mq = window.matchMedia(query);\n  const listener = () => isMatch = !!mq.matches;\n  mq.addEventListener(\"change\", listener);\n  isMatch = !!mq.matches;\n  return () => mq.removeEventListener(\"change\", listener);\n}/>\n\n<return=isMatch/>","<attrs/{ left, right }/>\n\n<let/editorSize=0.5/>\n<let/resizing = false/>\n<match-media/isVertical = \"(max-aspect-ratio: 1/1)\"/>\n\n<div/container class=[\"panes\", resizing && \"resizing\"]>\n  <div ...left style=`flex-grow:${editorSize}`>\n    <${left.renderBody}/>\n  </div>\n  <div.divider>\n    <div.inner\n      onMousedown(e) {\n        resizing = true;\n        e.preventDefault();\n        e.stopPropagation();\n      }/>\n  </div>\n  <div ...right style=`flex-grow:${1-editorSize}`>\n    <${right.renderBody}/>\n  </div>\n</div>\n<if=resizing>\n  <effect() {\n    const handler = (e) => {\n      if (e.buttons || e.which) {\n        const rect = container().getBoundingClientRect();\n        const fraction = isVertical \n          ? (e.clientY - rect.top) / rect.height \n          : (e.clientX - rect.left) / rect.width;\n        if (fraction > 0) {\n          // it seems a drag event with no position is fired when we stop\n          // so we'll ignore that value\n          editorSize = Math.min(0.8, Math.max(0.2, fraction));\n        }\n      } else {\n        resizing = false;\n      }\n    };\n    window.addEventListener(\"mousemove\", handler);\n    return () => window.removeEventListener(\"mousemove\", handler);\n  }/>\n</if>\n\n<style>\n  .panes {\n    display:flex;\n    flex:1;\n    width: 100%;\n  }\n  .panes > div {\n    overflow:hidden;\n    display: flex;\n    flex-basis:0;\n  }\n  .panes.resizing {\n    cursor: col-resize;\n  }\n  .panes.resizing > div:not(.divider) {\n    pointer-events: none;\n  }\n  .divider {\n    min-height: 2px;\n    min-width: 2px;\n    position:relative;\n    background:#eee;\n    cursor: col-resize;\n  }\n  .divider:hover {\n    background:#ccc;\n  }\n  .divider .inner {\n    position: absolute;\n    top:-10px; left: -10px; bottom:-10px; right:-10px;\n    opacity: 0;\n    z-index:1000;\n  }\n  @media (max-aspect-ratio: 1/1) {\n    .panes {\n      flex-direction: column;\n    }\n    .panes.resizing,\n    .divider:hover {\n      cursor: row-resize;\n    }\n  }\n</style>","<attrs/{ getCompilerOptions, files }/>\n<let/selectedIndex = 0/>\n<let/previewType = \"preview\"/>\n<let/debounce = false/>\n<const/selectedFile = files[selectedIndex]/>\n\n<style>\n  .editor-container {\n    background: #202134;\n    color: #fff;\n  }\n</style>\n\n<resizable-panes>\n  <@left class=\"editor-container\">\n    <pane>\n      <@actions>\n        <file-tabs files:=files selectedIndex:=selectedIndex/>\n      </@actions>\n      <@body>\n        <let/activeEditor = null/>\n        <if=activeEditor>\n          <activeEditor\n            value=selectedFile.content \n            filename=selectedFile.path \n            valueChange(content) {\n              const modifiedFile = { ...selectedFile, content };\n              files = [\n                ...files.slice(0, selectedIndex), \n                modifiedFile,\n                ...files.slice(selectedIndex+1)\n              ];\n              debounce = true;\n            }/>\n        </if>\n        <lifecycle onMount = (async () => { \n          const e = await import(\"./components/editor\");\n          await e.loading;\n          activeEditor = e;\n        })/>\n      </@body>\n    </pane>\n  </@left>\n  <@right>\n    <pane>\n      <@actions>\n        <controllable-select.preview-select \n          value=previewType \n          valueChange(value) {\n            previewType = value;\n            debounce = false;\n          }>\n          <option value=\"preview\">App Preview</option>\n          <option value=\"compiled-html\">Compiled (HTML)</option>\n          <option value=\"compiled-vdom\">Compiled (DOM)</option>\n        </controllable-select>\n        <playground-link files=files/>\n        <style>\n          .preview-select {\n            border:0;\n            height:100%;\n            font-size: 100%;\n            padding:0 1em;\n          }\n        </style>\n      </@actions>\n      <@body>\n        <let/preview = null/>\n        <${preview} \n          type=previewType\n          files=files\n          selectedFile=selectedFile\n          getCompilerOptions=getCompilerOptions\n          debounce=debounce/>\n        <lifecycle onMount = (async () => { \n          preview = await import(\"./components/preview\");\n        })/>\n      </@body>\n    </pane>\n  </@right>\n</resizable-panes>","import { compressToEncodedURIComponent, decompressFromEncodedURIComponent } from \"lz-string\";\n\nstatic function getInitialValue() {\n  try {\n    if (typeof window !== \"undefined\") {\n      return JSON.parse(decompressFromEncodedURIComponent(window.location.hash.slice(1)));\n    }\n  } catch(e) {\n    console.error(e);\n  }\n}\n\n<attrs/{ value:defaultValue }/>\n<let/value = getInitialValue() || defaultValue/>\n<lifecycle \n  onMount() {\n    window.addEventListener(\"hashchange\", this.handler = () => {\n      try {\n        if (!this.isUpdating) {\n          value = JSON.parse(decompressFromEncodedURIComponent(window.location.hash.slice(1)));\n        } else {\n          this.isUpdating = false;\n        }\n      } catch(e) {\n        console.error(e);\n      }\n    });\n  } \n  onUpdate() {\n    this.isUpdating = true;\n    window.location.hash = compressToEncodedURIComponent(JSON.stringify(value));\n  }\n  onDestroy() {\n    window.removeEventListener(\"hashchange\", this.handler);\n  }/>\n<return:=value/>\n","// src/visitors/program/index.ts\nimport { types as t13 } from \"@marko/compiler\";\n\n// src/util/marko-config.ts\nfunction isOutputHTML() {\n  return getMarkoOpts().output === \"html\";\n}\nfunction isOutputDOM() {\n  return !isOutputHTML();\n}\nfunction getMarkoOpts() {\n  return currentProgramPath.hub.file.markoOpts;\n}\nfunction isOptimize() {\n  return getMarkoOpts().optimize;\n}\n\n// src/util/sections.ts\nimport { types as t2 } from \"@marko/compiler\";\n\n// src/util/tag-name-type.ts\nimport { types as t } from \"@marko/compiler\";\nimport { isNativeTag, loadFileForTag } from \"@marko/babel-utils\";\nvar MARKO_FILE_REG = /^<.*>$|\\.marko$/;\nfunction analyzeTagNameType(tag) {\n  const extra = tag.node.extra ??= {};\n  if (extra.tagNameType === void 0) {\n    const name = tag.get(\"name\");\n    if (name.isStringLiteral()) {\n      extra.tagNameType = name.node.value[0] === \"@\" ? 3 /* AttributeTag */ : isNativeTag(tag) ? 0 /* NativeTag */ : 1 /* CustomTag */;\n      if (extra.tagNameType === 1 /* CustomTag */) {\n        const childFile = loadFileForTag(tag);\n        const childProgram = childFile?.ast.program;\n        if (childProgram?.extra.___featureType === \"class\") {\n          extra.tagNameType = 2 /* DynamicTag */;\n          extra.___featureType = \"class\";\n        }\n      }\n      extra.tagNameNullable = extra.tagNameNullable = false;\n    } else {\n      const pending = [name];\n      let path3;\n      let type = void 0;\n      let nullable = false;\n      while ((path3 = pending.pop()) && type !== 2 /* DynamicTag */) {\n        if (path3.isConditionalExpression()) {\n          pending.push(path3.get(\"test\"));\n          pending.push(path3.get(\"consequent\"));\n          if (path3.node.alternate) {\n            pending.push(path3.get(\"alternate\"));\n          }\n        } else if (path3.isLogicalExpression()) {\n          if (path3.node.operator === \"||\") {\n            pending.push(path3.get(\"left\"));\n          } else {\n            nullable = true;\n          }\n          pending.push(path3.get(\"right\"));\n        } else if (path3.isAssignmentExpression()) {\n          pending.push(path3.get(\"right\"));\n        } else if (path3.isBinaryExpression()) {\n          type = path3.node.operator !== \"+\" || type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n        } else if (path3.isStringLiteral() || path3.isTemplateLiteral()) {\n          type = type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n        } else if (path3.isNullLiteral()) {\n          nullable = true;\n        } else if (path3.isIdentifier()) {\n          if (path3.node.name === \"undefined\") {\n            nullable = true;\n            continue;\n          }\n          const binding = path3.scope.getBinding(path3.node.name);\n          if (!binding) {\n            type = 2 /* DynamicTag */;\n            continue;\n          }\n          if (binding.kind === \"module\") {\n            const decl = binding.path.parent;\n            if (MARKO_FILE_REG.test(decl.source.value) && decl.specifiers.some((it) => t.isImportDefaultSpecifier(it))) {\n              type = type !== void 0 && type !== 1 /* CustomTag */ ? 2 /* DynamicTag */ : 1 /* CustomTag */;\n            } else {\n              type = 2 /* DynamicTag */;\n            }\n            continue;\n          }\n          const bindingTag = binding.path;\n          if (bindingTag.isMarkoTag() && binding.kind === \"local\") {\n            const bindingTagName = bindingTag.get(\"name\").node.value;\n            if (bindingTagName === \"tag\") {\n              type = type !== void 0 && type !== 1 /* CustomTag */ ? 2 /* DynamicTag */ : 1 /* CustomTag */;\n              continue;\n            }\n            if (bindingTagName === \"const\") {\n              pending.push(\n                bindingTag.get(\n                  \"attributes\"\n                )[0].get(\"value\")\n              );\n              continue;\n            }\n            if (bindingTagName === \"let\") {\n              type = 2 /* DynamicTag */;\n              continue;\n            }\n            continue;\n          }\n          type = 2 /* DynamicTag */;\n        } else {\n          type = 2 /* DynamicTag */;\n        }\n      }\n      extra.tagNameType = type;\n      extra.tagNameNullable = nullable;\n      extra.tagNameDynamic = true;\n    }\n    if (extra.tagNameType === void 0) {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n  }\n  return extra.tagNameType;\n}\n\n// src/util/sections.ts\nfunction startSection(path3) {\n  const extra = path3.node.extra ??= {};\n  let section = extra.section;\n  if (!section) {\n    const parentSection = path3.parentPath ? getOrCreateSection(path3.parentPath) : void 0;\n    const sectionNamePath = path3.parentPath?.get(\n      \"name\"\n    );\n    const sectionName = path3.isProgram() ? \"\" : currentProgramPath.scope.generateUid(\n      sectionNamePath.toString() + \"Body\"\n    );\n    const programExtra = path3.hub.file.path.node.extra ??= {};\n    const sections = programExtra.sections ??= [];\n    section = extra.section = {\n      id: sections.length,\n      name: sectionName,\n      depth: parentSection ? parentSection.depth + 1 : 0,\n      parent: parentSection\n    };\n    sections.push(section);\n  }\n  return section;\n}\nfunction getOrCreateSection(path3) {\n  let cur = path3;\n  while (true) {\n    if (cur.type === \"Program\" || cur.type === \"MarkoTagBody\" && analyzeTagNameType(cur.parentPath) !== 0 /* NativeTag */) {\n      return startSection(cur);\n    }\n    cur = cur.parentPath;\n  }\n}\nfunction getSection(path3) {\n  let section;\n  let currentPath = path3;\n  while ((section = currentPath.node.extra?.section) === void 0) {\n    currentPath = currentPath.parentPath;\n  }\n  _setSectionPath(\n    section,\n    currentPath\n  );\n  return section;\n}\nfunction createSectionState(key, init) {\n  return [\n    (section) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      const sectionData = arrayOfSectionData[section.id] ??= init && init(section);\n      return sectionData;\n    },\n    (section, value) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      arrayOfSectionData[section.id] = value;\n    }\n  ];\n}\nvar [getScopeIdIdentifier] = createSectionState(\n  \"scopeIdIdentifier\",\n  (section) => currentProgramPath.scope.generateUidIdentifier(`scope${section.id}_id`)\n);\nvar [getSectionPath, _setSectionPath] = createSectionState(\"sectionPath\");\nvar [_getScopeIdentifier] = createSectionState(\n  \"scopeIdentifier\",\n  () => t2.identifier(\"undefined\")\n);\nvar getScopeIdentifier = (section, ignoreDefault) => {\n  const scopeId = _getScopeIdentifier(section);\n  if (!ignoreDefault && scopeId.name === \"undefined\") {\n    scopeId.name = currentProgramPath.scope.generateUid(`scope${section.id}_`);\n  }\n  return scopeId;\n};\nfunction forEachSection(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  sections?.forEach(fn);\n}\nfunction forEachSectionReverse(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  for (let i = sections.length; i--; ) {\n    fn(sections[i]);\n  }\n}\n\n// src/util/reserve.ts\nimport { types as t3 } from \"@marko/compiler\";\n\n// src/util/sorted-repeatable.ts\nvar SortedRepeatable = class {\n  constructor(compare) {\n    this.compare = compare;\n  }\n  add(data, item) {\n    return data ? Array.isArray(data) ? insertSorted(this.compare, data, item) : joinItems(this.compare, data, item) : item;\n  }\n  addAll(data, items) {\n    if (data) {\n      if (Array.isArray(data)) {\n        if (items) {\n          if (Array.isArray(items)) {\n            for (const item of items) {\n              insertSorted(this.compare, data, item);\n            }\n          } else {\n            insertSorted(this.compare, data, items);\n          }\n        }\n        return data;\n      }\n      if (items) {\n        if (Array.isArray(items)) {\n          return insertSorted(this.compare, [...items], data);\n        }\n        return joinItems(this.compare, items, data);\n      }\n      return data;\n    }\n    if (Array.isArray(items)) {\n      return [...items];\n    }\n    return items;\n  }\n  find(data, item) {\n    if (data) {\n      if (Array.isArray(data)) {\n        let max = data.length;\n        let pos = 0;\n        while (pos < max) {\n          const mid = pos + max >>> 1;\n          const cur = data[mid];\n          const compareResult = this.compare(cur, item);\n          if (compareResult === 0)\n            return cur;\n          if (compareResult > 0)\n            max = mid;\n          else\n            pos = mid + 1;\n        }\n      } else {\n        return this.compare(data, item) === 0 ? data : void 0;\n      }\n    }\n  }\n  clone(item) {\n    return Array.isArray(item) ? [...item] : item;\n  }\n  size(data) {\n    return data ? Array.isArray(data) ? data.length : 1 : 0;\n  }\n  toArray(data, map) {\n    if (data) {\n      if (Array.isArray(data)) {\n        return data.map(map);\n      }\n      return [map(data)];\n    }\n    return [];\n  }\n  *iterate(data) {\n    if (data) {\n      if (Array.isArray(data)) {\n        for (const item of data) {\n          yield item;\n        }\n      } else {\n        yield data;\n      }\n    }\n  }\n};\nfunction joinItems(compare, a, b) {\n  const compareResult = compare(a, b);\n  return compareResult === 0 ? a : compareResult < 0 ? [a, b] : [b, a];\n}\nfunction insertSorted(compare, data, item) {\n  const len = data.length;\n  let max = len;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(data[mid], item);\n    if (compareResult === 0)\n      return data;\n    if (compareResult > 0)\n      max = mid;\n    else\n      pos = mid + 1;\n  }\n  let cur = item;\n  while (pos < len) {\n    const next = cur;\n    cur = data[pos];\n    data[pos++] = next;\n  }\n  data[len] = cur;\n  return data;\n}\n\n// src/util/reserve.ts\nvar [getReservesByType] = createSectionState(\n  \"reservesByType\",\n  () => [void 0, void 0, void 0]\n);\nfunction reserveScope(type, section, node, name, debugKey = name) {\n  const extra = node.extra ??= {};\n  if (extra.reserve) {\n    const reserve2 = extra.reserve;\n    reserve2.name += \"_\" + name;\n    return reserve2;\n  }\n  const reservesByType = getReservesByType(section);\n  const reserve = extra.reserve = {\n    id: 0,\n    type,\n    name,\n    debugKey,\n    section\n  };\n  if (reservesByType[type]) {\n    reserve.id = reservesByType[type].push(reserve) - 1;\n  } else {\n    reservesByType[type] = [reserve];\n  }\n  return reserve;\n}\nfunction assignFinalIds() {\n  forEachSection((section) => {\n    let curIndex = 0;\n    for (const reserves of getReservesByType(section)) {\n      if (reserves) {\n        for (const reserve of reserves) {\n          reserve.id = curIndex;\n          curIndex += 1;\n        }\n      }\n    }\n  });\n}\nfunction getScopeAccessorLiteral(reserve) {\n  if (isOptimize()) {\n    return t3.numericLiteral(reserve.id);\n  }\n  return t3.stringLiteral(\n    reserve.debugKey + (reserve.type === 0 /* Visit */ ? `/${reserve.id}` : \"\")\n  );\n}\nvar repeatableReserves = new SortedRepeatable(function compareReserves(a, b) {\n  return a.section.id - b.section.id || a.type - b.type || a.id - b.id;\n});\n\n// src/util/references.ts\nvar intersectionSubscribeCounts = /* @__PURE__ */ new WeakMap();\nvar repeatableIntersections = new SortedRepeatable(compareIntersections);\nvar [getIntersectionsBySection, setIntersectionsBySection] = createSectionState(\"intersectionsBySection\", () => []);\nfunction trackReferences(tag) {\n  if (tag.has(\"var\")) {\n    trackReferencesForBindings(getOrCreateSection(tag), tag.get(\"var\"));\n  }\n  const body = tag.get(\"body\");\n  if (body.get(\"body\").length && body.get(\"params\").length) {\n    trackReferencesForBindings(getOrCreateSection(body), body);\n  }\n}\nfunction trackReferencesForBindings(section, path3) {\n  const scope = path3.scope;\n  const bindings = path3.getBindingIdentifiers();\n  for (const name in bindings) {\n    const references = scope.getBinding(name).referencePaths.concat(\n      /*\n        https://github.com/babel/babel/issues/11313\n        We need this so we can handle `+=` and friends\n      */\n      scope.getBinding(name).constantViolations.filter(\n        (path4) => path4.isAssignmentExpression() && path4.node.operator !== \"=\"\n      )\n    );\n    const identifier = bindings[name];\n    const binding = reserveScope(1 /* Store */, section, identifier, name);\n    for (const reference of references) {\n      const fnRoot = getFnRoot(reference.scope.path);\n      const exprRoot = getExprRoot(fnRoot || reference);\n      const markoRoot = exprRoot.parentPath;\n      const immediateRoot = fnRoot ?? exprRoot;\n      if (immediateRoot) {\n        const name2 = immediateRoot.node.id?.name;\n        if (!name2) {\n          if (markoRoot.isMarkoAttribute() && !markoRoot.node.default) {\n            (immediateRoot.node.extra ??= {}).name = markoRoot.node.name;\n          }\n        }\n        addBindingToReferences(immediateRoot, \"references\", binding);\n      }\n      addBindingToReferences(\n        markoRoot,\n        `${exprRoot.listKey || exprRoot.key}References`,\n        binding\n      );\n    }\n  }\n}\nfunction addBindingToReferences(path3, referencesKey, binding) {\n  const section = getOrCreateSection(path3);\n  const extra = path3.node.extra ??= {};\n  const prevReferences = extra[referencesKey];\n  if (prevReferences) {\n    if (prevReferences !== binding) {\n      extra[referencesKey] = addSubscriber(\n        getIntersection(\n          section,\n          repeatableReserves.add(\n            repeatableReserves.clone(prevReferences),\n            binding\n          )\n        )\n      );\n      if (isIntersection(prevReferences)) {\n        removeSubscriber(getIntersection(section, prevReferences));\n      }\n    }\n  } else {\n    extra[referencesKey] = binding;\n  }\n}\nfunction mergeReferences(section, groupEntries) {\n  let newReferences;\n  for (const [extra, key] of groupEntries) {\n    const references = extra[key];\n    if (isIntersection(references)) {\n      removeSubscriber(getIntersection(section, references));\n    }\n    newReferences = repeatableReserves.addAll(newReferences, references);\n    delete extra[key];\n  }\n  if (isIntersection(newReferences)) {\n    newReferences = addSubscriber(getIntersection(section, newReferences));\n  }\n  return newReferences;\n}\nfunction getExprRoot(path3) {\n  let curPath = path3;\n  while (!isMarkoPath(curPath.parentPath)) {\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction getFnRoot(path3) {\n  let curPath = path3;\n  if (curPath.isProgram())\n    return;\n  while (!isFunctionExpression(curPath)) {\n    if (isMarkoPath(curPath))\n      return;\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction isMarkoPath(path3) {\n  switch (path3.type) {\n    case \"MarkoTag\":\n    case \"MarkoTagBody\":\n    case \"MarkoAttribute\":\n    case \"MarkoSpreadAttribute\":\n    case \"MarkoPlaceholder\":\n    case \"MarkoScriptlet\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isFunctionExpression(path3) {\n  switch (path3.type) {\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction compareIntersections(a, b) {\n  const len = a.length;\n  const lenDelta = len - b.length;\n  if (lenDelta !== 0) {\n    return lenDelta;\n  }\n  for (let i = 0; i < len; i++) {\n    const compareResult = repeatableReserves.compare(a[i], b[i]);\n    if (compareResult !== 0) {\n      return compareResult;\n    }\n  }\n  return 0;\n}\nfunction finalizeIntersections() {\n  const intersectionsBySection = (currentProgramPath.node.extra ??= {}).intersectionsBySection = {};\n  forEachSection((section) => {\n    intersectionsBySection[section.id] = getIntersectionsBySection(\n      section\n    ).filter(\n      (intersection) => intersectionSubscribeCounts.get(intersection) > 0\n    );\n  });\n}\nfunction getIntersection(section, references) {\n  const intersections = getIntersectionsBySection(section);\n  let intersection = repeatableIntersections.find(intersections, references);\n  if (!intersection) {\n    intersection = references;\n    setIntersectionsBySection(\n      section,\n      repeatableIntersections.add(intersections, references)\n    );\n  }\n  return intersection;\n}\nfunction addSubscriber(intersection) {\n  intersectionSubscribeCounts.set(\n    intersection,\n    (intersectionSubscribeCounts.get(intersection) || 0) + 1\n  );\n  return intersection;\n}\nfunction removeSubscriber(intersection) {\n  intersectionSubscribeCounts.set(\n    intersection,\n    intersectionSubscribeCounts.get(intersection) - 1\n  );\n  return intersection;\n}\nfunction isIntersection(references) {\n  return Array.isArray(references);\n}\n\n// src/util/runtime.ts\nimport { types as t5 } from \"@marko/compiler\";\nimport { importNamed } from \"@marko/babel-utils\";\n\n// ../runtime/src/html/content.ts\nfunction toString(val) {\n  return val || val === 0 ? val + \"\" : \"\";\n}\nvar escapeXML = escapeIfNeeded((val) => {\n  let result = \"\";\n  let lastPos = 0;\n  for (let i = 0, len = val.length; i < len; i++) {\n    let replacement;\n    switch (val[i]) {\n      case \"<\":\n        replacement = \"&lt;\";\n        break;\n      case \"&\":\n        replacement = \"&amp;\";\n        break;\n      default:\n        continue;\n    }\n    result += val.slice(lastPos, i) + replacement;\n    lastPos = i + 1;\n  }\n  if (lastPos) {\n    return result + val.slice(lastPos);\n  }\n  return val;\n});\nvar escapeScript = escapeIfNeeded(escapeTagEnding(\"script\"));\nvar escapeStyle = escapeIfNeeded(escapeTagEnding(\"style\"));\nfunction escapeTagEnding(tagName) {\n  const openTag = `</${tagName}`;\n  const escaped = `<\\\\/${tagName}`;\n  return (val) => {\n    let result = \"\";\n    let lastPos = 0;\n    let i = val.indexOf(openTag, lastPos);\n    while (i !== -1) {\n      result += val.slice(lastPos, i) + escaped;\n      lastPos = i + 1;\n      i = val.indexOf(openTag, lastPos);\n    }\n    if (lastPos) {\n      return result + val.slice(lastPos);\n    }\n    return val;\n  };\n}\nfunction escapeAttrValue(val) {\n  const len = val.length;\n  let i = 0;\n  do {\n    switch (val[i]) {\n      case '\"':\n        return quoteValue(val, i + 1, \"'\", \"&#39;\");\n      case \"'\":\n      case \">\":\n      case \" \":\n      case \"\t\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\f\":\n        return quoteValue(val, i + 1, '\"', \"&#34;\");\n      default:\n        i++;\n        break;\n    }\n  } while (i < len);\n  return val;\n}\nfunction escapeIfNeeded(escape) {\n  return (val) => {\n    if (!val && val !== 0) {\n      return \"&zwj;\";\n    }\n    switch (typeof val) {\n      case \"string\":\n        return escape(val);\n      case \"boolean\":\n        return \"true\";\n      case \"number\":\n        return val + \"\";\n      default:\n        return escape(val + \"\");\n    }\n  };\n}\nfunction quoteValue(val, startPos, quote, escaped) {\n  let result = quote;\n  let lastPos = 0;\n  for (let i = startPos, len = val.length; i < len; i++) {\n    if (val[i] === quote) {\n      result += val.slice(lastPos, i) + escaped;\n      lastPos = i + 1;\n    }\n  }\n  return result + (lastPos ? val.slice(lastPos) : val) + quote;\n}\n\n// ../runtime/src/common/helpers.ts\nfunction classValue(value) {\n  return toDelimitedString(value, \" \", stringifyClassObject);\n}\nfunction stringifyClassObject(name, value) {\n  if (isVoid(value)) {\n    return \"\";\n  }\n  return name;\n}\nfunction styleValue(value) {\n  return toDelimitedString(value, \";\", stringifyStyleObject);\n}\nvar NON_DIMENSIONAL = /^(--|ta|or|li|z)|n-c|i(do|nk|m|t)|w$|we/;\nfunction stringifyStyleObject(name, value) {\n  if (isVoid(value)) {\n    return \"\";\n  }\n  if (typeof value === \"number\" && value && !NON_DIMENSIONAL.test(name)) {\n    value += \"px\";\n  }\n  return `${name}:${value}`;\n}\nfunction toDelimitedString(val, delimiter, stringify) {\n  switch (typeof val) {\n    case \"string\":\n      return val;\n    case \"object\":\n      if (val !== null) {\n        let result = \"\";\n        let curDelimiter = \"\";\n        if (Array.isArray(val)) {\n          for (const v of val) {\n            const part = toDelimitedString(v, delimiter, stringify);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        } else {\n          for (const name in val) {\n            const v = val[name];\n            const part = stringify(name, v);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        }\n        return result;\n      }\n  }\n  return \"\";\n}\nfunction isVoid(value) {\n  return value == null || value === false;\n}\n\n// ../runtime/src/html/attrs.ts\nfunction classAttr(val) {\n  return stringAttr(\"class\", classValue(val));\n}\nfunction styleAttr(val) {\n  return stringAttr(\"style\", styleValue(val));\n}\nfunction attr(name, val) {\n  return isVoid(val) ? \"\" : nonVoidUntypedAttr(name, val);\n}\nfunction stringAttr(name, val) {\n  return val && ` ${name}=${escapeAttrValue(val)}`;\n}\nfunction nonVoidUntypedAttr(name, val) {\n  switch (typeof val) {\n    case \"string\":\n      return ` ${name + attrAssignment(val)}`;\n    case \"boolean\":\n      return ` ${name}`;\n    case \"number\":\n      return ` ${name}=${val}`;\n    case \"object\":\n      if (val instanceof RegExp) {\n        return ` ${name}=${escapeAttrValue(val.source)}`;\n      }\n    default:\n      return ` ${name + attrAssignment(val + \"\")}`;\n  }\n}\nfunction attrAssignment(val) {\n  return val ? `=${escapeAttrValue(val)}` : \"\";\n}\n\n// ../runtime/src/html/reorder-runtime.ts\nfunction reorder_runtime_default(id, doc, walker, node, replacementNode, targetParent, targetNode, refNode, nextNode, runtimePrefix) {\n  runtimePrefix = \"RUNTIME_ID$\";\n  id = runtimePrefix + id;\n  doc = document;\n  walker = doc[runtimePrefix + \"w\"] || (doc[runtimePrefix + \"w\"] = doc.createTreeWalker(\n    doc,\n    128\n    /** NodeFilter.SHOW_COMMENT */\n  ));\n  while (node = walker.nextNode()) {\n    if (node.data.indexOf(runtimePrefix) === 0) {\n      walker[node.data] = node;\n    }\n  }\n  replacementNode = doc.getElementById(id);\n  targetNode = walker[id];\n  targetParent = targetNode.parentNode;\n  while (refNode = replacementNode.firstChild) {\n    targetParent.insertBefore(refNode, targetNode);\n  }\n  nextNode = replacementNode.parentNode;\n  nextNode.removeChild(replacementNode.nextSibling);\n  nextNode.removeChild(replacementNode);\n  refNode = walker[id + \"/\"];\n  while (nextNode = targetNode.nextSibling, targetParent.removeChild(targetNode) !== refNode) {\n    targetNode = nextNode;\n  }\n}\n\n// ../runtime/src/html/serializer.ts\nvar { hasOwnProperty } = Object.prototype;\nvar REF_START_CHARS = \"hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_\";\nvar REF_START_CHARS_LEN = REF_START_CHARS.length;\nvar REF_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_\";\nvar REF_CHARS_LEN = REF_CHARS.length;\nvar SYMBOL_REGISTRY_ID = Symbol(\"REGISTRY_ID\");\nvar SYMBOL_SCOPE = Symbol(\"SCOPE\");\nvar SYMBOL_SERIALIZE = Symbol(\"SERIALIZE\");\n\n// ../runtime/src/html/writer.ts\nvar runtimeId = \"M\" /* DEFAULT_RUNTIME_ID */;\nvar reorderRuntimeString = String(reorder_runtime_default).replace(\n  \"RUNTIME_ID\",\n  runtimeId\n);\n\n// src/util/scope-read.ts\nimport { types as t4 } from \"@marko/compiler\";\nfunction createScopeReadPattern(section, references) {\n  const rootDepth = section.depth;\n  const rootPattern = t4.objectPattern([]);\n  let nestedPatterns;\n  for (const ref of repeatableReserves.iterate(references)) {\n    if (ref.name.includes(\"#\"))\n      continue;\n    const propertyKey = getScopeAccessorLiteral(ref);\n    const propertyValue = t4.identifier(ref.name);\n    const isShorthand = propertyKey.value === propertyValue.name;\n    let pattern = rootPattern;\n    if (ref.section !== section) {\n      if (!nestedPatterns)\n        nestedPatterns = [rootPattern];\n      const relativeDepth = rootDepth - ref.section.depth;\n      let i = nestedPatterns.length;\n      let prev = nestedPatterns[i - 1];\n      for (; i <= relativeDepth; i++) {\n        const nestedPattern = t4.objectPattern([]);\n        prev.properties.push(\n          t4.objectProperty(t4.identifier(\"_\"), nestedPattern)\n        );\n        nestedPatterns.push(nestedPattern);\n        prev = nestedPattern;\n      }\n      pattern = nestedPatterns[relativeDepth];\n    }\n    pattern.properties.push(\n      t4.objectProperty(\n        isShorthand ? propertyValue : propertyKey,\n        propertyValue,\n        false,\n        isShorthand\n      )\n    );\n  }\n  return rootPattern;\n}\nfunction getScopeExpression(section, targetSection) {\n  let scope = scopeIdentifier;\n  const diff = section.depth - targetSection.depth;\n  for (let i = 0; i < diff; i++) {\n    scope = t4.memberExpression(scope, t4.identifier(\"_\"));\n  }\n  if (diff < 0) {\n    throw new Error(\"Unable to find scope for reference.\");\n  }\n  return scope;\n}\nfunction createScopeReadExpression(section, reference) {\n  return t4.memberExpression(\n    getScopeExpression(section, reference.section),\n    getScopeAccessorLiteral(reference),\n    true\n  );\n}\n\n// src/util/runtime.ts\nvar pureFunctions = [\n  \"createTemplate\",\n  \"createRenderer\",\n  \"value\",\n  \"intersection\",\n  \"closure\",\n  \"dynamicClosure\",\n  \"contextClosure\",\n  \"loopOf\",\n  \"loopIn\",\n  \"loopTo\",\n  \"conditional\",\n  \"bindFunction\",\n  \"bindRenderer\"\n];\nfunction importRuntime(name) {\n  const { output } = getMarkoOpts();\n  return importNamed(currentProgramPath.hub.file, getRuntimePath(output), name);\n}\nfunction callRuntime(name, ...args) {\n  const callExpression2 = t5.callExpression(\n    importRuntime(name),\n    filterArguments(args)\n  );\n  if (pureFunctions.includes(\n    name\n  )) {\n    callExpression2.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: ` @__PURE__ `\n      }\n    ];\n  }\n  return callExpression2;\n}\nfunction getHTMLRuntime() {\n  return {\n    escapeXML,\n    toString,\n    attr,\n    classAttr,\n    styleAttr,\n    escapeScript,\n    escapeStyle\n  };\n}\nfunction getRuntimePath(output) {\n  const { optimize } = getMarkoOpts();\n  return `@marko/runtime-fluurt/${false ? \"src\" : optimize ? \"dist\" : \"dist/debug\"}/${output === \"html\" ? \"html\" : \"dom\"}`;\n}\nfunction filterArguments(args) {\n  const filteredArgs = [];\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (arg || filteredArgs.length) {\n      filteredArgs[i] = arg || t5.unaryExpression(\"void\", t5.numericLiteral(0));\n    }\n  }\n  return filteredArgs;\n}\n\n// src/visitors/program/dom.ts\nimport { types as t11 } from \"@marko/compiler\";\nimport { getTemplateId as getTemplateId2 } from \"@marko/babel-utils\";\n\n// src/util/signals.ts\nimport { types as t10 } from \"@marko/compiler\";\nimport { getTemplateId } from \"@marko/babel-utils\";\n\n// src/core/return.ts\nimport { types as t9 } from \"@marko/compiler\";\nimport { assertNoParams, assertNoVar } from \"@marko/babel-utils\";\n\n// src/util/writer.ts\nimport { types as t8 } from \"@marko/compiler\";\n\n// src/util/to-template-string-or-literal.ts\nimport { types as t6 } from \"@marko/compiler\";\nfunction toTemplateOrStringLiteral(parts) {\n  const strs = [];\n  const exprs = [];\n  let curStr = parts[0];\n  for (let i = 1; i < parts.length; i++) {\n    let content = parts[i];\n    if (typeof content === \"object\") {\n      if (t6.isStringLiteral(content)) {\n        content = content.value;\n      } else if (t6.isTemplateLiteral(content)) {\n        let nextIndex = i + 1;\n        const exprLen = content.expressions.length;\n        shiftItems(parts, nextIndex, content.quasis.length + exprLen);\n        for (let j = 0; j < exprLen; j++) {\n          parts[nextIndex++] = content.quasis[j].value.raw;\n          parts[nextIndex++] = content.expressions[j];\n        }\n        parts[nextIndex] = content.quasis[exprLen].value.raw;\n        continue;\n      } else {\n        exprs.push(content);\n        strs.push(curStr);\n        curStr = \"\";\n        continue;\n      }\n    }\n    curStr += content;\n  }\n  if (exprs.length) {\n    strs.push(curStr);\n    return t6.templateLiteral(\n      strs.map((raw) => t6.templateElement({ raw })),\n      exprs\n    );\n  } else if (curStr) {\n    return t6.stringLiteral(curStr);\n  }\n}\nfunction appendLiteral(arr, str) {\n  arr[arr.length - 1] += str;\n}\nfunction shiftItems(list, start, offset) {\n  for (let i = list.length - 1; i >= start; i--) {\n    list[i + offset] = list[i];\n  }\n}\n\n// src/util/walks.ts\nimport { types as t7 } from \"@marko/compiler\";\nvar [getWalks] = createSectionState(\n  \"walks\",\n  () => [\"\"]\n);\nvar [getWalkComment] = createSectionState(\n  \"walkComment\",\n  () => []\n);\nvar [getSteps] = createSectionState(\"steps\", () => []);\nvar walkCodeToName = {\n  [32 /* Get */]: \"get\",\n  [33 /* Before */]: \"before\",\n  [35 /* After */]: \"after\",\n  [36 /* Inside */]: \"inside\",\n  [37 /* Replace */]: \"replace\",\n  [38 /* EndChild */]: \"endChild\",\n  [47 /* BeginChild */]: \"beginChild\",\n  [67 /* Next */]: \"next\",\n  [97 /* Over */]: \"over\",\n  [107 /* Out */]: \"out\",\n  [117 /* Multiplier */]: \"multiplier\",\n  [91 /* NextEnd */]: \"nextEnd\",\n  [106 /* OverEnd */]: \"overEnd\",\n  [116 /* OutEnd */]: \"outEnd\",\n  [126 /* MultiplierEnd */]: \"multiplierEnd\"\n};\nfunction enter(path3) {\n  getSteps(getSection(path3)).push(0 /* enter */);\n}\nfunction exit(path3) {\n  getSteps(getSection(path3)).push(1 /* exit */);\n}\nfunction enterShallow(path3) {\n  getSteps(getSection(path3)).push(0 /* enter */, 1 /* exit */);\n}\nfunction injectWalks(path3, expr) {\n  const walks = getWalks(getSection(path3));\n  const walkComment = getWalkComment(getSection(path3));\n  walkComment.push(\n    `${walkCodeToName[47 /* BeginChild */]}`,\n    expr.name,\n    walkCodeToName[38 /* EndChild */]\n  );\n  appendLiteral(walks, String.fromCharCode(47 /* BeginChild */));\n  walks.push(expr, String.fromCharCode(38 /* EndChild */));\n}\nfunction visit(path3, code) {\n  const { reserve } = path3.node.extra;\n  if (code && (!reserve || reserve.type !== 0 /* Visit */)) {\n    throw path3.buildCodeFrameError(\n      \"Tried to visit a node that was not marked as needing to visit during analyze.\"\n    );\n  }\n  if (isOutputHTML()) {\n    return;\n  }\n  const section = getSection(path3);\n  const steps = getSteps(section);\n  const walks = getWalks(section);\n  const walkComment = getWalkComment(section);\n  let walkString = \"\";\n  if (steps.length) {\n    const walks2 = [];\n    let depth = 0;\n    for (const step of steps) {\n      if (step === 0 /* enter */) {\n        depth++;\n        walks2.push(67 /* Next */);\n      } else {\n        depth--;\n        if (depth >= 0) {\n          walks2.length = walks2.lastIndexOf(67 /* Next */);\n          walks2.push(97 /* Over */);\n        } else {\n          walks2.length = walks2.lastIndexOf(107 /* Out */) + 1;\n          walks2.push(107 /* Out */);\n          depth = 0;\n        }\n      }\n    }\n    let current = walks2[0];\n    let count = 0;\n    for (const walk of walks2) {\n      if (walk !== current) {\n        walkComment.push(`${walkCodeToName[current]}(${count})`);\n        walkString += nCodeString(current, count);\n        current = walk;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n    walkComment.push(`${walkCodeToName[current]}(${count})`);\n    walkString += nCodeString(current, count);\n    steps.length = 0;\n  }\n  if (code !== void 0) {\n    if (code !== 32 /* Get */) {\n      writeTo(path3)`<!>`;\n    }\n    walkComment.push(`${walkCodeToName[code]}`);\n    walkString += String.fromCharCode(code);\n  }\n  appendLiteral(walks, walkString);\n}\nfunction nCodeString(code, number) {\n  switch (code) {\n    case 67 /* Next */:\n      return toCharString(number, code, 20 /* Next */);\n    case 97 /* Over */:\n      return toCharString(number, code, 10 /* Over */);\n    case 107 /* Out */:\n      return toCharString(number, code, 10 /* Out */);\n    default:\n      throw new Error(`Unexpected walk code: ${code}`);\n  }\n}\nfunction toCharString(number, startCode, rangeSize) {\n  let result = \"\";\n  if (number >= rangeSize) {\n    const multiplier = Math.floor(number / rangeSize);\n    result += toCharString(\n      multiplier,\n      117 /* Multiplier */,\n      10 /* Multiplier */\n    );\n    number -= multiplier * rangeSize;\n  }\n  result += String.fromCharCode(startCode + number);\n  return result;\n}\nfunction getWalkString(section) {\n  const walkLiteral = toTemplateOrStringLiteral(getWalks(section)) || t7.stringLiteral(\"\");\n  if (walkLiteral.value !== \"\") {\n    walkLiteral.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: \" \" + getWalkComment(section).join(\", \") + \" \"\n      }\n    ];\n  }\n  return walkLiteral;\n}\n\n// src/util/writer.ts\nvar [getRenderer] = createSectionState(\n  \"renderer\",\n  (section) => t8.identifier(section.name)\n);\nvar [getWrites] = createSectionState(\n  \"writes\",\n  () => [\"\"]\n);\nvar [getRegisterRenderer, setRegisterRenderer] = createSectionState(\n  \"registerRenderer\",\n  () => false\n);\nfunction writeTo(path3) {\n  const section = getSection(path3);\n  return (strs, ...exprs) => {\n    const exprsLen = exprs.length;\n    const writes = getWrites(section);\n    appendLiteral(writes, strs[0]);\n    for (let i = 0; i < exprsLen; i++) {\n      writes.push(exprs[i], strs[i + 1]);\n    }\n  };\n}\nfunction writePrependTo(path3) {\n  const section = getSection(path3);\n  return (strs, ...exprs) => {\n    const exprsLen = exprs.length;\n    const writes = getWrites(section);\n    writes[0] += strs[exprsLen];\n    for (let i = 0; i < exprsLen; i++) {\n      writes.unshift(strs[i], exprs[i]);\n    }\n  };\n}\nfunction consumeHTML(path3) {\n  const writes = getWrites(getSection(path3));\n  const result = toTemplateOrStringLiteral(writes);\n  writes.length = 0;\n  writes[0] = \"\";\n  if (result) {\n    return t8.expressionStatement(callRuntime(\"write\", result));\n  }\n}\nfunction hasPendingHTML(path3) {\n  const writes = getWrites(getSection(path3));\n  return Boolean(writes.length > 1 || writes[0]);\n}\nfunction flushBefore(path3) {\n  const expr = consumeHTML(path3);\n  if (expr) {\n    path3.insertBefore(expr)[0].skip();\n  }\n}\nfunction flushInto(path3) {\n  const target = path3.isProgram() ? path3 : path3.get(\"body\");\n  const expr = consumeHTML(target);\n  if (expr) {\n    target.pushContainer(\"body\", expr)[0].skip();\n  }\n}\nfunction getSectionMeta(section) {\n  const writes = getWrites(section);\n  return {\n    setup: getSetup(section),\n    walks: getWalkString(section),\n    writes: toTemplateOrStringLiteral(writes) || t8.stringLiteral(\"\"),\n    register: getRegisterRenderer(section)\n  };\n}\nfunction markNode(path3) {\n  const section = getSection(path3);\n  const { reserve } = path3.node.extra;\n  if (reserve?.type !== 0 /* Visit */) {\n    throw path3.buildCodeFrameError(\n      \"Tried to mark a node that was not determined to need a mark during analyze.\"\n    );\n  }\n  if (isOutputHTML()) {\n    writeTo(path3)`${callRuntime(\n      \"markResumeNode\",\n      getScopeIdIdentifier(section),\n      getScopeAccessorLiteral(reserve)\n    )}`;\n  }\n}\n\n// src/util/assert.ts\nfunction assertNoSpreadAttrs(tag) {\n  for (const attr2 of tag.get(\"attributes\")) {\n    if (attr2.isMarkoSpreadAttribute()) {\n      throw attr2.buildCodeFrameError(\n        `The <${tag.get(\"name\")}> tag does not support ...spread attributes.`\n      );\n    }\n  }\n}\nfunction assertNoBodyContent(tag) {\n  if (tag.node.body.body.length) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The <${tag.get(\"name\")}> tag does not support body content.`\n    );\n  }\n}\n\n// src/core/return.ts\nvar [returnId, _setReturnId] = createSectionState(\n  \"returnId\"\n);\nvar return_default = {\n  translate(tag) {\n    assertNoVar(tag);\n    assertNoParams(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    const section = getSection(tag);\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const [defaultAttr] = node.attributes;\n    if (!t9.isMarkoAttribute(defaultAttr) || !defaultAttr.default) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        `The '<return>' tag requires default attribute like '<return=VALUE>'.`\n      );\n    }\n    if (node.attributes.length > 1) {\n      const start = node.attributes[1].loc?.start;\n      const end = node.attributes[node.attributes.length - 1].loc?.end;\n      const msg = `The '<return>' tag only supports a default attribute.`;\n      if (start == null || end == null) {\n        throw tag.get(\"name\").buildCodeFrameError(msg);\n      } else {\n        throw tag.hub.buildError(\n          { loc: { start, end } },\n          msg,\n          Error\n        );\n      }\n    }\n    if (isOutputHTML()) {\n      flushBefore(tag);\n      const returnId2 = file.path.scope.generateUidIdentifier(\"return\");\n      _setReturnId(section, returnId2);\n      tag.replaceWith(\n        t9.variableDeclaration(\"const\", [\n          t9.variableDeclarator(returnId2, defaultAttr.value)\n        ])\n      )[0].skip();\n    } else {\n      addValue(\n        section,\n        defaultAttr.extra?.valueReferences,\n        {\n          identifier: importRuntime(\"tagVarSignal\"),\n          hasDownstreamIntersections: () => true\n        },\n        defaultAttr.value\n      );\n      tag.remove();\n    }\n  },\n  autocomplete: [\n    {\n      displayText: \"return=<value>\",\n      description: \"Provides a value for use in a parent template.\",\n      snippet: \"return=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#return\"\n    }\n  ]\n};\n\n// src/util/signals.ts\nvar [getSignals] = createSectionState(\n  \"signals\",\n  () => /* @__PURE__ */ new Map()\n);\nvar [getSubscribeBuilder, _setSubscribeBuilder] = createSectionState(\"queue\");\nfunction setSubscriberBuilder(tag, builder) {\n  _setSubscribeBuilder(getSection(tag.get(\"body\")), builder);\n}\nvar [getClosures] = createSectionState(\n  \"closures\",\n  () => []\n);\nvar addClosure = (fromSection, toSection, closure) => {\n  let currentSection = fromSection;\n  while (currentSection !== void 0 && currentSection !== toSection) {\n    getClosures(currentSection).push(closure);\n    currentSection = currentSection.parent;\n  }\n};\nvar [forceResumeScope, _setForceResumeScope] = createSectionState(\"forceResumeScope\");\nfunction setForceResumeScope(section) {\n  _setForceResumeScope(section, true);\n}\nvar [getSerializedScopeProperties] = createSectionState(\"serializedScopeProperties\", () => /* @__PURE__ */ new Map());\nvar [getRegisterScopeBuilder, _setRegisterScopeBuilder] = createSectionState(\"register\");\nfunction setRegisterScopeBuilder(tag, builder) {\n  _setRegisterScopeBuilder(getSection(tag.get(\"body\")), builder);\n}\nvar unimplementedBuild = () => {\n  return t10.stringLiteral(\"SIGNAL NOT INITIALIZED\");\n};\nfunction getSignal(section, reserve) {\n  const signals = getSignals(section);\n  let signal = signals.get(reserve);\n  if (!signal) {\n    signals.set(\n      reserve,\n      signal = {\n        identifier: t10.identifier(generateSignalName(section, reserve)),\n        reserve,\n        section,\n        values: [],\n        intersection: void 0,\n        render: [],\n        effect: [],\n        effectInlineReferences: void 0,\n        subscribers: [],\n        closures: /* @__PURE__ */ new Map(),\n        hasDownstreamIntersections: () => {\n          if (signal.intersection || signal.closures.size || signal.values.some((v) => v.signal.hasDownstreamIntersections())) {\n            signal.hasDownstreamIntersections = () => true;\n            return true;\n          } else {\n            signal.hasDownstreamIntersections = () => false;\n            return false;\n          }\n        },\n        build: unimplementedBuild\n      }\n    );\n    if (isOutputHTML()) {\n      return signal;\n    } else if (!reserve) {\n      signal.build = () => getSignalFn(signal, [scopeIdentifier]);\n    } else if (Array.isArray(reserve)) {\n      subscribe(reserve, signal);\n      signal.build = () => {\n        return callRuntime(\n          \"intersection\",\n          t10.numericLiteral(reserve.length),\n          getSignalFn(signal, [scopeIdentifier], reserve)\n        );\n      };\n    } else if (reserve.section !== section) {\n      const provider = getSignal(reserve.section, reserve);\n      addClosure(section, reserve.section, signal.identifier);\n      provider.closures.set(section, signal);\n      signal.build = () => {\n        const builder = getSubscribeBuilder(section);\n        const ownerScope = getScopeExpression(section, reserve.section);\n        const isImmediateOwner = ownerScope.object === scopeIdentifier;\n        return callRuntime(\n          builder && isImmediateOwner ? \"closure\" : \"dynamicClosure\",\n          getScopeAccessorLiteral(reserve),\n          getSignalFn(signal, [scopeIdentifier, t10.identifier(reserve.name)]),\n          isImmediateOwner ? null : t10.arrowFunctionExpression([scopeIdentifier], ownerScope),\n          buildSignalIntersections(signal),\n          buildSignalValuesWithIntersections(signal)\n        );\n      };\n    }\n  }\n  return signal;\n}\nfunction initValue(reserve, valueAccessor = getScopeAccessorLiteral(reserve)) {\n  const section = reserve.section;\n  const signal = getSignal(section, reserve);\n  signal.build = () => {\n    const fn = getSignalFn(signal, [\n      scopeIdentifier,\n      t10.identifier(reserve.name)\n    ]);\n    const intersections = buildSignalIntersections(signal);\n    const valuesWithIntersections = buildSignalValuesWithIntersections(signal);\n    if (fn.body.body.length > 0 || intersections || valuesWithIntersections) {\n      return callRuntime(\n        \"value\",\n        valueAccessor,\n        fn,\n        intersections,\n        valuesWithIntersections\n      );\n    } else {\n      return fn;\n    }\n  };\n  signal.valueAccessor = valueAccessor;\n  return signal;\n}\nfunction initContextProvider(templateId, reserve, providers, compute, renderer) {\n  const section = reserve.section;\n  const scopeAccessor = getScopeAccessorLiteral(reserve);\n  const valueAccessor = t10.stringLiteral(\n    `${reserve.id}${\":\" /* CONTEXT_VALUE */}`\n  );\n  const signal = initValue(reserve, valueAccessor);\n  addValue(section, providers, signal, compute);\n  signal.hasDynamicSubscribers = true;\n  signal.hasDownstreamIntersections = () => true;\n  addStatement(\n    \"render\",\n    reserve.section,\n    void 0,\n    t10.expressionStatement(\n      callRuntime(\n        \"initContextProvider\",\n        scopeIdentifier,\n        scopeAccessor,\n        valueAccessor,\n        t10.stringLiteral(templateId),\n        renderer\n      )\n    )\n  );\n  return signal;\n}\nfunction initContextConsumer(templateId, reserve) {\n  const section = reserve.section;\n  const signal = getSignal(section, reserve);\n  getClosures(section).push(signal.identifier);\n  signal.build = () => {\n    return callRuntime(\n      \"contextClosure\",\n      getScopeAccessorLiteral(reserve),\n      t10.stringLiteral(templateId),\n      getSignalFn(signal, [scopeIdentifier, t10.identifier(reserve.name)])\n    );\n  };\n  return signal;\n}\nfunction getSignalFn(signal, params, references) {\n  const section = signal.section;\n  for (const value of signal.values) {\n    signal.render.push(\n      t10.expressionStatement(\n        t10.callExpression(value.signal.identifier, [value.scope, value.value])\n      )\n    );\n  }\n  if (references) {\n    signal.render.unshift(\n      t10.variableDeclaration(\"const\", [\n        t10.variableDeclarator(\n          createScopeReadPattern(section, references),\n          scopeIdentifier\n        )\n      ])\n    );\n  }\n  return t10.arrowFunctionExpression(params, t10.blockStatement(signal.render));\n}\nfunction buildSignalIntersections(signal) {\n  let intersections = signal.intersection;\n  const section = signal.section;\n  const closureEntries = Array.from(signal.closures.entries()).sort(\n    ([a], [b]) => a.id - b.id\n  );\n  for (const [closureSection, closureSignal] of closureEntries) {\n    const builder = getSubscribeBuilder(closureSection);\n    const isImmediateOwner = closureSection.parent === section;\n    if (builder && isImmediateOwner) {\n      intersections = pushRepeatable(\n        intersections,\n        builder(closureSignal.identifier)\n      );\n    } else if (!signal.hasDynamicSubscribers) {\n      signal.hasDynamicSubscribers = true;\n    }\n  }\n  if (signal.hasDynamicSubscribers) {\n    signal.hasDynamicSubscribers = true;\n    intersections = pushRepeatable(\n      intersections,\n      callRuntime(\"dynamicSubscribers\", signal.valueAccessor)\n    );\n  }\n  return Array.isArray(intersections) ? callRuntime(\"intersections\", t10.arrayExpression(intersections)) : intersections;\n}\nfunction buildSignalValuesWithIntersections(signal) {\n  let valuesWithIntersections;\n  for (const value of signal.values) {\n    if (value.signal.hasDownstreamIntersections()) {\n      valuesWithIntersections = pushRepeatable(\n        valuesWithIntersections,\n        value.intersectionExpression ?? t10.identifier(value.signal.identifier.name)\n      );\n    }\n  }\n  return Array.isArray(valuesWithIntersections) ? callRuntime(\"values\", t10.arrayExpression(valuesWithIntersections)) : valuesWithIntersections;\n}\nfunction pushRepeatable(repeatable, value) {\n  if (!repeatable) {\n    return value;\n  } else if (Array.isArray(repeatable)) {\n    repeatable.push(value);\n    return repeatable;\n  } else {\n    return [repeatable, value];\n  }\n}\nfunction getTagVarSignal(varPath) {\n  if (varPath.isIdentifier()) {\n    return initValue(varPath.node.extra.reserve);\n  } else {\n    return getDestructureSignal(\n      Object.values(varPath.getBindingIdentifiers()),\n      varPath.node\n    );\n  }\n}\nfunction getTagParamsSignal(paramsPaths, pattern = t10.arrayPattern(\n  paramsPaths.map((path3) => path3.node)\n)) {\n  const parameterBindings = paramsPaths.reduce((bindingsLookup, path3) => {\n    return Object.assign(bindingsLookup, path3.getBindingIdentifiers());\n  }, {});\n  return getDestructureSignal(\n    parameterBindings,\n    t10.objectPattern([t10.objectProperty(t10.identifier(\"value\"), pattern)])\n  );\n}\nfunction getDestructureSignal(bindingsByName, destructurePattern) {\n  const bindings = Array.isArray(bindingsByName) ? bindingsByName : Object.values(bindingsByName);\n  if (bindings.length) {\n    const valueIdentifier = currentProgramPath.scope.generateUidIdentifier(\"destructure\");\n    const bindingSignals = bindings.map(\n      (binding) => initValue(binding.extra?.reserve)\n    );\n    const declarations = t10.variableDeclaration(\n      \"let\",\n      bindings.map((binding) => t10.variableDeclarator(binding))\n    );\n    return {\n      get identifier() {\n        const name = currentProgramPath.scope.generateUidIdentifier(\"destructure\");\n        currentProgramPath.pushContainer(\"body\", [\n          t10.variableDeclaration(\"const\", [\n            t10.variableDeclarator(name, this.build(true))\n          ])\n        ]);\n        return name;\n      },\n      build(canCallOnlyWhenDirty) {\n        if (canCallOnlyWhenDirty && !this.hasDownstreamIntersections()) {\n          return t10.arrowFunctionExpression(\n            [scopeIdentifier, destructurePattern],\n            t10.blockStatement(\n              bindingSignals.map(\n                (signal, i) => t10.expressionStatement(\n                  t10.callExpression(signal.identifier, [\n                    scopeIdentifier,\n                    bindings[i]\n                  ])\n                )\n              )\n            )\n          );\n        }\n        return t10.arrowFunctionExpression(\n          [scopeIdentifier, valueIdentifier, cleanIdentifier],\n          t10.blockStatement([\n            declarations,\n            t10.ifStatement(\n              t10.unaryExpression(\"!\", cleanIdentifier),\n              t10.expressionStatement(\n                t10.assignmentExpression(\"=\", destructurePattern, valueIdentifier)\n              )\n            ),\n            ...bindingSignals.map(\n              (signal, i) => t10.expressionStatement(\n                t10.callExpression(signal.identifier, [\n                  scopeIdentifier,\n                  bindings[i],\n                  cleanIdentifier\n                ])\n              )\n            )\n          ])\n        );\n      },\n      hasDownstreamIntersections() {\n        return bindings.some((binding) => {\n          const reserve = binding.extra.reserve;\n          const signal = getSignal(reserve.section, reserve);\n          return signal.hasDownstreamIntersections();\n        });\n      }\n    };\n  }\n}\nfunction subscribe(provider, subscriber) {\n  if (Array.isArray(provider)) {\n    provider.forEach((p) => subscribe(p, subscriber));\n    return;\n  }\n  const providerSignal = getSignal(subscriber.section, provider);\n  providerSignal.intersection = pushRepeatable(\n    providerSignal.intersection,\n    subscriber.identifier\n  );\n}\nfunction generateSignalName(section, references) {\n  let name;\n  if (references) {\n    if (Array.isArray(references)) {\n      name = \"expr\";\n      for (const ref of references) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name = references.name;\n    }\n  } else {\n    name = \"setup\";\n  }\n  name += section.name.replace(\"_\", \"$\");\n  return currentProgramPath.scope.generateUid(name);\n}\nfunction queueSource(source, value, targetSection) {\n  return callRuntime(\n    \"queueSource\",\n    getScopeExpression(targetSection, source.section),\n    source.identifier,\n    value\n  );\n}\nfunction finalizeSignalArgs(args) {\n  for (let i = args.length - 1; i >= 0; i--) {\n    const arg = args[i];\n    if (t10.isArrowFunctionExpression(arg)) {\n      const body = arg.body.body;\n      if (body) {\n        if (body.length === 0) {\n          args[i] = t10.nullLiteral();\n        } else if (body.length === 1 && t10.isExpressionStatement(body[0])) {\n          arg.body = body[0].expression;\n        }\n      }\n    }\n  }\n  for (let i = args.length - 1; t10.isNullLiteral(args[i]); ) {\n    args.length = i--;\n  }\n}\nfunction addStatement(type, targetSection, references, statement, originalNodes, isInlined) {\n  const signal = getSignal(targetSection, references);\n  const statements = signal[type] ??= [];\n  if (Array.isArray(statement)) {\n    statements.push(...statement);\n  } else {\n    statements.push(statement);\n  }\n  if (type === \"effect\") {\n    if (Array.isArray(originalNodes)) {\n      for (const node of originalNodes) {\n        if (isInlined || !t10.isFunction(node)) {\n          addEffectReferences(signal, node);\n        }\n      }\n    } else {\n      if (isInlined || !t10.isFunction(originalNodes)) {\n        addEffectReferences(signal, originalNodes);\n      }\n    }\n  }\n}\nfunction addValue(targetSection, references, signal, value, scope = scopeIdentifier, intersectionExpression) {\n  getSignal(targetSection, references).values.push({\n    signal,\n    value,\n    scope,\n    intersectionExpression\n  });\n}\nfunction addEffectReferences(signal, expression) {\n  signal.effectInlineReferences = repeatableReserves.addAll(\n    signal.effectInlineReferences,\n    expression.extra?.references\n  );\n}\nfunction getResumeRegisterId(section, references) {\n  const {\n    markoOpts: { optimize },\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let name = \"\";\n  if (references) {\n    if (typeof references === \"string\") {\n      name += `_${references}`;\n    } else if (Array.isArray(references)) {\n      for (const ref of references) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name += `_${references.name}`;\n    }\n  }\n  return getTemplateId(optimize, `${filename}_${section.id}${name}`);\n}\nfunction writeSignals(section) {\n  const signals = [...getSignals(section).values()].sort(sortSignals);\n  for (const signal of signals) {\n    let effectDeclarator;\n    if (signal.effect.length) {\n      const effectIdentifier = t10.identifier(`${signal.identifier.name}_effect`);\n      if (signal.effectInlineReferences) {\n        signal.effect.unshift(\n          t10.variableDeclaration(\"const\", [\n            t10.variableDeclarator(\n              createScopeReadPattern(section, signal.effectInlineReferences),\n              scopeIdentifier\n            )\n          ])\n        );\n      }\n      effectDeclarator = t10.variableDeclarator(\n        effectIdentifier,\n        callRuntime(\n          \"register\",\n          t10.stringLiteral(getResumeRegisterId(section, signal.reserve)),\n          t10.arrowFunctionExpression(\n            [scopeIdentifier],\n            signal.effect.length === 1 && t10.isExpressionStatement(signal.effect[0]) ? signal.effect[0].expression : t10.blockStatement(signal.effect)\n          )\n        )\n      );\n      signal.render.push(\n        t10.expressionStatement(\n          callRuntime(\"queueEffect\", scopeIdentifier, effectIdentifier)\n        )\n      );\n    }\n    const value = signal.register ? callRuntime(\n      \"register\",\n      t10.stringLiteral(getResumeRegisterId(section, signal.reserve)),\n      signal.build()\n    ) : signal.build();\n    if (t10.isCallExpression(value)) {\n      finalizeSignalArgs(value.arguments);\n    }\n    const signalDeclarator = t10.variableDeclarator(signal.identifier, value);\n    const roots = currentProgramPath.pushContainer(\n      \"body\",\n      effectDeclarator ? [\n        t10.variableDeclaration(\"const\", [effectDeclarator]),\n        t10.variableDeclaration(\"const\", [signalDeclarator])\n      ] : t10.variableDeclaration(\"const\", [signalDeclarator])\n    );\n    for (const root of roots) {\n      root.traverse(bindFunctionsVisitor, { root, section });\n    }\n  }\n}\nfunction sortSignals(a, b) {\n  const aReserves = getReserves(a);\n  const bReserves = getReserves(b);\n  for (let i = Math.max(aReserves.length, bReserves.length) - 1; i >= 0; i--) {\n    const diff = (bReserves[i] ?? -1) - (aReserves[i] ?? -1);\n    if (diff !== 0)\n      return diff;\n  }\n  return 0;\n}\nfunction getReserves({ reserve }) {\n  if (!reserve) {\n    return [];\n  } else if (Array.isArray(reserve)) {\n    return reserve.map(getMappedId).sort();\n  } else {\n    return [getMappedId(reserve)];\n  }\n}\nfunction getMappedId(reserve) {\n  return (reserve.type === 0 ? 1 : 0) * 1e4 + reserve.id;\n}\nfunction addHTMLEffectCall(section, references) {\n  addStatement(\"effect\", section, references, void 0, []);\n}\nfunction writeHTMLResumeStatements(path3, tagVarIdentifier) {\n  const section = getOrCreateSection(path3);\n  const intersections = currentProgramPath.node.extra.intersectionsBySection?.[section.id] ?? [];\n  const allSignals = Array.from(getSignals(section).values());\n  const scopeIdIdentifier = getScopeIdIdentifier(section);\n  const serializedReferences = [];\n  for (const intersection of intersections) {\n    for (const reference of intersection) {\n      if (reference.type !== 0 /* Visit */) {\n        repeatableReserves.add(serializedReferences, reference);\n      }\n    }\n  }\n  for (let i = allSignals.length; i--; ) {\n    if (allSignals[i].effect.length) {\n      const signalRefs = allSignals[i].reserve;\n      repeatableReserves.addAll(serializedReferences, signalRefs);\n      path3.pushContainer(\n        \"body\",\n        t10.expressionStatement(\n          callRuntime(\n            \"writeEffect\",\n            scopeIdIdentifier,\n            t10.stringLiteral(getResumeRegisterId(section, signalRefs))\n          )\n        )\n      );\n    }\n  }\n  const accessors = /* @__PURE__ */ new Set();\n  const additionalProperties = getSerializedScopeProperties(section);\n  const serializedProperties = serializedReferences.reduce((acc, ref) => {\n    const accessor = getScopeAccessorLiteral(ref);\n    if (ref.section.id === section.id) {\n      acc.push(t10.objectProperty(accessor, t10.identifier(ref.name)));\n      accessors.add(accessor.value);\n    } else {\n      getSerializedScopeProperties(ref.section).set(\n        accessor,\n        t10.identifier(ref.name)\n      );\n      getSerializedScopeProperties(section).set(\n        t10.stringLiteral(\"_\"),\n        callRuntime(\"serializedScope\", getScopeIdIdentifier(ref.section))\n        // TODO: section.parent\n      );\n    }\n    return acc;\n  }, []);\n  if (tagVarIdentifier && returnId(section) !== void 0) {\n    serializedProperties.push(\n      t10.objectProperty(\n        t10.stringLiteral(\"/\" /* TAG_VARIABLE */),\n        tagVarIdentifier\n      )\n    );\n  }\n  for (const [key, value] of additionalProperties) {\n    if (!accessors.has(key.value)) {\n      serializedProperties.push(\n        t10.objectProperty(key, value, !t10.isLiteral(key))\n      );\n      accessors.add(key.value);\n    }\n  }\n  if (serializedProperties.length || forceResumeScope(section)) {\n    const builder = getRegisterScopeBuilder(section);\n    path3.pushContainer(\n      \"body\",\n      t10.expressionStatement(\n        callRuntime(\n          \"writeScope\",\n          scopeIdIdentifier,\n          builder ? builder(t10.objectExpression(serializedProperties)) : t10.objectExpression(serializedProperties)\n        )\n      )\n    );\n  }\n  if (path3.get(\"body\").length) {\n    path3.unshiftContainer(\n      \"body\",\n      t10.variableDeclaration(\"const\", [\n        t10.variableDeclarator(scopeIdIdentifier, callRuntime(\"nextScopeId\"))\n      ])\n    );\n  }\n}\nvar bindFunctionsVisitor = {\n  FunctionExpression: { exit: bindFunction },\n  ArrowFunctionExpression: { exit: bindFunction }\n};\nfunction bindFunction(fn, { root, section }) {\n  const { node } = fn;\n  const { extra } = node;\n  const references = extra?.references;\n  const program = fn.hub.file.path;\n  const functionIdentifier = program.scope.generateUidIdentifier(extra?.name);\n  if (references) {\n    if (node.body.type !== \"BlockStatement\") {\n      node.body = t10.blockStatement([t10.returnStatement(node.body)]);\n    }\n    node.body.body.unshift(\n      t10.variableDeclaration(\"const\", [\n        t10.variableDeclarator(\n          createScopeReadPattern(section, references),\n          scopeIdentifier\n        )\n      ])\n    );\n  }\n  let parent = fn.parentPath;\n  while (parent) {\n    if (parent.isFunction())\n      return;\n    if (parent === root)\n      return;\n    parent = parent.parentPath;\n  }\n  root.insertBefore(\n    t10.variableDeclaration(\"const\", [\n      t10.variableDeclarator(functionIdentifier, node)\n    ])\n  );\n  node.params.unshift(scopeIdentifier);\n  fn.replaceWith(\n    callRuntime(\"bindFunction\", scopeIdentifier, functionIdentifier)\n  );\n}\nfunction getSetup(section) {\n  return getSignals(section).get(void 0)?.identifier;\n}\n\n// src/visitors/program/dom.ts\nvar dom_default = {\n  translate: {\n    exit(program) {\n      visit(program);\n      const section = getSection(program);\n      const templateIdentifier = t11.identifier(\"template\");\n      const walksIdentifier = t11.identifier(\"walks\");\n      const setupIdentifier = t11.identifier(\"setup\");\n      const attrsSignalIdentifier = t11.identifier(\"attrs\");\n      const closuresIdentifier = t11.identifier(\"closures\");\n      const { attrs: attrs2 } = program.node.extra;\n      const { walks, writes, setup } = getSectionMeta(section);\n      forEachSectionReverse((childSection) => {\n        const sectionPath = getSectionPath(childSection);\n        const tagParamsSignal = sectionPath.isProgram() ? void 0 : getTagParamsSignal(\n          sectionPath.get(\"params\")\n        );\n        writeSignals(childSection);\n        if (childSection !== section) {\n          const { walks: walks2, writes: writes2, setup: setup2, register: register2 } = getSectionMeta(childSection);\n          const closures2 = getClosures(childSection);\n          const identifier = getRenderer(childSection);\n          const renderer = callRuntime(\n            \"createRenderer\",\n            writes2,\n            walks2,\n            setup2,\n            closures2.length && t11.arrayExpression(closures2),\n            void 0,\n            void 0,\n            void 0,\n            void 0,\n            tagParamsSignal?.build()\n          );\n          program.node.body.push(\n            t11.variableDeclaration(\"const\", [\n              t11.variableDeclarator(\n                identifier,\n                register2 ? callRuntime(\n                  \"register\",\n                  t11.stringLiteral(\n                    getResumeRegisterId(childSection, \"renderer\")\n                  ),\n                  renderer\n                ) : renderer\n              )\n            ])\n          );\n        }\n      });\n      if (attrs2) {\n        const exportSpecifiers = [];\n        for (const name in attrs2.bindings) {\n          const bindingIdentifier = attrs2.bindings[name];\n          const signalIdentifier = getSignal(\n            section,\n            bindingIdentifier.extra.reserve\n          ).identifier;\n          exportSpecifiers.push(\n            t11.exportSpecifier(signalIdentifier, signalIdentifier)\n          );\n        }\n        program.node.body.push(\n          t11.exportNamedDeclaration(\n            t11.variableDeclaration(\"const\", [\n              t11.variableDeclarator(\n                attrsSignalIdentifier,\n                t11.isIdentifier(attrs2.var) ? getSignal(\n                  section,\n                  attrs2.var.extra.reserve\n                ).identifier : getDestructureSignal(attrs2.bindings, attrs2.var)?.build()\n              )\n            ])\n          ),\n          t11.exportNamedDeclaration(null, exportSpecifiers)\n        );\n      }\n      const closures = getClosures(section);\n      program.node.body.push(\n        t11.exportNamedDeclaration(\n          t11.variableDeclaration(\"const\", [\n            t11.variableDeclarator(\n              templateIdentifier,\n              writes || t11.stringLiteral(\"\")\n            )\n          ])\n        ),\n        t11.exportNamedDeclaration(\n          t11.variableDeclaration(\"const\", [\n            t11.variableDeclarator(walksIdentifier, walks || t11.stringLiteral(\"\"))\n          ])\n        ),\n        t11.exportNamedDeclaration(\n          t11.variableDeclaration(\"const\", [\n            t11.variableDeclarator(\n              setupIdentifier,\n              t11.isNullLiteral(setup) || !setup ? t11.functionExpression(null, [], t11.blockStatement([])) : setup\n            )\n          ])\n        )\n      );\n      if (closures.length) {\n        program.node.body.push(\n          t11.exportNamedDeclaration(\n            t11.variableDeclaration(\"const\", [\n              t11.variableDeclarator(\n                closuresIdentifier,\n                t11.arrayExpression(closures)\n              )\n            ])\n          )\n        );\n      }\n      const {\n        markoOpts: { optimize },\n        opts: { filename }\n      } = program.hub.file;\n      program.node.body.push(\n        t11.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            callRuntime(\n              \"createRenderer\",\n              templateIdentifier,\n              walksIdentifier,\n              setupIdentifier,\n              closures.length && closuresIdentifier,\n              void 0,\n              void 0,\n              void 0,\n              void 0,\n              attrs2 && attrsSignalIdentifier\n            ),\n            t11.stringLiteral(getTemplateId2(optimize, `${filename}`))\n          )\n        )\n      );\n    }\n  }\n};\n\n// src/visitors/program/html.ts\nimport { types as t12 } from \"@marko/compiler\";\nimport { getTemplateId as getTemplateId3 } from \"@marko/babel-utils\";\n\n// src/util/is-static.ts\nfunction isStatic(path3) {\n  return path3.isImportDeclaration() || path3.isExportDeclaration() || path3.isMarkoScriptlet({ static: true });\n}\n\n// src/visitors/program/html.ts\nvar html_default = {\n  translate: {\n    exit(program) {\n      const section = getSection(program);\n      const tagVarIdentifier = program.scope.generateUidIdentifier(\"tagVar\");\n      flushInto(program);\n      writeHTMLResumeStatements(program, tagVarIdentifier);\n      const returnIdentifier = returnId(section);\n      if (returnIdentifier !== void 0) {\n        program.pushContainer(\"body\", t12.returnStatement(returnIdentifier));\n      }\n      const renderContent = [];\n      for (const child of program.get(\"body\")) {\n        if (!isStatic(child)) {\n          renderContent.push(child.node);\n          child.remove();\n        } else if (child.isMarkoScriptlet()) {\n          child.replaceWithMultiple(child.node.body);\n        }\n      }\n      const rendererId = program.scope.generateUidIdentifier(\"renderer\");\n      const { attrs: attrs2 } = program.node.extra;\n      const {\n        markoOpts: { optimize },\n        opts: { filename }\n      } = program.hub.file;\n      program.pushContainer(\"body\", [\n        t12.variableDeclaration(\"const\", [\n          t12.variableDeclarator(\n            rendererId,\n            callRuntime(\n              \"createRenderer\",\n              t12.arrowFunctionExpression(\n                [\n                  attrs2 ? attrs2.var : t12.identifier(\"input\"),\n                  tagVarIdentifier\n                ],\n                t12.blockStatement(renderContent)\n              )\n            )\n          )\n        ]),\n        t12.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            rendererId,\n            t12.stringLiteral(getTemplateId3(optimize, `${filename}`))\n          )\n        )\n      ]);\n    }\n  }\n};\n\n// src/visitors/program/index.ts\nvar currentProgramPath;\nvar scopeIdentifier;\nvar cleanIdentifier;\nvar previousProgramPath = /* @__PURE__ */ new WeakMap();\nvar program_default = {\n  migrate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n    },\n    exit() {\n      currentProgramPath.scope.crawl();\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  analyze: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      startSection(program);\n    },\n    exit() {\n      assignFinalIds();\n      finalizeIntersections();\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  translate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      scopeIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"scope\") : null;\n      cleanIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"clean\") : null;\n      if (getMarkoOpts().output === \"hydrate\") {\n        program.skip();\n        program.node.body = [\n          t13.importDeclaration(\n            [],\n            t13.stringLiteral(program.hub.file.opts.filename)\n          )\n        ];\n        if (program.node.extra.hasInteractiveChild || program.node.extra.isInteractive) {\n          program.node.body.push(t13.expressionStatement(callRuntime(\"init\")));\n        }\n        return;\n      }\n    },\n    exit(program) {\n      if (isOutputHTML()) {\n        html_default.translate.exit(program);\n      } else {\n        dom_default.translate.exit(program);\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  }\n};\n\n// src/visitors/import-declaration.ts\nimport { resolveTagImport } from \"@marko/babel-utils\";\nvar import_declaration_default = {\n  translate: {\n    exit(path3) {\n      const source = path3.get(\"source\");\n      const request = source.node.value;\n      source.node.value = resolveTagImport(source, request) || request;\n    }\n  }\n};\n\n// src/visitors/document-type.ts\nvar document_type_default = {\n  translate(documentType) {\n    if (isOutputHTML()) {\n      writeTo(documentType)`<!${documentType.node.value}>`;\n    }\n    documentType.remove();\n  }\n};\n\n// src/visitors/assignment-expression.ts\nimport { types as t14 } from \"@marko/compiler\";\n\n// src/util/replace-assignments.ts\nvar assignmentReplacer = /* @__PURE__ */ new WeakMap();\nfunction getReplacement(assignment, value) {\n  return assignmentReplacer.get(assignment.node)?.(assignment, value);\n}\nfunction registerAssignmentReplacer(binding, map) {\n  for (const assignment of binding.constantViolations) {\n    assignmentReplacer.set(assignment.node, map);\n  }\n}\n\n// src/visitors/assignment-expression.ts\nvar assignment_expression_default = {\n  translate: {\n    exit(assignment) {\n      if (isOutputDOM()) {\n        const value = assignment.node.operator === \"=\" ? assignment.node.right : t14.binaryExpression(\n          assignment.node.operator.slice(\n            0,\n            -1\n          ),\n          assignment.node.left,\n          assignment.node.right\n        );\n        const replacement = getReplacement(assignment, value);\n        if (replacement) {\n          assignment.replaceWith(replacement);\n        }\n      }\n    }\n  }\n};\n\n// src/visitors/update-expression.ts\nimport { types as t15 } from \"@marko/compiler\";\nvar update_expression_default = {\n  translate: {\n    exit(assignment) {\n      if (isOutputDOM()) {\n        const value = t15.binaryExpression(\n          assignment.node.operator === \"++\" ? \"+\" : \"-\",\n          assignment.node.argument,\n          t15.numericLiteral(1)\n        );\n        const replacement = getReplacement(assignment, value);\n        if (replacement) {\n          assignment.replaceWith(\n            assignment.node.prefix || assignment.parentPath.isExpressionStatement() ? replacement : t15.sequenceExpression([replacement, assignment.node.argument])\n          );\n        }\n      }\n    }\n  }\n};\n\n// src/visitors/declaration.ts\nvar declaration_default = {\n  translate(declaration) {\n    if (isOutputHTML()) {\n      writeTo(declaration)`<?${declaration.node.value}?>`;\n    }\n    declaration.remove();\n  }\n};\n\n// src/visitors/cdata.ts\nvar cdata_default = {\n  translate(cdata) {\n    if (isOutputHTML()) {\n      writeTo(cdata)`<![CDATA[${cdata.node.value}]]>`;\n    }\n    cdata.remove();\n  }\n};\n\n// src/visitors/text.ts\nimport { types as t16 } from \"@marko/compiler\";\nvar text_default = {\n  translate(text) {\n    const followingSiblings = text.container.slice(\n      text.key + 1\n    );\n    let needsSeparator = false;\n    if (isOutputHTML()) {\n      for (const sibling of followingSiblings) {\n        if (t16.isMarkoPlaceholder(sibling)) {\n          needsSeparator = true;\n          break;\n        } else if (t16.isMarkoTag(sibling) || t16.isMarkoText(sibling)) {\n          break;\n        }\n      }\n    }\n    writeTo(text)`${text.node.value}${needsSeparator ? \"<!>\" : \"\"}`;\n    enterShallow(text);\n    text.remove();\n  }\n};\n\n// src/visitors/tag/index.ts\nimport { types as t26 } from \"@marko/compiler\";\nimport {\n  assertNoArgs,\n  getTagDef as getTagDef3,\n  isNativeTag as isNativeTag2\n} from \"@marko/babel-utils\";\n\n// src/util/plugin-hooks.ts\nimport { types as t17 } from \"@marko/compiler\";\nfunction enter2(modulePlugin, path3) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path3;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (isFunctionPlugin(plugin)) {\n    plugin(path3, t17);\n  } else if (plugin.enter) {\n    plugin.enter(path3, t17);\n  }\n  return node !== path3.node;\n}\nfunction exit2(modulePlugin, path3) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path3;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (!isFunctionPlugin(plugin) && plugin.exit) {\n    plugin.exit(path3, t17);\n  }\n  return node !== path3.node;\n}\nfunction isModulePlugin(plugin) {\n  return Boolean(plugin.default);\n}\nfunction isFunctionPlugin(plugin) {\n  return typeof plugin === \"function\";\n}\n\n// src/util/nested-attribute-tags.ts\nimport {\n  isAttributeTag,\n  isLoopTag,\n  isTransparentTag\n} from \"@marko/babel-utils\";\nfunction analyzeAttributeTags(tag) {\n  const { extra } = tag.node;\n  extra.nestedAttributeTags = {};\n  extra.hoistedControlFlows = 0;\n  analyzeChildren(extra, false, false, tag);\n}\nfunction analyzeChildren(rootExtra, repeated, dynamic, tag) {\n  let hasAttributeTags = false;\n  for (const child of tag.get(\"body\").get(\"body\")) {\n    if (child.isMarkoTag()) {\n      if (analyzeChild(rootExtra, repeated, dynamic, child)) {\n        hasAttributeTags = true;\n      }\n    }\n  }\n  return hasAttributeTags;\n}\nfunction analyzeChild(rootExtra, repeated, dynamic, tag) {\n  if (isTransparentTag(tag)) {\n    if (analyzeChildren(rootExtra, repeated || isLoopTag(tag), true, tag)) {\n      if (!isTransparentTag(tag.parentPath.parentPath)) {\n        rootExtra.hoistedControlFlows++;\n      }\n      return true;\n    }\n  } else if (isAttributeTag(tag)) {\n    const attrName = tag.node.name.value.slice(1);\n    const lookup = rootExtra.nestedAttributeTags;\n    const existing = lookup[attrName];\n    const info = existing || (lookup[attrName] = {\n      dynamic: false,\n      repeated: false\n    });\n    info.dynamic ||= dynamic;\n    info.repeated ||= repeated || existing !== void 0;\n    return true;\n  }\n  return false;\n}\n\n// src/visitors/tag/native-tag.ts\nimport { types as t21 } from \"@marko/compiler\";\nimport { getTagDef } from \"@marko/babel-utils\";\n\n// src/util/attrs-to-object.ts\nimport { types as t19 } from \"@marko/compiler\";\n\n// src/util/to-property-name.ts\nimport { types as t18 } from \"@marko/compiler\";\nvar IDENTIFIER_REG = /^[0-9A-Z_$]+$/i;\nfunction toPropertyName(name) {\n  return IDENTIFIER_REG.test(name) ? t18.identifier(name) : t18.stringLiteral(name);\n}\n\n// src/util/attrs-to-object.ts\nfunction attrsToObject(tag, withRenderBody = false) {\n  const { node } = tag;\n  let result = t19.objectExpression([]);\n  const resultExtra = result.extra = {};\n  for (const attr2 of node.attributes) {\n    const value = attr2.value;\n    if (t19.isMarkoSpreadAttribute(attr2)) {\n      result.properties.push(t19.spreadElement(value));\n    } else {\n      result.properties.push(\n        t19.objectProperty(toPropertyName(attr2.name), value)\n      );\n    }\n  }\n  if (withRenderBody) {\n    const { body, params } = node.body;\n    let hoistedControlFlows = node.extra.hoistedControlFlows;\n    if (hoistedControlFlows) {\n      for (const child of tag.get(\"body\").get(\"body\")) {\n        tag.insertBefore(child.node);\n        child.remove();\n        if (child.isConditional() || child.isLoop()) {\n          if (!--hoistedControlFlows) {\n            break;\n          }\n        }\n      }\n    }\n    if (body.length) {\n      result.properties.push(\n        t19.objectMethod(\n          \"method\",\n          t19.identifier(\"renderBody\"),\n          params.length ? [\n            t19.objectPattern([\n              t19.objectProperty(\n                t19.identifier(\"value\"),\n                t19.arrayPattern(params)\n              )\n            ])\n          ] : [],\n          t19.blockStatement(body)\n        )\n      );\n    }\n  }\n  if (result.properties.length) {\n    if (result.properties.length === 1) {\n      const [prop] = result.properties;\n      if (t19.isSpreadElement(prop)) {\n        result = prop.argument;\n        result.extra = resultExtra;\n      }\n    }\n  }\n  return result;\n}\nfunction getRenderBodyProp(attrsObject) {\n  if (t19.isObjectExpression(attrsObject)) {\n    const lastProp = attrsObject.properties[attrsObject.properties.length - 1];\n    if (t19.isObjectMethod(lastProp) && lastProp.key.name === \"renderBody\") {\n      return lastProp;\n    }\n  }\n}\n\n// src/util/translate-var.ts\nimport { types as t20 } from \"@marko/compiler\";\nfunction translateVar(tag, initialValue, kind = \"const\") {\n  const {\n    node: { var: tagVar }\n  } = tag;\n  if (!tagVar) {\n    return;\n  }\n  tag.get(\"var\").remove();\n  tag.insertBefore(\n    t20.variableDeclaration(kind, [\n      t20.variableDeclarator(t20.cloneDeep(tagVar), initialValue)\n    ])\n  );\n  tag.hub.file.path.scope.crawl();\n}\n\n// src/util/evaluate.ts\nfunction evaluate(path3) {\n  let { extra } = path3.node;\n  if (!extra) {\n    extra = path3.node.extra = {};\n  }\n  if (extra.confident === void 0) {\n    const value = path3.get(\"value\");\n    const { confident, value: computed } = value.evaluate();\n    extra.computed = computed;\n    extra.confident = confident;\n  }\n  return extra;\n}\n\n// src/visitors/tag/native-tag.ts\nvar native_tag_default = {\n  analyze: {\n    enter(tag) {\n      const { node } = tag;\n      const attrs2 = tag.get(\"attributes\");\n      let section = tag.has(\"var\") ? getOrCreateSection(tag) : void 0;\n      if (attrs2.some(isSpreadAttr)) {\n      } else {\n        for (const attr2 of attrs2) {\n          const attrNode = attr2.node;\n          const { name: name2 } = attrNode;\n          if (isEventHandler(name2)) {\n            section ??= getOrCreateSection(tag);\n            (currentProgramPath.node.extra ?? {}).isInteractive = true;\n          } else if (!evaluate(attr2).confident) {\n            section ??= getOrCreateSection(tag);\n          }\n        }\n      }\n      const name = node.var ? node.var.name : node.name.value;\n      if (section !== void 0) {\n        reserveScope(\n          0 /* Visit */,\n          section,\n          node,\n          name,\n          `#${tag.get(\"name\").evaluate().value}`\n        );\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { extra } = tag.node;\n      const isHTML = isOutputHTML();\n      const name = tag.get(\"name\");\n      const attrs2 = tag.get(\"attributes\");\n      const tagDef = getTagDef(tag);\n      const hasSpread = attrs2.some((attr2) => attr2.isMarkoSpreadAttribute());\n      const write2 = writeTo(tag);\n      const section = getSection(tag);\n      if (isHTML && extra.tagNameNullable) {\n        flushBefore(tag);\n      }\n      if (tag.has(\"var\")) {\n        if (isHTML) {\n          translateVar(\n            tag,\n            t21.arrowFunctionExpression(\n              [],\n              t21.blockStatement([\n                t21.throwStatement(\n                  t21.newExpression(t21.identifier(\"Error\"), [\n                    t21.stringLiteral(\"Cannot reference DOM node from server\")\n                  ])\n                )\n              ])\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let createElFunction = void 0;\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (reference.parentPath?.isCallExpression()) {\n              reference.parentPath.replaceWith(\n                t21.expressionStatement(\n                  createScopeReadExpression(referenceSection, extra.reserve)\n                )\n              );\n            } else {\n              createElFunction ??= t21.identifier(varName + \"_getter\");\n              reference.replaceWith(\n                callRuntime(\n                  \"bindFunction\",\n                  getScopeExpression(referenceSection, extra.reserve.section),\n                  createElFunction\n                )\n              );\n            }\n          }\n          if (createElFunction) {\n            currentProgramPath.pushContainer(\n              \"body\",\n              t21.variableDeclaration(\"const\", [\n                t21.variableDeclarator(\n                  createElFunction,\n                  t21.arrowFunctionExpression(\n                    [scopeIdentifier],\n                    t21.memberExpression(\n                      scopeIdentifier,\n                      getScopeAccessorLiteral(extra.reserve),\n                      true\n                    )\n                  )\n                )\n              ])\n            );\n          }\n        }\n      }\n      let visitAccessor;\n      if (extra.reserve) {\n        visitAccessor = getScopeAccessorLiteral(extra.reserve);\n        visit(tag, 32 /* Get */);\n      }\n      write2`<${name.node}`;\n      if (hasSpread) {\n        const attrsCallExpr = callRuntime(\n          \"attrs\",\n          scopeIdentifier,\n          attrsToObject(tag)\n        );\n        if (isHTML) {\n          write2`${attrsCallExpr}`;\n        } else {\n          tag.insertBefore(t21.expressionStatement(attrsCallExpr));\n        }\n      } else {\n        for (const attr2 of attrs2) {\n          const name2 = attr2.node.name;\n          const extra2 = attr2.node.extra ?? {};\n          const value = attr2.get(\"value\");\n          const { confident, computed, valueReferences } = extra2;\n          switch (name2) {\n            case \"class\":\n            case \"style\": {\n              const helper = `${name2}Attr`;\n              if (confident) {\n                write2`${getHTMLRuntime()[helper](computed)}`;\n              } else if (isHTML) {\n                write2`${callRuntime(helper, value.node)}`;\n              } else {\n                addStatement(\n                  \"render\",\n                  section,\n                  valueReferences,\n                  t21.expressionStatement(\n                    callRuntime(\n                      helper,\n                      t21.memberExpression(scopeIdentifier, visitAccessor, true),\n                      value.node\n                    )\n                  )\n                );\n              }\n              break;\n            }\n            default:\n              if (confident) {\n                write2`${getHTMLRuntime().attr(name2, computed)}`;\n              } else if (isHTML) {\n                if (isEventHandler(name2)) {\n                  addHTMLEffectCall(section, valueReferences);\n                } else {\n                  write2`${callRuntime(\n                    \"attr\",\n                    t21.stringLiteral(name2),\n                    value.node\n                  )}`;\n                }\n              } else if (isEventHandler(name2)) {\n                addStatement(\n                  \"effect\",\n                  section,\n                  valueReferences,\n                  t21.expressionStatement(\n                    callRuntime(\n                      \"on\",\n                      t21.memberExpression(scopeIdentifier, visitAccessor, true),\n                      t21.stringLiteral(getEventHandlerName(name2)),\n                      value.node\n                    )\n                  ),\n                  value.node\n                );\n              } else {\n                addStatement(\n                  \"render\",\n                  section,\n                  valueReferences,\n                  t21.expressionStatement(\n                    callRuntime(\n                      \"attr\",\n                      t21.memberExpression(scopeIdentifier, visitAccessor, true),\n                      t21.stringLiteral(name2),\n                      value.node\n                    )\n                  )\n                );\n              }\n              break;\n          }\n        }\n      }\n      if (tagDef && tagDef.parseOptions?.openTagOnly) {\n        switch (tagDef.htmlType) {\n          case \"svg\":\n          case \"math\":\n            write2`/>`;\n            break;\n          default:\n            write2`>`;\n            break;\n        }\n      } else {\n        write2`>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(t21.ifStatement(name.node, consumeHTML(tag)))[0].skip();\n      }\n      enter(tag);\n    },\n    exit(tag) {\n      const { extra } = tag.node;\n      const isHTML = isOutputHTML();\n      const openTagOnly = getTagDef(tag)?.parseOptions?.openTagOnly;\n      if (isHTML && extra.tagNameNullable) {\n        flushInto(tag);\n      }\n      tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n      if (!openTagOnly) {\n        writeTo(tag)`</${tag.node.name}>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(\n          t21.ifStatement(tag.node.name, consumeHTML(tag))\n        )[0].skip();\n      }\n      if (extra.reserve) {\n        markNode(tag);\n      }\n      exit(tag);\n      tag.remove();\n    }\n  }\n};\nfunction isSpreadAttr(attr2) {\n  return attr2.type === \"MarkoSpreadAttribute\";\n}\nfunction isEventHandler(propName) {\n  return /^on[A-Z-]/.test(propName);\n}\nfunction getEventHandlerName(propName) {\n  return propName.charAt(2) === \"-\" ? propName.slice(3) : propName.charAt(2).toLowerCase() + propName.slice(3);\n}\n\n// src/visitors/tag/custom-tag.ts\nimport { types as t22 } from \"@marko/compiler\";\nimport {\n  getTagDef as getTagDef2,\n  importDefault,\n  importNamed as importNamed2,\n  loadFileForTag as loadFileForTag2,\n  resolveRelativePath\n} from \"@marko/babel-utils\";\nvar custom_tag_default = {\n  analyze: {\n    enter(tag) {\n      trackReferences(tag);\n      const body = tag.get(\"body\");\n      if (body.get(\"body\").length) {\n        startSection(body);\n      }\n      if (getTagDef2(tag)?.template) {\n        reserveScope(\n          0 /* Visit */,\n          getOrCreateSection(tag),\n          tag.node,\n          \"#childScope\"\n        );\n      }\n      const childFile = loadFileForTag2(tag);\n      const childProgramExtra = childFile?.ast.program.extra;\n      const hasInteractiveChild = childProgramExtra?.isInteractive || childProgramExtra?.hasInteractiveChild;\n      if (hasInteractiveChild) {\n        (currentProgramPath.node.extra ?? {}).hasInteractiveChild = true;\n      }\n    },\n    exit(tag) {\n      const tagDef = getTagDef2(tag);\n      const template = tagDef?.template;\n      const section = getOrCreateSection(tag);\n      if (template) {\n        tag.node.extra.attrsReferences = mergeReferences(\n          section,\n          tag.node.attributes.filter((attr2) => attr2.extra?.valueReferences).map((attr2) => [attr2.extra, \"valueReferences\"])\n        );\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML(tag);\n      } else {\n        translateDOM(tag);\n      }\n    }\n  }\n};\nfunction translateHTML(tag) {\n  const tagBody = tag.get(\"body\");\n  const { node } = tag;\n  let tagIdentifier;\n  flushInto(tag);\n  writeHTMLResumeStatements(tagBody);\n  if (t22.isStringLiteral(node.name)) {\n    const { file } = tag.hub;\n    const tagName = node.name.value;\n    const relativePath = getTagRelativePath(tag);\n    tagIdentifier = t22.memberExpression(\n      importDefault(file, relativePath, tagName),\n      t22.identifier(\"_\")\n    );\n  } else {\n    tagIdentifier = node.name;\n  }\n  const tagVar = node.var;\n  const attrsObject = attrsToObject(tag, true);\n  const renderBodyProp = getRenderBodyProp(attrsObject);\n  if (node.extra.tagNameNullable) {\n    let renderBodyId = void 0;\n    let renderTagExpr = callExpression(\n      tagIdentifier,\n      attrsToObject(tag)\n    );\n    if (renderBodyProp) {\n      renderBodyId = tag.scope.generateUidIdentifier(\"renderBody\");\n      const [renderBodyPath] = tag.insertBefore(\n        t22.variableDeclaration(\"const\", [\n          t22.variableDeclarator(\n            renderBodyId,\n            callRuntime(\n              \"createRenderer\",\n              t22.arrowFunctionExpression(\n                renderBodyProp.params.length ? [\n                  t22.objectPattern([\n                    t22.objectProperty(\n                      t22.identifier(\"value\"),\n                      t22.arrayPattern(renderBodyProp.params)\n                    )\n                  ])\n                ] : [],\n                renderBodyProp.body\n              )\n            )\n          )\n        ])\n      );\n      renderBodyPath.skip();\n      attrsObject.properties[attrsObject.properties.length - 1] = t22.objectProperty(t22.identifier(\"renderBody\"), renderBodyId);\n    }\n    if (tagVar) {\n      translateVar(tag, t22.unaryExpression(\"void\", t22.numericLiteral(0)), \"let\");\n      renderTagExpr = t22.assignmentExpression(\"=\", tagVar, renderTagExpr);\n    }\n    tag.replaceWith(\n      t22.ifStatement(\n        tagIdentifier,\n        t22.expressionStatement(renderTagExpr),\n        renderBodyId && callStatement(renderBodyId)\n      )\n    )[0].skip();\n  } else if (tagVar) {\n    const section = getSection(tag);\n    translateVar(\n      tag,\n      callExpression(\n        tagIdentifier,\n        attrsObject,\n        callRuntime(\n          \"register\",\n          callRuntime(\n            \"createRenderer\",\n            t22.arrowFunctionExpression([], t22.blockStatement([]))\n          ),\n          t22.stringLiteral(\n            getResumeRegisterId(\n              section,\n              node.var.extra?.reserve\n            )\n          ),\n          getScopeIdIdentifier(section)\n        )\n      )\n    );\n    setForceResumeScope(section);\n    tag.remove();\n  } else {\n    tag.replaceWith(callStatement(tagIdentifier, attrsObject))[0].skip();\n  }\n}\nfunction translateDOM(tag) {\n  const tagSection = getSection(tag);\n  const tagBody = tag.get(\"body\");\n  const tagBodySection = getSection(tagBody);\n  const { node } = tag;\n  const write2 = writeTo(tag);\n  const binding = node.extra.reserve;\n  const { file } = tag.hub;\n  const tagName = node.name.value;\n  const relativePath = getTagRelativePath(tag);\n  const childFile = loadFileForTag2(tag);\n  const childProgram = childFile.ast.program;\n  const tagIdentifier = importNamed2(file, relativePath, \"setup\", tagName);\n  let tagAttrsIdentifier;\n  if (childProgram.extra.attrs) {\n    tagAttrsIdentifier = importNamed2(\n      file,\n      relativePath,\n      \"attrs\",\n      `${tagName}_attrs`\n    );\n  }\n  write2`${importNamed2(file, relativePath, \"template\", `${tagName}_template`)}`;\n  injectWalks(\n    tag,\n    importNamed2(file, relativePath, \"walks\", `${tagName}_walks`)\n  );\n  if (childProgram.extra.closures) {\n    getClosures(tagSection).push(\n      callRuntime(\n        \"childClosures\",\n        importNamed2(file, relativePath, \"closures\", `${tagName}_closures`),\n        getScopeAccessorLiteral(binding)\n      )\n    );\n  }\n  let attrsObject = attrsToObject(tag);\n  if (tagBodySection !== tagSection) {\n    attrsObject ??= t22.objectExpression([]);\n    attrsObject.properties.push(\n      t22.objectProperty(\n        t22.identifier(\"renderBody\"),\n        callRuntime(\n          \"bindRenderer\",\n          scopeIdentifier,\n          getRenderer(tagBodySection)\n        )\n      )\n    );\n  }\n  if (node.var) {\n    const source = initValue(\n      // TODO: support destructuring\n      node.var.extra.reserve\n    );\n    source.register = true;\n    addStatement(\n      \"render\",\n      tagSection,\n      void 0,\n      t22.expressionStatement(\n        callRuntime(\n          \"setTagVar\",\n          scopeIdentifier,\n          getScopeAccessorLiteral(binding),\n          source.identifier\n        )\n      )\n    );\n  }\n  addStatement(\n    \"render\",\n    tagSection,\n    void 0,\n    t22.expressionStatement(\n      t22.callExpression(tagIdentifier, [\n        createScopeReadExpression(tagSection, binding)\n      ])\n    )\n  );\n  if (attrsObject && tagAttrsIdentifier) {\n    addValue(\n      tagSection,\n      tag.node.extra.attrsReferences,\n      {\n        identifier: tagAttrsIdentifier,\n        hasDownstreamIntersections: () => true\n      },\n      attrsObject,\n      createScopeReadExpression(tagSection, binding),\n      callRuntime(\n        \"inChild\",\n        getScopeAccessorLiteral(binding),\n        t22.identifier(tagAttrsIdentifier.name)\n      )\n    );\n  }\n  tag.remove();\n}\nfunction getTagRelativePath(tag) {\n  const {\n    node,\n    hub: { file }\n  } = tag;\n  const nameIsString = t22.isStringLiteral(node.name);\n  let relativePath;\n  if (nameIsString) {\n    const tagDef = getTagDef2(tag);\n    const template = tagDef?.template;\n    relativePath = template && resolveRelativePath(file, template);\n  }\n  if (!relativePath) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `Unable to find entry point for custom tag <${nameIsString ? node.name.value : node.name}>.`\n    );\n  }\n  const tags = file.metadata.marko.tags;\n  if (!tags.includes(relativePath)) {\n    tags.push(relativePath);\n  }\n  return relativePath;\n}\nfunction callStatement(id, ...args) {\n  return t22.expressionStatement(callExpression(id, ...args));\n}\nfunction callExpression(id, ...args) {\n  return t22.callExpression(id, args.filter(Boolean));\n}\n\n// src/visitors/tag/dynamic-tag.ts\nimport { types as t24 } from \"@marko/compiler\";\n\n// src/util/to-first-expression-or-block.ts\nimport { types as t23 } from \"@marko/compiler\";\nfunction toFirstExpressionOrBlock(body) {\n  const nodes = body.body;\n  if (nodes.length === 1 && t23.isExpressionStatement(nodes[0])) {\n    return nodes[0].expression;\n  }\n  if (t23.isBlockStatement(body)) {\n    return body;\n  }\n  return t23.blockStatement(nodes);\n}\n\n// src/visitors/tag/dynamic-tag.ts\nimport {\n  getTemplateId as getTemplateId4,\n  importDefault as importDefault2,\n  importNamed as importNamed3,\n  loadFileForTag as loadFileForTag3\n} from \"@marko/babel-utils\";\nvar dynamic_tag_default = {\n  analyze: {\n    enter(tag) {\n      reserveScope(\n        0 /* Visit */,\n        getOrCreateSection(tag),\n        tag.node,\n        \"dynamicTagName\",\n        \"#text\"\n      );\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      tag.node.extra.attrsReferences = mergeReferences(\n        getOrCreateSection(tag),\n        tag.node.attributes.filter((attr2) => attr2.extra?.valueReferences).map((attr2) => [attr2.extra, \"valueReferences\"])\n      );\n      addBindingToReferences(tag, \"attrsReferences\", tag.node.extra.reserve);\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag, 37 /* Replace */);\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      let tagExpression = node.name;\n      if (t24.isStringLiteral(tagExpression)) {\n        const { file } = tag.hub;\n        const relativePath = getTagRelativePath(tag);\n        tagExpression = importDefault2(file, relativePath, tagExpression.value);\n      }\n      if (tag.node.extra?.___featureType === \"class\") {\n        importDefault2(\n          tag.hub.file,\n          `marko/src/runtime/helpers/tags-compat-${isOutputHTML() ? \"html\" : \"dom\"}.js`,\n          \"marko_tags_compat\"\n        );\n        if (isOutputHTML()) {\n          const serialized5to6 = importNamed3(\n            tag.hub.file,\n            `marko/src/runtime/helpers/tags-compat-html.js`,\n            \"serialized5to6\"\n          );\n          currentProgramPath.pushContainer(\n            \"body\",\n            t24.expressionStatement(\n              t24.callExpression(serialized5to6, [\n                t24.identifier(tagExpression.name),\n                t24.stringLiteral(\n                  getTemplateId4(\n                    isOptimize(),\n                    loadFileForTag3(tag).metadata.marko.id\n                  )\n                )\n              ])\n            )\n          );\n        } else {\n          currentProgramPath.pushContainer(\n            \"body\",\n            t24.expressionStatement(\n              callRuntime(\n                \"register\",\n                t24.stringLiteral(\n                  getTemplateId4(\n                    isOptimize(),\n                    loadFileForTag3(tag).metadata.marko.id\n                  )\n                ),\n                t24.identifier(tagExpression.name)\n              )\n            )\n          );\n        }\n      }\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        const attrsObject = attrsToObject(tag, true);\n        const emptyAttrs = t24.isObjectExpression(attrsObject) && !attrsObject.properties.length;\n        const renderBodyProp = getRenderBodyProp(attrsObject);\n        const args = [\n          tagExpression,\n          emptyAttrs ? t24.nullLiteral() : attrsObject\n        ];\n        if (renderBodyProp) {\n          attrsObject.properties.pop();\n          args.push(\n            callRuntime(\n              \"createRenderer\",\n              t24.arrowFunctionExpression(\n                renderBodyProp.params.length ? [\n                  t24.objectPattern([\n                    t24.objectProperty(\n                      t24.identifier(\"value\"),\n                      t24.arrayPattern(renderBodyProp.params)\n                    )\n                  ])\n                ] : [],\n                toFirstExpressionOrBlock(renderBodyProp.body)\n              )\n            )\n          );\n        }\n        const dynamicScopeIdentifier = currentProgramPath.scope.generateUidIdentifier(\"dynamicScope\");\n        const dynamicTagExpr = callRuntime(\"dynamicTag\", ...args);\n        if (node.var) {\n          translateVar(tag, dynamicTagExpr);\n          tag.remove();\n        } else {\n          tag.replaceWith(\n            t24.variableDeclaration(\"const\", [\n              t24.variableDeclarator(dynamicScopeIdentifier, dynamicTagExpr)\n            ])\n          )[0].skip();\n        }\n        const section = getSection(tag);\n        writeTo(tag)`${callRuntime(\n          \"markResumeControlEnd\",\n          getScopeIdIdentifier(section),\n          getScopeAccessorLiteral(node.extra.reserve)\n        )}`;\n        getSerializedScopeProperties(section).set(\n          t24.stringLiteral(\n            getScopeAccessorLiteral(node.extra.reserve).value + \"!\"\n          ),\n          dynamicScopeIdentifier\n        );\n        getSerializedScopeProperties(section).set(\n          t24.stringLiteral(\n            getScopeAccessorLiteral(node.extra.reserve).value + \"(\"\n          ),\n          t24.isIdentifier(tagExpression) ? t24.identifier(tagExpression.name) : tagExpression\n        );\n      } else {\n        const section = getSection(tag);\n        const bodySection = getSection(tag.get(\"body\"));\n        const hasBody = section !== bodySection;\n        const renderBodyIdentifier = hasBody && getRenderer(bodySection);\n        const tagNameReserve = node.extra?.reserve;\n        const signal = getSignal(section, tagNameReserve);\n        signal.build = () => {\n          return callRuntime(\n            \"conditional\",\n            getScopeAccessorLiteral(tagNameReserve),\n            getSignalFn(signal, [scopeIdentifier]),\n            buildSignalIntersections(signal),\n            buildSignalValuesWithIntersections(signal)\n          );\n        };\n        signal.hasDownstreamIntersections = () => true;\n        addValue(\n          section,\n          node.extra?.nameReferences,\n          signal,\n          renderBodyIdentifier ? t24.logicalExpression(\"||\", tagExpression, renderBodyIdentifier) : tagExpression\n        );\n        const attrsObject = attrsToObject(tag, true);\n        const emptyAttrs = t24.isObjectExpression(attrsObject) && !attrsObject.properties.length;\n        if (!emptyAttrs || renderBodyIdentifier) {\n          const attrsGetter = t24.arrowFunctionExpression([], attrsObject);\n          const id = currentProgramPath.scope.generateUidIdentifier(\n            tag.get(\"name\").toString() + \"_input\"\n          );\n          let added = false;\n          addValue(\n            section,\n            node.extra?.attrsReferences,\n            {\n              get identifier() {\n                if (!added) {\n                  currentProgramPath.pushContainer(\n                    \"body\",\n                    t24.variableDeclaration(\"const\", [\n                      t24.variableDeclarator(\n                        id,\n                        callRuntime(\n                          \"dynamicTagAttrs\",\n                          getScopeAccessorLiteral(tagNameReserve),\n                          renderBodyIdentifier\n                        )\n                      )\n                    ])\n                  );\n                  added = true;\n                }\n                return id;\n              },\n              hasDownstreamIntersections: () => true\n            },\n            attrsGetter\n          );\n        }\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/visitors/tag/attribute-tag.ts\nimport { types as t25 } from \"@marko/compiler\";\nimport { assertNoVar as assertNoVar2, findParentTag } from \"@marko/babel-utils\";\nvar attribute_tag_default = {\n  analyze: {\n    enter(tag) {\n      const body = tag.get(\"body\");\n      if (body.get(\"body\").length) {\n        startSection(body);\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      getSection(tag.get(\"body\"));\n      if (hasPendingHTML(tag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"Dynamic @tags cannot be mixed with body content.\"\n        );\n      }\n    },\n    exit(tag) {\n      assertNoVar2(tag);\n      flushInto(tag);\n      const parentTag = findParentTag(tag);\n      if (!parentTag) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags must be nested within another tag.\");\n      }\n      const parentExtra = parentTag.node.extra;\n      if (parentExtra.tagNameType === 0 /* NativeTag */) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags cannot be nested under native tags.\");\n      }\n      const attrName = tag.node.name.value.slice(1);\n      const info = parentExtra.nestedAttributeTags[attrName];\n      const attrsObject = attrsToObject(tag, true);\n      if (info.dynamic) {\n        if (!info.identifier) {\n          info.identifier = parentTag.scope.generateUidIdentifier(attrName);\n          parentTag.insertBefore(\n            info.repeated ? t25.variableDeclaration(\"const\", [\n              t25.variableDeclarator(info.identifier, t25.arrayExpression([]))\n            ]) : t25.variableDeclaration(\"let\", [\n              t25.variableDeclarator(info.identifier)\n            ])\n          );\n          parentTag.pushContainer(\n            \"attributes\",\n            t25.markoAttribute(attrName, info.identifier)\n          );\n        }\n        tag.replaceWith(\n          t25.expressionStatement(\n            info.repeated ? t25.callExpression(\n              t25.memberExpression(info.identifier, t25.identifier(\"push\")),\n              [attrsObject]\n            ) : t25.assignmentExpression(\"=\", info.identifier, attrsObject)\n          )\n        );\n      } else if (info.repeated) {\n        const existingAttr = parentTag.get(\"attributes\").find((attr2) => attr2.node.name === attrName);\n        if (existingAttr) {\n          existingAttr.get(\"value\").pushContainer(\"elements\", attrsObject);\n        } else {\n          parentTag.pushContainer(\n            \"attributes\",\n            t25.markoAttribute(attrName, t25.arrayExpression([attrsObject]))\n          );\n        }\n        tag.remove();\n      } else {\n        parentTag.pushContainer(\n          \"attributes\",\n          t25.markoAttribute(attrName, attrsObject)\n        );\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/visitors/tag/index.ts\nvar tag_default = {\n  analyze: {\n    enter(tag) {\n      const tagDef = getTagDef3(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        enter2(hook, tag);\n        return;\n      }\n      switch (type) {\n        case 0 /* NativeTag */:\n          native_tag_default.analyze.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.analyze.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.analyze.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const tagDef = getTagDef3(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        exit2(hook, tag);\n        return;\n      }\n      if (type === 0 /* NativeTag */) {\n        return;\n      }\n      analyzeAttributeTags(tag);\n      switch (type) {\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.analyze.exit(tag);\n          break;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagDef = getTagDef3(tag);\n      const extra = tag.node.extra;\n      assertNoArgs(tag);\n      if (tagDef?.translator) {\n        if (tagDef.translator.path) {\n          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);\n        }\n        enter2(tagDef.translator.hook, tag);\n        return;\n      }\n      for (const attr2 of tag.get(\"attributes\")) {\n        if (attr2.isMarkoAttribute()) {\n          if (attr2.node.arguments) {\n            throw attr2.buildCodeFrameError(\n              `Unsupported arguments on the \"${attr2.node.name}\" attribute.`\n            );\n          }\n          if (attr2.node.modifier) {\n            if (isNativeTag2(attr2.parentPath)) {\n              attr2.node.name += `:${attr2.node.modifier}`;\n            } else {\n              throw attr2.buildCodeFrameError(\n                `Unsupported modifier \"${attr2.node.modifier}\".`\n              );\n            }\n          }\n        }\n      }\n      if (extra.tagNameDynamic && extra.tagNameNullable && !tag.get(\"name\").isIdentifier() && isOutputHTML()) {\n        const tagNameId = tag.scope.generateUidIdentifier(\"tagName\");\n        const [tagNameVarPath] = tag.insertBefore(\n          t26.variableDeclaration(\"const\", [\n            t26.variableDeclarator(tagNameId, tag.node.name)\n          ])\n        );\n        tagNameVarPath.skip();\n        tag.set(\"name\", tagNameId);\n      }\n      switch (extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const translator = getTagDef3(tag)?.translator;\n      if (translator) {\n        exit2(translator.hook, tag);\n        return;\n      }\n      switch (tag.node.extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.exit(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.exit(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.exit(tag);\n          break;\n      }\n    }\n  }\n};\n\n// src/visitors/placeholder.ts\nimport { types as t27 } from \"@marko/compiler\";\nimport { isNativeTag as isNativeTag3 } from \"@marko/babel-utils\";\n\n// src/util/is-core-tag.ts\nimport { getTagDef as getTagDef4 } from \"@marko/babel-utils\";\nvar taglibId = \"marko-core\";\nfunction isCoreTag(tag) {\n  return tag.isMarkoTag() && getTagDef4(tag)?.taglibId === taglibId;\n}\nfunction isCoreTagName(tag, name) {\n  return isCoreTag(tag) && tag.node.name.value === name;\n}\n\n// src/visitors/placeholder.ts\nvar ESCAPE_TYPES = {\n  script: \"escapeScript\",\n  style: \"escapeStyle\"\n};\nvar placeholder_default = {\n  analyze(placeholder) {\n    const { node } = placeholder;\n    const { confident, computed } = evaluate(placeholder);\n    if (!(confident && (node.escape || !computed))) {\n      reserveScope(\n        0 /* Visit */,\n        getOrCreateSection(placeholder),\n        node,\n        \"placeholder\",\n        \"#text\"\n      );\n      needsMarker(placeholder);\n    }\n  },\n  translate(placeholder) {\n    const isHTML = isOutputHTML();\n    const write2 = writeTo(placeholder);\n    const extra = placeholder.node.extra;\n    const { confident, computed, valueReferences, reserve } = extra;\n    const canWriteHTML = isHTML || confident && (placeholder.node.escape || !computed);\n    const method = canWriteHTML ? placeholder.node.escape ? ESCAPE_TYPES[getParentTagName(placeholder)] || \"escapeXML\" : \"toString\" : placeholder.node.escape ? \"data\" : \"html\";\n    if (confident && canWriteHTML) {\n      write2`${getHTMLRuntime()[method](computed)}`;\n    } else {\n      if (extra.needsMarker) {\n        visit(placeholder, 37 /* Replace */);\n      } else {\n        if (!isHTML)\n          write2` `;\n        visit(placeholder, 32 /* Get */);\n      }\n      if (isHTML) {\n        write2`${callRuntime(\n          method,\n          placeholder.node.value\n        )}`;\n        markNode(placeholder);\n      } else {\n        addStatement(\n          \"render\",\n          getSection(placeholder),\n          valueReferences,\n          t27.expressionStatement(\n            method === \"data\" ? callRuntime(\n              \"data\",\n              t27.memberExpression(\n                scopeIdentifier,\n                getScopeAccessorLiteral(reserve),\n                true\n              ),\n              placeholder.node.value\n            ) : callRuntime(\n              \"html\",\n              scopeIdentifier,\n              placeholder.node.value,\n              getScopeAccessorLiteral(reserve)\n            )\n          )\n        );\n      }\n    }\n    enterShallow(placeholder);\n    placeholder.remove();\n  }\n};\nfunction getParentTagName({ parentPath }) {\n  return parentPath.isMarkoTag() && isNativeTag3(parentPath) && parentPath.node.name.value || \"\";\n}\nfunction noOutput(path3) {\n  return t27.isMarkoComment(path3) || t27.isMarkoTag(path3) && isCoreTag(path3) && [\"let\", \"const\", \"effect\", \"lifecycle\", \"attrs\", \"get\", \"id\"].includes(\n    path3.node.name.value\n  );\n}\nfunction needsMarker(placeholder) {\n  let prev = placeholder.getPrevSibling();\n  while (prev.node && noOutput(prev)) {\n    prev = prev.getPrevSibling();\n  }\n  if ((prev.node || t27.isProgram(placeholder.parentPath)) && !(t27.isMarkoTag(prev) && isNativeTag3(prev))) {\n    return placeholder.node.extra.needsMarker = true;\n  }\n  let next = placeholder.getNextSibling();\n  while (next.node && noOutput(next)) {\n    next = next.getNextSibling();\n  }\n  if ((next.node || t27.isProgram(placeholder.parentPath)) && !(t27.isMarkoTag(next) && isNativeTag3(next))) {\n    return placeholder.node.extra.needsMarker = true;\n  }\n  return placeholder.node.extra.needsMarker = false;\n}\n\n// src/visitors/scriptlet.ts\nvar scriptlet_default = {\n  translate(scriptlet) {\n    if (isOutputHTML()) {\n      if (scriptlet.node.static)\n        return;\n      scriptlet.replaceWithMultiple(scriptlet.node.body);\n    } else {\n      if (scriptlet.node.static) {\n        scriptlet.replaceWithMultiple(scriptlet.node.body);\n      } else {\n        addStatement(\n          \"render\",\n          getSection(scriptlet),\n          scriptlet.node.extra?.bodyReferences,\n          scriptlet.node.body\n        );\n        scriptlet.remove();\n      }\n    }\n  }\n};\n\n// src/visitors/comment.ts\nvar ieConditionalCommentRegExp = /^\\[if |<!\\[endif\\]$/;\nvar comment_default = {\n  translate(comment) {\n    if (isOutputHTML()) {\n      const { value } = comment.node;\n      if (ieConditionalCommentRegExp.test(value)) {\n        writeTo(comment)`<!--${value}-->`;\n      }\n    }\n    comment.remove();\n  }\n};\n\n// src/core/import.ts\nimport { parseStatements } from \"@marko/babel-utils\";\nvar import_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      parseStatements(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    rootOnly: true,\n    rawOpenTag: true,\n    openTagOnly: true,\n    ignoreAttributes: true,\n    relaxRequireCommas: true\n  },\n  autocomplete: [\n    {\n      displayText: 'import <scope> from \"<path>\"',\n      description: \"Use to import external modules, follows the same syntax as JavaScript imports.\",\n      snippet: 'import ${2} from \"${1:path}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#importing-external-files\"\n    }\n  ]\n};\n\n// src/core/export.ts\nimport { parseStatements as parseStatements2 } from \"@marko/babel-utils\";\nvar export_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      parseStatements2(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    rootOnly: true,\n    rawOpenTag: true,\n    openTagOnly: true,\n    ignoreAttributes: true,\n    relaxRequireCommas: true\n  },\n  autocomplete: [\n    {\n      displayText: \"export <value>\"\n    }\n  ]\n};\n\n// src/core/attrs.ts\nvar attrs_default = {\n  analyze(tag) {\n    if (tag.has(\"var\")) {\n      const varPath = tag.get(\"var\");\n      const bindings = varPath.getBindingIdentifiers();\n      trackReferencesForBindings(getOrCreateSection(tag), varPath);\n      (currentProgramPath.node.extra ??= {}).attrs = {\n        bindings,\n        var: varPath.node\n        // pathsToId: getPathsToId(varPath.node)\n      };\n    }\n  },\n  translate(tag) {\n    const bindings = currentProgramPath.node.extra?.attrs?.bindings;\n    if (bindings) {\n      for (const key in bindings) {\n        initValue(bindings[key].extra.reserve);\n      }\n    }\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"attrs/{ ... }\",\n      description: \"Use to receive the attributes passed into this template.\",\n      snippet: \"attrs/{ $1 }$2\"\n    }\n  ]\n};\n\n// src/core/condition/if.ts\nimport { types as t29 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams2, assertNoVar as assertNoVar3 } from \"@marko/babel-utils\";\n\n// src/util/to-first-statement-or-block.ts\nimport { types as t28 } from \"@marko/compiler\";\nfunction toFirstStatementOrBlock(body) {\n  const nodes = body.body;\n  if (nodes.length === 1) {\n    return nodes[0];\n  }\n  if (t28.isBlockStatement(body)) {\n    return body;\n  }\n  return t28.blockStatement(nodes);\n}\n\n// src/core/condition/if.ts\nvar if_default = {\n  analyze: {\n    enter(tag) {\n      reserveScope(\n        0 /* Visit */,\n        getOrCreateSection(tag),\n        tag.node,\n        \"if\",\n        \"#text\"\n      );\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      analyzeAttributeTags(tag);\n      exitBranchAnalyze(tag);\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [testAttr] = node.attributes;\n      assertNoVar3(tag);\n      assertNoParams2(tag);\n      if (!t29.isMarkoAttribute(testAttr) || !testAttr.default) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          `The '<if>' tag requires a default attribute like '<if=condition>'.`\n        );\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<if>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError(\n            { loc: { start, end } },\n            msg,\n            Error\n          );\n        }\n      }\n      visit(tag, 37 /* Replace */);\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      exitBranchTranslate(tag);\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      snippet: \"if=${1:condition}\",\n      description: \"Use to display content only if the condition is met.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar BRANCHES_LOOKUP = /* @__PURE__ */ new WeakMap();\nfunction getBranches(tag, bodySection) {\n  const branches = BRANCHES_LOOKUP.get(tag) ?? [];\n  const nextTag = tag.getNextSibling();\n  const isLast = !(isCoreTagName(nextTag, \"else\") || isCoreTagName(nextTag, \"else-if\"));\n  branches.push({\n    tag,\n    section: bodySection\n  });\n  if (!isLast) {\n    BRANCHES_LOOKUP.set(nextTag, branches);\n  }\n  return [isLast, branches];\n}\nfunction exitBranchAnalyze(tag) {\n  const section = getOrCreateSection(tag);\n  const tagBody = tag.get(\"body\");\n  const bodySection = getOrCreateSection(tagBody);\n  const [isLast, branches] = getBranches(tag, bodySection);\n  if (isLast) {\n    const rootExtra = branches[0].tag.node.extra;\n    const conditionalReferences = mergeReferences(\n      section,\n      branches.filter(({ tag: tag2 }) => tag2.node.attributes[0]?.extra?.valueReferences).map(({ tag: tag2 }) => [tag2.node.attributes[0].extra, \"valueReferences\"])\n    );\n    rootExtra.conditionalReferences = conditionalReferences;\n    rootExtra.isStateful = !!conditionalReferences;\n    rootExtra.singleNodeOptimization = branches.every(({ tag: tag2 }) => {\n      return tag2.node.body.body.length === 1;\n    });\n  }\n}\nfunction exitBranchTranslate(tag) {\n  const tagBody = tag.get(\"body\");\n  const section = getSection(tag);\n  const bodySection = getSection(tagBody);\n  const [isLast, branches] = getBranches(tag, bodySection);\n  const rootExtra = branches[0].tag.node.extra;\n  const isStateful = rootExtra.isStateful;\n  const singleNodeOptimization = rootExtra.singleNodeOptimization;\n  if (isOutputHTML()) {\n    if (isStateful) {\n      if (!singleNodeOptimization) {\n        writePrependTo(tagBody)`${callRuntime(\n          \"markResumeScopeStart\",\n          getScopeIdIdentifier(bodySection)\n        )}`;\n      }\n      setRegisterScopeBuilder(tag, (scope) => {\n        return t29.assignmentExpression(\n          \"=\",\n          getScopeIdentifier(bodySection),\n          scope\n        );\n      });\n      getSerializedScopeProperties(bodySection).set(\n        t29.stringLiteral(\"_\"),\n        callRuntime(\"serializedScope\", getScopeIdIdentifier(section))\n      );\n    }\n    flushInto(tag);\n    writeHTMLResumeStatements(tagBody);\n  }\n  if (isLast) {\n    const { extra } = branches[0].tag.node;\n    if (isOutputDOM()) {\n      let expr = t29.nullLiteral();\n      for (let i = branches.length; i--; ) {\n        const { tag: tag2, section: section2 } = branches[i];\n        const [testAttr] = tag2.node.attributes;\n        const id = getRenderer(section2);\n        setSubscriberBuilder(tag2, (subscriber) => {\n          return callRuntime(\n            \"inConditionalScope\",\n            subscriber,\n            getScopeAccessorLiteral(extra.reserve)\n            /*writer.getRenderer(section)*/\n          );\n        });\n        if (isStateful) {\n          setRegisterRenderer(section2, true);\n        }\n        tag2.remove();\n        if (testAttr) {\n          expr = t29.conditionalExpression(testAttr.value, id, expr);\n        } else {\n          expr = id;\n        }\n      }\n      const signal = getSignal(section, extra.reserve);\n      signal.build = () => {\n        return callRuntime(\n          \"conditional\",\n          getScopeAccessorLiteral(extra.reserve),\n          getSignalFn(signal, [scopeIdentifier])\n        );\n      };\n      signal.hasDownstreamIntersections = () => branches.some((b) => getClosures(b.section).length > 0);\n      addValue(\n        section,\n        extra.conditionalReferences,\n        signal,\n        expr\n      );\n    } else {\n      const write2 = writeTo(tag);\n      const nextTag = tag.getNextSibling();\n      const ifScopeIdIdentifier = tag.scope.generateUidIdentifier(\"ifScopeId\");\n      const ifScopeIdentifier = getScopeIdentifier(branches[0].section);\n      const ifRendererIdentifier = tag.scope.generateUidIdentifier(\"ifRenderer\");\n      let statement;\n      for (let i = branches.length; i--; ) {\n        const { tag: tag2, section: section2 } = branches[i];\n        const branchScopeIdentifier = getScopeIdentifier(section2, true);\n        branchScopeIdentifier.name = ifScopeIdentifier.name;\n        if (isStateful) {\n          tag2.node.body.body.push(\n            t29.expressionStatement(\n              callRuntime(\n                \"register\",\n                t29.assignmentExpression(\n                  \"=\",\n                  ifRendererIdentifier,\n                  callRuntime(\n                    \"createRenderer\",\n                    t29.arrowFunctionExpression([], t29.blockStatement([]))\n                  )\n                ),\n                t29.stringLiteral(getResumeRegisterId(section2, \"renderer\"))\n              )\n            )\n          );\n          if (singleNodeOptimization) {\n            tag2.node.body.body.push(\n              t29.expressionStatement(\n                t29.assignmentExpression(\n                  \"=\",\n                  ifScopeIdIdentifier,\n                  getScopeIdIdentifier(section2)\n                )\n              )\n            );\n          }\n        }\n        const [testAttr] = tag2.node.attributes;\n        const curStatement = toFirstStatementOrBlock(tag2.node.body);\n        if (testAttr) {\n          statement = t29.ifStatement(testAttr.value, curStatement, statement);\n        } else {\n          statement = curStatement;\n        }\n        tag2.remove();\n      }\n      if (!isStateful) {\n        nextTag.insertBefore(statement);\n      } else {\n        nextTag.insertBefore([\n          t29.variableDeclaration(\n            \"let\",\n            [\n              singleNodeOptimization && t29.variableDeclarator(ifScopeIdIdentifier),\n              t29.variableDeclarator(ifScopeIdentifier),\n              t29.variableDeclarator(ifRendererIdentifier)\n            ].filter(Boolean)\n          ),\n          statement\n        ]);\n        if (singleNodeOptimization) {\n          write2`${callRuntime(\n            \"markResumeControlSingleNodeEnd\",\n            getScopeIdIdentifier(section),\n            getScopeAccessorLiteral(extra.reserve),\n            ifScopeIdIdentifier\n          )}`;\n        } else {\n          write2`${callRuntime(\n            \"markResumeControlEnd\",\n            getScopeIdIdentifier(section),\n            getScopeAccessorLiteral(extra.reserve)\n          )}`;\n        }\n        getSerializedScopeProperties(section).set(\n          t29.stringLiteral(getScopeAccessorLiteral(extra.reserve).value + \"!\"),\n          ifScopeIdentifier\n        );\n        getSerializedScopeProperties(section).set(\n          t29.stringLiteral(getScopeAccessorLiteral(extra.reserve).value + \"(\"),\n          ifRendererIdentifier\n        );\n      }\n    }\n  }\n}\n\n// src/core/condition/else-if.ts\nimport { types as t30 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams3, assertNoVar as assertNoVar4 } from \"@marko/babel-utils\";\nvar else_if_default = {\n  analyze: {\n    enter(tag) {\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      exitBranchAnalyze(tag);\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [defaultAttr] = node.attributes;\n      assertNoVar4(tag);\n      assertNoParams3(tag);\n      if (!t30.isMarkoAttribute(defaultAttr) || !defaultAttr.default) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          `The '<else-if>' tag requires a default attribute like '<else-if=condition>'.`\n        );\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<else-if>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError(\n            { loc: { start, end } },\n            msg,\n            Error\n          );\n        }\n      }\n    },\n    exit(tag) {\n      exitBranchTranslate(tag);\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      snippet: \"else-if=${1:condition}\",\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\n\n// src/core/condition/else.ts\nimport { assertNoParams as assertNoParams4, assertNoVar as assertNoVar5 } from \"@marko/babel-utils\";\nvar else_default = {\n  analyze: {\n    enter(tag) {\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      exitBranchAnalyze(tag);\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [testAttr] = node.attributes;\n      assertNoVar5(tag);\n      assertNoParams4(tag);\n      if (node.attributes.length > 1 || testAttr && testAttr.name !== \"if\") {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<else>' tag only supports an if attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError(\n            { loc: { start, end } },\n            msg,\n            Error\n          );\n        }\n      }\n    },\n    exit(tag) {\n      exitBranchTranslate(tag);\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\n\n// src/core/const.ts\nimport { types as t31 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams5 } from \"@marko/babel-utils\";\nvar const_default = {\n  translate(tag) {\n    const { node } = tag;\n    const [defaultAttr] = node.attributes;\n    assertNoParams5(tag);\n    assertNoBodyContent(tag);\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'const' tag requires a tag variable.\");\n    }\n    if (!defaultAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'const' tag requires a default attribute.\");\n    }\n    if (node.attributes.length > 1 || !t31.isMarkoAttribute(defaultAttr) || !defaultAttr.default && defaultAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The 'const' tag only supports the 'default' attribute.\"\n      );\n    }\n    if (isOutputDOM()) {\n      const section = getSection(tag);\n      const references = defaultAttr.extra?.valueReferences;\n      const derivation = getTagVarSignal(tag.get(\"var\"));\n      addValue(section, references, derivation, defaultAttr.value);\n    } else {\n      translateVar(tag, defaultAttr.value);\n    }\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an constant binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#const\"\n    }\n  ]\n};\n\n// src/core/effect.ts\nimport { types as t32 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams6 } from \"@marko/babel-utils\";\nvar effect_default = {\n  analyze(tag) {\n    reserveScope(\n      1 /* Store */,\n      getOrCreateSection(tag),\n      tag.node,\n      \"cleanup\"\n    );\n    (currentProgramPath.node.extra ?? {}).isInteractive = true;\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [defaultAttr] = node.attributes;\n      assertNoParams6(tag);\n      assertNoBodyContent(tag);\n      if (!defaultAttr) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The 'effect' tag requires a default attribute.\"\n        );\n      }\n      if (node.attributes.length > 1 || !t32.isMarkoAttribute(defaultAttr) || !defaultAttr.default && defaultAttr.name !== \"value\") {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The 'effect' tag only supports the 'default' attribute.\"\n        );\n      }\n      const section = getSection(tag);\n      if (isOutputDOM()) {\n        const { value } = defaultAttr;\n        let inlineStatements = null;\n        if (t32.isFunctionExpression(value) || t32.isArrowFunctionExpression(value) && t32.isBlockStatement(value.body)) {\n          inlineStatements = value.body.body;\n          t32.traverse(value.body, (node2) => {\n            if (t32.isReturnStatement(node2)) {\n              inlineStatements = null;\n            }\n          });\n        }\n        addStatement(\n          \"effect\",\n          section,\n          defaultAttr.extra?.valueReferences,\n          inlineStatements || t32.expressionStatement(\n            callRuntime(\n              \"userEffect\",\n              scopeIdentifier,\n              getScopeAccessorLiteral(tag.node.extra.reserve),\n              defaultAttr.value\n            )\n          ),\n          value,\n          !!inlineStatements\n        );\n      } else {\n        addHTMLEffectCall(section, defaultAttr.extra?.valueReferences);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ]\n};\n\n// src/core/lifecycle.ts\nimport { types as t33 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams7 } from \"@marko/babel-utils\";\nvar lifecycle_default = {\n  analyze: {\n    enter(tag) {\n      custom_tag_default.analyze.enter(tag);\n      reserveScope(\n        1 /* Store */,\n        getOrCreateSection(tag),\n        tag.node,\n        \"cleanup\"\n      );\n      (currentProgramPath.node.extra ?? {}).isInteractive = true;\n    },\n    exit(tag) {\n      custom_tag_default.analyze.exit(tag);\n      const section = getOrCreateSection(tag);\n      tag.node.extra.attrsReferences = mergeReferences(\n        section,\n        tag.node.attributes.filter((attr2) => attr2.extra?.valueReferences).map((attr2) => [attr2.extra, \"valueReferences\"])\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      assertNoParams7(tag);\n      assertNoBodyContent(tag);\n      const section = getSection(tag);\n      if (isOutputDOM()) {\n        const attrsObject = attrsToObject(tag);\n        addStatement(\n          \"effect\",\n          section,\n          node.extra.attrsReferences,\n          t33.expressionStatement(\n            callRuntime(\n              \"lifecycle\",\n              scopeIdentifier,\n              getScopeAccessorLiteral(tag.node.extra.reserve),\n              attrsObject\n            )\n          ),\n          node.attributes.map((a) => a.value)\n        );\n      } else {\n        addHTMLEffectCall(section, node.extra.attrsReferences);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ]\n};\n\n// src/core/id.ts\nimport { types as t34 } from \"@marko/compiler\";\nimport {\n  assertNoArgs as assertNoArgs2,\n  assertNoAttributes,\n  assertNoParams as assertNoParams8\n} from \"@marko/babel-utils\";\nvar id_default = {\n  translate(tag) {\n    const { node } = tag;\n    const { var: tagVar } = node;\n    const id = callRuntime(\"nextTagId\");\n    assertNoArgs2(tag);\n    assertNoAttributes(tag);\n    assertNoBodyContent(tag);\n    assertNoParams8(tag);\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'id' tag requires a tag variable.\");\n    }\n    if (!t34.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The 'id' tag cannot be destructured\");\n    }\n    if (isOutputHTML()) {\n      tag.replaceWith(\n        t34.variableDeclaration(\"const\", [t34.variableDeclarator(node.var, id)])\n      );\n    } else {\n      const source = initValue(tagVar.extra.reserve);\n      addValue(getSection(tag), void 0, source, id);\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"id/<name>\",\n      description: \"Use to create a unique identifier.\",\n      snippet: \"id/${1:name}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#id\"\n    }\n  ]\n};\n\n// src/core/for.ts\nimport { types as t35 } from \"@marko/compiler\";\nimport {\n  assertAllowedAttributes,\n  assertNoVar as assertNoVar6,\n  getTagDef as getTagDef5\n} from \"@marko/babel-utils\";\nvar for_default = {\n  analyze: {\n    enter(tag) {\n      const isOnlyChild = checkOnlyChild(tag);\n      const parentTag = isOnlyChild ? tag.parentPath.parent : void 0;\n      const parentTagName = parentTag?.name?.value;\n      reserveScope(\n        0 /* Visit */,\n        getOrCreateSection(tag),\n        isOnlyChild ? parentTag : tag.node,\n        \"for\",\n        isOnlyChild ? `#${parentTagName}` : \"#text\"\n      );\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      analyzeAttributeTags(tag);\n      const section = getOrCreateSection(tag);\n      tag.node.extra.attrsReferences = mergeReferences(\n        section,\n        tag.node.attributes.filter(\n          (attr2) => t35.isMarkoAttribute(attr2) && attr2.extra?.valueReferences !== void 0\n        ).map((attr2) => [attr2.extra, \"valueReferences\"])\n      );\n      tag.node.extra.isStateful = !!tag.node.extra.attrsReferences && !Object.keys(tag.node.extra.nestedAttributeTags).length;\n      tag.node.extra.singleNodeOptimization = tag.node.body.body.length === 1;\n    }\n  },\n  translate: {\n    enter(tag) {\n      validateFor(tag);\n      const {\n        extra: { isOnlyChild }\n      } = tag.node;\n      if (!isOnlyChild) {\n        visit(tag, 37 /* Replace */);\n        enterShallow(tag);\n      }\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML2.exit(tag);\n      } else {\n        translateDOM2.exit(tag);\n      }\n    }\n  },\n  attributes: {\n    of: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over a list of items.\"\n        }\n      ]\n    },\n    in: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over the keys and values of an object.\"\n        }\n      ]\n    },\n    to: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates up to the provided number (inclusive)\"\n        }\n      ]\n    },\n    from: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates starting from the provided number (inclusive)\"\n        }\n      ]\n    },\n    step: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"The amount to increment during each interation (with from/to)\"\n        }\n      ]\n    }\n  },\n  autocomplete: [\n    {\n      snippet: \"for|${1:value, index}| of=${3:array}\",\n      description: \"Use to iterate over lists, object properties, or between ranges.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-a-list\"\n    },\n    {\n      snippet: \"for|${1:name, value}| in=${3:object}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties\"\n    },\n    {\n      snippet: \"for|${1:index}| from=${2:number} to=${3:number} step=${4:number}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers\"\n    }\n  ]\n};\nvar translateDOM2 = {\n  exit(tag) {\n    const tagBody = tag.get(\"body\");\n    const tagSection = getSection(tag);\n    const bodySection = getSection(tagBody);\n    const { node } = tag;\n    const {\n      attributes,\n      extra: { isOnlyChild, attrsReferences }\n    } = node;\n    const {\n      extra: { reserve }\n    } = isOnlyChild ? tag.parentPath.parent : tag.node;\n    const paramIdentifiers = Object.values(\n      tagBody.getBindingIdentifiers()\n    );\n    setSubscriberBuilder(tag, (signal2) => {\n      return callRuntime(\n        \"inLoopScope\",\n        signal2,\n        getScopeAccessorLiteral(reserve)\n      );\n    });\n    tag.remove();\n    const rendererId = getRenderer(bodySection);\n    const ofAttr = findName(attributes, \"of\");\n    const toAttr = findName(attributes, \"to\");\n    const inAttr = findName(attributes, \"in\");\n    const loopArgs = [];\n    let loopKind;\n    if (ofAttr) {\n      loopKind = \"loopOf\";\n      loopArgs.push(ofAttr.value);\n    } else if (inAttr) {\n      loopKind = \"loopIn\";\n      loopArgs.push(inAttr.value);\n    } else if (toAttr) {\n      const fromAttr = findName(attributes, \"from\");\n      const stepAttr = findName(attributes, \"step\");\n      loopKind = \"loopTo\";\n      loopArgs.push(\n        toAttr.value,\n        fromAttr ? fromAttr.value : t35.numericLiteral(0),\n        stepAttr ? stepAttr.value : t35.numericLiteral(1)\n      );\n    } else {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"Invalid <for> tag. Expected either an 'of', 'to', or 'in' attribute.\"\n      );\n    }\n    const byAttr = findName(attributes, \"by\");\n    if (byAttr) {\n      loopArgs.push(byAttr.value);\n    }\n    const signal = getSignal(tagSection, reserve);\n    signal.build = () => {\n      return callRuntime(\n        loopKind,\n        getScopeAccessorLiteral(reserve),\n        rendererId\n      );\n    };\n    signal.hasDownstreamIntersections = () => {\n      for (const identifier of paramIdentifiers) {\n        if (getSignal(\n          bodySection,\n          identifier.extra.reserve\n        ).hasDownstreamIntersections()) {\n          return true;\n        }\n      }\n      return getClosures(bodySection).length > 0;\n    };\n    addValue(tagSection, attrsReferences, signal, t35.arrayExpression(loopArgs));\n  }\n};\nvar translateHTML2 = {\n  exit(tag) {\n    const tagBody = tag.get(\"body\");\n    const tagSection = getSection(tag);\n    const bodySection = getSection(tagBody);\n    const { node } = tag;\n    const {\n      attributes,\n      body: { body, params },\n      extra: { isStateful, singleNodeOptimization, isOnlyChild }\n    } = node;\n    const {\n      extra: { reserve }\n    } = isOnlyChild ? tag.parentPath.parent : node;\n    const namePath = tag.get(\"name\");\n    const ofAttr = findName(attributes, \"of\");\n    const inAttr = findName(attributes, \"in\");\n    const toAttr = findName(attributes, \"to\");\n    const byAttr = findName(attributes, \"by\");\n    const block = t35.blockStatement(body);\n    const write2 = writeTo(tag);\n    const replacement = [];\n    let byParams;\n    let keyExpression = t35.identifier(\"NOO\");\n    if (isStateful) {\n      if (!singleNodeOptimization) {\n        writePrependTo(tagBody)`${callRuntime(\n          \"markResumeScopeStart\",\n          getScopeIdIdentifier(bodySection)\n        )}`;\n      }\n      setRegisterScopeBuilder(tag, (scope) => {\n        const tempScopeIdentifier = currentProgramPath.scope.generateUidIdentifier(\"s\");\n        return t35.callExpression(\n          t35.arrowFunctionExpression(\n            [tempScopeIdentifier],\n            t35.sequenceExpression([\n              t35.callExpression(\n                t35.memberExpression(\n                  getScopeIdentifier(bodySection),\n                  t35.identifier(\"set\")\n                ),\n                [keyExpression, tempScopeIdentifier]\n              ),\n              tempScopeIdentifier\n            ])\n          ),\n          [scope]\n        );\n      });\n      getSerializedScopeProperties(bodySection).set(\n        t35.stringLiteral(\"_\"),\n        callRuntime(\"serializedScope\", getScopeIdIdentifier(tagSection))\n      );\n    }\n    if (byAttr && isStateful) {\n      const byIdentifier = currentProgramPath.scope.generateUidIdentifier(\"by\");\n      replacement.push(\n        t35.variableDeclaration(\"const\", [\n          t35.variableDeclarator(byIdentifier, byAttr.value)\n        ])\n      );\n      byParams = [];\n      keyExpression = t35.callExpression(byIdentifier, byParams);\n    }\n    if (inAttr) {\n      const [keyParam, valParam] = params;\n      keyExpression = keyParam;\n      if (valParam) {\n        block.body.unshift(\n          t35.variableDeclaration(\"const\", [\n            t35.variableDeclarator(\n              valParam,\n              t35.memberExpression(inAttr.value, keyParam, true)\n            )\n          ])\n        );\n      }\n      replacement.push(\n        t35.forInStatement(\n          t35.variableDeclaration(\"const\", [t35.variableDeclarator(keyParam)]),\n          inAttr.value,\n          block\n        )\n      );\n    } else if (ofAttr) {\n      let ofAttrValue = ofAttr.value;\n      let [valParam, indexParam, loopParam] = params;\n      if (!valParam) {\n        throw namePath.buildCodeFrameError(\n          \"Invalid 'for of' tag, missing |value, index| params.\"\n        );\n      }\n      if (!t35.isIdentifier(valParam) && byParams) {\n        const tempValParam = currentProgramPath.scope.generateUidIdentifier(\"v\");\n        block.body.unshift(\n          t35.variableDeclaration(\"const\", [\n            t35.variableDeclarator(valParam, tempValParam)\n          ])\n        );\n        valParam = tempValParam;\n      }\n      if (indexParam || isStateful) {\n        indexParam ??= currentProgramPath.scope.generateUidIdentifier(\"i\");\n        const indexName = tag.scope.generateUidIdentifierBasedOnNode(\n          indexParam,\n          \"i\"\n        );\n        replacement.push(\n          t35.variableDeclaration(\"let\", [\n            t35.variableDeclarator(indexName, t35.numericLiteral(0))\n          ])\n        );\n        block.body.unshift(\n          t35.variableDeclaration(\"let\", [\n            t35.variableDeclarator(\n              indexParam,\n              t35.updateExpression(\"++\", indexName)\n            )\n          ])\n        );\n      }\n      if (loopParam) {\n        if (t35.isIdentifier(loopParam)) {\n          ofAttrValue = loopParam;\n        }\n        replacement.push(\n          t35.variableDeclaration(\"const\", [\n            t35.variableDeclarator(loopParam, ofAttr.value)\n          ])\n        );\n      }\n      if (byParams) {\n        byParams.push(valParam, indexParam);\n      } else {\n        keyExpression = indexParam;\n      }\n      replacement.push(\n        t35.forOfStatement(\n          t35.variableDeclaration(\"const\", [t35.variableDeclarator(valParam)]),\n          ofAttrValue,\n          block\n        )\n      );\n    } else if (toAttr) {\n      const stepValue = findName(attributes, \"step\")?.value ?? t35.numericLiteral(1);\n      const fromValue = findName(attributes, \"from\")?.value ?? t35.numericLiteral(0);\n      let [indexParam] = params;\n      const stepsName = tag.scope.generateUidIdentifier(\"steps\");\n      const indexName = tag.scope.generateUidIdentifier(\"i\");\n      const stepName = tag.scope.generateUidIdentifier(\"step\");\n      const fromName = tag.scope.generateUidIdentifier(\"from\");\n      if (indexParam || isStateful) {\n        indexParam ??= currentProgramPath.scope.generateUidIdentifier(\"i\");\n        keyExpression = indexParam;\n        block.body.unshift(\n          t35.variableDeclaration(\"const\", [\n            t35.variableDeclarator(\n              indexParam,\n              t35.binaryExpression(\n                \"+\",\n                fromName,\n                t35.binaryExpression(\"*\", indexName, stepName)\n              )\n            )\n          ])\n        );\n      }\n      replacement.push(\n        t35.forStatement(\n          t35.variableDeclaration(\"let\", [\n            t35.variableDeclarator(\n              fromName,\n              t35.logicalExpression(\"??\", fromValue, t35.numericLiteral(0))\n            ),\n            t35.variableDeclarator(\n              stepName,\n              t35.logicalExpression(\"??\", stepValue, t35.numericLiteral(1))\n            ),\n            t35.variableDeclarator(\n              stepsName,\n              t35.binaryExpression(\n                \"/\",\n                t35.binaryExpression(\"-\", toAttr.value, fromName),\n                stepName\n              )\n            ),\n            t35.variableDeclarator(indexName, t35.numericLiteral(0))\n          ]),\n          t35.binaryExpression(\"<=\", indexName, stepsName),\n          t35.updateExpression(\"++\", indexName),\n          block\n        )\n      );\n    }\n    if (isStateful) {\n      const forScopeIdsIdentifier = tag.scope.generateUidIdentifier(\"forScopeIds\");\n      const forScopesIdentifier = getScopeIdentifier(bodySection);\n      replacement.unshift(\n        t35.variableDeclaration(\n          \"const\",\n          [\n            singleNodeOptimization && t35.variableDeclarator(\n              forScopeIdsIdentifier,\n              t35.arrayExpression([])\n            ),\n            t35.variableDeclarator(\n              forScopesIdentifier,\n              t35.newExpression(t35.identifier(\"Map\"), [])\n            )\n          ].filter(Boolean)\n        )\n      );\n      if (singleNodeOptimization) {\n        block.body.push(\n          t35.expressionStatement(\n            t35.callExpression(\n              t35.memberExpression(forScopeIdsIdentifier, t35.identifier(\"push\")),\n              [getScopeIdIdentifier(bodySection)]\n            )\n          )\n        );\n        write2`${callRuntime(\n          \"markResumeControlSingleNodeEnd\",\n          getScopeIdIdentifier(tagSection),\n          getScopeAccessorLiteral(reserve),\n          forScopeIdsIdentifier\n        )}`;\n      } else {\n        write2`${callRuntime(\n          \"markResumeControlEnd\",\n          getScopeIdIdentifier(tagSection),\n          getScopeAccessorLiteral(reserve)\n        )}`;\n      }\n      getSerializedScopeProperties(tagSection).set(\n        t35.stringLiteral(getScopeAccessorLiteral(reserve).value + \"(\"),\n        t35.conditionalExpression(\n          t35.memberExpression(forScopesIdentifier, t35.identifier(\"size\")),\n          forScopesIdentifier,\n          t35.identifier(\"undefined\")\n        )\n      );\n    }\n    flushInto(tag);\n    writeHTMLResumeStatements(tagBody);\n    block.body.push(t35.expressionStatement(callRuntime(\"maybeFlush\")));\n    tag.replaceWithMultiple(replacement);\n  }\n};\nfunction findName(arr, value) {\n  return arr.find((obj) => t35.isMarkoAttribute(obj) && obj.name === value);\n}\nfunction validateFor(tag) {\n  const attrs2 = tag.node.attributes;\n  const hasParams = tag.node.body.params.length > 0;\n  assertNoVar6(tag);\n  if (findName(attrs2, \"of\")) {\n    assertAllowedAttributes(tag, [\"of\", \"by\"]);\n    if (!hasParams) {\n      throw tag.buildCodeFrameError(\n        `Invalid 'for of' tag, missing |value, index| params.`\n      );\n    }\n  } else if (findName(attrs2, \"in\")) {\n    assertAllowedAttributes(tag, [\"in\", \"by\"]);\n    if (!hasParams) {\n      throw tag.buildCodeFrameError(\n        `Invalid 'for in' tag, missing |key, value| params.`\n      );\n    }\n  } else if (findName(attrs2, \"to\")) {\n    assertAllowedAttributes(tag, [\"from\", \"to\", \"step\", \"by\"]);\n  } else {\n    throw tag.buildCodeFrameError(\n      \"Invalid 'for' tag, missing an 'of', 'in' or 'to' attribute.\"\n    );\n  }\n}\nfunction checkOnlyChild(tag) {\n  tag.node.extra ??= {};\n  if (t35.isMarkoTag(tag.parentPath?.parent) && getTagDef5(tag.parentPath.parentPath)?.html) {\n    return tag.node.extra.isOnlyChild = tag.parent.body.length === 1;\n  }\n  return tag.node.extra.isOnlyChild = false;\n}\n\n// src/core/get.ts\nimport path from \"path\";\nimport { types as t36 } from \"@marko/compiler\";\nimport {\n  assertNoParams as assertNoParams9,\n  getTemplateId as getTemplateId5,\n  resolveTagImport as resolveTagImport2\n} from \"@marko/babel-utils\";\nvar get_default = {\n  analyze: {\n    enter(tag) {\n      const section = getOrCreateSection(tag);\n      if (section.id === 0) {\n        (currentProgramPath.node.extra ??= {}).closures = true;\n      }\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit: custom_tag_default.analyze.exit\n  },\n  translate(tag) {\n    assertNoParams9(tag);\n    assertNoBodyContent(tag);\n    if (isOutputHTML()) {\n      flushBefore(tag);\n    }\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const [defaultAttr] = node.attributes;\n    let refId;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"<get> requires a variable to be defined, eg <get/NAME>.\"\n      );\n    }\n    if (defaultAttr === void 0) {\n      refId = \"$\";\n    } else {\n      if (!t36.isMarkoAttribute(defaultAttr) || !defaultAttr.default || !t36.isStringLiteral(defaultAttr.value)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          `The '<get>' tag requires default attribute that is a string that resolves to a Marko file like '<get/val=\"../file.marko\">' or '<get/val=\"<tag-name>\">'.`\n        );\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<get>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError(\n            { loc: { start, end } },\n            msg,\n            Error\n          );\n        }\n      }\n      const defaultAttrValue = tag.get(\"attributes\")[0].get(\"value\");\n      if (defaultAttr.value.value === \".\") {\n        refId = file.metadata.marko.id;\n      } else {\n        const relativeReferencePath = resolveTagImport2(\n          defaultAttrValue,\n          defaultAttrValue.node.value\n        );\n        if (!relativeReferencePath) {\n          throw defaultAttrValue.buildCodeFrameError(\n            \"Unable to resolve template provided to '<get>' tag.\"\n          );\n        }\n        refId = getTemplateId5(\n          file.markoOpts.optimize,\n          path.resolve(\n            file.opts.filename,\n            \"..\",\n            relativeReferencePath\n          )\n        );\n      }\n    }\n    if (isOutputHTML()) {\n      tag.replaceWith(\n        t36.variableDeclaration(\"const\", [\n          t36.variableDeclarator(\n            node.var,\n            callRuntime(\"getInContext\", t36.stringLiteral(refId))\n          )\n        ])\n      );\n    } else {\n      const identifiers = Object.values(\n        tag.get(\"var\").getBindingIdentifiers()\n      );\n      initContextConsumer(refId, identifiers[0].extra.reserve);\n      tag.remove();\n    }\n  },\n  autocomplete: [\n    {\n      displayText: 'get/<name>=\"<from>\"',\n      description: \"Gets a value provided from another template.\",\n      snippet: 'get/${1:name}=\"${2:from}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#get\"\n    }\n  ]\n};\n\n// src/core/html-comment.ts\nimport {\n  assertNoAttributeTags,\n  assertNoAttributes as assertNoAttributes2,\n  assertNoParams as assertNoParams10,\n  assertNoVar as assertNoVar7\n} from \"@marko/babel-utils\";\nvar html_comment_default = {\n  analyze() {\n  },\n  translate: {\n    enter(tag) {\n      enter(tag);\n      writeTo(tag)`<!--`;\n    },\n    exit(tag) {\n      assertNoVar7(tag);\n      assertNoParams10(tag);\n      assertNoAttributes2(tag);\n      assertNoAttributeTags(tag);\n      exit(tag);\n      writeTo(tag)`-->`;\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    // TODO: fix the types for Tag or parseOptions or something\n    text: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an html comment that is not stripped from the output.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#html-comment\"\n    }\n  ]\n};\n\n// src/core/let.ts\nimport { types as t37 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams11 } from \"@marko/babel-utils\";\nvar let_default = {\n  translate(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    const defaultAttr = node.attributes.find(\n      (attr2) => t37.isMarkoAttribute(attr2) && (attr2.default || attr2.name === \"value\")\n    ) ?? t37.markoAttribute(\"value\", t37.identifier(\"undefined\"));\n    assertNoParams11(tag);\n    assertNoBodyContent(tag);\n    if (!tagVar) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'let' tag requires a tag variable.\");\n    }\n    if (!t37.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The 'let' cannot be destructured.\");\n    }\n    if (isOutputDOM()) {\n      const section = getSection(tag);\n      const binding = tagVar.extra.reserve;\n      const source = initValue(binding);\n      const references = defaultAttr.extra?.valueReferences;\n      const isSetup = !references;\n      if (!isSetup) {\n        let initValueId;\n        addValue(\n          section,\n          references,\n          {\n            get identifier() {\n              if (!initValueId) {\n                initValueId = tag.scope.generateUidIdentifier(\n                  source.identifier.name + \"_init\"\n                );\n                currentProgramPath.pushContainer(\n                  \"body\",\n                  t37.variableDeclaration(\"const\", [\n                    t37.variableDeclarator(\n                      initValueId,\n                      callRuntime(\n                        \"initValue\",\n                        getScopeAccessorLiteral(binding),\n                        source.identifier\n                      )\n                    )\n                  ])\n                );\n              }\n              return initValueId;\n            },\n            hasDownstreamIntersections() {\n              return source.hasDownstreamIntersections();\n            }\n          },\n          defaultAttr.value\n        );\n      } else {\n        addValue(section, references, source, defaultAttr.value);\n      }\n      registerAssignmentReplacer(\n        tag.scope.getBinding(binding.name),\n        (assignment, value) => queueSource(source, value, getSection(assignment))\n      );\n    } else {\n      translateVar(tag, defaultAttr.value);\n    }\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a mutable binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#let\"\n    }\n  ]\n};\n\n// src/core/put.ts\nimport { types as t38 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams12, assertNoVar as assertNoVar8 } from \"@marko/babel-utils\";\nvar put_default = {\n  analyze: {\n    enter(tag) {\n      reserveScope(\n        0 /* Visit */,\n        getOrCreateSection(tag),\n        tag.node,\n        \"put\",\n        \"#text\"\n      );\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      custom_tag_default.analyze.exit(tag);\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [defaultAttr] = node.attributes;\n      if (!node.body.body.length) {\n        throw tag.buildCodeFrameError(\n          `The '<put>' tag requires body content that the context is forwarded through.`\n        );\n      }\n      if (!t38.isMarkoAttribute(defaultAttr) || !defaultAttr.default) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          `The '<put>' tag requires default attribute like '<put=val>'.`\n        );\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<put>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError(\n            { loc: { start, end } },\n            msg,\n            Error\n          );\n        }\n      }\n      if (isOutputHTML()) {\n        flushBefore(tag);\n        tag.insertBefore(\n          t38.expressionStatement(\n            callRuntime(\n              \"pushContext\",\n              t38.stringLiteral(tag.hub.file.metadata.marko.id),\n              defaultAttr.value\n            )\n          )\n        );\n      } else {\n        visit(tag, 37 /* Replace */);\n        enterShallow(tag);\n        const bodySection = getSection(tag.get(\"body\"));\n        const rendererId = getRenderer(bodySection);\n        initContextProvider(\n          tag.hub.file.metadata.marko.id,\n          node.extra.reserve,\n          defaultAttr.extra?.valueReferences,\n          defaultAttr.value,\n          rendererId\n        );\n      }\n    },\n    exit(tag) {\n      assertNoParams12(tag);\n      assertNoVar8(tag);\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        tag.insertAfter(t38.expressionStatement(callRuntime(\"popContext\")));\n      }\n      tag.replaceWithMultiple(tag.node.body.body);\n    }\n  },\n  autocomplete: [\n    {\n      displayText: \"put=<value>\",\n      description: \"Sets a value which can be read from a child template.\",\n      snippet: \"put=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#put\"\n    }\n  ]\n};\n\n// src/core/style.ts\nimport path2 from \"path\";\nimport { assertNoParams as assertNoParams13, importDefault as importDefault3 } from \"@marko/babel-utils\";\nimport { types as t39 } from \"@marko/compiler\";\nvar style_default = {\n  translate(tag) {\n    const {\n      hub: { file }\n    } = tag;\n    assertNoParams13(tag);\n    assertNoSpreadAttrs(tag);\n    let type = \"text/css\";\n    const attrs2 = tag.get(\"attributes\");\n    const base = path2.basename(file.opts.sourceFileName);\n    const typeAttr = attrs2.find(\n      (attr2) => attr2.isMarkoAttribute() && attr2.node.name === \"type\"\n    );\n    const classAttr2 = attrs2.find(\n      (attr2) => attr2.isMarkoAttribute() && attr2.node.name === \"class\"\n    );\n    if (typeAttr && classAttr2) {\n      throw classAttr2.buildCodeFrameError(\n        `<style> must only use \"type\" or \"class\" and not both.`\n      );\n    } else if (typeAttr) {\n      const typeValue = typeAttr.get(\"value\");\n      if (typeValue.isStringLiteral()) {\n        type = typeValue.node.value;\n      } else {\n        throw typeValue.buildCodeFrameError(\n          `<style> \"type\" attribute can only be a string literal.`\n        );\n      }\n    } else if (classAttr2) {\n      const classValue2 = classAttr2.get(\"value\");\n      if (classValue2.isStringLiteral()) {\n        type = classValue2.node.value;\n      } else {\n        throw classValue2.buildCodeFrameError(\n          `<style> \"class\" attribute can only be a string literal.`\n        );\n      }\n    }\n    if (type === \"text/css\") {\n      type = \"css\";\n    }\n    if (tag.node.var && !type.startsWith(\"module\")) {\n      type = \"module.\" + type;\n    }\n    const body = tag.get(\"body\").get(\"body\");\n    const markoText = body[0];\n    if (body.length !== 1 || !markoText.isMarkoText()) {\n      throw (markoText.isMarkoText() ? body[1] : body[0]).buildCodeFrameError(\n        \"The '<style>' tag currently only supports static content.\"\n      );\n    }\n    const { resolveVirtualDependency } = getMarkoOpts();\n    if (resolveVirtualDependency) {\n      const importPath = resolveVirtualDependency(\n        file.opts.filename,\n        {\n          type,\n          code: markoText.node.value,\n          startPos: markoText.node.start,\n          endPos: markoText.node.end,\n          path: `./${base}`,\n          virtualPath: `./${base}.${type}`\n        }\n      );\n      if (!tag.node.var) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          t39.importDeclaration([], t39.stringLiteral(importPath))\n        );\n      } else if (t39.isIdentifier(tag.node.var)) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          t39.importDeclaration(\n            [t39.importDefaultSpecifier(tag.node.var)],\n            t39.stringLiteral(importPath)\n          )\n        );\n      } else {\n        currentProgramPath.pushContainer(\n          \"body\",\n          t39.variableDeclaration(\"const\", [\n            t39.variableDeclarator(\n              tag.node.var,\n              importDefault3(file, importPath, \"style\")\n            )\n          ])\n        );\n      }\n    }\n    tag.remove();\n  },\n  attributes: {\n    type: { enum: [\"css\", \"less\", \"scss\", \"text/css\"] }\n  }\n};\n\n// src/core/tag.ts\nimport { types as t40 } from \"@marko/compiler\";\nvar tag_default2 = {\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n      if (!tag.node.var) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"<tag> requires a variable to be defined, eg <tag/NAME>.\"\n        );\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        flushInto(tag);\n      }\n      tag.replaceWith(\n        t40.variableDeclaration(\"const\", [\n          t40.variableDeclarator(\n            tag.node.var,\n            callRuntime(\n              \"createRenderer\",\n              t40.arrowFunctionExpression(\n                tag.node.body.params,\n                toFirstExpressionOrBlock(tag.node.body)\n              )\n            )\n          )\n        ])\n      );\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"tag/<name>|<params>|\",\n      description: \"Creates a reusable fragment within the template.\",\n      snippet: \"tag/${1:name}|${2:param1, param2}|\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#tag\"\n    }\n  ]\n};\n\n// src/core/static.ts\nimport { types as t41 } from \"@marko/compiler\";\nimport { parseStatements as parseStatements3 } from \"@marko/babel-utils\";\nvar static_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^static\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = parseStatements3(file, code, start, start + code.length);\n    if (body.length === 1 && t41.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(t41.markoScriptlet(body, true));\n  },\n  \"parse-options\": {\n    rootOnly: true,\n    rawOpenTag: true,\n    openTagOnly: true,\n    ignoreAttributes: true\n  },\n  autocomplete: [\n    {\n      displayText: \"static <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#static-javascript\"\n    }\n  ]\n};\n\n// src/core/noop.ts\nvar noop_default = {\n  migrate: [(tag) => tag.remove()]\n};\n\n// src/core/__flush_here_and_after__.ts\nvar flush_here_and_after_default = {\n  migrate: [\n    (tag) => {\n      tag.replaceWithMultiple(tag.node.body.body);\n      currentProgramPath.scope.crawl();\n    }\n  ]\n};\n\n// src/core/index.ts\nvar core_default = {\n  taglibId,\n  \"<import>\": import_default,\n  \"<export>\": export_default,\n  \"<attrs>\": attrs_default,\n  \"<if>\": if_default,\n  \"<else-if>\": else_if_default,\n  \"<else>\": else_default,\n  \"<for>\": for_default,\n  \"<let>\": let_default,\n  \"<const>\": const_default,\n  \"<effect>\": effect_default,\n  \"<lifecycle>\": lifecycle_default,\n  \"<id>\": id_default,\n  \"<html-comment>\": html_comment_default,\n  \"<tag>\": tag_default2,\n  \"<put>\": put_default,\n  \"<get>\": get_default,\n  \"<return>\": return_default,\n  \"<style>\": style_default,\n  \"<await-reorderer>\": noop_default,\n  \"<init-widgets>\": noop_default,\n  \"<init-components>\": noop_default,\n  \"<static>\": static_default,\n  \"<__flush_here_and_after__>\": flush_here_and_after_default\n};\n\n// src/visitors/referenced-identifier.ts\nimport { types as t42 } from \"@marko/compiler\";\nvar outGlobalIdentifiers = /* @__PURE__ */ new WeakMap();\nvar hasAttrsTag = /* @__PURE__ */ new WeakSet();\nvar referenced_identifier_default = {\n  migrate(identifier) {\n    const { name } = identifier.node;\n    if (identifier.scope.hasBinding(name))\n      return;\n    switch (identifier.node.name) {\n      case \"input\": {\n        if (!hasAttrsTag.has(currentProgramPath)) {\n          hasAttrsTag.add(currentProgramPath);\n          insertAfterStatic(\n            t42.markoTag(\n              t42.stringLiteral(\"attrs\"),\n              void 0,\n              t42.markoTagBody(),\n              void 0,\n              identifier.node\n            )\n          );\n        }\n        break;\n      }\n      case \"out\":\n        if (t42.isMemberExpression(identifier.parent) && t42.isIdentifier(identifier.parent.property) && identifier.parent.property.name === \"global\") {\n          let globalIdentifier = outGlobalIdentifiers.get(currentProgramPath);\n          if (!globalIdentifier) {\n            globalIdentifier = currentProgramPath.scope.generateUidIdentifier(\"$global\");\n            outGlobalIdentifiers.set(currentProgramPath, globalIdentifier);\n            insertAfterStatic(\n              t42.markoTag(\n                t42.stringLiteral(\"get\"),\n                void 0,\n                t42.markoTagBody(),\n                void 0,\n                globalIdentifier\n              )\n            );\n          }\n          identifier.parentPath.replaceWith(globalIdentifier);\n        } else {\n          throw identifier.buildCodeFrameError(\n            \"Only out.global is supported for compatibility.\"\n          );\n        }\n        break;\n    }\n  }\n};\nfunction insertAfterStatic(node) {\n  for (const child of currentProgramPath.get(\"body\")) {\n    if (!isStatic(child)) {\n      child.insertBefore(node);\n      return;\n    }\n  }\n  currentProgramPath.unshiftContainer(\"body\", node);\n}\n\n// src/index.ts\nvar visitors = {\n  Program: program_default,\n  AssignmentExpression: assignment_expression_default,\n  UpdateExpression: update_expression_default,\n  ReferencedIdentifier: referenced_identifier_default,\n  ImportDeclaration: import_declaration_default,\n  MarkoDocumentType: document_type_default,\n  MarkoDeclaration: declaration_default,\n  MarkoCDATA: cdata_default,\n  MarkoText: text_default,\n  MarkoTag: tag_default,\n  MarkoPlaceholder: placeholder_default,\n  MarkoScriptlet: scriptlet_default,\n  MarkoComment: comment_default\n};\nvar getVisitorOfType = (typename) => Object.entries(visitors).reduce((visitor, [name, value]) => {\n  if (typename in value) {\n    visitor[name] = value[typename];\n  }\n  return visitor;\n}, {});\nvar analyze = getVisitorOfType(\"analyze\");\nvar translate = getVisitorOfType(\"translate\");\nvar taglibs = [\n  [\n    __dirname,\n    {\n      ...core_default,\n      migrate: getVisitorOfType(\"migrate\")\n    }\n  ]\n];\nexport {\n  analyze,\n  taglibs,\n  translate\n};\n//# sourceMappingURL=index.mjs.map\n","import * as fluurtTranslator from \"../../../../../browser-shims/v6/translator\";\n\n<hash-value/files=[\n  {\n    name: \"index.marko\",\n    path: \"/components/index.marko\",\n    content:\n      \"<let/count=0/>\\n<button onClick() { count++ }>\\n  ${count}\\n</button>\",\n  },\n]/>\n<repl\n  getCompilerOptions() {\n    return {\n      translator: fluurtTranslator,\n      optimize: false,\n    };\n  }\n  files:=files\n/>\n","import { register, init } from \"marko/dist/runtime/components/index.js\";\nimport \"../../../components/app-layout/style.css\";\nimport \"../../../components/app-layout/favicon.png\";\nimport \"../../../components/app-layout/components/skip-link/index.marko.css!=!/Users/mirawlings/dev/marko-js/website/node_modules/@marko/webpack/dist/loader/index.js!/Users/mirawlings/dev/marko-js/website/src/components/app-layout/components/skip-link/index.marko?virtual=./index.marko.css\";\nimport \"../../../components/app-layout/components/layout-header/style.css\";\nimport \"../../../logos/marko.svg\";\nimport \"../../../components/app-layout/components/layout-search/style.css\";\nimport component_0 from \"../../../components/app-layout/components/layout-header/component-browser.js\";\nregister(\"OIKmBXjW\", component_0);\nimport \"../../../components/app-layout/components/layout-sidebar/style.css\";\nimport component_1 from \"../../../components/app-layout/components/layout-sidebar/components/version-switcher/component-browser.js\";\nregister(\"07hv1F0+\", component_1);\nimport component_2 from \"../../../components/app-layout/components/layout-sidebar/component-browser.js\";\nregister(\"mFesaajv\", component_2);\nimport \"../../../components/app-footer/style.css\";\nimport \"../../../components/app-footer/openjsf.svg\";\nimport \"../../../components/app-footer/osi.svg\";\nimport \"../../../components/app-footer/ebay.svg\";\nimport \"../../../components/discord-link/index.marko.css!=!/Users/mirawlings/dev/marko-js/website/node_modules/@marko/webpack/dist/loader/index.js!/Users/mirawlings/dev/marko-js/website/src/components/discord-link/index.marko?virtual=./index.marko.css\";\nimport \"../../../logos/discord.svg\";\nimport \"./components/playground-6.marko\";\ninit();","module.exports = require(\"../../../../node_modules/@marko/compiler/dist/babel-types\");\n","// We don't bring in the full Marko compiler, but the ast types are needed.\nexports.types = require(\"./dist/babel-types\");\n","module.exports = require(\"memfs\");\n","const path = require(\"path\");\nconst resolve = require(\"resolve\");\nconst resolveExports = require(\"resolve.exports\");\n\nconst Module = {\n  _nodeModulePaths: nodeModulePaths,\n  _resolveFilename: function (target, fromModule) {\n    return resolve.sync(target, {\n      basedir: path.dirname(fromModule.filename),\n      paths: fromModule.paths,\n      extensions: [\".js\", \".json\", \".marko\", \".mjs\"],\n      pathFilter(pkg, _, relativePath) {\n        if (/^index(\\.[^/\\\\]+)?$/.test(relativePath)) {\n          try {\n            return resolveExports.legacy(pkg, Module._resolveExportsOptions);\n          } catch {}\n        } else {\n          try {\n            return resolveExports.resolve(\n              pkg,\n              relativePath,\n              Module._resolveExportsOptions\n            );\n          } catch {}\n        }\n\n        return relativePath;\n      },\n    });\n  },\n  _resolveExportsOptions: {\n    browser: true,\n  },\n};\n\nmodule.exports = Module;\n\nfunction nodeModulePaths(dir) {\n  const paths = [];\n\n  while (true) {\n    const parentDir = path.dirname(dir);\n    paths.push(path.join(dir, \"node_modules\"));\n\n    if (!parentDir || parentDir === dir) {\n      break;\n    }\n\n    dir = parentDir;\n  }\n\n  return paths;\n}\n","module.exports = {\n  env: {},\n  browser: true,\n  versions: {\n    node: \"1000.0.0\",\n  },\n  cwd() {\n    return \"/\"\n  }\n}","var siteHeaderEvents = require(\"./events\");\n\nvar classNames = {\n  base: \"headspace\",\n  fixed: \"headspace--fixed\",\n  hidden: \"headspace--hidden\"\n};\nvar debounce = cb => () => window.requestAnimationFrame(cb);\nvar tolerance = 3;\n\nmodule.exports = {\n  onMount() {\n    siteHeaderEvents.emit(\"create\", this);\n    var scrollLast = 0;\n    var startOffset = this.getEl('header').offsetHeight;\n    var bannerHeight = (this.getEl('banner') || { offsetHeight:0 }).offsetHeight;\n\n    var handleScroll = debounce(() => {\n      var scrollCurrent = window.pageYOffset;\n\n      if (scrollCurrent <= bannerHeight) {\n        this.reset();\n      } else if (!this.paused && scrollCurrent > startOffset) {\n        var toleanceReached = Math.abs(scrollCurrent - scrollLast) >= tolerance;\n        var scrollingDown = scrollCurrent > scrollLast;\n        var wasAtTop = scrollLast <= startOffset;\n        if (toleanceReached || (scrollingDown && wasAtTop)) {\n          scrollCurrent > scrollLast ? this.hide() : this.fix();\n        }\n      }\n\n      scrollLast = scrollCurrent;\n    });\n\n    handleScroll();\n    window.addEventListener(\"scroll\", handleScroll);\n  },\n  reset() {\n    this.removeClass(classNames.fixed);\n    this.removeClass(classNames.hidden);\n    siteHeaderEvents.emit(\"reset\");\n  },\n  fix() {\n    this.addClass(classNames.fixed);\n    this.removeClass(classNames.hidden);\n    siteHeaderEvents.emit(\"fix\");\n  },\n  hide() {\n    this.addClass(classNames.hidden);\n    siteHeaderEvents.emit(\"hide\");\n  },\n  addClass(cls) {\n    this.getEl('header').classList.add(cls);\n  },\n  removeClass(cls) {\n    this.getEl('header').classList.remove(cls);\n  },\n  pause() {\n    this.paused = true;\n  },\n  resume() {\n    setTimeout(() =>\n      window.requestAnimationFrame(() => {\n        this.paused = false;\n      })\n    );\n  },\n  toggleMenu () {\n    siteHeaderEvents.emit('toggle-menu');\n  }\n};\n","// TODO: remove this.\nvar EventEmitter = require(\"events\");\n\nmodule.exports = new EventEmitter();\n","var siteHeaderEvents = require(\"../layout-header/events\");\nvar forEach = [].forEach;\nvar filter = [].filter;\nvar slice = [].slice;\nvar siteHeaderComponent;\n\nmodule.exports = {\n  onMount() {\n    this.preventOverscroll();\n    this.listenForHeaderChanges();\n    this.initScrollSpy();\n  },\n\n  initScrollSpy() {\n    var headersSelector = [1, 2, 3, 4, 5, 6]\n      .map(n => \".doc-content h\" + n)\n      .join(\",\");\n    var headers = slice.call(document.querySelectorAll(headersSelector));\n    var waiting = false;\n\n    headers.length &&\n      this.subscribeTo(window).on(\"scroll\", () => {\n        if (!waiting) {\n          waiting = true;\n          setTimeout(() => {\n            var threshold = window.innerHeight / 3;\n            var closestHeader;\n            var closestTop;\n\n            headers.map(header => {\n              var top = header.getBoundingClientRect().top;\n              if (\n                closestTop == null ||\n                (top < threshold && Math.abs(top) < Math.abs(closestTop))\n              ) {\n                closestTop = top;\n                closestHeader = header;\n              }\n            });\n\n            var anchor = closestHeader.id;\n            var anchorEl =\n              this.el.querySelector('a[href=\"#' + anchor + '\"]') ||\n              this.el.querySelector(\"a.selected\");\n            var targetAnchor = anchorEl;\n            var childList = targetAnchor.nextSibling;\n\n            if (childList) {\n              forEach.call(childList.querySelectorAll(\"a[href^=\\\\#]\"), a =>\n                a.classList.remove(\"selected\")\n              );\n            }\n\n            while (targetAnchor) {\n              var parentList = targetAnchor.closest(\"ul\");\n              var siblings =\n                parentList &&\n                filter.call(\n                  parentList.querySelectorAll(\":scope > li > a[href^=\\\\#]\"),\n                  a => a !== targetAnchor\n                );\n              siblings && siblings.forEach(a => a.classList.remove(\"selected\"));\n              targetAnchor.classList.add(\"selected\");\n              targetAnchor = parentList && parentList.previousElementSibling;\n            }\n\n            this.scrollAnchorIntoView(anchorEl);\n\n            waiting = false;\n          }, 50);\n        }\n      });\n  },\n\n  listenForHeaderChanges() {\n    forEach.call(this.el.querySelectorAll(\"a[href^=\\\\#]\"), a => {\n      this.subscribeTo(a).on(\"click\", () => {\n        siteHeaderComponent.hide();\n        siteHeaderComponent.pause();\n        siteHeaderComponent.resume();\n        this.hide();\n      });\n    });\n\n    // handles nested selected links\n    var selectedLink = slice.call(this.el.querySelectorAll(\"a.selected\")).pop();\n\n    selectedLink &&\n      this.subscribeTo(selectedLink).on(\"click\", e => {\n        window.scrollTo(0, 0);\n        siteHeaderComponent.reset();\n        e.preventDefault();\n      });\n\n    this.subscribeTo(siteHeaderEvents)\n      .on(\"reset\", () => {\n        this.el.classList.remove(\"no-header\");\n        this.el.classList.remove(\"fixed\");\n        setTimeout(() => this.el.classList.remove(\"transition\"), 0);\n      })\n      .on(\"fix\", () => {\n        this.el.classList.remove(\"no-header\");\n        this.el.classList.add(\"fixed\");\n        setTimeout(() => this.el.classList.add(\"transition\"), 0);\n      })\n      .on(\"hide\", () => {\n        this.el.classList.add(\"no-header\");\n        this.el.classList.add(\"fixed\");\n        setTimeout(() => this.el.classList.add(\"transition\"), 0);\n      })\n      .on(\"toggle-menu\", () => {\n        if (this.el.classList.contains(\"show\")) {\n          this.el.classList.remove(\"show\");\n          document.body.style.overflow = \"\";\n        } else {\n          this.el.classList.add(\"show\");\n        }\n      })\n      .on(\"create\", _siteHeaderComponent => {\n        siteHeaderComponent = _siteHeaderComponent;\n\n        if (window.pageYOffset > siteHeaderComponent.el.offsetHeight) {\n          this.el.classList.add(\"no-header\");\n          this.el.classList.add(\"fixed\");\n        }\n      });\n  },\n\n  preventOverscroll() {\n    var sidebar = this.getEl(\"sidebar\");\n    this.subscribeTo(document.body).on(\"wheel\", e => {\n      var delta = e.deltaY;\n      var scrollTarget = sidebar.scrollTop + delta;\n      var topY = 0;\n      var bottomY = sidebar.scrollHeight - sidebar.offsetHeight;\n      var atTop = scrollTarget <= topY;\n      var atBottom = scrollTarget >= bottomY;\n\n      if ((delta < 0 && atTop) || (delta > 0 && atBottom)) {\n        if (e.target === sidebar || sidebar.contains(e.target)) {\n          if (atTop && sidebar.scrollTop != topY) {\n            sidebar.scrollTop = topY;\n          } else if (atBottom && sidebar.scrollTop != bottomY) {\n            sidebar.scrollTop = bottomY;\n          }\n          e.preventDefault();\n        }\n      }\n    });\n  },\n\n  scrollAnchorIntoView(anchorEl) {\n    var sidebar = this.getEl(\"sidebar\");\n    var anchorTop = anchorEl.offsetTop;\n    var sidebarScrollTop = sidebar.scrollTop;\n    var sidebarHeight = sidebar.offsetHeight;\n    var sidebarScrollBottom = sidebarScrollTop + sidebarHeight;\n\n    var targetList = anchorEl.closest(\"li\");\n    var parentList;\n\n    while (true) {\n      parentList = targetList.parentNode.closest(\"ul\");\n      if (parentList && parentList.offsetHeight < sidebarHeight) {\n        targetList = parentList;\n      } else {\n        break;\n      }\n    }\n\n    var targetTop = targetList.offsetTop;\n    var targetHeight = targetList.offsetHeight;\n    var targetBottom = targetTop + targetHeight;\n    var targetIsFullyVisible =\n      targetTop > sidebarScrollTop && targetBottom < sidebarScrollBottom;\n\n    if (!targetIsFullyVisible) {\n      sidebar.scrollTop = targetTop + targetHeight / 2 - sidebarHeight / 2;\n    }\n  },\n\n  hide() {\n    this.el.classList.remove(\"show\");\n    document.body.style.overflow = \"\";\n  }\n};\n","module.exports = {\n  switchVersion(e) {\n    var location = e.target.value;\n    if (location !== \"current\") {\n      e.target.value = \"current\";\n      window.location.href = location;\n    }\n  }\n};\n","export default __webpack_public_path__ + \"339b8a9e.svg\";","export default __webpack_public_path__ + \"6876aea9.svg\";","export default __webpack_public_path__ + \"1b70b500.svg\";","export default __webpack_public_path__ + \"d78b83f1.png\";","export default __webpack_public_path__ + \"78800ea4.svg\";","export default __webpack_public_path__ + \"91bc26e5.svg\";"],"names":["_selectedIndexChange","_filesChange","files","externalFiles","selectedIndex","externalSelected","input","_filesSet","_files","_component","setState","_state","_selectedIndexSet","_selectedIndex","selectedFile","out","be","_component4","nextId","_nextIdSet","_nextId","_index","file","index","_keyScope","_marko_tag","_instance","renderBody","_nestedComponentDef","_component2","_state2","_componentDef","editing","_editingSet","_editing","selected","mutable","_marko_class_merge","d","_assign","_nestedComponentDef2","_component3","_state3","name","finishRename","_cache","_cached","modifiedFile","path","replace","slice","nameInput","_createRef","_valueChange","_name","e","length","pa","code","target","value","_lifecycle","focus","setSelectionRange","indexOf","t","window","confirm","stopPropagation","ee","newFile","content","newIndex","concat","_end","_marko_componentType","_marko_component","_marko_template","Component","_marko_defineComponent","_","_marko_registerComponent","_marko_renderer","state","$global","_begin","actions","body","_marko_dynamic_tag","n","_marko_node","i","valueChange","class","className","el","_effect","_marko_createElement","attrs","_meta","_marko_attrs","_extractHandlers","compressToEncodedURIComponent","JSON","stringify","query","fallback","isMatch","matchMedia","matches","_isMatchSet","_isMatch","mq","listener","addEventListener","removeEventListener","_return","left","right","editorSize","_editorSizeSet","_editorSize","resizing","_resizingSet","_resizing","_matchMediaReturn","_matchMedia","isVertical","container","preventDefault","_meta2","handler","buttons","which","rect","getBoundingClientRect","fraction","clientY","top","height","clientX","width","Math","min","max","_marko_node2","_marko_node3","onCreate","_component7","getCompilerOptions","previewType","_previewTypeSet","_previewType","debounce","_debounceSet","_debounce","_resizablePanes","_pane","_fileTabs","_assign2","Symbol","iterator","_marko_self_iterator","activeEditor","_activeEditorSet","_activeEditor","_nestedComponentDef3","_state4","loading","_nestedComponentDef4","_component5","_state5","_controllableSelect","_playgroundLink","_nestedComponentDef5","_component6","_state6","preview","_previewSet","_preview","defaultValue","parse","decompressFromEncodedURIComponent","location","hash","console","error","getInitialValue","_valueSet","_value","this","isUpdating","isOutputHTML","getMarkoOpts","output","isOutputDOM","currentProgramPath","hub","markoOpts","isOptimize","optimize","MARKO_FILE_REG","analyzeTagNameType","tag","extra","node","tagNameType","get","isStringLiteral","isNativeTag","childFile","loadFileForTag","childProgram","ast","program","___featureType","tagNameNullable","pending","path3","type","nullable","pop","isConditionalExpression","push","alternate","isLogicalExpression","operator","isAssignmentExpression","isBinaryExpression","isTemplateLiteral","isNullLiteral","isIdentifier","binding","scope","getBinding","kind","decl","parent","test","source","specifiers","some","it","bindingTag","isMarkoTag","bindingTagName","tagNameDynamic","startSection","section","parentSection","parentPath","getOrCreateSection","sectionNamePath","sectionName","isProgram","generateUid","toString","programExtra","sections","id","depth","cur","getSection","currentPath","_setSectionPath","createSectionState","key","init","arrayOfSectionData","getScopeIdIdentifier","generateUidIdentifier","getSectionPath","_getScopeIdentifier","t2","getScopeIdentifier","ignoreDefault","scopeId","forEachSection","fn","forEach","SortedRepeatable","constructor","compare","add","data","item","Array","isArray","insertSorted","joinItems","addAll","items","find","pos","mid","compareResult","clone","size","toArray","map","iterate","a","b","len","next","getReservesByType","reserveScope","debugKey","reserve","reserve2","reservesByType","getScopeAccessorLiteral","t3","repeatableReserves","intersectionSubscribeCounts","WeakMap","repeatableIntersections","lenDelta","getIntersectionsBySection","setIntersectionsBySection","trackReferencesForBindings","bindings","getBindingIdentifiers","references","referencePaths","constantViolations","filter","path4","reference","fnRoot","getFnRoot","exprRoot","getExprRoot","markoRoot","immediateRoot","name2","isMarkoAttribute","default","addBindingToReferences","listKey","referencesKey","prevReferences","addSubscriber","getIntersection","isIntersection","removeSubscriber","mergeReferences","groupEntries","newReferences","curPath","isMarkoPath","isFunctionExpression","intersections","intersection","set","val","escapeXML","escapeIfNeeded","result","lastPos","replacement","escapeScript","escapeTagEnding","escapeStyle","tagName","openTag","escaped","escapeAttrValue","quoteValue","escape","startPos","quote","stringifyClassObject","isVoid","NON_DIMENSIONAL","stringifyStyleObject","toDelimitedString","delimiter","curDelimiter","v","part","classAttr","stringAttr","styleAttr","attr","attrAssignment","RegExp","nonVoidUntypedAttr","hasOwnProperty","Object","prototype","createScopeReadPattern","rootDepth","rootPattern","t4","nestedPatterns","ref","includes","propertyKey","propertyValue","isShorthand","pattern","relativeDepth","prev","nestedPattern","properties","getScopeExpression","targetSection","scopeIdentifier","diff","Error","createScopeReadExpression","String","doc","walker","replacementNode","targetParent","targetNode","refNode","nextNode","runtimePrefix","document","createTreeWalker","getElementById","parentNode","firstChild","insertBefore","removeChild","nextSibling","pureFunctions","importRuntime","importNamed","getRuntimePath","callRuntime","args","callExpression2","t5","filteredArgs","arg","filterArguments","leadingComments","getHTMLRuntime","toTemplateOrStringLiteral","parts","strs","exprs","curStr","t6","nextIndex","exprLen","expressions","shiftItems","quasis","j","raw","appendLiteral","arr","str","list","start","offset","getWalks","getWalkComment","getSteps","walkCodeToName","enter","exit","enterShallow","visit","buildCodeFrameError","steps","walks","walkComment","walkString","walks2","step","lastIndexOf","current","count","walk","nCodeString","writeTo","fromCharCode","number","toCharString","startCode","rangeSize","multiplier","floor","getWalkString","walkLiteral","t7","join","getRenderer","t8","getWrites","getRegisterRenderer","setRegisterRenderer","exprsLen","writes","writePrependTo","unshift","consumeHTML","flushBefore","expr","skip","flushInto","pushContainer","getSectionMeta","setup","getSetup","register","markNode","assertNoSpreadAttrs","attr2","isMarkoSpreadAttribute","assertNoBodyContent","returnId","_setReturnId","return_default","translate","assertNoVar","assertNoParams","defaultAttr","attributes","t9","loc","end","msg","buildError","returnId2","replaceWith","addValue","valueReferences","identifier","hasDownstreamIntersections","remove","autocomplete","displayText","description","snippet","descriptionMoreURL","getSignals","Map","getSubscribeBuilder","_setSubscribeBuilder","setSubscriberBuilder","builder","getClosures","addClosure","fromSection","toSection","closure","currentSection","forceResumeScope","_setForceResumeScope","getSerializedScopeProperties","getRegisterScopeBuilder","_setRegisterScopeBuilder","setRegisterScopeBuilder","unimplementedBuild","t10","getSignal","signals","signal","generateSignalName","values","render","effect","effectInlineReferences","subscribers","closures","build","subscribe","getSignalFn","provider","ownerScope","isImmediateOwner","object","buildSignalIntersections","buildSignalValuesWithIntersections","initValue","valueAccessor","valuesWithIntersections","params","closureEntries","from","entries","sort","closureSection","closureSignal","pushRepeatable","hasDynamicSubscribers","intersectionExpression","repeatable","getDestructureSignal","bindingsByName","destructurePattern","valueIdentifier","bindingSignals","declarations","canCallOnlyWhenDirty","cleanIdentifier","subscriber","p","providerSignal","finalizeSignalArgs","expression","addStatement","statement","originalNodes","isInlined","statements","addEffectReferences","getResumeRegisterId","opts","filename","getTemplateId","sortSignals","aReserves","getReserves","bReserves","getMappedId","addHTMLEffectCall","writeHTMLResumeStatements","tagVarIdentifier","intersectionsBySection","allSignals","scopeIdIdentifier","serializedReferences","signalRefs","accessors","Set","additionalProperties","serializedProperties","reduce","acc","accessor","has","unshiftContainer","bindFunctionsVisitor","FunctionExpression","bindFunction","ArrowFunctionExpression","root","functionIdentifier","isFunction","dom_default","templateIdentifier","t11","walksIdentifier","setupIdentifier","attrsSignalIdentifier","closuresIdentifier","attrs2","forEachSectionReverse","childSection","sectionPath","tagParamsSignal","paramsPaths","bindingsLookup","assign","getTagParamsSignal","effectDeclarator","effectIdentifier","arguments","signalDeclarator","roots","traverse","writeSignals","writes2","setup2","register2","closures2","renderer","exportSpecifiers","bindingIdentifier","signalIdentifier","var","getTemplateId2","isStatic","isImportDeclaration","isExportDeclaration","isMarkoScriptlet","static","html_default","returnIdentifier","t12","renderContent","child","replaceWithMultiple","rendererId","getTemplateId3","previousProgramPath","program_default","migrate","crawl","analyze","curIndex","reserves","finalizeIntersections","t13","hasInteractiveChild","isInteractive","import_declaration_default","request","resolveTagImport","document_type_default","documentType","assignmentReplacer","getReplacement","assignment","assignment_expression_default","t14","update_expression_default","t15","argument","prefix","isExpressionStatement","declaration_default","declaration","cdata_default","cdata","text_default","text","followingSiblings","needsSeparator","sibling","t16","enter2","modulePlugin","plugin","isModulePlugin","isFunctionPlugin","t17","exit2","Boolean","analyzeAttributeTags","nestedAttributeTags","hoistedControlFlows","analyzeChildren","rootExtra","repeated","dynamic","hasAttributeTags","analyzeChild","isTransparentTag","isLoopTag","isAttributeTag","attrName","lookup","existing","info","IDENTIFIER_REG","attrsToObject","withRenderBody","t19","resultExtra","t18","isConditional","isLoop","prop","getRenderBodyProp","attrsObject","lastProp","translateVar","initialValue","tagVar","t20","evaluate","confident","computed","native_tag_default","isSpreadAttr","attrNode","isEventHandler","isHTML","tagDef","getTagDef","hasSpread","write2","t21","varName","createElFunction","referenceSection","isCallExpression","visitAccessor","attrsCallExpr","extra2","helper","propName","charAt","toLowerCase","parseOptions","openTagOnly","htmlType","custom_tag_default","trackReferences","getTagDef2","template","loadFileForTag2","childProgramExtra","attrsReferences","tagBody","tagIdentifier","t22","relativePath","getTagRelativePath","importDefault","renderBodyProp","renderBodyId","renderTagExpr","callExpression","renderBodyPath","callStatement","setForceResumeScope","translateHTML","tagSection","tagBodySection","importNamed2","tagAttrsIdentifier","injectWalks","translateDOM","nameIsString","resolveRelativePath","tags","metadata","marko","toFirstExpressionOrBlock","nodes","t23","dynamic_tag_default","tagExpression","t24","importDefault2","serialized5to6","importNamed3","getTemplateId4","loadFileForTag3","emptyAttrs","dynamicScopeIdentifier","dynamicTagExpr","bodySection","renderBodyIdentifier","tagNameReserve","nameReferences","attrsGetter","added","attribute_tag_default","hasPendingHTML","assertNoVar2","parentTag","findParentTag","parentExtra","t25","existingAttr","tag_default","getTagDef3","hook","analyzer","assertNoArgs","translator","watchFiles","modifier","isNativeTag2","tagNameId","tagNameVarPath","t26","taglibId","isCoreTag","getTagDef4","isCoreTagName","ESCAPE_TYPES","script","style","placeholder_default","placeholder","getPrevSibling","noOutput","t27","isNativeTag3","needsMarker","getNextSibling","canWriteHTML","method","getParentTagName","scriptlet_default","scriptlet","bodyReferences","ieConditionalCommentRegExp","comment_default","comment","import_default","parseStatements","rawValue","rootOnly","rawOpenTag","ignoreAttributes","relaxRequireCommas","export_default","parseStatements2","attrs_default","varPath","toFirstStatementOrBlock","t28","if_default","exitBranchAnalyze","testAttr","assertNoVar3","assertNoParams2","t29","exitBranchTranslate","BRANCHES_LOOKUP","getBranches","branches","nextTag","isLast","conditionalReferences","tag2","isStateful","singleNodeOptimization","every","section2","ifScopeIdIdentifier","ifScopeIdentifier","ifRendererIdentifier","curStatement","else_if_default","assertNoVar4","assertNoParams3","t30","else_default","assertNoVar5","assertNoParams4","const_default","assertNoParams5","t31","effect_default","assertNoParams6","t32","inlineStatements","node2","lifecycle_default","assertNoParams7","t33","id_default","assertNoArgs2","assertNoAttributes","assertNoParams8","t34","for_default","isOnlyChild","t35","getTagDef5","html","checkOnlyChild","parentTagName","keys","hasParams","assertNoVar6","findName","assertAllowedAttributes","validateFor","translateHTML2","translateDOM2","of","in","to","paramIdentifiers","signal2","ofAttr","toAttr","inAttr","loopArgs","loopKind","fromAttr","stepAttr","byAttr","namePath","block","byParams","keyExpression","tempScopeIdentifier","byIdentifier","keyParam","valParam","ofAttrValue","indexParam","loopParam","tempValParam","indexName","generateUidIdentifierBasedOnNode","stepValue","fromValue","stepsName","stepName","fromName","forScopeIdsIdentifier","forScopesIdentifier","obj","get_default","assertNoParams9","refId","t36","defaultAttrValue","relativeReferencePath","resolveTagImport2","getTemplateId5","templateId","initContextConsumer","put_default","t38","providers","compute","scopeAccessor","initContextProvider","assertNoParams12","assertNoVar8","insertAfter","noop_default","core_default","t37","assertNoParams11","initValueId","registerAssignmentReplacer","queueSource","assertNoVar7","assertNoParams10","assertNoAttributes2","assertNoAttributeTags","t40","assertNoParams13","base","path2","sourceFileName","typeAttr","classAttr2","typeValue","classValue2","startsWith","markoText","isMarkoText","resolveVirtualDependency","importPath","endPos","virtualPath","t39","importDefault3","enum","trim","parseStatements3","t41","outGlobalIdentifiers","hasAttrsTag","WeakSet","insertAfterStatic","visitors","Program","AssignmentExpression","UpdateExpression","ReferencedIdentifier","hasBinding","t42","property","globalIdentifier","ImportDeclaration","MarkoDocumentType","MarkoDeclaration","MarkoCDATA","MarkoText","MarkoTag","MarkoPlaceholder","MarkoScriptlet","MarkoComment","getVisitorOfType","typename","visitor","taglibs","_hashValueReturn","_hashValue","_repl","fluurtTranslator","module","exports","types","require","resolve","resolveExports","Module","_nodeModulePaths","dir","paths","parentDir","dirname","_resolveFilename","fromModule","sync","basedir","extensions","pathFilter","pkg","legacy","_resolveExportsOptions","browser","env","versions","cwd","siteHeaderEvents","classNames","onMount","emit","cb","scrollLast","startOffset","getEl","offsetHeight","bannerHeight","handleScroll","scrollCurrent","pageYOffset","reset","paused","abs","hide","fix","requestAnimationFrame","removeClass","addClass","cls","classList","pause","resume","setTimeout","toggleMenu","EventEmitter","siteHeaderComponent","preventOverscroll","listenForHeaderChanges","initScrollSpy","headersSelector","headers","call","querySelectorAll","waiting","subscribeTo","on","closestHeader","closestTop","threshold","innerHeight","header","anchor","anchorEl","querySelector","targetAnchor","childList","parentList","closest","siblings","previousElementSibling","scrollAnchorIntoView","selectedLink","scrollTo","contains","overflow","_siteHeaderComponent","sidebar","delta","deltaY","scrollTarget","scrollTop","bottomY","scrollHeight","atTop","atBottom","sidebarScrollTop","offsetTop","sidebarHeight","sidebarScrollBottom","targetList","targetTop","targetHeight","switchVersion","href"],"sourceRoot":""}