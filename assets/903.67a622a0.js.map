{"version":3,"file":"903.67a622a0.js","mappings":"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","sources":["webpack:///../../node_modules/@marko/tags-api-preview/dist/components/_instance/Users/mirawlings/dev/marko-js/website/node_modules/@marko/tags-api-preview/dist/components/_instance/index.marko","webpack:///../src/dom.ts","webpack:///../src/dom/scope.ts","webpack:///../src/dom/reconcile-longest-increasing-subsequence.ts","webpack:///../src/common/helpers.ts","webpack:///../src/dom/abort-signal.ts","webpack:///../src/dom/dom.ts","webpack:///../src/dom/walker.ts","webpack:///../src/dom/renderer.ts","webpack:///../src/dom/signals.ts","webpack:///../src/dom/control-flow.ts","webpack:///../src/dom/event.ts","webpack:///../src/dom/resume.ts","webpack:///../src/dom/schedule.ts","webpack:///../src/dom/queue.ts","webpack:///../src/dom/template.ts","webpack:///../../node_modules/marko/dist/runtime/helpers/attr-tag.js","webpack:///../../node_modules/marko/dist/runtime/helpers/tags-compat-dom.js","webpack:///../../node_modules/@marko/tags-api-preview/dist/chunk-5R2Z7TR6.mjs","webpack:///../../node_modules/@marko/tags-api-preview/dist/chunk-G2QGH4BR.mjs","webpack:///../../node_modules/@marko/tags-api-preview/dist/components/effect/index.mjs","webpack:///../../node_modules/@marko/tags-api-preview/dist/components/lifecycle/index.mjs","webpack:///../../node_modules/@marko/tags-api-preview/dist/components/return/index-browser.mjs","webpack:///../../node_modules/@marko/tags-api-preview/dist/transform/cached-values/index-browser.mjs","webpack:///../../node_modules/@marko/tags-api-preview/dist/transform/native-tag-var/index-browser.mjs","webpack:///../../node_modules/@marko/tags-api-preview/dist/translate/native-tag-handlers/index-browser.mjs","webpack:///../../node_modules/@marko/tags-api-preview/dist/util/replace-assignments/index.mjs"],"sourcesContent":["class {\n  onCreate() {\n    this.state = {};\n  }\n}\n\n<component-def/>\n$ input.renderBody(out, componentDef, component, state);\n","export {\n  conditional,\n  conditionalOnlyChild,\n  inConditionalScope,\n  loopOf,\n  loopIn,\n  loopTo,\n  inLoopScope,\n  patchConditionals,\n} from \"./dom/control-flow\";\n\nexport {\n  data,\n  html,\n  attr,\n  attrs,\n  classAttr,\n  styleAttr,\n  props,\n  lifecycle,\n} from \"./dom/dom\";\n\nexport { resetAbortSignal, getAbortSignal } from \"./dom/abort-signal\";\n\nexport { on } from \"./dom/event\";\n\nexport {\n  init,\n  register,\n  registerSubscriber,\n  getRegisteredWithScope,\n  scopeLookup,\n} from \"./dom/resume\";\n\nexport {\n  queueSource,\n  queueEffect,\n  run,\n  prepare,\n  runEffects,\n} from \"./dom/queue\";\n\nexport { write, bindFunction, bindRenderer, createScope } from \"./dom/scope\";\n\nexport type { Scope } from \"./common/types\";\n\nexport {\n  createRenderer,\n  dynamicTagAttrs,\n  createScopeWithRenderer,\n} from \"./dom/renderer\";\n\nexport { createTemplate } from \"./dom/template\";\n\nexport {\n  value,\n  initValue,\n  intersection,\n  closure,\n  dynamicClosure,\n  dynamicSubscribers,\n  childClosures,\n  setTagVar,\n  tagVarSignal,\n  nextTagId,\n  inChild,\n  values,\n  intersections,\n} from \"./dom/signals\";\n","import type { Scope } from \"../common/types\";\nimport type { Renderer } from \"./renderer\";\n\nlet debugID = 0;\n\nexport function createScope($global: Scope[\"$global\"]): Scope {\n  const scope = {} as Scope;\n  if (MARKO_DEBUG) {\n    scope.___debugId = debugID++;\n  }\n  scope.___client = true;\n  scope.$global = $global;\n  return scope;\n}\n\nconst emptyScope = createScope({});\nexport function getEmptyScope(marker: Comment) {\n  emptyScope.___startNode = emptyScope.___endNode = marker;\n  return emptyScope;\n}\n\nexport function write<S extends Scope, K extends keyof S>(\n  scope: S,\n  localIndex: K,\n  value: S[K],\n) {\n  if (scope[localIndex] !== value) {\n    scope[localIndex] = value;\n    return 1;\n  }\n  return 0;\n}\n\nfunction binder<T, U = T>(bind: (scope: Scope, value: T) => U) {\n  return (scope: Scope, value: T): U => {\n    scope.___bound ??= new Map();\n    let bound = scope.___bound.get(value) as U;\n    if (!bound) {\n      bound = bind(scope, value);\n      scope.___bound.set(value, bound);\n    }\n    return bound;\n  };\n}\n\nexport const bindRenderer = binder(\n  (ownerScope, renderer: Renderer): Renderer =>\n    renderer && {\n      ...renderer,\n      ___owner: ownerScope,\n    },\n);\n\ntype BindableFunction = (\n  this: unknown,\n  scope: Scope,\n  ...args: any[]\n) => unknown;\nexport const bindFunction = binder(\n  <T extends BindableFunction>(boundScope: Scope, fn: T) =>\n    fn.length\n      ? function bound(this: unknown, ...args: any[]) {\n          return fn.call(this, boundScope, ...args);\n        }\n      : function bound(this: unknown) {\n          return fn.call(this, boundScope);\n        },\n);\n\nexport function destroyScope(scope: Scope) {\n  _destroyScope(scope);\n\n  scope._?.___cleanup?.delete(scope);\n\n  const closureSignals = scope.___renderer?.___closureSignals;\n  if (closureSignals) {\n    for (const signal of closureSignals) {\n      signal.___unsubscribe?.(scope);\n    }\n  }\n  return scope;\n}\n\nfunction _destroyScope(scope: Scope) {\n  const cleanup = scope.___cleanup;\n  if (cleanup) {\n    for (const instance of cleanup) {\n      _destroyScope(instance);\n    }\n  }\n\n  const controllers = scope.___abortControllers;\n  if (controllers) {\n    for (const ctrl of controllers.values()) {\n      ctrl.abort();\n    }\n  }\n}\n\nexport function onDestroy(scope: Scope) {\n  let parentScope = scope._;\n  while (parentScope && !parentScope.___cleanup?.has(scope)) {\n    (parentScope.___cleanup ||= new Set()).add(scope);\n    scope = parentScope;\n    parentScope = scope._;\n  }\n}\n\nexport function removeAndDestroyScope(scope: Scope) {\n  destroyScope(scope);\n  let current = scope.___startNode;\n  const stop = scope.___endNode.nextSibling;\n  while (current !== stop) {\n    const next = current.nextSibling;\n    current.remove();\n    current = next!;\n  }\n}\n\nexport function insertBefore(\n  scope: Scope,\n  parent: Node & ParentNode,\n  nextSibling: Node | null,\n) {\n  let current = scope.___startNode as Node;\n  const stop = scope.___endNode.nextSibling;\n  while (current !== stop) {\n    const next = current.nextSibling;\n    parent.insertBefore(current, nextSibling);\n    current = next!;\n  }\n}\n","import type { Scope } from \"../common/types\";\nimport { insertBefore, removeAndDestroyScope } from \"./scope\";\n\nconst WRONG_POS = 2147483647;\n\nexport function reconcile(\n  parent: Node & ParentNode,\n  oldScopes: Scope[],\n  newScopes: Scope[],\n  afterReference: Node | null,\n): void {\n  let oldStart = 0;\n  let newStart = 0;\n  let oldEnd = oldScopes.length - 1;\n  let newEnd = newScopes.length - 1;\n  let oldStartScope = oldScopes[oldStart];\n  let newStartScope = newScopes[newStart];\n  let oldEndScope = oldScopes[oldEnd];\n  let newEndScope = newScopes[newEnd];\n  let i: number;\n  let j: number | undefined;\n  let k: number;\n  let nextSibling: Node | null;\n  let oldScope: Scope | null;\n  let newScope: Scope;\n\n  // Step 1\n  // tslint:disable-next-line: label-position\n  outer: {\n    // Skip nodes with the same key at the beginning.\n    while (oldStartScope === newStartScope) {\n      ++oldStart;\n      ++newStart;\n      if (oldStart > oldEnd || newStart > newEnd) {\n        break outer;\n      }\n      oldStartScope = oldScopes[oldStart];\n      newStartScope = newScopes[newStart];\n    }\n\n    // Skip nodes with the same key at the end.\n    while (oldEndScope === newEndScope) {\n      --oldEnd;\n      --newEnd;\n      if (oldStart > oldEnd || newStart > newEnd) {\n        break outer;\n      }\n      oldEndScope = oldScopes[oldEnd];\n      newEndScope = newScopes[newEnd];\n    }\n  }\n\n  if (oldStart > oldEnd) {\n    // All old nodes are in the correct place, insert the remaining new nodes.\n    if (newStart <= newEnd) {\n      k = newEnd + 1;\n      nextSibling =\n        k < newScopes.length ? newScopes[k].___startNode : afterReference;\n      do {\n        insertBefore(newScopes[newStart++], parent, nextSibling);\n      } while (newStart <= newEnd);\n    }\n  } else if (newStart > newEnd) {\n    // All new nodes are in the correct place, remove the remaining old nodes.\n    do {\n      removeAndDestroyScope(oldScopes[oldStart++]);\n    } while (oldStart <= oldEnd);\n  } else {\n    // Step 2\n    const oldLength = oldEnd - oldStart + 1;\n    const newLength = newEnd - newStart + 1;\n\n    const aNullable = oldScopes as Array<Scope | null>; // will be removed by js optimizing compilers.\n    // Mark all nodes as inserted.\n    const sources = new Array(newLength);\n    for (i = 0; i < newLength; ++i) {\n      sources[i] = -1;\n    }\n\n    // When pos === WRONG_POS, it means that one of the nodes in the wrong position.\n    let pos = 0;\n    let synced = 0;\n\n    const keyIndex: Map<unknown, number> = new Map();\n    for (j = newStart; j <= newEnd; ++j) {\n      keyIndex.set(newScopes[j], j);\n    }\n\n    for (i = oldStart; i <= oldEnd && synced < newLength; ++i) {\n      oldScope = oldScopes[i];\n      j = keyIndex.get(oldScope);\n      if (j !== undefined) {\n        pos = pos > j ? WRONG_POS : j;\n        ++synced;\n        newScope = newScopes[j];\n        sources[j - newStart] = i;\n        aNullable[i] = null;\n      }\n    }\n\n    if (oldLength === oldScopes.length && synced === 0) {\n      // None of the newNodes already exist in the DOM\n      // All newNodes need to be inserted\n      for (; newStart < newLength; ++newStart) {\n        insertBefore(newScopes[newStart], parent, afterReference);\n      }\n      // All oldNodes need to be removed\n      for (; oldStart < oldLength; ++oldStart) {\n        removeAndDestroyScope(oldScopes[oldStart]);\n      }\n    } else {\n      i = oldLength - synced;\n      while (i > 0) {\n        oldScope = aNullable[oldStart++];\n        if (oldScope !== null) {\n          removeAndDestroyScope(oldScope);\n          i--;\n        }\n      }\n\n      // Step 3\n      if (pos === WRONG_POS) {\n        const seq = longestIncreasingSubsequence(sources);\n        j = seq.length - 1;\n        k = newScopes.length;\n        for (i = newLength - 1; i >= 0; --i) {\n          if (sources[i] === -1) {\n            pos = i + newStart;\n            newScope = newScopes[pos++];\n            nextSibling =\n              pos < k ? newScopes[pos].___startNode : afterReference;\n            insertBefore(newScope, parent, nextSibling);\n          } else {\n            if (j < 0 || i !== seq[j]) {\n              pos = i + newStart;\n              newScope = newScopes[pos++];\n              nextSibling =\n                pos < k ? newScopes[pos].___startNode : afterReference;\n              insertBefore(newScope, parent, nextSibling);\n            } else {\n              --j;\n            }\n          }\n        }\n      } else if (synced !== newLength) {\n        k = newScopes.length;\n        for (i = newLength - 1; i >= 0; --i) {\n          if (sources[i] === -1) {\n            pos = i + newStart;\n            newScope = newScopes[pos++];\n            nextSibling =\n              pos < k ? newScopes[pos].___startNode : afterReference;\n            insertBefore(newScope, parent, nextSibling);\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction longestIncreasingSubsequence(a: number[]): number[] {\n  const p = a.slice();\n  const result: number[] = [];\n  result.push(0);\n  let u: number;\n  let v: number;\n\n  for (let i = 0, il = a.length; i < il; ++i) {\n    if (a[i] === -1) {\n      continue;\n    }\n\n    const j = result[result.length - 1];\n    if (a[j] < a[i]) {\n      p[i] = j;\n      result.push(i);\n      continue;\n    }\n\n    u = 0;\n    v = result.length - 1;\n\n    while (u < v) {\n      // tslint:disable-next-line:no-bitwise\n      const c = ((u + v) / 2) | 0;\n      if (a[result[c]] < a[i]) {\n        u = c + 1;\n      } else {\n        v = c;\n      }\n    }\n\n    if (a[i] < a[result[u]]) {\n      if (u > 0) {\n        p[i] = result[u - 1];\n      }\n      result[u] = i;\n    }\n  }\n\n  u = result.length;\n  v = result[u - 1];\n\n  while (u-- > 0) {\n    result[u] = v;\n    v = p[v];\n  }\n\n  return result;\n}\n","export function classValue(value: unknown) {\n  return toDelimitedString(value, \" \", stringifyClassObject);\n}\n\nfunction stringifyClassObject(name: string, value: unknown) {\n  if (isVoid(value)) {\n    return \"\";\n  }\n\n  return name;\n}\n\nexport function styleValue(value: unknown) {\n  return toDelimitedString(value, \";\", stringifyStyleObject);\n}\n\nconst NON_DIMENSIONAL = /^(--|ta|or|li|z)|n-c|i(do|nk|m|t)|w$|we/;\nfunction stringifyStyleObject(name: string, value: unknown) {\n  if (isVoid(value)) {\n    return \"\";\n  }\n\n  if (typeof value === \"number\" && value && !NON_DIMENSIONAL.test(name)) {\n    (value as unknown as string) += \"px\";\n  }\n\n  return `${name}:${value}`;\n}\n\nfunction toDelimitedString(\n  val: unknown,\n  delimiter: string,\n  stringify: (n: string, v: unknown) => string | undefined,\n) {\n  switch (typeof val) {\n    case \"string\":\n      return val;\n    case \"object\":\n      if (val !== null) {\n        let result = \"\";\n        let curDelimiter = \"\";\n\n        if (Array.isArray(val)) {\n          for (const v of val) {\n            const part = toDelimitedString(v, delimiter, stringify);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        } else {\n          for (const name in val) {\n            const v = (val as Record<string, unknown>)[name];\n            const part = stringify(name, v);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        }\n\n        return result;\n      }\n  }\n\n  return \"\";\n}\n\nexport function isVoid(value: unknown) {\n  return value == null || value === false;\n}\n\nexport function alphaEncode(num: number): string {\n  return num < 52\n    ? String.fromCharCode(num < 26 ? num + 97 : num + (65 - 26))\n    : alphaEncode((num / 52) | 0) + alphaEncode(num % 52);\n}\n","import type { Scope } from \"../common/types\";\nimport { onDestroy } from \"./scope\";\n\nexport function resetAbortSignal(scope: Scope, id: string | number) {\n  const controllers = scope.___abortControllers;\n  if (controllers) {\n    const ctrl = controllers.get(id);\n    if (ctrl) {\n      ctrl.abort();\n      controllers.delete(id);\n    }\n  }\n}\n\nexport function getAbortSignal(scope: Scope, id: string | number) {\n  const controllers = (scope.___abortControllers ??= new Map());\n  let controller = controllers.get(id);\n  if (!controller) {\n    onDestroy(scope);\n    controllers.set(id, (controller = new AbortController()));\n  }\n\n  return controller.signal;\n}\n","import { classValue, styleValue } from \"../common/helpers\";\nimport {\n  type Accessor,\n  AccessorChar,\n  NodeType,\n  type Scope,\n} from \"../common/types\";\nimport { getAbortSignal } from \"./abort-signal\";\nimport { write } from \"./scope\";\n\nexport function isDocumentFragment(node: Node): node is DocumentFragment {\n  return node.nodeType === NodeType.DocumentFragment;\n}\n\nexport function attr(element: Element, name: string, value: unknown) {\n  const normalizedValue = normalizeAttrValue(value);\n  if (normalizedValue === undefined) {\n    element.removeAttribute(name);\n  } else {\n    element.setAttribute(name, normalizedValue);\n  }\n}\n\nexport function classAttr(element: Element, value: unknown) {\n  attr(element, \"class\", classValue(value) || false);\n}\n\nexport function styleAttr(element: Element, value: unknown) {\n  attr(element, \"style\", styleValue(value) || false);\n}\n\nexport function data(node: Text | Comment, value: unknown) {\n  const normalizedValue = normalizeString(value);\n  // TODO: benchmark if it is actually faster to check data first\n  if (node.data !== normalizedValue) {\n    node.data = normalizedValue;\n  }\n}\n\nexport function attrs(\n  scope: Scope,\n  elementAccessor: Accessor,\n  nextAttrs: Record<string, unknown>,\n) {\n  const prevAttrs = scope[elementAccessor + AccessorChar.PreviousAttributes] as\n    | typeof nextAttrs\n    | undefined;\n  const element = scope[elementAccessor] as Element;\n\n  if (prevAttrs) {\n    for (const name in prevAttrs) {\n      if (!(nextAttrs && name in nextAttrs)) {\n        element.removeAttribute(name);\n      }\n    }\n  }\n  // https://jsperf.com/object-keys-vs-for-in-with-closure/194\n  for (const name in nextAttrs) {\n    if (!(prevAttrs && nextAttrs[name] === prevAttrs[name])) {\n      if (name === \"class\") {\n        classAttr(element, nextAttrs[name]);\n      } else if (name === \"style\") {\n        styleAttr(element, nextAttrs[name]);\n      } else if (name !== \"renderBody\") {\n        attr(element, name, nextAttrs[name]);\n      }\n    }\n  }\n\n  scope[elementAccessor + AccessorChar.PreviousAttributes] = nextAttrs;\n}\n\nconst doc = document;\nconst parser = /* @__PURE__ */ doc.createElement(\"template\");\n\nexport function html(scope: Scope, value: unknown, index: Accessor) {\n  const firstChild = scope[index] as Node & ChildNode;\n  const lastChild = (scope[index + \"-\"] || firstChild) as Node & ChildNode;\n  const parentNode = firstChild.parentNode!;\n  const afterReference = lastChild.nextSibling;\n\n  parser.innerHTML = value || value === 0 ? `${value}` : \"<!>\";\n  const newContent = parser.content;\n  write(scope, index, newContent.firstChild);\n  write(scope, (index + \"-\") as any as number, newContent.lastChild);\n  parentNode.insertBefore(newContent, firstChild);\n\n  let current = firstChild;\n  while (current !== afterReference) {\n    const next = current.nextSibling;\n    current.remove();\n    current = next!;\n  }\n}\n\nexport function props(scope: Scope, nodeIndex: number, index: number) {\n  const nextProps = scope[index] as Record<string, unknown>;\n  const prevProps = scope[index + \"-\"] as Record<string, unknown> | undefined;\n  const node = scope[nodeIndex] as Node;\n\n  if (prevProps) {\n    for (const name in prevProps) {\n      if (!(name in nextProps)) {\n        (node as any)[name] = undefined;\n      }\n    }\n  }\n  // https://jsperf.com/object-keys-vs-for-in-with-closure/194\n  for (const name in nextProps) {\n    (node as any)[name] = nextProps[name];\n  }\n\n  scope[index + \"-\"] = nextProps;\n}\n\nfunction normalizeAttrValue(value: unknown) {\n  if (value || value === 0) {\n    return value === true ? \"\" : value + \"\";\n  }\n}\n\nfunction normalizeString(value: unknown) {\n  return value || value === 0 ? value + \"\" : \"\\u200d\";\n}\nexport function lifecycle(\n  scope: Scope,\n  index: string | number,\n  thisObj: Record<string, unknown> & {\n    onMount?: (this: unknown) => void;\n    onUpdate?: (this: unknown) => void;\n    onDestroy?: (this: unknown) => void;\n  },\n) {\n  const instance = scope[index] as typeof thisObj;\n  if (instance) {\n    Object.assign(instance, thisObj);\n    instance.onUpdate?.();\n  } else {\n    scope[index] = thisObj;\n    thisObj.onMount?.();\n    getAbortSignal(\n      scope,\n      AccessorChar.LifecycleAbortController + index,\n    ).onabort = () => thisObj.onDestroy?.();\n  }\n}\n","import { type Scope, NodeType, WalkCode, WalkRangeSize } from \"../common/types\";\nimport { createScope } from \"./scope\";\n\nexport const walker = /* @__PURE__ */ document.createTreeWalker(document);\n\n// Laws of the walks string:\n//  - Always prefer Get to Before to After, Inside, or Replace\n//    - Get must always be used to get a static node from clonable template if possible\n//    - Replace must only be used to insert between two static text nodes\n//    - Inside must only be used to insert into elements with no static children\n//    - After must only be used to insert a last child or immediately following another action (if it makes the walks string smaller)\n//  - Adjacent actions must always be in source order (Before* Get* Inside* After* || Before* Replace)\n//    - When an element is both walked into and needs to insert After, you must walk in first (Next) and then walk Out before After\n//  - Unless the inserted node is Text, Inside, After, & Replace must be followed by Out/Over to skip over unknown children\n//  - Out must always be followed by After or Over\n//    - Before must be done before walking into the node\n//    - Next would walk back in the node we just walked Out of\n//  - A component must assume the walker is on its first node, and include instructions for walking to its assumed nextSibling\n\nexport function trimWalkString(walkString: string): string {\n  let end = walkString.length;\n  while (walkString.charCodeAt(--end) > WalkCode.BeginChild);\n  return walkString.slice(0, end + 1);\n}\n\nexport function walk(startNode: Node, walkCodes: string, scope: Scope) {\n  walker.currentNode = startNode;\n  walkInternal(walkCodes, scope, 0);\n  walker.currentNode = document.documentElement;\n}\n\nfunction walkInternal(\n  walkCodes: string,\n  scope: Scope,\n  currentWalkIndex: number,\n) {\n  let value: number;\n  let storedMultiplier = 0;\n  let currentMultiplier = 0;\n  let currentScopeIndex = 0;\n\n  while ((value = walkCodes.charCodeAt(currentWalkIndex++))) {\n    currentMultiplier = storedMultiplier;\n    storedMultiplier = 0;\n    if (value >= WalkCode.Multiplier) {\n      storedMultiplier =\n        currentMultiplier * WalkRangeSize.Multiplier +\n        value -\n        WalkCode.Multiplier;\n    } else if (value >= WalkCode.Out) {\n      value = WalkRangeSize.Out * currentMultiplier + value - WalkCode.Out;\n      while (value--) {\n        walker.parentNode();\n      }\n      walker.nextSibling();\n    } else if (value >= WalkCode.Over) {\n      value = WalkRangeSize.Over * currentMultiplier + value - WalkCode.Over;\n      while (value--) {\n        !walker.nextSibling() && !walker.nextNode();\n      }\n    } else if (value >= WalkCode.Next) {\n      value = WalkRangeSize.Next * currentMultiplier + value - WalkCode.Next;\n      while (value--) {\n        walker.nextNode();\n      }\n    } else if (value === WalkCode.BeginChild) {\n      currentWalkIndex = walkInternal(\n        walkCodes,\n        (scope[\n          MARKO_DEBUG\n            ? getDebugKey(currentScopeIndex++, \"#childScope\")\n            : currentScopeIndex++\n        ] = createScope(scope.$global)),\n        currentWalkIndex,\n      )!;\n    } else if (value === WalkCode.EndChild) {\n      return currentWalkIndex;\n    } else if (value === WalkCode.Get) {\n      scope[\n        MARKO_DEBUG\n          ? getDebugKey(currentScopeIndex++, walker.currentNode)\n          : currentScopeIndex++\n      ] = walker.currentNode;\n    } else {\n      const newNode = (scope[\n        MARKO_DEBUG\n          ? getDebugKey(currentScopeIndex++, \"#text\")\n          : currentScopeIndex++\n      ] = document.createTextNode(\"\"));\n      const current = walker.currentNode;\n      const parentNode = current.parentNode!;\n\n      if (value === WalkCode.Before) {\n        parentNode.insertBefore(newNode, current);\n      } else {\n        if (value === WalkCode.After) {\n          parentNode.insertBefore(newNode, current.nextSibling);\n        } else {\n          if (MARKO_DEBUG && value !== WalkCode.Replace) {\n            throw new Error(`Unknown walk code: ${value}`);\n          }\n          parentNode.replaceChild(newNode, current);\n        }\n\n        walker.currentNode = newNode;\n      }\n    } /* else {\n      if (MARKO_DEBUG && value !== WalkCodes.Replace) {\n        throw new Error(`Unknown walk code: ${value}`);\n      }\n      const current = walker.currentNode;\n      current.parentNode!.replaceChild(walker.currentNode = scope[currentScopeIndex++] = document.createTextNode(\"\"), current);\n    } */\n  }\n\n  return currentWalkIndex;\n}\n\nfunction getDebugKey(index: number, node: Node | string) {\n  if (typeof node === \"string\") {\n    return `${node}/${index}`;\n  } else if (node.nodeType === NodeType.Text) {\n    return `#text/${index}`;\n  } else if (node.nodeType === NodeType.Comment) {\n    return `#comment/${index}`;\n  } else if (node.nodeType === NodeType.Element) {\n    return `#${(node as Element).tagName.toLowerCase()}/${index}`;\n  }\n\n  return index;\n}\n","import {\n  type Accessor,\n  AccessorChar,\n  NodeType,\n  WalkCode,\n  type Scope,\n} from \"../common/types\";\nimport { setConditionalRendererOnlyChild } from \"./control-flow\";\nimport { attrs } from \"./dom\";\nimport { bindRenderer, createScope } from \"./scope\";\nimport type { IntersectionSignal, ValueSignal } from \"./signals\";\nimport { trimWalkString, walk } from \"./walker\";\n\nexport type Renderer = {\n  ___template: string;\n  ___walks: string | undefined;\n  ___setup: SetupFn | undefined;\n  ___closureSignals: Set<IntersectionSignal>;\n  ___clone: () => Node;\n  ___hasUserEffects: 0 | 1;\n  ___sourceNode: Node | undefined;\n  ___args: ValueSignal | undefined;\n  ___owner: Scope | undefined;\n};\n\nexport type RendererOrElementName =\n  | Renderer\n  | (string & Record<keyof Renderer, undefined>);\n\ntype SetupFn = (scope: Scope) => void;\n\nexport function createScopeWithRenderer(\n  renderer: RendererOrElementName,\n  $global: Scope[\"___global\"],\n  ownerScope?: Scope,\n) {\n  const newScope = createScope($global);\n  newScope._ = renderer.___owner || ownerScope;\n  newScope.___renderer = renderer as Renderer;\n  initRenderer(renderer, newScope);\n  if (renderer.___closureSignals) {\n    for (const signal of renderer.___closureSignals) {\n      signal.___subscribe?.(newScope);\n    }\n  }\n  return newScope;\n}\n\nexport function initRenderer(renderer: RendererOrElementName, scope: Scope) {\n  const dom =\n    typeof renderer === \"string\"\n      ? document.createElement(renderer)\n      : renderer.___clone();\n  walk(\n    dom.nodeType === NodeType.DocumentFragment ? dom.firstChild! : dom,\n    renderer.___walks ?? \" \",\n    scope,\n  );\n  scope.___startNode =\n    dom.nodeType === NodeType.DocumentFragment\n      ? dom.firstChild!\n      : (dom as ChildNode);\n  scope.___endNode =\n    dom.nodeType === NodeType.DocumentFragment\n      ? dom.lastChild!\n      : (dom as ChildNode);\n  if (renderer.___setup) {\n    renderer.___setup(scope);\n  }\n  return dom;\n}\n\nexport function dynamicTagAttrs(\n  nodeAccessor: Accessor,\n  renderBody?: Renderer,\n  inputIsArgs?: boolean,\n) {\n  return (\n    scope: Scope,\n    getAttrs: () => Record<string, unknown>,\n    clean?: boolean | 1,\n  ) => {\n    const renderer = scope[\n      nodeAccessor + AccessorChar.ConditionalRenderer\n    ] as Renderer;\n\n    if (!renderer || renderer === renderBody || (clean && !renderer.___args)) {\n      return;\n    }\n\n    const childScope = scope[nodeAccessor + AccessorChar.ConditionalScope];\n    if (typeof renderer === \"string\") {\n      // This will always be 0 because in dynamicRenderer we used WalkCodes.Get\n      const elementAccessor = MARKO_DEBUG ? `#${renderer}/0` : 0;\n      attrs(childScope, elementAccessor, getAttrs());\n      setConditionalRendererOnlyChild(\n        childScope,\n        elementAccessor,\n        renderBody && bindRenderer(scope, renderBody),\n      );\n    } else if (renderer.___args) {\n      if (clean) {\n        renderer.___args(childScope, null as any, clean);\n      } else {\n        const attributes = getAttrs();\n        renderer.___args(\n          childScope,\n          inputIsArgs\n            ? attributes\n            : [\n                renderBody\n                  ? {\n                      ...attributes,\n                      renderBody: bindRenderer(scope, renderBody),\n                    }\n                  : attributes,\n              ],\n          clean,\n        );\n      }\n    }\n  };\n}\n\nexport function createRenderer(\n  template: string,\n  walks?: string,\n  setup?: SetupFn,\n  closureSignals?: IntersectionSignal[],\n  hasUserEffects: 0 | 1 = 0,\n  args?: ValueSignal,\n): Renderer {\n  return {\n    ___template: template,\n    ___walks: walks && /* @__PURE__ */ trimWalkString(walks),\n    ___setup: setup,\n    ___clone: _clone,\n    ___closureSignals: new Set(closureSignals),\n    ___hasUserEffects: hasUserEffects,\n    ___sourceNode: undefined,\n    ___args: args,\n    ___owner: undefined,\n  };\n}\n\nfunction _clone(this: Renderer) {\n  let sourceNode: Node | null | undefined = this.___sourceNode;\n  if (!sourceNode) {\n    if (MARKO_DEBUG && this.___template === undefined) {\n      throw new Error(\n        \"The renderer does not have a template to clone: \" +\n          JSON.stringify(this),\n      );\n    }\n    const walks = this.___walks;\n    // TODO: there's probably a better way to determine if nodes will be inserted before/after the parsed content\n    // and therefore we need to put it in a document fragment, even though only a single node results from the parse\n    const ensureFragment =\n      walks &&\n      walks.length < 4 &&\n      walks.charCodeAt(walks.length - 1) !== WalkCode.Get;\n    this.___sourceNode = sourceNode = parse(\n      this.___template,\n      ensureFragment as boolean,\n    );\n  }\n  return sourceNode.cloneNode(true);\n}\n\nconst doc = document;\nconst parser = /* @__PURE__ */ doc.createElement(\"template\");\n\nfunction parse(template: string, ensureFragment?: boolean) {\n  let node: Node | null;\n  parser.innerHTML = template;\n  const content = parser.content;\n\n  if (\n    ensureFragment ||\n    (node = content.firstChild) !== content.lastChild ||\n    (node && node.nodeType === NodeType.Comment)\n  ) {\n    node = doc.createDocumentFragment();\n    node.appendChild(content);\n  } else if (!node) {\n    node = doc.createTextNode(\"\");\n  }\n\n  return node as Node & { firstChild: ChildNode; lastChild: ChildNode };\n}\n","import { type Accessor, AccessorChar, type Scope } from \"../common/types\";\nimport type { RendererOrElementName } from \"./renderer\";\nimport { bindFunction } from \"./scope\";\n\nexport type Signal = ValueSignal | IntersectionSignal;\n\nexport type ValueSignal<T = unknown> = (\n  scope: Scope,\n  value: T,\n  clean?: 1 | boolean,\n) => void;\n\nexport type BoundValueSignal<T = unknown> = (\n  value: T,\n  clean?: 1 | boolean,\n) => void;\n\nexport type IntersectionSignal = ((\n  scope: Scope,\n  clean?: 1 | boolean,\n) => void) & {\n  ___subscribe?(scope: Scope): void;\n  ___unsubscribe?(scope: Scope): void;\n};\n\nexport type BoundIntersectionSignal = ((clean?: 1 | boolean) => void) & {\n  ___subscribe?(scope: Scope): void;\n  ___unsubscribe?(scope: Scope): void;\n};\n\nexport function initValue<T>(\n  valueAccessor: Accessor,\n  fn: ValueSignal<T>,\n): ValueSignal<T> {\n  const markAccessor = valueAccessor + AccessorChar.Mark;\n  return (scope, nextValue, clean) => {\n    if (clean !== 1 && scope[markAccessor] === undefined) {\n      fn(scope, nextValue, clean);\n    }\n  };\n}\n\nexport function value<T>(\n  valueAccessor: Accessor,\n  render?: ValueSignal<T>,\n  intersection?: IntersectionSignal,\n  valueWithIntersection?: ValueSignal<any>,\n): ValueSignal<T> {\n  const markAccessor = valueAccessor + AccessorChar.Mark;\n  return (scope, nextValue, clean) => {\n    let creation: boolean | undefined;\n    let currentMark: number;\n\n    if (clean === 1) {\n      currentMark = scope[markAccessor] = (scope[markAccessor] ?? 0) + 1;\n    } else {\n      creation = scope[markAccessor] === undefined;\n      currentMark = scope[markAccessor] ||= 1;\n    }\n\n    if (currentMark === 1) {\n      if (\n        clean !== 1 &&\n        (creation || !(clean ||= scope[valueAccessor] === nextValue))\n      ) {\n        scope[valueAccessor] = nextValue;\n        render?.(scope, nextValue);\n      } else {\n        valueWithIntersection?.(scope, 0, clean);\n      }\n      intersection?.(scope, clean);\n    }\n\n    // closure needs this to be called after the fn\n    // so it is marked until all downstream have been called\n    if (clean !== 1) {\n      scope[markAccessor]--;\n    }\n  };\n}\n\nlet accessorId = 0;\n\nexport function intersection(\n  count: number,\n  fn: IntersectionSignal,\n  intersection?: IntersectionSignal,\n  valueWithIntersection?: ValueSignal,\n): IntersectionSignal {\n  const cleanAccessor = AccessorChar.Dynamic + accessorId++;\n  const markAccessor = cleanAccessor + AccessorChar.Mark;\n  return (scope, clean) => {\n    let currentMark;\n    if (clean === 1) {\n      currentMark = scope[markAccessor] = (scope[markAccessor] ?? 0) + 1;\n    } else {\n      if (scope[markAccessor] === undefined) {\n        scope[markAccessor] = count - 1;\n        clean = undefined;\n      } else {\n        currentMark = scope[markAccessor]--;\n        clean = scope[cleanAccessor] &&= clean;\n      }\n    }\n    if (currentMark === 1) {\n      if (clean) {\n        valueWithIntersection?.(scope, 0, clean);\n      } else {\n        scope[cleanAccessor] = true;\n        fn(scope, clean);\n      }\n      intersection?.(scope, clean);\n    }\n  };\n}\n\nconst defaultGetOwnerScope = (scope: Scope) => scope._!;\n\nexport function closure<T>(\n  ownerValueAccessor: Accessor | ((scope: Scope) => Accessor),\n  fn: ValueSignal<T>,\n  _getOwnerScope?: (scope: Scope) => Scope,\n  intersection?: IntersectionSignal,\n  valueWithIntersection?: ValueSignal<any>,\n): IntersectionSignal {\n  const cleanAccessor = AccessorChar.Dynamic + accessorId++;\n  const markAccessor = cleanAccessor + 1;\n  const getOwnerScope = _getOwnerScope || defaultGetOwnerScope;\n  const getOwnerValueAccessor =\n    typeof ownerValueAccessor === \"function\"\n      ? ownerValueAccessor\n      : () => ownerValueAccessor as Accessor;\n  return (scope, clean) => {\n    let ownerScope, ownerValueAccessor, currentMark;\n    if (clean === 1) {\n      currentMark = scope[markAccessor] = (scope[markAccessor] ?? 0) + 1;\n    } else {\n      if (scope[markAccessor] === undefined) {\n        ownerScope = getOwnerScope(scope);\n        ownerValueAccessor = getOwnerValueAccessor(scope);\n        const ownerMark = ownerScope[ownerValueAccessor + AccessorChar.Mark];\n        const ownerHasRun =\n          ownerMark === undefined ? !ownerScope.___client : ownerMark === 0;\n        scope[markAccessor] = (currentMark = ownerHasRun ? 1 : 2) - 1;\n        clean = undefined;\n      } else {\n        currentMark = scope[markAccessor]--;\n        clean = scope[cleanAccessor] &&= clean;\n      }\n    }\n    if (currentMark === 1) {\n      if (clean) {\n        valueWithIntersection?.(scope, 0, clean);\n      } else {\n        scope[cleanAccessor] = false;\n        ownerScope ??= getOwnerScope(scope);\n        ownerValueAccessor ??= getOwnerValueAccessor(scope);\n        fn?.(scope, ownerScope[ownerValueAccessor]);\n      }\n      intersection?.(scope, clean);\n    }\n  };\n}\n\nexport function dynamicClosure<T>(\n  ownerValueAccessor: Accessor | ((scope: Scope) => Accessor),\n  fn: ValueSignal<T>,\n  _getOwnerScope?: (scope: Scope) => Scope,\n  intersection?: IntersectionSignal,\n  valueWithIntersection?: ValueSignal,\n): IntersectionSignal {\n  const getOwnerScope = _getOwnerScope || defaultGetOwnerScope;\n  const getOwnerValueAccessor =\n    typeof ownerValueAccessor === \"function\"\n      ? ownerValueAccessor\n      : () => ownerValueAccessor as string;\n  const signalFn = closure(\n    getOwnerValueAccessor,\n    fn,\n    getOwnerScope,\n    intersection,\n    valueWithIntersection,\n  );\n  return Object.assign(signalFn, {\n    ___subscribe(scope: Scope) {\n      const ownerScope = getOwnerScope(scope);\n      const providerSubscriptionsAccessor =\n        getOwnerValueAccessor(scope) + AccessorChar.Subscribers;\n      ownerScope[providerSubscriptionsAccessor] ??= new Set();\n      ownerScope[providerSubscriptionsAccessor].add(\n        bindFunction(scope, signalFn as any),\n      );\n    },\n    ___unsubscribe(scope: Scope) {\n      const ownerScope = getOwnerScope(scope);\n      const providerSubscriptionsAccessor =\n        getOwnerValueAccessor(scope) + AccessorChar.Subscribers;\n      ownerScope[providerSubscriptionsAccessor]?.delete(\n        bindFunction(scope, signalFn as any),\n      );\n    },\n  });\n}\n\nexport function childClosures(\n  closureSignals: IntersectionSignal[],\n  childAccessor: Accessor,\n) {\n  const signal = (scope: Scope, clean?: boolean | 1) => {\n    const childScope = scope[childAccessor] as Scope;\n    for (const closureSignal of closureSignals) {\n      closureSignal(childScope, clean);\n    }\n  };\n  return Object.assign(signal, {\n    ___subscribe(scope: Scope) {\n      const childScope = scope[childAccessor] as Scope;\n      for (const closureSignal of closureSignals) {\n        closureSignal.___subscribe?.(childScope);\n      }\n    },\n    ___unsubscribe(scope: Scope) {\n      const childScope = scope[childAccessor] as Scope;\n      for (const closureSignal of closureSignals) {\n        closureSignal.___unsubscribe?.(childScope);\n      }\n    },\n  });\n}\n\nexport function dynamicSubscribers(valueAccessor: Accessor) {\n  const subscribersAccessor = valueAccessor + AccessorChar.Subscribers;\n  return (scope: Scope, clean?: boolean | 1) => {\n    const subscribers = scope[\n      subscribersAccessor\n    ] as Set<BoundIntersectionSignal>;\n    if (subscribers) {\n      for (const subscriber of subscribers) {\n        subscriber(clean);\n      }\n    }\n  };\n}\n\nexport function setTagVar(\n  scope: Scope,\n  childAccessor: Accessor,\n  tagVarSignal: ValueSignal,\n) {\n  scope[childAccessor][AccessorChar.TagVariable] = bindFunction(\n    scope,\n    tagVarSignal as any,\n  ) as BoundValueSignal;\n}\n\nexport const tagVarSignal = (\n  scope: Scope,\n  value: unknown,\n  clean?: boolean | 1,\n) => scope[AccessorChar.TagVariable]?.(value, clean);\n\nexport const renderBodyClosures = (\n  renderBody: RendererOrElementName | undefined,\n  childScope: Scope,\n  clean?: 1 | boolean,\n) => {\n  const signals = renderBody?.___closureSignals;\n  if (signals) {\n    for (const signal of signals) {\n      signal(childScope, clean);\n    }\n  }\n};\n\nexport const inMany = (\n  scopes: Scope[],\n  clean: 1 | boolean | undefined,\n  signal: IntersectionSignal,\n) => {\n  for (const scope of scopes) {\n    signal(scope, clean);\n  }\n};\n\nlet tagId = 0;\nexport function nextTagId() {\n  return \"c\" + tagId++;\n}\n\nexport function inChild(childAccessor: Accessor, signal: ValueSignal) {\n  return (scope: Scope, _: unknown, clean?: 1 | boolean) => {\n    signal(scope[childAccessor] as Scope, _, clean);\n  };\n}\n\nexport function intersections(\n  signals: IntersectionSignal[],\n): IntersectionSignal {\n  return (scope, clean) => {\n    for (const signal of signals) {\n      signal(scope, clean);\n    }\n  };\n}\n\nexport function values(signals: ValueSignal[]): ValueSignal {\n  return (scope, _, clean) => {\n    for (const signal of signals) {\n      signal(scope, _, clean);\n    }\n  };\n}\n","import { type Accessor, AccessorChar, type Scope } from \"../common/types\";\nimport { reconcile } from \"./reconcile\";\nimport {\n  type Renderer,\n  type RendererOrElementName,\n  createScopeWithRenderer,\n} from \"./renderer\";\nimport {\n  destroyScope,\n  getEmptyScope,\n  insertBefore,\n  removeAndDestroyScope,\n} from \"./scope\";\nimport {\n  type IntersectionSignal,\n  type ValueSignal,\n  renderBodyClosures,\n} from \"./signals\";\nimport type { ClientTemplate as Template } from \"./template\";\n\ntype LoopForEach = (\n  value: unknown[],\n  cb: (key: unknown, args: unknown[]) => void,\n) => void;\n\nexport function patchConditionals(\n  fn: <T extends typeof conditional | typeof conditionalOnlyChild>(\n    cond: T,\n  ) => T,\n) {\n  conditional = fn(conditional);\n  conditionalOnlyChild = fn(conditionalOnlyChild);\n}\n\nexport let conditional = function conditional(\n  nodeAccessor: Accessor,\n  dynamicTagAttrs?: IntersectionSignal,\n  intersection?: IntersectionSignal,\n  valueWithIntersection?: ValueSignal,\n): ValueSignal<RendererOrElementName | undefined> {\n  const rendererAccessor = nodeAccessor + AccessorChar.ConditionalRenderer;\n  const childScopeAccessor = nodeAccessor + AccessorChar.ConditionalScope;\n  return (scope, newRenderer, clean) => {\n    newRenderer = newRenderer\n      ? (newRenderer as any as Template)._ || newRenderer\n      : undefined;\n    let currentRenderer = scope[rendererAccessor] as\n      | RendererOrElementName\n      | undefined;\n    if (!clean && !(clean = currentRenderer === newRenderer)) {\n      currentRenderer = scope[rendererAccessor] = newRenderer;\n      setConditionalRenderer(scope, nodeAccessor, newRenderer);\n      dynamicTagAttrs?.(scope);\n    } else {\n      valueWithIntersection?.(scope, 0, clean);\n    }\n    intersection?.(scope, clean);\n    renderBodyClosures(currentRenderer, scope[childScopeAccessor], clean);\n  };\n};\n\n// TODO: remove this, use return from conditional instead\nexport function inConditionalScope<S extends Scope>(\n  signal: IntersectionSignal,\n  nodeAccessor: Accessor /* branch?: Renderer */,\n): IntersectionSignal {\n  const scopeAccessor = nodeAccessor + AccessorChar.ConditionalScope;\n  const rendererAccessor = nodeAccessor + AccessorChar.ConditionalRenderer;\n  return (scope: Scope, clean?: boolean | 1) => {\n    const conditionalScope = scope[scopeAccessor] as S;\n    if (conditionalScope) {\n      const conditionalRenderer = scope[rendererAccessor] as Renderer;\n      if (\n        !conditionalRenderer?.___closureSignals ||\n        conditionalRenderer.___closureSignals.has(signal)\n      ) {\n        signal(conditionalScope, clean);\n      }\n    }\n  };\n}\n\nexport function setConditionalRenderer<ChildScope extends Scope>(\n  scope: Scope,\n  nodeAccessor: Accessor,\n  newRenderer: RendererOrElementName | undefined,\n) {\n  let newScope: ChildScope;\n  let prevScope = scope[\n    nodeAccessor + AccessorChar.ConditionalScope\n  ] as ChildScope;\n\n  if (newRenderer) {\n    newScope = scope[nodeAccessor + AccessorChar.ConditionalScope] =\n      createScopeWithRenderer(newRenderer, scope.$global, scope) as ChildScope;\n    prevScope = prevScope || getEmptyScope(scope[nodeAccessor] as Comment);\n  } else {\n    newScope = getEmptyScope(scope[nodeAccessor] as Comment) as ChildScope;\n    scope[nodeAccessor + AccessorChar.ConditionalScope] = undefined;\n  }\n\n  insertBefore(\n    newScope,\n    prevScope.___startNode.parentNode!,\n    prevScope.___startNode,\n  );\n  removeAndDestroyScope(prevScope);\n}\n\nexport let conditionalOnlyChild = function conditionalOnlyChild(\n  nodeAccessor: Accessor,\n  action?: ValueSignal<RendererOrElementName | undefined>,\n): ValueSignal<RendererOrElementName | undefined> {\n  const rendererAccessor = nodeAccessor + AccessorChar.ConditionalRenderer;\n  const childScopeAccessor = nodeAccessor + AccessorChar.ConditionalScope;\n  return (scope, newRenderer, clean) => {\n    let currentRenderer = scope[rendererAccessor] as\n      | RendererOrElementName\n      | undefined;\n    if (!clean && currentRenderer !== newRenderer) {\n      currentRenderer = scope[rendererAccessor] = newRenderer;\n      setConditionalRendererOnlyChild(scope, nodeAccessor, newRenderer);\n    }\n    renderBodyClosures(currentRenderer, scope[childScopeAccessor], clean);\n    action?.(scope, currentRenderer, clean);\n  };\n};\n\nexport function setConditionalRendererOnlyChild(\n  scope: Scope,\n  nodeAccessor: Accessor,\n  newRenderer: RendererOrElementName | undefined,\n) {\n  const prevScope = scope[\n    nodeAccessor + AccessorChar.ConditionalScope\n  ] as Scope;\n  const referenceNode = scope[nodeAccessor] as Element;\n  referenceNode.textContent = \"\";\n\n  if (newRenderer) {\n    const newScope = (scope[nodeAccessor + AccessorChar.ConditionalScope] =\n      createScopeWithRenderer(newRenderer, scope.$global, scope));\n    insertBefore(newScope, referenceNode, null);\n  }\n\n  prevScope && destroyScope(prevScope);\n}\n\nconst emptyMarkerMap = /* @__PURE__ */ (() =>\n  new Map().set(Symbol(\"empty\"), getEmptyScope(undefined as any)))();\nexport const emptyMarkerArray = [\n  /* @__PURE__ */ getEmptyScope(undefined as any),\n];\nconst emptyMap = new Map();\nconst emptyArray = [] as Scope[];\n\nexport function loopOf(nodeAccessor: Accessor, renderer: Renderer) {\n  return loop(nodeAccessor, renderer, (value, cb) => {\n    const [all, getKey = keyBySecondArg] = value as typeof value &\n      [all: unknown[], getKey?: (item: unknown, index: number) => unknown];\n    let i = 0;\n    for (const item of all) {\n      cb(getKey(item, i), [item, i, all]);\n      i++;\n    }\n  });\n}\n\nexport function loopIn(nodeAccessor: Accessor, renderer: Renderer) {\n  return loop(nodeAccessor, renderer, (value, cb) => {\n    const [all, getKey = keyByFirstArg] = value as typeof value &\n      [\n        all: Record<string, unknown>,\n        getKey?: (key: string, v: unknown) => unknown,\n      ];\n    for (const key in all) {\n      const v = all[key];\n      cb(getKey(key, v), [key, v, all]);\n    }\n  });\n}\n\nexport function loopTo(nodeAccessor: Accessor, renderer: Renderer) {\n  return loop(nodeAccessor, renderer, (value, cb) => {\n    const [to, from = 0, step = 1, getKey = keyByFirstArg] = value as [\n      to: number,\n      from: number,\n      step: number,\n      getKey?: (v: number) => unknown,\n    ];\n    const steps = (to - from) / step;\n    for (let i = 0; i <= steps; i++) {\n      const v = from + i * step;\n      cb(getKey(v), [v]);\n    }\n  });\n}\n\nfunction loop(\n  nodeAccessor: Accessor,\n  renderer: Renderer,\n  forEach: LoopForEach,\n) {\n  const loopScopeAccessor = nodeAccessor + AccessorChar.LoopScopeArray;\n  const closureSignals = renderer.___closureSignals;\n  const params = renderer.___args;\n  return (\n    scope: Scope,\n    value: [unknown, (...args: unknown[]) => unknown],\n    clean: boolean | 1,\n  ) => {\n    if (clean) {\n      for (const childScope of scope[loopScopeAccessor]) {\n        params?.(childScope, null, clean);\n        for (const signal of closureSignals) {\n          signal(childScope, clean);\n        }\n      }\n\n      return;\n    }\n\n    const referenceNode = scope[nodeAccessor] as Element | Comment | Text;\n    // TODO: compiler should use only comment so the text check can be removed\n    const referenceIsMarker =\n      referenceNode.nodeType === 8 /* Comment */ ||\n      referenceNode.nodeType === 3; /* Text */\n    const oldMap =\n      (scope[nodeAccessor + AccessorChar.LoopScopeMap] as Map<\n        unknown,\n        Scope\n      >) || (referenceIsMarker ? emptyMarkerMap : emptyMap);\n    const oldArray =\n      (scope[nodeAccessor + AccessorChar.LoopScopeArray] as Scope[]) ||\n      Array.from(oldMap.values());\n\n    let newMap!: Map<unknown, Scope>;\n    let newArray!: Scope[];\n    let afterReference: Node | null;\n    let parentNode: Node & ParentNode;\n    let needsReconciliation = true;\n\n    forEach(value, (key, args) => {\n      let childScope = oldMap.get(key);\n      const isNew = !childScope;\n      if (!childScope) {\n        childScope = createScopeWithRenderer(renderer, scope.$global, scope);\n        // TODO: once we can track moves\n        // needsReconciliation = true;\n      } else {\n        // TODO: track if any childScope has changed index\n        // needsReconciliation ||= oldArray[index] !== childScope;\n      }\n      if (params) {\n        params(childScope, args);\n      }\n      if (closureSignals) {\n        for (const signal of closureSignals) {\n          signal(childScope, isNew);\n        }\n      }\n\n      if (newMap) {\n        newMap.set(key, childScope);\n        newArray.push(childScope);\n      } else {\n        newMap = new Map([[key, childScope]]);\n        newArray = [childScope];\n      }\n    });\n\n    if (!newMap) {\n      if (referenceIsMarker) {\n        newMap = emptyMarkerMap;\n        newArray = emptyMarkerArray;\n        getEmptyScope(referenceNode as Comment);\n      } else {\n        // Fast path when loop is only child of parent\n        if (renderer.___hasUserEffects) {\n          for (let i = 0; i < oldArray.length; i++) {\n            destroyScope(oldArray[i]);\n          }\n        }\n        referenceNode.textContent = \"\";\n        newMap = emptyMap;\n        newArray = emptyArray;\n        needsReconciliation = false;\n      }\n    }\n\n    if (needsReconciliation) {\n      if (referenceIsMarker) {\n        if (oldMap === emptyMarkerMap) {\n          getEmptyScope(referenceNode as Comment);\n        }\n        const oldLastChild = oldArray[oldArray.length - 1];\n        afterReference = oldLastChild.___endNode.nextSibling;\n        parentNode = oldLastChild.___startNode.parentNode!;\n      } else {\n        afterReference = null;\n        parentNode = referenceNode as Element;\n      }\n      reconcile(parentNode, oldArray, newArray!, afterReference);\n    }\n\n    scope[nodeAccessor + AccessorChar.LoopScopeMap] = newMap;\n    scope[nodeAccessor + AccessorChar.LoopScopeArray] = newArray;\n  };\n}\n\n// TODO: remove this, use return from loop instead\nexport function inLoopScope(\n  signal: IntersectionSignal,\n  loopNodeAccessor: Accessor,\n) {\n  const loopScopeAccessor = loopNodeAccessor + AccessorChar.LoopScopeArray;\n  return (scope: Scope, clean?: boolean | 1) => {\n    const loopScopes =\n      scope[loopScopeAccessor] ??\n      scope[loopNodeAccessor + AccessorChar.LoopScopeMap]?.values() ??\n      [];\n    for (const scope of loopScopes) {\n      signal(scope, clean);\n    }\n  };\n}\n\nfunction keyBySecondArg(_item: unknown, index: unknown) {\n  return index;\n}\n\nfunction keyByFirstArg(name: unknown) {\n  return name;\n}\n","type EventNames = keyof GlobalEventHandlersEventMap;\n\nconst elementHandlersByEvent = new Map<\n  string,\n  WeakMap<Element, undefined | ((...args: any[]) => void)>\n>();\nconst delegatedEventsByRoot = new WeakMap<Node, Set<string>>();\nconst eventOpts: AddEventListenerOptions = { capture: true };\n\nexport function on<\n  T extends EventNames,\n  H extends\n    | false\n    | null\n    | undefined\n    | ((ev: GlobalEventHandlersEventMap[T], target: Element) => void),\n>(element: Element, type: T, handler: H) {\n  let handlersByElement = elementHandlersByEvent.get(type);\n\n  if (!handlersByElement) {\n    elementHandlersByEvent.set(type, (handlersByElement = new WeakMap()));\n  }\n\n  if (!handlersByElement.has(element)) {\n    ensureDelegated(element, type);\n  }\n\n  handlersByElement.set(element, handler || undefined);\n}\n\nfunction ensureDelegated(node: Node, type: string) {\n  const root = node.getRootNode();\n  let delegatedEvents = delegatedEventsByRoot.get(root);\n\n  if (!delegatedEvents) {\n    delegatedEventsByRoot.set(root, (delegatedEvents = new Set()));\n  }\n\n  if (!delegatedEvents.has(type)) {\n    delegatedEvents.add(type);\n    root.addEventListener(type, handleDelegated, eventOpts);\n  }\n}\n\nfunction handleDelegated(ev: GlobalEventHandlersEventMap[EventNames]) {\n  let target = ev.target as Element | null;\n  if (target) {\n    const handlersByElement = elementHandlersByEvent.get(ev.type)!;\n    handlersByElement.get(target)?.(ev, target);\n\n    if (ev.bubbles) {\n      while ((target = target.parentElement) && !ev.cancelBubble) {\n        handlersByElement.get(target)?.(ev, target);\n      }\n    }\n  }\n}\n","import { ResumeSymbol, type Scope } from \"../common/types\";\nimport type { Renderer } from \"./renderer\";\nimport { bindFunction, bindRenderer } from \"./scope\";\nimport type { IntersectionSignal, ValueSignal } from \"./signals\";\n\ntype RegisteredFn<S extends Scope = Scope> = (scope: S) => void;\n\nconst registeredObjects = new Map<\n  string,\n  RegisteredFn | ValueSignal | Renderer\n>();\nconst doc = document;\n\nexport function register<T>(id: string, obj: T): T {\n  registeredObjects.set(id, obj as any);\n  return obj;\n}\n\nexport function getRegisteredWithScope(registryId: string, scope: Scope) {\n  const obj = registeredObjects.get(registryId);\n  if (!scope) {\n    return obj;\n  } else if ((obj as Renderer).___template) {\n    return bindRenderer(scope, obj as Renderer);\n  } else {\n    return bindFunction(scope, obj as RegisteredFn);\n  }\n}\n\nexport const scopeLookup = {} as Record<number | string, Scope>;\n\nexport function init(\n  runtimeId = ResumeSymbol.DefaultRuntimeId /* [a-zA-Z0-9]+ */,\n) {\n  const runtimeLength = runtimeId.length;\n  const resumeVar = runtimeId + ResumeSymbol.VarResume;\n  // TODO: check if this is a fakeArray\n  // and warn in dev that there are conflicting runtime ids\n  const initialHydration = (window as any)[resumeVar];\n  const walker = doc.createTreeWalker(doc, 128 /** NodeFilter.SHOW_COMMENT */);\n\n  let currentScopeId: number;\n  let currentNode: Node & ChildNode;\n  // const scopeLookup: Record<number, Scope> = {};\n  const getScope = (id: number) =>\n    scopeLookup[id] ?? (scopeLookup[id] = {} as Scope);\n  const stack: number[] = [];\n  const fakeArray = { push: resume };\n\n  if (initialHydration) {\n    for (let i = 0; i < initialHydration.length; i += 2) {\n      resume(initialHydration[i], initialHydration[i + 1]);\n    }\n  } else {\n    (window as any)[resumeVar] = fakeArray;\n  }\n\n  function resume(\n    scopesFn:\n      | null\n      | ((\n          b: typeof getRegisteredWithScope,\n          s: typeof scopeLookup,\n          ...rest: unknown[]\n        ) => Record<string, Scope>),\n    calls: Array<string | number>,\n  ) {\n    // TODO: Can be refactored/removed when adding runtimeId and componentIdPrefix\n    /**\n     * Necessary for injecting content into an existing document (e.g. microframe)\n     */\n    if (doc.readyState !== \"loading\") {\n      walker.currentNode = doc;\n    }\n\n    if (scopesFn) {\n      const scopes = scopesFn(getRegisteredWithScope, scopeLookup);\n      scopeLookup.$global ||= scopes.$global || {};\n\n      /**\n       * Loop over all the new hydration scopes and see if a previous walk\n       * had to create a dummy scope to store Nodes of interest.\n       * If so merge them and set/replace the scope in the scopeLookup.\n       */\n      for (const scopeIdAsString in scopes) {\n        if (scopeIdAsString === \"$global\") continue;\n        const scopeId = parseInt(scopeIdAsString);\n        const scope = scopes[scopeId];\n        const storedScope = scopeLookup[scopeId];\n        scope.$global = scopes.$global;\n        if (storedScope !== scope) {\n          scopeLookup[scopeId] = Object.assign(scope, storedScope) as Scope;\n        }\n      }\n    }\n\n    while ((currentNode = walker.nextNode() as ChildNode)) {\n      const nodeValue = currentNode.nodeValue!;\n      if (nodeValue.startsWith(runtimeId)) {\n        const token = nodeValue[runtimeLength];\n        const scopeId = parseInt(nodeValue.slice(runtimeLength + 1));\n        const scope = getScope(scopeId);\n        const data = nodeValue.slice(nodeValue.indexOf(\" \") + 1);\n\n        if (token === ResumeSymbol.Node) {\n          scope[data] = currentNode.previousSibling;\n        } else if (token === ResumeSymbol.SectionStart) {\n          stack.push(currentScopeId);\n          currentScopeId = scopeId;\n          scope.___startNode = currentNode;\n        } else if (token === ResumeSymbol.SectionEnd) {\n          scope[data] = currentNode;\n          if (scopeId < currentScopeId) {\n            const currScope = scopeLookup[currentScopeId];\n            const currParent = currentNode.parentNode!;\n            const startNode = currScope.___startNode as Node;\n            if (currParent !== startNode.parentNode) {\n              currParent.prepend(startNode);\n            }\n            currScope.___endNode = currentNode.previousSibling!;\n            currentScopeId = stack.pop()!;\n          }\n        } else if (token === ResumeSymbol.SectionSingleNodesEnd) {\n          scope[\n            MARKO_DEBUG ? data.slice(0, data.indexOf(\" \")) : parseInt(data)\n          ] = currentNode;\n          // https://jsben.ch/dR7uk\n          const childScopeIds = JSON.parse(\n            \"[\" + data.slice(data.indexOf(\" \") + 1) + \"]\",\n          );\n          for (let i = childScopeIds.length - 1; i >= 0; i--) {\n            const childScope = getScope(childScopeIds[i]);\n            // TODO: consider whether the single node optimization\n            // should only apply to elements which means could\n            // use previousElementSibling instead of a while loop\n            while (\n              (currentNode = currentNode.previousSibling!).nodeType ===\n              8 /* Node.COMMENT_NODE */\n            );\n            // TODO: consider only setting ___startNode?\n            childScope.___startNode = childScope.___endNode = currentNode;\n          }\n        }\n      }\n    }\n\n    for (let i = 0; i < calls.length; i += 2) {\n      (registeredObjects.get(calls[i + 1] as string) as RegisteredFn)(\n        scopeLookup[calls[i] as number]!,\n      );\n    }\n  }\n}\n\nexport function registerSubscriber(\n  id: string,\n  signal: IntersectionSignal,\n  // ownerValueAccessor: string | number,\n  // getOwnerScope = (scope: Scope) => scope._!\n) {\n  register(id, signal.___subscribe!);\n  return signal;\n\n  // TODO: we need to handle the async case - DO NOT REMOVE UNTIL WE DO\n  // const ownerMarkAccessor = ownerValueAccessor + AccessorChars.MARK;\n  // const ownerSubscribersAccessor =\n  //   ownerValueAccessor + AccessorChars.SUBSCRIBERS;\n\n  // register(id, (subscriberScope: Scope) => {\n  //   const ownerScope = getOwnerScope(subscriberScope);\n  //   const boundSignal = bindFunction(subscriberScope, signal);\n  //   const ownerMark = ownerScope[ownerMarkAccessor];\n  //   (ownerScope[ownerSubscribersAccessor] ??= new Set()).add(boundSignal);\n\n  //   // TODO: if the mark is not undefined, it means the value was updated clientside\n  //   // before this subscriber was flushed.\n  //   if (ownerMark === 0) {\n  //     // the value has finished updating\n  //     // we should trigger an update to `signal`\n  //   } else if (ownerMark >= 1) {\n  //     // the value is queued for update\n  //     // we should mark `signal` and let it be updated when the owner is updated\n  //   }\n  // });\n}\n","import { run } from \"./queue\";\n\nconst port2 = /* @__PURE__ */ (() => {\n  const { port1, port2 } = new MessageChannel();\n  port1.onmessage = () => {\n    isScheduled = false;\n    run();\n  };\n  return port2;\n})();\n\nexport let isScheduled: boolean;\n\nexport function schedule() {\n  if (!isScheduled) {\n    isScheduled = true;\n    queueMicrotask(flushAndWaitFrame);\n  }\n}\n\nfunction flushAndWaitFrame() {\n  run();\n  requestAnimationFrame(triggerMacroTask);\n}\n\nfunction triggerMacroTask() {\n  port2.postMessage(0);\n}\n","import type { Scope } from \"../common/types\";\nimport { schedule } from \"./schedule\";\nimport type { ValueSignal } from \"./signals\";\n\nconst enum BatchOffset {\n  Scope = 0,\n  Signal = 1,\n  Value = 2,\n  Total = 3,\n}\n\nconst enum EffectOffset {\n  Scope = 0,\n  Function = 1,\n  Total = 2,\n}\n\ntype ExecFn<S extends Scope = Scope> = (scope: S, arg?: any) => void;\n\nlet currentBatch: unknown[] = [];\nlet currentEffects: unknown[] = [];\n\nexport function queueSource<T>(scope: Scope, signal: ValueSignal, value: T) {\n  schedule();\n  signal(scope, 0, 1);\n  currentBatch.push(scope, signal, value);\n  return value;\n}\n\nexport function queueEffect<S extends Scope, T extends ExecFn<S>>(\n  scope: S,\n  fn: T,\n) {\n  currentEffects.push(scope, fn);\n}\n\nexport function run() {\n  try {\n    runBatch();\n  } finally {\n    currentBatch = [];\n  }\n  try {\n    runEffects();\n  } finally {\n    currentEffects = [];\n  }\n}\n\nexport function runSync(fn: () => void) {\n  const prevBatch = currentBatch;\n  const prevEffects = currentEffects;\n  currentBatch = [];\n  currentEffects = [];\n  try {\n    fn();\n    runBatch();\n    currentBatch = prevBatch;\n    runEffects();\n  } finally {\n    currentBatch = prevBatch;\n    currentEffects = prevEffects;\n  }\n}\n\nexport function prepare(fn: () => void) {\n  const prevBatch = currentBatch;\n  const prevEffects = currentEffects;\n  const preparedEffects = (currentEffects = []);\n  currentBatch = [];\n  try {\n    fn();\n    runBatch();\n  } finally {\n    currentBatch = prevBatch;\n    currentEffects = prevEffects;\n  }\n  return preparedEffects;\n}\n\nexport function runEffects(effects: unknown[] = currentEffects) {\n  for (let i = 0; i < effects.length; i += EffectOffset.Total) {\n    const scope = effects[i] as Scope;\n    const fn = effects[i + 1] as (scope: Scope) => void;\n    fn(scope);\n  }\n}\n\nfunction runBatch() {\n  for (let i = 0; i < currentBatch.length; i += BatchOffset.Total) {\n    const scope = currentBatch[i + BatchOffset.Scope] as Scope;\n    const signal = currentBatch[i + BatchOffset.Signal] as ValueSignal;\n    const value = currentBatch[i + BatchOffset.Value] as unknown;\n    signal(scope, value);\n  }\n}\n","import type {\n  Template,\n  Input,\n  TemplateInstance,\n  Scope,\n  RenderResult,\n} from \"../common/types\";\nimport { prepare, runEffects, runSync } from \"./queue\";\nimport { type Renderer, initRenderer } from \"./renderer\";\nimport { register } from \"./resume\";\nimport { createScope, removeAndDestroyScope } from \"./scope\";\n\nexport const createTemplate = (renderer: Renderer, templateId?: string) =>\n  register(templateId!, new ClientTemplate(renderer));\n\nexport class ClientTemplate implements Template {\n  public _: Renderer;\n\n  constructor(renderer: Renderer) {\n    this._ = renderer;\n  }\n\n  mount(\n    templateInput: Input & { $global?: Record<string, unknown> } = {},\n    reference: ParentNode & Node,\n    position?: InsertPosition,\n  ): TemplateInstance {\n    let scope!: Scope, dom!: Node;\n    const { $global = {}, ...input } = templateInput;\n    const args = this._.___args;\n    const effects = prepare(() => {\n      scope = createScope($global);\n      dom = initRenderer(this._, scope);\n      if (args) {\n        args(scope, [input]);\n      }\n    });\n\n    /*\n      <!-- beforebegin -->\n      <reference>\n        <!-- afterbegin -->\n        foo\n        <!-- beforeend -->\n      </reference>\n      <!-- afterend -->\n    */\n\n    switch (position) {\n      case \"afterbegin\":\n        reference.insertBefore(dom, reference.firstChild);\n        break;\n      case \"afterend\":\n        reference.parentElement!.insertBefore(dom, reference.nextSibling);\n        break;\n      case \"beforebegin\":\n        reference.parentElement!.insertBefore(dom, reference);\n        break;\n      default:\n        reference.appendChild(dom);\n        break;\n    }\n\n    runEffects(effects);\n\n    return {\n      update: (newInput: unknown) => {\n        if (args) {\n          runSync(() => {\n            args(scope, null, 1);\n            args(scope, [newInput]);\n          });\n        }\n      },\n      destroy: () => {\n        removeAndDestroyScope(scope);\n      },\n    };\n  }\n\n  render(): RenderResult {\n    throw new Error(\n      `render() is not implemented for the DOM compilation of a Marko template`,\n    );\n  }\n}\n","\"use strict\";\n\nvar ownerInput;\n\nexports.r = function repeatedAttrTag(targetProperty, attrTagInput) {\n  var prev = ownerInput[targetProperty];\n  if (prev) {\n    prev.push(attrTagInput);\n  } else {\n    ownerInput[targetProperty] = [attrTagInput];\n  }\n};\nexports.a = function repeatableAttrTag(targetProperty, attrTagInput) {\n  var prev = ownerInput[targetProperty];\n  if (prev) {\n    if (Array.isArray(prev)) {\n      prev.push(attrTagInput);\n    } else {\n      ownerInput[targetProperty] = [prev, attrTagInput];\n    }\n  } else {\n    attrTagInput[Symbol.iterator] = selfIterator;\n    ownerInput[targetProperty] = attrTagInput;\n  }\n};\n\nexports.i = function attrTagInput(render, input) {\n  var prevOwnerInput = ownerInput;\n  ownerInput = input || {};\n  try {\n    var renderBody = render();\n    if (renderBody) {\n      ownerInput.renderBody = renderBody;\n    }\n    return ownerInput;\n  } finally {\n    ownerInput = prevOwnerInput;\n  }\n};\n\nfunction* selfIterator() {\n  yield this;\n}","\"use strict\";const { _i_ } = require(\"@internal/components-util\");\nconst { R_ } = require(\"../components/ComponentsContext\");\n\nconst {\n  prepare,\n  runEffects,\n  patchConditionals,\n  createScopeWithRenderer,\n  queueEffect,\n  scopeLookup,\n  getRegisteredWithScope,\n  register\n} = require(\n  // eslint-disable-next-line no-constant-condition\n  \"@marko/runtime-tags/dom\"\n);\nconst defineComponent = require(\"../components/defineComponent\");\nconst { r: registerComponent } = require(\"../components/registry\");\nconst createRenderer = require(\"../components/renderer\");\nconst defaultCreateOut = require(\"../createOut\");\nconst morphdom = require(\"../vdom/morphdom\");\nconst { _h_ } = require(\"../vdom/morphdom/fragment\");\nconst dynamicTag = require(\"./dynamic-tag\");\n\ndynamicTag.bk_ = function tagsToVdom(\ntagsRenderer,\nrenderBody,\nargs)\n{\n  if (\n  tagsRenderer ?\n  tagsRenderer.bl_ === undefined :\n  !Array.isArray(renderBody) && renderBody?.bl_ === undefined)\n\n  return tagsRenderer;\n\n  return (input, out) =>\n  TagsCompat({ i: args ? args : input, r: tagsRenderer || renderBody }, out);\n};\n\nconst TagsCompatId = \"tags-compat\";\nconst TagsCompat = createRenderer(\n  function (_, out, componentDef, component) {\n    let existing = false;\n    const isHydrate =\n    R_(out).o_._W_;\n    const input = Array.isArray(_.i) ? _.i : [_.i];\n    const tagsRenderer = resolveRegistered(_.r);\n    const args = tagsRenderer.bm_;\n\n    component.effects = prepare(() => {\n      if (isHydrate) {\n        const scopeId = out.global.componentIdToScopeId[component.id];\n        component.scope = scopeLookup[scopeId];\n      }\n      if (!component.scope) {\n        component.scope = createScopeWithRenderer(\n          tagsRenderer /* out.global as context */\n        );\n        for (const signal of tagsRenderer.bn_) {\n          signal(component.scope, true);\n        }\n      } else {\n        args && args(component.scope, input, 1);\n        existing = true;\n      }\n      args && args(component.scope, input);\n    });\n    out.bf(out._Y_, component, existing);\n    if (!existing) {\n      out.node({\n        bo_: () =>\n        component.scope.bp_ === component.scope.bq_ ?\n        component.scope.bp_ :\n        component.scope.bp_.parentNode\n      });\n    }\n    out.ef();\n  },\n  // eslint-disable-next-line no-constant-condition\n\n\n\n\n\n  {\n    t: TagsCompatId\n  },\n  {}\n);\n\nregisterComponent(TagsCompatId, () => ({\n  _: TagsCompat,\n  Component: defineComponent(\n    {\n      onMount() {\n        runEffects(this.effects);\n      },\n      onUpdate() {\n        runEffects(this.effects);\n      }\n    },\n    TagsCompat\n  )\n}));\n\n// (\n//   nodeAccessor: Accessor,\n//   dynamicTagAttrs?: IntersectionSignal,\n//   intersection?: IntersectionSignal,\n//   valueWithIntersection?: ValueSignal\n// )\n\nconst rendererCache = new WeakMap();\n\npatchConditionals((conditional) => (...args) => {\n  const signal = conditional(...args);\n  const hasAttrs = args.length > 1;\n  return (scope, renderer, clean) => {\n    return signal(scope, create5to6Renderer(renderer, hasAttrs), clean);\n  };\n});\n\nfunction create5to6Renderer(renderer, hasAttrs) {\n  let newRenderer = renderer;\n  if (renderer) {\n    const rendererFromAnywhere =\n    renderer._ ||\n    renderer.render ||\n    renderer.renderer && renderer.renderer.renderer ||\n    renderer.renderer;\n    const isMarko6 = rendererFromAnywhere ?\n    rendererFromAnywhere.bl_ :\n    renderer.bl_;\n\n    if (typeof renderer !== \"string\" && !isMarko6) {\n      newRenderer = rendererCache.get(renderer);\n      if (!newRenderer) {\n        const { Component } = renderer;\n        if (Component) {\n          const setCustomEvents = Component.prototype.aB_;\n          Component.prototype.aB_ = function (\n          customEvents,\n          scopeId)\n          {\n            for (const customEvent of customEvents) {\n              customEvent[1] = resolveRegistered(customEvent[1]);\n            }\n\n            setCustomEvents.call(this, customEvents, scopeId);\n          };\n        }\n        newRenderer = {\n          br_(scope) {\n            if (!hasAttrs) {\n              renderAndMorph(scope, rendererFromAnywhere, renderer, {});\n            }\n          },\n          bl_() {\n            const realFragment = document.createDocumentFragment();\n            _h_(null, null, realFragment);\n            return realFragment;\n          },\n          bs_: 1,\n          bm_(scope, input, clean) {\n            if (clean) return;\n            renderAndMorph(scope, rendererFromAnywhere, renderer, input);\n          }\n        };\n        rendererCache.set(renderer, newRenderer);\n      }\n    }\n  }\n  return newRenderer;\n}\n\nregister(\"@marko/tags-compat-5-to-6\", create5to6Renderer);\n\nfunction renderAndMorph(scope, renderer, renderBody, input) {\n  const out = defaultCreateOut();\n  let rootNode = scope.bp_.fragment;\n  if (!rootNode) {\n    const component = scope.marko5Component = _i_[scope.m5c];\n    rootNode = component._A_;\n    scope.bp_ = rootNode.startNode;\n    scope.bq_ = rootNode.endNode;\n  }\n  const host = scope.bp_;\n  const existingComponent = scope.marko5Component;\n  const componentsContext = R_(out);\n  const globalComponentsContext = componentsContext.o_;\n  let customEvents;\n  globalComponentsContext.ax_ = existingComponent;\n  out.sync();\n  if (renderer) {\n    const [rawInput] = input;\n    const normalizedInput = {};\n\n    for (const key in rawInput) {\n      let value = rawInput[key];\n      if (key.startsWith(\"on\")) {\n        const c = key[2];\n        customEvents = customEvents || {};\n        customEvents[(c === \"-\" ? \"\" : c.toLowerCase()) + key.slice(3)] = [\n        value];\n\n      } else {\n        normalizedInput[key] = rawInput[key];\n      }\n    }\n\n    renderer(normalizedInput, out);\n  } else {\n    RenderBodyComponent({ renderBody, args: input }, out);\n  }\n\n  queueEffect(scope, () => {\n    const targetNode = out.af_().ay_;\n    morphdom(rootNode, targetNode, host, componentsContext);\n    const componentDefs = componentsContext.ad_(\n      getRootNode(host)\n    );\n    const component = componentDefs[0].r_;\n    component._A_ = rootNode;\n    component.N_ = input[0];\n    component.U_ = customEvents;\n    scope.marko5Component = component;\n  });\n}\n\nfunction getRootNode(el) {\n  var cur = el;\n  while (cur.parentNode) cur = cur.parentNode;\n  return cur;\n}\n\nconst RenderBodyComponentId = \"renderbody-renderer\";\nconst RenderBodyComponent = createRenderer(\n  function (input, out, _componentDef) {\n    dynamicTag(\n      out,\n      input.renderBody,\n      null,\n      null,\n      input.args,\n      null,\n      _componentDef,\n      \"0\"\n    );\n  },\n  // eslint-disable-next-line no-constant-condition\n\n\n\n\n\n\n  {\n    t: RenderBodyComponentId,\n    i: true\n  },\n  {}\n);\n\nregisterComponent(RenderBodyComponentId, () => ({\n  _: RenderBodyComponent,\n  Component: defineComponent({}, RenderBodyComponent)\n}));\n\nfunction resolveRegistered(renderer) {\n  if (!Array.isArray(renderer)) return renderer;\n\n  const [registerId, scopeId] = renderer;\n  const scope = scopeLookup[scopeId];\n  return getRegisteredWithScope(registerId, scope);\n}","// src/translate/track-rendering/index.ts\nvar rendering = 0;\nfunction begin() {\n  rendering++;\n}\nfunction end() {\n  rendering--;\n}\nfunction isRendering() {\n  return rendering > 0;\n}\n\nexport {\n  begin,\n  end,\n  isRendering\n};\n","// src/util/patch-lifecycle.ts\nvar extensionsKey = Symbol();\nfunction patch_lifecycle_default(component, methods) {\n  const proto = component.__proto__;\n  const extensions = proto[extensionsKey];\n  if (extensions) {\n    if (!extensions.has(methods)) {\n      extensions.add(methods);\n      addMethods(proto, methods);\n      return true;\n    }\n  } else {\n    proto[extensionsKey] = /* @__PURE__ */ new Set([methods]);\n    addMethods(proto, methods);\n    return true;\n  }\n  return false;\n}\nfunction addMethods(proto, methods) {\n  for (const name in methods) {\n    proto[name] = callBoth(proto[name], methods[name]);\n  }\n}\nfunction callBoth(a, b) {\n  if (a) {\n    return function() {\n      a.call(this);\n      b.call(this);\n    };\n  }\n  return b;\n}\n\nexport {\n  patch_lifecycle_default\n};\n","import {\n  patch_lifecycle_default\n} from \"../../chunk-G2QGH4BR.mjs\";\n\n// src/components/effect/index.ts\nvar metaKey = Symbol();\nvar indexKey = Symbol();\nvar lifecycleMethods = {\n  onMount: runEffects,\n  onUpdate: runEffects,\n  onDestroy: runCleanups\n};\nfunction effect_default(component, fn) {\n  const meta = component[metaKey];\n  const index = component[indexKey];\n  if (meta) {\n    if (index === void 0) {\n      meta.push(1, fn, 0);\n    } else {\n      component[indexKey] += 3;\n      if (meta[index + 1] !== fn) {\n        const cleanup = meta[index + 2];\n        meta[index] = 1;\n        meta[index + 1] = fn;\n        if (cleanup) {\n          cleanup();\n          meta[index + 2] = 0;\n        }\n      }\n    }\n  } else {\n    patch_lifecycle_default(component, lifecycleMethods);\n    component[metaKey] = [1, fn, 0];\n  }\n}\nfunction runEffects() {\n  const meta = this[metaKey];\n  if (meta) {\n    this[indexKey] = 0;\n    for (let i = 0; i < meta.length; i += 3) {\n      if (meta[i]) {\n        const fn = meta[i + 1];\n        meta[i] = 0;\n        if (fn) {\n          meta[i + 2] = fn();\n        }\n      }\n    }\n  }\n}\nfunction runCleanups() {\n  const meta = this[metaKey];\n  if (meta) {\n    for (let i = 2; i < meta.length; i += 3) {\n      const cleanup = meta[i];\n      cleanup && cleanup();\n    }\n  }\n}\nexport {\n  effect_default as default\n};\n","import {\n  patch_lifecycle_default\n} from \"../../chunk-G2QGH4BR.mjs\";\n\n// src/components/lifecycle/index.ts\nvar metaKey = Symbol();\nvar indexKey = Symbol();\nvar lifecycleMethods = {\n  onMount: runMount,\n  onUpdate: runUpdate,\n  onDestroy: runDestroy\n};\nfunction lifecycle_default(component, cur = {}) {\n  const meta = component[metaKey];\n  const index = component[indexKey];\n  if (meta) {\n    if (index === void 0) {\n      meta.push(0, cur);\n    } else {\n      component[indexKey] += 2;\n      const prev = meta[index + 1];\n      prev.onMount = cur.onMount;\n      prev.onDestroy = cur.onDestroy;\n      if (prev.onUpdate !== cur.onUpdate) {\n        meta[index] = 1;\n        prev.onUpdate = cur.onUpdate;\n      }\n    }\n  } else {\n    patch_lifecycle_default(component, lifecycleMethods);\n    component[metaKey] = [0, cur];\n  }\n}\nfunction runMount() {\n  const meta = this[metaKey];\n  if (meta) {\n    this[indexKey] = 0;\n    for (let i = 1; i < meta.length; i += 2) {\n      const handlers = meta[i];\n      if (handlers.onMount) {\n        handlers.onMount();\n      }\n    }\n  }\n}\nfunction runUpdate() {\n  const meta = this[metaKey];\n  if (meta) {\n    this[indexKey] = 0;\n    for (let i = 0; i < meta.length; i += 2) {\n      if (meta[i]) {\n        meta[i] = 0;\n        const handlers = meta[i + 1];\n        if (handlers.onUpdate) {\n          handlers.onUpdate();\n        }\n      }\n    }\n  }\n}\nfunction runDestroy() {\n  const meta = this[metaKey];\n  if (meta) {\n    for (let i = 1; i < meta.length; i += 2) {\n      const handlers = meta[i];\n      if (handlers.onDestroy) {\n        handlers.onDestroy();\n      }\n    }\n  }\n}\nexport {\n  lifecycle_default as default\n};\n","import {\n  patch_lifecycle_default\n} from \"../../chunk-G2QGH4BR.mjs\";\n\n// src/components/return/index-browser.ts\nvar metaKey = Symbol();\nvar indexKey = Symbol();\nvar lifecycleMethods = {\n  onMount: resetIndex,\n  onUpdate: resetIndex\n};\nfunction getReturn(component) {\n  const meta = component[metaKey];\n  const index = component[indexKey];\n  let val;\n  if (meta) {\n    if (index === void 0) {\n      meta.push(val = createReturn(component));\n    } else {\n      val = meta[component[indexKey]++];\n    }\n  } else {\n    patch_lifecycle_default(component, lifecycleMethods);\n    component[metaKey] = [val = createReturn(component)];\n  }\n  return val;\n}\nfunction resetIndex() {\n  this[indexKey] = 0;\n}\nfunction createReturn(component) {\n  let curValue;\n  return function(newVal, write) {\n    if (write) {\n      if (curValue && (curValue.value !== newVal.value || curValue.valueChange !== newVal.valueChange)) {\n        component.forceUpdate();\n      }\n      return curValue = newVal;\n    }\n    return curValue;\n  };\n}\nexport {\n  getReturn as default\n};\n","import {\n  patch_lifecycle_default\n} from \"../../chunk-G2QGH4BR.mjs\";\n\n// src/transform/cached-values/index-browser.ts\nvar metaKey = Symbol();\nvar indexKey = Symbol();\nvar curComponent;\nvar isCached = false;\nvar lifecycleMethods = {\n  onMount: resetIndex,\n  onUpdate: resetIndex\n};\nfunction cached(component, cur) {\n  const meta = component[metaKey];\n  const index = component[indexKey];\n  curComponent = component;\n  if (meta) {\n    if (index === void 0) {\n      meta.push(cur);\n      return false;\n    }\n    const prev = meta[index];\n    component[indexKey] += 2;\n    for (let i = prev.length; i--; ) {\n      if (prev[i] !== cur[i]) {\n        meta[index] = cur;\n        return false;\n      }\n    }\n    return isCached = true;\n  }\n  patch_lifecycle_default(component, lifecycleMethods);\n  component[metaKey] = [cur];\n  return false;\n}\nfunction cache(val) {\n  const meta = curComponent[metaKey];\n  const index = curComponent[indexKey];\n  curComponent = void 0;\n  if (isCached) {\n    isCached = false;\n    return index === void 0 ? meta[meta.length - 1] : meta[index - 1];\n  }\n  if (index == void 0) {\n    meta.push(val);\n  } else {\n    meta[index - 1] = val;\n  }\n  return val;\n}\nfunction resetIndex() {\n  this[indexKey] = 0;\n}\nexport {\n  cache,\n  cached\n};\n","import {\n  isRendering\n} from \"../../chunk-5R2Z7TR6.mjs\";\n\n// src/transform/native-tag-var/index-browser.ts\nfunction createElGetter(owner, key) {\n  return owner[key] || (owner[key] = () => {\n    if (isRendering()) {\n      throw new Error(\"Cannot read an element reference while rendering.\");\n    }\n    return owner.getEl(key);\n  });\n}\nexport {\n  createElGetter as default\n};\n","// src/translate/native-tag-handlers/index-browser.ts\nvar eventNameReg = /^on[A-Z]/;\nvar changeNameReg = /Change$/;\nvar bindsByTag = {};\nregisterBind(\"input\", \"value\");\nregisterBind(\"input\", \"checked\");\nregisterBind(\"textarea\", \"value\");\nvar index_browser_default = (attrs, def, tag, meta) => {\n  const binds = bindsByTag[tag];\n  const resultAttrs = {};\n  for (const key in attrs) {\n    const val = attrs[key];\n    if (eventNameReg.test(key)) {\n      if (val) {\n        const eventName = key.toLowerCase();\n        meta[eventName] = def.d(eventName.slice(2), val, false);\n      }\n    } else if (!((binds == null ? void 0 : binds[key]) || changeNameReg.test(key))) {\n      resultAttrs[key] = val;\n    }\n  }\n  if (binds) {\n    for (const key in binds) {\n      const handler = attrs[`${key}Change`];\n      resultAttrs[key] = attrs[key];\n      if (handler) {\n        meta.oninput = def.d(\"input\", binds[key](handler), false);\n      } else {\n        (meta.pa || (meta.pa = [])).push(key);\n      }\n    }\n  }\n  return resultAttrs;\n};\nfunction registerBind(tag, prop) {\n  bindsByTag[tag] = bindsByTag[tag] || {};\n  bindsByTag[tag][prop] = (change) => (e) => change(e.target[prop]);\n}\nexport {\n  index_browser_default as default\n};\n","// src/util/replace-assignments/index.ts\nfunction assign(fn, value) {\n  if (fn) {\n    fn(value);\n    return value;\n  }\n  throw new TypeError(\"Assignment to constant variable.\");\n}\nexport {\n  assign as default\n};\n"],"names":["onCreate","this","state","_marko_template","_","_marko_renderer","input","out","_componentDef","_component","$global","componentDef","renderBody","t","_marko_componentType","_marko_component","Component","_marko_defineComponent","dom_exports","createScope","scope","__export","attr","attrs","bindFunction","bindRenderer","childClosures","classAttr","closure","conditional","conditionalOnlyChild","createRenderer","createScopeWithRenderer","createTemplate","data","dynamicClosure","dynamicSubscribers","dynamicTagAttrs","getAbortSignal","getRegisteredWithScope","html","inChild","inConditionalScope","inLoopScope","init","initValue","intersection","intersections","lifecycle","loopIn","loopOf","loopTo","nextTagId","on","patchConditionals","prepare","props","queueEffect","queueSource","register","registerSubscriber","resetAbortSignal","run","runEffects","scopeLookup","setTagVar","styleAttr","tagVarSignal","value","values","write","module","exports","emptyScope","getEmptyScope","marker","a","c","localIndex","value2","binder","bind","h","Map","bound","get","set","ownerScope","renderer","i","boundScope","fn","length","args","call","destroyScope","_destroyScope","f","delete","closureSignals","p","b","signal","g","cleanup","instance","controllers","j","ctrl","abort","removeAndDestroyScope","current","stop","nextSibling","next","remove","insertBefore","parent","WRONG_POS","stringifyClassObject","name","isVoid","NON_DIMENSIONAL","stringifyStyleObject","test","toDelimitedString","val","delimiter","stringify","result","curDelimiter","Array","isArray","v","part","id","controller","parentScope","has","Set","add","onDestroy","AbortController","element","normalizedValue","normalizeAttrValue","removeAttribute","setAttribute","classValue","styleValue","node","normalizeString","elementAccessor","nextAttrs","prevAttrs","parser","document","createElement","index","firstChild","lastChild","parentNode","afterReference","innerHTML","newContent","content","nodeIndex","nextProps","prevProps","thisObj","Object","assign","onUpdate","onMount","onabort","walker","createTreeWalker","trimWalkString","walkString","end","charCodeAt","slice","walk","startNode","walkCodes","currentNode","walkInternal","documentElement","currentWalkIndex","storedMultiplier","currentMultiplier","currentScopeIndex","nextNode","newNode","createTextNode","replaceChild","newScope","initRenderer","e","dom","q","nodeType","k","l","nodeAccessor","inputIsArgs","getAttrs","clean","d","childScope","setConditionalRendererOnlyChild","attributes","template","walks","setup","hasUserEffects","m","_clone","r","n","sourceNode","ensureFragment","parser2","doc2","createDocumentFragment","appendChild","parse","cloneNode","valueAccessor","markAccessor","nextValue","render","intersection2","valueWithIntersection","creation","currentMark","accessorId","count","cleanAccessor","defaultGetOwnerScope","ownerValueAccessor","_getOwnerScope","getOwnerScope","getOwnerValueAccessor","ownerValueAccessor2","ownerMark","ownerHasRun","o","signalFn","providerSubscriptionsAccessor","childAccessor","closureSignal","subscribersAccessor","subscribers","subscriber","tagVarSignal2","renderBodyClosures","signals","tagId","dynamicTagAttrs2","rendererAccessor","childScopeAccessor","newRenderer","currentRenderer","prevScope","setConditionalRenderer","scopeAccessor","conditionalScope","conditionalRenderer","action","referenceNode","textContent","emptyMarkerMap","Symbol","emptyMarkerArray","emptyMap","emptyArray","loop","cb","all","getKey","keyBySecondArg","item","keyByFirstArg","key","to","from","step","steps","forEach","loopScopeAccessor","params","newMap","newArray","referenceIsMarker","oldMap","oldArray","needsReconciliation","isNew","push","oldLastChild","oldScopes","newScopes","oldScope","oldStart","newStart","oldEnd","newEnd","oldStartScope","newStartScope","oldEndScope","newEndScope","outer","oldLength","newLength","aNullable","sources","pos","synced","keyIndex","seq","u","il","longestIncreasingSubsequence","reconcile","loopNodeAccessor","loopScopes","scope2","_item","elementHandlersByEvent","delegatedEventsByRoot","WeakMap","eventOpts","capture","type","handler","handlersByElement","root","getRootNode","delegatedEvents","addEventListener","handleDelegated","ensureDelegated","ev","target","bubbles","parentElement","cancelBubble","registeredObjects","doc3","obj","registryId","runtimeId","currentScopeId","runtimeLength","resumeVar","initialHydration","window","walker2","getScope","stack","fakeArray","resume","scopesFn","calls","readyState","scopes","scopeIdAsString","scopeId","parseInt","storedScope","nodeValue","startsWith","token","data2","indexOf","previousSibling","currScope","currParent","prepend","pop","childScopeIds","JSON","isScheduled","port2","port1","port22","MessageChannel","onmessage","flushAndWaitFrame","requestAnimationFrame","triggerMacroTask","postMessage","currentBatch","currentEffects","queueMicrotask","runBatch","prevBatch","prevEffects","preparedEffects","effects","templateId","ClientTemplate","constructor","mount","templateInput","reference","position","update","newInput","runSync","destroy","Error","ownerInput","selfIterator","targetProperty","attrTagInput","prev","iterator","prevOwnerInput","_i_","require","R_","defineComponent","registerComponent","defaultCreateOut","morphdom","_h_","dynamicTag","bk_","tagsRenderer","undefined","bl_","TagsCompat","TagsCompatId","component","existing","isHydrate","o_","_W_","resolveRegistered","bm_","global","componentIdToScopeId","bn_","bf","_Y_","bo_","bp_","bq_","ef","rendererCache","create5to6Renderer","hasAttrs","rendererFromAnywhere","isMarko6","setCustomEvents","prototype","aB_","customEvents","customEvent","br_","renderAndMorph","realFragment","bs_","rootNode","fragment","marko5Component","m5c","_A_","endNode","host","existingComponent","componentsContext","ax_","sync","rawInput","normalizedInput","toLowerCase","RenderBodyComponent","targetNode","af_","ay_","ad_","el","cur","r_","N_","U_","RenderBodyComponentId","registerId","rendering","begin","isRendering","extensionsKey","patch_lifecycle_default","methods","proto","__proto__","extensions","addMethods","callBoth","metaKey","indexKey","lifecycleMethods","meta","effect_default","handlers","lifecycle_default","resetIndex","getReturn","createReturn","curValue","newVal","valueChange","forceUpdate","curComponent","isCached","cached","cache","createElGetter","owner","getEl","eventNameReg","changeNameReg","bindsByTag","registerBind","index_browser_default","def","tag","binds","resultAttrs","eventName","oninput","pa","prop","change","TypeError"],"sourceRoot":""}