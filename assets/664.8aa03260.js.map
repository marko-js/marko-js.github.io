{"version":3,"file":"664.8aa03260.js","mappings":"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","sources":["webpack:///../../browser-shims/v6/ sync","webpack:///../components/repl/components/file-tabs.marko","webpack:///../components/repl/components/pane.marko","webpack:///../components/repl/components/controllable-select.marko","webpack:///../components/repl/components/playground-link.marko","webpack:///../components/repl/components/match-media.marko","webpack:///../components/repl/components/resizable-panes.marko","webpack:///../components/repl/index.marko","webpack:///./playground/components/hash-value.marko","webpack:///../../browser-shims/v6/translator.js","webpack:///./playground/v6/components/playground-6.marko","webpack:///./playground/v6/index.marko","webpack:///../../browser-shims/compiler/dist/babel-types/index.js","webpack:///../../browser-shims/compiler/index.js","webpack:///../../browser-shims/fs.js","webpack:///../../browser-shims/module.js","webpack:///../../browser-shims/process.js","webpack:///../components/app-layout/components/layout-header/component-browser.js","webpack:///../components/app-layout/components/layout-header/events.js","webpack:///../components/app-layout/components/layout-sidebar/component-browser.js","webpack:///../components/app-layout/components/layout-sidebar/components/version-switcher/component-browser.js","webpack:///../components/app-footer/ebay.svg","webpack:///../components/app-footer/openjsf.svg","webpack:///../components/app-footer/osi.svg","webpack:///../components/app-layout/favicon.png","webpack:///../logos/discord.svg","webpack:///../logos/marko.svg"],"sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"../../browser-shims/v6 sync recursive\";\nmodule.exports = webpackEmptyContext;","<attrs/{ files: externalFiles, selectedIndex: externalSelected }/>\n\n<let/files := externalFiles/>\n<let/selectedIndex := externalSelected/>\n\n<const/selectedFile = files[selectedIndex]/>\n\n<div.file-tabs>\n  <let/nextId = 1/>\n  <for|file, index| of=files>\n    <let/editing = false/>\n    <const/selected = selectedFile === file/>\n    <const/mutable = (index > 0)/>\n    <div.file-tab class={ selected } onClick() { \n      if (selected) {\n        editing = true;\n      } else {\n        editing = false;\n        selectedIndex = index;\n      }\n    }>\n      <if=(!editing || !selected || !mutable)>\n        ${file.name}\n      </if>\n      <else>\n        <let/name = file.name/>\n        <const/finishRename() {\n          const modifiedFile = { ...file, name, path: file.path.replace(file.name, name) };\n          files = [\n            ...files.slice(0, index), \n            modifiedFile,\n            ...files.slice(index+1)\n          ];\n          editing = false;\n        }/>\n        <input/nameInput \n          type=\"text\" \n          size=name.length \n          value:=name \n          onBlur=finishRename\n          onKeydown(e) {\n            if (e.code === \"Enter\") {\n              finishRename();\n            }\n          }/>\n        <lifecycle onMount() { \n          nameInput().focus();\n          nameInput().setSelectionRange(0, name.indexOf(\".\"));\n        }/>\n      </else>\n      <if=mutable>\n        <button.file-close onClick(e) { \n          if (window.confirm(`Delete ${file.path}?`)) {\n            if (selectedIndex >= index) {\n              selectedIndex--;\n            }\n            files = [...files.slice(0, index), ...files.slice(index+1)];\n          }\n          e.stopPropagation();\n        }>\n          &times;\n        </button>\n      </if>\n    </div>\n  </for>\n  <button.new-file onClick() { \n    const newFile = { name:`Component${nextId}.marko`, path:`/components/Component${nextId}.marko`, content:\"\" };\n    const newIndex = files.length;\n    files = files.concat(newFile);\n    selectedIndex = newIndex;\n    nextId++;\n  }>\n    +\n  </button>\n</div>\n<style>\n  .file-tabs {\n    display:flex;\n    overflow-x: auto;\n    width:100%;\n    height:100%;\n  }\n  .file-tab {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: 100%;\n    padding:0 1em;\n    flex-shrink: 0;\n    border-bottom: 2px solid transparent;\n    cursor:pointer;\n  }\n  .file-tab:not(.selected):hover {\n    background: rgba(255,255,255,0.1);\n  }\n  .file-tab.selected {\n    border-bottom: 2px solid #09bcf8;\n  }\n  .file-close {\n    padding:0.5em;\n    background: transparent;\n    margin-right:-0.5em;\n    color:#fff;\n    cursor: pointer;\n    line-height: normal;\n    border: 0;\n  }\n  .file-close:hover {\n    color:#f1195b;\n  }\n  .new-file {\n    padding:0 1em;\n    font-size: 1.5em;\n    background: transparent;\n    color:#999;\n    cursor: pointer;\n    line-height: normal;\n    border: 0;\n  }\n  .new-file:hover {\n    color: #09bcf8;\n  }\n</style>","<attrs/{ actions, body }/>\n\n<div.pane>\n  <div.pane-actions>\n    <${actions.renderBody}/>\n  </div>\n  <div.pane-divider/>\n  <div.pane-body>\n    <${body.renderBody}/>\n  </div>\n</div>\n\n<style>\n  .pane {\n    display:flex;\n    flex-direction: column;\n    flex:1;\n  }\n  .pane-actions {\n    height: 3em;\n  }\n  .pane-divider {\n    height:1px;\n    background: rgba(0,0,0,0.2);\n  }\n  .pane-body {\n    flex:1;\n    flex-basis: 0;\n    overflow: auto;\n  }\n</style>\n","<attrs/{ value, valueChange, renderBody, class:className }/>\n<select/el class=className onChange(e) { valueChange(e.target.value); }>\n  <${renderBody}/>\n</select>\n<effect() {\n  el().value = value;\n  // TODO: this should not be necessary\n  // but re-rendering the parent component causes new closures\n  // to be passed for renderBody and valueChange which causes\n  // this component to re-render.  Morphdom sets the <select>\n  // back to the original value.  So we track those values as well,\n  // so we can re-set the <select>'s value.\n  renderBody; valueChange;\n}/>","import { compressToEncodedURIComponent } from \"lz-string\";\n\n<attrs/{ files, ...attrs }/>\n<a.playground-link ...attrs\n  href=`/playground/#${compressToEncodedURIComponent(JSON.stringify(files))}`\n  target=\"_top\">\n  <span>Open in playground </span>\n</a>\n\n<style>\n  .playground-link {\n    float:right;\n    padding: 0.8em 1em;\n    display:block;\n    position: relative;\n  }\n  .playground-link span {\n    display:none;\n    position:absolute;\n    right: 1em;\n    width: 10em;\n  }\n  .playground-link:hover span {\n    display:inline;\n  }\n</style>\n\n","<attrs/{ default: query, fallback }/>\n<let/isMatch = typeof window !== \"undefined\" ? window.matchMedia(query).matches : fallback/>\n\n<effect() {\n  const mq = window.matchMedia(query);\n  const listener = () => isMatch = !!mq.matches;\n  mq.addEventListener(\"change\", listener);\n  isMatch = !!mq.matches;\n  return () => mq.removeEventListener(\"change\", listener);\n}/>\n\n<return=isMatch/>","<attrs/{ left, right }/>\n\n<let/editorSize=0.5/>\n<let/resizing = false/>\n<match-media/isVertical = \"(max-aspect-ratio: 1/1)\"/>\n\n<div/container class=[\"panes\", resizing && \"resizing\"]>\n  <div ...left style=`flex-grow:${editorSize}`>\n    <${left.renderBody}/>\n  </div>\n  <div.divider>\n    <div.inner\n      onMousedown(e) {\n        resizing = true;\n        e.preventDefault();\n        e.stopPropagation();\n      }/>\n  </div>\n  <div ...right style=`flex-grow:${1-editorSize}`>\n    <${right.renderBody}/>\n  </div>\n</div>\n<if=resizing>\n  <effect() {\n    const handler = (e) => {\n      if (e.buttons || e.which) {\n        const rect = container().getBoundingClientRect();\n        const fraction = isVertical \n          ? (e.clientY - rect.top) / rect.height \n          : (e.clientX - rect.left) / rect.width;\n        if (fraction > 0) {\n          // it seems a drag event with no position is fired when we stop\n          // so we'll ignore that value\n          editorSize = Math.min(0.8, Math.max(0.2, fraction));\n        }\n      } else {\n        resizing = false;\n      }\n    };\n    window.addEventListener(\"mousemove\", handler);\n    return () => window.removeEventListener(\"mousemove\", handler);\n  }/>\n</if>\n\n<style>\n  .panes {\n    display:flex;\n    flex:1;\n    width: 100%;\n  }\n  .panes > div {\n    overflow:hidden;\n    display: flex;\n    flex-basis:0;\n  }\n  .panes.resizing {\n    cursor: col-resize;\n  }\n  .panes.resizing > div:not(.divider) {\n    pointer-events: none;\n  }\n  .divider {\n    min-height: 2px;\n    min-width: 2px;\n    position:relative;\n    background:#eee;\n    cursor: col-resize;\n  }\n  .divider:hover {\n    background:#ccc;\n  }\n  .divider .inner {\n    position: absolute;\n    top:-10px; left: -10px; bottom:-10px; right:-10px;\n    opacity: 0;\n    z-index:1000;\n  }\n  @media (max-aspect-ratio: 1/1) {\n    .panes {\n      flex-direction: column;\n    }\n    .panes.resizing,\n    .divider:hover {\n      cursor: row-resize;\n    }\n  }\n</style>","<attrs/{ getCompilerOptions, files }/>\n<let/selectedIndex = 0/>\n<let/previewType = \"preview\"/>\n<let/debounce = false/>\n<const/selectedFile = files[selectedIndex]/>\n\n<style>\n  .editor-container {\n    background: #202134;\n    color: #fff;\n  }\n</style>\n\n<resizable-panes>\n  <@left class=\"editor-container\">\n    <pane>\n      <@actions>\n        <file-tabs files:=files selectedIndex:=selectedIndex/>\n      </@actions>\n      <@body>\n        <let/activeEditor = null/>\n        <activeEditor\n          value=selectedFile.content \n          filename=selectedFile.path \n          valueChange(content) {\n            const modifiedFile = { ...selectedFile, content };\n            files = [\n              ...files.slice(0, selectedIndex), \n              modifiedFile,\n              ...files.slice(selectedIndex+1)\n            ];\n            debounce = true;\n          }/>\n        <lifecycle onMount = (async () => { \n          const e = await import(\"./components/editor\");\n          await e.loading;\n          activeEditor = e;\n        })/>\n      </@body>\n    </pane>\n  </@left>\n  <@right>\n    <pane>\n      <@actions>\n        <controllable-select.preview-select \n          value=previewType \n          valueChange(value) {\n            previewType = value;\n            debounce = false;\n          }>\n          <option value=\"preview\">App Preview</option>\n          <option value=\"compiled-html\">Compiled (HTML)</option>\n          <option value=\"compiled-vdom\">Compiled (DOM)</option>\n        </controllable-select>\n        <playground-link files=files/>\n        <style>\n          .preview-select {\n            border:0;\n            height:100%;\n            font-size: 100%;\n            padding:0 1em;\n          }\n        </style>\n      </@actions>\n      <@body>\n        <let/preview = null/>\n        <${preview} \n          type=previewType\n          files=files\n          selectedFile=selectedFile\n          getCompilerOptions=getCompilerOptions\n          debounce=debounce/>\n        <lifecycle onMount = (async () => { \n          preview = await import(\"./components/preview\");\n        })/>\n      </@body>\n    </pane>\n  </@right>\n</resizable-panes>","import { compressToEncodedURIComponent, decompressFromEncodedURIComponent } from \"lz-string\";\n\n<attrs/{ default:defaultValue }/>\n<let/value = (\n  (() => { \n    try {\n      if (typeof window !== \"undefined\") {\n        return JSON.parse(decompressFromEncodedURIComponent(window.location.hash.slice(1)));\n      }\n    } catch(e) {\n      console.error(e);\n    }\n  })() \n  || defaultValue\n)/>\n<lifecycle \n  onMount() {\n    window.addEventListener(\"hashchange\", this.handler = () => {\n      try {\n        if (!this.isUpdating) {\n          value = JSON.parse(decompressFromEncodedURIComponent(window.location.hash.slice(1)));\n        } else {\n          this.isUpdating = false;\n        }\n      } catch(e) {\n        console.error(e);\n      }\n    });\n  } \n  onUpdate() {\n    this.isUpdating = true;\n    window.location.hash = compressToEncodedURIComponent(JSON.stringify(value));\n  }\n  onDestroy() {\n    window.removevEventListener(\"hashchange\", this.handler);\n  }/>\n<return:=value/>","var __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\")\n    return require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\n// src/visitors/program/index.ts\nimport { types as t12 } from \"@marko/compiler\";\n\n// src/util/marko-config.ts\nfunction isOutputHTML() {\n  return getMarkoOpts().output === \"html\";\n}\nfunction isOutputDOM() {\n  return !isOutputHTML();\n}\nfunction getMarkoOpts() {\n  return currentProgramPath.hub.file.markoOpts;\n}\nfunction isOptimize() {\n  return getMarkoOpts().optimize;\n}\n\n// src/visitors/program/html.ts\nimport { types as t9 } from \"@marko/compiler\";\n\n// src/util/signals.ts\nimport { types as t8 } from \"@marko/compiler\";\n\n// src/util/tag-name-type.ts\nimport { types as t } from \"@marko/compiler\";\nimport { isNativeTag } from \"@marko/babel-utils\";\nvar MARKO_FILE_REG = /^<.*>$|\\.marko$/;\nfunction analyzeTagNameType(tag) {\n  const extra = tag.node.extra ??= {};\n  if (extra.tagNameType === void 0) {\n    const name = tag.get(\"name\");\n    if (name.isStringLiteral()) {\n      extra.tagNameType = name.node.value[0] === \"@\" ? 3 /* AttributeTag */ : isNativeTag(tag) ? 0 /* NativeTag */ : 1 /* CustomTag */;\n      extra.tagNameNullable = extra.tagNameNullable = false;\n    } else {\n      const pending = [name];\n      let path3;\n      let type = void 0;\n      let nullable = false;\n      while ((path3 = pending.pop()) && type !== 2 /* DynamicTag */) {\n        if (path3.isConditionalExpression()) {\n          pending.push(path3.get(\"consequent\"));\n          if (path3.node.alternate) {\n            pending.push(path3.get(\"alternate\"));\n          }\n        } else if (path3.isLogicalExpression()) {\n          if (path3.node.operator === \"||\") {\n            pending.push(path3.get(\"left\"));\n          } else {\n            nullable = true;\n          }\n          pending.push(path3.get(\"right\"));\n        } else if (path3.isAssignmentExpression()) {\n          pending.push(path3.get(\"right\"));\n        } else if (path3.isBinaryExpression()) {\n          type = path3.node.operator !== \"+\" || type !== void 0 && type !== 0 /* NativeTag */ ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n        } else if (path3.isStringLiteral() || path3.isTemplateLiteral()) {\n          type = type !== void 0 && type !== 0 /* NativeTag */ ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n        } else if (path3.isNullLiteral()) {\n          nullable = true;\n        } else if (path3.isIdentifier()) {\n          if (path3.node.name === \"undefined\") {\n            nullable = true;\n            continue;\n          }\n          const binding = path3.scope.getBinding(path3.node.name);\n          if (!binding) {\n            type = 2 /* DynamicTag */;\n            continue;\n          }\n          if (binding.kind === \"module\") {\n            const decl = binding.path.parent;\n            if (MARKO_FILE_REG.test(decl.source.value) && decl.specifiers.some((it) => t.isImportDefaultSpecifier(it))) {\n              type = type !== void 0 && type !== 1 /* CustomTag */ ? 2 /* DynamicTag */ : 1 /* CustomTag */;\n            } else {\n              type = 2 /* DynamicTag */;\n            }\n            continue;\n          }\n          const bindingTag = binding.path;\n          if (bindingTag.isMarkoTag() && binding.kind === \"local\") {\n            const bindingTagName = bindingTag.get(\"name\").node.value;\n            if (bindingTagName === \"tag\") {\n              type = type !== void 0 && type !== 1 /* CustomTag */ ? 2 /* DynamicTag */ : 1 /* CustomTag */;\n              continue;\n            }\n            if (bindingTagName === \"const\") {\n              pending.push(bindingTag.get(\"attributes\")[0].get(\"value\"));\n              continue;\n            }\n            if (bindingTagName === \"let\") {\n              const defaultAttr = bindingTag.get(\"attributes\")[0];\n              if (defaultAttr.node) {\n                pending.push(defaultAttr.get(\"value\"));\n              } else {\n                nullable = true;\n              }\n              const assignments = binding.constantViolations;\n              for (let i = assignments.length; i--; ) {\n                const assignment = assignments[i];\n                const { operator } = assignment.node;\n                if (operator === \"=\") {\n                  pending.push(assignment.get(\"right\"));\n                } else if (operator === \"+=\") {\n                  type = type !== void 0 && type !== 0 /* NativeTag */ ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n                } else {\n                  type = 2 /* DynamicTag */;\n                  break;\n                }\n              }\n            }\n            continue;\n          }\n          type = 2 /* DynamicTag */;\n        } else {\n          type = 2 /* DynamicTag */;\n        }\n      }\n      extra.tagNameType = isOutputHTML() ? type : 2 /* DynamicTag */;\n      extra.tagNameNullable = nullable;\n      extra.tagNameDynamic = true;\n    }\n    if (extra.tagNameType === void 0) {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n  }\n  return extra.tagNameType;\n}\n\n// src/util/sections.ts\nfunction startSection(path3) {\n  const extra = path3.node.extra ??= {};\n  let sectionId = extra.sectionId;\n  if (sectionId === void 0) {\n    const programExtra = path3.hub.file.path.node.extra ??= {};\n    const sectionNameNode = path3.parent?.name;\n    const sectionName = sectionNameNode?.value ?? sectionNameNode?.name ?? \"dynamic\";\n    sectionId = extra.sectionId = programExtra.nextSectionId || 0;\n    programExtra.nextSectionId = sectionId + 1;\n    programExtra.sectionNames = programExtra.sectionNames ?? [];\n    programExtra.sectionNames[sectionId] = currentProgramPath.scope.generateUid(sectionName + \"Body\");\n  }\n  return sectionId;\n}\nfunction getOrCreateSectionId(path3) {\n  let cur = path3;\n  while (true) {\n    if (cur.type === \"Program\" || cur.type === \"MarkoTagBody\" && analyzeTagNameType(cur.parentPath) !== 0 /* NativeTag */) {\n      return startSection(cur);\n    }\n    cur = cur.parentPath;\n  }\n}\nfunction getSectionId(path3) {\n  let sectionId;\n  let currentPath = path3;\n  while ((sectionId = currentPath.node.extra?.sectionId) === void 0) {\n    currentPath = currentPath.parentPath;\n  }\n  return sectionId;\n}\nfunction createSectionState(key, init) {\n  return [\n    (sectionId) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= [];\n      const sectionData = arrayOfSectionData[sectionId] ??= init && init(sectionId);\n      return sectionData;\n    },\n    (sectionId, value) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= [];\n      arrayOfSectionData[sectionId] = value;\n    }\n  ];\n}\nfunction forEachSectionId(fn) {\n  const { nextSectionId } = currentProgramPath.node.extra;\n  for (let sectionId = 0; sectionId < nextSectionId; sectionId++) {\n    fn(sectionId);\n  }\n}\nfunction forEachSectionIdReverse(fn) {\n  const { nextSectionId } = currentProgramPath.node.extra;\n  for (let sectionId = nextSectionId; sectionId--; ) {\n    fn(sectionId);\n  }\n}\n\n// src/util/reserve.ts\nimport { types as t2 } from \"@marko/compiler\";\n\n// src/util/sorted-arr.ts\nfunction insertInArray(compare, arr, val) {\n  const len = arr.length;\n  let max = len;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(arr[mid], val);\n    if (compareResult === 0)\n      return arr;\n    if (compareResult > 0)\n      max = mid;\n    else\n      pos = mid + 1;\n  }\n  let cur = val;\n  while (pos < len) {\n    const next = cur;\n    cur = arr[pos];\n    arr[pos++] = next;\n  }\n  arr[len] = cur;\n  return arr;\n}\nfunction findIndex(compare, arr, val) {\n  let max = arr.length;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(arr[mid], val);\n    if (compareResult === 0)\n      return mid;\n    if (compareResult > 0)\n      max = mid;\n    else\n      pos = mid + 1;\n  }\n  return -1;\n}\nfunction createSortedCollection(compare) {\n  return {\n    insert(data, val, immutable = false) {\n      if (data) {\n        if (Array.isArray(data)) {\n          return insertInArray(compare, immutable ? [...data] : data, val);\n        } else {\n          const compareResult = compare(data, val);\n          if (compareResult !== 0) {\n            return compareResult < 0 ? [data, val] : [val, data];\n          }\n        }\n      }\n      return val;\n    },\n    find(data, val) {\n      if (data) {\n        if (Array.isArray(data)) {\n          return data[findIndex(compare, data, val)];\n        } else {\n          return data === val ? data : void 0;\n        }\n      }\n    },\n    count(data) {\n      if (data === void 0)\n        return 0;\n      if (!Array.isArray(data))\n        return 1;\n      return data.length;\n    }\n  };\n}\n\n// src/util/reserve.ts\nvar [getReservesByType] = createSectionState(\"reservesByType\", () => [void 0, void 0, void 0]);\nfunction reserveScope(type, sectionId, node, name, debugKey = name) {\n  const extra = node.extra ??= {};\n  if (extra.reserve) {\n    const reserve2 = extra.reserve;\n    reserve2.name += \"_\" + name;\n    return reserve2;\n  }\n  const reservesByType = getReservesByType(sectionId);\n  const reserve = extra.reserve = {\n    id: 0,\n    type,\n    name,\n    debugKey,\n    sectionId\n  };\n  if (reservesByType[type]) {\n    reserve.id = reservesByType[type].push(reserve) - 1;\n  } else {\n    reservesByType[type] = [reserve];\n  }\n  return reserve;\n}\nfunction assignFinalIds() {\n  forEachSectionId((sectionId) => {\n    let curIndex = 0;\n    for (const reserves of getReservesByType(sectionId)) {\n      if (reserves) {\n        for (const reserve of reserves) {\n          reserve.id = curIndex;\n          curIndex += 1;\n        }\n      }\n    }\n  });\n}\nfunction getNodeLiteral(reserve) {\n  if (!isOptimize()) {\n    return t2.stringLiteral(reserve.debugKey + (reserve.type === 0 /* Visit */ ? `/${reserve.id}` : \"\"));\n  }\n  return t2.numericLiteral(reserve.id);\n}\nfunction compareReserves(a, b) {\n  return a.sectionId - b.sectionId || a.type - b.type || a.id - b.id;\n}\nvar { insert: insertReserve, count: countReserves } = createSortedCollection(compareReserves);\n\n// src/util/runtime.ts\nimport { types as t3 } from \"@marko/compiler\";\nimport { importNamed } from \"@marko/babel-utils\";\nvar pureFunctions = [\n  \"createRenderFn\",\n  \"createRenderer\",\n  \"source\",\n  \"derivation\",\n  \"subscriber\",\n  \"closure\",\n  \"loop\",\n  \"conditional\",\n  \"destructureSources\",\n  \"bind\",\n  \"bindRenderer\",\n  \"inLoopScope\",\n  \"inConditionalScope\"\n];\nfunction importRuntime(name) {\n  const { output } = getMarkoOpts();\n  return importNamed(currentProgramPath.hub.file, getRuntimePath(output), name);\n}\nfunction callRuntime(name, ...args) {\n  const callExpression2 = t3.callExpression(importRuntime(name), filterArguments(args));\n  if (pureFunctions.includes(name)) {\n    callExpression2.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: ` @__PURE__ `\n      }\n    ];\n  }\n  return callExpression2;\n}\nfunction getHTMLRuntime() {\n  return getRuntime(\"html\");\n}\nfunction getRuntime(output) {\n  return __require(getRuntimePath(output));\n}\nfunction getRuntimePath(output) {\n  const { optimize } = getMarkoOpts();\n  return `@marko/runtime-fluurt/${false ? \"src\" : optimize ? \"dist\" : \"dist/debug\"}/${output === \"html\" ? \"html\" : \"dom\"}`;\n}\nfunction callRead(reference, targetSectionId) {\n  return t3.memberExpression(getScopeExpression(reference, targetSectionId), getNodeLiteral(reference), true);\n}\nfunction getScopeExpression(reference, sectionId) {\n  const diff = reference.sectionId !== sectionId ? 1 : 0;\n  let scope = scopeIdentifier;\n  for (let i = 0; i < diff; i++) {\n    scope = t3.memberExpression(scope, t3.identifier(\"_\"));\n  }\n  return scope;\n}\nfunction filterArguments(args) {\n  const filteredArgs = [];\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (arg || filteredArgs.length) {\n      filteredArgs[i] = arg || t3.nullLiteral();\n    }\n  }\n  return filteredArgs;\n}\n\n// src/util/signals.ts\nimport { getTemplateId } from \"@marko/babel-utils\";\n\n// src/core/return.ts\nimport { types as t7 } from \"@marko/compiler\";\nimport { assertNoVar, assertNoParams } from \"@marko/babel-utils\";\n\n// src/util/writer.ts\nimport { types as t6 } from \"@marko/compiler\";\n\n// src/util/to-template-string-or-literal.ts\nimport { types as t4 } from \"@marko/compiler\";\nfunction toTemplateOrStringLiteral(parts) {\n  const strs = [];\n  const exprs = [];\n  let curStr = parts[0];\n  for (let i = 1; i < parts.length; i++) {\n    let content = parts[i];\n    if (typeof content === \"object\") {\n      if (t4.isStringLiteral(content)) {\n        content = content.value;\n      } else if (t4.isTemplateLiteral(content)) {\n        let nextIndex = i + 1;\n        const exprLen = content.expressions.length;\n        shiftItems(parts, nextIndex, content.quasis.length + exprLen);\n        for (let j = 0; j < exprLen; j++) {\n          parts[nextIndex++] = content.quasis[j].value.raw;\n          parts[nextIndex++] = content.expressions[j];\n        }\n        parts[nextIndex] = content.quasis[exprLen].value.raw;\n        continue;\n      } else {\n        exprs.push(content);\n        strs.push(curStr);\n        curStr = \"\";\n        continue;\n      }\n    }\n    curStr += content;\n  }\n  if (exprs.length) {\n    strs.push(curStr);\n    return t4.templateLiteral(strs.map((raw) => t4.templateElement({ raw })), exprs);\n  } else if (curStr) {\n    return t4.stringLiteral(curStr);\n  }\n}\nfunction appendLiteral(arr, str) {\n  arr[arr.length - 1] += str;\n}\nfunction shiftItems(list, start, offset) {\n  for (let i = list.length - 1; i >= start; i--) {\n    list[i + offset] = list[i];\n  }\n}\n\n// src/util/walks.ts\nimport { types as t5 } from \"@marko/compiler\";\nvar [getWalks] = createSectionState(\"walks\", () => [\"\"]);\nvar [getWalkComment] = createSectionState(\"walkComment\", () => []);\nvar [getSteps] = createSectionState(\"steps\", () => []);\nvar walkCodeToName = {\n  [32 /* Get */]: \"get\",\n  [33 /* Before */]: \"before\",\n  [35 /* After */]: \"after\",\n  [36 /* Inside */]: \"inside\",\n  [37 /* Replace */]: \"replace\",\n  [38 /* EndChild */]: \"endChild\",\n  [47 /* BeginChild */]: \"beginChild\",\n  [67 /* Next */]: \"next\",\n  [97 /* Over */]: \"over\",\n  [107 /* Out */]: \"out\",\n  [117 /* Multiplier */]: \"multiplier\",\n  [91 /* NextEnd */]: \"nextEnd\",\n  [106 /* OverEnd */]: \"overEnd\",\n  [116 /* OutEnd */]: \"outEnd\",\n  [126 /* MultiplierEnd */]: \"multiplierEnd\"\n};\nfunction enter(path3) {\n  getSteps(getSectionId(path3)).push(0 /* enter */);\n}\nfunction exit(path3) {\n  getSteps(getSectionId(path3)).push(1 /* exit */);\n}\nfunction enterShallow(path3) {\n  getSteps(getSectionId(path3)).push(0 /* enter */, 1 /* exit */);\n}\nfunction injectWalks(path3, expr) {\n  const walks = getWalks(getSectionId(path3));\n  const walkComment = getWalkComment(getSectionId(path3));\n  walkComment.push(`${walkCodeToName[47 /* BeginChild */]}`, expr.name, walkCodeToName[38 /* EndChild */]);\n  appendLiteral(walks, String.fromCharCode(47 /* BeginChild */));\n  walks.push(expr, String.fromCharCode(38 /* EndChild */));\n}\nfunction visit(path3, code) {\n  const { reserve } = path3.node.extra;\n  if (code && (!reserve || reserve.type !== 0 /* Visit */)) {\n    throw path3.buildCodeFrameError(\"Tried to visit a node that was not marked as needing to visit during analyze.\");\n  }\n  if (isOutputHTML()) {\n    return;\n  }\n  const sectionId = getSectionId(path3);\n  const steps = getSteps(sectionId);\n  const walks = getWalks(sectionId);\n  const walkComment = getWalkComment(sectionId);\n  let walkString = \"\";\n  if (steps.length) {\n    const walks2 = [];\n    let depth = 0;\n    for (const step of steps) {\n      if (step === 0 /* enter */) {\n        depth++;\n        walks2.push(67 /* Next */);\n      } else {\n        depth--;\n        if (depth >= 0) {\n          walks2.length = walks2.lastIndexOf(67 /* Next */);\n          walks2.push(97 /* Over */);\n        } else {\n          walks2.length = walks2.lastIndexOf(107 /* Out */) + 1;\n          walks2.push(107 /* Out */);\n          depth = 0;\n        }\n      }\n    }\n    let current = walks2[0];\n    let count = 0;\n    for (const walk of walks2) {\n      if (walk !== current) {\n        walkComment.push(`${walkCodeToName[current]}(${count})`);\n        walkString += nCodeString(current, count);\n        current = walk;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n    walkComment.push(`${walkCodeToName[current]}(${count})`);\n    walkString += nCodeString(current, count);\n    steps.length = 0;\n  }\n  if (code !== void 0) {\n    if (code !== 32 /* Get */) {\n      writeTo(path3)`<!>`;\n    }\n    walkComment.push(`${walkCodeToName[code]}`);\n    walkString += String.fromCharCode(code);\n  }\n  appendLiteral(walks, walkString);\n}\nfunction nCodeString(code, number) {\n  switch (code) {\n    case 67 /* Next */:\n      return toCharString(number, code, 20 /* Next */);\n    case 97 /* Over */:\n      return toCharString(number, code, 10 /* Over */);\n    case 107 /* Out */:\n      return toCharString(number, code, 10 /* Out */);\n    default:\n      throw new Error(`Unexpected walk code: ${code}`);\n  }\n}\nfunction toCharString(number, startCode, rangeSize) {\n  let result = \"\";\n  if (number >= rangeSize) {\n    const multiplier = Math.floor(number / rangeSize);\n    result += toCharString(multiplier, 117 /* Multiplier */, 10 /* Multiplier */);\n    number -= multiplier * rangeSize;\n  }\n  result += String.fromCharCode(startCode + number);\n  return result;\n}\nfunction getWalkString(sectionId) {\n  const walkLiteral = toTemplateOrStringLiteral(getWalks(sectionId)) || t5.stringLiteral(\"\");\n  if (walkLiteral.value !== \"\") {\n    walkLiteral.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: \" \" + getWalkComment(sectionId).join(\", \") + \" \"\n      }\n    ];\n  }\n  return walkLiteral;\n}\n\n// src/util/writer.ts\nvar [getRenderer] = createSectionState(\"renderer\", (sectionId) => {\n  const name = currentProgramPath.node.extra.sectionNames[sectionId];\n  return t6.identifier(name);\n});\nvar [getWrites] = createSectionState(\"writes\", () => [\"\"]);\nfunction writeTo(path3) {\n  const sectionId = getSectionId(path3);\n  return (strs, ...exprs) => {\n    const exprsLen = exprs.length;\n    const writes = getWrites(sectionId);\n    appendLiteral(writes, strs[0]);\n    for (let i = 0; i < exprsLen; i++) {\n      writes.push(exprs[i], strs[i + 1]);\n    }\n  };\n}\nfunction consumeHTML(path3) {\n  const writes = getWrites(getSectionId(path3));\n  const result = toTemplateOrStringLiteral(writes);\n  writes.length = 0;\n  writes[0] = \"\";\n  if (result) {\n    return t6.expressionStatement(callRuntime(\"write\", result));\n  }\n}\nfunction hasPendingHTML(path3) {\n  const writes = getWrites(getSectionId(path3));\n  return Boolean(writes.length > 1 || writes[0]);\n}\nfunction flushBefore(path3) {\n  const expr = consumeHTML(path3);\n  if (expr) {\n    path3.insertBefore(expr)[0].skip();\n  }\n}\nfunction flushInto(path3) {\n  const target = path3.isProgram() ? path3 : path3.get(\"body\");\n  const expr = consumeHTML(target);\n  if (expr) {\n    target.pushContainer(\"body\", expr)[0].skip();\n  }\n}\nfunction getSectionMeta(sectionId) {\n  const writes = getWrites(sectionId);\n  return {\n    apply: getSetup(sectionId),\n    walks: getWalkString(sectionId),\n    writes: toTemplateOrStringLiteral(writes) || t6.stringLiteral(\"\")\n  };\n}\nfunction markNode(path3) {\n  const { reserve } = path3.node.extra;\n  if (reserve?.type !== 0 /* Visit */) {\n    throw path3.buildCodeFrameError(\"Tried to mark a node that was not determined to need a mark during analyze.\");\n  }\n  if (isOutputHTML()) {\n    writeTo(path3)`${callRuntime(\"markHydrateNode\", scopeIdentifier, getNodeLiteral(reserve))}`;\n  }\n}\n\n// src/util/assert.ts\nfunction assertNoSpreadAttrs(tag) {\n  for (const attr of tag.get(\"attributes\")) {\n    if (attr.isMarkoSpreadAttribute()) {\n      throw attr.buildCodeFrameError(`The <${tag.get(\"name\")}> tag does not support ...spread attributes.`);\n    }\n  }\n}\nfunction assertNoBodyContent(tag) {\n  if (tag.node.body.body.length) {\n    throw tag.get(\"name\").buildCodeFrameError(`The <${tag.get(\"name\")}> tag does not support body content.`);\n  }\n}\n\n// src/core/return.ts\nvar [returnId, _setReturnId] = createSectionState(\"returnId\");\nvar return_default = {\n  translate(tag) {\n    assertNoVar(tag);\n    assertNoParams(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    const sectionId = getSectionId(tag);\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const [defaultAttr] = node.attributes;\n    if (!t7.isMarkoAttribute(defaultAttr) || !defaultAttr.default) {\n      throw tag.get(\"name\").buildCodeFrameError(`The '<return>' tag requires default attribute like '<return=VALUE>'.`);\n    }\n    if (node.attributes.length > 1) {\n      const start = node.attributes[1].loc?.start;\n      const end = node.attributes[node.attributes.length - 1].loc?.end;\n      const msg = `The '<return>' tag only supports a default attribute.`;\n      if (start == null || end == null) {\n        throw tag.get(\"name\").buildCodeFrameError(msg);\n      } else {\n        throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n      }\n    }\n    if (isOutputHTML()) {\n      flushBefore(tag);\n      const returnId2 = file.path.scope.generateUidIdentifier(\"return\");\n      _setReturnId(sectionId, returnId2);\n      tag.replaceWith(t7.variableDeclaration(\"const\", [\n        t7.variableDeclarator(returnId2, defaultAttr.value)\n      ]))[0].skip();\n    } else {\n      const signal = getSignal(sectionId, defaultAttr.extra?.valueReferences?.references);\n      const tagVarSignalIdentifier = importRuntime(\"tagVarSignal\");\n      signal.subscribers.push(tagVarSignalIdentifier);\n      addStatement(\"apply\", sectionId, defaultAttr.extra?.valueReferences, t7.expressionStatement(callRuntime(\"setSource\", scopeIdentifier, t7.identifier(tagVarSignalIdentifier.name), defaultAttr.value)));\n      tag.remove();\n    }\n  },\n  autocomplete: [\n    {\n      displayText: \"return=<value>\",\n      description: \"Provides a value for use in a parent template.\",\n      snippet: \"return=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#return\"\n    }\n  ]\n};\n\n// src/util/signals.ts\nvar [getSignals] = createSectionState(\"signals\", () => /* @__PURE__ */ new Map());\nvar [getSubscribeBuilder, _setSubscribeBuilder] = createSectionState(\"queue\");\nvar [getClosures] = createSectionState(\"closures\", () => []);\nvar [forceHydrateScope, _setForceHydrateScope] = createSectionState(\"forceHydrateScope\");\nfunction setForceHydrateScope(sectionId) {\n  _setForceHydrateScope(sectionId, true);\n}\nfunction setSubscriberBuilder(tag, builder) {\n  _setSubscribeBuilder(getSectionId(tag.get(\"body\")), builder);\n}\nfunction getSignal(sectionId, reserve) {\n  const key = !Array.isArray(reserve) ? reserve : reserve.map((r) => `${r.sectionId}/${r.id}`).sort().join(\"-\");\n  const signals = getSignals(sectionId);\n  let signal = signals.get(key);\n  if (!signal) {\n    signals.set(key, signal = {\n      identifier: t8.identifier(generateSignalName(sectionId, reserve)),\n      reserve,\n      sectionId,\n      render: [],\n      hydrate: [],\n      hydrateInlineReferences: void 0,\n      subscribers: []\n    });\n    if (!reserve) {\n      signal.build = () => {\n        for (const subscriber of signal.subscribers) {\n          signal.render.push(t8.expressionStatement(callRuntime(\"notifySignal\", scopeIdentifier, subscriber)));\n        }\n        return t8.arrowFunctionExpression([scopeIdentifier], t8.blockStatement(signal.render));\n      };\n    } else if (Array.isArray(reserve)) {\n      subscribe(reserve, signal);\n      signal.build = () => {\n        return callRuntime(\"subscriber\", t8.arrayExpression(signal.subscribers), t8.numericLiteral(reserve.length), getComputeFn(sectionId, t8.blockStatement(signal.render), reserve));\n      };\n    } else if (reserve.sectionId !== sectionId) {\n      getClosures(sectionId).push(signal.identifier);\n      signal.build = () => {\n        const builder = getSubscribeBuilder(sectionId);\n        const provider = getSignal(reserve.sectionId, reserve);\n        if (builder) {\n          provider.subscribers.push(builder(signal.identifier));\n        } else if (!provider.hasDynamicSubscribers) {\n          provider.hasDynamicSubscribers = true;\n          provider.subscribers.push(callRuntime(\"dynamicSubscribers\", getNodeLiteral(reserve)));\n        }\n        return callRuntime(builder ? \"closure\" : \"dynamicClosure\", t8.numericLiteral(1), getNodeLiteral(reserve), t8.arrayExpression(signal.subscribers), t8.arrowFunctionExpression([scopeIdentifier, t8.identifier(reserve.name)], t8.blockStatement(signal.render)));\n      };\n    } else {\n      signal.build = () => {\n        return t8.stringLiteral(\"SIGNAL NOT INITIALIZED\");\n      };\n    }\n  }\n  return signal;\n}\nfunction initSource(reserve) {\n  const sectionId = reserve.sectionId;\n  const signal = getSignal(sectionId, reserve);\n  signal.build = () => {\n    return callRuntime(\"source\", getNodeLiteral(reserve), t8.arrayExpression(signal.subscribers), t8.arrowFunctionExpression([scopeIdentifier, t8.identifier(reserve.name)], t8.blockStatement(signal.render)));\n  };\n  return signal;\n}\nfunction initDerivation(reserve, providers, compute) {\n  const sectionId = reserve.sectionId;\n  const signal = getSignal(sectionId, reserve);\n  signal.build = () => {\n    return callRuntime(\"derivation\", getNodeLiteral(reserve), t8.numericLiteral(Array.isArray(providers) ? providers.length : 1), t8.arrayExpression(signal.subscribers), getComputeFn(sectionId, compute, providers), t8.arrowFunctionExpression([scopeIdentifier, t8.identifier(reserve.name)], t8.blockStatement(signal.render)));\n  };\n  subscribe(providers, signal);\n  return signal;\n}\nfunction initContextProvider(templateId, reserve, providers, compute, renderer) {\n  const sectionId = reserve.sectionId;\n  const scopeAccessor = getNodeLiteral(reserve);\n  const valueAccessor = t8.stringLiteral(`${reserve.id}${\":\" /* CONTEXT_VALUE */}`);\n  const signal = getSignal(sectionId, reserve);\n  signal.build = () => {\n    return callRuntime(\"derivation\", valueAccessor, t8.numericLiteral(Array.isArray(providers) ? providers.length : 1), t8.arrayExpression(signal.subscribers), getComputeFn(sectionId, compute, providers), t8.arrowFunctionExpression([scopeIdentifier, t8.identifier(reserve.name)], t8.blockStatement(signal.render)));\n  };\n  subscribe(providers, signal);\n  signal.subscribers.push(callRuntime(\"dynamicSubscribers\", valueAccessor));\n  addStatement(\"apply\", reserve.sectionId, void 0, t8.expressionStatement(callRuntime(\"initContextProvider\", scopeIdentifier, scopeAccessor, valueAccessor, t8.stringLiteral(templateId), renderer)));\n  return signal;\n}\nfunction initContextConsumer(templateId, reserve) {\n  const sectionId = reserve.sectionId;\n  const signal = getSignal(sectionId, reserve);\n  getClosures(sectionId).push(signal.identifier);\n  signal.build = () => {\n    return callRuntime(\"contextClosure\", getNodeLiteral(reserve), t8.stringLiteral(templateId), t8.arrayExpression(signal.subscribers), t8.arrowFunctionExpression([scopeIdentifier, t8.identifier(reserve.name)], t8.blockStatement(signal.render)));\n  };\n  return signal;\n}\nfunction getComputeFn(sectionId, body, references) {\n  const params = [scopeIdentifier];\n  if (Array.isArray(references)) {\n    references.forEach((binding) => params.push(t8.assignmentPattern(t8.identifier(binding.name), callRead(binding, sectionId))));\n  } else if (references) {\n    params.push(t8.assignmentPattern(t8.identifier(references.name), callRead(references, sectionId)));\n  }\n  return t8.arrowFunctionExpression(params, body);\n}\nfunction subscribe(provider, subscriber) {\n  if (Array.isArray(provider)) {\n    provider.forEach((p) => subscribe(p, subscriber));\n    return;\n  }\n  const providerSignal = getSignal(subscriber.sectionId, provider);\n  providerSignal.subscribers.push(subscriber.identifier);\n}\nfunction generateSignalName(sectionId, references) {\n  let name;\n  if (references) {\n    if (Array.isArray(references)) {\n      name = \"expr\";\n      for (const ref of references) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name = references.name;\n    }\n  } else {\n    name = \"setup\";\n  }\n  name += sectionId ? currentProgramPath.node.extra.sectionNames[sectionId].replace(\"_\", \"$\") : \"\";\n  return currentProgramPath.scope.generateUid(name);\n}\nfunction queueSource(source, value, targetSectionId) {\n  return callRuntime(\"queueSource\", getScopeExpression2(source.sectionId, targetSectionId), source.identifier, value);\n}\nfunction getScopeExpression2(ownerSectionId, sectionId) {\n  const diff = ownerSectionId !== sectionId ? 1 : 0;\n  let scope = scopeIdentifier;\n  for (let i = 0; i < diff; i++) {\n    scope = t8.memberExpression(scope, t8.identifier(\"_\"));\n  }\n  return scope;\n}\nfunction finalizeSignalArgs(args) {\n  for (let i = args.length - 1; i >= 0; i--) {\n    const arg = args[i];\n    if (t8.isArrowFunctionExpression(arg)) {\n      const body = arg.body.body;\n      if (body) {\n        if (body.length === 0) {\n          args[i] = t8.nullLiteral();\n        } else if (body.length === 1 && t8.isExpressionStatement(body[0])) {\n          arg.body = body[0].expression;\n        }\n      }\n    }\n  }\n  for (let i = args.length - 1; t8.isNullLiteral(args[i]); ) {\n    args.length = i--;\n  }\n}\nfunction addStatement(type, targetSectionId, references, statement, originalNodes, isInlined) {\n  const reserve = references?.references;\n  const signal = getSignal(targetSectionId, reserve);\n  const statements = signal[type === \"apply\" ? \"render\" : \"hydrate\"] ??= [];\n  if (Array.isArray(statement)) {\n    statements.push(...statement);\n  } else {\n    statements.push(statement);\n  }\n  if (type === \"hydrate\") {\n    if (Array.isArray(originalNodes)) {\n      for (const node of originalNodes) {\n        if (isInlined || !t8.isFunction(node)) {\n          addHydrateReferences(signal, node);\n        }\n      }\n    } else {\n      if (isInlined || !t8.isFunction(originalNodes)) {\n        addHydrateReferences(signal, originalNodes);\n      }\n    }\n  }\n}\nfunction addHydrateReferences(signal, expression) {\n  const references = expression.extra?.references?.references;\n  let refs = signal.hydrateInlineReferences;\n  if (references) {\n    if (Array.isArray(references)) {\n      for (const ref of references) {\n        refs = insertReserve(refs, ref);\n      }\n    } else {\n      refs = insertReserve(refs, references);\n    }\n  }\n  signal.hydrateInlineReferences = refs;\n}\nfunction getHydrateRegisterId(sectionId, references) {\n  const {\n    markoOpts: { optimize },\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let name = \"\";\n  if (references) {\n    if (Array.isArray(references)) {\n      for (const ref of references) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name += `_${references.name}`;\n    }\n  }\n  return getTemplateId(optimize, `${filename}_${sectionId}${name}`);\n}\nfunction writeSignals(sectionId) {\n  const signals = getSignals(sectionId);\n  const declarations = Array.from(signals.values()).sort(sortSignals).flatMap((signal) => {\n    let value = signal.build();\n    if (signal.register) {\n      value = callRuntime(\"register\", t8.stringLiteral(getHydrateRegisterId(sectionId, signal.reserve)), value);\n    }\n    const signalDeclarator = t8.variableDeclarator(signal.identifier, value);\n    let hydrateDeclarator;\n    if (signal.hydrate.length) {\n      const hydrateIdentifier = t8.identifier(\"_hydrate\" + signal.identifier.name);\n      if (signal.hydrateInlineReferences) {\n        signal.hydrate.unshift(t8.variableDeclaration(\"const\", (Array.isArray(signal.hydrateInlineReferences) ? signal.hydrateInlineReferences : [signal.hydrateInlineReferences]).map((binding) => t8.variableDeclarator(t8.identifier(binding.name), callRead(binding, sectionId)))));\n      }\n      hydrateDeclarator = t8.variableDeclarator(hydrateIdentifier, callRuntime(\"register\", t8.stringLiteral(getHydrateRegisterId(sectionId, signal.reserve)), t8.arrowFunctionExpression([scopeIdentifier], signal.hydrate.length === 1 && t8.isExpressionStatement(signal.hydrate[0]) ? signal.hydrate[0].expression : t8.blockStatement(signal.hydrate))));\n      signal.render.push(t8.expressionStatement(callRuntime(\"queueHydrate\", scopeIdentifier, hydrateIdentifier)));\n    }\n    if (t8.isCallExpression(value)) {\n      finalizeSignalArgs(value.arguments);\n    }\n    return hydrateDeclarator ? [\n      t8.variableDeclaration(\"const\", [hydrateDeclarator]),\n      t8.variableDeclaration(\"const\", [signalDeclarator])\n    ] : t8.variableDeclaration(\"const\", [signalDeclarator]);\n  });\n  const newPaths = currentProgramPath.pushContainer(\"body\", declarations);\n  newPaths.forEach((newPath) => newPath.traverse(bindFunctionsVisitor, { root: newPath, sectionId }));\n}\nfunction sortSignals(a, b) {\n  const aReserves = getReserves(a);\n  const bReserves = getReserves(b);\n  for (let i = Math.max(aReserves.length, bReserves.length) - 1; i >= 0; i--) {\n    const diff = (bReserves[i] ?? -1) - (aReserves[i] ?? -1);\n    if (diff !== 0)\n      return diff;\n  }\n  return 0;\n}\nfunction getReserves({ reserve }) {\n  if (!reserve) {\n    return [];\n  } else if (Array.isArray(reserve)) {\n    return reserve.map(getMappedId).sort();\n  } else {\n    return [getMappedId(reserve)];\n  }\n}\nfunction getMappedId(reserve) {\n  return (reserve.type === 0 ? 1 : 0) * 1e4 + reserve.id;\n}\nfunction addHTMLHydrateCall(sectionId, references) {\n  addStatement(\"hydrate\", sectionId, references, void 0, []);\n}\nfunction writeHTMLHydrateStatements(path3, tagVarIdentifier) {\n  const sectionId = getOrCreateSectionId(path3);\n  const allSignals = Array.from(getSignals(sectionId).values());\n  path3.unshiftContainer(\"body\", t8.variableDeclaration(\"const\", [\n    t8.variableDeclarator(scopeIdentifier, callRuntime(\"nextScopeId\"))\n  ]));\n  const refs = [];\n  for (let i = allSignals.length; i--; ) {\n    if (allSignals[i].hydrate.length) {\n      const references = allSignals[i].reserve;\n      if (references) {\n        if (Array.isArray(references)) {\n          for (const ref of references) {\n            insertReserve(refs, ref);\n          }\n        } else {\n          insertReserve(refs, references);\n        }\n      }\n      path3.pushContainer(\"body\", t8.expressionStatement(callRuntime(\"writeHydrateCall\", scopeIdentifier, t8.stringLiteral(getHydrateRegisterId(sectionId, references)))));\n    }\n  }\n  const serializedProperties = refs.reduce((acc, ref) => {\n    acc.push(t8.objectProperty(getNodeLiteral(ref), t8.identifier(ref.name)));\n    return acc;\n  }, []);\n  if (tagVarIdentifier && returnId(sectionId) !== void 0) {\n    serializedProperties.push(t8.objectProperty(t8.stringLiteral(\"/\" /* TAG_VARIABLE */), tagVarIdentifier));\n  }\n  if (serializedProperties.length || forceHydrateScope(sectionId)) {\n    path3.pushContainer(\"body\", t8.expressionStatement(callRuntime(\"writeHydrateScope\", scopeIdentifier, t8.objectExpression(serializedProperties))));\n  }\n}\nvar bindFunctionsVisitor = {\n  FunctionExpression: { exit: bindFunction },\n  ArrowFunctionExpression: { exit: bindFunction }\n};\nfunction bindFunction(fn, { root, sectionId }) {\n  const { node } = fn;\n  const { extra } = node;\n  const references = extra?.references?.references;\n  const program = fn.hub.file.path;\n  const functionIdentifier = program.scope.generateUidIdentifier(extra?.name);\n  if (references) {\n    if (node.body.type !== \"BlockStatement\") {\n      node.body = t8.blockStatement([t8.returnStatement(node.body)]);\n    }\n    node.body.body.unshift(t8.variableDeclaration(\"const\", (Array.isArray(references) ? references : [references]).map((binding) => t8.variableDeclarator(t8.identifier(binding.name), callRead(binding, sectionId)))));\n  }\n  let parent = fn.parentPath;\n  while (parent) {\n    if (parent.isFunction())\n      return;\n    if (parent === root)\n      return;\n    parent = parent.parentPath;\n  }\n  root.insertBefore(t8.variableDeclaration(\"const\", [\n    t8.variableDeclarator(functionIdentifier, node)\n  ]));\n  node.params.unshift(scopeIdentifier);\n  fn.replaceWith(callRuntime(\"bind\", scopeIdentifier, functionIdentifier));\n}\nfunction getSetup(sectionId) {\n  return getSignals(sectionId).get(void 0)?.identifier;\n}\n\n// src/util/is-static.ts\nfunction isStatic(path3) {\n  return path3.isImportDeclaration() || path3.isExportDeclaration() || path3.isMarkoScriptlet({ static: true });\n}\n\n// src/visitors/program/html.ts\nvar html_default = {\n  translate: {\n    exit(program) {\n      const tagVarIdentifier = program.scope.generateUidIdentifier(\"tagVar\");\n      flushInto(program);\n      writeHTMLHydrateStatements(program, tagVarIdentifier);\n      const returnIdentifier = returnId(0);\n      if (returnIdentifier !== void 0) {\n        program.pushContainer(\"body\", t9.returnStatement(returnIdentifier));\n      }\n      const renderContent = [];\n      for (const child of program.get(\"body\")) {\n        if (!isStatic(child)) {\n          renderContent.push(child.node);\n          child.remove();\n        } else if (child.isMarkoScriptlet()) {\n          child.replaceWithMultiple(child.node.body);\n        }\n      }\n      const rendererId = program.scope.generateUidIdentifier(\"renderer\");\n      const { attrs } = program.node.extra;\n      program.pushContainer(\"body\", [\n        t9.variableDeclaration(\"const\", [\n          t9.variableDeclarator(rendererId, t9.arrowFunctionExpression([\n            attrs ? attrs.var : t9.identifier(\"input\"),\n            tagVarIdentifier\n          ], t9.blockStatement(renderContent)))\n        ]),\n        t9.exportDefaultDeclaration(rendererId),\n        t9.exportNamedDeclaration(t9.variableDeclaration(\"const\", [\n          t9.variableDeclarator(t9.identifier(\"render\"), callRuntime(\"createRenderer\", rendererId))\n        ]))\n      ]);\n    }\n  }\n};\n\n// src/visitors/program/dom.ts\nimport { types as t10 } from \"@marko/compiler\";\nvar dom_default = {\n  translate: {\n    exit(program) {\n      visit(program);\n      const sectionId = getSectionId(program);\n      const templateIdentifier = t10.identifier(\"template\");\n      const walksIdentifier = t10.identifier(\"walks\");\n      const setupIdentifier = t10.identifier(\"setup\");\n      const attrsSignalIdentifier = t10.identifier(\"attrs\");\n      const closuresIdentifier = t10.identifier(\"closures\");\n      const { attrs } = program.node.extra;\n      const { walks, writes, apply } = getSectionMeta(sectionId);\n      forEachSectionIdReverse((childSectionId) => {\n        writeSignals(childSectionId);\n        if (childSectionId !== sectionId) {\n          const { walks: walks2, writes: writes2, apply: apply2 } = getSectionMeta(childSectionId);\n          const closures2 = getClosures(childSectionId);\n          const identifier = getRenderer(childSectionId);\n          program.node.body.push(t10.variableDeclaration(\"const\", [\n            t10.variableDeclarator(identifier, callRuntime(\"createRenderer\", writes2, walks2, apply2, closures2.length && t10.arrayExpression(closures2)))\n          ]));\n        }\n      });\n      if (attrs) {\n        const exportSpecifiers = [];\n        const subscribers = [];\n        const statements = [];\n        for (const name in attrs.bindings) {\n          const bindingIdentifier = attrs.bindings[name];\n          const signalIdentifier = getSignal(sectionId, bindingIdentifier.extra.reserve).identifier;\n          exportSpecifiers.push(t10.exportSpecifier(signalIdentifier, bindingIdentifier.extra.reserve.exportIdentifier));\n          subscribers.push(signalIdentifier);\n          statements.push(t10.expressionStatement(callRuntime(\"setSource\", scopeIdentifier, signalIdentifier, bindingIdentifier)));\n        }\n        program.node.body.push(t10.exportNamedDeclaration(t10.variableDeclaration(\"const\", [\n          t10.variableDeclarator(attrsSignalIdentifier, callRuntime(\"destructureSources\", t10.arrayExpression(subscribers), t10.arrowFunctionExpression([scopeIdentifier, attrs.var], t10.blockStatement(statements))))\n        ])), t10.exportNamedDeclaration(null, exportSpecifiers));\n      }\n      const closures = getClosures(sectionId);\n      program.node.body.push(t10.exportNamedDeclaration(t10.variableDeclaration(\"const\", [\n        t10.variableDeclarator(templateIdentifier, writes || t10.stringLiteral(\"\"))\n      ])), t10.exportNamedDeclaration(t10.variableDeclaration(\"const\", [\n        t10.variableDeclarator(walksIdentifier, walks || t10.stringLiteral(\"\"))\n      ])), t10.exportNamedDeclaration(t10.variableDeclaration(\"const\", [\n        t10.variableDeclarator(setupIdentifier, t10.isNullLiteral(apply) || !apply ? t10.functionExpression(null, [], t10.blockStatement([])) : apply)\n      ])));\n      if (closures.length) {\n        program.node.body.push(t10.exportNamedDeclaration(t10.variableDeclaration(\"const\", [\n          t10.variableDeclarator(closuresIdentifier, t10.arrayExpression(closures))\n        ])));\n      }\n      program.node.body.push(t10.exportDefaultDeclaration(callRuntime(\"createRenderFn\", templateIdentifier, walksIdentifier, setupIdentifier, attrs && attrsSignalIdentifier, closures.length && closuresIdentifier)));\n    }\n  }\n};\n\n// src/util/references.ts\nimport { types as t11 } from \"@marko/compiler\";\nvar [getReferenceGroups] = createSectionState(\"apply\", () => [\n  {\n    sectionId: 0,\n    index: 0,\n    count: 0,\n    references: void 0,\n    apply: t11.identifier(\"\"),\n    hydrate: t11.identifier(\"\")\n  }\n]);\nfunction trackReferences(tag) {\n  if (tag.has(\"var\")) {\n    trackReferencesForBindings(getOrCreateSectionId(tag), tag.get(\"var\"));\n  }\n  const body = tag.get(\"body\");\n  if (body.get(\"body\").length && body.get(\"params\").length) {\n    trackReferencesForBindings(getOrCreateSectionId(body), body);\n  }\n}\nfunction trackReferencesForBindings(sectionId, path3, reserveType = 1 /* Store */) {\n  const scope = path3.scope;\n  const bindings = path3.getBindingIdentifiers();\n  for (const name in bindings) {\n    const references = scope.getBinding(name).referencePaths.concat(scope.getBinding(name).constantViolations.filter((path4) => path4.isAssignmentExpression() && path4.node.operator !== \"=\"));\n    const identifier = bindings[name];\n    const binding = reserveScope(reserveType, sectionId, identifier, name);\n    insertReferenceGroup(getReferenceGroups(sectionId), {\n      sectionId,\n      index: 0,\n      count: 0,\n      references: binding,\n      apply: t11.identifier(\"\"),\n      hydrate: t11.identifier(\"\")\n    });\n    for (const reference of references) {\n      const fnRoot = getFnRoot(reference.scope.path);\n      const exprRoot = getExprRoot(fnRoot || reference);\n      const markoRoot = exprRoot.parentPath;\n      const immediateRoot = fnRoot ?? exprRoot;\n      if (immediateRoot) {\n        const name2 = immediateRoot.node.id?.name;\n        if (!name2) {\n          if (markoRoot.isMarkoAttribute() && !markoRoot.node.default) {\n            (immediateRoot.node.extra ??= {}).name = markoRoot.node.name;\n          }\n        }\n        updateReferenceGroup(immediateRoot, \"references\", binding);\n      }\n      updateReferenceGroup(markoRoot, `${exprRoot.listKey || exprRoot.key}References`, binding);\n    }\n  }\n}\nfunction updateReferenceGroup(path3, extraKey, newBinding) {\n  const sectionId = getOrCreateSectionId(path3);\n  const currentGroup = (path3.node.extra ??= {})[extraKey];\n  const newReferences = insertReserve(currentGroup?.references, newBinding, true);\n  if (currentGroup) {\n    currentGroup.count--;\n  }\n  getOrCreateReferenceGroup(sectionId, newBinding);\n  path3.node.extra[extraKey] = getOrCreateReferenceGroup(sectionId, newReferences);\n}\nfunction mergeReferenceGroups(sectionId, groupEntries) {\n  let newReferences;\n  for (const [extra, key] of groupEntries) {\n    const group = extra[key];\n    const references = group.references;\n    delete extra[key];\n    group.count--;\n    sectionId = group.sectionId;\n    if (references) {\n      if (Array.isArray(references)) {\n        for (const binding of references) {\n          newReferences = insertReserve(newReferences, binding);\n        }\n      } else {\n        newReferences = insertReserve(newReferences, references);\n      }\n    }\n  }\n  return getOrCreateReferenceGroup(sectionId, newReferences);\n}\nfunction getOrCreateReferenceGroup(sectionId, references) {\n  const newGroup = {\n    sectionId,\n    index: 0,\n    count: 1,\n    references,\n    apply: t11.identifier(\"\"),\n    hydrate: t11.identifier(\"\")\n  };\n  const referenceGroups = getReferenceGroups(sectionId);\n  const existingGroup = findReferenceGroup(referenceGroups, newGroup);\n  if (existingGroup) {\n    existingGroup.count++;\n  } else {\n    insertReferenceGroup(referenceGroups, newGroup);\n  }\n  return existingGroup ?? newGroup;\n}\nfunction getExprRoot(path3) {\n  let curPath = path3;\n  while (!isMarkoPath(curPath.parentPath)) {\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction getFnRoot(path3) {\n  let curPath = path3;\n  if (curPath.isProgram())\n    return;\n  while (!isFunctionExpression(curPath)) {\n    if (isMarkoPath(curPath))\n      return;\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction isMarkoPath(path3) {\n  switch (path3.type) {\n    case \"MarkoTag\":\n    case \"MarkoTagBody\":\n    case \"MarkoAttribute\":\n    case \"MarkoSpreadAttribute\":\n    case \"MarkoPlaceholder\":\n    case \"MarkoScriptlet\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isFunctionExpression(path3) {\n  switch (path3.type) {\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\nvar { insert: insertReferenceGroup, find: findReferenceGroup } = createSortedCollection(function compareReferenceGroups({ references: a }, { references: b }) {\n  if (a) {\n    if (b) {\n      if (Array.isArray(a)) {\n        if (Array.isArray(b)) {\n          const len = a.length;\n          const lenDelta = len - b.length;\n          if (lenDelta !== 0) {\n            return lenDelta;\n          }\n          for (let i = 0; i < len; i++) {\n            const compareResult = compareReserves(a[i], b[i]);\n            if (compareResult !== 0) {\n              return compareResult;\n            }\n          }\n          return 0;\n        } else {\n          return 1;\n        }\n      } else if (Array.isArray(b)) {\n        return -1;\n      } else {\n        return compareReserves(a, b);\n      }\n    } else {\n      return 1;\n    }\n  } else {\n    return b ? -1 : 0;\n  }\n});\nfunction finalizeReferences() {\n  const allReferenceGroups = [];\n  forEachSectionId((sectionId) => {\n    const referenceGroups = getReferenceGroups(sectionId).filter((g) => g.count > 0 || !Array.isArray(g.references));\n    referenceGroups.forEach((g, i) => {\n      g.index = i;\n      g.apply.name = generateReferenceGroupName(\"apply\", sectionId, g.references);\n      g.hydrate.name = generateReferenceGroupName(\"hydrate\", sectionId, g.references);\n    });\n    allReferenceGroups[sectionId] = referenceGroups;\n  });\n  (currentProgramPath.node.extra ??= {}).referenceGroups = allReferenceGroups;\n}\nfunction getReferenceGroup(sectionId, lookup, analyze2 = false) {\n  const referenceGroups = analyze2 ? getReferenceGroups(sectionId) : currentProgramPath.node.extra.referenceGroups[sectionId];\n  let found;\n  if (typeof lookup === \"number\") {\n    found = referenceGroups[lookup];\n  } else {\n    found = findReferenceGroup(referenceGroups, {\n      references: lookup\n    });\n  }\n  if (!found) {\n    throw new Error(`Reference group not found for section ${sectionId}: ${lookup}`);\n  }\n  return found;\n}\nfunction generateReferenceGroupName(type, sectionId, references) {\n  let name = type + (sectionId ? currentProgramPath.node.extra.sectionNames[sectionId].replace(\"_\", \"$\") : \"\");\n  if (references) {\n    if (Array.isArray(references)) {\n      name += \"With\";\n      for (const ref of references) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name += `_${references.name}`;\n    }\n  }\n  return currentProgramPath.scope.generateUid(name);\n}\n\n// src/visitors/program/index.ts\nvar currentProgramPath;\nvar scopeIdentifier;\nvar previousProgramPath = /* @__PURE__ */ new WeakMap();\nvar program_default = {\n  migrate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n    },\n    exit() {\n      currentProgramPath.scope.crawl();\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  analyze: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      startSection(program);\n    },\n    exit() {\n      assignFinalIds();\n      finalizeReferences();\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  translate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      scopeIdentifier = program.scope.generateUidIdentifier(\"scope\");\n      if (getMarkoOpts().output === \"hydrate\") {\n        program.skip();\n        program.node.body = [\n          t12.importDeclaration([], t12.stringLiteral(program.hub.file.opts.filename))\n        ];\n        if (program.node.extra.hasInteractiveChild || program.node.extra.isInteractive) {\n          program.node.body.push(t12.expressionStatement(callRuntime(\"init\")));\n        }\n        return;\n      }\n    },\n    exit(program) {\n      if (isOutputHTML()) {\n        html_default.translate.exit(program);\n      } else {\n        dom_default.translate.exit(program);\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  }\n};\n\n// src/visitors/import-declaration.ts\nimport { resolveTagImport } from \"@marko/babel-utils\";\nvar import_declaration_default = {\n  translate: {\n    exit(path3) {\n      const source = path3.get(\"source\");\n      const request = source.node.value;\n      source.node.value = resolveTagImport(source, request) || request;\n    }\n  }\n};\n\n// src/visitors/document-type.ts\nvar document_type_default = {\n  translate(documentType) {\n    if (isOutputHTML()) {\n      writeTo(documentType)`<!${documentType.node.value}>`;\n    }\n    documentType.remove();\n  }\n};\n\n// src/visitors/assignment-expression.ts\nimport { types as t13 } from \"@marko/compiler\";\n\n// src/util/replace-assignments.ts\nvar assignmentReplacer = /* @__PURE__ */ new WeakMap();\nfunction getReplacement(assignment, value) {\n  return assignmentReplacer.get(assignment.node)?.(assignment, value);\n}\nfunction registerAssignmentReplacer(binding, map) {\n  for (const assignment of binding.constantViolations) {\n    assignmentReplacer.set(assignment.node, map);\n  }\n}\n\n// src/visitors/assignment-expression.ts\nvar assignment_expression_default = {\n  translate: {\n    exit(assignment) {\n      if (isOutputDOM()) {\n        const value = assignment.node.operator === \"=\" ? assignment.node.right : t13.binaryExpression(assignment.node.operator.slice(0, -1), assignment.node.left, assignment.node.right);\n        const replacement = getReplacement(assignment, value);\n        if (replacement) {\n          assignment.replaceWith(replacement);\n        }\n      }\n    }\n  }\n};\n\n// src/visitors/update-expression.ts\nimport { types as t14 } from \"@marko/compiler\";\nvar update_expression_default = {\n  translate: {\n    exit(assignment) {\n      if (isOutputDOM()) {\n        const value = t14.binaryExpression(assignment.node.operator === \"++\" ? \"+\" : \"-\", assignment.node.argument, t14.numericLiteral(1));\n        const replacement = getReplacement(assignment, value);\n        if (replacement) {\n          assignment.replaceWith(assignment.node.prefix || assignment.parentPath.isExpressionStatement() ? replacement : t14.sequenceExpression([replacement, assignment.node.argument]));\n        }\n      }\n    }\n  }\n};\n\n// src/visitors/declaration.ts\nvar declaration_default = {\n  translate(declaration) {\n    if (isOutputHTML()) {\n      writeTo(declaration)`<?${declaration.node.value}?>`;\n    }\n    declaration.remove();\n  }\n};\n\n// src/visitors/cdata.ts\nvar cdata_default = {\n  translate(cdata) {\n    if (isOutputHTML()) {\n      writeTo(cdata)`<![CDATA[${cdata.node.value}]]>`;\n    }\n    cdata.remove();\n  }\n};\n\n// src/visitors/text.ts\nimport { types as t15 } from \"@marko/compiler\";\nvar text_default = {\n  translate(text) {\n    const followingSiblings = text.container.slice(text.key + 1);\n    let needsSeparator = false;\n    if (isOutputHTML()) {\n      for (const sibling of followingSiblings) {\n        if (t15.isMarkoPlaceholder(sibling)) {\n          needsSeparator = true;\n          break;\n        } else if (t15.isMarkoTag(sibling) || t15.isMarkoText(sibling)) {\n          break;\n        }\n      }\n    }\n    writeTo(text)`${text.node.value}${needsSeparator ? \"<!>\" : \"\"}`;\n    enterShallow(text);\n    text.remove();\n  }\n};\n\n// src/visitors/tag/index.ts\nimport { types as t25 } from \"@marko/compiler\";\nimport {\n  assertNoArgs,\n  getTagDef as getTagDef3,\n  isNativeTag as isNativeTag2\n} from \"@marko/babel-utils\";\n\n// src/util/plugin-hooks.ts\nimport { types as t16 } from \"@marko/compiler\";\nfunction enter2(modulePlugin, path3) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path3;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (isFunctionPlugin(plugin)) {\n    plugin(path3, t16);\n  } else if (plugin.enter) {\n    plugin.enter(path3, t16);\n  }\n  return node !== path3.node;\n}\nfunction exit2(modulePlugin, path3) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path3;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (!isFunctionPlugin(plugin) && plugin.exit) {\n    plugin.exit(path3, t16);\n  }\n  return node !== path3.node;\n}\nfunction isModulePlugin(plugin) {\n  return Boolean(plugin.default);\n}\nfunction isFunctionPlugin(plugin) {\n  return typeof plugin === \"function\";\n}\n\n// src/visitors/tag/native-tag.ts\nimport { types as t20 } from \"@marko/compiler\";\nimport { getTagDef } from \"@marko/babel-utils\";\n\n// src/util/attrs-to-object.ts\nimport { types as t18 } from \"@marko/compiler\";\n\n// src/util/to-property-name.ts\nimport { types as t17 } from \"@marko/compiler\";\nvar IDENTIFIER_REG = /^[0-9A-Z_$]+$/i;\nfunction toPropertyName(name) {\n  return IDENTIFIER_REG.test(name) ? t17.identifier(name) : t17.stringLiteral(name);\n}\n\n// src/util/attrs-to-object.ts\nfunction attrsToObject(tag, withRenderBody = false) {\n  const { node } = tag;\n  let result = t18.objectExpression([]);\n  const resultExtra = result.extra = {};\n  for (const attr of node.attributes) {\n    const value = attr.value;\n    if (t18.isMarkoSpreadAttribute(attr)) {\n      result.properties.push(t18.spreadElement(value));\n    } else {\n      result.properties.push(t18.objectProperty(toPropertyName(attr.name), value));\n    }\n  }\n  if (withRenderBody) {\n    const { body, params } = node.body;\n    let hoistedControlFlows = node.extra.hoistedControlFlows;\n    if (hoistedControlFlows) {\n      for (const child of tag.get(\"body\").get(\"body\")) {\n        tag.insertBefore(child.node);\n        child.remove();\n        if (child.isConditional() || child.isLoop()) {\n          if (!--hoistedControlFlows) {\n            break;\n          }\n        }\n      }\n    }\n    if (body.length) {\n      result.properties.push(t18.objectMethod(\"method\", t18.identifier(\"renderBody\"), params, t18.blockStatement(body)));\n    }\n  }\n  if (result.properties.length) {\n    if (result.properties.length === 1) {\n      const [prop] = result.properties;\n      if (t18.isSpreadElement(prop)) {\n        result = prop.argument;\n        result.extra = resultExtra;\n      }\n    }\n    return result;\n  }\n}\nfunction getRenderBodyProp(attrsObject) {\n  if (t18.isObjectExpression(attrsObject)) {\n    const lastProp = attrsObject.properties[attrsObject.properties.length - 1];\n    if (t18.isObjectMethod(lastProp) && lastProp.key.name === \"renderBody\") {\n      return lastProp;\n    }\n  }\n}\n\n// src/util/translate-var.ts\nimport { types as t19 } from \"@marko/compiler\";\nfunction translateVar(tag, initialValue, kind = \"const\") {\n  const {\n    node: { var: tagVar }\n  } = tag;\n  if (!tagVar) {\n    return;\n  }\n  tag.get(\"var\").remove();\n  tag.insertBefore(t19.variableDeclaration(kind, [\n    t19.variableDeclarator(t19.cloneDeep(tagVar), initialValue)\n  ]));\n  tag.hub.file.path.scope.crawl();\n}\n\n// src/util/evaluate.ts\nfunction evaluate(path3) {\n  let { extra } = path3.node;\n  if (!extra) {\n    extra = path3.node.extra = {};\n  }\n  if (extra.confident === void 0) {\n    const value = path3.get(\"value\");\n    const { confident, value: computed } = value.evaluate();\n    extra.computed = computed;\n    extra.confident = confident;\n  }\n  return extra;\n}\n\n// src/visitors/tag/native-tag.ts\nvar native_tag_default = {\n  analyze: {\n    enter(tag) {\n      const { node } = tag;\n      const attrs = tag.get(\"attributes\");\n      let sectionId = tag.has(\"var\") ? getOrCreateSectionId(tag) : void 0;\n      if (attrs.some(isSpreadAttr)) {\n      } else {\n        for (const attr of attrs) {\n          const attrNode = attr.node;\n          const { name: name2 } = attrNode;\n          if (isEventHandler(name2)) {\n            sectionId ??= getOrCreateSectionId(tag);\n            (currentProgramPath.node.extra ?? {}).isInteractive = true;\n          } else if (!evaluate(attr).confident) {\n            sectionId ??= getOrCreateSectionId(tag);\n          }\n        }\n      }\n      const name = node.var ? node.var.name : node.name.value;\n      if (sectionId !== void 0) {\n        reserveScope(0 /* Visit */, sectionId, node, name, `#${node.name.value}`);\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { extra } = tag.node;\n      const isHTML = isOutputHTML();\n      const name = tag.get(\"name\");\n      const attrs = tag.get(\"attributes\");\n      const tagDef = getTagDef(tag);\n      const hasSpread = attrs.some((attr) => attr.isMarkoSpreadAttribute());\n      const write = writeTo(tag);\n      const sectionId = getSectionId(tag);\n      if (isHTML && extra.tagNameNullable) {\n        flushBefore(tag);\n      }\n      if (tag.has(\"var\")) {\n        if (isHTML) {\n          translateVar(tag, t20.arrowFunctionExpression([], t20.blockStatement([\n            t20.throwStatement(t20.newExpression(t20.identifier(\"Error\"), [\n              t20.stringLiteral(\"Cannot reference DOM node from server\")\n            ]))\n          ])));\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let createElFunction = void 0;\n          for (const reference of references) {\n            const referenceSectionId = getSectionId(reference);\n            if (reference.parentPath?.isCallExpression()) {\n              reference.parentPath.replaceWith(t20.expressionStatement(callRead(extra.reserve, referenceSectionId)));\n            } else {\n              createElFunction ??= t20.identifier(varName + \"_getter\");\n              reference.replaceWith(callRuntime(\"bind\", getScopeExpression(extra.reserve, referenceSectionId), createElFunction));\n            }\n          }\n          if (createElFunction) {\n            currentProgramPath.pushContainer(\"body\", t20.variableDeclaration(\"const\", [\n              t20.variableDeclarator(createElFunction, t20.arrowFunctionExpression([scopeIdentifier], t20.memberExpression(scopeIdentifier, getNodeLiteral(extra.reserve), true)))\n            ]));\n          }\n        }\n      }\n      let visitAccessor;\n      if (extra.reserve) {\n        visitAccessor = getNodeLiteral(extra.reserve);\n        visit(tag, 32 /* Get */);\n      }\n      write`<${name.node}`;\n      if (hasSpread) {\n        const attrsCallExpr = callRuntime(\"attrs\", scopeIdentifier, attrsToObject(tag));\n        if (isHTML) {\n          write`${attrsCallExpr}`;\n        } else {\n          tag.insertBefore(t20.expressionStatement(attrsCallExpr));\n        }\n      } else {\n        for (const attr of attrs) {\n          const name2 = attr.node.name;\n          const extra2 = attr.node.extra ?? {};\n          const value = attr.get(\"value\");\n          const { confident, computed, valueReferences } = extra2;\n          switch (name2) {\n            case \"class\":\n            case \"style\": {\n              const helper = `${name2}Attr`;\n              if (confident) {\n                write`${getHTMLRuntime()[helper](computed)}`;\n              } else if (isHTML) {\n                write`${callRuntime(helper, value.node)}`;\n              } else {\n                addStatement(\"apply\", sectionId, valueReferences, t20.expressionStatement(callRuntime(helper, t20.memberExpression(scopeIdentifier, visitAccessor, true), value.node)));\n              }\n              break;\n            }\n            default:\n              if (confident) {\n                write`${getHTMLRuntime().attr(name2, computed)}`;\n              } else if (isHTML) {\n                if (isEventHandler(name2)) {\n                  addHTMLHydrateCall(sectionId, valueReferences);\n                } else {\n                  write`${callRuntime(\"attr\", t20.stringLiteral(name2), value.node)}`;\n                }\n              } else if (isEventHandler(name2)) {\n                addStatement(\"hydrate\", sectionId, valueReferences, t20.expressionStatement(callRuntime(\"on\", t20.memberExpression(scopeIdentifier, visitAccessor, true), t20.stringLiteral(getEventHandlerName(name2)), value.node)), value.node);\n              } else {\n                addStatement(\"apply\", sectionId, valueReferences, t20.expressionStatement(callRuntime(\"attr\", t20.memberExpression(scopeIdentifier, visitAccessor, true), t20.stringLiteral(name2), value.node)));\n              }\n              break;\n          }\n        }\n      }\n      if (tagDef && tagDef.parseOptions?.openTagOnly) {\n        switch (tagDef.htmlType) {\n          case \"svg\":\n          case \"math\":\n            write`/>`;\n            break;\n          default:\n            write`>`;\n            break;\n        }\n      } else {\n        write`>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(t20.ifStatement(name.node, consumeHTML(tag)))[0].skip();\n      }\n      enter(tag);\n    },\n    exit(tag) {\n      const { extra } = tag.node;\n      const isHTML = isOutputHTML();\n      const openTagOnly = getTagDef(tag)?.parseOptions?.openTagOnly;\n      if (isHTML && extra.tagNameNullable) {\n        flushInto(tag);\n      }\n      tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n      if (!openTagOnly) {\n        writeTo(tag)`</${tag.node.name}>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(t20.ifStatement(tag.node.name, consumeHTML(tag)))[0].skip();\n      }\n      if (extra.reserve) {\n        markNode(tag);\n      }\n      exit(tag);\n      tag.remove();\n    }\n  }\n};\nfunction isSpreadAttr(attr) {\n  return attr.type === \"MarkoSpreadAttribute\";\n}\nfunction isEventHandler(propName) {\n  return /^on[A-Z-]/.test(propName);\n}\nfunction getEventHandlerName(propName) {\n  return propName.charAt(2) === \"-\" ? propName.slice(3) : propName.charAt(2).toLowerCase() + propName.slice(3);\n}\n\n// src/visitors/tag/custom-tag.ts\nimport { types as t21 } from \"@marko/compiler\";\nimport {\n  getTagDef as getTagDef2,\n  importNamed as importNamed2,\n  importDefault,\n  resolveRelativePath,\n  loadFileForTag\n} from \"@marko/babel-utils\";\nvar custom_tag_default = {\n  analyze: {\n    enter(tag) {\n      trackReferences(tag);\n      const body = tag.get(\"body\");\n      if (body.get(\"body\").length) {\n        startSection(body);\n      }\n      if (getTagDef2(tag)?.template) {\n        reserveScope(0 /* Visit */, getOrCreateSectionId(tag), tag.node, \"#childScope\");\n      }\n      const childFile = loadFileForTag(tag);\n      const childProgramExtra = childFile?.ast.program.extra;\n      const hasInteractiveChild = childProgramExtra?.isInteractive || childProgramExtra?.hasInteractiveChild;\n      if (hasInteractiveChild) {\n        (currentProgramPath.node.extra ?? {}).hasInteractiveChild = true;\n      }\n    },\n    exit(tag) {\n      const tagDef = getTagDef2(tag);\n      const template = tagDef?.template;\n      const sectionId = getOrCreateSectionId(tag);\n      if (template) {\n        tag.node.extra.attrsReferences = mergeReferenceGroups(sectionId, tag.node.attributes.filter((attr) => attr.extra?.valueReferences).map((attr) => [attr.extra, \"valueReferences\"]));\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML(tag);\n      } else {\n        translateDOM(tag);\n      }\n    }\n  }\n};\nfunction translateHTML(tag) {\n  const tagBody = tag.get(\"body\");\n  const { node } = tag;\n  let tagIdentifier;\n  flushInto(tag);\n  writeHTMLHydrateStatements(tagBody);\n  if (t21.isStringLiteral(node.name)) {\n    const { file } = tag.hub;\n    const tagName = node.name.value;\n    const relativePath = getTagRelativePath(tag);\n    tagIdentifier = importDefault(file, relativePath, tagName);\n  } else {\n    tagIdentifier = node.name;\n  }\n  const tagVar = node.var;\n  const attrsObject = attrsToObject(tag, true);\n  const renderBodyProp = getRenderBodyProp(attrsObject);\n  if (node.extra.tagNameNullable) {\n    let renderBodyId = void 0;\n    let renderTagExpr = callExpression(tagIdentifier, attrsToObject(tag));\n    if (renderBodyProp) {\n      renderBodyId = tag.scope.generateUidIdentifier(\"renderBody\");\n      const [renderBodyPath] = tag.insertBefore(t21.functionDeclaration(renderBodyId, renderBodyProp.params, renderBodyProp.body));\n      renderBodyPath.skip();\n      attrsObject.properties[attrsObject.properties.length - 1] = t21.objectProperty(t21.identifier(\"renderBody\"), renderBodyId);\n    }\n    if (tagVar) {\n      translateVar(tag, t21.unaryExpression(\"void\", t21.numericLiteral(0)), \"let\");\n      renderTagExpr = t21.assignmentExpression(\"=\", tagVar, renderTagExpr);\n    }\n    tag.replaceWith(t21.ifStatement(tagIdentifier, t21.expressionStatement(renderTagExpr), renderBodyId && callStatement(renderBodyId)))[0].skip();\n  } else if (tagVar) {\n    translateVar(tag, callExpression(tagIdentifier, attrsObject, callRuntime(\"register\", t21.arrowFunctionExpression([], t21.blockStatement([])), t21.stringLiteral(getHydrateRegisterId(getSectionId(tag), node.var.extra?.reserve)), scopeIdentifier)));\n    setForceHydrateScope(getSectionId(tag));\n    tag.remove();\n  } else {\n    tag.replaceWith(callStatement(tagIdentifier, attrsObject))[0].skip();\n  }\n}\nfunction translateDOM(tag) {\n  const tagSectionId = getSectionId(tag);\n  const tagBody = tag.get(\"body\");\n  const tagBodySectionId = getSectionId(tagBody);\n  const { node } = tag;\n  const write = writeTo(tag);\n  const binding = node.extra.reserve;\n  const { file } = tag.hub;\n  const tagName = node.name.value;\n  const relativePath = getTagRelativePath(tag);\n  const childFile = loadFileForTag(tag);\n  const childProgram = childFile.ast.program;\n  const tagIdentifier = importNamed2(file, relativePath, \"setup\", tagName);\n  let tagAttrsIdentifier;\n  if (childProgram.extra.attrs) {\n    tagAttrsIdentifier = importNamed2(file, relativePath, \"attrs\", `${tagName}_attrs`);\n  }\n  write`${importNamed2(file, relativePath, \"template\", `${tagName}_template`)}`;\n  injectWalks(tag, importNamed2(file, relativePath, \"walks\", `${tagName}_walks`));\n  if (childProgram.extra.closures) {\n    getClosures(tagSectionId).push(callRuntime(\"inChildMany\", importNamed2(file, relativePath, \"closures\", `${tagName}_closures`), getNodeLiteral(binding)));\n  }\n  let attrsObject = attrsToObject(tag);\n  if (tagBodySectionId !== tagSectionId) {\n    attrsObject ??= t21.objectExpression([]);\n    attrsObject.properties.push(t21.objectProperty(t21.identifier(\"renderBody\"), callRuntime(\"bindRenderer\", scopeIdentifier, getRenderer(tagBodySectionId))));\n  }\n  if (node.var) {\n    const source = initSource(node.var.extra.reserve);\n    source.register = true;\n    addStatement(\"apply\", tagSectionId, void 0, t21.expressionStatement(callRuntime(\"setTagVar\", scopeIdentifier, getNodeLiteral(binding), source.identifier)));\n  }\n  addStatement(\"apply\", tagSectionId, void 0, t21.expressionStatement(t21.callExpression(tagIdentifier, [callRead(binding, tagSectionId)])));\n  if (attrsObject && tagAttrsIdentifier) {\n    let attrsSubscriber = callRuntime(\"inChild\", tagAttrsIdentifier, getNodeLiteral(binding));\n    if (!tag.node.extra.attrsReferences.references) {\n      const tagAttrsIdentifierInChild = currentProgramPath.scope.generateUidIdentifier(`${tagName}_attrs_inChild`);\n      currentProgramPath.pushContainer(\"body\", t21.variableDeclaration(\"const\", [\n        t21.variableDeclarator(tagAttrsIdentifierInChild, attrsSubscriber)\n      ]));\n      attrsSubscriber = tagAttrsIdentifierInChild;\n    }\n    getSignal(tagSectionId, tag.node.extra.attrsReferences.references).subscribers.push(attrsSubscriber);\n    addStatement(\"apply\", tagSectionId, tag.node.extra.attrsReferences, t21.expressionStatement(callRuntime(\"setSource\", callRead(binding, tagSectionId), t21.identifier(tagAttrsIdentifier.name), attrsObject)));\n  }\n  tag.remove();\n}\nfunction getTagRelativePath(tag) {\n  const {\n    node,\n    hub: { file }\n  } = tag;\n  const nameIsString = t21.isStringLiteral(node.name);\n  let relativePath;\n  if (nameIsString) {\n    const tagDef = getTagDef2(tag);\n    const template = tagDef?.template;\n    relativePath = template && resolveRelativePath(file, template);\n  }\n  if (!relativePath) {\n    throw tag.get(\"name\").buildCodeFrameError(`Unable to find entry point for custom tag <${nameIsString ? node.name.value : node.name}>.`);\n  }\n  const tags = file.metadata.marko.tags;\n  if (!tags.includes(relativePath)) {\n    tags.push(relativePath);\n  }\n  return relativePath;\n}\nfunction callStatement(id, ...args) {\n  return t21.expressionStatement(callExpression(id, ...args));\n}\nfunction callExpression(id, ...args) {\n  return t21.callExpression(id, args.filter(Boolean));\n}\n\n// src/visitors/tag/dynamic-tag.ts\nimport { types as t23 } from \"@marko/compiler\";\n\n// src/util/to-first-expression-or-block.ts\nimport { types as t22 } from \"@marko/compiler\";\nfunction toFirstExpressionOrBlock(body) {\n  const nodes = body.body;\n  if (nodes.length === 1 && t22.isExpressionStatement(nodes[0])) {\n    return nodes[0].expression;\n  }\n  if (t22.isBlockStatement(body)) {\n    return body;\n  }\n  return t22.blockStatement(nodes);\n}\n\n// src/visitors/tag/dynamic-tag.ts\nvar dynamic_tag_default = {\n  analyze: {\n    enter(tag) {\n      reserveScope(0 /* Visit */, getOrCreateSectionId(tag), tag.node, \"dynamicTagName\", \"#text\");\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      tag.node.extra.attrsReferences = mergeReferenceGroups(getOrCreateSectionId(tag), tag.node.attributes.filter((attr) => attr.extra?.valueReferences).map((attr) => [attr.extra, \"valueReferences\"]));\n      updateReferenceGroup(tag, \"attrsReferences\", tag.node.extra.reserve);\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag, 37 /* Replace */);\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      if (isOutputHTML()) {\n        flushInto(tag);\n        const attrsObject = attrsToObject(tag, true);\n        const renderBodyProp = getRenderBodyProp(attrsObject);\n        const args = [\n          node.name,\n          attrsObject || t23.nullLiteral()\n        ];\n        if (renderBodyProp) {\n          attrsObject.properties.pop();\n          args.push(t23.arrowFunctionExpression(renderBodyProp.params, toFirstExpressionOrBlock(renderBodyProp.body)));\n        }\n        const dynamicTagExpr = callRuntime(\"dynamicTag\", ...args);\n        if (node.var) {\n          translateVar(tag, dynamicTagExpr);\n          tag.remove();\n        } else {\n          tag.replaceWith(t23.expressionStatement(dynamicTagExpr))[0].skip();\n        }\n      } else {\n        const sectionId = getSectionId(tag);\n        const bodySectionId = getSectionId(tag.get(\"body\"));\n        const hasBody = sectionId !== bodySectionId;\n        const renderBodyIdentifier = hasBody && getRenderer(bodySectionId);\n        const tagNameReserve = node.extra?.reserve;\n        const references = node.extra?.nameReferences?.references;\n        const signal = getSignal(sectionId, tagNameReserve);\n        signal.build = () => {\n          return callRuntime(\"conditional\", getNodeLiteral(tagNameReserve), t23.numericLiteral(countReserves(references) || 1), getComputeFn(sectionId, renderBodyIdentifier ? t23.logicalExpression(\"||\", node.name, renderBodyIdentifier) : node.name, references), signal.subscribers[0], t23.arrowFunctionExpression([scopeIdentifier], t23.blockStatement(signal.render)));\n        };\n        subscribe(references, signal);\n        const attrsObject = attrsToObject(tag, true);\n        if (attrsObject || renderBodyIdentifier) {\n          const attrsSignal = getSignal(sectionId, node.extra?.attrsReferences.references);\n          attrsSignal.subscribers.push(callRuntime(\"dynamicAttrsProxy\", getNodeLiteral(tagNameReserve)));\n          addStatement(\"apply\", sectionId, node.extra?.attrsReferences, t23.expressionStatement(callRuntime(\"dynamicTagAttrs\", scopeIdentifier, getNodeLiteral(tagNameReserve), t23.arrowFunctionExpression([], attrsObject ?? t23.objectExpression([])), renderBodyIdentifier)));\n        }\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/visitors/tag/attribute-tag.ts\nimport { types as t24 } from \"@marko/compiler\";\nimport { findParentTag, assertNoVar as assertNoVar2 } from \"@marko/babel-utils\";\nvar attribute_tag_default = {\n  translate: {\n    enter(tag) {\n      if (hasPendingHTML(tag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\"Dynamic @tags cannot be mixed with body content.\");\n      }\n    },\n    exit(tag) {\n      assertNoVar2(tag);\n      flushInto(tag);\n      const parentTag = findParentTag(tag);\n      if (!parentTag) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags must be nested within another tag.\");\n      }\n      const parentExtra = parentTag.node.extra;\n      if (parentExtra.tagNameType === 0 /* NativeTag */) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags cannot be nested under native tags.\");\n      }\n      const attrName = tag.node.name.value.slice(1);\n      const info = parentExtra.nestedAttributeTags[attrName];\n      const attrsObject = attrsToObject(tag, true) || t24.objectExpression([]);\n      if (info.dynamic) {\n        if (!info.identifier) {\n          info.identifier = parentTag.scope.generateUidIdentifier(attrName);\n          parentTag.insertBefore(info.repeated ? t24.variableDeclaration(\"const\", [\n            t24.variableDeclarator(info.identifier, t24.arrayExpression([]))\n          ]) : t24.variableDeclaration(\"let\", [\n            t24.variableDeclarator(info.identifier)\n          ]));\n          parentTag.pushContainer(\"attributes\", t24.markoAttribute(attrName, info.identifier));\n        }\n        tag.replaceWith(t24.expressionStatement(info.repeated ? t24.callExpression(t24.memberExpression(info.identifier, t24.identifier(\"push\")), [attrsObject]) : t24.assignmentExpression(\"=\", info.identifier, attrsObject)));\n      } else if (info.repeated) {\n        const existingAttr = parentTag.get(\"attributes\").find((attr) => attr.node.name === attrName);\n        if (existingAttr) {\n          existingAttr.get(\"value\").pushContainer(\"elements\", attrsObject);\n        } else {\n          parentTag.pushContainer(\"attributes\", t24.markoAttribute(attrName, t24.arrayExpression([attrsObject])));\n        }\n        tag.remove();\n      } else {\n        parentTag.pushContainer(\"attributes\", t24.markoAttribute(attrName, attrsObject));\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/util/nested-attribute-tags.ts\nimport {\n  isAttributeTag,\n  isTransparentTag,\n  isLoopTag\n} from \"@marko/babel-utils\";\nfunction analyzeAttributeTags(tag) {\n  const { extra } = tag.node;\n  extra.nestedAttributeTags = {};\n  extra.hoistedControlFlows = 0;\n  analyzeChildren(extra, false, false, tag);\n}\nfunction analyzeChildren(rootExtra, repeated, dynamic, tag) {\n  let hasAttributeTags = false;\n  for (const child of tag.get(\"body\").get(\"body\")) {\n    if (child.isMarkoTag()) {\n      if (analyzeChild(rootExtra, repeated, dynamic, child)) {\n        hasAttributeTags = true;\n      }\n    }\n  }\n  return hasAttributeTags;\n}\nfunction analyzeChild(rootExtra, repeated, dynamic, tag) {\n  if (isTransparentTag(tag)) {\n    if (analyzeChildren(rootExtra, repeated || isLoopTag(tag), true, tag)) {\n      if (!isTransparentTag(tag.parentPath.parentPath)) {\n        rootExtra.hoistedControlFlows++;\n      }\n      return true;\n    }\n  } else if (isAttributeTag(tag)) {\n    const attrName = tag.node.name.value.slice(1);\n    const lookup = rootExtra.nestedAttributeTags;\n    const existing = lookup[attrName];\n    const info = existing || (lookup[attrName] = {\n      dynamic: false,\n      repeated: false\n    });\n    info.dynamic ||= dynamic;\n    info.repeated ||= repeated || existing !== void 0;\n    return true;\n  }\n  return false;\n}\n\n// src/visitors/tag/index.ts\nvar tag_default = {\n  analyze: {\n    enter(tag) {\n      const tagDef = getTagDef3(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        enter2(hook, tag);\n        return;\n      }\n      switch (type) {\n        case 0 /* NativeTag */:\n          native_tag_default.analyze.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.analyze.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const tagDef = getTagDef3(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        exit2(hook, tag);\n        return;\n      }\n      if (type === 0 /* NativeTag */) {\n        return;\n      }\n      analyzeAttributeTags(tag);\n      switch (type) {\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.analyze.exit(tag);\n          break;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagDef = getTagDef3(tag);\n      const extra = tag.node.extra;\n      assertNoArgs(tag);\n      if (tagDef?.translator) {\n        if (tagDef.translator.path) {\n          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);\n        }\n        enter2(tagDef.translator.hook, tag);\n        return;\n      }\n      for (const attr of tag.get(\"attributes\")) {\n        if (attr.isMarkoAttribute()) {\n          if (attr.node.arguments) {\n            throw attr.buildCodeFrameError(`Unsupported arguments on the \"${attr.node.name}\" attribute.`);\n          }\n          if (attr.node.modifier) {\n            if (isNativeTag2(attr.parentPath)) {\n              attr.node.name += `:${attr.node.modifier}`;\n            } else {\n              throw attr.buildCodeFrameError(`Unsupported modifier \"${attr.node.modifier}\".`);\n            }\n          }\n        }\n      }\n      if (extra.tagNameDynamic && extra.tagNameNullable && !tag.get(\"name\").isIdentifier() && isOutputHTML()) {\n        const tagNameId = tag.scope.generateUidIdentifier(\"tagName\");\n        const [tagNameVarPath] = tag.insertBefore(t25.variableDeclaration(\"const\", [\n          t25.variableDeclarator(tagNameId, tag.node.name)\n        ]));\n        tagNameVarPath.skip();\n        tag.set(\"name\", tagNameId);\n      }\n      switch (extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const translator = getTagDef3(tag)?.translator;\n      if (translator) {\n        exit2(translator.hook, tag);\n        return;\n      }\n      switch (tag.node.extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.exit(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.exit(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.exit(tag);\n          break;\n      }\n    }\n  }\n};\n\n// src/visitors/placeholder.ts\nimport { types as t26 } from \"@marko/compiler\";\nimport { isNativeTag as isNativeTag3 } from \"@marko/babel-utils\";\n\n// src/util/is-core-tag.ts\nimport { getTagDef as getTagDef4 } from \"@marko/babel-utils\";\nvar taglibId = \"marko-core\";\nfunction isCoreTag(tag) {\n  return tag.isMarkoTag() && getTagDef4(tag)?.taglibId === taglibId;\n}\nfunction isCoreTagName(tag, name) {\n  return isCoreTag(tag) && tag.node.name.value === name;\n}\n\n// src/visitors/placeholder.ts\nvar ESCAPE_TYPES = {\n  script: \"escapeScript\",\n  style: \"escapeStyle\"\n};\nvar placeholder_default = {\n  analyze(placeholder) {\n    const { node } = placeholder;\n    const { confident, computed } = evaluate(placeholder);\n    if (!(confident && (node.escape || !computed))) {\n      reserveScope(0 /* Visit */, getOrCreateSectionId(placeholder), node, \"placeholder\", \"#text\");\n      needsMarker(placeholder);\n    }\n  },\n  translate(placeholder) {\n    const isHTML = isOutputHTML();\n    const write = writeTo(placeholder);\n    const extra = placeholder.node.extra;\n    const { confident, computed, valueReferences, reserve } = extra;\n    const canWriteHTML = isHTML || confident && (placeholder.node.escape || !computed);\n    const method = canWriteHTML ? placeholder.node.escape ? ESCAPE_TYPES[getParentTagName(placeholder)] || \"escapeXML\" : \"toString\" : placeholder.node.escape ? \"data\" : \"html\";\n    if (confident && canWriteHTML) {\n      write`${getHTMLRuntime()[method](computed)}`;\n    } else {\n      if (extra.needsMarker) {\n        visit(placeholder, 37 /* Replace */);\n      } else {\n        if (!isHTML)\n          write` `;\n        visit(placeholder, 32 /* Get */);\n      }\n      if (isHTML) {\n        write`${callRuntime(method, placeholder.node.value)}`;\n        markNode(placeholder);\n      } else {\n        addStatement(\"apply\", getSectionId(placeholder), valueReferences, t26.expressionStatement(method === \"data\" ? callRuntime(\"data\", t26.memberExpression(scopeIdentifier, getNodeLiteral(reserve), true), placeholder.node.value) : callRuntime(\"html\", scopeIdentifier, placeholder.node.value, getNodeLiteral(reserve))));\n      }\n    }\n    enterShallow(placeholder);\n    placeholder.remove();\n  }\n};\nfunction getParentTagName({ parentPath }) {\n  return parentPath.isMarkoTag() && isNativeTag3(parentPath) && parentPath.node.name.value || \"\";\n}\nfunction noOutput(path3) {\n  return t26.isMarkoComment(path3) || t26.isMarkoTag(path3) && isCoreTag(path3) && [\"let\", \"const\", \"effect\", \"lifecycle\", \"attrs\", \"get\", \"id\"].includes(path3.node.name.value);\n}\nfunction needsMarker(placeholder) {\n  let prev = placeholder.getPrevSibling();\n  while (prev.node && noOutput(prev)) {\n    prev = prev.getPrevSibling();\n  }\n  if ((prev.node || t26.isProgram(placeholder.parentPath)) && !(t26.isMarkoTag(prev) && isNativeTag3(prev))) {\n    return placeholder.node.extra.needsMarker = true;\n  }\n  let next = placeholder.getNextSibling();\n  while (next.node && noOutput(next)) {\n    next = next.getNextSibling();\n  }\n  if ((next.node || t26.isProgram(placeholder.parentPath)) && !(t26.isMarkoTag(next) && isNativeTag3(next))) {\n    return placeholder.node.extra.needsMarker = true;\n  }\n  return placeholder.node.extra.needsMarker = false;\n}\n\n// src/visitors/scriptlet.ts\nvar scriptlet_default = {\n  translate(scriptlet) {\n    if (isOutputHTML()) {\n      if (scriptlet.node.static)\n        return;\n      scriptlet.replaceWithMultiple(scriptlet.node.body);\n    } else {\n      if (scriptlet.node.static) {\n        scriptlet.replaceWithMultiple(scriptlet.node.body);\n      } else {\n        addStatement(\"apply\", getSectionId(scriptlet), scriptlet.node.extra?.bodyReferences, scriptlet.node.body);\n        scriptlet.remove();\n      }\n    }\n  }\n};\n\n// src/visitors/comment.ts\nvar ieConditionalCommentRegExp = /^\\[if |<!\\[endif\\]$/;\nvar comment_default = {\n  translate(comment) {\n    if (isOutputHTML()) {\n      const { value } = comment.node;\n      if (ieConditionalCommentRegExp.test(value)) {\n        writeTo(comment)`<!--${value}-->`;\n      }\n    }\n    comment.remove();\n  }\n};\n\n// src/core/import.ts\nimport { parseScript } from \"@marko/babel-utils\";\nvar import_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(parseScript(tag.hub.file, node.rawValue, node.start).body[0]);\n  },\n  parseOptions: {\n    rootOnly: true,\n    rawOpenTag: true,\n    openTagOnly: true,\n    ignoreAttributes: true,\n    relaxRequireCommas: true\n  },\n  autocomplete: [\n    {\n      displayText: 'import <scope> from \"<path>\"',\n      description: \"Use to import external modules, follows the same syntax as JavaScript imports.\",\n      snippet: 'import ${2} from \"${1:path}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#importing-external-files\"\n    }\n  ]\n};\n\n// src/core/export.ts\nimport { parseScript as parseScript2 } from \"@marko/babel-utils\";\nvar export_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(parseScript2(tag.hub.file, node.rawValue, node.start).body[0]);\n  },\n  parseOptions: {\n    rootOnly: true,\n    rawOpenTag: true,\n    openTagOnly: true,\n    ignoreAttributes: true,\n    relaxRequireCommas: true\n  },\n  autocomplete: [\n    {\n      displayText: \"export <value>\"\n    }\n  ]\n};\n\n// src/core/attrs.ts\nvar attrs_default = {\n  analyze(tag) {\n    if (tag.has(\"var\")) {\n      const varPath = tag.get(\"var\");\n      const bindings = varPath.getBindingIdentifiers();\n      const sectionId = getOrCreateSectionId(tag);\n      trackReferencesForBindings(sectionId, varPath, 1 /* Store */);\n      for (const key in bindings) {\n        const binding = bindings[key].extra.reserve;\n        binding.exportIdentifier = getReferenceGroup(sectionId, binding, true).apply;\n      }\n      (currentProgramPath.node.extra ??= {}).attrs = {\n        bindings,\n        var: varPath.node\n      };\n    }\n  },\n  translate(tag) {\n    const bindings = currentProgramPath.node.extra?.attrs?.bindings;\n    if (bindings) {\n      for (const key in bindings) {\n        initSource(bindings[key].extra.reserve);\n      }\n    }\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"attrs/{ ... }\",\n      description: \"Use to receive the attributes passed into this template.\",\n      snippet: \"attrs/{ $1 }$2\"\n    }\n  ]\n};\n\n// src/core/condition/if.ts\nimport { types as t28 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams2, assertNoVar as assertNoVar3 } from \"@marko/babel-utils\";\n\n// src/util/to-first-statement-or-block.ts\nimport { types as t27 } from \"@marko/compiler\";\nfunction toFirstStatementOrBlock(body) {\n  const nodes = body.body;\n  if (nodes.length === 1) {\n    return nodes[0];\n  }\n  if (t27.isBlockStatement(body)) {\n    return body;\n  }\n  return t27.blockStatement(nodes);\n}\n\n// src/core/condition/if.ts\nvar if_default = {\n  analyze: {\n    enter(tag) {\n      reserveScope(0 /* Visit */, getOrCreateSectionId(tag), tag.node, \"if\", \"#text\");\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      analyzeAttributeTags(tag);\n      exitBranchAnalyze(tag);\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [testAttr] = node.attributes;\n      assertNoVar3(tag);\n      assertNoParams2(tag);\n      if (!t28.isMarkoAttribute(testAttr) || !testAttr.default) {\n        throw tag.get(\"name\").buildCodeFrameError(`The '<if>' tag requires a default attribute like '<if=condition>'.`);\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<if>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n        }\n      }\n      visit(tag, 37 /* Replace */);\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      exitBranchTranslate(tag);\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      snippet: \"if=${1:condition}\",\n      description: \"Use to display content only if the condition is met.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar BRANCHES_LOOKUP = /* @__PURE__ */ new WeakMap();\nfunction getBranches(tag, bodySectionId) {\n  const branches = BRANCHES_LOOKUP.get(tag) ?? [];\n  const nextTag = tag.getNextSibling();\n  const isLast = !(isCoreTagName(nextTag, \"else\") || isCoreTagName(nextTag, \"else-if\"));\n  branches.push({\n    tag,\n    sectionId: bodySectionId\n  });\n  if (!isLast) {\n    BRANCHES_LOOKUP.set(nextTag, branches);\n  }\n  return [isLast, branches];\n}\nfunction exitBranchAnalyze(tag) {\n  const sectionId = getOrCreateSectionId(tag);\n  const tagBody = tag.get(\"body\");\n  const bodySectionId = getOrCreateSectionId(tagBody);\n  const [isLast, branches] = getBranches(tag, bodySectionId);\n  if (isLast) {\n    branches[0].tag.node.extra.conditionalReferences = mergeReferenceGroups(sectionId, branches.filter(({ tag: tag2 }) => tag2.node.attributes[0]?.extra?.valueReferences).map(({ tag: tag2 }) => [tag2.node.attributes[0].extra, \"valueReferences\"]));\n  }\n}\nfunction exitBranchTranslate(tag) {\n  const tagBody = tag.get(\"body\");\n  const bodySectionId = getSectionId(tagBody);\n  const [isLast, branches] = getBranches(tag, bodySectionId);\n  if (isOutputHTML()) {\n    flushInto(tag);\n    writeHTMLHydrateStatements(tagBody);\n  }\n  if (isLast) {\n    if (isOutputDOM()) {\n      const sectionId = getSectionId(tag);\n      const { extra } = branches[0].tag.node;\n      let expr = t28.nullLiteral();\n      for (let i = branches.length; i--; ) {\n        const { tag: tag2, sectionId: sectionId2 } = branches[i];\n        const [testAttr] = tag2.node.attributes;\n        const id = getRenderer(sectionId2);\n        setSubscriberBuilder(tag2, (subscriber) => {\n          return callRuntime(\"inConditionalScope\", subscriber, getNodeLiteral(extra.reserve));\n        });\n        tag2.remove();\n        if (testAttr) {\n          expr = t28.conditionalExpression(testAttr.value, id, expr);\n        } else {\n          expr = id;\n        }\n      }\n      const references = extra.conditionalReferences.references;\n      const signal = getSignal(sectionId, extra.reserve);\n      signal.build = () => {\n        return callRuntime(\"conditional\", getNodeLiteral(extra.reserve), t28.numericLiteral(countReserves(references) || 1), getComputeFn(sectionId, expr, references));\n      };\n      subscribe(references, signal);\n    } else {\n      const nextTag = tag.getNextSibling();\n      let statement;\n      for (let i = branches.length; i--; ) {\n        const { tag: tag2 } = branches[i];\n        const [testAttr] = tag2.node.attributes;\n        const curStatement = toFirstStatementOrBlock(tag2.node.body);\n        if (testAttr) {\n          statement = t28.ifStatement(testAttr.value, curStatement, statement);\n        } else {\n          statement = curStatement;\n        }\n        tag2.remove();\n      }\n      nextTag.insertBefore(statement);\n    }\n  }\n}\n\n// src/core/condition/else-if.ts\nimport { types as t29 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams3, assertNoVar as assertNoVar4 } from \"@marko/babel-utils\";\nvar else_if_default = {\n  analyze: {\n    enter(tag) {\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      exitBranchAnalyze(tag);\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [defaultAttr] = node.attributes;\n      assertNoVar4(tag);\n      assertNoParams3(tag);\n      if (!t29.isMarkoAttribute(defaultAttr) || !defaultAttr.default) {\n        throw tag.get(\"name\").buildCodeFrameError(`The '<else-if>' tag requires a default attribute like '<else-if=condition>'.`);\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<else-if>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n        }\n      }\n    },\n    exit(tag) {\n      exitBranchTranslate(tag);\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      snippet: \"else-if=${1:condition}\",\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\n\n// src/core/condition/else.ts\nimport { assertNoParams as assertNoParams4, assertNoVar as assertNoVar5 } from \"@marko/babel-utils\";\nvar else_default = {\n  analyze: {\n    enter(tag) {\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      exitBranchAnalyze(tag);\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [testAttr] = node.attributes;\n      assertNoVar5(tag);\n      assertNoParams4(tag);\n      if (node.attributes.length > 1 || testAttr && testAttr.name !== \"if\") {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<else>' tag only supports an if attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n        }\n      }\n    },\n    exit(tag) {\n      exitBranchTranslate(tag);\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\n\n// src/core/const.ts\nimport { types as t30 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams5 } from \"@marko/babel-utils\";\nvar const_default = {\n  translate(tag) {\n    const { node } = tag;\n    const [defaultAttr] = node.attributes;\n    assertNoParams5(tag);\n    assertNoBodyContent(tag);\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'const' tag requires a tag variable.\");\n    }\n    if (!defaultAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'const' tag requires a default attribute.\");\n    }\n    if (node.attributes.length > 1 || !t30.isMarkoAttribute(defaultAttr) || !defaultAttr.default && defaultAttr.name !== \"default\") {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'const' tag only supports the 'default' attribute.\");\n    }\n    if (isOutputDOM()) {\n      const identifiers = Object.values(tag.get(\"var\").getBindingIdentifiers());\n      if (identifiers.length === 1) {\n        initDerivation(identifiers[0].extra.reserve, defaultAttr.extra?.valueReferences?.references, defaultAttr.value);\n      } else {\n      }\n    } else {\n      translateVar(tag, defaultAttr.value);\n    }\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an constant binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#const\"\n    }\n  ]\n};\n\n// src/core/effect.ts\nimport { types as t31 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams6 } from \"@marko/babel-utils\";\nvar effect_default = {\n  analyze(tag) {\n    const sectionId = getSectionId(tag);\n    reserveScope(1 /* Store */, sectionId, tag.node, \"cleanup\");\n    (currentProgramPath.node.extra ?? {}).isInteractive = true;\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [defaultAttr] = node.attributes;\n      assertNoParams6(tag);\n      assertNoBodyContent(tag);\n      if (!defaultAttr) {\n        throw tag.get(\"name\").buildCodeFrameError(\"The 'effect' tag requires a default attribute.\");\n      }\n      if (node.attributes.length > 1 || !t31.isMarkoAttribute(defaultAttr) || !defaultAttr.default && defaultAttr.name !== \"default\") {\n        throw tag.get(\"name\").buildCodeFrameError(\"The 'effect' tag only supports the 'default' attribute.\");\n      }\n      const sectionId = getSectionId(tag);\n      if (isOutputDOM()) {\n        const { value } = defaultAttr;\n        let inlineStatements = null;\n        if (t31.isFunctionExpression(value) || t31.isArrowFunctionExpression(value) && t31.isBlockStatement(value.body)) {\n          inlineStatements = value.body.body;\n          t31.traverse(value.body, (node2) => {\n            if (t31.isReturnStatement(node2)) {\n              inlineStatements = null;\n            }\n          });\n        }\n        addStatement(\"hydrate\", sectionId, defaultAttr.extra?.valueReferences, inlineStatements || t31.expressionStatement(callRuntime(\"userEffect\", scopeIdentifier, getNodeLiteral(tag.node.extra.reserve), defaultAttr.value)), value, !!inlineStatements);\n      } else {\n        addHTMLHydrateCall(sectionId, defaultAttr.extra?.valueReferences);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ]\n};\n\n// src/core/lifecycle.ts\nimport { types as t32 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams7 } from \"@marko/babel-utils\";\nvar lifecycle_default = {\n  analyze: {\n    enter(tag) {\n      custom_tag_default.analyze.enter(tag);\n      const sectionId = getSectionId(tag);\n      reserveScope(1 /* Store */, sectionId, tag.node, \"cleanup\");\n      (currentProgramPath.node.extra ?? {}).isInteractive = true;\n    },\n    exit(tag) {\n      custom_tag_default.analyze.exit(tag);\n      const sectionId = getOrCreateSectionId(tag);\n      tag.node.extra.attrsReferences = mergeReferenceGroups(sectionId, tag.node.attributes.filter((attr) => attr.extra?.valueReferences).map((attr) => [attr.extra, \"valueReferences\"]));\n    }\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      assertNoParams7(tag);\n      assertNoBodyContent(tag);\n      const sectionId = getSectionId(tag);\n      if (isOutputDOM()) {\n        const attrsObject = attrsToObject(tag);\n        addStatement(\"hydrate\", sectionId, node.extra.attrsReferences, t32.expressionStatement(callRuntime(\"lifecycle\", scopeIdentifier, getNodeLiteral(tag.node.extra.reserve), attrsObject)), node.attributes.map((a) => a.value));\n      } else {\n        addHTMLHydrateCall(sectionId, node.extra.attrsReferences);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ]\n};\n\n// src/core/id.ts\nimport { types as t33 } from \"@marko/compiler\";\nimport {\n  assertNoArgs as assertNoArgs2,\n  assertNoAttributes,\n  assertNoParams as assertNoParams8\n} from \"@marko/babel-utils\";\nvar id_default = {\n  translate(tag) {\n    const { node } = tag;\n    const { var: tagVar } = node;\n    const id = callRuntime(\"nextTagId\");\n    assertNoArgs2(tag);\n    assertNoAttributes(tag);\n    assertNoBodyContent(tag);\n    assertNoParams8(tag);\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'id' tag requires a tag variable.\");\n    }\n    if (!t33.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The 'id' tag cannot be destructured\");\n    }\n    if (isOutputHTML()) {\n      tag.replaceWith(t33.variableDeclaration(\"const\", [t33.variableDeclarator(node.var, id)]));\n    } else {\n      initDerivation(tagVar.extra.reserve, void 0, id);\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"id/<name>\",\n      description: \"Use to create a unique identifier.\",\n      snippet: \"id/${1:name}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#id\"\n    }\n  ]\n};\n\n// src/core/for.ts\nimport { types as t34 } from \"@marko/compiler\";\nimport {\n  assertAllowedAttributes,\n  assertNoVar as assertNoVar6,\n  getTagDef as getTagDef5\n} from \"@marko/babel-utils\";\nvar for_default = {\n  analyze: {\n    enter(tag) {\n      const isOnlyChild = checkOnlyChild(tag);\n      const parentTag = isOnlyChild ? tag.parentPath.parent : void 0;\n      const parentTagName = parentTag?.name?.value;\n      reserveScope(0 /* Visit */, getOrCreateSectionId(tag), isOnlyChild ? parentTag : tag.node, \"for\", isOnlyChild ? `#${parentTagName}` : \"#text\");\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      analyzeAttributeTags(tag);\n    }\n  },\n  translate: {\n    enter(tag) {\n      validateFor(tag);\n      if (!isOutputHTML() && Object.keys(tag.node.extra.nestedAttributeTags).length) {\n        tag.remove();\n        return;\n      }\n      const {\n        extra: { isOnlyChild }\n      } = tag.node;\n      if (!isOnlyChild) {\n        visit(tag, 37 /* Replace */);\n        enterShallow(tag);\n      }\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML2.exit(tag);\n      } else {\n        translateDOM2.exit(tag);\n      }\n    }\n  },\n  attributes: {\n    of: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over a list of items.\"\n        }\n      ]\n    },\n    in: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over the keys and values of an object.\"\n        }\n      ]\n    },\n    to: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates up to the provided number (inclusive)\"\n        }\n      ]\n    },\n    from: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates starting from the provided number (inclusive)\"\n        }\n      ]\n    },\n    step: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"The amount to increment during each interation (with from/to)\"\n        }\n      ]\n    }\n  },\n  autocomplete: [\n    {\n      snippet: \"for|${1:value, index}| of=${3:array}\",\n      description: \"Use to iterate over lists, object properties, or between ranges.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-a-list\"\n    },\n    {\n      snippet: \"for|${1:name, value}| in=${3:object}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties\"\n    },\n    {\n      snippet: \"for|${1:index}| from=${2:number} to=${3:number} step=${4:number}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers\"\n    }\n  ]\n};\nvar translateDOM2 = {\n  exit(tag) {\n    const bodySectionId = getSectionId(tag.get(\"body\"));\n    const sectionId = getSectionId(tag);\n    const { node } = tag;\n    const {\n      attributes,\n      body: { params },\n      extra: { isOnlyChild }\n    } = node;\n    const paramsPath = tag.get(\"body\").get(\"params\");\n    const {\n      extra: { reserve }\n    } = isOnlyChild ? tag.parentPath.parent : tag.node;\n    const ofAttr = findName(attributes, \"of\");\n    const byAttr = findName(attributes, \"by\");\n    setSubscriberBuilder(tag, (signal) => {\n      return callRuntime(\"inLoopScope\", signal, getNodeLiteral(reserve));\n    });\n    if (ofAttr) {\n      const ofAttrValue = ofAttr.value;\n      const [valParam] = params;\n      if (!t34.isIdentifier(valParam)) {\n        throw tag.buildCodeFrameError(`Invalid 'for of' tag, |value| parameter must be an identifier.`);\n      }\n      const rendererId = getRenderer(bodySectionId);\n      tag.remove();\n      const references = ofAttr.extra?.valueReferences?.references;\n      const signal = getSignal(sectionId, reserve);\n      signal.build = () => {\n        const bindings = paramsPath.reduce((paramsLookup, param) => {\n          return Object.assign(paramsLookup, param.getBindingIdentifiers());\n        }, {});\n        return callRuntime(\"loop\", getNodeLiteral(reserve), t34.numericLiteral(countReserves(references) || 1), rendererId, t34.arrayExpression(Object.values(bindings).map((binding) => getSignal(bodySectionId, binding.extra.reserve).identifier)), t34.arrowFunctionExpression([scopeIdentifier, t34.arrayPattern(params)], t34.blockStatement(Object.values(bindings).map((binding) => {\n          return t34.expressionStatement(callRuntime(\"setSource\", scopeIdentifier, getSignal(bodySectionId, binding.extra.reserve).identifier, binding));\n        }))), getComputeFn(sectionId, t34.arrayExpression([\n          ofAttrValue,\n          byAttr ? byAttr.value : t34.nullLiteral()\n        ]), references));\n      };\n      subscribe(references, signal);\n      for (const param of params) {\n        initSource(param.extra?.reserve);\n      }\n    }\n  }\n};\nvar translateHTML2 = {\n  exit(tag) {\n    const tagBody = tag.get(\"body\");\n    const { node } = tag;\n    const {\n      attributes,\n      body: { body, params }\n    } = node;\n    const namePath = tag.get(\"name\");\n    const ofAttr = findName(attributes, \"of\");\n    const inAttr = findName(attributes, \"in\");\n    const fromAttr = findName(attributes, \"from\");\n    const toAttr = findName(attributes, \"to\");\n    const block = t34.blockStatement(body);\n    let forNode;\n    flushInto(tag);\n    writeHTMLHydrateStatements(tagBody);\n    if (inAttr) {\n      const [keyParam, valParam] = params;\n      if (valParam) {\n        block.body.unshift(t34.variableDeclaration(\"const\", [\n          t34.variableDeclarator(valParam, t34.memberExpression(inAttr.value, keyParam, true))\n        ]));\n      }\n      forNode = t34.forInStatement(t34.variableDeclaration(\"const\", [t34.variableDeclarator(keyParam)]), inAttr.value, block);\n    } else if (ofAttr) {\n      let ofAttrValue = ofAttr.value;\n      const [valParam, keyParam, loopParam] = params;\n      if (!valParam) {\n        throw namePath.buildCodeFrameError(\"Invalid 'for of' tag, missing |value, index| params.\");\n      }\n      forNode = [];\n      if (keyParam) {\n        const indexName = tag.scope.generateUidIdentifierBasedOnNode(keyParam, \"i\");\n        forNode.push(t34.variableDeclaration(\"let\", [\n          t34.variableDeclarator(indexName, t34.numericLiteral(0))\n        ]));\n        block.body.unshift(t34.variableDeclaration(\"let\", [\n          t34.variableDeclarator(keyParam, t34.updateExpression(\"++\", indexName))\n        ]));\n      }\n      if (loopParam) {\n        if (t34.isIdentifier(loopParam)) {\n          ofAttrValue = loopParam;\n        }\n        forNode.push(t34.variableDeclaration(\"const\", [\n          t34.variableDeclarator(loopParam, ofAttr.value)\n        ]));\n      }\n      forNode.push(t34.forOfStatement(t34.variableDeclaration(\"const\", [t34.variableDeclarator(valParam)]), ofAttrValue, block));\n    } else if (fromAttr && toAttr) {\n      const stepAttr = findName(attributes, \"step\") || {\n        value: t34.numericLiteral(1)\n      };\n      const stepValue = stepAttr ? stepAttr.value : t34.numericLiteral(1);\n      const [indexParam] = params;\n      const stepsName = tag.scope.generateUidIdentifier(\"steps\");\n      const stepName = tag.scope.generateUidIdentifier(\"step\");\n      if (indexParam) {\n        block.body.unshift(t34.variableDeclaration(\"const\", [\n          t34.variableDeclarator(indexParam, t34.binaryExpression(\"+\", fromAttr.value, t34.binaryExpression(\"*\", stepName, stepValue)))\n        ]));\n      }\n      forNode = t34.forStatement(t34.variableDeclaration(\"let\", [\n        t34.variableDeclarator(stepsName, t34.binaryExpression(\"/\", t34.binaryExpression(\"-\", toAttr.value, fromAttr.value), stepValue)),\n        t34.variableDeclarator(stepName, t34.numericLiteral(0))\n      ]), t34.binaryExpression(\"<=\", stepName, stepsName), t34.updateExpression(\"++\", stepName), block);\n    }\n    block.body.push(t34.expressionStatement(callRuntime(\"maybeFlush\")));\n    tag.replaceWithMultiple([].concat(forNode));\n  }\n};\nfunction findName(arr, value) {\n  return arr.find((obj) => t34.isMarkoAttribute(obj) && obj.name === value);\n}\nfunction validateFor(tag) {\n  const attrs = tag.node.attributes;\n  const hasParams = tag.node.body.params.length > 0;\n  assertNoVar6(tag);\n  if (findName(attrs, \"of\")) {\n    assertAllowedAttributes(tag, [\"of\", \"by\"]);\n    if (!hasParams) {\n      throw tag.buildCodeFrameError(`Invalid 'for of' tag, missing |value, index| params.`);\n    }\n  } else if (findName(attrs, \"in\")) {\n    assertAllowedAttributes(tag, [\"in\", \"by\"]);\n    if (!hasParams) {\n      throw tag.buildCodeFrameError(`Invalid 'for in' tag, missing |key, value| params.`);\n    }\n  } else if (findName(attrs, \"from\") && findName(attrs, \"to\")) {\n    assertAllowedAttributes(tag, [\"from\", \"to\", \"step\", \"by\"]);\n  } else {\n    throw tag.buildCodeFrameError(\"Invalid 'for' tag, missing an 'of', 'in' or 'to' attribute.\");\n  }\n}\nfunction checkOnlyChild(tag) {\n  tag.node.extra ??= {};\n  if (t34.isMarkoTag(tag.parentPath?.parent) && getTagDef5(tag.parentPath.parentPath)?.html) {\n    return tag.node.extra.isOnlyChild = tag.parent.body.length === 1;\n  }\n  return tag.node.extra.isOnlyChild = false;\n}\n\n// src/core/get.ts\nimport path from \"path\";\nimport { types as t35 } from \"@marko/compiler\";\nimport {\n  resolveTagImport as resolveTagImport2,\n  getTemplateId as getTemplateId2,\n  assertNoParams as assertNoParams9\n} from \"@marko/babel-utils\";\nvar get_default = {\n  analyze: {\n    enter(tag) {\n      const sectionId = getOrCreateSectionId(tag);\n      if (sectionId === 0) {\n        (currentProgramPath.node.extra ??= {}).closures = true;\n      }\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit: custom_tag_default.analyze.exit\n  },\n  translate(tag) {\n    assertNoParams9(tag);\n    assertNoBodyContent(tag);\n    if (isOutputHTML()) {\n      flushBefore(tag);\n    }\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const [defaultAttr] = node.attributes;\n    let refId;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"<get> requires a variable to be defined, eg <get/NAME>.\");\n    }\n    if (defaultAttr === void 0) {\n      refId = \"$\";\n    } else {\n      if (!t35.isMarkoAttribute(defaultAttr) || !defaultAttr.default || !t35.isStringLiteral(defaultAttr.value)) {\n        throw tag.get(\"name\").buildCodeFrameError(`The '<get>' tag requires default attribute that is a string that resolves to a Marko file like '<get/val=\"../file.marko\">' or '<get/val=\"<tag-name>\">'.`);\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<get>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n        }\n      }\n      const defaultAttrValue = tag.get(\"attributes\")[0].get(\"value\");\n      if (defaultAttr.value.value === \".\") {\n        refId = file.metadata.marko.id;\n      } else {\n        const relativeReferencePath = resolveTagImport2(defaultAttrValue, defaultAttrValue.node.value);\n        if (!relativeReferencePath) {\n          throw defaultAttrValue.buildCodeFrameError(\"Unable to resolve template provided to '<get>' tag.\");\n        }\n        refId = getTemplateId2(file.markoOpts.optimize, path.resolve(file.opts.filename, \"..\", relativeReferencePath));\n      }\n    }\n    if (isOutputHTML()) {\n      tag.replaceWith(t35.variableDeclaration(\"const\", [\n        t35.variableDeclarator(node.var, callRuntime(\"getInContext\", t35.stringLiteral(refId)))\n      ]));\n    } else {\n      const identifiers = Object.values(tag.get(\"var\").getBindingIdentifiers());\n      initContextConsumer(refId, identifiers[0].extra.reserve);\n      tag.remove();\n    }\n  },\n  autocomplete: [\n    {\n      displayText: 'get/<name>=\"<from>\"',\n      description: \"Gets a value provided from another template.\",\n      snippet: 'get/${1:name}=\"${2:from}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#get\"\n    }\n  ]\n};\n\n// src/core/html-comment.ts\nimport {\n  assertNoAttributeTags,\n  assertNoAttributes as assertNoAttributes2,\n  assertNoParams as assertNoParams10,\n  assertNoVar as assertNoVar7\n} from \"@marko/babel-utils\";\nvar html_comment_default = {\n  analyze() {\n  },\n  translate: {\n    enter(tag) {\n      enter(tag);\n      writeTo(tag)`<!--`;\n    },\n    exit(tag) {\n      assertNoVar7(tag);\n      assertNoParams10(tag);\n      assertNoAttributes2(tag);\n      assertNoAttributeTags(tag);\n      exit(tag);\n      writeTo(tag)`-->`;\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    text: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an html comment that is not stripped from the output.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#html-comment\"\n    }\n  ]\n};\n\n// src/core/let.ts\nimport { types as t36 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams11 } from \"@marko/babel-utils\";\nvar let_default = {\n  translate(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    const [defaultAttr] = node.attributes;\n    assertNoParams11(tag);\n    assertNoBodyContent(tag);\n    if (!tagVar) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'let' tag requires a tag variable.\");\n    }\n    if (!t36.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The 'let' cannot be destructured.\");\n    }\n    if (!defaultAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'let' tag requires a default attribute.\");\n    }\n    if (node.attributes.length > 1 || !t36.isMarkoAttribute(defaultAttr) || !defaultAttr.default && defaultAttr.name !== \"default\") {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'let' tag only supports the 'default' attribute.\");\n    }\n    if (isOutputDOM()) {\n      const sectionId = getSectionId(tag);\n      const binding = tagVar.extra.reserve;\n      const source = initSource(binding);\n      addStatement(\"apply\", sectionId, defaultAttr.extra?.valueReferences, t36.expressionStatement(callRuntime(\"setSource\", scopeIdentifier, source.identifier, defaultAttr.value)));\n      registerAssignmentReplacer(tag.scope.getBinding(binding.name), (assignment, value) => queueSource(source, value, getSectionId(assignment)));\n    } else {\n      translateVar(tag, defaultAttr.value);\n    }\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a mutable binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#let\"\n    }\n  ]\n};\n\n// src/core/put.ts\nimport { types as t37 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams12, assertNoVar as assertNoVar8 } from \"@marko/babel-utils\";\nvar put_default = {\n  analyze: {\n    enter(tag) {\n      reserveScope(0 /* Visit */, getOrCreateSectionId(tag), tag.node, \"put\", \"#text\");\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      custom_tag_default.analyze.exit(tag);\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [defaultAttr] = node.attributes;\n      if (!node.body.body.length) {\n        throw tag.buildCodeFrameError(`The '<put>' tag requires body content that the context is forwarded through.`);\n      }\n      if (!t37.isMarkoAttribute(defaultAttr) || !defaultAttr.default) {\n        throw tag.get(\"name\").buildCodeFrameError(`The '<put>' tag requires default attribute like '<put=val>'.`);\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<put>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n        }\n      }\n      if (isOutputHTML()) {\n        flushBefore(tag);\n        tag.insertBefore(t37.expressionStatement(callRuntime(\"pushContext\", t37.stringLiteral(tag.hub.file.metadata.marko.id), defaultAttr.value)));\n      } else {\n        visit(tag, 37 /* Replace */);\n        enterShallow(tag);\n        const bodySectionId = getSectionId(tag.get(\"body\"));\n        const rendererId = getRenderer(bodySectionId);\n        initContextProvider(tag.hub.file.metadata.marko.id, node.extra.reserve, defaultAttr.extra?.valueReferences?.references, defaultAttr.value, rendererId);\n      }\n    },\n    exit(tag) {\n      assertNoParams12(tag);\n      assertNoVar8(tag);\n      if (isOutputHTML()) {\n        flushInto(tag);\n        tag.insertAfter(t37.expressionStatement(callRuntime(\"popContext\")));\n      }\n      tag.replaceWithMultiple(tag.node.body.body);\n    }\n  },\n  autocomplete: [\n    {\n      displayText: \"put=<value>\",\n      description: \"Sets a value which can be read from a child template.\",\n      snippet: \"put=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#put\"\n    }\n  ]\n};\n\n// src/core/style.ts\nimport path2 from \"path\";\nimport { assertNoParams as assertNoParams13, importDefault as importDefault2 } from \"@marko/babel-utils\";\nimport { types as t38 } from \"@marko/compiler\";\nvar style_default = {\n  translate(tag) {\n    const {\n      hub: { file }\n    } = tag;\n    assertNoParams13(tag);\n    assertNoSpreadAttrs(tag);\n    let type = \"text/css\";\n    const attrs = tag.get(\"attributes\");\n    const base = path2.basename(file.opts.sourceFileName);\n    const typeAttr = attrs.find((attr) => attr.isMarkoAttribute() && attr.node.name === \"type\");\n    const classAttr = attrs.find((attr) => attr.isMarkoAttribute() && attr.node.name === \"class\");\n    if (typeAttr && classAttr) {\n      throw classAttr.buildCodeFrameError(`<style> must only use \"type\" or \"class\" and not both.`);\n    } else if (typeAttr) {\n      const typeValue = typeAttr.get(\"value\");\n      if (typeValue.isStringLiteral()) {\n        type = typeValue.node.value;\n      } else {\n        throw typeValue.buildCodeFrameError(`<style> \"type\" attribute can only be a string literal.`);\n      }\n    } else if (classAttr) {\n      const classValue = classAttr.get(\"value\");\n      if (classValue.isStringLiteral()) {\n        type = classValue.node.value;\n      } else {\n        throw classValue.buildCodeFrameError(`<style> \"class\" attribute can only be a string literal.`);\n      }\n    }\n    if (type === \"text/css\") {\n      type = \"css\";\n    }\n    if (tag.node.var && !type.startsWith(\"module\")) {\n      type = \"module.\" + type;\n    }\n    const body = tag.get(\"body\").get(\"body\");\n    const markoText = body[0];\n    if (body.length !== 1 || !markoText.isMarkoText()) {\n      throw (markoText.isMarkoText() ? body[1] : body[0]).buildCodeFrameError(\"The '<style>' tag currently only supports static content.\");\n    }\n    const { resolveVirtualDependency } = getMarkoOpts();\n    if (resolveVirtualDependency) {\n      const importPath = resolveVirtualDependency(file.opts.filename, {\n        type,\n        code: markoText.node.value,\n        startPos: markoText.node.start,\n        endPos: markoText.node.end,\n        path: `./${base}`,\n        virtualPath: `./${base}.${type}`\n      });\n      if (!tag.node.var) {\n        currentProgramPath.pushContainer(\"body\", t38.importDeclaration([], t38.stringLiteral(importPath)));\n      } else if (t38.isIdentifier(tag.node.var)) {\n        currentProgramPath.pushContainer(\"body\", t38.importDeclaration([t38.importDefaultSpecifier(tag.node.var)], t38.stringLiteral(importPath)));\n      } else {\n        currentProgramPath.pushContainer(\"body\", t38.variableDeclaration(\"const\", [\n          t38.variableDeclarator(tag.node.var, importDefault2(file, importPath, \"style\"))\n        ]));\n      }\n    }\n    tag.remove();\n  },\n  attributes: {\n    type: { enum: [\"css\", \"less\", \"scss\", \"text/css\"] }\n  }\n};\n\n// src/core/tag.ts\nimport { types as t39 } from \"@marko/compiler\";\nvar tag_default2 = {\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n      if (!tag.node.var) {\n        throw tag.get(\"name\").buildCodeFrameError(\"<tag> requires a variable to be defined, eg <tag/NAME>.\");\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        flushInto(tag);\n      }\n      tag.replaceWith(t39.variableDeclaration(\"const\", [\n        t39.variableDeclarator(tag.node.var, t39.arrowFunctionExpression(tag.node.body.params, toFirstExpressionOrBlock(tag.node.body)))\n      ]));\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"tag/<name>|<params>|\",\n      description: \"Creates a reusable fragment within the template.\",\n      snippet: \"tag/${1:name}|${2:param1, param2}|\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#tag\"\n    }\n  ]\n};\n\n// src/core/static.ts\nimport { types as t40 } from \"@marko/compiler\";\nimport { parseScript as parseScript3 } from \"@marko/babel-utils\";\nvar static_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^static\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let { body } = parseScript3(file, code, start);\n    if (body.length === 1 && t40.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(t40.markoScriptlet(body, true));\n  },\n  \"parse-options\": {\n    rootOnly: true,\n    rawOpenTag: true,\n    openTagOnly: true,\n    ignoreAttributes: true\n  },\n  autocomplete: [\n    {\n      displayText: \"static <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#static-javascript\"\n    }\n  ]\n};\n\n// src/core/noop.ts\nvar noop_default = {\n  migrate: [(tag) => tag.remove()]\n};\n\n// src/core/__flush_here_and_after__.ts\nvar flush_here_and_after_default = {\n  migrate: [\n    (tag) => {\n      tag.replaceWithMultiple(tag.node.body.body);\n      currentProgramPath.scope.crawl();\n    }\n  ]\n};\n\n// src/core/index.ts\nvar core_default = {\n  taglibId,\n  \"<import>\": import_default,\n  \"<export>\": export_default,\n  \"<attrs>\": attrs_default,\n  \"<if>\": if_default,\n  \"<else-if>\": else_if_default,\n  \"<else>\": else_default,\n  \"<for>\": for_default,\n  \"<let>\": let_default,\n  \"<const>\": const_default,\n  \"<effect>\": effect_default,\n  \"<lifecycle>\": lifecycle_default,\n  \"<id>\": id_default,\n  \"<html-comment>\": html_comment_default,\n  \"<tag>\": tag_default2,\n  \"<put>\": put_default,\n  \"<get>\": get_default,\n  \"<return>\": return_default,\n  \"<style>\": style_default,\n  \"<await-reorderer>\": noop_default,\n  \"<init-widgets>\": noop_default,\n  \"<init-components>\": noop_default,\n  \"<static>\": static_default,\n  \"<__flush_here_and_after__>\": flush_here_and_after_default\n};\n\n// src/visitors/referenced-identifier.ts\nimport { types as t41 } from \"@marko/compiler\";\nvar outGlobalIdentifiers = /* @__PURE__ */ new WeakMap();\nvar hasAttrsTag = /* @__PURE__ */ new WeakSet();\nvar referenced_identifier_default = {\n  migrate(identifier) {\n    const { name } = identifier.node;\n    if (identifier.scope.hasBinding(name))\n      return;\n    switch (identifier.node.name) {\n      case \"input\": {\n        if (!hasAttrsTag.has(currentProgramPath)) {\n          hasAttrsTag.add(currentProgramPath);\n          insertAfterStatic(t41.markoTag(t41.stringLiteral(\"attrs\"), void 0, t41.markoTagBody(), void 0, identifier.node));\n        }\n        break;\n      }\n      case \"out\":\n        if (t41.isMemberExpression(identifier.parent) && t41.isIdentifier(identifier.parent.property) && identifier.parent.property.name === \"global\") {\n          let globalIdentifier = outGlobalIdentifiers.get(currentProgramPath);\n          if (!globalIdentifier) {\n            globalIdentifier = currentProgramPath.scope.generateUidIdentifier(\"$global\");\n            outGlobalIdentifiers.set(currentProgramPath, globalIdentifier);\n            insertAfterStatic(t41.markoTag(t41.stringLiteral(\"get\"), void 0, t41.markoTagBody(), void 0, globalIdentifier));\n          }\n          identifier.parentPath.replaceWith(globalIdentifier);\n        } else {\n          throw identifier.buildCodeFrameError(\"Only out.global is supported for compatibility.\");\n        }\n        break;\n    }\n  }\n};\nfunction insertAfterStatic(node) {\n  for (const child of currentProgramPath.get(\"body\")) {\n    if (!isStatic(child)) {\n      child.insertBefore(node);\n      return;\n    }\n  }\n  currentProgramPath.unshiftContainer(\"body\", node);\n}\n\n// src/index.ts\nvar visitors = {\n  Program: program_default,\n  AssignmentExpression: assignment_expression_default,\n  UpdateExpression: update_expression_default,\n  ReferencedIdentifier: referenced_identifier_default,\n  ImportDeclaration: import_declaration_default,\n  MarkoDocumentType: document_type_default,\n  MarkoDeclaration: declaration_default,\n  MarkoCDATA: cdata_default,\n  MarkoText: text_default,\n  MarkoTag: tag_default,\n  MarkoPlaceholder: placeholder_default,\n  MarkoScriptlet: scriptlet_default,\n  MarkoComment: comment_default\n};\nvar getVisitorOfType = (typename) => Object.entries(visitors).reduce((visitor, [name, value]) => {\n  if (typename in value) {\n    visitor[name] = value[typename];\n  }\n  return visitor;\n}, {});\nvar analyze = getVisitorOfType(\"analyze\");\nvar translate = getVisitorOfType(\"translate\");\nvar taglibs = [\n  [\n    __dirname,\n    {\n      ...core_default,\n      migrate: getVisitorOfType(\"migrate\")\n    }\n  ]\n];\nexport {\n  analyze,\n  taglibs,\n  translate\n};\n//# sourceMappingURL=index.esm.js.map\n","import * as fluurtTranslator from \"../../../../../browser-shims/v6/translator\";\n\n<hash-value/files=[\n  {\n    name: \"index.marko\",\n    path: \"/components/index.marko\",\n    content:\n      \"<let/count=0/>\\n<button onClick() { count++ }>\\n  ${count}\\n</button>\",\n  },\n]/>\n<repl\n  getCompilerOptions() {\n    return {\n      translator: fluurtTranslator,\n      optimize: false,\n    };\n  }\n  files:=files\n/>\n","import { register, init } from \"marko/dist/runtime/components/index.js\";\nimport \"../../../components/app-layout/style.css\";\nimport \"../../../components/app-layout/favicon.png\";\nimport \"../../../components/app-layout/components/skip-link/index.marko.css!=!/Users/mirawlings/dev/marko-js/website/node_modules/@marko/webpack/dist/loader/index.js!/Users/mirawlings/dev/marko-js/website/src/components/app-layout/components/skip-link/index.marko?virtual=./index.marko.css\";\nimport \"../../../components/app-layout/components/layout-header/style.css\";\nimport \"../../../logos/marko.svg\";\nimport \"../../../components/app-layout/components/layout-search/style.css\";\nimport component_0 from \"../../../components/app-layout/components/layout-header/component-browser.js\";\nregister(\"OIKmBXjW\", component_0);\nimport \"../../../components/app-layout/components/layout-sidebar/style.css\";\nimport component_1 from \"../../../components/app-layout/components/layout-sidebar/components/version-switcher/component-browser.js\";\nregister(\"07hv1F0+\", component_1);\nimport component_2 from \"../../../components/app-layout/components/layout-sidebar/component-browser.js\";\nregister(\"mFesaajv\", component_2);\nimport \"../../../components/app-footer/style.css\";\nimport \"../../../components/app-footer/openjsf.svg\";\nimport \"../../../components/app-footer/osi.svg\";\nimport \"../../../components/app-footer/ebay.svg\";\nimport \"../../../components/discord-link/index.marko.css!=!/Users/mirawlings/dev/marko-js/website/node_modules/@marko/webpack/dist/loader/index.js!/Users/mirawlings/dev/marko-js/website/src/components/discord-link/index.marko?virtual=./index.marko.css\";\nimport \"../../../logos/discord.svg\";\nimport \"./components/playground-6.marko\";\ninit();","module.exports = require(\"../../../../node_modules/@marko/compiler/dist/babel-types\");\n","// We don't bring in the full Marko compiler, but the ast types are needed.\nexports.types = require(\"./dist/babel-types\");\n","module.exports = require(\"memfs\");\n","const path = require(\"path\");\nconst resolve = require(\"resolve\");\nconst resolveExports = require(\"resolve.exports\");\n\nconst Module = {\n  _nodeModulePaths: nodeModulePaths,\n  _resolveFilename: function (target, fromModule) {\n    return resolve.sync(target, {\n      basedir: path.dirname(fromModule.filename),\n      paths: fromModule.paths,\n      extensions: [\".js\", \".json\", \".marko\", \".mjs\"],\n      pathFilter(pkg, _, relativePath) {\n        if (/^index(\\.[^/\\\\]+)?$/.test(relativePath)) {\n          try {\n            return resolveExports.legacy(pkg, Module._resolveExportsOptions);\n          } catch {}\n        } else {\n          try {\n            return resolveExports.resolve(\n              pkg,\n              relativePath,\n              Module._resolveExportsOptions\n            );\n          } catch {}\n        }\n\n        return relativePath;\n      },\n    });\n  },\n  _resolveExportsOptions: {\n    browser: true,\n  },\n};\n\nmodule.exports = Module;\n\nfunction nodeModulePaths(dir) {\n  const paths = [];\n\n  while (true) {\n    const parentDir = path.dirname(dir);\n    paths.push(path.join(dir, \"node_modules\"));\n\n    if (!parentDir || parentDir === dir) {\n      break;\n    }\n\n    dir = parentDir;\n  }\n\n  return paths;\n}\n","module.exports = {\n  env: {},\n  browser: true,\n  cwd() {\n    return \"/\"\n  }\n}","var siteHeaderEvents = require(\"./events\");\n\nvar classNames = {\n  base: \"headspace\",\n  fixed: \"headspace--fixed\",\n  hidden: \"headspace--hidden\"\n};\nvar debounce = cb => () => window.requestAnimationFrame(cb);\nvar tolerance = 3;\n\nmodule.exports = {\n  onMount() {\n    siteHeaderEvents.emit(\"create\", this);\n    var scrollLast = 0;\n    var startOffset = this.getEl('header').offsetHeight;\n    var bannerHeight = (this.getEl('banner') || { offsetHeight:0 }).offsetHeight;\n\n    var handleScroll = debounce(() => {\n      var scrollCurrent = window.pageYOffset;\n\n      if (scrollCurrent <= bannerHeight) {\n        this.reset();\n      } else if (!this.paused && scrollCurrent > startOffset) {\n        var toleanceReached = Math.abs(scrollCurrent - scrollLast) >= tolerance;\n        var scrollingDown = scrollCurrent > scrollLast;\n        var wasAtTop = scrollLast <= startOffset;\n        if (toleanceReached || (scrollingDown && wasAtTop)) {\n          scrollCurrent > scrollLast ? this.hide() : this.fix();\n        }\n      }\n\n      scrollLast = scrollCurrent;\n    });\n\n    handleScroll();\n    window.addEventListener(\"scroll\", handleScroll);\n  },\n  reset() {\n    this.removeClass(classNames.fixed);\n    this.removeClass(classNames.hidden);\n    siteHeaderEvents.emit(\"reset\");\n  },\n  fix() {\n    this.addClass(classNames.fixed);\n    this.removeClass(classNames.hidden);\n    siteHeaderEvents.emit(\"fix\");\n  },\n  hide() {\n    this.addClass(classNames.hidden);\n    siteHeaderEvents.emit(\"hide\");\n  },\n  addClass(cls) {\n    this.getEl('header').classList.add(cls);\n  },\n  removeClass(cls) {\n    this.getEl('header').classList.remove(cls);\n  },\n  pause() {\n    this.paused = true;\n  },\n  resume() {\n    setTimeout(() =>\n      window.requestAnimationFrame(() => {\n        this.paused = false;\n      })\n    );\n  },\n  toggleMenu () {\n    siteHeaderEvents.emit('toggle-menu');\n  }\n};\n","// TODO: remove this.\nvar EventEmitter = require(\"events\");\n\nmodule.exports = new EventEmitter();\n","var siteHeaderEvents = require(\"../layout-header/events\");\nvar forEach = [].forEach;\nvar filter = [].filter;\nvar slice = [].slice;\nvar siteHeaderComponent;\n\nmodule.exports = {\n  onMount() {\n    this.preventOverscroll();\n    this.listenForHeaderChanges();\n    this.initScrollSpy();\n  },\n\n  initScrollSpy() {\n    var headersSelector = [1, 2, 3, 4, 5, 6]\n      .map(n => \".doc-content h\" + n)\n      .join(\",\");\n    var headers = slice.call(document.querySelectorAll(headersSelector));\n    var waiting = false;\n\n    headers.length &&\n      this.subscribeTo(window).on(\"scroll\", () => {\n        if (!waiting) {\n          waiting = true;\n          setTimeout(() => {\n            var threshold = window.innerHeight / 3;\n            var closestHeader;\n            var closestTop;\n\n            headers.map(header => {\n              var top = header.getBoundingClientRect().top;\n              if (\n                closestTop == null ||\n                (top < threshold && Math.abs(top) < Math.abs(closestTop))\n              ) {\n                closestTop = top;\n                closestHeader = header;\n              }\n            });\n\n            var anchor = closestHeader.id;\n            var anchorEl =\n              this.el.querySelector('a[href=\"#' + anchor + '\"]') ||\n              this.el.querySelector(\"a.selected\");\n            var targetAnchor = anchorEl;\n            var childList = targetAnchor.nextSibling;\n\n            if (childList) {\n              forEach.call(childList.querySelectorAll(\"a[href^=\\\\#]\"), a =>\n                a.classList.remove(\"selected\")\n              );\n            }\n\n            while (targetAnchor) {\n              var parentList = targetAnchor.closest(\"ul\");\n              var siblings =\n                parentList &&\n                filter.call(\n                  parentList.querySelectorAll(\":scope > li > a[href^=\\\\#]\"),\n                  a => a !== targetAnchor\n                );\n              siblings && siblings.forEach(a => a.classList.remove(\"selected\"));\n              targetAnchor.classList.add(\"selected\");\n              targetAnchor = parentList && parentList.previousElementSibling;\n            }\n\n            this.scrollAnchorIntoView(anchorEl);\n\n            waiting = false;\n          }, 50);\n        }\n      });\n  },\n\n  listenForHeaderChanges() {\n    forEach.call(this.el.querySelectorAll(\"a[href^=\\\\#]\"), a => {\n      this.subscribeTo(a).on(\"click\", () => {\n        siteHeaderComponent.hide();\n        siteHeaderComponent.pause();\n        siteHeaderComponent.resume();\n        this.hide();\n      });\n    });\n\n    // handles nested selected links\n    var selectedLink = slice.call(this.el.querySelectorAll(\"a.selected\")).pop();\n\n    selectedLink &&\n      this.subscribeTo(selectedLink).on(\"click\", e => {\n        window.scrollTo(0, 0);\n        siteHeaderComponent.reset();\n        e.preventDefault();\n      });\n\n    this.subscribeTo(siteHeaderEvents)\n      .on(\"reset\", () => {\n        this.el.classList.remove(\"no-header\");\n        this.el.classList.remove(\"fixed\");\n        setTimeout(() => this.el.classList.remove(\"transition\"), 0);\n      })\n      .on(\"fix\", () => {\n        this.el.classList.remove(\"no-header\");\n        this.el.classList.add(\"fixed\");\n        setTimeout(() => this.el.classList.add(\"transition\"), 0);\n      })\n      .on(\"hide\", () => {\n        this.el.classList.add(\"no-header\");\n        this.el.classList.add(\"fixed\");\n        setTimeout(() => this.el.classList.add(\"transition\"), 0);\n      })\n      .on(\"toggle-menu\", () => {\n        if (this.el.classList.contains(\"show\")) {\n          this.el.classList.remove(\"show\");\n          document.body.style.overflow = \"\";\n        } else {\n          this.el.classList.add(\"show\");\n        }\n      })\n      .on(\"create\", _siteHeaderComponent => {\n        siteHeaderComponent = _siteHeaderComponent;\n\n        if (window.pageYOffset > siteHeaderComponent.el.offsetHeight) {\n          this.el.classList.add(\"no-header\");\n          this.el.classList.add(\"fixed\");\n        }\n      });\n  },\n\n  preventOverscroll() {\n    var sidebar = this.getEl(\"sidebar\");\n    this.subscribeTo(document.body).on(\"wheel\", e => {\n      var delta = e.deltaY;\n      var scrollTarget = sidebar.scrollTop + delta;\n      var topY = 0;\n      var bottomY = sidebar.scrollHeight - sidebar.offsetHeight;\n      var atTop = scrollTarget <= topY;\n      var atBottom = scrollTarget >= bottomY;\n\n      if ((delta < 0 && atTop) || (delta > 0 && atBottom)) {\n        if (e.target === sidebar || sidebar.contains(e.target)) {\n          if (atTop && sidebar.scrollTop != topY) {\n            sidebar.scrollTop = topY;\n          } else if (atBottom && sidebar.scrollTop != bottomY) {\n            sidebar.scrollTop = bottomY;\n          }\n          e.preventDefault();\n        }\n      }\n    });\n  },\n\n  scrollAnchorIntoView(anchorEl) {\n    var sidebar = this.getEl(\"sidebar\");\n    var anchorTop = anchorEl.offsetTop;\n    var sidebarScrollTop = sidebar.scrollTop;\n    var sidebarHeight = sidebar.offsetHeight;\n    var sidebarScrollBottom = sidebarScrollTop + sidebarHeight;\n\n    var targetList = anchorEl.closest(\"li\");\n    var parentList;\n\n    while (true) {\n      parentList = targetList.parentNode.closest(\"ul\");\n      if (parentList && parentList.offsetHeight < sidebarHeight) {\n        targetList = parentList;\n      } else {\n        break;\n      }\n    }\n\n    var targetTop = targetList.offsetTop;\n    var targetHeight = targetList.offsetHeight;\n    var targetBottom = targetTop + targetHeight;\n    var targetIsFullyVisible =\n      targetTop > sidebarScrollTop && targetBottom < sidebarScrollBottom;\n\n    if (!targetIsFullyVisible) {\n      sidebar.scrollTop = targetTop + targetHeight / 2 - sidebarHeight / 2;\n    }\n  },\n\n  hide() {\n    this.el.classList.remove(\"show\");\n    document.body.style.overflow = \"\";\n  }\n};\n","module.exports = {\n  switchVersion(e) {\n    var location = e.target.value;\n    if (location !== \"current\") {\n      e.target.value = \"current\";\n      window.location.href = location;\n    }\n  }\n};\n","export default __webpack_public_path__ + \"339b8a9e.svg\";","export default __webpack_public_path__ + \"6876aea9.svg\";","export default __webpack_public_path__ + \"1b70b500.svg\";","export default __webpack_public_path__ + \"d78b83f1.png\";","export default __webpack_public_path__ + \"78800ea4.svg\";","export default __webpack_public_path__ + \"91bc26e5.svg\";"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","id","module","exports","files","externalFiles","selectedIndex","externalSelected","selectedFile","nextId","file","index","editing","selected","mutable","d","name","finishRename","modifiedFile","path","replace","slice","nameInput","length","focus","setSelectionRange","indexOf","window","confirm","stopPropagation","newFile","content","newIndex","concat","actions","body","renderBody","value","valueChange","class","className","el","target","attrs","compressToEncodedURIComponent","JSON","stringify","default","query","fallback","isMatch","matchMedia","matches","mq","listener","addEventListener","removeEventListener","left","right","editorSize","resizing","isVertical","container","preventDefault","handler","buttons","which","rect","getBoundingClientRect","fraction","clientY","top","height","clientX","width","Math","min","max","getCompilerOptions","previewType","debounce","activeEditor","async","loading","preview","defaultValue","parse","decompressFromEncodedURIComponent","location","hash","console","error","this","isUpdating","removevEventListener","__require","require","isOutputHTML","getMarkoOpts","output","isOutputDOM","currentProgramPath","hub","markoOpts","MARKO_FILE_REG","analyzeTagNameType","tag","extra","node","tagNameType","get","isStringLiteral","isNativeTag","tagNameNullable","pending","path3","type","nullable","pop","isConditionalExpression","push","alternate","isLogicalExpression","operator","isAssignmentExpression","isBinaryExpression","isTemplateLiteral","isNullLiteral","isIdentifier","binding","scope","getBinding","kind","decl","parent","test","source","specifiers","some","it","t","bindingTag","isMarkoTag","bindingTagName","defaultAttr","assignments","constantViolations","i","assignment","tagNameDynamic","startSection","sectionId","programExtra","sectionNameNode","sectionName","nextSectionId","sectionNames","generateUid","getOrCreateSectionId","cur","parentPath","getSectionId","currentPath","createSectionState","key","init","arrayOfSectionData","state","forEachSectionId","fn","createSortedCollection","compare","insert","data","val","immutable","Array","isArray","arr","len","pos","mid","compareResult","next","insertInArray","find","findIndex","count","getReservesByType","reserveScope","debugKey","reserve","reserve2","reservesByType","getNodeLiteral","optimize","t2","compareReserves","a","b","insertReserve","countReserves","pureFunctions","importRuntime","importNamed","getRuntimePath","callRuntime","args","callExpression2","t3","filterArguments","includes","leadingComments","getHTMLRuntime","callRead","reference","targetSectionId","getScopeExpression","diff","scopeIdentifier","filteredArgs","arg","toTemplateOrStringLiteral","parts","strs","exprs","curStr","t4","nextIndex","exprLen","expressions","shiftItems","quasis","j","raw","map","appendLiteral","str","list","start","offset","getWalks","getWalkComment","getSteps","walkCodeToName","enter","exit","enterShallow","visit","buildCodeFrameError","steps","walks","walkComment","walkString","walks2","depth","step","lastIndexOf","current","walk","nCodeString","writeTo","String","fromCharCode","number","toCharString","startCode","rangeSize","result","multiplier","floor","getWalkString","walkLiteral","t5","join","getRenderer","t6","getWrites","exprsLen","writes","consumeHTML","flushBefore","expr","insertBefore","skip","flushInto","isProgram","pushContainer","getSectionMeta","apply","getSetup","markNode","assertNoSpreadAttrs","attr","isMarkoSpreadAttribute","assertNoBodyContent","returnId","_setReturnId","return_default","translate","assertNoVar","assertNoParams","attributes","t7","loc","end","msg","buildError","returnId2","generateUidIdentifier","replaceWith","signal","getSignal","valueReferences","references","tagVarSignalIdentifier","subscribers","addStatement","remove","autocomplete","displayText","description","snippet","descriptionMoreURL","getSignals","Map","getSubscribeBuilder","_setSubscribeBuilder","getClosures","forceHydrateScope","_setForceHydrateScope","setSubscriberBuilder","builder","r","sort","signals","set","identifier","t8","generateSignalName","render","hydrate","hydrateInlineReferences","subscribe","build","getComputeFn","provider","hasDynamicSubscribers","subscriber","initSource","initDerivation","providers","compute","params","forEach","p","ref","statement","originalNodes","isInlined","statements","addHydrateReferences","expression","refs","getHydrateRegisterId","opts","filename","getTemplateId","sortSignals","aReserves","getReserves","bReserves","getMappedId","addHTMLHydrateCall","writeHTMLHydrateStatements","tagVarIdentifier","allSignals","from","values","unshiftContainer","serializedProperties","reduce","acc","bindFunctionsVisitor","FunctionExpression","bindFunction","ArrowFunctionExpression","root","functionIdentifier","unshift","isFunction","isStatic","isImportDeclaration","isExportDeclaration","isMarkoScriptlet","static","html_default","program","returnIdentifier","t9","renderContent","child","replaceWithMultiple","rendererId","var","dom_default","templateIdentifier","t10","walksIdentifier","setupIdentifier","attrsSignalIdentifier","closuresIdentifier","forEachSectionIdReverse","childSectionId","declarations","flatMap","register","signalDeclarator","hydrateDeclarator","hydrateIdentifier","finalizeSignalArgs","arguments","newPath","traverse","writeSignals","writes2","apply2","closures2","exportSpecifiers","bindings","bindingIdentifier","signalIdentifier","exportIdentifier","closures","getReferenceGroups","t11","trackReferencesForBindings","reserveType","getBindingIdentifiers","referencePaths","filter","path4","insertReferenceGroup","fnRoot","getFnRoot","exprRoot","getExprRoot","markoRoot","immediateRoot","name2","isMarkoAttribute","updateReferenceGroup","listKey","extraKey","newBinding","currentGroup","newReferences","getOrCreateReferenceGroup","mergeReferenceGroups","groupEntries","group","newGroup","referenceGroups","existingGroup","findReferenceGroup","curPath","isMarkoPath","isFunctionExpression","lenDelta","getReferenceGroup","lookup","analyze2","found","generateReferenceGroupName","previousProgramPath","WeakMap","program_default","migrate","crawl","analyze","curIndex","reserves","allReferenceGroups","g","finalizeReferences","t12","hasInteractiveChild","isInteractive","import_declaration_default","request","resolveTagImport","document_type_default","documentType","assignmentReplacer","getReplacement","assignment_expression_default","t13","replacement","update_expression_default","t14","argument","prefix","isExpressionStatement","declaration_default","declaration","cdata_default","cdata","text_default","text","followingSiblings","needsSeparator","sibling","t15","enter2","modulePlugin","plugin","isModulePlugin","isFunctionPlugin","t16","exit2","Boolean","IDENTIFIER_REG","toPropertyName","t17","attrsToObject","withRenderBody","t18","resultExtra","properties","hoistedControlFlows","isConditional","isLoop","prop","getRenderBodyProp","attrsObject","lastProp","translateVar","initialValue","tagVar","t19","evaluate","confident","computed","native_tag_default","has","isSpreadAttr","attrNode","isEventHandler","isHTML","tagDef","getTagDef","hasSpread","write","t20","varName","createElFunction","referenceSectionId","isCallExpression","visitAccessor","attrsCallExpr","extra2","helper","propName","charAt","toLowerCase","parseOptions","openTagOnly","htmlType","custom_tag_default","trackReferences","getTagDef2","template","childProgramExtra","loadFileForTag","ast","attrsReferences","tagBody","tagIdentifier","t21","tagName","relativePath","getTagRelativePath","importDefault","renderBodyProp","renderBodyId","renderTagExpr","callExpression","renderBodyPath","callStatement","translateHTML","tagSectionId","tagBodySectionId","childProgram","importNamed2","tagAttrsIdentifier","injectWalks","attrsSubscriber","tagAttrsIdentifierInChild","translateDOM","nameIsString","resolveRelativePath","tags","metadata","marko","toFirstExpressionOrBlock","nodes","t22","dynamic_tag_default","t23","dynamicTagExpr","bodySectionId","renderBodyIdentifier","tagNameReserve","nameReferences","attribute_tag_default","hasPendingHTML","assertNoVar2","parentTag","findParentTag","parentExtra","attrName","info","nestedAttributeTags","t24","dynamic","repeated","existingAttr","analyzeAttributeTags","analyzeChildren","rootExtra","hasAttributeTags","analyzeChild","isTransparentTag","isLoopTag","isAttributeTag","existing","tag_default","getTagDef3","hook","analyzer","assertNoArgs","translator","watchFiles","modifier","isNativeTag2","tagNameId","tagNameVarPath","t25","taglibId","isCoreTag","getTagDef4","isCoreTagName","ESCAPE_TYPES","script","style","placeholder_default","placeholder","escape","prev","getPrevSibling","noOutput","t26","isNativeTag3","needsMarker","getNextSibling","canWriteHTML","method","getParentTagName","scriptlet_default","scriptlet","bodyReferences","ieConditionalCommentRegExp","comment_default","comment","import_default","parseScript","rawValue","rootOnly","rawOpenTag","ignoreAttributes","relaxRequireCommas","export_default","parseScript2","attrs_default","varPath","toFirstStatementOrBlock","t27","if_default","exitBranchAnalyze","testAttr","assertNoVar3","assertNoParams2","t28","exitBranchTranslate","BRANCHES_LOOKUP","getBranches","branches","nextTag","isLast","conditionalReferences","tag2","sectionId2","curStatement","else_if_default","assertNoVar4","assertNoParams3","t29","else_default","assertNoVar5","assertNoParams4","const_default","assertNoParams5","t30","identifiers","Object","effect_default","assertNoParams6","t31","inlineStatements","node2","lifecycle_default","assertNoParams7","t32","id_default","assertNoArgs2","assertNoAttributes","assertNoParams8","t33","for_default","isOnlyChild","t34","getTagDef5","html","checkOnlyChild","parentTagName","hasParams","assertNoVar6","findName","assertAllowedAttributes","validateFor","translateHTML2","translateDOM2","of","in","to","paramsPath","ofAttr","byAttr","ofAttrValue","valParam","paramsLookup","param","assign","namePath","inAttr","fromAttr","toAttr","block","forNode","keyParam","loopParam","indexName","generateUidIdentifierBasedOnNode","stepAttr","stepValue","indexParam","stepsName","stepName","obj","get_default","assertNoParams9","refId","t35","defaultAttrValue","relativeReferencePath","resolveTagImport2","getTemplateId2","templateId","initContextConsumer","put_default","t37","renderer","scopeAccessor","valueAccessor","initContextProvider","assertNoParams12","assertNoVar8","insertAfter","noop_default","core_default","assertNoParams11","t36","registerAssignmentReplacer","ownerSectionId","getScopeExpression2","queueSource","assertNoVar7","assertNoParams10","assertNoAttributes2","assertNoAttributeTags","t39","assertNoParams13","base","path2","sourceFileName","typeAttr","classAttr","typeValue","classValue","startsWith","markoText","isMarkoText","resolveVirtualDependency","importPath","startPos","endPos","virtualPath","t38","importDefault2","enum","trim","parseScript3","t40","outGlobalIdentifiers","hasAttrsTag","WeakSet","insertAfterStatic","visitors","Program","AssignmentExpression","UpdateExpression","ReferencedIdentifier","hasBinding","add","t41","property","globalIdentifier","ImportDeclaration","MarkoDocumentType","MarkoDeclaration","MarkoCDATA","MarkoText","MarkoTag","MarkoPlaceholder","MarkoScriptlet","MarkoComment","getVisitorOfType","typename","entries","visitor","taglibs","fluurtTranslator","types","resolveExports","Module","_nodeModulePaths","dir","paths","parentDir","dirname","_resolveFilename","fromModule","sync","basedir","extensions","pathFilter","pkg","_","legacy","_resolveExportsOptions","browser","env","cwd","siteHeaderEvents","classNames","onMount","emit","cb","scrollLast","startOffset","getEl","offsetHeight","bannerHeight","handleScroll","scrollCurrent","pageYOffset","reset","paused","abs","hide","fix","requestAnimationFrame","removeClass","addClass","cls","classList","pause","resume","setTimeout","toggleMenu","EventEmitter","siteHeaderComponent","preventOverscroll","listenForHeaderChanges","initScrollSpy","headersSelector","n","headers","call","document","querySelectorAll","waiting","subscribeTo","on","closestHeader","closestTop","threshold","innerHeight","header","anchor","anchorEl","querySelector","targetAnchor","childList","nextSibling","parentList","closest","siblings","previousElementSibling","scrollAnchorIntoView","selectedLink","scrollTo","contains","overflow","_siteHeaderComponent","sidebar","delta","deltaY","scrollTarget","scrollTop","bottomY","scrollHeight","atTop","atBottom","sidebarScrollTop","offsetTop","sidebarHeight","sidebarScrollBottom","targetList","parentNode","targetTop","targetHeight","switchVersion","href"],"sourceRoot":""}