{"version":3,"sources":["webpack:///../node_modules/events-light/src/index.js","webpack:///../node_modules/listener-tracker/lib/listener-tracker.js","webpack:///../src/runtime/RenderResult.js","webpack:///../src/runtime/components/Component.js","webpack:///../src/runtime/components/ComponentDef.js","webpack:///../src/runtime/components/ComponentsContext.js","webpack:///../src/runtime/components/GlobalComponentsContext.js","webpack:///../src/runtime/components/KeySequence.js","webpack:///../src/runtime/components/State.js","webpack:///../src/runtime/components/defineComponent.js","webpack:///../src/runtime/components/dom-data.js","webpack:///../src/runtime/components/event-delegation.js","webpack:///../src/runtime/components/index-browser.js","webpack:///../src/runtime/components/init-components-browser.js","webpack:///../src/runtime/components/registry-browser.js","webpack:///../src/runtime/components/update-manager.js","webpack:///../src/runtime/components/util-browser.js","webpack:///../src/runtime/createOut.js","webpack:///../src/runtime/dom-insert.js","webpack:///../src/runtime/queueMicrotask.js","webpack:///../src/runtime/setImmediate.js","webpack:///../src/runtime/vdom/VComponent.js","webpack:///../src/runtime/vdom/VDocumentFragment.js","webpack:///../src/runtime/vdom/VElement.js","webpack:///../src/runtime/vdom/VFragment.js","webpack:///../src/runtime/vdom/VNode.js","webpack:///../src/runtime/vdom/VText.js","webpack:///../src/runtime/vdom/morphdom/fragment.js","webpack:///../src/runtime/vdom/morphdom/helpers.js","webpack:///../src/runtime/vdom/morphdom/index.js","webpack:///../src/runtime/vdom/morphdom/specialElHandlers.js","webpack:///../src/runtime/vdom/parse-html.js","webpack:///../src/runtime/vdom/vdom.js","webpack:///../node_modules/raptor-util/copyProps.js","webpack:///../node_modules/raptor-util/extend.js","webpack:///../node_modules/raptor-util/inherit.js","webpack:///../node_modules/warp10/constants.js","webpack:///../node_modules/warp10/finalize.js","webpack:///../node_modules/warp10/src/constants.js","webpack:///../node_modules/warp10/src/finalize.js"],"names":["slice","Array","prototype","isFunction","arg","checkListener","listener","TypeError","invokeListener","ee","args","length","call","apply","addListener","eventEmitter","type","prepend","events","$e","listeners","unshift","push","EventEmitter","this","emit","arguments","error","Error","context","i","len","on","prependListener","once","g","removeListener","splice","removeAllListeners","listenerCount","module","exports","DESTROY","isNonEventEmitter","target","EventEmitterWrapper","$__target","$__listeners","$__subscribeTo","EventEmitterAdapter","SubscriptionTracker","$__subscribeToList","$__remove","test","testWrapped","filter","curListener","curEvent","curListenerFunc","curWrappedListenerFunc","subscribeTo","self","subscribeToList","cur","event","wrappedListener","listenerFunc","addEventListener","onceListener","removeEventListener","options","wrapper","nonEE","addDestroyListener","wrap","targetEventEmitter","createTracker","domInsert","require","RenderResult","out","proto","getComponent","getComponents","componentDefs","result","getComponentDefs","components","component","componentDef","selector","afterInsert","componentsContext","getNode","getOutput","toString","document","Object","get","renderResult","referenceEl","isShadow","ShadowRoot","componentProto","defaultCreateOut","getComponentsContext","componentsUtil","componentLookup","destroyNodeRecursive","inherit","updateManager","morphdom","eventDelegation","domData","componentsByDOMNode","keyedElementsByComponentId","CONTEXT_KEY","hasOwnProperty","NON_COMPONENT_SUBSCRIBE_TO_OPTIONS","removeEventListenerHandle","handleCustomEventWithMethodListener","extraArgs","targetComponent","targetMethod","targetMethodName","resolveKeyHelper","key","index","Component","id","ssrKeyedElements","subscriptions","subscribeToOptions","COMPONENT_SUBSCRIBE_TO_OPTIONS","customEvents","isOnce","getElId","resolveComponentIdHelper","getEl","getEls","els","el","rootNode","lookup","destroy","root","nodes","node","isDestroyed","state","newState","setState","name","setStateDirty","value","replaceState","onInput","oldInput","updatedInput","newInput","existingComponent","oldKeys","newKeys","checkInputChanged","forceUpdate","update","input","stateChanges","oldState","handlerMethod","handlers","propName","propertyName","handler","newValue","oldValue","processUpdateHandlers","shouldUpdate","doc","globalData","renderer","globalComponentsContext","targetNode","eventListenerHandles","finalCustomEvents","eventType","customEvent","fragment","walkFragments","onCreate","onRender","w10Noop","attachBubblingEvent","addDelegatedEventHandler","extend","KeySequence","EMPTY_OBJECT","ComponentDef","componentId","elId","nestedId","String","d","handlerMethodName","o","typeName","types","extra","componentProps","flags","registry","global","undefinedPropNames","scope","GlobalComponentsContext","ComponentsContext","parentComponentsContext","nestedContextsForParent","nextComponentIdProvider","State","rawState","ensure","set","forcedDirtyState","toJSON","BaseState","BaseComponent","def","ComponentClass","runtimeId","getMarkoPropsFromEl","listenersAttachedKey","delegatedEvents","getEventFromEl","eventName","eventInfo","parseInt","delegateEvent","targetComponentId","targetFunc","noop","___","body","propagationStopped","oldStopPropagation","curNode","addDelegatedEventHandlerToDoc","initComponents","getComponentForEl","init","window","register","deferredDefs","warp10Finalize","win","defaultDocument","createFragmentNode","addComponentRootToKeyedElements","serverComponentRootNodes","serverRenderedMeta","indexServerComponentBoundaries","stack","runtimeLength","nextSibling","commentValue","firstChar","endNode","startNode","parts","ownerId","keyedElements","ownerComponent","markoKey","markoProps","separatorIndex","initComponent","domEvents","domEventArgs","eventEl","eventListener","addEventListenerHelper","method","invokeComponentEventHandler","handles","addDOMEventListeners","tryHydrateComponent","rawDef","meta","mount","hydrateComponentAndGetMount","trackComponent","tryInvoke","fn","initServerRendered","renderedComponents","globalKey","fakeArray","r","concat","isFromSerializedGlobals","prefix","isLast","queueMicrotask","defineComponent","pendingDefs","registered","loaded","componentTypes","pendingForType","load","getComponentClass","Boolean","updatesScheduled","batchStack","unbatchedQueue","setImmediate","updateUnbatchedComponents","updateComponents","queue","batchStackLen","batch","func","keysByDOMNode","vElementsByDOMNode","vPropsByDOMNode","markoUID","destroyComponentForNode","componentToDestroy","nextComponentId","vElement","curChild","virtualProps","JSON","repeatedElementsForKey","parentId","actualCreateOut","createOut","createOutFunc","helpers","insertBefore","insertAfter","removeChild","resolveEl","beforeRemove","appendTo","prependTo","replace","replaceChildrenOf","promise","rethrow","err","setTimeout","Promise","msg","Math","ev","callbacks","VNode","VComponent","preserve","VDocumentFragmentClone","other","VDocumentFragment","vElementByDOMNode","ATTR_XLINK_HREF","xmlnsRegExp","NS_XLINK","NS_HTML","DEFAULT_NS","svg","math","defineProperty","ATTR_HREF","convertAttrValue","assign","a","b","setAttribute","namespaceURI","removeAttribute","VElementClone","VElement","constId","props","attrs","e","child","childCount","n","tagName","attributes","attrValue","attrName","forEach","virtualizeChildNodes","attrCount","attr","vdomEl","removePreservedAttributes","fromFlags","vFromEl","toFlags","toEl","fromEl","oldAttrs","VFragment","firstChild","parentNode","childValue","lastChild","VText","fragmentPrototype","nodeType","current","actualReference","referenceNode","insertInto","remove","nextNode","isRoot","detachedContainer","next","specialElHandlers","existingComponentLookup","normalizeComponentKey","virtualizeElement","morphAttrs","componentByDOMNode","detachedByDOMNode","beginFragmentNode","isAutoKey","compareNodeNames","caseInsensitiveCompare","fromNode","toNode","isHydrate","keySequences","realNode","vNode","parentEl","morphChildren","onNodeAdded","parentComponent","morphComponent","detachedNodes","curFromNodeChild","curToNodeChild","outer","toNextSibling","curToNodeType","curToNodeKey","curVFromNodeChild","curFromNodeKey","curToNodeKeyOriginal","referenceComponent","fromNextSibling","morphEl","detachNode","insertVirtualNodeBefore","matchingFromEl","depth","nodeValue","fromComponent","destroyComponent","curFromNodeType","isCompatible","matchingFromComponent","insertVirtualComponentBefore","fragmentBoundary","nodeName","specialElHandler","detachedFromComponent","syncBooleanAttrProp","forEachOption","SpecialElHandlers","option","button","textarea","select","selected","parseHTML","container","specialHtmlRegexp","vdomParent","virtualize","vdomDocFragment","virtualizeHTML","html","vdomFragment","Node_prototype","vdomNode","from","to","getOwnPropertyNames","descriptor","getOwnPropertyDescriptor","source","copyProps","ctor","superCtor","shouldCopyProps","oldProto","newProto","create","constructor","writable","configurable","$super","_inherit","NOOP","$W10NOOP","constants","isArray","resolve","object","path","resolveType","info","Date","assignments","$$","rhsValue","assignment","rhs","lhs","l","lhsLast"],"mappings":"+XACA,IAAIA,EAAQC,MAAMC,UAAUF,MAE5B,SAASG,EAAWC,GAChB,MAAsB,mBAARA,EAGlB,SAASC,EAAcC,GACnB,IAAKH,EAAWG,GACZ,MAAMC,UAAU,oBAIxB,SAASC,EAAeC,EAAIH,EAAUI,GAClC,OAAQA,EAAKC,QAET,KAAK,EACDL,EAASM,KAAKH,GACd,MACJ,KAAK,EACDH,EAASM,KAAKH,EAAIC,EAAK,IACvB,MACJ,KAAK,EACDJ,EAASM,KAAKH,EAAIC,EAAK,GAAIA,EAAK,IAChC,MAEJ,QACIJ,EAASO,MAAMJ,EAAIT,EAAMY,KAAKF,EAAM,KAIhD,SAASI,EAAYC,EAAcC,EAAMV,EAAUW,GAC/CZ,EAAcC,GAEd,IAAIY,EAASH,EAAaI,KAAOJ,EAAaI,GAAK,IAE/CC,EAAYF,EAAOF,GAevB,OAdII,EACIjB,EAAWiB,GACXF,EAAOF,GAAQC,EAAU,CAACX,EAAUc,GAAa,CAACA,EAAWd,GAEzDW,EACAG,EAAUC,QAAQf,GAElBc,EAAUE,KAAKhB,GAKvBY,EAAOF,GAAQV,EAEZS,EAGX,SAASQ,IACLC,KAAKL,GAAKK,KAAKL,IAAM,GAGzBI,EAAaA,aAAeA,EAE5BA,EAAarB,UAAY,CACrBiB,GAAI,KAEJM,KAAM,SAAST,GACX,IAAIN,EAAOgB,UAEPR,EAASM,KAAKL,GAClB,GAAKD,EAAL,CAIA,IAAIE,EAAYF,GAAUA,EAAOF,GACjC,IAAKI,EAAW,CAEZ,GAAa,UAATJ,EAAkB,CAClB,IAAIW,EAAQjB,EAAK,GACjB,KAAMiB,aAAiBC,OAAQ,CAC3B,IAAIC,EAAUF,GACdA,EAAQ,IAAIC,MAAM,UAAYC,IACxBA,QAAUA,EAGpB,MAAMF,EAGV,OAAO,EAGX,GAAIxB,EAAWiB,GACXZ,EAAegB,KAAMJ,EAAWV,QAIhC,IAAK,IAAIoB,EAAE,EAAGC,GAFdX,EAAYpB,EAAMY,KAAKQ,IAEKT,OAAQmB,EAAEC,EAAKD,IAAK,CAC5C,IAAIxB,EAAWc,EAAUU,GACzBtB,EAAegB,KAAMlB,EAAUI,GAIvC,OAAO,IAGXsB,GAAI,SAAShB,EAAMV,GACf,OAAOQ,EAAYU,KAAMR,EAAMV,GAAU,IAG7C2B,gBAAiB,SAASjB,EAAMV,GAC5B,OAAOQ,EAAYU,KAAMR,EAAMV,GAAU,IAG7C4B,KAAM,SAASlB,EAAMV,GAcjB,OAbAD,EAAcC,GAWdkB,KAAKQ,GAAGhB,GATR,SAASmB,IACLX,KAAKY,eAAepB,EAAMmB,GAEtB7B,IACAA,EAASO,MAAMW,KAAME,WACrBpB,EAAW,SAMZkB,MAIXY,eAAgB,SAASpB,EAAMV,GAC3BD,EAAcC,GAEd,IACIc,EADAF,EAASM,KAAKL,GAGlB,GAAID,IAAWE,EAAYF,EAAOF,IAC9B,GAAIb,EAAWiB,GACPA,IAAcd,UACPY,EAAOF,QAGlB,IAAK,IAAIc,EAAEV,EAAUT,OAAO,EAAGmB,GAAG,EAAGA,IAC7BV,EAAUU,KAAOxB,GACjBc,EAAUiB,OAAOP,EAAG,GAMpC,OAAON,MAGXc,mBAAoB,SAAStB,GACzB,IAAIE,EAASM,KAAKL,GACdD,UACOA,EAAOF,IAItBuB,cAAe,SAASvB,GACpB,IAAIE,EAASM,KAAKL,GACdC,EAAYF,GAAUA,EAAOF,GACjC,OAAOI,EAAajB,EAAWiB,GAAa,EAAIA,EAAUT,OAAU,IAI5E6B,EAAOC,QAAUlB,G,sECrKjB,IAGImB,EAAU,UAEd,SAASC,EAAkBC,GACzB,OAAQA,EAAOV,KAGjB,SAASW,EAAoBD,GACzBpB,KAAKsB,UAAYF,EACjBpB,KAAKuB,aAAe,GACpBvB,KAAKwB,eAAiB,KAuH1B,SAASC,EAAoBL,GACzBpB,KAAKsB,UAAYF,EA2BrB,SAASM,IACL1B,KAAK2B,mBAAqB,GAjJ9BN,EAAoB3C,UAAY,CAC5BkD,UAAW,SAASC,EAAMC,GACtB,IAAIV,EAASpB,KAAKsB,UACd1B,EAAYI,KAAKuB,aAErBvB,KAAKuB,aAAe3B,EAAUmC,QAAO,SAASC,GAC1C,IAAIC,EAAWD,EArBT,GAsBFE,EAAkBF,EArBR,GAsBVG,EAAyBH,EArBZ,GAuBjB,GAAIF,GAMA,GAAIK,GAA0BN,EAAKI,EAAUE,GAGzC,OAFAf,EAAOR,eAAeqB,EAAUE,IAEzB,OAER,GAAIN,EAAKI,EAAUC,GAOtB,OAFAd,EAAOR,eAAeqB,EAAUE,GAA0BD,IAEnD,EAGX,OAAO,KAOX,IAAIE,EAAcpC,KAAKwB,eAEvB,IAAKxB,KAAKuB,aAAapC,QAAUiD,EAAa,CAC1C,IAAIC,EAAOrC,KACPsC,EAAkBF,EAAYT,mBAClCS,EAAYT,mBAAqBW,EAAgBP,QAAO,SAASQ,GAC7D,OAAOA,IAAQF,OAK3B7B,GAAI,SAASgC,EAAO1D,GAGhB,OAFAkB,KAAKsB,UAAUd,GAAGgC,EAAO1D,GACzBkB,KAAKuB,aAAazB,KAAK,CAAC0C,EAAO1D,IACxBkB,MAGXU,KAAM,SAAS8B,EAAO1D,GAClB,IAAIuD,EAAOrC,KAKPyC,EAAkB,WAClBJ,EAAKT,WAAU,SAASY,EAAOE,GAC3B,OAAOD,IAAoBC,KAC5B,GAEH5D,EAASO,MAAMW,KAAME,YAKzB,OAFAF,KAAKsB,UAAUZ,KAAK8B,EAAOC,GAC3BzC,KAAKuB,aAAazB,KAAK,CAAC0C,EAAO1D,EAAU2D,IAClCzC,MAGXY,eAAgB,SAAS4B,EAAO1D,GAkB5B,MAjBqB,mBAAV0D,IACP1D,EAAW0D,EACXA,EAAQ,MAGR1D,GAAY0D,EACZxC,KAAK4B,WAAU,SAASK,EAAUD,GAC9B,OAAOQ,IAAUP,GAAYnD,IAAakD,KAEvClD,EACPkB,KAAK4B,WAAU,SAASK,EAAUD,GAC9B,OAAOlD,IAAakD,KAEjBQ,GACPxC,KAAKc,mBAAmB0B,GAGrBxC,MAGXc,mBAAoB,SAAS0B,GAEzB,IAAI5C,EAAYI,KAAKuB,aACjBH,EAASpB,KAAKsB,UAElB,GAAIkB,EACAxC,KAAK4B,WAAU,SAASK,EAAUD,GAC9B,OAAOQ,IAAUP,SAElB,CACH,IAAK,IAAI3B,EAAIV,EAAUT,OAAS,EAAGmB,GAAK,EAAGA,IAAK,CAC5C,IAAIiC,EAAM3C,EAAUU,GACpBc,EAAOR,eAAe2B,EA1HpB,GA0HsCA,EAzH9B,IA2HdvC,KAAKuB,aAAapC,OAAS,EAG/B,OAAOa,OAQfyB,EAAoB/C,UAAY,CAC5B8B,GAAI,SAASgC,EAAO1D,GAEhB,OADAkB,KAAKsB,UAAUqB,iBAAiBH,EAAO1D,GAChCkB,MAGXU,KAAM,SAAS8B,EAAO1D,GAClB,IAAIuD,EAAOrC,KAGP4C,EAAe,WACjBP,EAAKf,UAAUuB,oBAAoBL,EAAOI,GAC1C9D,KAGF,OADAkB,KAAKsB,UAAUqB,iBAAiBH,EAAOI,GAChC5C,MAGXY,eAAgB,SAAS4B,EAAO1D,GAE5B,OADAkB,KAAKsB,UAAUuB,oBAAoBL,EAAO1D,GACnCkB,OAQf0B,EAAoBhD,UAAY,CAE5B0D,YAAa,SAAShB,EAAQ0B,GAM1B,IALA,IACIC,EACAC,EAFAC,GAAsBH,IAA0C,IAA/BA,EAAQG,mBAGzCX,EAAkBtC,KAAK2B,mBAElBrB,EAAE,EAAGC,EAAI+B,EAAgBnD,OAAQmB,EAAEC,EAAKD,IAAK,CAClD,IAAIiC,EAAMD,EAAgBhC,GAC1B,GAAIiC,EAAIjB,YAAcF,EAAQ,CAC1B2B,EAAUR,EACV,OA6BR,OAzBKQ,IACG5B,EAAkBC,KACpB4B,EAAQ,IAAIvB,EAAoBL,IAGlC2B,EAAU,IAAI1B,EAAoB2B,GAAS5B,GACvC6B,IAAuBD,GACvBD,EAAQrC,KAAKQ,GAAS,WAClB6B,EAAQjC,qBAER,IAAK,IAAIR,EAAIgC,EAAgBnD,OAAS,EAAGmB,GAAK,EAAGA,IAC7C,GAAIgC,EAAgBhC,GAAGgB,YAAcF,EAAQ,CACzCkB,EAAgBzB,OAAOP,EAAG,GAC1B,UAQhByC,EAAQvB,eAAiBxB,KACzBsC,EAAgBxC,KAAKiD,IAGlBA,GAGXjC,mBAAoB,SAASM,EAAQoB,GACjC,IACIlC,EADAgC,EAAkBtC,KAAK2B,mBAG3B,GAAIP,EACA,IAAKd,EAAIgC,EAAgBnD,OAAS,EAAGmB,GAAK,EAAGA,IAAK,CAC9C,IAAIiC,EAAMD,EAAgBhC,GAC1B,GAAIiC,EAAIjB,YAAcF,EAAQ,CAC1BmB,EAAIzB,mBAAmB0B,GAElBD,EAAIhB,aAAapC,QAGlBmD,EAAgBzB,OAAOP,EAAG,GAG9B,WAGL,CACH,IAAKA,EAAIgC,EAAgBnD,OAAS,EAAGmB,GAAK,EAAGA,IACzCgC,EAAgBhC,GAAGQ,qBAEvBwB,EAAgBnD,OAAS,MAKrC8B,EAAUD,EAAOC,QAAUS,GAEnBwB,KAAO,SAASC,GACpB,IAAIH,EACAD,EAcJ,OAZI5B,EAAkBgC,KACpBH,EAAQ,IAAIvB,EAAoB0B,IAGlCJ,EAAU,IAAI1B,EAAoB2B,GAASG,GACtCH,GAEHG,EAAmBzC,KAAKQ,GAAS,WAC7B6B,EAAQxB,aAAapC,OAAS,KAI7B4D,GAGX9B,EAAQmC,cAAgB,WACpB,OAAO,IAAI1B,I,+ECjQf,IAAI2B,EAAYC,EAAhB,uDAYA,SAASC,EAAaC,GACpBxD,KAAA,IAAWA,KAAK,GAAhB,EACAA,KAAA,UAGFgB,YAEA,IAAIyC,EAASF,YAAyB,CACpCG,aAAc,WACZ,OAAO1D,KAAK2D,gBAAZ,IAEFA,cAAe,YACb,YAAI3D,KAAK,GACP,MAAMI,MAAN,oBAGF,IAAIwD,EAzBR,SAA0BC,GACxB,IAAID,EAAgBC,EAApB,GAEA,MACE,MAAMzD,MAAN,gBAEF,SAmBsB0D,CAApB,MAEIC,EAAJ,GASA,OAPAH,WAAsB,YACpB,IAAII,EAAYC,EAAhB,GACKC,IAAYA,EAAjB,IACEH,aAIJ,GAGFI,YAAa,YACX,IACIC,EADMpE,KAAV,GACA,GAOA,OALEA,KAAA,GADF,EACuBoE,KAArB,GAEA,KAGF,MAEFC,QAAS,YACP,OAAOrE,KAAK,GAAL,GAAP,IAEFsE,UAAW,WACT,OAAOtE,KAAK,GAAZ,MAEFuE,SAAU,WACR,OAAOvE,KAAK,GAAZ,YAEFwE,SAA6B,oBAAZA,UA3CnB,UA8CAC,+BAAqC,CACnCC,IAAK,WAOH,OAAO1E,KAAP,cAIJyE,kCAAwC,CACtCC,IAAK,WAOH,OAAO1E,KAAP,MAWJqD,EAAU,GAER,SAAesB,EAAcC,GAC3B,OAAOD,UAAqBC,EAA5B,kBAEF,SAAqBD,EAAcC,GACjC,IAAIC,EACoB,mBAAfC,YAA6BF,aADtC,WAEA,OAAOD,cACLE,EAAWD,EAAcA,EAD3B,mB,uFCrGJ,IA8JIG,EA5JA1B,EAAYC,EAAhB,uDACI0B,EAAmB1B,EAAvB,sDACI2B,EAAuB3B,8EAEvB4B,EAAiB5B,EAArB,oEACI6B,EAAkBD,EAAtB,GACIE,EAAuBF,EAA3B,GACInF,EAAeuD,EAAnB,gDACIC,EAAeD,EAAnB,yDACI5B,EAAsB4B,EAA1B,+DACI+B,EAAU/B,EAAd,6CACIgC,EAAgBhC,EAApB,sEACIiC,EAAWjC,EAAf,gEACIkC,EAAkBlC,EAAtB,wEACImC,EAAUnC,EAAd,gEACIoC,EAAsBD,EAA1B,GACIE,EAA6BF,EAAjC,GACIG,EAAJ,sBAEIC,EAAiBpB,iBAArB,eACIjG,EAAQC,gBAAZ,MAGIqH,EAAqC,CACvC7C,oBADF,GAIIhD,EAAOF,YAAX,KAGA,SAASa,EAAemF,GACtBA,IAmBF,SAASC,EAAoC,EAA7C,OAOE9G,UAEA,IACEA,EAAO+G,SAAP/G,IAGF,IAAIgH,EAAkBf,EAAgBnB,EAAtC,IACImC,EAC0B,mBAArBC,EAAP,EAEIF,EAHN,GAIA,MACE,MAAM9F,MAAM,qBAAZ,GAGF+F,aAGF,SAASE,EAAiBC,EAAKC,GAC7B,OAAOA,EAAQD,MAAH,EAAZ,EAuFF,SAASE,EAAUC,GACjB1G,aACAC,KAAA,KACAA,KAAA,QACAA,KAAA,QACAA,KAAA,QACAA,KAAA,QACAA,KAAA,GAPqB,KAQrBA,KAAA,QACAA,KAAA,QACAA,KAAA,QACAA,KAAA,UACAA,KAAA,MACAA,KAAA,UACAA,KAAA,MACAA,KAAA,MACAA,KAAA,MACAA,KAAA,MACAA,KAAA,UAEA,IAAI0G,EAAmBf,EAAvB,GAEA,GACE3F,KAAA,YACO2F,EAAP,IAEA3F,KAAA,MAIJwG,YAAsBzB,EAAiB,CACrC,IADqC,EAGrC3C,YAAa,YACX,MACE,MAAMrD,YAGR,IAAI4H,EACF3G,KAAK,KACJA,KAAK,GAAmB,IAF3B,GAII4G,EAAqBxF,UAvLzByF,EAuLA,EAIA,OAAOF,gBAAP,IAGF1G,KAAM,YACJ,IACA,EADI6G,EAAe9G,KAAnB,GAGA,GAAI8G,IAAiB1F,EAAS0F,EAA9B,IAAwD,CACtD,IAAIV,EAAmBhF,EAAvB,GACI2F,EAAS3F,EAAb,GACI6E,EAAY7E,EAAhB,GACIlC,EAAOV,iBAAX,GAEAwH,EAAoC,KAAD,IAAnCA,GAOA,UACSc,EAAP,GAIJ,OAAO7G,aAAP,YAEF+G,QAAS,cACP,SA9JJ,SAAkChD,EAAWsC,EAAKC,GAChD,OAAOvC,SAAqBqC,EAAiBC,EAA7C,GAgKSW,CAAyBjH,KAAMsG,EAAtC,GAFStG,KAAP,IAIJkH,MAAO,cACL,SACqBlH,KAAK,GACtB,IAAMqG,EAAiBC,EADzB,IAkBOtG,KAAP,IAGJmH,OAAQ,YACNb,QAKA,IAHA,IAEA,EAFIc,EAAJ,GACI9G,EAAJ,EAEQ+G,EAAKrH,KAAKkH,MAAMZ,EAAxB,IACEc,UACA9G,IAEF,UAEFoD,aAAc,cACZ,IAAI4D,EAAWtH,KAAK,GAAiB,IAAMqG,EAAiBC,EAA5D,IAUA,OAAOgB,GAAY5B,MAAnB,IAEF/B,cAAe,YACb,IAAI4D,EAASvH,KAAK,GAAiB,IAAMsG,EAAzC,MACA,OAAOiB,EACH9C,oBACO,YACH,OAAOiB,MAAwB6B,EAA/B,OAFJ9C,OADS,SAAb,IAQF+C,QAAS,WACP,IAAIxH,KAAJ,IAIA,IAAIyH,EAAOzH,KAAX,GAEAA,KAAA,KAEYyH,EAAZ,MAEAC,SAAc,YACZtC,MAEA,IAAII,UACFmC,+BAIJF,qBAEOtC,EAAgBnF,KAAvB,IACAA,KAAA,QAGF,GAAmB,WACjB,IAAIA,KAAJ,IAIAA,KAAA,MACAA,KAAA,MAEA0F,MAAwB1F,KAAxB0F,WAEA1F,KAAA,QAGAA,KAAA,MAEA,IAAI2G,EAAgB3G,KAApB,GACA,IACE2G,uBACA3G,KAAA,WAIJ4H,YAAa,WACX,OAAO5H,KAAP,IAEF,YACE,OAAOA,KAAP,IAEF,aACE,IAAI6H,EAAQ7H,KAAZ,IACK6H,GAAL,KAIA,IACEA,EAAQ7H,KAAK,GAAW,IAAIA,KAAJ,IAAxB6H,OAGFA,MAAiBC,GAAjBD,IAEIA,EAAJ,IACE7H,KAAA,MAGF,IACEA,KAAA,WAGJ+H,SAAU,cACR,IAAIF,EAAQ7H,KAAZ,GAKA,GAHA,IACE6H,EAAQ7H,KAAK,GAAW,IAAIA,KAAJ,IAAxB6H,OAEF,iBAAWG,EAAkB,CAE3B,IAAIF,EAAJ,EACA,IAAK,IAAL,OACMjC,SAAJ,IACEgC,QAAgBC,EAAhBD,YAIJA,eAIJI,cAAe,cACb,IAAIJ,EAAQ7H,KAAZ,GAEA,GAAIE,mBACFgI,EAAQL,EAARK,IAGFL,kBAQFM,aAAc,YACZnI,KAAA,WAGF,YACE,OAAOA,KAAP,IAEF,aACMA,KAAJ,GACEA,KAAA,KAEAA,KAAA,QAIJ,IAAa,gBAEX,MADAoI,EAAUA,GAAWpI,KAArBoI,QAGA,IAAIC,EAAWrI,KAAf,GAyBA,OAxBAA,KAAA,UACAA,KAAA,IAAmBwD,GAAOA,EAAR,IAA6BxD,KAA/C,IAEA,IAGEA,KAAA,MACAsI,EAAeF,YAAmBG,GAAnBH,GAAfE,GACAtI,KAAA,OAGFuI,EAAWvI,KAAK,GAAiBsI,GAAjCC,GAEKvI,KAAK,GApTd,SAA2BwI,EAAmBH,EAAUE,GACtD,GAAIF,GAAJ,EAA0B,CACxB,GAAIA,SAAJ,MAAwBE,EACtB,SAGF,IAAIE,EAAUhE,YAAd,GACIiE,EAAUjE,YAAd,GACIlE,EAAMkI,EAAV,OACA,GAAIlI,IAAQmI,EAAZ,OACE,SAGF,IAAK,IAAIpI,EAAT,EAAkBA,KAAO,CACvB,IAAIgG,EAAMmC,EAAV,GACA,KAAMnC,SAAmB+B,OAAkBE,EAA3C,GACE,UAKN,SA+RuBI,CAAkB3I,EAAMqI,EAA7C,KACErI,KAAA,WAGF,IAAIA,KAAK,KACPA,KAAA,KACIuI,GAAYA,EAAhB,UACEvI,KAAA,GAAiBuI,EAAjB,UAIJ,GAGFK,YAAa,WACX5I,KAAA,MACAA,KAAA,OAGF,IAAgB,WACTA,KAAL,KACEA,KAAA,MACAsF,cAIJuD,OAAQ,WACN,IAAI,IAAA7I,KAAK,KAAT,IAAkCA,KAAK,IAAvC,CAIA,IAAI8I,EAAQ9I,KAAZ,GACI6H,EAAQ7H,KAAZ,IAEI,IAAAA,KAAK,IAAL,OAA2B6H,IAA/B,IAAiDA,MAhYrD,SAA+B7D,EAAW+E,EAAcC,GACtD,MACA,EAEA,IAAK,IAAL,OACE,GAAInD,SAAJ,GAAiD,CAI/C,KADAoD,EAAgBjF,EAFQ,UAAxB,IAQE,QAJCkF,IAAaA,EAAd,UAAmC,CAACC,EAApC,IA6BN,OAjBA,IAIED,WAAiB,YACf,IAAIE,EAAeC,EAAnB,GACAJ,EAAgBI,EAAhBJ,GAEA,IAAIK,EAAWP,EAAf,GACIQ,EAAWP,EAAf,GACAC,iBAGFjF,OACAA,SAGF,EA0VQwF,CAAsBxJ,KAAM6H,EAAP,IAAyBA,EAAzB,OACvBA,UAIJ,IAAI7H,KAAK,MAIP,IAAIA,KAAKyJ,aAAaX,EAAOjB,IAC3B7H,KAAA,MAIJA,KAAA,OAGF,UACE,OACE,IAAAA,KAAK,IACJ,OAAAA,KAAK,KAFR,IAE6BA,KAAK,GAAL,IAI/B,GAAU,WACRA,KAAA,MACAA,KAAA,MACAA,KAAA,QACA,IAAI6H,EAAQ7H,KAAZ,GACA,GACE6H,QAIJ4B,aAAc,WACZ,UAGF,IAAqB,WACnB,IAAIpH,EAAJ,KAGA,IAFeA,EAAf,IAGE,MAAMtD,YAGR,IAAI+J,EAAQ9I,KAAK,IAAkBA,KAAnC,GAEAsF,OAA6B,WAC3BjD,wBAA2CA,EAA3CA,OAGFrC,KAAA,MAGF,IAAa,cACX,IAAI0J,EAAM1J,KAAV,GACI2J,EAAa3J,KAAjB,GACIsH,EAAWtH,KAAf,GACI4J,EAAW5J,KAAf,IAEIwD,GADYoG,aAAhB,GACA,GACApG,SACAA,KAAkBxD,KAAlBwD,GACAA,KAAmBxD,KAAnBwD,IAEA,IAAIY,EAAoBa,EAAxB,GACI4E,EAA0BzF,EAA9B,GACAyF,WACAA,OAEAD,EAASd,EAATc,GAEA,IAAI/F,EAAS,IAAIN,EAAjB,GAEIuG,EAAatG,OAAjB,IAIA,OAFA+B,EAAS+B,EAAUwC,EAAYJ,EAA/BnE,GAEA,GAGF,IAAW,WACT,IAAIkC,EAAOzH,KAAX,GAEA,OADAyH,WACA,GAGF,IAA4B,WAC1B,IAAIsC,EAAuB/J,KAA3B,GACA,IACE+J,aACA/J,KAAA,UAIJ,UACE,IAAI6H,EAAQ7H,KAAZ,GACA,OAAO6H,GAASA,EAAhB,KAGF,IAAoB,cAClB,IAAImC,EAAqBhK,KAAK,GAA9B,GACAA,KAAA,KAEA8G,WAAqB,YACnB,IAAImD,EAAYC,EAAhB,GACI9D,EAAmB8D,EAAvB,GACInD,EAASmD,EAAb,GACIjE,EAAYiE,EAAhB,GAEAF,KAA+B,CAAC5D,EAAkBW,EAAlDiD,OAIJ,SACE,OA7iBJ,SAAuBG,GAGrB,IAFA,MAEA,IACExC,EAAOwC,EAAPxC,aAMAwC,EAAWxC,EAAXwC,SAGF,SAgiBSC,CAAcpK,KAArB,KAGF,UAOE,OAAQA,KAAK,GAAcA,KAAK,GAAxB,MAAD,YAAwD,YAG7D,OAhkBN,IAgkBaqH,eAIX,IA/ZqC,EAgarC,SACErH,KAAA,UAAiBA,KAAKqK,SAASvB,EAA/B,GACA9I,KAAA,mBAGF,OACEA,KAAA,UAAiBA,KAAKsK,SAAtB,GACAtK,KAAA,iBAGF,KACEA,KAAA,UAAiBA,KAAjB,WACAA,KAAA,eAGF,MACEA,KAAA,SAAgBA,KAAhB,UACAA,KAAA,cAGF,MACEA,KAAA,WAAkBA,KAAlB,YACAA,KAAA,iBAIJ+E,OAAsBA,EAAtBA,QACAA,MAA2BA,EAA3BA,OACAA,MAA4BA,EAA5BA,QASA1B,EAAU,GAER,SAAeW,GACb,OAAOA,EAAP,SAEF,SAAqBA,GACnB,YAIJqB,EAAQmB,EAARnB,GAEArE,a,0FCtpBA,IACIuJ,EAAUjH,iDAEVkH,EADgBlH,EAApB,oEACA,IACImH,EAA2BnH,8EAE3BoH,EAASpH,EAAb,4CACIqH,EAAcrH,EAAlB,mEACIsH,EAAJ,GAUA,SAASC,EAAa7G,EAAW8G,EAAa1G,GAC5CpE,KAAA,IAD+D,EAE/DA,KAAA,KACAA,KAAA,KAEAA,KAAA,SAL+D,EAO/DA,KAAA,OAEAA,KAAA,OACAA,KAAA,MAEAA,KAAA,IAZ+D,EAa/DA,KAAA,SAGF6K,YAAyB,CACvB,IAAY,YACV,OACE7K,KAAK,MAAmBA,KAAK,IAAiB,IADzC,QAAP,IASF+K,KAAM,YACJ,IAAItE,EAAKzG,KAAT,GAEA,aAAIgL,EACF,GAEA,iBAAWA,IAMTA,EAAWC,OAAXD,IAGF,IAAIA,iBACFvE,EAAK,IAALA,EACAuE,EAAWA,YAAXA,IAGKvE,MAAP,IAMJ,IAAoB,WAClB,OAAOzG,KAAKyG,GAAK,KAAOzG,KAAxB,OAGFkL,EAAG,kBAED,OADAT,KACOD,EAAoBxK,KAAMmL,EAAmBpE,EAApD,IAGF,UACE,OAAO/G,KAAK,GAAZ,MAIJ6K,eAA4BA,YAA5BA,IAEAA,MAA8B,kBAC5B,IAAIpE,EAAK2E,EAAT,GACIC,EAAWC,EAAMF,EAArB,IACItC,EAAQsC,MAAZ,KACIG,EAAQH,MAAZ,EAEIvD,EAAQ0D,EAAZ,EACIC,EAAiBD,EAArB,EACIE,EAAQF,EAAZ,EACIvH,EAAY0H,QAAhB,GAUA,GANA1H,QAzFF,EA2FMyH,KACD3C,IAAUA,EAAX,mBA7FJ,EAgGM2C,EACEzH,EAAJ,UACEA,aAA0B,CAAE2H,OAA5B3H,IAEEA,EAAJ,UACE8E,EAAQ9E,YAAyB,CAAE2H,OAA3B3H,KAAR8E,OAEG,CACL,KAAW,CACT,IAAI8C,EAAqBL,EAAzB,EACA,GACEK,WAA2B,YACzB/D,eAKJ7D,UAGF,GACE0G,EAAO1G,EAAP0G,GAIJ1G,OAEIuH,EAAJ,IACEvH,KAAiCuH,EAAjCvH,GAGF,IAAI6H,EAAQN,EAAZ,EACIzE,EAAeyE,EAAnB,EAOA,OANA,GACEvH,WAGFA,OAEO,CACLyC,GADK,EAEL,GAFK,EAGL,IAAc8E,EAHT,EAIL,IAAUA,KAJZ,IAQFvK,a,+FCzJA,IAAI8K,EAA0BxI,EAA9B,+EAEA,SAASyI,EAAkBvI,EAAKwI,GAC9B,MACA,EAME,EAJF,GACEnC,EAA0BmC,EAA1BnC,GACA5F,EAAe+H,EAAf/H,IAIIgI,EAA0BD,EAD9B,OAGEC,EAA0BD,MAA1BC,IAGFA,mBAGA,KADApC,EAA0BrG,SAA1BqG,MAEErG,YAA2BqG,EAA0B,IAAIiC,EAAzDtI,IAMJxD,KAAA,KACAA,KAAA,MACAA,KAAA,KACAA,KAAA,KACAA,KAAA,WACAA,KAAA,GACEgM,GAA2BA,EAD7B,GAIFD,YAA8B,CAC5B,GAAmB,YACjB,IAAInI,EAAgB5D,KAApB,GAUA,OARA+L,WAEA/L,KAAA,eAIAA,KAAA,oBAEA,IAQJgB,UAAiBC,EAAjBD,EAEAC,EAAQ,GANR,SAA8BuC,GAC5B,OAAOA,OAAsBA,KAAoB,IAAIuI,EAArD,M,qGCtDF,IAAIG,EAA0B5I,0EAQ9BtC,UANA,SAAiCwC,GAC/BxD,KAAA,OACAA,KAAA,WACAA,KAAA,IAA0BkM,EAA1B,K,mFCLF,SAASvB,IACP3K,KAAA,IAAiByE,cAAjB,MAGFkG,gBAAmC,YACjC,IAAIpD,EAASvH,KAAb,IAEA,OAAIuH,EAAJ,GACSjB,MAAYiB,EAAnB,MAGFA,OACA,IAGFvG,a,mFCfA,IAAI0J,EAASpH,EAAb,4CAgBA,SAAS6I,EAAMnI,GACbhE,KAAA,KACAA,KAAA,OAEAA,KAAA,MACAA,KAAA,SACAA,KAAA,SACAA,KAAA,IAPwB,KASxByE,kBAGF0H,YAAkB,CAChB,GAAU,WACR,IAAI9J,EAAJ,KAEAA,QACAA,WACAA,WACAA,YAGF,IAAY,YACV,IACA,EAEI+J,EAAWpM,KAAf,IAEA,WACQsG,KAAN,GANF,KAOIuB,oBASJ,WAhBA,KAiBEA,MAEEC,EAFFD,WAQJ,IAAQ,kBACN,IA/DmBuB,EACjB3F,EA8DE2I,EAAWpM,KAAf,IAMA,GAJA,IAjEmBoJ,EAkEjBiD,EAjEA5I,EAiEOzD,KAjEC6H,YAAZ,UACMuB,KAAN,GACE3E,0BAA2C,CACzCC,IAAK,WACH,OAAO1E,KAAK,IAAZ,IAEFsM,IAAK,YACHtM,KAAA,gBA6DJ,GACyBA,KAAK,MAAcA,KAAK,IAA/C,KACAuM,WACK,GAAIH,OAAJ,EACL,OAGGpM,KAAL,KAIEA,KAAA,IAJkB,EAKlBA,KAAA,MACAA,KAAA,IAAcoM,EAAW1B,EAAO,GAAhC,GACA1K,KAAA,OACAA,KAAA,UAGFA,KAAA,cAEA,IAAIkI,SAEKkE,EAAP,GAGAA,QAGJI,OAAQ,WACN,OAAOxM,KAAP,MAIJgB,a,6FCrGA,IAAIyL,EAAYnJ,EAAhB,6DACIoJ,EAAgBpJ,EAApB,iEACI+B,EAAU/B,EAAd,6CAEAtC,UAAiB,SAAyB2L,EAAK/C,GAC7C,GAAI+C,EAAJ,GACE,SAGF,IACA,EADIC,EAAiB,aAGjBpN,SAAJ,EAEA,eAAIA,EACFiE,EAAQkJ,EAARlJ,cACK,cAAIjE,EAGT,MAAMT,YAFN0E,IAaF,cACEiJ,eAkBF,cACED,eAMF,OAlCAG,cAYKnJ,EAAL,IAEE4B,EAAQuH,EAARvH,GAKF5B,EAAQ+C,YAAsBoG,EAA9BnJ,UAMA+C,QAKAnB,EAAQ8G,EAAR9G,GACA5B,QACAA,QAEA,I,gFC3DFzC,EAAA,QAAiB,CACf,IAAoB,IADL,QAEf,IAAsB,IAFP,QAGf,GAAuB,IAHR,QAIf,IAAsB,IAJP,QAKf,IAAiB,IALF,QAMf,GANF,K,8FCAA,IAAIkE,EAAiB5B,EAArB,oEACIuJ,EAAY3H,EAAhB,IACIC,EAAkBD,EAAtB,GACI4H,EAAsB5H,EAA1B,IAMI6H,EAAuB,OAA3B,EACIC,EAAJ,GAEA,SAASC,EAAe5F,EAAI6F,GAC1B,IACIC,EADeL,EAAnB,GACA,GAYA,MAVA,iBAAWK,KACTA,EAAYA,QAAZA,MACA,KACEA,cAAeA,MAEjB,GAAIA,WACFA,KAAeC,SAASD,EAAD,GAAvBA,MAIJ,EAGF,SAASE,EAAc1F,EAAMuF,EAAW9L,EAAQoB,GAC9C,IAAI2D,EAAe/E,EAAnB,GACIkM,EAAoBlM,EAAxB,GACI2F,EAAS3F,EAAb,GACI6E,EAAY7E,EAAhB,GAEA,UACqB0L,EAAnB,GACA,GAGF,IAAI5G,EAAkBf,EAAtB,GAEA,MAIA,IAAIoI,EACsB,mBAAjBpH,EAAP,EAEID,EAHN,GAIA,MACE,MAAM9F,MAAM,qBAAZ,GAGF,MAAI6F,GACF,iBAAWA,IACTA,EAAYC,KAAZD,IAKJ,EACEsH,UAAkCtH,WAAlCsH,IAEAA,eAgEJ,SAASC,KAETvM,EAAQ,IAARA,EACAA,EAAQwM,IAARxM,EACAA,EAAQ,IAARA,EACAA,EAAQ,IAARA,EACAA,EAAQ,IAlER,SAAkCgJ,GAC3B+C,EAAL,KACEA,UAiEJ/L,EAAQ,IAAU,YAChBwD,wBAAqC,aA9DvC,SAAuCwF,EAAWP,GAChD,IAAIgE,EAAOhE,QAAX,EACI9J,EAAa8J,KAA4BA,MAA7C,GACK9J,EAAL,IACE8N,qBAEG9N,KAAuB,YACtB,IAAI+N,GAAJ,EAGIC,EAAqBpL,EAAzB,gBAEAA,kBAAwB,WACtBoL,UACAD,MAGF,IAAIE,EAAUrL,EAAd,OACA,MAIAqL,EAIEA,4BA/FV,IAkGWA,WAAiCA,EAAjCA,WAPHA,GAWA,IACA,EADI1E,EAAW,KAAf,EAMA,GACE,IAAK/H,EAAS6L,EAAeY,EAA7B,MACER,EAAcQ,EAAS1E,EAAU/H,EAAjCiM,GAEA,GACE,aAGIQ,EAAUA,EAAX,aAAkCA,EAR3C,iBAnCJH,GA2DAI,CAA8B7D,EAA9B6D,Q,2FCzIJ,IAAI5I,EAAiB5B,EAArB,oEACIyK,EAAiBzK,EAArB,+EACIoI,EAAWpI,EAAf,wEAEAA,+EACEyK,EADFzK,IAGArC,EAAQ+M,kBAAoB9I,EAA5BjE,IACAA,EAAQgN,KAAOC,uBAAyBH,EAAxC9M,IAEAA,EAAQkN,SAAW,cACjBzC,OAAe,WACb,c,qGCXJ,IAuBI0C,EAtBAC,EAAiB/K,EAArB,yCACIkC,EAAkBlC,EAAtB,wEACIgL,EAAJ,OACIC,EAAJ,SACIC,EAAqBlL,yEAErB4B,EAAiB5B,EAArB,oEACI6B,EAAkBD,EAAtB,GACIuJ,EACFvJ,EADF,IAEI2F,EAAevH,EAAnB,oEACIoI,EAAWpI,EAAf,wEACImC,EAAUnC,EAAd,gEACIqC,EAA6BF,EAAjC,GACIC,EAAsBD,EAA1B,GACIiJ,EAAJ,GACIC,EAAJ,GAQA,SAASC,EAA+BjH,EAAMkF,EAAWgC,GACvD,MACA,EACA,EACA,EACA,EACIC,EAAgBjC,EAApB,OAIA,IAHAgC,EAAQA,GAARA,GAEAlH,EAAOA,EAAPA,WACA,GAAa,CAEX,GADAoH,EAAcpH,EAAdoH,YACA,IAAIpH,WAAqB,CAEvB,IAAIqH,EAAerH,EAAnB,UACA,GAAIqH,eAAJ,EAAwD,CACtD,IAAIC,EAAYD,EAAhB,GAEA,GAAIC,SAAJ,MAAyBA,EACvBJ,eACK,SAAII,EAAmB,CAC5B,IAEA,EAFIC,EAAJ,EACIC,EAAYN,EAAhB,MAeA,GAXEvH,EADE6H,eAAyBD,EAA7B,WACaV,EAAmBW,EAAD,YAA7B7H,GAEWkH,EACTU,aAD2B,WAA7B5H,GAMFwD,EAAcqE,sBAA8BL,EAA5ChE,GAGA,OAFAmE,EAAYE,YAAZF,IAEuB,CACrB,IAAIG,EAAQtE,QAAZ,MACIxE,EAAM8I,EAAV,GACAC,EAAUD,EAAVC,GACAvE,EAAcsE,EAAdtE,GAEEwE,GADGC,EAAiBpK,EAAtB,IACkBoK,EAAhBD,GAGE3J,OACCA,KAFH2J,IAIFb,EAAgC,EAAD,IAA/BA,GAQFC,OAEAS,4BACAD,mCAGC,OAAIvH,WAAqB,CAE9B,IAAI6H,EAAW7H,eAAf,kBACI8H,EAAavK,MAAjB,GACA,KAAc,CACZ,IAAIwK,EAAiBF,UAArB,KACAH,EAAUG,YAAmBE,EAA7BL,GACAG,EAAWA,cAAXA,IAEEF,GADGC,EAAiBpK,EAAtB,IACkBoK,EAAhBD,GAGE3J,OACCA,KAFH2J,KAIFA,KAEF,GACE7K,wBAAgC,YAC9B,OAAI6B,cACFd,MAA4Cc,QAA5Cd,OAINoJ,EAA+BjH,EAAMkF,EAArC+B,GAGFjH,KAmDJ,SAASgI,EAAc1L,EAAcyF,GACnC,IAAI1F,EAAYC,EAAhB,GAEAD,OACAA,OAEiBC,EAAjB,KAGED,QAGF,IAAI4L,EAAY3L,EAAhB,IACA,KAAe,CACb,IAAI8F,EAAJ,GAEA6F,WAAkB,YAGhB,IAAI3F,EAAY4F,EAAhB,GACIzJ,EAAmByJ,EAAvB,GACIC,EAAU9L,KAA2B6L,EAAzC,IACI9I,EAAS8I,EAAb,GACI5J,EAAY4J,EAAhB,IA7CN,SAA8B,EAA9B,aASE,IAAIjP,EAzBN,SAAgCyG,EAAI4C,EAAWlD,EAAQjI,GACrD,IAAIiR,EAAJ,EAUA,OATA,IACEA,EAAgB,YACdjR,KACAuI,6BAIJA,2BAEO,WACLA,4BAamB2I,CAAuB3I,EAAI4C,EAAWlD,GAAQ,YAGjE,IAAI7H,EAAO,CAACsD,EAAZ,GACA,IACEtD,EAAO+G,SAAP/G,IAvCN,SAAqC8E,EAAWoC,EAAkBlH,GAChE,IAAI+Q,EAASjM,EAAb,GACA,MACE,MAAM5D,MAAM,qBAAZ,GAGF6P,aAoCEC,CAA4BlM,EAAWoC,EAAvC8J,MAEFC,UA4BIC,CAAqB,EAAD,UAApBA,MAWErG,EAAJ,SACE/F,QAIAA,EAAJ,GACEA,QAEAA,QACAA,SA4IJ,SAASqM,EAAoBC,EAAQC,EAAM7G,EAAKmD,GAC9C,IAAI5I,EAAe4G,EAAA,MAEjB0F,EAFiB,IAGjBA,EAHiB,IAAnB,GAMIC,EAAQC,EAA4BxM,EAAxC,GAuBA,OArBA,IAIE,EACEmK,WAEAA,EAAe,CAAfA,GACA1E,uCAAyC,WACvCkF,EAA+BlF,EAA/BkF,GACAR,OACO,YACH,OAAOqC,EAA4BxM,EAAnC,MAFJmK,qBAMAA,cAKN,EAGF,SAASqC,EAA4BxM,EAAcyF,GACjD,IAGA,EAHIoB,EAAc7G,EAAlB,GACID,EAAYC,EAAhB,GACIqD,EAAWoH,EAAf,GAGA,KAME,cALOA,EAAP,GAEA1K,OACA0B,WAtXJ,EAwXQzB,OACFD,OACAW,EAAeX,MAAsBA,EAAtBA,IAAfW,GACA+L,KACO,WACL/L,oBAGF+L,KAGK,WACLf,EAAc1L,EAAd0L,KAKN,SAASe,EAAezM,GACtB,IAAID,EAAYC,EAAhB,GACA,IACEkB,EAAgBnB,EAAhBmB,OAIJ,SAASwL,EAAUC,GACjB,GAAQA,IAGV3P,EAAQ,IAzMR,SAA4B2C,EAAe8F,GAGzClE,SAEAkE,EAAMA,GAANA,EACA,IAEA,EAFInJ,EAAMqD,EAAV,OAIA,IAAKtD,EAAL,EAAcA,KAEZoQ,EADe9M,EAAfK,IAIF,IAAK3D,EAAL,EAAcA,KAEZqP,EADe/L,EAAfK,GACA0L,IAyLJ1O,EAAQ,IAjLR,SAAS4P,EAAmBC,EAAoBpH,GAC9C,IAEA,EAFIlK,SAAJ,EACIuR,EAAJ,IAGA,cAAIvR,EAAmB,CAGnBuR,GAFF,WAAIvR,GACFqN,KACAkE,MAEclE,EA/OpB,KA+OMkE,IAGFD,EAAqBxC,EAArBwC,GAEA,IAAIE,EAAa1C,KAAiB,CAChC2C,EACAC,OAFF,GAWA,OANIJ,GAAsBA,EAA1B,SACEA,WAA2B,YACzBE,eAIJ,EAGF,IAAIG,EAA0BnR,KAAKkR,SAAnC,EACAJ,EAAqBzC,EAArByC,GAEA,GACEjE,EAAY7M,KAAZ6M,EACAnD,MAEAmD,EAAYiE,KAzQhB,IA0QIpH,EAAMA,GAANA,GAmBF,IAAI0H,EAASN,KAAb,GACIP,EAAO5B,EAAX,GACI0C,EAASP,EAAb,EA0CA,OAxCA,EACE,UACSnC,EAAP,IAGF4B,KAEA,IACE5B,SAMJC,EAA+BlF,EAA/BkF,GACApJ,SAEIsL,EAAJ,IACEP,MAAkBO,EAAlBP,GAGEO,EAAJ,IACEP,MAAgBA,MACZA,aAAqBO,EADTP,GAEZO,EAFJP,IAODO,KAAD,SACO,YACH,IAAIzF,EAAWkF,MAActM,EAA7B,IAEA,OAAOyH,SACH2E,EAAoBpM,EAAcsM,EAAM7G,EADrCgC,GAEHA,YAFJ,MAJJ,qBAWA,MA8EFzK,EAAQ,IAARA,G,8FC3aA,IACIqQ,EAAiBhO,EAArB,2DACIiO,EAAkBjO,EAAtB,uEACIyK,EAAiBzK,EAArB,+EACAA,uEAEA,IAGIkO,EAHAC,EAAJ,GACIC,EAAJ,GACIC,EAAJ,GA+HA1Q,EAAQgQ,EA5HR,SAAkBzR,EAAMmN,GACtB,MAsBA,OArBA,IACEiF,EAAiBJ,EAAjBI,IAEFH,cACOC,EAAP,UACOC,EAAP,GAEA,WACSH,EAAP,GACAF,GAAe,WACbM,WAAuB,YACrB7D,MACE7O,EADF6O,KAGE7O,EAHF6O,GAIE7O,EAJF6O,aAUN,GAsGF9M,EAAQ,IANR,SAAyBoK,EAAU5E,GAEjC,OAAO,IArDT,SAA2B4E,GACzB,IAAIuB,EAAiB+E,EAArB,GAEA,YAMA/E,GAFAA,EA1BF,SAAcvB,GACZ,IAAIjK,EAASsQ,EAAb,GACA,MAAa,CAOX,IANAtQ,EAASqQ,EAATrQ,MAGEA,EAASA,MAGX,EACE,MAAMhB,MAAM,wBAAZ,GAGFsR,OAGF,SAUiBG,CAAjBjF,IAEiBA,WAAjBA,GAEA,KACEA,EAAiB2E,EAAgB3E,EAAgBA,EAAjDA,WAIFA,kBA8BA+E,OAEA,GAIqBG,CAArB,GACO,CAAP,IAKF7Q,EAAQ,IAjFR,SAAsBzB,GACpB,OAAOuS,QAAQN,EAAf,KAiFFxQ,EAAQ,IArGR,SAAuB0L,EAAKnN,EAAMkK,EAAKmD,GACrC,IACE2E,OAcDA,KAAoBA,MAArB,SAAmD,CAAC7E,EAAKjD,EAAzD,M,4FCnDF,IAAIsI,GAAJ,EACIC,EAAJ,GACIC,EAAJ,GAEIC,EAAe7O,EAAnB,yDAMA,SAAS8O,IACP,GAAIF,EAAJ,OACE,IACEG,KADF,QAMEL,MAiBN,SAASK,EAAiBC,GAIxB,IAAK,IAAIhS,EAAT,EAAgBA,EAAIgS,EAApB,OAAkChS,IAChBgS,EAAhB,GADqC,MAMvCA,WA0DFrR,EAAQ,IA3BR,SAA8B+C,GAC5B,IAAIuO,EAAgBN,EAApB,OAEA,KAAmB,CAKjB,IAAIO,EAAQP,EAAWM,EAAvB,GAKIC,EAAJ,IACEA,cAEAA,MAAiB,CAAjBA,QApEJ,IAMAR,KAEAG,MAmEED,WAKJjR,EAAQ,IAxDR,SAAqBwR,GAKnB,IAAID,EAAQ,CACV,IADF,MAIAP,UAEA,IACEQ,IADF,QAGE,IAGMD,EAAJ,KACEH,EAAiBG,EAAjBH,KAJJ,QASEJ,e,0FCzEN,IAAIxM,EAAUnC,EAAd,gEACIoC,EAAsBD,EAA1B,GACIiN,EAAgBjN,EAApB,IACIkN,EAAqBlN,EAAzB,IACImN,EAAkBnN,EAAtB,IACIoN,EAAW3E,eAAiBA,aAAe,CAAE5N,EAAjD,IACIuM,EAAYgG,EAAhB,IAEI1N,EAAJ,GAEIoJ,EAAJ,SACI3D,EAAJ,GA4BA,SAASkI,EAAwBnL,GAC/B,IAAIoL,EAAqBrN,MAAwBiC,YAAjD,GACA,IACEoL,cACO5N,EAAgB4N,EAAvB,KA4BJ,SAASC,IAKP,MAAO,IAAMH,EAAb,IA4FF5R,EAAQ,IAARA,EACAA,EAAQ,GAARA,EACAA,EAAQ,IA7JR,SAA2BoG,EAAIqC,GAM7B,IALA,IAEA,EACA,EAHI/B,EACW,iBAANN,GAAkBqC,GAAD,kBAAxB,GADF,EAKA,GAAa,CAYX,GAXI/B,EAAJ,SACMA,qBAAJ,EACEA,EAAOA,WAAPA,WAEAA,EAAOA,EAAPA,SACA3D,EAAY0B,MAAZ1B,KAEQiP,EAAWN,MAAhB,MACL3O,EAAYiP,EAAZjP,KAGF,EACE,SAGF2D,EAAOA,mBAAwBA,EAA/BA,aAwIJ1G,EAAQ,IAARA,EACAA,EAAQ,GA9HR,SAASmE,EAAqBuC,EAAM3D,GAElC,GADA8O,KACInL,gBAAJ,KAA2BA,WAAsB,CAC/C,MAEI3D,IAAcsC,EAAMoM,MAAxB,KACM/K,IAAS3D,KAAb,KACM0B,UAAiC,QAAQ7D,KAA7C,UACSmC,QACL0B,SADF,WAIO1B,KAAP,IAMN,IADA,IAAIkP,EAAWvL,EAAf,WACOuL,GAAYA,IAAavL,EAAhC,SACEvC,EAAqB8N,EAArB9N,GACA8N,EAAWA,EAAXA,cA2GNjS,EAAQ,IA9FR,WACE,UA8FFA,EAAQ,IA3FR,SAA6B,EAA7B,OAME,KAAuB,CACrB,IAAI6J,EAAc7G,EAAlB,GACA,SACS,CAACkH,EAAmBL,EAAa/D,EAAxC,GAEO,CAACoE,EAAmBL,EAA3B,KAiFN7J,EAAQ,IA5ER,SAA6BoG,GAC3B,IACA,EADI4L,EAAWN,MAAf,GAgBA,OAbA,EACEQ,EAAeF,EAAfE,KAEAA,EAAeP,MAAfO,MAEEA,EAAe9L,eAAf8L,cACAP,QAEGO,EAAeA,EAAeC,WAAH,GAF9BR,IAOJ,GA4DF3R,EAAQ,IAlDR,SAAyC,EAAzC,OAMM,QAAQY,KAAZ,IACgCyN,KAC5BA,MADF,IAEA+D,KAEA/D,QAwCJrO,EAAQ,IA1DR,SAA+BqF,EAAKgN,GAIlC,MAHA,MAAIhN,OACFA,EAAMA,UAAY,IAAMgN,EAAlBhN,IAANA,KAEF,I,sEC3HF,IAAIiN,EAMJ,SAASC,EAAU7J,GACjB,OAAO4J,EAAP,GAGFC,MARA,SAAsBC,GACpBF,KASFvS,a,6ECZA,IAAI0J,EAASpH,EAAb,4CACI4B,EAAiB5B,EAArB,oEACIwP,EAA0B5N,EAA9B,IACIE,EAAuBF,EAA3B,GACIwO,EAAUpQ,EAAd,kEAEIqQ,EAAeD,EAAnB,IACIE,EAAcF,EAAlB,IACIG,EAAcH,EAAlB,IAEA,SAASI,EAAUzM,GACjB,oBAAWA,EAAgB,CACzB,IAAI0D,EAAJ,EAEA,KADA1D,EAAK7C,wBAAL6C,IAEE,MAAMjH,MAAM,cAAZ,GAGJ,SAGF,SAAS2T,EAAanP,GACpBQ,KACA0N,KAGF9R,UAAiB,gBACf0J,EAAOtJ,EAAQ,CACb4S,SAAU,YACRpP,EAAckP,EAAdlP,GACA,IAAIyC,EAAKH,EAAMlH,KAAf,GAEA,OADA2T,EAAatM,EAAI,KAAjBsM,GACOxP,EAAYnE,KAAnB,IAEFiU,UAAW,YACTrP,EAAckP,EAAdlP,GACA,IAAIyC,EAAKH,EAAMlH,KAAf,GAEA,OADA2T,EAAatM,EAAIzC,cAAL,KAAZ+O,GACOxP,EAAYnE,KAAnB,IAEFkU,QAAS,YACPtP,EAAckP,EAAdlP,GACA,IAAIyC,EAAKH,EAAMlH,KAAf,GAIA,OAHA+T,KACAJ,EAAatM,EAAIzC,EAAaA,EAA9B+O,YACAE,KACO1P,EAAYnE,KAAnB,IAEFmU,kBAAmB,YACjBvP,EAAckP,EAAdlP,GAIA,IAHA,IAAIyC,EAAKH,EAAMlH,KAAf,GAEIkT,EAAWtO,EAAf,WACA,GAAiB,CACf,IAAImK,EAAcmE,EADH,YAEfa,KACAb,IAKF,OAFAtO,eACA+O,EAAatM,EAAI,KAAjBsM,GACOxP,EAAYnE,KAAnB,IAEF2T,aAAc,YACZ/O,EAAckP,EAAdlP,GACA,IAAIyC,EAAKH,EAAMlH,KAAf,GAEA,OADA2T,EAAatM,EAAIzC,EAAaA,EAA9B+O,YACOxP,EAAYnE,KAAnB,IAEF4T,YAAa,YACXhP,EAAckP,EAAdlP,GACA,IAAIyC,EAAKH,EAAMlH,KAAf,GAEA,OADA4T,EAAYvM,EAAIzC,EAAaA,EAA7BgP,YACOzP,EAAYnE,KAAnB,Q,2ECzEN,IAAIoU,EASJ,SAASC,EAAQC,GACfC,YAAW,WACT,WAVJvT,UAC4B,mBAAnBsQ,eAAP,eAEuB,mBAAZkD,UAA2BJ,EAAUI,QAA5C,WACA,YACEJ,oBALRpT,Y,+ECCG,IACKsR,EACAhE,EACAmG,EALRzT,EAAA,QACE2K,mBAEM2G,EAAJ,GACIhE,EAAJ,OACImG,EAAM,GAAKC,KAAf,SACApG,8BAAgC,YAC9B,GAAIqG,SAAJ,EAAqB,CACnB,IAAIC,EAAJ,EACAtC,KACA,IAAK,IAAIhS,EAAT,EAAgBA,EAAIsU,EAApB,OAAsCtU,IACpCsU,WAIC,YACL,IAAItC,WACFhE,wB,kFCjBR,IAAIuG,EAAQvR,EAAZ,uDACI+B,EAAU/B,EAAd,6CAEA,SAASwR,EAAW9Q,EAAWsC,EAAKiJ,EAAgBwF,GAClD/U,KAAA,YACAA,KAAA,MACAA,KAAA,KACAA,KAAA,KAGF8U,YAAuB,CACrB,IADFA,GAIAzP,EAAQyP,EAARzP,GAEArE,a,yFChBA,IAAI6T,EAAQvR,EAAZ,uDACI+B,EAAU/B,EAAd,6CACIoH,EAASpH,EAAb,4CAEA,SAAS0R,EAAuBC,GAC9BvK,EAAO1K,KAAP0K,GACA1K,KAAA,SACAA,KAAA,SAGF,SAASkV,EAAkB1R,GACzBxD,KAAA,UACAA,KAAA,KAGFkV,YAA8B,CAC5B,IAD4B,GAG5B,KAH4B,EAK5B,IAAc,WACZ,OAAO,IAAIF,EAAX,OAGF,IAAc,YACZ,OAAOtL,EAAP,2BAIJrE,EAAQ6P,EAAR7P,GAEA2P,YAAmCE,EAAnCF,UAEAhU,a,gFC/BA,IAAIyE,EAAUnC,EAAd,gEACI4B,EAAiB5B,EAArB,oEACI6R,EAAoB1P,EAAxB,IACIoP,EAAQvR,EAAZ,uDACI+B,EAAU/B,EAAd,6CACI8R,EAAJ,aACIC,EAAJ,cACIxP,EAAiBpB,iBAArB,eACI6Q,EAAJ,+BACIC,EAAJ,+BAGIC,EAAa,CACfC,IAFF,6BAGEC,KAJF,sCAWIC,EAAiBlR,OAArB,eAEImR,EAAJ,OACIhL,EAAenG,cAAnB,IAEA,SAASoR,EAAiBrW,EAAM0I,GAC9B,WAAIA,EACF,GACK,UAAI1I,GACL0I,aAAJ,OACSA,EAAP,OAIGA,EAAP,GAGF,SAAS4N,EAAOC,EAAGC,GACjB,IAAK,IAAL,OACMnQ,SAAJ,KACEkQ,KAASC,EAATD,IAKN,SAASE,EAAa5O,EAAI6O,EAAclO,EAAME,GAC5C,OAAIgO,EACF7O,oBAEAA,wBAIJ,SAAS8O,EAAgB9O,EAAI6O,EAAclO,GACzC,OAAIkO,EACF7O,qBAEAA,yBAIJ,SAAS+O,EAAcnB,GACrBjV,KAAA,IAA6BiV,EAA7B,IACAjV,KAAA,SACAA,KAAA,SAEAA,KAAA,IAAciV,EAAd,IACAjV,KAAA,IAAqBiV,EAArB,IACAjV,KAAA,IAAqBiV,EAArB,IACAjV,KAAA,IAAmBiV,EAAnB,IACAjV,KAAA,IAAgBiV,EAAhB,IACAjV,KAAA,IAAwBiV,EAAxB,IACAjV,KAAA,IAAkBiV,EAAlB,IAGF,SAASoB,EAAS,EAAlB,aAWE,MAFArW,KAAA,SAIA,IACEsW,EAAUC,EAAVD,GAGFtW,KAAA,MACAA,KAAA,IAAgByL,GAAhB,EACAzL,KAAA,IAAqBwW,GAArB,EACAxW,KAAA,IAAqBuW,GAArB,EACAvW,KAAA,MACAA,KAAA,SACAA,KAAA,MACAA,KAAA,MACAA,KAAA,MAGFqW,YAAqB,CACnB,IADmB,EAGnB,IAAc,WACZ,OAAO,IAAID,EAAX,OAUFK,EAAG,wBACD,IAAIC,EAAQ1W,KAAK,IACf,IAAIqW,EAAS,EAAb,UADF,IAYA,WAAIM,EACK3W,KAAP,MAEA,GAUJ4W,EAAG,cAID,OAHAjP,EAAOA,EAAPA,OACAA,MACA3H,KAAA,OACOA,KAAP,OAGF,IAAc,cACZ,IAAI6W,EAAU7W,KAAd,IACI8W,EAAa9W,KAAjB,IACIkW,EAAeV,SAAnB,EAEI/J,EAAQzL,KAAZ,IACIqH,EAAKqC,oBAAT,GAEA,GA7IJ,EA6IQ+B,EACFqK,EAAOzO,EAAPyO,OACK,CACL,IAAK,IAAL,OAAiC,CAC/B,IAAIiB,EAAYD,EAAhB,GAEA,IAAIC,OAAJ,MAA2BA,EAAmB,CAC5C,IAAIvX,SAAJ,EAEA,WAAIA,IAGFuX,EAAYlB,EAAiBrW,EAA7BuX,IAGEC,GAAJ,EACEf,EAAa5O,EAAIiO,EAAUM,EAA3BK,GAEA5O,qBAKN,aAAIwP,IACFxP,eAAkBA,QAAWrH,KAA7BqH,IAMJ,OAFA8N,cAEA,GAGF,IAAiB,YAIf,IAAIjN,EAAQlI,KAAK,IAAjB,GACA,OAAOkI,UAAP,IAAwBA,IAI5B7C,EAAQgR,EAARhR,GAEA,IAAI5B,EAAS2S,YAA0BC,EAAvC,UAEA,CAAC,UAAW,WAAY,YAAYY,SAAQ,YAC1CtB,EAAelS,EAAOuE,EAAM,CAC1BtD,IAAK,WACH,IAAIwD,EAAQlI,KAAK,IAAjB,GACA,OAAOkI,OAAP,MAA0BA,QAKhCyN,EAAelS,EAAO,KAAY,CAChCiB,IAAK,WACH,IAAIwD,EAAQlI,KAAZ,IAIA,OAHA,MAAIkI,IACFA,EAAQlI,KAAK,IAAbkI,OAEKA,cAAiBA,EACpBA,EADGA,GAEH,aAAAlI,KAAK,IAAL,gBACAA,KAAK,IAAL,KADA,KAFJ,MASJqW,MAAwC,YAKtC,UAoDFA,MAjDA,SAA2B1O,EAAMuP,EAAsB3H,GACrD,IAAIuH,EAAanP,EAAjB,WACIwP,EAAYL,EAAhB,OAEIN,EAAJ,KACID,EAAJ,KAEA,KAAe,CACbC,KACA,IAAK,IAAIlW,EAAT,EAAgBA,EAAhB,EAA+BA,IAAK,CAClC,IAAI8W,EAAON,EAAX,GACIE,EAAWI,EAAf,KACK/B,OAAL,KACE,eAAI2B,EACFT,EAAQrR,MAARqR,GACSa,iBAAJ,EACLZ,gBAAyBY,EAAzBZ,MAEAA,KAAkBY,EAAlBZ,QAMR,IAAIK,EAAUlP,EAAd,SAEIA,iBAAJ,IACEkP,EAAUA,EAAVA,eAGF,IAAIQ,EAAS,IAAIhB,EAAS,EAAb,aAAb,GAgBA,MANA,aAAIgB,MACFA,MAA0B1P,EAA1B0P,MACSH,GACTA,EAAqBvP,EAAM0P,EAA3BH,GAGF,GAKFb,MAAyB,gBACvB,IAAIiB,EAA4BjB,EAAhC,IAEIkB,EAAYC,EAAhB,IACIC,EAAUC,EAAd,IAEAvC,WAEA,IAOA,EAPIqB,EAAQkB,EAAZ,IACInB,EAAQmB,EAAZ,IAEA,GAzRF,EAyRMD,EACF,OAAO3B,EAAO6B,EAAd,GAaF,IAcA,EAqBA,EAnCIC,EAAWJ,EAAf,IAEA,KAAc,CACZ,GAAII,IAAJ,EAKE,OAEAA,EAAWN,EAA0BM,EAArCA,GAMJ,GAxTF,EAwTMH,GAxTN,EAwTqCF,EAUjC,OATIK,EAAQ,SAAeb,EAAYP,EAAK,SAC1CmB,eAEEC,QAAiBb,EAAYP,EAAjC,MACEmB,aAEEC,WAAoBb,EAAYP,EAApC,SACEmB,oBAgBJ,SAPAnB,EAAQc,EAA0Bd,EAAOD,GAAzCC,GAgBE,GARAO,EAAYP,EAAZO,GACAb,OAEIc,IAAJ,IACEd,IACAc,KAGED,UAAJ,IAAyBA,EACvBZ,EAAgBwB,EAAQzB,EAAxBC,QACK,GAAIyB,OAAJ,EAAsC,CAC3C,IAAIpY,SAAJ,EAEA,WAAIA,IACFuX,EAAYlB,EAAiBrW,EAA7BuX,IAGFd,EAAa0B,EAAQzB,EAAcc,EAAnCf,GAcJ,GAAIyB,cA9WN,EA8W8BH,EAC1B,WACQP,KAAN,IACMA,IAAJ,EACEW,yBAEAA,uBAOV3W,a,iFChZA,IAAIyE,EAAUnC,EAAd,gEACIoP,EAAgBjN,EAApB,IACI0P,EAAoB1P,EAAxB,IACIoP,EAAQvR,EAAZ,uDACI+B,EAAU/B,EAAd,6CACIkL,EAAqBlL,yEAEzB,SAASuU,EAAUvR,EAAKiJ,EAAgBwF,GACtC/U,KAAA,YACAA,KAAA,MACAA,KAAA,KAGF6X,YAAsB,CACpB,IADoB,GAEpB,IAAc,WACZ,IAAI1N,EAAWqE,IAGf,OAFAkE,QAA4B1S,KAA5B0S,KACAyC,cACA,IAIJ9P,EAAQwS,EAARxS,GAEArE,a,uECxBA,SAAS6T,KAETA,YAAkB,CAChB,IAAU,cACR7U,KAAA,MACAA,KAAA,MACAA,KAAA,SACAA,KAAA,SACAA,KAAA,SACAA,KAAA,SACAA,KAAA,OAGF,UACE,IAAI8X,EAAa9X,KAAjB,IAEA,OAAI8X,GAAcA,EAAlB,IACyBA,EAAvB,KAK2BA,EAA3B,IAGF,GAGF,UACE,IAAI/I,EAAc/O,KAAlB,IAEA,MACE,GAAI+O,EAAJ,IAEE,OADiBA,EAAjB,KACqBA,EAArB,QAEG,CACL,IAAIgJ,EAAa/X,KAAjB,IACA,GAAI+X,GAAcA,EAAlB,IACE,OAAOA,EAAP,IAIJ,UAGF,IAAgB,YAGd,GAFA/X,KAAA,MAEA,aAAIA,KAAK,IACP,GAAI0W,EAAJ,IAAmB,CACjB,IAAIsB,EAAatB,EAAjB,IACA1W,KAAA,KAAyBA,KAAK,KAAN,IAAxB,MACK,KAAI0W,OAAqBA,EAAzB,GAGL,MAAM3X,YAFNiB,KAAA,WAIG,CACL,IAAIiY,EAAYjY,KAAhB,IAEA0W,WAEA,EACEuB,QAEAjY,KAAA,MAGFA,KAAA,MAGF,UAGF,IAAgB,WACd,OAAIA,KAAK,MAAkBA,KAAvB,KAAkDA,KAAtD,IACSA,KAAK,IAAZ,MAEA,OAqBNgB,a,6ECrGA,IAAI6T,EAAQvR,EAAZ,uDACI+B,EAAU/B,EAAd,6CAEA,SAAS4U,EAAMhQ,EAAOqH,GACpBvP,KAAA,UACAA,KAAA,MAGFkY,YAAkB,CAChB,KADgB,EAGhB,IAHgB,EAKhB,IAAc,YACZ,OAAOxO,iBAAmB1J,KAA1B,MAGF,IAAc,WACZ,OAAO,IAAIkY,EAAMlY,KAAjB,OAIJqF,EAAQ6S,EAAR7S,GAEArE,a,yFCxBA,IACI2S,EADUrQ,EAAd,kEACA,IAEI6U,EAAoB,CACtBC,SADsB,GAEtB,iBACE,IAAIN,EAAa9X,KAAKmP,UAAtB,YACA,OAAO2I,IAAe9X,KAAf8X,eAAP,GAEF,gBACE,IAAIG,EAAYjY,KAAKkP,QAArB,gBACA,OAAO+I,IAAcjY,KAAdiY,iBAAP,GAEF,iBACE,IAAIF,EAAa/X,KAAKmP,UAAtB,WACA,OAAO4I,IAAe/X,KAAf+X,yBAAP,GAEF,mBACE,OAAO/X,KAAKmP,UAAU4I,WAAtB,cAEF,kBACE,OAAO/X,KAAKkP,QAAZ,aAEF,YASE,IAFA,IAAIxH,EAAJ,GACI2Q,EAAUrY,KAAd,UACOqY,IAAYrY,KAAnB,SACE0H,UACA2Q,EAAUA,EAAVA,YAGF,OADA3Q,UACA,GAEFiM,aAAc,cACZ,IAAI2E,EAAkBC,QAAwBvY,KAAxBuY,QAAtB,EACA,OAAO5E,EAAa,EAAD,EAGjB3T,KAAKmP,UAHP,aAMFqJ,WAAY,cAIV,OAHAxY,KAAA,eAAmB,YACjB2T,EAAahM,EAAM4Q,EAAnB5E,KADF3T,MAGA,MAEFyY,OAAQ,WACNzY,KAAA,eAAmB,YACjBA,KAAA,mCADFA,QAMJ,SAASwO,EAAmBW,EAAWuJ,EAAUX,GAC/C,IAAI5N,EAAW1F,cAAf,GACIkU,EAASxJ,GAAaA,kBAA4BA,EAAtD,WACAhF,YAAqBwO,EACjBnU,uBADuB,IAEvBA,wBAFJ2F,IAGAA,UAAmBwO,EACfnU,uBADqB,IAErBA,wBAFJ2F,IAGAA,uBACAA,qBACA,IAAIyO,EAAqBzO,oBAA6B3F,SAAtD,yBAKA,OAJAuT,EACEA,GAAe5I,GAAaA,EAA5B4I,YADFA,EAEApE,EAAaxJ,EAAD,YAAZwJ,GACAA,EAAaxJ,EAAD,UAAZwJ,GACA,EAgBF1S,EAAQ,IAARA,EACAA,EAAQ,IAdR,SAA2BkO,EAAW4I,GACpC,IAAI5N,EAAWqE,EAAmBW,EAAW,KAA7C,GASA,OARAhF,MAA6B,YAC3BA,WACAwJ,EACExJ,EADU,UAGV4N,GAAc5I,EAHhBwE,aAMF,I,sFCzFF,SAASA,EAAahM,EAAM4Q,EAAeR,GACzC,OAAIpQ,EAAJ,WACSA,eAAP,GAEKoQ,EAAA,eAEJQ,GAAiBA,EAAlB,WAFF,GAiCFtX,EAAQ,IAARA,EACAA,EAAQ,IA5BR,SAAqB0G,EAAM4Q,EAAeR,GACxC,OAAOpE,EAAa,EAElB4E,GAAiBA,EAFA,YAAnB,IA4BFtX,EAAQ,IArBR,SAAqB0G,GACnB,IAAIkR,EAAOlR,EAAX,YACIwC,EAAW0O,GAAQA,EAAvB,SACA,SACSA,IAAS1O,EAAT0O,YAAP,KAEF,GAgBF5X,EAAQ,IAbR,SAAoB0G,GAClB,IAAIkR,EAAOlR,EAAX,WACA,OAAQkR,GAAQA,EAAT,UAAP,GAYF5X,EAAQ,IATR,SAAqB0G,GACfA,EAAJ,OAAiBA,EAAjB,SACKA,8B,sFCjCP,IAAImR,EAAoBxV,EAAxB,4EACIqH,EAAcrH,EAAlB,mEACI4B,EAAiB5B,EAArB,oEACIyV,EAA0B7T,EAA9B,GACIE,EAAuBF,EAA3B,GACIuJ,EACFvJ,EADF,IAEI8T,EAAwB9T,EAA5B,IACImR,EAAW/S,4DACX2V,EAAoB5C,EAAxB,IACI6C,EAAa7C,EAAjB,IACI7Q,EAAkBlC,EAAtB,wEACI6G,EAAW7G,EAAf,mEACIoQ,EAAUpQ,EAAd,kEACImC,EAAUnC,EAAd,gEACIoP,EAAgBjN,EAApB,IACI0T,EAAqB1T,EAAzB,GACI0P,EAAoB1P,EAAxB,IACI2T,EAAoB3T,EAAxB,IAEIkO,EAAeD,EAAnB,IACIE,EAAcF,EAAlB,IACI3E,EAAc2E,EAAlB,IACIoE,EAAapE,EAAjB,IACIG,EAAcH,EAAlB,IACIlF,EAAqBrE,EAAzB,IACIkP,EAAoBlP,EAAxB,IAaA,SAASmP,EAAUhT,GACjB,YAAOA,KAGT,SAASiT,EAAiB5B,EAAQD,GAChC,OAAOC,QAAuBD,EAA9B,IAGF,SAAS8B,EAAuBzD,EAAGC,GACjC,OAAOD,kBAAoBC,EAA3B,cA8oBFhV,UAroBA,SAAkByY,EAAUC,EAAQhQ,EAAKtF,GACvC,MACIuV,GAAJ,EACIC,EAAenV,cAAnB,MAOA,wBAQE,IAAIoV,EAAWC,QAAwBC,EAAvC,cACApG,EAAakG,EAAUjV,EAAvB+O,GAhDJ,IAmDMmG,OA/CN,KAgDMA,QAEA,IACEpH,YACC4G,OAAD,YAKF,aAAIQ,OACFE,EAAcH,EAAUC,EAAxBE,GAvCR,SAAqBrS,EAAMvD,GAvB3B,IAwBMuD,YACFnC,WAwCEyU,CAAYJ,EAAZI,IAIJ,0BASE,IAAI3S,EAAYtD,KAAwB2P,EACtCnF,IADkD,EAApD,GAKA2K,WAEI7S,GAAJ,IACEA,EAAM0S,EAAsB1S,EAAK4T,EAAjC5T,IACAmI,EACEc,EAD6B,OAI7BvL,EAJFyK,IAMAiE,YAGFyH,EAAenW,EAAfmW,GAGF,gBACEH,EAAchW,EAAD,KAAbgW,GAlEF,IACEnQ,EAA0BzF,EAA1ByF,GACA8P,EAAY9P,EAAZ8P,IAmEF,IAAIS,EAAJ,GAEA,kBAzGF,IA0GQzS,YAtGR,KAsG0CA,YACpCyS,UACAhB,QAA4B7J,IAA5B6J,KAEAhU,KACAyO,MAIJ,cACE7P,YAGF,kBACE,IAGA,EACA,EACA,EAEA,EACA,EACA,EACA,EACA,EACA,EAZIqW,EAAmBvC,EAAvB,GACIwC,EAAiBZ,EAArB,IAaAa,EAAO,KAAOD,GAAgB,CAC5BE,EAAgBF,EAAhBE,IACAC,EAAgBH,EAAhBG,IACAC,EAAeJ,EAAfI,IAGIL,GAvIV,KAuI8BA,aACtBA,EAAmBtL,EAAnBsL,IAGF,IACA,EADI9K,EAAiB+K,OAArB,EAGA,GAhJN,IAgJUG,EA2EG,GAAIC,EAAJ,CACLC,SACAC,SACA,IAAIC,EAAJ,EAwBA,GAtBIvB,EAAJ,IACM/J,IAAJ,IACEmL,GAAgB,IAAMnL,EAAtBmL,IAEFI,KAEAA,IAKFJ,GACEd,EAAakB,EAAblB,MACCA,EAAakB,EAAblB,IAAsC,IAF1B,QAAfc,GAKA,IACEE,EAAiBlI,MAAjBkI,GACAD,EAAoBxF,MAApBwF,GACAI,EAAkBhM,EAAlBgM,IAGEH,IAAJ,EAEON,EAAL,KAGMf,EAAiBe,EAArB,GACEU,EAAQ,EAAD,IAAPA,IAQAC,EAAWZ,EAAkBZ,EAA7BwB,GAGAC,EAAwB,EAAD,QAAvBA,UAYJ,QACEC,KAFFA,EAAiBL,KAAjBK,KAGEA,IAFF,EAGE,CACA,IAAIxB,OAAJ,EAA4C,CAC1C,GA3Rd,IA4RgBU,aACCC,MACCd,EACEa,EADoB,SAEpBC,OALN,KAOE,EACAK,EAAoB1B,EAApB0B,IACAA,IAAgCL,EAAhCK,IACAjI,WACAoI,UAIIR,EAAJ,GACEnF,WAEA6F,EAAQ,EAAD,IAAPA,GAQFV,IACAD,IACA,SACK,GApTrB,KAqTgBC,OAvThB,IAwTgBD,YAEcA,EAAd,WACe,KAAf,EAA4C,CAM1C,IALA,IAEA,EAFInL,EAAUmL,EAAd,YACIe,EAAJ,IAIa,CACX,GAlUpB,IAkUwBlM,WAEF,WADAmM,EAAYnM,EAAZmM,WACwB,CACtB,OAAID,EACF,MAEAA,SAEG,IAAIC,iBACTD,IAGJlM,EAAUA,EAAVA,YAGF,IAAI/E,EAAWqE,EAAmB,EAEhCU,EAF+B,YAAjC,GAKAwD,WACAyC,WACA2F,UACAjH,KACAA,KAEKyG,EAAL,IACEN,EAAc7P,EAAUmQ,EAAxBN,GAGFM,IACAD,EAAmBlQ,EAAnBkQ,YACA,UAKNa,EAAwB,EAAD,QAAvBA,GAQAH,cAEA,IAAI3B,UACFA,gBAGGkB,EAAL,IA0EE3G,EAAawH,EAAgBd,EAA7B1G,GACAoH,KAxEIxB,EAFJoB,EAAoBxF,MAApBwF,GAEA,IACMI,IAAJ,EAaIP,GACAA,QAFF,GAOEO,IAGApH,EAAawH,EAAgBd,EAA7B1G,KAQAoH,EAAkBhM,EAAlBgM,GAEA,GACEE,EAAWZ,EAAkBZ,EAA7BwB,KAUJrH,EAAYuH,EAAgBd,EAA5BzG,GAEA,GACEqH,EAAWZ,EAAkBZ,EAA7BwB,IAIJD,EAAQ,EAAD,IAAPA,KAOAE,EAAwB,EAAD,QAAvBA,GAQAD,EAAWE,EAAgB1B,EAA3BwB,IAWRX,IACAD,QA1OK,CAiPP,QAGE,GAFAU,EAAkBhM,EAAlBgM,GAEKO,EAAgBnC,MAArB,GAOEkB,IAGGxQ,MAAkDyR,EADrD,KAGEC,SAZJ,CAkBA,IAAIC,EAAkBnB,EAAtB,SAEIoB,OAAJ,EAEA,GAAID,IAAJ,EACE,GAzeV,IAyecA,EAAkC,CAGpC,aADAb,EAAoBxF,MAApBwF,IACqC,CACnC,QAAIhB,EAWG,CAELU,IACA,SAVEb,GAHFmB,EAAoB1B,EAApB0B,IAGwB,IAEpBL,EAHJ,OAMEK,MAAgCL,EAAhCK,UAOMC,EAAiBD,EAAtB,OAGLc,OAOF,IAJAA,GACEA,QADFA,IAEElC,EAAiBoB,EAAjBpB,KAMAyB,EAAQ,EAAD,IAAPA,QA1gBd,IAkhBYQ,GAjhBZ,IAkhBYA,IAGAC,KAGIpB,cAA+BC,EAAnC,MACED,YAA6BC,EAA7BD,MAKN,QAAIoB,EAAuB,CAEzBnB,IACAD,IACA,WAGFY,EAAWZ,EAAkBZ,EAA7BwB,GACAZ,IAOFa,EAAwB,EAAD,QAAvBA,GASAZ,IACAD,QAtaA,CACE,IAAIrW,EAAYsW,EAAhB,GACA,aACGoB,EAAwB3C,EAAwB/U,EAAjD,KAGA,QAAI2V,EAAoB,CACtB,IAAIrS,EAAW+R,EAAkBgB,EAAjC,GACArW,OACAmV,WAEI5J,GAAJ,IACEmL,EAAe1B,EAAsB,EAEnCkB,EAFFQ,IAIAjM,EACEc,EAD6B,OAI7BvL,EAJFyK,IAOAiE,YAGFyH,EAAenW,EAAfmW,GAEAE,EAAmBtL,EAAnBsL,QAEAsB,EAA6B,EAAD,UAA5BA,OAUG,CACL,GAAID,OAAJ,EAA4D,CAC1D,GACErB,IACCiB,EAAgBnC,MADjBkB,UADF,IAGExQ,MACEyR,EADFzR,IAGA,CAGAwQ,EAAmBtL,EAAYuM,EAA/BjB,IACAkB,KACA,SAKF5H,EACE+H,EADU,KAAZ/H,QAMA0G,EACEA,GAAoBtL,EADtBsL,GAIGC,EAAL,IACEH,EAAenW,EAAfmW,GAIJG,KAiWJ,GAAIb,EAAJ,IAGEA,cAOA,IAHA,IAAImC,GAhkBV,KAikBQnC,WAAsCA,EAAtCA,QADF,KAGOY,GAAoBA,IAA3B,IACEU,EAAkBhM,EAAlBgM,IAEKO,EAAgBnC,MAArB,KACEkB,IAEGxQ,MAAkDyR,EADrD,KAGEC,OAKJZ,EAAoBxF,MAApBwF,GAYAM,EAAWZ,EAAkBZ,EAN3BqB,IALFF,EAAiBlI,MAAjBkI,KAIuBtB,EAAvB,GACEwB,EAGEH,GAAqBA,EADvBG,KAMFT,KAKN,oBACE,IAAIwB,EAAWnE,EAAf,IAEIpB,EAAUoB,EAAd,IACA,SAAIpB,OAAyBkB,QAA7B,KAIA0B,EAAWvB,EAAQH,EAAnB0B,IAEIxB,EAAJ,KAIA,aAAImE,GACF7B,EAAcrC,EAAQD,EAAtBsC,GAGF,IAAI8B,EAAmBhD,EAAvB,QACA,IAAIgD,GACFA,EAAiBnE,EAAjBmE,IASJ9B,EAAcP,EAAUC,EAAQA,EAAhCM,IAEAI,WAAsB,YACpB,IAAI2B,EAAwB3C,MAA5B,GAEA,YAAI2C,EAAqC,CACvC3C,gBAEA,IAAIrG,EAAqBoG,MAAzB,GACA,EACEpG,YACSpL,EAAJ,aACLvC,EAAqB,GAEnB2W,OAFF3W,GAKA,GAAII,UACFqO,Y,4FCnrBV,SAASmI,EAAoBrE,EAAQD,EAAM1P,GACrC2P,OAAiBD,EAArB,KACEC,KAAeD,EAAfC,GACIA,EAAJ,GACEA,qBAEAA,yBAKN,SAASsE,EAAc5U,EAAIuJ,EAAItQ,GAG7B,IAFA,IAAI4S,EAAW7L,EAAf,IAEA,GACE,WAAI6L,MACFtC,EAAGsC,IAAHtC,GAEAtQ,EAAI2b,EAAc/I,EAAUtC,EAA5BtQ,GAGF4S,EAAWA,EAAXA,IAGF,SAIF,SAASgJ,KACTA,YAA8B,CAK5BC,OAAQ,cACNH,EAAoBrE,EAAQD,EAA5BsE,aAEFI,OAAQ,cACNJ,EAAoBrE,EAAQD,EAA5BsE,aAQFlT,MAAO,cACLkT,EAAoBrE,EAAQD,EAA5BsE,WACAA,EAAoBrE,EAAQD,EAA5BsE,YAEIrE,SAAgBD,EAApB,KACEC,QAAeD,EAAfC,IAGEA,0BAAiCD,MAArC,UACEC,4BAIJ0E,SAAU,cACR,IAAI3E,EAAJ,KAIA,IAAIpO,EAAWoO,EAAf,GACIC,SAAJ,IACEA,WAGF,IAAIG,EAAaH,EAAjB,WACA,KAAgB,CAGd,IAAIpO,EAAWuO,EAAf,UAEA,GACEvO,OACED,GAAYC,GAAYoO,EAF5B,YAIE,OAGFG,iBAGJwE,OAAQ,cACN,IAAK5E,MAAL,YAAuC,CACrC,IAAI6E,EAAJ,EACAN,EAAc,GAEZ,cACME,MAAJ,cACEI,QAJNN,GAUItE,kBAAJ,IACEA,sBAMR3W,UAAiB,IAAjBA,G,4ECzGA,IAAIwb,EAAY,YACd,IAAIC,EAAYjY,uBAAhB,YAWA,OAVAgY,EAAYC,EAAA,QACR,YAEE,OADAA,cACOA,EAAP,SAEF,YAEE,OADAA,cACA,IAGN,IAGFzb,UAAiB,YACf,OAAOwb,KAAP,a,4EChBF,IAAI3H,EAAQvR,EAAZ,uDACI4R,EAAoB5R,EAAxB,mEACI+S,EAAW/S,EAAf,0DACI4U,EAAQ5U,EAAZ,uDACIwR,EAAaxR,EAAjB,4DACIuU,EAAYvU,EAAhB,2DACIkZ,EAAYlZ,EAAhB,4DAEIiL,EAAqC,oBAAZ/J,UAA7B,SACIkY,EAAJ,OAEA,SAASxF,EAAqBvP,EAAMgV,EAAYpN,GAE9C,IADA,IAAI2D,EAAWvL,EAAf,WACA,GACEgV,MAA0BC,EAAW1J,EAArCyJ,IACAzJ,EAAWA,EAAXA,YAIJ,SAAS0J,EAAWjV,EAAM4H,GACxB,OAAQ5H,EAAR,UACE,OACE,OAAO0O,UAAP,GACF,OACE,OAAO,IAAI6B,EAAMvQ,EAAV,UAAP,GACF,QACE,IAAIkV,EAAkB,IAAtB,EAEA,OADA3F,EAAqBvP,EAAMkV,EAA3B3F,GAPJ,GAYF,SAAS4F,EAAeC,EAAMrT,EAAK6F,GACjC,IAAKmN,OAAL,GACE,OAAO,IAAIxE,EAAM6E,EAAjB,GAMF,IAHA,IAAIC,EAAe,IAAnB,EACI9J,EAAWsJ,EAAf,GAEA,GACEQ,MAA4BJ,EAAW1J,EAAvC8J,IACA9J,EAAWA,EAAXA,YAGF,SAGF,IAAI+J,EAAiBpI,EAArB,UAMAoI,IAAmB,YACjB,IACA,EADIzd,SAAJ,EAcA,MAXA,WAAIA,IACF,MAAI0I,EACFA,KACK,WAAI1I,GACL0I,EAAJ,SACEgV,EAAWJ,EAAe5U,EAAD,SAAzBgV,YAKNld,KAAA,IAAoBkd,GAAY,IAAIhF,EAAMhQ,EAA1C,aACOlI,KAAP,OAGFid,MAA2C,WACzC,OAAOjd,KAAK,IAAe,IAA3B,IAGFiB,EAAQ,IAARA,EACAA,EAAQ,IAARA,EACAA,EAAQ,IAARA,EACAA,EAAQ,IAARA,EACAA,EAAQ,IAARA,EACAA,EAAQ,IAARA,EACAA,EAAQ,IAARA,EACAA,EAAQ,IAARA,G,kDCnFAD,EAAOC,QAAU,SAAmBkc,EAAMC,GACtC3Y,OAAO4Y,oBAAoBF,GAAMlG,SAAQ,SAASjP,GAC9C,IAAIsV,EAAa7Y,OAAO8Y,yBAAyBJ,EAAMnV,GACvDvD,OAAOkR,eAAeyH,EAAIpV,EAAMsV,Q,+CCHxCtc,EAAOC,QAAU,SAAgBG,EAAQoc,GAKrC,GAJKpc,IACDA,EAAS,IAGToc,EACA,IAAK,IAAIrU,KAAYqU,EACbA,EAAO3X,eAAesD,KACtB/H,EAAO+H,GAAYqU,EAAOrU,IAKtC,OAAO/H,I,sDCbX,IAAIqc,EAAYna,EAAQ,+CAExB,SAAS+B,EAAQqY,EAAMC,EAAWC,GAC9B,IAAIC,EAAWH,EAAKhf,UAChBof,EAAWJ,EAAKhf,UAAY+F,OAAOsZ,OAAOJ,EAAUjf,UAAW,CAC/Dsf,YAAa,CACT9V,MAAOwV,EACPO,UAAU,EACVC,cAAc,KAQtB,OALIL,IAAgC,IAApBD,GACZH,EAAUI,EAAUC,GAExBJ,EAAKS,OAASR,EACdD,EAAKhf,UAAYof,EACVJ,EAIX1c,EAAOC,QAAUoE,EACjBA,EAAQ+Y,SAAW/Y,G,mDCrBnBrE,EAAOC,QAAU,EAAjBD,+C,kDCAAA,EAAOC,QAAU,EAAjBD,8C,qDCAA,IAAIsN,EAAsCJ,OAC1CjN,EAAQod,KAAO/P,EAAIgQ,SAAWhQ,EAAIgQ,UAAY,c,sDCD9C,IAAIC,EAAYjb,EAAQ,8CACpBkb,EAAU/f,MAAM+f,QAEpB,SAASC,EAAQC,EAAQC,EAAMpe,GAE3B,IADA,IAAI8X,EAAUqG,EACLpe,EAAE,EAAGA,EAAEC,EAAKD,IACjB+X,EAAUA,EAAQsG,EAAKre,IAG3B,OAAO+X,EAGX,SAASuG,EAAYC,GACjB,GAAkB,SAAdA,EAAKrf,KACL,OAAO,IAAIsf,KAAKD,EAAK3W,OAClB,GAAkB,SAAd2W,EAAKrf,KACZ,OAAO+e,EAAUF,KAEjB,MAAM,IAAIje,MAAM,YAIxBY,EAAOC,QAAU,SAAkBsZ,GAC/B,IAAKA,EACD,OAAOA,EAGX,IAAIwE,EAAcxE,EAAMyE,GACxB,GAAID,EAAa,CACb,IACIxe,EADAme,EAASnE,EAAMnP,EAGnB,GAAI2T,IAAgBxe,EAAIwe,EAAY5f,QAChC,IAAK,IAAImB,EAAE,EAAGA,EAAEC,EAAKD,IAAK,CACtB,IAGI2e,EAHAC,EAAaH,EAAYze,GAEzB6e,EAAMD,EAAWjO,EAIjBgO,EADAT,EAAQW,GACGV,EAAQC,EAAQS,EAAKA,EAAIhgB,QAEzByf,EAAYO,GAG3B,IAAIC,EAAMF,EAAWG,EACjBC,EAAUF,EAAIjgB,OAAO,EAEzB,IAAiB,IAAbmgB,EAAgB,CAChBZ,EAASnE,EAAMnP,EAAI6T,EACnB,MAEgBR,EAAQC,EAAQU,EAAKE,GAC3BF,EAAIE,IAAYL,EAOtC,OAFAF,EAAY5f,OAAS,EAEJ,MAAVuf,EAAiB,KAAOA,EAE/B,OAAOnE","file":"509.7ed47c9c.js","sourcesContent":["/* jshint newcap:false */\nvar slice = Array.prototype.slice;\n\nfunction isFunction(arg) {\n    return typeof arg === 'function';\n}\n\nfunction checkListener(listener) {\n    if (!isFunction(listener)) {\n        throw TypeError('Invalid listener');\n    }\n}\n\nfunction invokeListener(ee, listener, args) {\n    switch (args.length) {\n        // fast cases\n        case 1:\n            listener.call(ee);\n            break;\n        case 2:\n            listener.call(ee, args[1]);\n            break;\n        case 3:\n            listener.call(ee, args[1], args[2]);\n            break;\n            // slower\n        default:\n            listener.apply(ee, slice.call(args, 1));\n    }\n}\n\nfunction addListener(eventEmitter, type, listener, prepend) {\n    checkListener(listener);\n\n    var events = eventEmitter.$e || (eventEmitter.$e = {});\n\n    var listeners = events[type];\n    if (listeners) {\n        if (isFunction(listeners)) {\n            events[type] = prepend ? [listener, listeners] : [listeners, listener];\n        } else {\n            if (prepend) {\n                listeners.unshift(listener);\n            } else {\n                listeners.push(listener);\n            }\n        }\n\n    } else {\n        events[type] = listener;\n    }\n    return eventEmitter;\n}\n\nfunction EventEmitter() {\n    this.$e = this.$e || {};\n}\n\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype = {\n    $e: null,\n\n    emit: function(type) {\n        var args = arguments;\n\n        var events = this.$e;\n        if (!events) {\n            return;\n        }\n\n        var listeners = events && events[type];\n        if (!listeners) {\n            // If there is no 'error' event listener then throw.\n            if (type === 'error') {\n                var error = args[1];\n                if (!(error instanceof Error)) {\n                    var context = error;\n                    error = new Error('Error: ' + context);\n                    error.context = context;\n                }\n\n                throw error; // Unhandled 'error' event\n            }\n\n            return false;\n        }\n\n        if (isFunction(listeners)) {\n            invokeListener(this, listeners, args);\n        } else {\n            listeners = slice.call(listeners);\n\n            for (var i=0, len=listeners.length; i<len; i++) {\n                var listener = listeners[i];\n                invokeListener(this, listener, args);\n            }\n        }\n\n        return true;\n    },\n\n    on: function(type, listener) {\n        return addListener(this, type, listener, false);\n    },\n\n    prependListener: function(type, listener) {\n        return addListener(this, type, listener, true);\n    },\n\n    once: function(type, listener) {\n        checkListener(listener);\n\n        function g() {\n            this.removeListener(type, g);\n\n            if (listener) {\n                listener.apply(this, arguments);\n                listener = null;\n            }\n        }\n\n        this.on(type, g);\n\n        return this;\n    },\n\n    // emits a 'removeListener' event iff the listener was removed\n    removeListener: function(type, listener) {\n        checkListener(listener);\n\n        var events = this.$e;\n        var listeners;\n\n        if (events && (listeners = events[type])) {\n            if (isFunction(listeners)) {\n                if (listeners === listener) {\n                    delete events[type];\n                }\n            } else {\n                for (var i=listeners.length-1; i>=0; i--) {\n                    if (listeners[i] === listener) {\n                        listeners.splice(i, 1);\n                    }\n                }\n            }\n        }\n\n        return this;\n    },\n\n    removeAllListeners: function(type) {\n        var events = this.$e;\n        if (events) {\n            delete events[type];\n        }\n    },\n\n    listenerCount: function(type) {\n        var events = this.$e;\n        var listeners = events && events[type];\n        return listeners ? (isFunction(listeners) ? 1 : listeners.length) : 0;\n    }\n};\n\nmodule.exports = EventEmitter;","var INDEX_EVENT = 0;\nvar INDEX_USER_LISTENER = 1;\nvar INDEX_WRAPPED_LISTENER = 2;\nvar DESTROY = \"destroy\";\n\nfunction isNonEventEmitter(target) {\n  return !target.once;\n}\n\nfunction EventEmitterWrapper(target) {\n    this.$__target = target;\n    this.$__listeners = [];\n    this.$__subscribeTo = null;\n}\n\nEventEmitterWrapper.prototype = {\n    $__remove: function(test, testWrapped) {\n        var target = this.$__target;\n        var listeners = this.$__listeners;\n\n        this.$__listeners = listeners.filter(function(curListener) {\n            var curEvent = curListener[INDEX_EVENT];\n            var curListenerFunc = curListener[INDEX_USER_LISTENER];\n            var curWrappedListenerFunc = curListener[INDEX_WRAPPED_LISTENER];\n\n            if (testWrapped) {\n                // If the user used `once` to attach an event listener then we had to\n                // wrap their listener function with a new function that does some extra\n                // cleanup to avoid a memory leak. If the `testWrapped` flag is set to true\n                // then we are attempting to remove based on a function that we had to\n                // wrap (not the user listener function)\n                if (curWrappedListenerFunc && test(curEvent, curWrappedListenerFunc)) {\n                    target.removeListener(curEvent, curWrappedListenerFunc);\n\n                    return false;\n                }\n            } else if (test(curEvent, curListenerFunc)) {\n                // If the listener function was wrapped due to it being a `once` listener\n                // then we should remove from the target EventEmitter using wrapped\n                // listener function. Otherwise, we remove the listener using the user-provided\n                // listener function.\n                target.removeListener(curEvent, curWrappedListenerFunc || curListenerFunc);\n\n                return false;\n            }\n\n            return true;\n        });\n\n        // Fixes https://github.com/raptorjs/listener-tracker/issues/2\n        // If all of the listeners stored with a wrapped EventEmitter\n        // have been removed then we should unregister the wrapped\n        // EventEmitter in the parent SubscriptionTracker\n        var subscribeTo = this.$__subscribeTo;\n\n        if (!this.$__listeners.length && subscribeTo) {\n            var self = this;\n            var subscribeToList = subscribeTo.$__subscribeToList;\n            subscribeTo.$__subscribeToList = subscribeToList.filter(function(cur) {\n                return cur !== self;\n            });\n        }\n    },\n\n    on: function(event, listener) {\n        this.$__target.on(event, listener);\n        this.$__listeners.push([event, listener]);\n        return this;\n    },\n\n    once: function(event, listener) {\n        var self = this;\n\n        // Handling a `once` event listener is a little tricky since we need to also\n        // do our own cleanup if the `once` event is emitted. Therefore, we need\n        // to wrap the user's listener function with our own listener function.\n        var wrappedListener = function() {\n            self.$__remove(function(event, listenerFunc) {\n                return wrappedListener === listenerFunc;\n            }, true /* We are removing the wrapped listener */);\n\n            listener.apply(this, arguments);\n        };\n\n        this.$__target.once(event, wrappedListener);\n        this.$__listeners.push([event, listener, wrappedListener]);\n        return this;\n    },\n\n    removeListener: function(event, listener) {\n        if (typeof event === 'function') {\n            listener = event;\n            event = null;\n        }\n\n        if (listener && event) {\n            this.$__remove(function(curEvent, curListener) {\n                return event === curEvent && listener === curListener;\n            });\n        } else if (listener) {\n            this.$__remove(function(curEvent, curListener) {\n                return listener === curListener;\n            });\n        } else if (event) {\n            this.removeAllListeners(event);\n        }\n\n        return this;\n    },\n\n    removeAllListeners: function(event) {\n\n        var listeners = this.$__listeners;\n        var target = this.$__target;\n\n        if (event) {\n            this.$__remove(function(curEvent, curListener) {\n                return event === curEvent;\n            });\n        } else {\n            for (var i = listeners.length - 1; i >= 0; i--) {\n                var cur = listeners[i];\n                target.removeListener(cur[INDEX_EVENT], cur[INDEX_USER_LISTENER]);\n            }\n            this.$__listeners.length = 0;\n        }\n\n        return this;\n    }\n};\n\nfunction EventEmitterAdapter(target) {\n    this.$__target = target;\n}\n\nEventEmitterAdapter.prototype = {\n    on: function(event, listener) {\n        this.$__target.addEventListener(event, listener);\n        return this;\n    },\n\n    once: function(event, listener) {\n        var self = this;\n\n        // need to save this so we can remove it below\n        var onceListener = function() {\n          self.$__target.removeEventListener(event, onceListener);\n          listener();\n        };\n        this.$__target.addEventListener(event, onceListener);\n        return this;\n    },\n\n    removeListener: function(event, listener) {\n        this.$__target.removeEventListener(event, listener);\n        return this;\n    }\n};\n\nfunction SubscriptionTracker() {\n    this.$__subscribeToList = [];\n}\n\nSubscriptionTracker.prototype = {\n\n    subscribeTo: function(target, options) {\n        var addDestroyListener = !options || options.addDestroyListener !== false;\n        var wrapper;\n        var nonEE;\n        var subscribeToList = this.$__subscribeToList;\n\n        for (var i=0, len=subscribeToList.length; i<len; i++) {\n            var cur = subscribeToList[i];\n            if (cur.$__target === target) {\n                wrapper = cur;\n                break;\n            }\n        }\n\n        if (!wrapper) {\n            if (isNonEventEmitter(target)) {\n              nonEE = new EventEmitterAdapter(target);\n            }\n\n            wrapper = new EventEmitterWrapper(nonEE || target);\n            if (addDestroyListener && !nonEE) {\n                wrapper.once(DESTROY, function() {\n                    wrapper.removeAllListeners();\n\n                    for (var i = subscribeToList.length - 1; i >= 0; i--) {\n                        if (subscribeToList[i].$__target === target) {\n                            subscribeToList.splice(i, 1);\n                            break;\n                        }\n                    }\n                });\n            }\n\n            // Store a reference to the parent SubscriptionTracker so that we can do cleanup\n            // if the EventEmitterWrapper instance becomes empty (i.e., no active listeners)\n            wrapper.$__subscribeTo = this;\n            subscribeToList.push(wrapper);\n        }\n\n        return wrapper;\n    },\n\n    removeAllListeners: function(target, event) {\n        var subscribeToList = this.$__subscribeToList;\n        var i;\n\n        if (target) {\n            for (i = subscribeToList.length - 1; i >= 0; i--) {\n                var cur = subscribeToList[i];\n                if (cur.$__target === target) {\n                    cur.removeAllListeners(event);\n\n                    if (!cur.$__listeners.length) {\n                        // Do some cleanup if we removed all\n                        // listeners for the target event emitter\n                        subscribeToList.splice(i, 1);\n                    }\n\n                    break;\n                }\n            }\n        } else {\n            for (i = subscribeToList.length - 1; i >= 0; i--) {\n                subscribeToList[i].removeAllListeners();\n            }\n            subscribeToList.length = 0;\n        }\n    }\n};\n\nexports = module.exports = SubscriptionTracker;\n\nexports.wrap = function(targetEventEmitter) {\n    var nonEE;\n    var wrapper;\n\n    if (isNonEventEmitter(targetEventEmitter)) {\n      nonEE = new EventEmitterAdapter(targetEventEmitter);\n    }\n\n    wrapper = new EventEmitterWrapper(nonEE || targetEventEmitter);\n    if (!nonEE) {\n      // we don't set this for non EE types\n      targetEventEmitter.once(DESTROY, function() {\n          wrapper.$__listeners.length = 0;\n      });\n    }\n\n    return wrapper;\n};\n\nexports.createTracker = function() {\n    return new SubscriptionTracker();\n};\n","var domInsert = require(\"./dom-insert\");\nvar complain = \"MARKO_DEBUG\" && require(\"complain\");\n\nfunction getComponentDefs(result) {\n  var componentDefs = result.___components;\n\n  if (!componentDefs) {\n    throw Error(\"No component\");\n  }\n  return componentDefs;\n}\n\nfunction RenderResult(out) {\n  this.out = this.___out = out;\n  this.___components = undefined;\n}\n\nmodule.exports = RenderResult;\n\nvar proto = (RenderResult.prototype = {\n  getComponent: function() {\n    return this.getComponents()[0];\n  },\n  getComponents: function(selector) {\n    if (this.___components === undefined) {\n      throw Error(\"Not added to DOM\");\n    }\n\n    var componentDefs = getComponentDefs(this);\n\n    var components = [];\n\n    componentDefs.forEach(function(componentDef) {\n      var component = componentDef.___component;\n      if (!selector || selector(component)) {\n        components.push(component);\n      }\n    });\n\n    return components;\n  },\n\n  afterInsert: function(doc) {\n    var out = this.___out;\n    var componentsContext = out.___components;\n    if (componentsContext) {\n      this.___components = componentsContext.___initComponents(doc);\n    } else {\n      this.___components = null;\n    }\n\n    return this;\n  },\n  getNode: function(doc) {\n    return this.___out.___getNode(doc);\n  },\n  getOutput: function() {\n    return this.___out.___getOutput();\n  },\n  toString: function() {\n    return this.___out.toString();\n  },\n  document: typeof document != \"undefined\" && document\n});\n\nObject.defineProperty(proto, \"html\", {\n  get: function() {\n    // eslint-disable-next-line no-constant-condition\n    if (\"MARKO_DEBUG\") {\n      complain(\n        'The \"html\" property is deprecated. Please use \"toString\" instead.'\n      );\n    }\n    return this.toString();\n  }\n});\n\nObject.defineProperty(proto, \"context\", {\n  get: function() {\n    // eslint-disable-next-line no-constant-condition\n    if (\"MARKO_DEBUG\") {\n      complain(\n        'The \"context\" property is deprecated. Please use \"out\" instead.'\n      );\n    }\n    return this.___out;\n  }\n});\n\n// Add all of the following DOM methods to Component.prototype:\n// - appendTo(referenceEl)\n// - replace(referenceEl)\n// - replaceChildrenOf(referenceEl)\n// - insertBefore(referenceEl)\n// - insertAfter(referenceEl)\n// - prependTo(referenceEl)\ndomInsert(\n  proto,\n  function getEl(renderResult, referenceEl) {\n    return renderResult.getNode(referenceEl.ownerDocument);\n  },\n  function afterInsert(renderResult, referenceEl) {\n    var isShadow =\n      typeof ShadowRoot === \"function\" && referenceEl instanceof ShadowRoot;\n    return renderResult.afterInsert(\n      isShadow ? referenceEl : referenceEl.ownerDocument\n    );\n  }\n);\n","\"use strict\";\n/* jshint newcap:false */\n\nvar complain = \"MARKO_DEBUG\" && require(\"complain\");\n\nvar domInsert = require(\"../dom-insert\");\nvar defaultCreateOut = require(\"../createOut\");\nvar getComponentsContext = require(\"./ComponentsContext\")\n  .___getComponentsContext;\nvar componentsUtil = require(\"./util\");\nvar componentLookup = componentsUtil.___componentLookup;\nvar destroyNodeRecursive = componentsUtil.___destroyNodeRecursive;\nvar EventEmitter = require(\"events-light\");\nvar RenderResult = require(\"../RenderResult\");\nvar SubscriptionTracker = require(\"listener-tracker\");\nvar inherit = require(\"raptor-util/inherit\");\nvar updateManager = require(\"./update-manager\");\nvar morphdom = require(\"../vdom/morphdom\");\nvar eventDelegation = require(\"./event-delegation\");\nvar domData = require(\"./dom-data\");\nvar componentsByDOMNode = domData.___componentByDOMNode;\nvar keyedElementsByComponentId = domData.___ssrKeyedElementsByComponentId;\nvar CONTEXT_KEY = \"__subtree_context__\";\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar slice = Array.prototype.slice;\n\nvar COMPONENT_SUBSCRIBE_TO_OPTIONS;\nvar NON_COMPONENT_SUBSCRIBE_TO_OPTIONS = {\n  addDestroyListener: false\n};\n\nvar emit = EventEmitter.prototype.emit;\nvar ELEMENT_NODE = 1;\n\nfunction removeListener(removeEventListenerHandle) {\n  removeEventListenerHandle();\n}\n\nfunction walkFragments(fragment) {\n  var node;\n\n  while (fragment) {\n    node = fragment.firstChild;\n\n    if (!node) {\n      break;\n    }\n\n    fragment = node.fragment;\n  }\n\n  return node;\n}\n\nfunction handleCustomEventWithMethodListener(\n  component,\n  targetMethodName,\n  args,\n  extraArgs\n) {\n  // Remove the \"eventType\" argument\n  args.push(component);\n\n  if (extraArgs) {\n    args = extraArgs.concat(args);\n  }\n\n  var targetComponent = componentLookup[component.___scope];\n  var targetMethod =\n    typeof targetMethodName === \"function\"\n      ? targetMethodName\n      : targetComponent[targetMethodName];\n  if (!targetMethod) {\n    throw Error(\"Method not found: \" + targetMethodName);\n  }\n\n  targetMethod.apply(targetComponent, args);\n}\n\nfunction resolveKeyHelper(key, index) {\n  return index ? key + \"_\" + index : key;\n}\n\nfunction resolveComponentIdHelper(component, key, index) {\n  return component.id + \"-\" + resolveKeyHelper(key, index);\n}\n\n/**\n * This method is used to process \"update_<stateName>\" handler functions.\n * If all of the modified state properties have a user provided update handler\n * then a rerender will be bypassed and, instead, the DOM will be updated\n * looping over and invoking the custom update handlers.\n * @return {boolean} Returns true if if the DOM was updated. False, otherwise.\n */\nfunction processUpdateHandlers(component, stateChanges, oldState) {\n  var handlerMethod;\n  var handlers;\n\n  for (var propName in stateChanges) {\n    if (hasOwnProperty.call(stateChanges, propName)) {\n      var handlerMethodName = \"update_\" + propName;\n\n      handlerMethod = component[handlerMethodName];\n      if (handlerMethod) {\n        (handlers || (handlers = [])).push([propName, handlerMethod]);\n      } else {\n        // This state change does not have a state handler so return false\n        // to force a rerender\n        return;\n      }\n    }\n  }\n\n  // If we got here then all of the changed state properties have\n  // an update handler or there are no state properties that actually\n  // changed.\n  if (handlers) {\n    // Otherwise, there are handlers for all of the changed properties\n    // so apply the updates using those handlers\n\n    handlers.forEach(function(handler) {\n      var propertyName = handler[0];\n      handlerMethod = handler[1];\n\n      var newValue = stateChanges[propertyName];\n      var oldValue = oldState[propertyName];\n      handlerMethod.call(component, newValue, oldValue);\n    });\n\n    component.___emitUpdate();\n    component.___reset();\n  }\n\n  return true;\n}\n\nfunction checkInputChanged(existingComponent, oldInput, newInput) {\n  if (oldInput != newInput) {\n    if (oldInput == null || newInput == null) {\n      return true;\n    }\n\n    var oldKeys = Object.keys(oldInput);\n    var newKeys = Object.keys(newInput);\n    var len = oldKeys.length;\n    if (len !== newKeys.length) {\n      return true;\n    }\n\n    for (var i = len; i--; ) {\n      var key = oldKeys[i];\n      if (!(key in newInput && oldInput[key] === newInput[key])) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nvar componentProto;\n\n/**\n * Base component type.\n *\n * NOTE: Any methods that are prefixed with an underscore should be considered private!\n */\nfunction Component(id) {\n  EventEmitter.call(this);\n  this.id = id;\n  this.___state = null;\n  this.___rootNode = null;\n  this.___subscriptions = null;\n  this.___domEventListenerHandles = null;\n  this.___bubblingDomEvents = null; // Used to keep track of bubbling DOM events for components rendered on the server\n  this.___customEvents = null;\n  this.___scope = null;\n  this.___renderInput = null;\n  this.___input = undefined;\n  this.___mounted = false;\n  this.___global = undefined;\n  this.___destroyed = false;\n  this.___updateQueued = false;\n  this.___dirty = false;\n  this.___settingInput = false;\n  this.___document = undefined;\n\n  var ssrKeyedElements = keyedElementsByComponentId[id];\n\n  if (ssrKeyedElements) {\n    this.___keyedElements = ssrKeyedElements;\n    delete keyedElementsByComponentId[id];\n  } else {\n    this.___keyedElements = {};\n  }\n}\n\nComponent.prototype = componentProto = {\n  ___isComponent: true,\n\n  subscribeTo: function(target) {\n    if (!target) {\n      throw TypeError();\n    }\n\n    var subscriptions =\n      this.___subscriptions ||\n      (this.___subscriptions = new SubscriptionTracker());\n\n    var subscribeToOptions = target.___isComponent\n      ? COMPONENT_SUBSCRIBE_TO_OPTIONS\n      : NON_COMPONENT_SUBSCRIBE_TO_OPTIONS;\n\n    return subscriptions.subscribeTo(target, subscribeToOptions);\n  },\n\n  emit: function(eventType) {\n    var customEvents = this.___customEvents;\n    var target;\n\n    if (customEvents && (target = customEvents[eventType])) {\n      var targetMethodName = target[0];\n      var isOnce = target[1];\n      var extraArgs = target[2];\n      var args = slice.call(arguments, 1);\n\n      handleCustomEventWithMethodListener(\n        this,\n        targetMethodName,\n        args,\n        extraArgs\n      );\n\n      if (isOnce) {\n        delete customEvents[eventType];\n      }\n    }\n\n    return emit.apply(this, arguments);\n  },\n  getElId: function(key, index) {\n    if (!key) {\n      return this.id;\n    }\n    return resolveComponentIdHelper(this, key, index);\n  },\n  getEl: function(key, index) {\n    if (key) {\n      var keyedElement = this.___keyedElements[\n        \"@\" + resolveKeyHelper(key, index)\n      ];\n\n      // eslint-disable-next-line no-constant-condition\n      if (\"MARKO_DEBUG\") {\n        if (\n          keyedElement &&\n          keyedElement.nodeType !== 1 /* Node.ELEMENT_NODE */\n        ) {\n          throw new Error(\n            \"Using 'getEl(key)' to get a component instance is not supported, did you mean 'getComponent(key)'?\"\n          );\n        }\n      }\n\n      return keyedElement;\n    } else {\n      return this.el;\n    }\n  },\n  getEls: function(key) {\n    key = key + \"[]\";\n\n    var els = [];\n    var i = 0;\n    var el;\n    while ((el = this.getEl(key, i))) {\n      els.push(el);\n      i++;\n    }\n    return els;\n  },\n  getComponent: function(key, index) {\n    var rootNode = this.___keyedElements[\"@\" + resolveKeyHelper(key, index)];\n    // eslint-disable-next-line no-constant-condition\n    if (\"MARKO_DEBUG\") {\n      if (/\\[\\]$/.test(key)) {\n        throw new Error(\n          \"A repeated key[] was passed to getComponent. Use a non-repeating key if there is only one of these components.\"\n        );\n      }\n    }\n\n    return rootNode && componentsByDOMNode.get(rootNode);\n  },\n  getComponents: function(key) {\n    var lookup = this.___keyedElements[\"@\" + key + \"[]\"];\n    return lookup\n      ? Object.keys(lookup)\n          .map(function(key) {\n            return componentsByDOMNode.get(lookup[key]);\n          })\n          .filter(Boolean)\n      : [];\n  },\n  destroy: function() {\n    if (this.___destroyed) {\n      return;\n    }\n\n    var root = this.___rootNode;\n\n    this.___destroyShallow();\n\n    var nodes = root.nodes;\n\n    nodes.forEach(function(node) {\n      destroyNodeRecursive(node);\n\n      if (eventDelegation.___handleNodeDetach(node) !== false) {\n        node.parentNode.removeChild(node);\n      }\n    });\n\n    root.detached = true;\n\n    delete componentLookup[this.id];\n    this.___keyedElements = {};\n  },\n\n  ___destroyShallow: function() {\n    if (this.___destroyed) {\n      return;\n    }\n\n    this.___emitDestroy();\n    this.___destroyed = true;\n\n    componentsByDOMNode.set(this.___rootNode, undefined);\n\n    this.___rootNode = null;\n\n    // Unsubscribe from all DOM events\n    this.___removeDOMEventListeners();\n\n    var subscriptions = this.___subscriptions;\n    if (subscriptions) {\n      subscriptions.removeAllListeners();\n      this.___subscriptions = null;\n    }\n  },\n\n  isDestroyed: function() {\n    return this.___destroyed;\n  },\n  get state() {\n    return this.___state;\n  },\n  set state(newState) {\n    var state = this.___state;\n    if (!state && !newState) {\n      return;\n    }\n\n    if (!state) {\n      state = this.___state = new this.___State(this);\n    }\n\n    state.___replace(newState || {});\n\n    if (state.___dirty) {\n      this.___queueUpdate();\n    }\n\n    if (!newState) {\n      this.___state = null;\n    }\n  },\n  setState: function(name, value) {\n    var state = this.___state;\n\n    if (!state) {\n      state = this.___state = new this.___State(this);\n    }\n    if (typeof name == \"object\") {\n      // Merge in the new state with the old state\n      var newState = name;\n      for (var k in newState) {\n        if (hasOwnProperty.call(newState, k)) {\n          state.___set(k, newState[k], true /* ensure:true */);\n        }\n      }\n    } else {\n      state.___set(name, value, true /* ensure:true */);\n    }\n  },\n\n  setStateDirty: function(name, value) {\n    var state = this.___state;\n\n    if (arguments.length == 1) {\n      value = state[name];\n    }\n\n    state.___set(\n      name,\n      value,\n      true /* ensure:true */,\n      true /* forceDirty:true */\n    );\n  },\n\n  replaceState: function(newState) {\n    this.___state.___replace(newState);\n  },\n\n  get input() {\n    return this.___input;\n  },\n  set input(newInput) {\n    if (this.___settingInput) {\n      this.___input = newInput;\n    } else {\n      this.___setInput(newInput);\n    }\n  },\n\n  ___setInput: function(newInput, onInput, out) {\n    onInput = onInput || this.onInput;\n    var updatedInput;\n\n    var oldInput = this.___input;\n    this.___input = undefined;\n    this.___context = (out && out[CONTEXT_KEY]) || this.___context;\n\n    if (onInput) {\n      // We need to set a flag to preview `this.input = foo` inside\n      // onInput causing infinite recursion\n      this.___settingInput = true;\n      updatedInput = onInput.call(this, newInput || {}, out);\n      this.___settingInput = false;\n    }\n\n    newInput = this.___renderInput = updatedInput || newInput;\n\n    if ((this.___dirty = checkInputChanged(this, oldInput, newInput))) {\n      this.___queueUpdate();\n    }\n\n    if (this.___input === undefined) {\n      this.___input = newInput;\n      if (newInput && newInput.$global) {\n        this.___global = newInput.$global;\n      }\n    }\n\n    return newInput;\n  },\n\n  forceUpdate: function() {\n    this.___dirty = true;\n    this.___queueUpdate();\n  },\n\n  ___queueUpdate: function() {\n    if (!this.___updateQueued) {\n      this.___updateQueued = true;\n      updateManager.___queueComponentUpdate(this);\n    }\n  },\n\n  update: function() {\n    if (this.___destroyed === true || this.___isDirty === false) {\n      return;\n    }\n\n    var input = this.___input;\n    var state = this.___state;\n\n    if (this.___dirty === false && state !== null && state.___dirty === true) {\n      if (processUpdateHandlers(this, state.___changes, state.___old, state)) {\n        state.___dirty = false;\n      }\n    }\n\n    if (this.___isDirty === true) {\n      // The UI component is still dirty after process state handlers\n      // then we should rerender\n\n      if (this.shouldUpdate(input, state) !== false) {\n        this.___scheduleRerender();\n      }\n    }\n\n    this.___reset();\n  },\n\n  get ___isDirty() {\n    return (\n      this.___dirty === true ||\n      (this.___state !== null && this.___state.___dirty === true)\n    );\n  },\n\n  ___reset: function() {\n    this.___dirty = false;\n    this.___updateQueued = false;\n    this.___renderInput = null;\n    var state = this.___state;\n    if (state) {\n      state.___reset();\n    }\n  },\n\n  shouldUpdate: function() {\n    return true;\n  },\n\n  ___scheduleRerender: function() {\n    var self = this;\n    var renderer = self.___renderer;\n\n    if (!renderer) {\n      throw TypeError();\n    }\n\n    var input = this.___renderInput || this.___input;\n\n    updateManager.___batchUpdate(function() {\n      self.___rerender(input, false).afterInsert(self.___document);\n    });\n\n    this.___reset();\n  },\n\n  ___rerender: function(input, isHydrate) {\n    var doc = this.___document;\n    var globalData = this.___global;\n    var rootNode = this.___rootNode;\n    var renderer = this.___renderer;\n    var createOut = renderer.createOut || defaultCreateOut;\n    var out = createOut(globalData);\n    out.sync();\n    out.___document = this.___document;\n    out[CONTEXT_KEY] = this.___context;\n\n    var componentsContext = getComponentsContext(out);\n    var globalComponentsContext = componentsContext.___globalContext;\n    globalComponentsContext.___rerenderComponent = this;\n    globalComponentsContext.___isHydrate = isHydrate;\n\n    renderer(input, out);\n\n    var result = new RenderResult(out);\n\n    var targetNode = out.___getOutput().___firstChild;\n\n    morphdom(rootNode, targetNode, doc, componentsContext);\n\n    return result;\n  },\n\n  ___detach: function() {\n    var root = this.___rootNode;\n    root.remove();\n    return root;\n  },\n\n  ___removeDOMEventListeners: function() {\n    var eventListenerHandles = this.___domEventListenerHandles;\n    if (eventListenerHandles) {\n      eventListenerHandles.forEach(removeListener);\n      this.___domEventListenerHandles = null;\n    }\n  },\n\n  get ___rawState() {\n    var state = this.___state;\n    return state && state.___raw;\n  },\n\n  ___setCustomEvents: function(customEvents, scope) {\n    var finalCustomEvents = (this.___customEvents = {});\n    this.___scope = scope;\n\n    customEvents.forEach(function(customEvent) {\n      var eventType = customEvent[0];\n      var targetMethodName = customEvent[1];\n      var isOnce = customEvent[2];\n      var extraArgs = customEvent[3];\n\n      finalCustomEvents[eventType] = [targetMethodName, isOnce, extraArgs];\n    });\n  },\n\n  get el() {\n    return walkFragments(this.___rootNode);\n  },\n\n  get els() {\n    // eslint-disable-next-line no-constant-condition\n    if (\"MARKO_DEBUG\") {\n      complain(\n        'The \"this.els\" attribute is deprecated. Please use \"this.getEls(key)\" instead.'\n      );\n    }\n    return (this.___rootNode ? this.___rootNode.nodes : []).filter(function(\n      el\n    ) {\n      return el.nodeType === ELEMENT_NODE;\n    });\n  },\n\n  ___emit: emit,\n  ___emitCreate(input, out) {\n    this.onCreate && this.onCreate(input, out);\n    this.___emit(\"create\", input, out);\n  },\n\n  ___emitRender(out) {\n    this.onRender && this.onRender(out);\n    this.___emit(\"render\", out);\n  },\n\n  ___emitUpdate() {\n    this.onUpdate && this.onUpdate();\n    this.___emit(\"update\");\n  },\n\n  ___emitMount() {\n    this.onMount && this.onMount();\n    this.___emit(\"mount\");\n  },\n\n  ___emitDestroy() {\n    this.onDestroy && this.onDestroy();\n    this.___emit(\"destroy\");\n  }\n};\n\ncomponentProto.elId = componentProto.getElId;\ncomponentProto.___update = componentProto.update;\ncomponentProto.___destroy = componentProto.destroy;\n\n// Add all of the following DOM methods to Component.prototype:\n// - appendTo(referenceEl)\n// - replace(referenceEl)\n// - replaceChildrenOf(referenceEl)\n// - insertBefore(referenceEl)\n// - insertAfter(referenceEl)\n// - prependTo(referenceEl)\ndomInsert(\n  componentProto,\n  function getEl(component) {\n    return component.___detach();\n  },\n  function afterInsert(component) {\n    return component;\n  }\n);\n\ninherit(Component, EventEmitter);\n\nmodule.exports = Component;\n","\"use strict\";\nvar complain = \"MARKO_DEBUG\" && require(\"complain\");\nvar w10Noop = require(\"warp10/constants\").NOOP;\nvar componentUtil = require(\"./util\");\nvar attachBubblingEvent = componentUtil.___attachBubblingEvent;\nvar addDelegatedEventHandler = require(\"./event-delegation\")\n  .___addDelegatedEventHandler;\nvar extend = require(\"raptor-util/extend\");\nvar KeySequence = require(\"./KeySequence\");\nvar EMPTY_OBJECT = {};\n\nvar FLAG_WILL_RERENDER_IN_BROWSER = 1;\nvar FLAG_HAS_RENDER_BODY = 2;\n\n/**\n * A ComponentDef is used to hold the metadata collected at runtime for\n * a single component and this information is used to instantiate the component\n * later (after the rendered HTML has been added to the DOM)\n */\nfunction ComponentDef(component, componentId, componentsContext) {\n  this.___componentsContext = componentsContext; // The AsyncWriter that this component is associated with\n  this.___component = component;\n  this.id = componentId;\n\n  this.___domEvents = undefined; // An array of DOM events that need to be added (in sets of three)\n\n  this.___isExisting = false;\n\n  this.___renderBoundary = false;\n  this.___flags = 0;\n\n  this.___nextIdIndex = 0; // The unique integer to use for the next scoped ID\n  this.___keySequence = null;\n}\n\nComponentDef.prototype = {\n  ___nextKey: function(key) {\n    return (\n      this.___keySequence || (this.___keySequence = new KeySequence())\n    ).___nextKey(key);\n  },\n\n  /**\n   * This helper method generates a unique and fully qualified DOM element ID\n   * that is unique within the scope of the current component.\n   */\n  elId: function(nestedId) {\n    var id = this.id;\n\n    if (nestedId == null) {\n      return id;\n    } else {\n      if (typeof nestedId !== \"string\") {\n        // eslint-disable-next-line no-constant-condition\n        if (\"MARKO_DEBUG\") {\n          complain(\"Using non strings as keys is deprecated.\");\n        }\n\n        nestedId = String(nestedId);\n      }\n\n      if (nestedId.indexOf(\"#\") === 0) {\n        id = \"#\" + id;\n        nestedId = nestedId.substring(1);\n      }\n\n      return id + \"-\" + nestedId;\n    }\n  },\n  /**\n   * Returns the next auto generated unique ID for a nested DOM element or nested DOM component\n   */\n  ___nextComponentId: function() {\n    return this.id + \"-c\" + this.___nextIdIndex++;\n  },\n\n  d: function(eventName, handlerMethodName, isOnce, extraArgs) {\n    addDelegatedEventHandler(eventName);\n    return attachBubblingEvent(this, handlerMethodName, isOnce, extraArgs);\n  },\n\n  get ___type() {\n    return this.___component.___type;\n  }\n};\n\nComponentDef.prototype.nk = ComponentDef.prototype.___nextKey;\n\nComponentDef.___deserialize = function(o, types, global, registry) {\n  var id = o[0];\n  var typeName = types[o[1]];\n  var input = o[2] || null;\n  var extra = o[3] || EMPTY_OBJECT;\n\n  var state = extra.s;\n  var componentProps = extra.w;\n  var flags = extra.f;\n  var component = registry.___createComponent(typeName, id);\n\n  // Prevent newly created component from being queued for update since we area\n  // just building it from the server info\n  component.___updateQueued = true;\n\n  if (flags & FLAG_HAS_RENDER_BODY) {\n    (input || (input = {})).renderBody = w10Noop;\n  }\n\n  if (flags & FLAG_WILL_RERENDER_IN_BROWSER) {\n    if (component.onCreate) {\n      component.onCreate(input, { global: global });\n    }\n    if (component.onInput) {\n      input = component.onInput(input, { global: global }) || input;\n    }\n  } else {\n    if (state) {\n      var undefinedPropNames = extra.u;\n      if (undefinedPropNames) {\n        undefinedPropNames.forEach(function(undefinedPropName) {\n          state[undefinedPropName] = undefined;\n        });\n      }\n      // We go through the setter here so that we convert the state object\n      // to an instance of `State`\n      component.state = state;\n    }\n\n    if (componentProps) {\n      extend(component, componentProps);\n    }\n  }\n\n  component.___input = input;\n\n  if (extra.b) {\n    component.___bubblingDomEvents = extra.b;\n  }\n\n  var scope = extra.p;\n  var customEvents = extra.e;\n  if (customEvents) {\n    component.___setCustomEvents(customEvents, scope);\n  }\n\n  component.___global = global;\n\n  return {\n    id: id,\n    ___component: component,\n    ___domEvents: extra.d,\n    ___flags: extra.f || 0\n  };\n};\n\nmodule.exports = ComponentDef;\n","\"use strict\";\nvar GlobalComponentsContext = require(\"./GlobalComponentsContext\");\n\nfunction ComponentsContext(out, parentComponentsContext) {\n  var globalComponentsContext;\n  var componentDef;\n\n  if (parentComponentsContext) {\n    globalComponentsContext = parentComponentsContext.___globalContext;\n    componentDef = parentComponentsContext.___componentDef;\n\n    var nestedContextsForParent;\n    if (\n      !(nestedContextsForParent = parentComponentsContext.___nestedContexts)\n    ) {\n      nestedContextsForParent = parentComponentsContext.___nestedContexts = [];\n    }\n\n    nestedContextsForParent.push(this);\n  } else {\n    globalComponentsContext = out.global.___components;\n    if (globalComponentsContext === undefined) {\n      out.global.___components = globalComponentsContext = new GlobalComponentsContext(\n        out\n      );\n    }\n  }\n\n  this.___globalContext = globalComponentsContext;\n  this.___components = [];\n  this.___out = out;\n  this.___componentDef = componentDef;\n  this.___nestedContexts = undefined;\n  this.___isPreserved =\n    parentComponentsContext && parentComponentsContext.___isPreserved;\n}\n\nComponentsContext.prototype = {\n  ___initComponents: function(doc) {\n    var componentDefs = this.___components;\n\n    ComponentsContext.___initClientRendered(componentDefs, doc);\n\n    this.___out.emit(\"___componentsInitialized\");\n\n    // Reset things stored in global since global is retained for\n    // future renders\n    this.___out.global.___components = undefined;\n\n    return componentDefs;\n  }\n};\n\nfunction getComponentsContext(out) {\n  return out.___components || (out.___components = new ComponentsContext(out));\n}\n\nmodule.exports = exports = ComponentsContext;\n\nexports.___getComponentsContext = getComponentsContext;\n","var nextComponentIdProvider = require(\"./util\").___nextComponentIdProvider;\n\nfunction GlobalComponentsContext(out) {\n  this.___renderedComponentsById = {};\n  this.___rerenderComponent = undefined;\n  this.___nextComponentId = nextComponentIdProvider(out);\n}\n\nmodule.exports = GlobalComponentsContext;\n","function KeySequence() {\n  this.___lookup = Object.create(null);\n}\n\nKeySequence.prototype.___nextKey = function(key) {\n  var lookup = this.___lookup;\n\n  if (lookup[key]) {\n    return key + \"_\" + lookup[key]++;\n  }\n\n  lookup[key] = 1;\n  return key;\n};\n\nmodule.exports = KeySequence;\n","var extend = require(\"raptor-util/extend\");\n\nfunction ensure(state, propertyName) {\n  var proto = state.constructor.prototype;\n  if (!(propertyName in proto)) {\n    Object.defineProperty(proto, propertyName, {\n      get: function() {\n        return this.___raw[propertyName];\n      },\n      set: function(value) {\n        this.___set(propertyName, value, false /* ensure:false */);\n      }\n    });\n  }\n}\n\nfunction State(component) {\n  this.___component = component;\n  this.___raw = {};\n\n  this.___dirty = false;\n  this.___old = null;\n  this.___changes = null;\n  this.___forced = null; // An object that we use to keep tracking of state properties that were forced to be dirty\n\n  Object.seal(this);\n}\n\nState.prototype = {\n  ___reset: function() {\n    var self = this;\n\n    self.___dirty = false;\n    self.___old = null;\n    self.___changes = null;\n    self.___forced = null;\n  },\n\n  ___replace: function(newState) {\n    var state = this;\n    var key;\n\n    var rawState = this.___raw;\n\n    for (key in rawState) {\n      if (!(key in newState)) {\n        state.___set(\n          key,\n          undefined,\n          false /* ensure:false */,\n          false /* forceDirty:false */\n        );\n      }\n    }\n\n    for (key in newState) {\n      state.___set(\n        key,\n        newState[key],\n        true /* ensure:true */,\n        false /* forceDirty:false */\n      );\n    }\n  },\n  ___set: function(name, value, shouldEnsure, forceDirty) {\n    var rawState = this.___raw;\n\n    if (shouldEnsure) {\n      ensure(this, name);\n    }\n\n    if (forceDirty) {\n      var forcedDirtyState = this.___forced || (this.___forced = {});\n      forcedDirtyState[name] = true;\n    } else if (rawState[name] === value) {\n      return;\n    }\n\n    if (!this.___dirty) {\n      // This is the first time we are modifying the component state\n      // so introduce some properties to do some tracking of\n      // changes to the state\n      this.___dirty = true; // Mark the component state as dirty (i.e. modified)\n      this.___old = rawState;\n      this.___raw = rawState = extend({}, rawState);\n      this.___changes = {};\n      this.___component.___queueUpdate();\n    }\n\n    this.___changes[name] = value;\n\n    if (value === undefined) {\n      // Don't store state properties with an undefined or null value\n      delete rawState[name];\n    } else {\n      // Otherwise, store the new value in the component state\n      rawState[name] = value;\n    }\n  },\n  toJSON: function() {\n    return this.___raw;\n  }\n};\n\nmodule.exports = State;\n","\"use strict\";\n/* jshint newcap:false */\n\nvar BaseState = require(\"./State\");\nvar BaseComponent = require(\"./Component\");\nvar inherit = require(\"raptor-util/inherit\");\n\nmodule.exports = function defineComponent(def, renderer) {\n  if (def.___isComponent) {\n    return def;\n  }\n\n  var ComponentClass = function() {};\n  var proto;\n\n  var type = typeof def;\n\n  if (type == \"function\") {\n    proto = def.prototype;\n  } else if (type == \"object\") {\n    proto = def;\n  } else {\n    throw TypeError();\n  }\n\n  ComponentClass.prototype = proto;\n\n  // We don't use the constructor provided by the user\n  // since we don't invoke their constructor until\n  // we have had a chance to do our own initialization.\n  // Instead, we store their constructor in the \"initComponent\"\n  // property and that method gets called later inside\n  // init-components-browser.js\n  function Component(id) {\n    BaseComponent.call(this, id);\n  }\n\n  if (!proto.___isComponent) {\n    // Inherit from Component if they didn't already\n    inherit(ComponentClass, BaseComponent);\n  }\n\n  // The same prototype will be used by our constructor after\n  // we he have set up the prototype chain using the inherit function\n  proto = Component.prototype = ComponentClass.prototype;\n\n  // proto.constructor = def.constructor = Component;\n\n  // Set a flag on the constructor function to make it clear this is\n  // a component so that we can short-circuit this work later\n  Component.___isComponent = true;\n\n  function State(component) {\n    BaseState.call(this, component);\n  }\n  inherit(State, BaseState);\n  proto.___State = State;\n  proto.___renderer = renderer;\n\n  return Component;\n};\n","module.exports = {\n  ___vPropsByDOMNode: new WeakMap(),\n  ___vElementByDOMNode: new WeakMap(),\n  ___componentByDOMNode: new WeakMap(),\n  ___detachedByDOMNode: new WeakMap(),\n  ___keyByDOMNode: new WeakMap(),\n  ___ssrKeyedElementsByComponentId: {}\n};\n","var componentsUtil = require(\"./util\");\nvar runtimeId = componentsUtil.___runtimeId;\nvar componentLookup = componentsUtil.___componentLookup;\nvar getMarkoPropsFromEl = componentsUtil.___getMarkoPropsFromEl;\n\nvar TEXT_NODE = 3;\n\n// We make our best effort to allow multiple marko runtimes to be loaded in the\n// same window. Each marko runtime will get its own unique runtime ID.\nvar listenersAttachedKey = \"$MDE\" + runtimeId;\nvar delegatedEvents = {};\n\nfunction getEventFromEl(el, eventName) {\n  var virtualProps = getMarkoPropsFromEl(el);\n  var eventInfo = virtualProps[eventName];\n\n  if (typeof eventInfo === \"string\") {\n    eventInfo = eventInfo.split(\" \");\n    if (eventInfo[2]) {\n      eventInfo[2] = eventInfo[2] === \"true\";\n    }\n    if (eventInfo.length == 4) {\n      eventInfo[3] = parseInt(eventInfo[3], 10);\n    }\n  }\n\n  return eventInfo;\n}\n\nfunction delegateEvent(node, eventName, target, event) {\n  var targetMethod = target[0];\n  var targetComponentId = target[1];\n  var isOnce = target[2];\n  var extraArgs = target[3];\n\n  if (isOnce) {\n    var virtualProps = getMarkoPropsFromEl(node);\n    delete virtualProps[eventName];\n  }\n\n  var targetComponent = componentLookup[targetComponentId];\n\n  if (!targetComponent) {\n    return;\n  }\n\n  var targetFunc =\n    typeof targetMethod === \"function\"\n      ? targetMethod\n      : targetComponent[targetMethod];\n  if (!targetFunc) {\n    throw Error(\"Method not found: \" + targetMethod);\n  }\n\n  if (extraArgs != null) {\n    if (typeof extraArgs === \"number\") {\n      extraArgs = targetComponent.___bubblingDomEvents[extraArgs];\n    }\n  }\n\n  // Invoke the component method\n  if (extraArgs) {\n    targetFunc.apply(targetComponent, extraArgs.concat(event, node));\n  } else {\n    targetFunc.call(targetComponent, event, node);\n  }\n}\n\nfunction addDelegatedEventHandler(eventType) {\n  if (!delegatedEvents[eventType]) {\n    delegatedEvents[eventType] = true;\n  }\n}\n\nfunction addDelegatedEventHandlerToDoc(eventType, doc) {\n  var body = doc.body || doc;\n  var listeners = (doc[listenersAttachedKey] = doc[listenersAttachedKey] || {});\n  if (!listeners[eventType]) {\n    body.addEventListener(\n      eventType,\n      (listeners[eventType] = function(event) {\n        var propagationStopped = false;\n\n        // Monkey-patch to fix #97\n        var oldStopPropagation = event.stopPropagation;\n\n        event.stopPropagation = function() {\n          oldStopPropagation.call(event);\n          propagationStopped = true;\n        };\n\n        var curNode = event.target;\n        if (!curNode) {\n          return;\n        }\n\n        curNode =\n          // event.target of an SVGElementInstance does not have a\n          // `getAttribute` function in IE 11.\n          // See https://github.com/marko-js/marko/issues/796\n          curNode.correspondingUseElement ||\n          // in some browsers the event target can be a text node\n          // one example being dragenter in firefox.\n          (curNode.nodeType === TEXT_NODE ? curNode.parentNode : curNode);\n\n        // Search up the tree looking DOM events mapped to target\n        // component methods\n        var propName = \"on\" + eventType;\n        var target;\n\n        // Attributes will have the following form:\n        // on<event_type>(\"<target_method>|<component_id>\")\n\n        do {\n          if ((target = getEventFromEl(curNode, propName))) {\n            delegateEvent(curNode, propName, target, event);\n\n            if (propagationStopped) {\n              break;\n            }\n          }\n        } while ((curNode = curNode.parentNode) && curNode.getAttribute);\n      }),\n      true\n    );\n  }\n}\n\nfunction noop() {}\n\nexports.___handleNodeAttach = noop;\nexports.___handleNodeDetach = noop;\nexports.___delegateEvent = delegateEvent;\nexports.___getEventFromEl = getEventFromEl;\nexports.___addDelegatedEventHandler = addDelegatedEventHandler;\nexports.___init = function(doc) {\n  Object.keys(delegatedEvents).forEach(function(eventType) {\n    addDelegatedEventHandlerToDoc(eventType, doc);\n  });\n};\n","var componentsUtil = require(\"./util\");\nvar initComponents = require(\"./init-components\");\nvar registry = require(\"./registry\");\n\nrequire(\"./ComponentsContext\").___initClientRendered =\n  initComponents.___initClientRendered;\n\nexports.getComponentForEl = componentsUtil.___getComponentForEl;\nexports.init = window.$initComponents = initComponents.___initServerRendered;\n\nexports.register = function(id, component) {\n  registry.r(id, function() {\n    return component;\n  });\n};\n","\"use strict\";\nvar complain = \"MARKO_DEBUG\" && require(\"complain\");\nvar warp10Finalize = require(\"warp10/finalize\");\nvar eventDelegation = require(\"./event-delegation\");\nvar win = window;\nvar defaultDocument = document;\nvar createFragmentNode = require(\"../vdom/morphdom/fragment\")\n  .___createFragmentNode;\nvar componentsUtil = require(\"./util-browser\");\nvar componentLookup = componentsUtil.___componentLookup;\nvar addComponentRootToKeyedElements =\n  componentsUtil.___addComponentRootToKeyedElements;\nvar ComponentDef = require(\"./ComponentDef\");\nvar registry = require(\"./registry\");\nvar domData = require(\"./dom-data\");\nvar keyedElementsByComponentId = domData.___ssrKeyedElementsByComponentId;\nvar componentsByDOMNode = domData.___componentByDOMNode;\nvar serverComponentRootNodes = {};\nvar serverRenderedMeta = {};\n\nvar DEFAULT_RUNTIME_ID = \"M\";\nvar FLAG_WILL_RERENDER_IN_BROWSER = 1;\n// var FLAG_HAS_RENDER_BODY = 2;\n\nvar deferredDefs;\n\nfunction indexServerComponentBoundaries(node, runtimeId, stack) {\n  var componentId;\n  var ownerId;\n  var ownerComponent;\n  var keyedElements;\n  var nextSibling;\n  var runtimeLength = runtimeId.length;\n  stack = stack || [];\n\n  node = node.firstChild;\n  while (node) {\n    nextSibling = node.nextSibling;\n    if (node.nodeType === 8) {\n      // Comment node\n      var commentValue = node.nodeValue;\n      if (commentValue.slice(0, runtimeLength) === runtimeId) {\n        var firstChar = commentValue[runtimeLength];\n\n        if (firstChar === \"^\" || firstChar === \"#\") {\n          stack.push(node);\n        } else if (firstChar === \"/\") {\n          var endNode = node;\n          var startNode = stack.pop();\n          var rootNode;\n\n          if (startNode.parentNode === endNode.parentNode) {\n            rootNode = createFragmentNode(startNode.nextSibling, endNode);\n          } else {\n            rootNode = createFragmentNode(\n              endNode.parentNode.firstChild,\n              endNode\n            );\n          }\n\n          componentId = startNode.nodeValue.substring(runtimeLength + 1);\n          firstChar = startNode.nodeValue[runtimeLength];\n\n          if (firstChar === \"^\") {\n            var parts = componentId.split(/ /g);\n            var key = parts[2];\n            ownerId = parts[1];\n            componentId = parts[0];\n            if ((ownerComponent = componentLookup[ownerId])) {\n              keyedElements = ownerComponent.___keyedElements;\n            } else {\n              keyedElements =\n                keyedElementsByComponentId[ownerId] ||\n                (keyedElementsByComponentId[ownerId] = {});\n            }\n            addComponentRootToKeyedElements(\n              keyedElements,\n              key,\n              rootNode,\n              componentId\n            );\n          }\n\n          serverComponentRootNodes[componentId] = rootNode;\n\n          startNode.parentNode.removeChild(startNode);\n          endNode.parentNode.removeChild(endNode);\n        }\n      }\n    } else if (node.nodeType === 1) {\n      // HTML element node\n      var markoKey = node.getAttribute(\"data-marko-key\");\n      var markoProps = componentsUtil.___getMarkoPropsFromEl(node);\n      if (markoKey) {\n        var separatorIndex = markoKey.indexOf(\" \");\n        ownerId = markoKey.substring(separatorIndex + 1);\n        markoKey = markoKey.substring(0, separatorIndex);\n        if ((ownerComponent = componentLookup[ownerId])) {\n          keyedElements = ownerComponent.___keyedElements;\n        } else {\n          keyedElements =\n            keyedElementsByComponentId[ownerId] ||\n            (keyedElementsByComponentId[ownerId] = {});\n        }\n        keyedElements[markoKey] = node;\n      }\n      if (markoProps) {\n        Object.keys(markoProps).forEach(function(key) {\n          if (key.slice(0, 2) === \"on\") {\n            eventDelegation.___addDelegatedEventHandler(key.slice(2));\n          }\n        });\n      }\n      indexServerComponentBoundaries(node, runtimeId, stack);\n    }\n\n    node = nextSibling;\n  }\n}\n\nfunction invokeComponentEventHandler(component, targetMethodName, args) {\n  var method = component[targetMethodName];\n  if (!method) {\n    throw Error(\"Method not found: \" + targetMethodName);\n  }\n\n  method.apply(component, args);\n}\n\nfunction addEventListenerHelper(el, eventType, isOnce, listener) {\n  var eventListener = listener;\n  if (isOnce) {\n    eventListener = function(event) {\n      listener(event);\n      el.removeEventListener(eventType, eventListener);\n    };\n  }\n\n  el.addEventListener(eventType, eventListener, false);\n\n  return function remove() {\n    el.removeEventListener(eventType, eventListener);\n  };\n}\n\nfunction addDOMEventListeners(\n  component,\n  el,\n  eventType,\n  targetMethodName,\n  isOnce,\n  extraArgs,\n  handles\n) {\n  var removeListener = addEventListenerHelper(el, eventType, isOnce, function(\n    event\n  ) {\n    var args = [event, el];\n    if (extraArgs) {\n      args = extraArgs.concat(args);\n    }\n\n    invokeComponentEventHandler(component, targetMethodName, args);\n  });\n  handles.push(removeListener);\n}\n\nfunction initComponent(componentDef, doc) {\n  var component = componentDef.___component;\n\n  component.___reset();\n  component.___document = doc;\n\n  var isExisting = componentDef.___isExisting;\n\n  if (isExisting) {\n    component.___removeDOMEventListeners();\n  }\n\n  var domEvents = componentDef.___domEvents;\n  if (domEvents) {\n    var eventListenerHandles = [];\n\n    domEvents.forEach(function(domEventArgs) {\n      // The event mapping is for a direct DOM event (not a custom event and not for bubblign dom events)\n\n      var eventType = domEventArgs[0];\n      var targetMethodName = domEventArgs[1];\n      var eventEl = component.___keyedElements[domEventArgs[2]];\n      var isOnce = domEventArgs[3];\n      var extraArgs = domEventArgs[4];\n\n      addDOMEventListeners(\n        component,\n        eventEl,\n        eventType,\n        targetMethodName,\n        isOnce,\n        extraArgs,\n        eventListenerHandles\n      );\n    });\n\n    if (eventListenerHandles.length) {\n      component.___domEventListenerHandles = eventListenerHandles;\n    }\n  }\n\n  if (component.___mounted) {\n    component.___emitUpdate();\n  } else {\n    component.___mounted = true;\n    component.___emitMount();\n  }\n}\n\n/**\n * This method is used to initialized components associated with UI components\n * rendered in the browser. While rendering UI components a \"components context\"\n * is added to the rendering context to keep up with which components are rendered.\n * When ready, the components can then be initialized by walking the component tree\n * in the components context (nested components are initialized before ancestor components).\n * @param  {Array<marko-components/lib/ComponentDef>} componentDefs An array of ComponentDef instances\n */\nfunction initClientRendered(componentDefs, doc) {\n  // Ensure that event handlers to handle delegating events are\n  // always attached before initializing any components\n  eventDelegation.___init(doc);\n\n  doc = doc || defaultDocument;\n  var len = componentDefs.length;\n  var componentDef;\n  var i;\n\n  for (i = len; i--; ) {\n    componentDef = componentDefs[i];\n    trackComponent(componentDef);\n  }\n\n  for (i = len; i--; ) {\n    componentDef = componentDefs[i];\n    initComponent(componentDef, doc);\n  }\n}\n\n/**\n * This method initializes all components that were rendered on the server by iterating over all\n * of the component IDs.\n */\nfunction initServerRendered(renderedComponents, doc) {\n  var type = typeof renderedComponents;\n  var globalKey = \"$\";\n  var runtimeId;\n\n  if (type !== \"object\") {\n    if (type === \"string\") {\n      runtimeId = renderedComponents;\n      globalKey += runtimeId + \"_C\";\n    } else {\n      globalKey += (runtimeId = DEFAULT_RUNTIME_ID) + \"C\";\n    }\n\n    renderedComponents = win[globalKey];\n\n    var fakeArray = (win[globalKey] = {\n      r: runtimeId,\n      concat: initServerRendered\n    });\n\n    if (renderedComponents && renderedComponents.forEach) {\n      renderedComponents.forEach(function(renderedComponent) {\n        fakeArray.concat(renderedComponent);\n      });\n    }\n\n    return fakeArray;\n  }\n\n  var isFromSerializedGlobals = this.concat === initServerRendered;\n  renderedComponents = warp10Finalize(renderedComponents);\n\n  if (isFromSerializedGlobals) {\n    runtimeId = this.r;\n    doc = defaultDocument;\n  } else {\n    runtimeId = renderedComponents.r || DEFAULT_RUNTIME_ID;\n    doc = doc || defaultDocument;\n\n    // eslint-disable-next-line no-constant-condition\n    if (\"MARKO_DEBUG\") {\n      complain(\n        \"Passing serialized data to `require('marko/components).init` is deprecated. Instead set '$global.runtimeId' and provide the 'runtimeId' option to your Marko bundler plugin.\"\n      );\n    }\n  }\n\n  // eslint-disable-next-line no-constant-condition\n  if (\"MARKO_DEBUG\") {\n    if (doc !== defaultDocument) {\n      complain(\n        \"Passing a document other than the current document to `require('marko/components).init` is deprecated.\"\n      );\n    }\n  }\n\n  var prefix = renderedComponents.p || \"\";\n  var meta = serverRenderedMeta[prefix];\n  var isLast = renderedComponents.l;\n\n  if (meta) {\n    if (isLast) {\n      delete serverRenderedMeta[prefix];\n    }\n  } else {\n    meta = {};\n\n    if (!isLast) {\n      serverRenderedMeta[prefix] = meta;\n    }\n  }\n\n  // Ensure that event handlers to handle delegating events are\n  // always attached before initializing any components\n  indexServerComponentBoundaries(doc, runtimeId);\n  eventDelegation.___init(doc);\n\n  if (renderedComponents.g) {\n    meta.___globals = renderedComponents.g;\n  }\n\n  if (renderedComponents.t) {\n    meta.___types = meta.___types\n      ? meta.___types.concat(renderedComponents.t)\n      : renderedComponents.t;\n  }\n\n  // hydrate components top down (leaf nodes last)\n  // and return an array of functions to mount these components\n  (renderedComponents.w || [])\n    .map(function(componentDef) {\n      var typeName = meta.___types[componentDef[1]];\n\n      return registry.___isRegistered(typeName)\n        ? tryHydrateComponent(componentDef, meta, doc, runtimeId)\n        : registry.___addPendingDef(componentDef, typeName, doc, runtimeId);\n    })\n    .reverse()\n    .forEach(tryInvoke);\n\n  return this;\n}\n\nfunction tryHydrateComponent(rawDef, meta, doc, runtimeId) {\n  var componentDef = ComponentDef.___deserialize(\n    rawDef,\n    meta.___types,\n    meta.___globals,\n    registry\n  );\n  var mount = hydrateComponentAndGetMount(componentDef, doc);\n\n  if (!mount) {\n    // hydrateComponentAndGetMount will return false if there is not rootNode\n    // for the component.  If this is the case, we'll wait until the\n    // DOM has fully loaded to attempt to init the component again.\n    if (deferredDefs) {\n      deferredDefs.push(componentDef);\n    } else {\n      deferredDefs = [componentDef];\n      doc.addEventListener(\"DOMContentLoaded\", function() {\n        indexServerComponentBoundaries(doc, runtimeId);\n        deferredDefs\n          .map(function(componentDef) {\n            return hydrateComponentAndGetMount(componentDef, doc);\n          })\n          .reverse()\n          .forEach(tryInvoke);\n        deferredDefs = undefined;\n      });\n    }\n  }\n\n  return mount;\n}\n\nfunction hydrateComponentAndGetMount(componentDef, doc) {\n  var componentId = componentDef.id;\n  var component = componentDef.___component;\n  var rootNode = serverComponentRootNodes[componentId];\n  var renderResult;\n\n  if (rootNode) {\n    delete serverComponentRootNodes[componentId];\n\n    component.___rootNode = rootNode;\n    componentsByDOMNode.set(rootNode, component);\n\n    if (componentDef.___flags & FLAG_WILL_RERENDER_IN_BROWSER) {\n      component.___document = doc;\n      renderResult = component.___rerender(component.___input, true);\n      trackComponent(componentDef);\n      return function mount() {\n        renderResult.afterInsert(doc);\n      };\n    } else {\n      trackComponent(componentDef);\n    }\n\n    return function mount() {\n      initComponent(componentDef, doc);\n    };\n  }\n}\n\nfunction trackComponent(componentDef) {\n  var component = componentDef.___component;\n  if (component) {\n    componentLookup[component.id] = component;\n  }\n}\n\nfunction tryInvoke(fn) {\n  if (fn) fn();\n}\n\nexports.___initClientRendered = initClientRendered;\nexports.___initServerRendered = initServerRendered;\nexports.___tryHydrateComponent = tryHydrateComponent;\n","var complain = \"MARKO_DEBUG\" && require(\"complain\");\nvar queueMicrotask = require(\"../queueMicrotask\");\nvar defineComponent = require(\"./defineComponent\");\nvar initComponents = require(\"./init-components-browser\");\nrequire(\".\");\n\nvar registered = {};\nvar loaded = {};\nvar componentTypes = {};\nvar pendingDefs;\n\nfunction register(type, def) {\n  var pendingForType;\n  if (pendingDefs) {\n    pendingForType = pendingDefs[type];\n  }\n  registered[type] = def;\n  delete loaded[type];\n  delete componentTypes[type];\n\n  if (pendingForType) {\n    delete pendingDefs[type];\n    queueMicrotask(function() {\n      pendingForType.forEach(function(args) {\n        initComponents.___tryHydrateComponent(\n          args[0],\n          type,\n          args[1],\n          args[2]\n        )();\n      });\n    });\n  }\n\n  return type;\n}\n\nfunction addPendingDef(def, type, doc, runtimeId) {\n  if (!pendingDefs) {\n    pendingDefs = {};\n\n    // eslint-disable-next-line no-constant-condition\n    if (\"MARKO_DEBUG\") {\n      doc.addEventListener(\"load\", function() {\n        var pendingComponentIds = Object.keys(pendingDefs);\n        if (pendingComponentIds.length) {\n          complain(\n            \"Marko templates were never loaded for: \" + pendingComponentIds\n          );\n        }\n      });\n    }\n  }\n  (pendingDefs[type] = pendingDefs[type] || []).push([def, doc, runtimeId]);\n}\n\nfunction isRegistered(type) {\n  return Boolean(registered[type]);\n}\n\nfunction load(typeName) {\n  var target = loaded[typeName];\n  if (!target) {\n    target = registered[typeName];\n\n    if (target) {\n      target = target();\n    }\n\n    if (!target) {\n      throw Error(\"Component not found: \" + typeName);\n    }\n\n    loaded[typeName] = target;\n  }\n\n  return target;\n}\n\nfunction getComponentClass(typeName) {\n  var ComponentClass = componentTypes[typeName];\n\n  if (ComponentClass) {\n    return ComponentClass;\n  }\n\n  ComponentClass = load(typeName);\n\n  ComponentClass = ComponentClass.Component || ComponentClass;\n\n  if (!ComponentClass.___isComponent) {\n    ComponentClass = defineComponent(ComponentClass, ComponentClass.renderer);\n  }\n\n  // Make the component \"type\" accessible on each component instance\n  ComponentClass.prototype.___type = typeName;\n\n  // eslint-disable-next-line no-constant-condition\n  if (\"MARKO_DEBUG\") {\n    var classNameMatch = /\\/([^/]+?)(?:\\/index|\\/template|)(?:\\.marko|\\.component(?:-browser)?|)$/.exec(\n      typeName\n    );\n    var className = classNameMatch ? classNameMatch[1] : \"AnonymousComponent\";\n    className = className.replace(/-(.)/g, function(g) {\n      return g[1].toUpperCase();\n    });\n    className = className\n      .replace(/\\$\\d+\\.\\d+\\.\\d+$/, \"\")\n      .replace(/^[^a-z$_]/i, \"_$&\")\n      .replace(/[^0-9a-z$_]+/gi, \"_\");\n    className = className[0].toUpperCase() + className.slice(1);\n    // eslint-disable-next-line no-unused-vars\n    try {\n      var OldComponentClass = ComponentClass;\n      eval(\n        \"ComponentClass = function \" +\n          className +\n          \"(id, doc) { OldComponentClass.call(this, id, doc); }\"\n      );\n      ComponentClass.prototype = OldComponentClass.prototype;\n    } catch (e) {\n      /** ignore error */\n    }\n  }\n\n  componentTypes[typeName] = ComponentClass;\n\n  return ComponentClass;\n}\n\nfunction createComponent(typeName, id) {\n  var ComponentClass = getComponentClass(typeName);\n  return new ComponentClass(id);\n}\n\nexports.r = register;\nexports.___createComponent = createComponent;\nexports.___isRegistered = isRegistered;\nexports.___addPendingDef = addPendingDef;\n","\"use strict\";\n\nvar updatesScheduled = false;\nvar batchStack = []; // A stack of batched updates\nvar unbatchedQueue = []; // Used for scheduled batched updates\n\nvar setImmediate = require(\"../setImmediate\");\n\n/**\n * This function is called when we schedule the update of \"unbatched\"\n * updates to components.\n */\nfunction updateUnbatchedComponents() {\n  if (unbatchedQueue.length) {\n    try {\n      updateComponents(unbatchedQueue);\n    } finally {\n      // Reset the flag now that this scheduled batch update\n      // is complete so that we can later schedule another\n      // batched update if needed\n      updatesScheduled = false;\n    }\n  }\n}\n\nfunction scheduleUpdates() {\n  if (updatesScheduled) {\n    // We have already scheduled a batched update for the\n    // nextTick so nothing to do\n    return;\n  }\n\n  updatesScheduled = true;\n\n  setImmediate(updateUnbatchedComponents);\n}\n\nfunction updateComponents(queue) {\n  // Loop over the components in the queue and update them.\n  // NOTE: It is okay if the queue grows during the iteration\n  //       since we will still get to them at the end\n  for (var i = 0; i < queue.length; i++) {\n    var component = queue[i];\n    component.___update(); // Do the actual component update\n  }\n\n  // Clear out the queue by setting the length to zero\n  queue.length = 0;\n}\n\nfunction batchUpdate(func) {\n  // If the batched update stack is empty then this\n  // is the outer batched update. After the outer\n  // batched update completes we invoke the \"afterUpdate\"\n  // event listeners.\n  var batch = {\n    ___queue: null\n  };\n\n  batchStack.push(batch);\n\n  try {\n    func();\n  } finally {\n    try {\n      // Update all of the components that where queued up\n      // in this batch (if any)\n      if (batch.___queue) {\n        updateComponents(batch.___queue);\n      }\n    } finally {\n      // Now that we have completed the update of all the components\n      // in this batch we need to remove it off the top of the stack\n      batchStack.length--;\n    }\n  }\n}\n\nfunction queueComponentUpdate(component) {\n  var batchStackLen = batchStack.length;\n\n  if (batchStackLen) {\n    // When a batch update is started we push a new batch on to a stack.\n    // If the stack has a non-zero length then we know that a batch has\n    // been started so we can just queue the component on the top batch. When\n    // the batch is ended this component will be updated.\n    var batch = batchStack[batchStackLen - 1];\n\n    // We default the batch queue to null to avoid creating an Array instance\n    // unnecessarily. If it is null then we create a new Array, otherwise\n    // we push it onto the existing Array queue\n    if (batch.___queue) {\n      batch.___queue.push(component);\n    } else {\n      batch.___queue = [component];\n    }\n  } else {\n    // We are not within a batched update. We need to schedule a batch update\n    // for the nextTick (if that hasn't been done already) and we will\n    // add the component to the unbatched queued\n    scheduleUpdates();\n    unbatchedQueue.push(component);\n  }\n}\n\nexports.___queueComponentUpdate = queueComponentUpdate;\nexports.___batchUpdate = batchUpdate;\n","var domData = require(\"./dom-data\");\nvar componentsByDOMNode = domData.___componentByDOMNode;\nvar keysByDOMNode = domData.___keyByDOMNode;\nvar vElementsByDOMNode = domData.___vElementByDOMNode;\nvar vPropsByDOMNode = domData.___vPropsByDOMNode;\nvar markoUID = window.$MUID || (window.$MUID = { i: 0 });\nvar runtimeId = markoUID.i++;\n\nvar componentLookup = {};\n\nvar defaultDocument = document;\nvar EMPTY_OBJECT = {};\n\nfunction getComponentForEl(el, doc) {\n  var node =\n    typeof el == \"string\" ? (doc || defaultDocument).getElementById(el) : el;\n  var component;\n  var vElement;\n\n  while (node) {\n    if (node.fragment) {\n      if (node.fragment.endNode === node) {\n        node = node.fragment.startNode;\n      } else {\n        node = node.fragment;\n        component = componentsByDOMNode.get(node);\n      }\n    } else if ((vElement = vElementsByDOMNode.get(node))) {\n      component = vElement.___ownerComponent;\n    }\n\n    if (component) {\n      return component;\n    }\n\n    node = node.previousSibling || node.parentNode;\n  }\n}\n\nfunction destroyComponentForNode(node) {\n  var componentToDestroy = componentsByDOMNode.get(node.fragment || node);\n  if (componentToDestroy) {\n    componentToDestroy.___destroyShallow();\n    delete componentLookup[componentToDestroy.id];\n  }\n}\nfunction destroyNodeRecursive(node, component) {\n  destroyComponentForNode(node);\n  if (node.nodeType === 1 || node.nodeType === 12) {\n    var key;\n\n    if (component && (key = keysByDOMNode.get(node))) {\n      if (node === component.___keyedElements[key]) {\n        if (componentsByDOMNode.get(node) && /\\[\\]$/.test(key)) {\n          delete component.___keyedElements[key][\n            componentsByDOMNode.get(node).id\n          ];\n        } else {\n          delete component.___keyedElements[key];\n        }\n      }\n    }\n\n    var curChild = node.firstChild;\n    while (curChild && curChild !== node.endNode) {\n      destroyNodeRecursive(curChild, component);\n      curChild = curChild.nextSibling;\n    }\n  }\n}\n\nfunction nextComponentId() {\n  // Each component will get an ID that is unique across all loaded\n  // marko runtimes. This allows multiple instances of marko to be\n  // loaded in the same window and they should all place nice\n  // together\n  return \"c\" + markoUID.i++;\n}\n\nfunction nextComponentIdProvider() {\n  return nextComponentId;\n}\n\nfunction attachBubblingEvent(\n  componentDef,\n  handlerMethodName,\n  isOnce,\n  extraArgs\n) {\n  if (handlerMethodName) {\n    var componentId = componentDef.id;\n    if (extraArgs) {\n      return [handlerMethodName, componentId, isOnce, extraArgs];\n    } else {\n      return [handlerMethodName, componentId, isOnce];\n    }\n  }\n}\n\nfunction getMarkoPropsFromEl(el) {\n  var vElement = vElementsByDOMNode.get(el);\n  var virtualProps;\n\n  if (vElement) {\n    virtualProps = vElement.___properties;\n  } else {\n    virtualProps = vPropsByDOMNode.get(el);\n    if (!virtualProps) {\n      virtualProps = el.getAttribute(\"data-marko\");\n      vPropsByDOMNode.set(\n        el,\n        (virtualProps = virtualProps ? JSON.parse(virtualProps) : EMPTY_OBJECT)\n      );\n    }\n  }\n\n  return virtualProps;\n}\n\nfunction normalizeComponentKey(key, parentId) {\n  if (key[0] === \"#\") {\n    key = key.replace(\"#\" + parentId + \"-\", \"\");\n  }\n  return key;\n}\n\nfunction addComponentRootToKeyedElements(\n  keyedElements,\n  key,\n  rootNode,\n  componentId\n) {\n  if (/\\[\\]$/.test(key)) {\n    var repeatedElementsForKey = (keyedElements[key] =\n      keyedElements[key] || {});\n    repeatedElementsForKey[componentId] = rootNode;\n  } else {\n    keyedElements[key] = rootNode;\n  }\n}\n\n// eslint-disable-next-line no-constant-condition\nif (\"MARKO_DEBUG\") {\n  var warnNodeRemoved = function(event) {\n    var fragment = event.target.fragment;\n    if (fragment) {\n      var baseError = new Error(\n        \"Fragment boundary marker removed.  This will cause an error when the fragment is updated.\"\n      );\n      fragment.___markersRemovedError = function(message) {\n        var error = new Error(message + \" Boundary markers missing.\");\n\n        baseError.stack = baseError.stack.replace(/.*warnNodeRemoved.*\\n/, \"\");\n\n        // eslint-disable-next-line no-console\n        console.warn(baseError);\n        return error;\n      };\n    }\n  };\n  exports.___startDOMManipulationWarning = function() {\n    document.addEventListener(\"DOMNodeRemoved\", warnNodeRemoved);\n  };\n  exports.___stopDOMManipulationWarning = function() {\n    document.removeEventListener(\"DOMNodeRemoved\", warnNodeRemoved);\n  };\n}\n\nexports.___runtimeId = runtimeId;\nexports.___componentLookup = componentLookup;\nexports.___getComponentForEl = getComponentForEl;\nexports.___destroyComponentForNode = destroyComponentForNode;\nexports.___destroyNodeRecursive = destroyNodeRecursive;\nexports.___nextComponentIdProvider = nextComponentIdProvider;\nexports.___attachBubblingEvent = attachBubblingEvent;\nexports.___getMarkoPropsFromEl = getMarkoPropsFromEl;\nexports.___addComponentRootToKeyedElements = addComponentRootToKeyedElements;\nexports.___normalizeComponentKey = normalizeComponentKey;\n","var actualCreateOut;\n\nfunction setCreateOut(createOutFunc) {\n  actualCreateOut = createOutFunc;\n}\n\nfunction createOut(globalData) {\n  return actualCreateOut(globalData);\n}\n\ncreateOut.___setCreateOut = setCreateOut;\n\nmodule.exports = createOut;\n","var extend = require(\"raptor-util/extend\");\nvar componentsUtil = require(\"./components/util\");\nvar destroyComponentForNode = componentsUtil.___destroyComponentForNode;\nvar destroyNodeRecursive = componentsUtil.___destroyNodeRecursive;\nvar helpers = require(\"./vdom/morphdom/helpers\");\n\nvar insertBefore = helpers.___insertBefore;\nvar insertAfter = helpers.___insertAfter;\nvar removeChild = helpers.___removeChild;\n\nfunction resolveEl(el) {\n  if (typeof el == \"string\") {\n    var elId = el;\n    el = document.getElementById(elId);\n    if (!el) {\n      throw Error(\"Not found: \" + elId);\n    }\n  }\n  return el;\n}\n\nfunction beforeRemove(referenceEl) {\n  destroyNodeRecursive(referenceEl);\n  destroyComponentForNode(referenceEl);\n}\n\nmodule.exports = function(target, getEl, afterInsert) {\n  extend(target, {\n    appendTo: function(referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n      insertBefore(el, null, referenceEl);\n      return afterInsert(this, referenceEl);\n    },\n    prependTo: function(referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n      insertBefore(el, referenceEl.firstChild || null, referenceEl);\n      return afterInsert(this, referenceEl);\n    },\n    replace: function(referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n      beforeRemove(referenceEl);\n      insertBefore(el, referenceEl, referenceEl.parentNode);\n      removeChild(referenceEl);\n      return afterInsert(this, referenceEl);\n    },\n    replaceChildrenOf: function(referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n\n      var curChild = referenceEl.firstChild;\n      while (curChild) {\n        var nextSibling = curChild.nextSibling; // Just in case the DOM changes while removing\n        beforeRemove(curChild);\n        curChild = nextSibling;\n      }\n\n      referenceEl.innerHTML = \"\";\n      insertBefore(el, null, referenceEl);\n      return afterInsert(this, referenceEl);\n    },\n    insertBefore: function(referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n      insertBefore(el, referenceEl, referenceEl.parentNode);\n      return afterInsert(this, referenceEl);\n    },\n    insertAfter: function(referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n      insertAfter(el, referenceEl, referenceEl.parentNode);\n      return afterInsert(this, referenceEl);\n    }\n  });\n};\n","var promise;\nmodule.exports =\n  typeof queueMicrotask === \"function\"\n    ? queueMicrotask\n    : typeof Promise === \"function\" && (promise = Promise.resolve())\n    ? function(cb) {\n        promise.then(cb).catch(rethrow);\n      }\n    : setTimeout;\nfunction rethrow(err) {\n  setTimeout(function() {\n    throw err;\n  });\n}\n","module.exports =\n  global.setImmediate ||\n  (function() {\n    var queue = [];\n    var win = window;\n    var msg = \"\" + Math.random();\n    win.addEventListener(\"message\", function(ev) {\n      if (ev.data === msg) {\n        var callbacks = queue;\n        queue = [];\n        for (var i = 0; i < callbacks.length; i++) {\n          callbacks[i]();\n        }\n      }\n    });\n    return function(callback) {\n      if (queue.push(callback) === 1) {\n        win.postMessage(msg, \"*\");\n      }\n    };\n  })();\n","var VNode = require(\"./VNode\");\nvar inherit = require(\"raptor-util/inherit\");\n\nfunction VComponent(component, key, ownerComponent, preserve) {\n  this.___VNode(null /* childCount */, ownerComponent);\n  this.___key = key;\n  this.___component = component;\n  this.___preserve = preserve;\n}\n\nVComponent.prototype = {\n  ___nodeType: 2\n};\n\ninherit(VComponent, VNode);\n\nmodule.exports = VComponent;\n","var VNode = require(\"./VNode\");\nvar inherit = require(\"raptor-util/inherit\");\nvar extend = require(\"raptor-util/extend\");\n\nfunction VDocumentFragmentClone(other) {\n  extend(this, other);\n  this.___parentNode = null;\n  this.___nextSiblingInternal = null;\n}\n\nfunction VDocumentFragment(out) {\n  this.___VNode(null /* childCount */);\n  this.___out = out;\n}\n\nVDocumentFragment.prototype = {\n  ___nodeType: 11,\n\n  ___DocumentFragment: true,\n\n  ___cloneNode: function() {\n    return new VDocumentFragmentClone(this);\n  },\n\n  ___actualize: function(doc) {\n    return doc.createDocumentFragment();\n  }\n};\n\ninherit(VDocumentFragment, VNode);\n\nVDocumentFragmentClone.prototype = VDocumentFragment.prototype;\n\nmodule.exports = VDocumentFragment;\n","/* jshint newcap:false */\n\nvar domData = require(\"../components/dom-data\");\nvar componentsUtil = require(\"../components/util\");\nvar vElementByDOMNode = domData.___vElementByDOMNode;\nvar VNode = require(\"./VNode\");\nvar inherit = require(\"raptor-util/inherit\");\nvar ATTR_XLINK_HREF = \"xlink:href\";\nvar xmlnsRegExp = /^xmlns(:|$)/;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar NS_XLINK = \"http://www.w3.org/1999/xlink\";\nvar NS_HTML = \"http://www.w3.org/1999/xhtml\";\nvar NS_MATH = \"http://www.w3.org/1998/Math/MathML\";\nvar NS_SVG = \"http://www.w3.org/2000/svg\";\nvar DEFAULT_NS = {\n  svg: NS_SVG,\n  math: NS_MATH\n};\n\nvar FLAG_SIMPLE_ATTRS = 1;\nvar FLAG_CUSTOM_ELEMENT = 2;\nvar FLAG_SPREAD_ATTRS = 4;\n\nvar defineProperty = Object.defineProperty;\n\nvar ATTR_HREF = \"href\";\nvar EMPTY_OBJECT = Object.freeze({});\n\nfunction convertAttrValue(type, value) {\n  if (value === true) {\n    return \"\";\n  } else if (type == \"object\") {\n    if (value instanceof RegExp) {\n      return value.source;\n    }\n  }\n\n  return value + \"\";\n}\n\nfunction assign(a, b) {\n  for (var key in b) {\n    if (hasOwnProperty.call(b, key)) {\n      a[key] = b[key];\n    }\n  }\n}\n\nfunction setAttribute(el, namespaceURI, name, value) {\n  if (namespaceURI === null) {\n    el.setAttribute(name, value);\n  } else {\n    el.setAttributeNS(namespaceURI, name, value);\n  }\n}\n\nfunction removeAttribute(el, namespaceURI, name) {\n  if (namespaceURI === null) {\n    el.removeAttribute(name);\n  } else {\n    el.removeAttributeNS(namespaceURI, name);\n  }\n}\n\nfunction VElementClone(other) {\n  this.___firstChildInternal = other.___firstChildInternal;\n  this.___parentNode = null;\n  this.___nextSiblingInternal = null;\n\n  this.___key = other.___key;\n  this.___attributes = other.___attributes;\n  this.___properties = other.___properties;\n  this.___nodeName = other.___nodeName;\n  this.___flags = other.___flags;\n  this.___valueInternal = other.___valueInternal;\n  this.___constId = other.___constId;\n}\n\nfunction VElement(\n  tagName,\n  attrs,\n  key,\n  ownerComponent,\n  childCount,\n  flags,\n  props\n) {\n  this.___VNode(childCount, ownerComponent);\n\n  var constId;\n\n  if (props) {\n    constId = props.i;\n  }\n\n  this.___key = key;\n  this.___flags = flags || 0;\n  this.___attributes = attrs || EMPTY_OBJECT;\n  this.___properties = props || EMPTY_OBJECT;\n  this.___nodeName = tagName;\n  this.___valueInternal = null;\n  this.___constId = constId;\n  this.___preserve = false;\n  this.___preserveBody = false;\n}\n\nVElement.prototype = {\n  ___nodeType: 1,\n\n  ___cloneNode: function() {\n    return new VElementClone(this);\n  },\n\n  /**\n   * Shorthand method for creating and appending an HTML element\n   *\n   * @param  {String} tagName    The tag name (e.g. \"div\")\n   * @param  {int|null} attrCount  The number of attributes (or `null` if not known)\n   * @param  {int|null} childCount The number of child nodes (or `null` if not known)\n   */\n  e: function(tagName, attrs, key, ownerComponent, childCount, flags, props) {\n    var child = this.___appendChild(\n      new VElement(\n        tagName,\n        attrs,\n        key,\n        ownerComponent,\n        childCount,\n        flags,\n        props\n      )\n    );\n\n    if (childCount === 0) {\n      return this.___finishChild();\n    } else {\n      return child;\n    }\n  },\n\n  /**\n   * Shorthand method for creating and appending a static node. The provided node is automatically cloned\n   * using a shallow clone since it will be mutated as a result of setting `nextSibling` and `parentNode`.\n   *\n   * @param  {String} value The value for the new Comment node\n   */\n  n: function(node, ownerComponent) {\n    node = node.___cloneNode();\n    node.___ownerComponent = ownerComponent;\n    this.___appendChild(node);\n    return this.___finishChild();\n  },\n\n  ___actualize: function(doc, parentNamespaceURI) {\n    var tagName = this.___nodeName;\n    var attributes = this.___attributes;\n    var namespaceURI = DEFAULT_NS[tagName] || parentNamespaceURI || NS_HTML;\n\n    var flags = this.___flags;\n    var el = doc.createElementNS(namespaceURI, tagName);\n\n    if (flags & FLAG_CUSTOM_ELEMENT) {\n      assign(el, attributes);\n    } else {\n      for (var attrName in attributes) {\n        var attrValue = attributes[attrName];\n\n        if (attrValue !== false && attrValue != null) {\n          var type = typeof attrValue;\n\n          if (type !== \"string\") {\n            // Special attributes aren't copied to the real DOM. They are only\n            // kept in the virtual attributes map\n            attrValue = convertAttrValue(type, attrValue);\n          }\n\n          if (attrName == ATTR_XLINK_HREF) {\n            setAttribute(el, NS_XLINK, ATTR_HREF, attrValue);\n          } else {\n            el.setAttribute(attrName, attrValue);\n          }\n        }\n      }\n\n      if (tagName === \"textarea\") {\n        el.defaultValue = el.value = this.___value;\n      }\n    }\n\n    vElementByDOMNode.set(el, this);\n\n    return el;\n  },\n\n  ___hasAttribute: function(name) {\n    // We don't care about the namespaces since the there\n    // is no chance that attributes with the same name will have\n    // different namespaces\n    var value = this.___attributes[name];\n    return value != null && value !== false;\n  }\n};\n\ninherit(VElement, VNode);\n\nvar proto = (VElementClone.prototype = VElement.prototype);\n\n[\"checked\", \"selected\", \"disabled\"].forEach(function(name) {\n  defineProperty(proto, name, {\n    get: function() {\n      var value = this.___attributes[name];\n      return value !== false && value != null;\n    }\n  });\n});\n\ndefineProperty(proto, \"___value\", {\n  get: function() {\n    var value = this.___valueInternal;\n    if (value == null) {\n      value = this.___attributes.value;\n    }\n    return value != null && value !== false\n      ? value + \"\"\n      : this.___attributes.type === \"checkbox\" ||\n        this.___attributes.type === \"radio\"\n      ? \"on\"\n      : \"\";\n  }\n});\n\nVElement.___removePreservedAttributes = function(attrs) {\n  // By default this static method is a no-op, but if there are any\n  // compiled components that have \"no-update\" attributes then\n  // `preserve-attrs.js` will be imported and this method will be replaced\n  // with a method that actually does something\n  return attrs;\n};\n\nfunction virtualizeElement(node, virtualizeChildNodes, ownerComponent) {\n  var attributes = node.attributes;\n  var attrCount = attributes.length;\n\n  var attrs = null;\n  var props = null;\n\n  if (attrCount) {\n    attrs = {};\n    for (var i = 0; i < attrCount; i++) {\n      var attr = attributes[i];\n      var attrName = attr.name;\n      if (!xmlnsRegExp.test(attrName)) {\n        if (attrName === \"data-marko\") {\n          props = componentsUtil.___getMarkoPropsFromEl(node);\n        } else if (attr.namespaceURI === NS_XLINK) {\n          attrs[ATTR_XLINK_HREF] = attr.value;\n        } else {\n          attrs[attrName] = attr.value;\n        }\n      }\n    }\n  }\n\n  var tagName = node.nodeName;\n\n  if (node.namespaceURI === NS_HTML) {\n    tagName = tagName.toLowerCase();\n  }\n\n  var vdomEl = new VElement(\n    tagName,\n    attrs,\n    null /*key*/,\n    ownerComponent,\n    0 /*child count*/,\n    0 /*flags*/,\n    props\n  );\n\n  if (vdomEl.___nodeName === \"textarea\") {\n    vdomEl.___valueInternal = node.value;\n  } else if (virtualizeChildNodes) {\n    virtualizeChildNodes(node, vdomEl, ownerComponent);\n  }\n\n  return vdomEl;\n}\n\nVElement.___virtualize = virtualizeElement;\n\nVElement.___morphAttrs = function(fromEl, vFromEl, toEl) {\n  var removePreservedAttributes = VElement.___removePreservedAttributes;\n\n  var fromFlags = vFromEl.___flags;\n  var toFlags = toEl.___flags;\n\n  vElementByDOMNode.set(fromEl, toEl);\n\n  var attrs = toEl.___attributes;\n  var props = toEl.___properties;\n\n  if (toFlags & FLAG_CUSTOM_ELEMENT) {\n    return assign(fromEl, attrs);\n  }\n\n  var attrName;\n\n  // We use expando properties to associate the previous HTML\n  // attributes provided as part of the VDOM node with the\n  // real VElement DOM node. When diffing attributes,\n  // we only use our internal representation of the attributes.\n  // When diffing for the first time it's possible that the\n  // real VElement node will not have the expando property\n  // so we build the attribute map from the expando property\n\n  var oldAttrs = vFromEl.___attributes;\n\n  if (oldAttrs) {\n    if (oldAttrs === attrs) {\n      // For constant attributes the same object will be provided\n      // every render and we can use that to our advantage to\n      // not waste time diffing a constant, immutable attribute\n      // map.\n      return;\n    } else {\n      oldAttrs = removePreservedAttributes(oldAttrs, props);\n    }\n  }\n\n  var attrValue;\n\n  if (toFlags & FLAG_SIMPLE_ATTRS && fromFlags & FLAG_SIMPLE_ATTRS) {\n    if (oldAttrs[\"class\"] !== (attrValue = attrs[\"class\"])) {\n      fromEl.className = attrValue;\n    }\n    if (oldAttrs.id !== (attrValue = attrs.id)) {\n      fromEl.id = attrValue;\n    }\n    if (oldAttrs.style !== (attrValue = attrs.style)) {\n      fromEl.style.cssText = attrValue;\n    }\n    return;\n  }\n\n  // In some cases we only want to set an attribute value for the first\n  // render or we don't want certain attributes to be touched. To support\n  // that use case we delete out all of the preserved attributes\n  // so it's as if they never existed.\n  attrs = removePreservedAttributes(attrs, props, true);\n\n  var namespaceURI;\n\n  // Loop over all of the attributes in the attribute map and compare\n  // them to the value in the old map. However, if the value is\n  // null/undefined/false then we want to remove the attribute\n  for (attrName in attrs) {\n    attrValue = attrs[attrName];\n    namespaceURI = null;\n\n    if (attrName === ATTR_XLINK_HREF) {\n      namespaceURI = NS_XLINK;\n      attrName = ATTR_HREF;\n    }\n\n    if (attrValue == null || attrValue === false) {\n      removeAttribute(fromEl, namespaceURI, attrName);\n    } else if (oldAttrs[attrName] !== attrValue) {\n      var type = typeof attrValue;\n\n      if (type !== \"string\") {\n        attrValue = convertAttrValue(type, attrValue);\n      }\n\n      setAttribute(fromEl, namespaceURI, attrName, attrValue);\n    }\n  }\n\n  // If there are any old attributes that are not in the new set of attributes\n  // then we need to remove those attributes from the target node\n  //\n  // NOTE: We can skip this if the the element is keyed and didn't have spread attributes\n  //       because we know we already processed all of the attributes for\n  //       both the target and original element since target VElement nodes will\n  //       have all attributes declared. However, we can only skip if the node\n  //       was not a virtualized node (i.e., a node that was not rendered by a\n  //       Marko template, but rather a node that was created from an HTML\n  //       string or a real DOM node).\n  if (toEl.___key === null || fromFlags & FLAG_SPREAD_ATTRS) {\n    for (attrName in oldAttrs) {\n      if (!(attrName in attrs)) {\n        if (attrName === ATTR_XLINK_HREF) {\n          fromEl.removeAttributeNS(ATTR_XLINK_HREF, ATTR_HREF);\n        } else {\n          fromEl.removeAttribute(attrName);\n        }\n      }\n    }\n  }\n};\n\nmodule.exports = VElement;\n","var domData = require(\"../components/dom-data\");\nvar keysByDOMNode = domData.___keyByDOMNode;\nvar vElementByDOMNode = domData.___vElementByDOMNode;\nvar VNode = require(\"./VNode\");\nvar inherit = require(\"raptor-util/inherit\");\nvar createFragmentNode = require(\"./morphdom/fragment\").___createFragmentNode;\n\nfunction VFragment(key, ownerComponent, preserve) {\n  this.___VNode(null /* childCount */, ownerComponent);\n  this.___key = key;\n  this.___preserve = preserve;\n}\n\nVFragment.prototype = {\n  ___nodeType: 12,\n  ___actualize: function() {\n    var fragment = createFragmentNode();\n    keysByDOMNode.set(fragment, this.___key);\n    vElementByDOMNode.set(fragment, this);\n    return fragment;\n  }\n};\n\ninherit(VFragment, VNode);\n\nmodule.exports = VFragment;\n","/* jshint newcap:false */\nfunction VNode() {}\n\nVNode.prototype = {\n  ___VNode: function(finalChildCount, ownerComponent) {\n    this.___finalChildCount = finalChildCount;\n    this.___childCount = 0;\n    this.___firstChildInternal = null;\n    this.___lastChild = null;\n    this.___parentNode = null;\n    this.___nextSiblingInternal = null;\n    this.___ownerComponent = ownerComponent;\n  },\n\n  get ___firstChild() {\n    var firstChild = this.___firstChildInternal;\n\n    if (firstChild && firstChild.___DocumentFragment) {\n      var nestedFirstChild = firstChild.___firstChild;\n      // The first child is a DocumentFragment node.\n      // If the DocumentFragment node has a first child then we will return that.\n      // Otherwise, the DocumentFragment node is not *really* the first child and\n      // we need to skip to its next sibling\n      return nestedFirstChild || firstChild.___nextSibling;\n    }\n\n    return firstChild;\n  },\n\n  get ___nextSibling() {\n    var nextSibling = this.___nextSiblingInternal;\n\n    if (nextSibling) {\n      if (nextSibling.___DocumentFragment) {\n        var firstChild = nextSibling.___firstChild;\n        return firstChild || nextSibling.___nextSibling;\n      }\n    } else {\n      var parentNode = this.___parentNode;\n      if (parentNode && parentNode.___DocumentFragment) {\n        return parentNode.___nextSibling;\n      }\n    }\n\n    return nextSibling;\n  },\n\n  ___appendChild: function(child) {\n    this.___childCount++;\n\n    if (this.___nodeName === \"textarea\") {\n      if (child.___Text) {\n        var childValue = child.___nodeValue;\n        this.___valueInternal = (this.___valueInternal || \"\") + childValue;\n      } else if (child.___preserve || child.___preserveBody) {\n        this.___preserveTextAreaValue = true;\n      } else {\n        throw TypeError();\n      }\n    } else {\n      var lastChild = this.___lastChild;\n\n      child.___parentNode = this;\n\n      if (lastChild) {\n        lastChild.___nextSiblingInternal = child;\n      } else {\n        this.___firstChildInternal = child;\n      }\n\n      this.___lastChild = child;\n    }\n\n    return child;\n  },\n\n  ___finishChild: function finishChild() {\n    if (this.___childCount === this.___finalChildCount && this.___parentNode) {\n      return this.___parentNode.___finishChild();\n    } else {\n      return this;\n    }\n  }\n\n  // ,toJSON: function() {\n  //     var clone = Object.assign({\n  //         nodeType: this.nodeType\n  //     }, this);\n  //\n  //     for (var k in clone) {\n  //         if (k.startsWith('_')) {\n  //             delete clone[k];\n  //         }\n  //     }\n  //     delete clone._nextSibling;\n  //     delete clone._lastChild;\n  //     delete clone.parentNode;\n  //     return clone;\n  // }\n};\n\nmodule.exports = VNode;\n","var VNode = require(\"./VNode\");\nvar inherit = require(\"raptor-util/inherit\");\n\nfunction VText(value, ownerComponent) {\n  this.___VNode(-1 /* no children */, ownerComponent);\n  this.___nodeValue = value;\n}\n\nVText.prototype = {\n  ___Text: true,\n\n  ___nodeType: 3,\n\n  ___actualize: function(doc) {\n    return doc.createTextNode(this.___nodeValue);\n  },\n\n  ___cloneNode: function() {\n    return new VText(this.___nodeValue);\n  }\n};\n\ninherit(VText, VNode);\n\nmodule.exports = VText;\n","var helpers = require(\"./helpers\");\nvar insertBefore = helpers.___insertBefore;\n\nvar fragmentPrototype = {\n  nodeType: 12,\n  get firstChild() {\n    var firstChild = this.startNode.nextSibling;\n    return firstChild === this.endNode ? undefined : firstChild;\n  },\n  get lastChild() {\n    var lastChild = this.endNode.previousSibling;\n    return lastChild === this.startNode ? undefined : lastChild;\n  },\n  get parentNode() {\n    var parentNode = this.startNode.parentNode;\n    return parentNode === this.detachedContainer ? undefined : parentNode;\n  },\n  get namespaceURI() {\n    return this.startNode.parentNode.namespaceURI;\n  },\n  get nextSibling() {\n    return this.endNode.nextSibling;\n  },\n  get nodes() {\n    // eslint-disable-next-line no-constant-condition\n    if (\"MARKO_DEBUG\") {\n      if (this.___markersRemovedError) {\n        throw this.___markersRemovedError(\"Cannot get fragment nodes.\");\n      }\n    }\n    var nodes = [];\n    var current = this.startNode;\n    while (current !== this.endNode) {\n      nodes.push(current);\n      current = current.nextSibling;\n    }\n    nodes.push(current);\n    return nodes;\n  },\n  insertBefore: function(newChildNode, referenceNode) {\n    var actualReference = referenceNode == null ? this.endNode : referenceNode;\n    return insertBefore(\n      newChildNode,\n      actualReference,\n      this.startNode.parentNode\n    );\n  },\n  insertInto: function(newParentNode, referenceNode) {\n    this.nodes.forEach(function(node) {\n      insertBefore(node, referenceNode, newParentNode);\n    }, this);\n    return this;\n  },\n  remove: function() {\n    this.nodes.forEach(function(node) {\n      this.detachedContainer.appendChild(node);\n    }, this);\n  }\n};\n\nfunction createFragmentNode(startNode, nextNode, parentNode) {\n  var fragment = Object.create(fragmentPrototype);\n  var isRoot = startNode && startNode.ownerDocument === startNode.parentNode;\n  fragment.startNode = isRoot\n    ? document.createComment(\"\")\n    : document.createTextNode(\"\");\n  fragment.endNode = isRoot\n    ? document.createComment(\"\")\n    : document.createTextNode(\"\");\n  fragment.startNode.fragment = fragment;\n  fragment.endNode.fragment = fragment;\n  var detachedContainer = (fragment.detachedContainer = document.createDocumentFragment());\n  parentNode =\n    parentNode || (startNode && startNode.parentNode) || detachedContainer;\n  insertBefore(fragment.startNode, startNode, parentNode);\n  insertBefore(fragment.endNode, nextNode, parentNode);\n  return fragment;\n}\n\nfunction beginFragmentNode(startNode, parentNode) {\n  var fragment = createFragmentNode(startNode, null, parentNode);\n  fragment.___finishFragment = function(nextNode) {\n    fragment.___finishFragment = null;\n    insertBefore(\n      fragment.endNode,\n      nextNode,\n      parentNode || startNode.parentNode\n    );\n  };\n  return fragment;\n}\n\nexports.___createFragmentNode = createFragmentNode;\nexports.___beginFragmentNode = beginFragmentNode;\n","function insertBefore(node, referenceNode, parentNode) {\n  if (node.insertInto) {\n    return node.insertInto(parentNode, referenceNode);\n  }\n  return parentNode.insertBefore(\n    node,\n    (referenceNode && referenceNode.startNode) || referenceNode\n  );\n}\n\nfunction insertAfter(node, referenceNode, parentNode) {\n  return insertBefore(\n    node,\n    referenceNode && referenceNode.nextSibling,\n    parentNode\n  );\n}\n\nfunction nextSibling(node) {\n  var next = node.nextSibling;\n  var fragment = next && next.fragment;\n  if (fragment) {\n    return next === fragment.startNode ? fragment : null;\n  }\n  return next;\n}\n\nfunction firstChild(node) {\n  var next = node.firstChild;\n  return (next && next.fragment) || next;\n}\n\nfunction removeChild(node) {\n  if (node.remove) node.remove();\n  else node.parentNode.removeChild(node);\n}\n\nexports.___insertBefore = insertBefore;\nexports.___insertAfter = insertAfter;\nexports.___nextSibling = nextSibling;\nexports.___firstChild = firstChild;\nexports.___removeChild = removeChild;\n","\"use strict\";\nvar specialElHandlers = require(\"./specialElHandlers\");\nvar KeySequence = require(\"../../components/KeySequence\");\nvar componentsUtil = require(\"../../components/util\");\nvar existingComponentLookup = componentsUtil.___componentLookup;\nvar destroyNodeRecursive = componentsUtil.___destroyNodeRecursive;\nvar addComponentRootToKeyedElements =\n  componentsUtil.___addComponentRootToKeyedElements;\nvar normalizeComponentKey = componentsUtil.___normalizeComponentKey;\nvar VElement = require(\"../vdom\").___VElement;\nvar virtualizeElement = VElement.___virtualize;\nvar morphAttrs = VElement.___morphAttrs;\nvar eventDelegation = require(\"../../components/event-delegation\");\nvar fragment = require(\"./fragment\");\nvar helpers = require(\"./helpers\");\nvar domData = require(\"../../components/dom-data\");\nvar keysByDOMNode = domData.___keyByDOMNode;\nvar componentByDOMNode = domData.___componentByDOMNode;\nvar vElementByDOMNode = domData.___vElementByDOMNode;\nvar detachedByDOMNode = domData.___detachedByDOMNode;\n\nvar insertBefore = helpers.___insertBefore;\nvar insertAfter = helpers.___insertAfter;\nvar nextSibling = helpers.___nextSibling;\nvar firstChild = helpers.___firstChild;\nvar removeChild = helpers.___removeChild;\nvar createFragmentNode = fragment.___createFragmentNode;\nvar beginFragmentNode = fragment.___beginFragmentNode;\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar COMPONENT_NODE = 2;\nvar FRAGMENT_NODE = 12;\nvar DOCTYPE_NODE = 10;\n\n// var FLAG_SIMPLE_ATTRS = 1;\n// var FLAG_CUSTOM_ELEMENT = 2;\n// var FLAG_SPREAD_ATTRS = 4;\n\nfunction isAutoKey(key) {\n  return key[0] !== \"@\";\n}\n\nfunction compareNodeNames(fromEl, toEl) {\n  return fromEl.___nodeName === toEl.___nodeName;\n}\n\nfunction caseInsensitiveCompare(a, b) {\n  return a.toLowerCase() === b.toLowerCase();\n}\n\nfunction onNodeAdded(node, componentsContext) {\n  if (node.nodeType === ELEMENT_NODE) {\n    eventDelegation.___handleNodeAttach(node, componentsContext);\n  }\n}\n\nfunction morphdom(fromNode, toNode, doc, componentsContext) {\n  var globalComponentsContext;\n  var isHydrate = false;\n  var keySequences = Object.create(null);\n\n  if (componentsContext) {\n    globalComponentsContext = componentsContext.___globalContext;\n    isHydrate = globalComponentsContext.___isHydrate;\n  }\n\n  function insertVirtualNodeBefore(\n    vNode,\n    key,\n    referenceEl,\n    parentEl,\n    ownerComponent,\n    parentComponent\n  ) {\n    var realNode = vNode.___actualize(doc, parentEl.namespaceURI);\n    insertBefore(realNode, referenceEl, parentEl);\n\n    if (\n      vNode.___nodeType === ELEMENT_NODE ||\n      vNode.___nodeType === FRAGMENT_NODE\n    ) {\n      if (key) {\n        keysByDOMNode.set(realNode, key);\n        (isAutoKey(key) ? parentComponent : ownerComponent).___keyedElements[\n          key\n        ] = realNode;\n      }\n\n      if (vNode.___nodeName !== \"textarea\") {\n        morphChildren(realNode, vNode, parentComponent);\n      }\n\n      onNodeAdded(realNode, componentsContext);\n    }\n  }\n\n  function insertVirtualComponentBefore(\n    vComponent,\n    referenceNode,\n    referenceNodeParentEl,\n    component,\n    key,\n    ownerComponent,\n    parentComponent\n  ) {\n    var rootNode = (component.___rootNode = insertBefore(\n      createFragmentNode(),\n      referenceNode,\n      referenceNodeParentEl\n    ));\n    componentByDOMNode.set(rootNode, component);\n\n    if (key && ownerComponent) {\n      key = normalizeComponentKey(key, parentComponent.id);\n      addComponentRootToKeyedElements(\n        ownerComponent.___keyedElements,\n        key,\n        rootNode,\n        component.id\n      );\n      keysByDOMNode.set(rootNode, key);\n    }\n\n    morphComponent(component, vComponent);\n  }\n\n  function morphComponent(component, vComponent) {\n    morphChildren(component.___rootNode, vComponent, component);\n  }\n\n  var detachedNodes = [];\n\n  function detachNode(node, parentNode, ownerComponent) {\n    if (node.nodeType === ELEMENT_NODE || node.nodeType === FRAGMENT_NODE) {\n      detachedNodes.push(node);\n      detachedByDOMNode.set(node, ownerComponent || true);\n    } else {\n      destroyNodeRecursive(node);\n      removeChild(node);\n    }\n  }\n\n  function destroyComponent(component) {\n    component.destroy();\n  }\n\n  function morphChildren(fromNode, toNode, parentComponent) {\n    var curFromNodeChild = firstChild(fromNode);\n    var curToNodeChild = toNode.___firstChild;\n\n    var curToNodeKey;\n    var curFromNodeKey;\n    var curToNodeType;\n\n    var fromNextSibling;\n    var toNextSibling;\n    var matchingFromEl;\n    var matchingFromComponent;\n    var curVFromNodeChild;\n    var fromComponent;\n\n    outer: while (curToNodeChild) {\n      toNextSibling = curToNodeChild.___nextSibling;\n      curToNodeType = curToNodeChild.___nodeType;\n      curToNodeKey = curToNodeChild.___key;\n\n      // Skip <!doctype>\n      if (curFromNodeChild && curFromNodeChild.nodeType === DOCTYPE_NODE) {\n        curFromNodeChild = nextSibling(curFromNodeChild);\n      }\n\n      var ownerComponent = curToNodeChild.___ownerComponent || parentComponent;\n      var referenceComponent;\n\n      if (curToNodeType === COMPONENT_NODE) {\n        var component = curToNodeChild.___component;\n        if (\n          (matchingFromComponent = existingComponentLookup[component.id]) ===\n          undefined\n        ) {\n          if (isHydrate === true) {\n            var rootNode = beginFragmentNode(curFromNodeChild, fromNode);\n            component.___rootNode = rootNode;\n            componentByDOMNode.set(rootNode, component);\n\n            if (ownerComponent && curToNodeKey) {\n              curToNodeKey = normalizeComponentKey(\n                curToNodeKey,\n                parentComponent.id\n              );\n              addComponentRootToKeyedElements(\n                ownerComponent.___keyedElements,\n                curToNodeKey,\n                rootNode,\n                component.id\n              );\n\n              keysByDOMNode.set(rootNode, curToNodeKey);\n            }\n\n            morphComponent(component, curToNodeChild);\n\n            curFromNodeChild = nextSibling(rootNode);\n          } else {\n            insertVirtualComponentBefore(\n              curToNodeChild,\n              curFromNodeChild,\n              fromNode,\n              component,\n              curToNodeKey,\n              ownerComponent,\n              parentComponent\n            );\n          }\n        } else {\n          if (matchingFromComponent.___rootNode !== curFromNodeChild) {\n            if (\n              curFromNodeChild &&\n              (fromComponent = componentByDOMNode.get(curFromNodeChild)) &&\n              globalComponentsContext.___renderedComponentsById[\n                fromComponent.id\n              ] === undefined\n            ) {\n              // The component associated with the current real DOM node was not rendered\n              // so we should just remove it out of the real DOM by destroying it\n              curFromNodeChild = nextSibling(fromComponent.___rootNode);\n              destroyComponent(fromComponent);\n              continue;\n            }\n\n            // We need to move the existing component into\n            // the correct location\n            insertBefore(\n              matchingFromComponent.___rootNode,\n              curFromNodeChild,\n              fromNode\n            );\n          } else {\n            curFromNodeChild =\n              curFromNodeChild && nextSibling(curFromNodeChild);\n          }\n\n          if (!curToNodeChild.___preserve) {\n            morphComponent(component, curToNodeChild);\n          }\n        }\n\n        curToNodeChild = toNextSibling;\n        continue;\n      } else if (curToNodeKey) {\n        curVFromNodeChild = undefined;\n        curFromNodeKey = undefined;\n        var curToNodeKeyOriginal = curToNodeKey;\n\n        if (isAutoKey(curToNodeKey)) {\n          if (ownerComponent !== parentComponent) {\n            curToNodeKey += \":\" + ownerComponent.id;\n          }\n          referenceComponent = parentComponent;\n        } else {\n          referenceComponent = ownerComponent;\n        }\n\n        // We have a keyed element. This is the fast path for matching\n        // up elements\n        curToNodeKey = (\n          keySequences[referenceComponent.id] ||\n          (keySequences[referenceComponent.id] = new KeySequence())\n        ).___nextKey(curToNodeKey);\n\n        if (curFromNodeChild) {\n          curFromNodeKey = keysByDOMNode.get(curFromNodeChild);\n          curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);\n          fromNextSibling = nextSibling(curFromNodeChild);\n        }\n\n        if (curFromNodeKey === curToNodeKey) {\n          // Elements line up. Now we just have to make sure they are compatible\n          if (!curToNodeChild.___preserve) {\n            // We just skip over the fromNode if it is preserved\n\n            if (compareNodeNames(curToNodeChild, curVFromNodeChild)) {\n              morphEl(\n                curFromNodeChild,\n                curVFromNodeChild,\n                curToNodeChild,\n                parentComponent\n              );\n            } else {\n              // Remove the old node\n              detachNode(curFromNodeChild, fromNode, ownerComponent);\n\n              // Incompatible nodes. Just move the target VNode into the DOM at this position\n              insertVirtualNodeBefore(\n                curToNodeChild,\n                curToNodeKey,\n                curFromNodeChild,\n                fromNode,\n                ownerComponent,\n                parentComponent\n              );\n            }\n          }\n        } else {\n          matchingFromEl = referenceComponent.___keyedElements[curToNodeKey];\n          if (\n            matchingFromEl === undefined ||\n            matchingFromEl === curFromNodeChild\n          ) {\n            if (isHydrate === true && curFromNodeChild) {\n              if (\n                curFromNodeChild.nodeType === ELEMENT_NODE &&\n                (curToNodeChild.___preserve ||\n                  caseInsensitiveCompare(\n                    curFromNodeChild.nodeName,\n                    curToNodeChild.___nodeName || \"\"\n                  ))\n              ) {\n                curVFromNodeChild = virtualizeElement(curFromNodeChild);\n                curVFromNodeChild.___nodeName = curToNodeChild.___nodeName;\n                keysByDOMNode.set(curFromNodeChild, curToNodeKey);\n                referenceComponent.___keyedElements[\n                  curToNodeKey\n                ] = curFromNodeChild;\n\n                if (curToNodeChild.___preserve) {\n                  vElementByDOMNode.set(curFromNodeChild, curVFromNodeChild);\n                } else {\n                  morphEl(\n                    curFromNodeChild,\n                    curVFromNodeChild,\n                    curToNodeChild,\n                    parentComponent\n                  );\n                }\n\n                curToNodeChild = toNextSibling;\n                curFromNodeChild = fromNextSibling;\n                continue;\n              } else if (\n                curToNodeChild.___nodeType === FRAGMENT_NODE &&\n                curFromNodeChild.nodeType === COMMENT_NODE\n              ) {\n                var content = curFromNodeChild.nodeValue;\n                if (content == \"F#\" + curToNodeKeyOriginal) {\n                  var endNode = curFromNodeChild.nextSibling;\n                  var depth = 0;\n                  var nodeValue;\n\n                  // eslint-disable-next-line no-constant-condition\n                  while (true) {\n                    if (endNode.nodeType === COMMENT_NODE) {\n                      nodeValue = endNode.nodeValue;\n                      if (nodeValue === \"F/\") {\n                        if (depth === 0) {\n                          break;\n                        } else {\n                          depth--;\n                        }\n                      } else if (nodeValue.indexOf(\"F#\") === 0) {\n                        depth++;\n                      }\n                    }\n                    endNode = endNode.nextSibling;\n                  }\n\n                  var fragment = createFragmentNode(\n                    curFromNodeChild,\n                    endNode.nextSibling,\n                    fromNode\n                  );\n                  keysByDOMNode.set(fragment, curToNodeKey);\n                  vElementByDOMNode.set(fragment, curToNodeChild);\n                  referenceComponent.___keyedElements[curToNodeKey] = fragment;\n                  removeChild(curFromNodeChild);\n                  removeChild(endNode);\n\n                  if (!curToNodeChild.___preserve) {\n                    morphChildren(fragment, curToNodeChild, parentComponent);\n                  }\n\n                  curToNodeChild = toNextSibling;\n                  curFromNodeChild = fragment.nextSibling;\n                  continue;\n                }\n              }\n            }\n\n            insertVirtualNodeBefore(\n              curToNodeChild,\n              curToNodeKey,\n              curFromNodeChild,\n              fromNode,\n              ownerComponent,\n              parentComponent\n            );\n            fromNextSibling = curFromNodeChild;\n          } else {\n            if (detachedByDOMNode.get(matchingFromEl) !== undefined) {\n              detachedByDOMNode.set(matchingFromEl, undefined);\n            }\n\n            if (!curToNodeChild.___preserve) {\n              curVFromNodeChild = vElementByDOMNode.get(matchingFromEl);\n\n              if (compareNodeNames(curVFromNodeChild, curToNodeChild)) {\n                if (fromNextSibling === matchingFromEl) {\n                  // Single element removal:\n                  // A <-> A\n                  // B <-> C <-- We are here\n                  // C     D\n                  // D\n                  //\n                  // Single element swap:\n                  // A <-> A\n                  // B <-> C <-- We are here\n                  // C     B\n\n                  if (\n                    toNextSibling &&\n                    toNextSibling.___key === curFromNodeKey\n                  ) {\n                    // Single element swap\n\n                    // We want to stay on the current real DOM node\n                    fromNextSibling = curFromNodeChild;\n\n                    // But move the matching element into place\n                    insertBefore(matchingFromEl, curFromNodeChild, fromNode);\n                  } else {\n                    // Single element removal\n\n                    // We need to remove the current real DOM node\n                    // and the matching real DOM node will fall into\n                    // place. We will continue diffing with next sibling\n                    // after the real DOM node that just fell into place\n                    fromNextSibling = nextSibling(fromNextSibling);\n\n                    if (curFromNodeChild) {\n                      detachNode(curFromNodeChild, fromNode, ownerComponent);\n                    }\n                  }\n                } else {\n                  // A <-> A\n                  // B <-> D <-- We are here\n                  // C\n                  // D\n\n                  // We need to move the matching node into place\n                  insertAfter(matchingFromEl, curFromNodeChild, fromNode);\n\n                  if (curFromNodeChild) {\n                    detachNode(curFromNodeChild, fromNode, ownerComponent);\n                  }\n                }\n\n                morphEl(\n                  matchingFromEl,\n                  curVFromNodeChild,\n                  curToNodeChild,\n                  parentComponent\n                );\n              } else {\n                insertVirtualNodeBefore(\n                  curToNodeChild,\n                  curToNodeKey,\n                  curFromNodeChild,\n                  fromNode,\n                  ownerComponent,\n                  parentComponent\n                );\n                detachNode(matchingFromEl, fromNode, ownerComponent);\n              }\n            } else {\n              // preserve the node\n              // but still we need to diff the current from node\n              insertBefore(matchingFromEl, curFromNodeChild, fromNode);\n              fromNextSibling = curFromNodeChild;\n            }\n          }\n        }\n\n        curToNodeChild = toNextSibling;\n        curFromNodeChild = fromNextSibling;\n        continue;\n      }\n\n      // The know the target node is not a VComponent node and we know\n      // it is also not a preserve node. Let's now match up the HTML\n      // element, text node, comment, etc.\n      while (curFromNodeChild) {\n        fromNextSibling = nextSibling(curFromNodeChild);\n\n        if ((fromComponent = componentByDOMNode.get(curFromNodeChild))) {\n          // The current \"to\" element is not associated with a component,\n          // but the current \"from\" element is associated with a component\n\n          // Even if we destroy the current component in the original\n          // DOM or not, we still need to skip over it since it is\n          // not compatible with the current \"to\" node\n          curFromNodeChild = fromNextSibling;\n\n          if (\n            !globalComponentsContext.___renderedComponentsById[fromComponent.id]\n          ) {\n            destroyComponent(fromComponent);\n          }\n\n          continue; // Move to the next \"from\" node\n        }\n\n        var curFromNodeType = curFromNodeChild.nodeType;\n\n        var isCompatible = undefined;\n\n        if (curFromNodeType === curToNodeType) {\n          if (curFromNodeType === ELEMENT_NODE) {\n            // Both nodes being compared are Element nodes\n            curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);\n            if (curVFromNodeChild === undefined) {\n              if (isHydrate === true) {\n                curVFromNodeChild = virtualizeElement(curFromNodeChild);\n\n                if (\n                  caseInsensitiveCompare(\n                    curVFromNodeChild.___nodeName,\n                    curToNodeChild.___nodeName\n                  )\n                ) {\n                  curVFromNodeChild.___nodeName = curToNodeChild.___nodeName;\n                }\n              } else {\n                // Skip over nodes that don't look like ours...\n                curFromNodeChild = fromNextSibling;\n                continue;\n              }\n            } else if ((curFromNodeKey = curVFromNodeChild.___key)) {\n              // We have a keyed element here but our target VDOM node\n              // is not keyed so this not doesn't belong\n              isCompatible = false;\n            }\n\n            isCompatible =\n              isCompatible !== false &&\n              compareNodeNames(curVFromNodeChild, curToNodeChild) === true;\n\n            if (isCompatible === true) {\n              // We found compatible DOM elements so transform\n              // the current \"from\" node to match the current\n              // target DOM node.\n              morphEl(\n                curFromNodeChild,\n                curVFromNodeChild,\n                curToNodeChild,\n                parentComponent\n              );\n            }\n          } else if (\n            curFromNodeType === TEXT_NODE ||\n            curFromNodeType === COMMENT_NODE\n          ) {\n            // Both nodes being compared are Text or Comment nodes\n            isCompatible = true;\n            // Simply update nodeValue on the original node to\n            // change the text value\n            if (curFromNodeChild.nodeValue !== curToNodeChild.___nodeValue) {\n              curFromNodeChild.nodeValue = curToNodeChild.___nodeValue;\n            }\n          }\n        }\n\n        if (isCompatible === true) {\n          // Advance both the \"to\" child and the \"from\" child since we found a match\n          curToNodeChild = toNextSibling;\n          curFromNodeChild = fromNextSibling;\n          continue outer;\n        }\n\n        detachNode(curFromNodeChild, fromNode, ownerComponent);\n        curFromNodeChild = fromNextSibling;\n      } // END: while (curFromNodeChild)\n\n      // If we got this far then we did not find a candidate match for\n      // our \"to node\" and we exhausted all of the children \"from\"\n      // nodes. Therefore, we will just append the current \"to\" node\n      // to the end\n      insertVirtualNodeBefore(\n        curToNodeChild,\n        curToNodeKey,\n        curFromNodeChild,\n        fromNode,\n        ownerComponent,\n        parentComponent\n      );\n\n      curToNodeChild = toNextSibling;\n      curFromNodeChild = fromNextSibling;\n    }\n\n    // We have processed all of the \"to nodes\".\n    if (fromNode.___finishFragment) {\n      // If we are in an unfinished fragment, we have reached the end of the nodes\n      // we were matching up and need to end the fragment\n      fromNode.___finishFragment(curFromNodeChild);\n    } else {\n      // If curFromNodeChild is non-null then we still have some from nodes\n      // left over that need to be removed\n      var fragmentBoundary =\n        fromNode.nodeType === FRAGMENT_NODE ? fromNode.endNode : null;\n\n      while (curFromNodeChild && curFromNodeChild !== fragmentBoundary) {\n        fromNextSibling = nextSibling(curFromNodeChild);\n\n        if ((fromComponent = componentByDOMNode.get(curFromNodeChild))) {\n          curFromNodeChild = fromNextSibling;\n          if (\n            !globalComponentsContext.___renderedComponentsById[fromComponent.id]\n          ) {\n            destroyComponent(fromComponent);\n          }\n          continue;\n        }\n\n        curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);\n        curFromNodeKey = keysByDOMNode.get(fromNode);\n\n        // For transcluded content, we need to check if the element belongs to a different component\n        // context than the current component and ensure it gets removed from its key index.\n        if (!curFromNodeKey || isAutoKey(curFromNodeKey)) {\n          referenceComponent = parentComponent;\n        } else {\n          referenceComponent =\n            curVFromNodeChild && curVFromNodeChild.___ownerComponent;\n        }\n\n        detachNode(curFromNodeChild, fromNode, referenceComponent);\n\n        curFromNodeChild = fromNextSibling;\n      }\n    }\n  }\n\n  function morphEl(fromEl, vFromEl, toEl, parentComponent) {\n    var nodeName = toEl.___nodeName;\n\n    var constId = toEl.___constId;\n    if (constId !== undefined && vFromEl.___constId === constId) {\n      return;\n    }\n\n    morphAttrs(fromEl, vFromEl, toEl);\n\n    if (toEl.___preserveBody) {\n      return;\n    }\n\n    if (nodeName !== \"textarea\") {\n      morphChildren(fromEl, toEl, parentComponent);\n    }\n\n    var specialElHandler = specialElHandlers[nodeName];\n    if (specialElHandler !== undefined) {\n      specialElHandler(fromEl, toEl);\n    }\n  } // END: morphEl(...)\n\n  // eslint-disable-next-line no-constant-condition\n  if (\"MARKO_DEBUG\") {\n    componentsUtil.___stopDOMManipulationWarning();\n  }\n\n  morphChildren(fromNode, toNode, toNode.___component);\n\n  detachedNodes.forEach(function(node) {\n    var detachedFromComponent = detachedByDOMNode.get(node);\n\n    if (detachedFromComponent !== undefined) {\n      detachedByDOMNode.set(node, undefined);\n\n      var componentToDestroy = componentByDOMNode.get(node);\n      if (componentToDestroy) {\n        componentToDestroy.destroy();\n      } else if (node.parentNode) {\n        destroyNodeRecursive(\n          node,\n          detachedFromComponent !== true && detachedFromComponent\n        );\n\n        if (eventDelegation.___handleNodeDetach(node) != false) {\n          removeChild(node);\n        }\n      }\n    }\n  });\n\n  // eslint-disable-next-line no-constant-condition\n  if (\"MARKO_DEBUG\") {\n    componentsUtil.___startDOMManipulationWarning();\n  }\n}\n\nmodule.exports = morphdom;\n","function syncBooleanAttrProp(fromEl, toEl, name) {\n  if (fromEl[name] !== toEl[name]) {\n    fromEl[name] = toEl[name];\n    if (fromEl[name]) {\n      fromEl.setAttribute(name, \"\");\n    } else {\n      fromEl.removeAttribute(name, \"\");\n    }\n  }\n}\n\nfunction forEachOption(el, fn, i) {\n  var curChild = el.___firstChild;\n\n  while (curChild) {\n    if (curChild.___nodeName === \"option\") {\n      fn(curChild, ++i);\n    } else {\n      i = forEachOption(curChild, fn, i);\n    }\n\n    curChild = curChild.___nextSibling;\n  }\n\n  return i;\n}\n\n// We use a JavaScript class to benefit from fast property lookup\nfunction SpecialElHandlers() {}\nSpecialElHandlers.prototype = {\n  /**\n   * Needed for IE. Apparently IE doesn't think that \"selected\" is an\n   * attribute when reading over the attributes using selectEl.attributes\n   */\n  option: function(fromEl, toEl) {\n    syncBooleanAttrProp(fromEl, toEl, \"selected\");\n  },\n  button: function(fromEl, toEl) {\n    syncBooleanAttrProp(fromEl, toEl, \"disabled\");\n  },\n  /**\n   * The \"value\" attribute is special for the <input> element since it sets\n   * the initial value. Changing the \"value\" attribute without changing the\n   * \"value\" property will have no effect since it is only used to the set the\n   * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n   */\n  input: function(fromEl, toEl) {\n    syncBooleanAttrProp(fromEl, toEl, \"checked\");\n    syncBooleanAttrProp(fromEl, toEl, \"disabled\");\n\n    if (fromEl.value != toEl.___value) {\n      fromEl.value = toEl.___value;\n    }\n\n    if (fromEl.hasAttribute(\"value\") && !toEl.___hasAttribute(\"value\")) {\n      fromEl.removeAttribute(\"value\");\n    }\n  },\n\n  textarea: function(fromEl, toEl) {\n    if (toEl.___preserveTextAreaValue) {\n      return;\n    }\n\n    var newValue = toEl.___value;\n    if (fromEl.value != newValue) {\n      fromEl.value = newValue;\n    }\n\n    var firstChild = fromEl.firstChild;\n    if (firstChild) {\n      // Needed for IE. Apparently IE sets the placeholder as the\n      // node value and vise versa. This ignores an empty update.\n      var oldValue = firstChild.nodeValue;\n\n      if (\n        oldValue == newValue ||\n        (!newValue && oldValue == fromEl.placeholder)\n      ) {\n        return;\n      }\n\n      firstChild.nodeValue = newValue;\n    }\n  },\n  select: function(fromEl, toEl) {\n    if (!toEl.___hasAttribute(\"multiple\")) {\n      var selected = 0;\n      forEachOption(\n        toEl,\n        function(option, i) {\n          if (option.___hasAttribute(\"selected\")) {\n            selected = i;\n          }\n        },\n        -1\n      );\n\n      if (fromEl.selectedIndex !== selected) {\n        fromEl.selectedIndex = selected;\n      }\n    }\n  }\n};\n\nmodule.exports = new SpecialElHandlers();\n","var parseHTML = function(html) {\n  var container = document.createElement(\"template\");\n  parseHTML = container.content\n    ? function(html) {\n        container.innerHTML = html;\n        return container.content;\n      }\n    : function(html) {\n        container.innerHTML = html;\n        return container;\n      };\n\n  return parseHTML(html);\n};\n\nmodule.exports = function(html) {\n  return parseHTML(html).firstChild;\n};\n","var VNode = require(\"./VNode\");\nvar VDocumentFragment = require(\"./VDocumentFragment\");\nvar VElement = require(\"./VElement\");\nvar VText = require(\"./VText\");\nvar VComponent = require(\"./VComponent\");\nvar VFragment = require(\"./VFragment\");\nvar parseHTML = require(\"./parse-html\");\n\nvar defaultDocument = typeof document != \"undefined\" && document;\nvar specialHtmlRegexp = /[&<]/;\n\nfunction virtualizeChildNodes(node, vdomParent, ownerComponent) {\n  var curChild = node.firstChild;\n  while (curChild) {\n    vdomParent.___appendChild(virtualize(curChild, ownerComponent));\n    curChild = curChild.nextSibling;\n  }\n}\n\nfunction virtualize(node, ownerComponent) {\n  switch (node.nodeType) {\n    case 1:\n      return VElement.___virtualize(node, virtualizeChildNodes, ownerComponent);\n    case 3:\n      return new VText(node.nodeValue, ownerComponent);\n    case 11:\n      var vdomDocFragment = new VDocumentFragment();\n      virtualizeChildNodes(node, vdomDocFragment, ownerComponent);\n      return vdomDocFragment;\n  }\n}\n\nfunction virtualizeHTML(html, doc, ownerComponent) {\n  if (!specialHtmlRegexp.test(html)) {\n    return new VText(html, ownerComponent);\n  }\n\n  var vdomFragment = new VDocumentFragment();\n  var curChild = parseHTML(html);\n\n  while (curChild) {\n    vdomFragment.___appendChild(virtualize(curChild, ownerComponent));\n    curChild = curChild.nextSibling;\n  }\n\n  return vdomFragment;\n}\n\nvar Node_prototype = VNode.prototype;\n\n/**\n * Shorthand method for creating and appending a Text node with a given value\n * @param  {String} value The text value for the new Text node\n */\nNode_prototype.t = function(value) {\n  var type = typeof value;\n  var vdomNode;\n\n  if (type !== \"string\") {\n    if (value == null) {\n      value = \"\";\n    } else if (type === \"object\") {\n      if (value.toHTML) {\n        vdomNode = virtualizeHTML(value.toHTML(), document);\n      }\n    }\n  }\n\n  this.___appendChild(vdomNode || new VText(value.toString()));\n  return this.___finishChild();\n};\n\nNode_prototype.___appendDocumentFragment = function() {\n  return this.___appendChild(new VDocumentFragment());\n};\n\nexports.___VDocumentFragment = VDocumentFragment;\nexports.___VElement = VElement;\nexports.___VText = VText;\nexports.___VComponent = VComponent;\nexports.___VFragment = VFragment;\nexports.___virtualize = virtualize;\nexports.___virtualizeHTML = virtualizeHTML;\nexports.___defaultDocument = defaultDocument;\n","module.exports = function copyProps(from, to) {\n    Object.getOwnPropertyNames(from).forEach(function(name) {\n        var descriptor = Object.getOwnPropertyDescriptor(from, name);\n        Object.defineProperty(to, name, descriptor);\n    });\n};","module.exports = function extend(target, source) { //A simple function to copy properties from one object to another\n    if (!target) { //Check if a target was provided, otherwise create a new empty object to return\n        target = {};\n    }\n\n    if (source) {\n        for (var propName in source) {\n            if (source.hasOwnProperty(propName)) { //Only look at source properties that are not inherited\n                target[propName] = source[propName]; //Copy the property\n            }\n        }\n    }\n\n    return target;\n};","var copyProps = require('./copyProps');\n\nfunction inherit(ctor, superCtor, shouldCopyProps) {\n    var oldProto = ctor.prototype;\n    var newProto = ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n            value: ctor,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (oldProto && shouldCopyProps !== false) {\n        copyProps(oldProto, newProto);\n    }\n    ctor.$super = superCtor;\n    ctor.prototype = newProto;\n    return ctor;\n}\n\n\nmodule.exports = inherit;\ninherit._inherit = inherit;\n","module.exports = require(\"./src/constants\");","module.exports = require('./src/finalize');","var win = typeof window !== \"undefined\" ? window : global;\nexports.NOOP = win.$W10NOOP = win.$W10NOOP || function () {};","var constants = require(\"./constants\");\nvar isArray = Array.isArray;\n\nfunction resolve(object, path, len) {\n    var current = object;\n    for (var i=0; i<len; i++) {\n        current = current[path[i]];\n    }\n\n    return current;\n}\n\nfunction resolveType(info) {\n    if (info.type === 'Date') {\n        return new Date(info.value);\n    } else if (info.type === 'NOOP') {\n        return constants.NOOP;\n    } else {\n        throw new Error('Bad type');\n    }\n}\n\nmodule.exports = function finalize(outer) {\n    if (!outer) {\n        return outer;\n    }\n\n    var assignments = outer.$$;\n    if (assignments) {\n        var object = outer.o;\n        var len;\n\n        if (assignments && (len=assignments.length)) {\n            for (var i=0; i<len; i++) {\n                var assignment = assignments[i];\n\n                var rhs = assignment.r;\n                var rhsValue;\n\n                if (isArray(rhs)) {\n                    rhsValue = resolve(object, rhs, rhs.length);\n                } else {\n                    rhsValue = resolveType(rhs);\n                }\n\n                var lhs = assignment.l;\n                var lhsLast = lhs.length-1;\n\n                if (lhsLast === -1) {\n                    object = outer.o = rhsValue;\n                    break;\n                } else {\n                    var lhsParent = resolve(object, lhs, lhsLast);\n                    lhsParent[lhs[lhsLast]] = rhsValue;\n                }\n            }\n        }\n\n        assignments.length = 0; // Assignments have been applied, do not reapply\n\n        return object == null ? null : object;\n    } else {\n        return outer;\n    }\n\n};"],"sourceRoot":""}