{"version":3,"file":"420.860abe49.js","mappings":"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","sources":["webpack:///../../node_modules/@marko/runtime-tags/dist/translator/index.js"],"sourcesContent":["\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name2 in all)\n    __defProp(target, name2, { get: all[name2], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/translator/index.ts\nvar translator_exports = {};\n__export(translator_exports, {\n  analyze: () => analyze,\n  getRuntimeEntryFiles: () => getRuntimeEntryFiles,\n  internalEntryBuilder: () => entry_builder_default,\n  preferAPI: () => preferAPI,\n  tagDiscoveryDirs: () => tagDiscoveryDirs,\n  taglibs: () => taglibs,\n  transform: () => transform,\n  translate: () => translate\n});\nmodule.exports = __toCommonJS(translator_exports);\n\n// src/translator/util/runtime-info.ts\nvar import_package = require(\"../../package.json\");\nvar runtime_info_default = {\n  name: import_package.name,\n  taglibId: \"marko-core\"\n};\n\n// src/translator/core/attrs.ts\nvar import_compiler = require(\"@marko/compiler\");\nvar import_babel_utils = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/assert.ts\nfunction assertNoSpreadAttrs(tag) {\n  for (const attr2 of tag.get(\"attributes\")) {\n    if (attr2.isMarkoSpreadAttribute()) {\n      throw attr2.buildCodeFrameError(\n        `The \\`${tag.get(\"name\").node.value}\\` tag does not support \\`...spread\\` attributes.`\n      );\n    }\n  }\n}\nfunction assertNoBodyContent(tag) {\n  if (tag.node.body.body.length) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${tag.get(\"name\").node.value}\\` tag does not support body content.`\n    );\n  }\n}\n\n// src/translator/core/attrs.ts\nvar attrs_default = {\n  migrate: [\n    (tag) => {\n      (0, import_babel_utils.assertNoArgs)(tag);\n      (0, import_babel_utils.assertNoParams)(tag);\n      (0, import_babel_utils.assertNoAttributes)(tag);\n      assertNoBodyContent(tag);\n      (0, import_babel_utils.assertNoAttributeTags)(tag);\n      (0, import_babel_utils.diagnosticDeprecate)(tag, {\n        label: \"The `attrs` tag is deprecated, prefer destructuring `input` via the `const` tag.\",\n        fix() {\n          const tagVar = tag.node.var;\n          if (tagVar && !(tagVar.type === \"Identifier\" && tagVar.name === \"input\")) {\n            const constTag = import_compiler.types.markoTag(\n              import_compiler.types.stringLiteral(\"const\"),\n              [import_compiler.types.markoAttribute(\"value\", import_compiler.types.identifier(\"input\"))],\n              import_compiler.types.markoTagBody([])\n            );\n            constTag.var = tagVar;\n            tag.replaceWith(constTag);\n          } else {\n            tag.remove();\n          }\n        }\n      });\n    }\n  ],\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"attrs/{ ... }\",\n      description: \"Use to receive the attributes passed into this template.\",\n      snippet: \"attrs/{ $1 }$2\"\n    }\n  ]\n};\n\n// src/translator/core/await.ts\nvar import_compiler22 = require(\"@marko/compiler\");\nvar import_babel_utils12 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/evaluate.ts\nvar import_babel_utils2 = require(\"@marko/compiler/babel-utils\");\nfunction evaluate(value) {\n  let { extra } = value;\n  if (!extra) {\n    extra = value.extra = {};\n  }\n  if (extra.confident === void 0) {\n    const computed = (0, import_babel_utils2.computeNode)(value);\n    if (computed) {\n      extra.computed = computed.value;\n      extra.confident = true;\n    } else {\n      extra.computed = void 0;\n      extra.confident = false;\n    }\n  }\n  return extra;\n}\n\n// src/translator/util/references.ts\nvar import_compiler21 = require(\"@marko/compiler\");\n\n// src/translator/visitors/program/index.ts\nvar import_compiler20 = require(\"@marko/compiler\");\nvar import_babel_utils11 = require(\"@marko/compiler/babel-utils\");\nvar import_path2 = __toESM(require(\"path\"));\n\n// src/translator/util/binding-has-downstream-expressions.ts\nfunction bindingHasDownstreamExpressions(binding) {\n  if (binding.downstreamExpressions.size) return true;\n  for (const alias of binding.aliases) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  return false;\n}\n\n// src/translator/util/entry-builder.ts\nvar import_compiler2 = require(\"@marko/compiler\");\nvar import_babel_utils3 = require(\"@marko/compiler/babel-utils\");\nvar kState = Symbol();\nvar entry_builder_default = {\n  build(entryFile) {\n    const state = entryFile[kState];\n    if (!state) {\n      throw entryFile.path.buildCodeFrameError(\n        \"Unable to build hydrate code, no files were visited before finalizing the build\"\n      );\n    }\n    const body = state.imports.map(\n      (it) => import_compiler2.types.importDeclaration([], import_compiler2.types.stringLiteral(it))\n    );\n    if (state.init) {\n      body.unshift(\n        import_compiler2.types.importDeclaration(\n          [import_compiler2.types.importSpecifier(import_compiler2.types.identifier(\"init\"), import_compiler2.types.identifier(\"init\"))],\n          import_compiler2.types.stringLiteral(\n            `${runtime_info_default.name}/${entryFile.markoOpts.optimize ? \"\" : \"debug/\"}dom`\n          )\n        )\n      );\n      body.push(\n        import_compiler2.types.expressionStatement(import_compiler2.types.callExpression(import_compiler2.types.identifier(\"init\"), []))\n      );\n    }\n    return body;\n  },\n  visit(file, entryFile, visitChild) {\n    const state = entryFile[kState] ||= {\n      imports: [],\n      init: false\n    };\n    const { analyzedTags } = file.metadata.marko;\n    state.imports.push(\n      (0, import_babel_utils3.resolveRelativePath)(entryFile, file.opts.filename)\n    );\n    state.init ||= file.path.node.extra.hasInteractiveChild || file.path.node.extra.isInteractive || false;\n    for (const tag of analyzedTags || []) {\n      visitChild(tag);\n    }\n  }\n};\n\n// src/translator/util/marko-config.ts\nfunction isOutputHTML() {\n  return getMarkoOpts().output === \"html\";\n}\nfunction isOutputDOM() {\n  return !isOutputHTML();\n}\nfunction getMarkoOpts() {\n  return currentProgramPath.hub.file.markoOpts;\n}\nfunction isOptimize() {\n  return getMarkoOpts().optimize;\n}\n\n// src/translator/util/runtime.ts\nvar import_compiler4 = require(\"@marko/compiler\");\nvar import_babel_utils4 = require(\"@marko/compiler/babel-utils\");\n\n// src/common/attr-tag.ts\nvar rest = false ? Symbol(\"Attribute Tag\") : Symbol();\n\n// src/common/helpers.ts\nfunction classValue(value) {\n  return toDelimitedString(value, \" \", stringifyClassObject);\n}\nfunction stringifyClassObject(name2, value) {\n  return value ? name2 : \"\";\n}\nfunction styleValue(value) {\n  return toDelimitedString(value, \";\", stringifyStyleObject);\n}\nvar NON_DIMENSIONAL = /^(--|ta|or|li|z)|n-c|i(do|nk|m|t)|w$|we/;\nfunction stringifyStyleObject(name2, value) {\n  return value || value === 0 ? `${name2}:${typeof value === \"number\" && value && !NON_DIMENSIONAL.test(name2) ? value + \"px\" : value}` : \"\";\n}\nfunction toDelimitedString(val, delimiter, stringify) {\n  switch (typeof val) {\n    case \"string\":\n      return val;\n    case \"object\":\n      if (val !== null) {\n        let result = \"\";\n        let curDelimiter = \"\";\n        if (Array.isArray(val)) {\n          for (const v of val) {\n            const part = toDelimitedString(v, delimiter, stringify);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        } else {\n          for (const name2 in val) {\n            const v = val[name2];\n            const part = stringify(name2, v);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        }\n        return result;\n      }\n  }\n  return \"\";\n}\nfunction isEventHandler(name2) {\n  return /^on[A-Z-]/.test(name2);\n}\nfunction getEventHandlerName(name2) {\n  return name2[2] === \"-\" ? name2.slice(3) : name2.slice(2).toLowerCase();\n}\nfunction isVoid(value) {\n  return value == null || value === false;\n}\n\n// src/html/content.ts\nfunction toString(val) {\n  return val ? val + \"\" : val === 0 ? \"0\" : \"\";\n}\nvar unsafeXMLReg = /[<&]/g;\nvar replaceUnsafeXML = (c) => c === \"&\" ? \"&amp;\" : \"&lt;\";\nvar escapeXMLStr = (str) => unsafeXMLReg.test(str) ? str.replace(unsafeXMLReg, replaceUnsafeXML) : str;\nfunction escapeXML(val) {\n  return val ? escapeXMLStr(val + \"\") : val === 0 ? \"0\" : \"&zwj;\";\n}\nvar unsafeScriptReg = /<\\/script/g;\nvar escapeScriptStr = (str) => unsafeScriptReg.test(str) ? str.replace(unsafeScriptReg, \"\\\\x3C/script\") : str;\nfunction escapeScript(val) {\n  return val ? escapeScriptStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\nvar unsafeStyleReg = /<\\/style/g;\nvar escapeStyleStr = (str) => unsafeStyleReg.test(str) ? str.replace(unsafeStyleReg, \"\\\\3C/style\") : str;\nfunction escapeStyle(val) {\n  return val ? escapeStyleStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\n\n// src/html/serializer.ts\nvar { hasOwnProperty } = {};\nvar Generator = function* () {\n}().constructor;\nvar AsyncGenerator = async function* () {\n}().constructor;\nvar KNOWN_SYMBOLS = (() => {\n  const KNOWN_SYMBOLS2 = /* @__PURE__ */ new Map();\n  for (const name2 of Object.getOwnPropertyNames(Symbol)) {\n    const symbol = Symbol[name2];\n    if (typeof symbol === \"symbol\") {\n      KNOWN_SYMBOLS2.set(symbol, \"Symbol.\" + name2);\n    }\n  }\n  return KNOWN_SYMBOLS2;\n})();\nvar KNOWN_FUNCTIONS = /* @__PURE__ */ new Map([\n  // This is by no means an exhaustive list,\n  // but it should cover most of the built-in functions.\n  [AggregateError, \"AggregateError\"],\n  [Array, \"Array\"],\n  [Array.from, \"Array.from\"],\n  [Array.isArray, \"Array.isArray\"],\n  [Array.of, \"Array.of\"],\n  [ArrayBuffer, \"ArrayBuffer\"],\n  [ArrayBuffer.isView, \"ArrayBuffer.isView\"],\n  [Atomics.add, \"Atomics.add\"],\n  [Atomics.and, \"Atomics.and\"],\n  [Atomics.compareExchange, \"Atomics.compareExchange\"],\n  [Atomics.exchange, \"Atomics.exchange\"],\n  [Atomics.isLockFree, \"Atomics.isLockFree\"],\n  [Atomics.load, \"Atomics.load\"],\n  [Atomics.notify, \"Atomics.notify\"],\n  [Atomics.or, \"Atomics.or\"],\n  [Atomics.store, \"Atomics.store\"],\n  [Atomics.sub, \"Atomics.sub\"],\n  [Atomics.wait, \"Atomics.wait\"],\n  [BigInt, \"BigInt\"],\n  [BigInt.asIntN, \"BigInt.asIntN\"],\n  [BigInt.asUintN, \"BigInt.asUintN\"],\n  [BigInt64Array, \"BigInt64Array\"],\n  [BigInt64Array.from, \"BigInt64Array.from\"],\n  [BigInt64Array.of, \"BigInt64Array.of\"],\n  [BigUint64Array, \"BigUint64Array\"],\n  [BigUint64Array.from, \"BigUint64Array.from\"],\n  [BigUint64Array.of, \"BigUint64Array.of\"],\n  [Boolean, \"Boolean\"],\n  [console.assert, \"console.assert\"],\n  [console.clear, \"console.clear\"],\n  [console.count, \"console.count\"],\n  [console.countReset, \"console.countReset\"],\n  [console.debug, \"console.debug\"],\n  [console.dir, \"console.dir\"],\n  [console.dirxml, \"console.dirxml\"],\n  [console.error, \"console.error\"],\n  [console.group, \"console.group\"],\n  [console.groupCollapsed, \"console.groupCollapsed\"],\n  [console.groupEnd, \"console.groupEnd\"],\n  [console.info, \"console.info\"],\n  [console.log, \"console.log\"],\n  [console.table, \"console.table\"],\n  [console.time, \"console.time\"],\n  [console.timeEnd, \"console.timeEnd\"],\n  [console.timeLog, \"console.timeLog\"],\n  [console.timeStamp, \"console.timeStamp\"],\n  [console.trace, \"console.trace\"],\n  [console.warn, \"console.warn\"],\n  [DataView, \"DataView\"],\n  [Date, \"Date\"],\n  [Date.now, \"Date.now\"],\n  [Date.parse, \"Date.parse\"],\n  [Date.UTC, \"Date.UTC\"],\n  [decodeURI, \"decodeURI\"],\n  [decodeURIComponent, \"decodeURIComponent\"],\n  [encodeURI, \"encodeURI\"],\n  [encodeURIComponent, \"encodeURIComponent\"],\n  [Error, \"Error\"],\n  [EvalError, \"EvalError\"],\n  [Float32Array, \"Float32Array\"],\n  [Float32Array.from, \"Float32Array.from\"],\n  [Float32Array.of, \"Float32Array.of\"],\n  [Float64Array, \"Float64Array\"],\n  [Float64Array.from, \"Float64Array.from\"],\n  [Float64Array.of, \"Float64Array.of\"],\n  [Function, \"Function\"],\n  [globalThis.atob, \"atob\"],\n  [globalThis.btoa, \"btoa\"],\n  [globalThis.clearImmediate, \"clearImmediate\"],\n  [globalThis.clearInterval, \"clearInterval\"],\n  [globalThis.clearTimeout, \"clearTimeout\"],\n  [globalThis.crypto?.getRandomValues, \"crypto.getRandomValues\"],\n  [globalThis.crypto?.randomUUID, \"crypto.randomUUID\"],\n  [globalThis.fetch, \"fetch\"],\n  [globalThis.performance?.now, \"performance.now\"],\n  [globalThis.queueMicrotask, \"queueMicrotask\"],\n  [globalThis.setImmediate, \"setImmediate\"],\n  [globalThis.setInterval, \"setInterval\"],\n  [globalThis.setTimeout, \"setTimeout\"],\n  [globalThis.structuredClone, \"structuredClone\"],\n  [globalThis.URL, \"URL\"],\n  [globalThis.URLSearchParams, \"URLSearchParams\"],\n  [globalThis.WritableStream, \"WritableStream\"],\n  [Int16Array, \"Int16Array\"],\n  [Int16Array.from, \"Int16Array.from\"],\n  [Int16Array.of, \"Int16Array.of\"],\n  [Int32Array, \"Int32Array\"],\n  [Int32Array.from, \"Int32Array.from\"],\n  [Int32Array.of, \"Int32Array.of\"],\n  [Int8Array, \"Int8Array\"],\n  [Int8Array.from, \"Int8Array.from\"],\n  [Int8Array.of, \"Int8Array.of\"],\n  [Intl.Collator, \"Intl.Collator\"],\n  [Intl.DateTimeFormat, \"Intl.DateTimeFormat\"],\n  [Intl.DisplayNames, \"Intl.DisplayNames\"],\n  [Intl.getCanonicalLocales, \"Intl.getCanonicalLocales\"],\n  [Intl.ListFormat, \"Intl.ListFormat\"],\n  [Intl.Locale, \"Intl.Locale\"],\n  [Intl.NumberFormat, \"Intl.NumberFormat\"],\n  [Intl.PluralRules, \"Intl.PluralRules\"],\n  [Intl.RelativeTimeFormat, \"Intl.RelativeTimeFormat\"],\n  [Intl.Segmenter, \"Intl.Segmenter\"],\n  [Intl.supportedValuesOf, \"Intl.supportedValuesOf\"],\n  [isFinite, \"isFinite\"],\n  [isNaN, \"isNaN\"],\n  [JSON.parse, \"JSON.parse\"],\n  [JSON.stringify, \"JSON.stringify\"],\n  [Map, \"Map\"],\n  [Map.groupBy, \"Map.groupBy\"],\n  [Math.abs, \"Math.abs\"],\n  [Math.acos, \"Math.acos\"],\n  [Math.acosh, \"Math.acosh\"],\n  [Math.asin, \"Math.asin\"],\n  [Math.asinh, \"Math.asinh\"],\n  [Math.atan, \"Math.atan\"],\n  [Math.atan2, \"Math.atan2\"],\n  [Math.atanh, \"Math.atanh\"],\n  [Math.cbrt, \"Math.cbrt\"],\n  [Math.ceil, \"Math.ceil\"],\n  [Math.clz32, \"Math.clz32\"],\n  [Math.cos, \"Math.cos\"],\n  [Math.cosh, \"Math.cosh\"],\n  [Math.exp, \"Math.exp\"],\n  [Math.expm1, \"Math.expm1\"],\n  [Math.floor, \"Math.floor\"],\n  [Math.fround, \"Math.fround\"],\n  [Math.hypot, \"Math.hypot\"],\n  [Math.imul, \"Math.imul\"],\n  [Math.log, \"Math.log\"],\n  [Math.log10, \"Math.log10\"],\n  [Math.log1p, \"Math.log1p\"],\n  [Math.log2, \"Math.log2\"],\n  [Math.max, \"Math.max\"],\n  [Math.min, \"Math.min\"],\n  [Math.pow, \"Math.pow\"],\n  [Math.random, \"Math.random\"],\n  [Math.round, \"Math.round\"],\n  [Math.sign, \"Math.sign\"],\n  [Math.sin, \"Math.sin\"],\n  [Math.sinh, \"Math.sinh\"],\n  [Math.sqrt, \"Math.sqrt\"],\n  [Math.tan, \"Math.tan\"],\n  [Math.tanh, \"Math.tanh\"],\n  [Math.trunc, \"Math.trunc\"],\n  [Number, \"Number\"],\n  [Number.isFinite, \"Number.isFinite\"],\n  [Number.isInteger, \"Number.isInteger\"],\n  [Number.isNaN, \"Number.isNaN\"],\n  [Number.isSafeInteger, \"Number.isSafeInteger\"],\n  [Number.parseFloat, \"Number.parseFloat\"],\n  [Number.parseInt, \"Number.parseInt\"],\n  [Object, \"Object\"],\n  [Object.assign, \"Object.assign\"],\n  [Object.create, \"Object.create\"],\n  [Object.defineProperties, \"Object.defineProperties\"],\n  [Object.defineProperty, \"Object.defineProperty\"],\n  [Object.entries, \"Object.entries\"],\n  [Object.freeze, \"Object.freeze\"],\n  [Object.fromEntries, \"Object.fromEntries\"],\n  [Object.getOwnPropertyDescriptor, \"Object.getOwnPropertyDescriptor\"],\n  [Object.getOwnPropertyDescriptors, \"Object.getOwnPropertyDescriptors\"],\n  [Object.getOwnPropertyNames, \"Object.getOwnPropertyNames\"],\n  [Object.getOwnPropertySymbols, \"Object.getOwnPropertySymbols\"],\n  [Object.getPrototypeOf, \"Object.getPrototypeOf\"],\n  [Object.is, \"Object.is\"],\n  [Object.isExtensible, \"Object.isExtensible\"],\n  [Object.isFrozen, \"Object.isFrozen\"],\n  [Object.isSealed, \"Object.isSealed\"],\n  [Object.keys, \"Object.keys\"],\n  [Object.preventExtensions, \"Object.preventExtensions\"],\n  [Object.seal, \"Object.seal\"],\n  [Object.setPrototypeOf, \"Object.setPrototypeOf\"],\n  [Object.values, \"Object.values\"],\n  [parseFloat, \"parseFloat\"],\n  [parseInt, \"parseInt\"],\n  [Promise, \"Promise\"],\n  [Proxy, \"Proxy\"],\n  [RangeError, \"RangeError\"],\n  [ReferenceError, \"ReferenceError\"],\n  [Reflect.apply, \"Reflect.apply\"],\n  [Reflect.construct, \"Reflect.construct\"],\n  [Reflect.defineProperty, \"Reflect.defineProperty\"],\n  [Reflect.deleteProperty, \"Reflect.deleteProperty\"],\n  [Reflect.get, \"Reflect.get\"],\n  [Reflect.getOwnPropertyDescriptor, \"Reflect.getOwnPropertyDescriptor\"],\n  [Reflect.getPrototypeOf, \"Reflect.getPrototypeOf\"],\n  [Reflect.has, \"Reflect.has\"],\n  [Reflect.isExtensible, \"Reflect.isExtensible\"],\n  [Reflect.ownKeys, \"Reflect.ownKeys\"],\n  [Reflect.preventExtensions, \"Reflect.preventExtensions\"],\n  [Reflect.set, \"Reflect.set\"],\n  [Reflect.setPrototypeOf, \"Reflect.setPrototypeOf\"],\n  [RegExp, \"RegExp\"],\n  [Set, \"Set\"],\n  [String, \"String\"],\n  [String.fromCharCode, \"String.fromCharCode\"],\n  [String.fromCodePoint, \"String.fromCodePoint\"],\n  [String.raw, \"String.raw\"],\n  [Symbol, \"Symbol\"],\n  [Symbol.for, \"Symbol.for\"],\n  [SyntaxError, \"SyntaxError\"],\n  [TypeError, \"TypeError\"],\n  [Uint16Array, \"Uint16Array\"],\n  [Uint16Array.from, \"Uint16Array.from\"],\n  [Uint16Array.of, \"Uint16Array.of\"],\n  [Uint32Array, \"Uint32Array\"],\n  [Uint32Array.from, \"Uint32Array.from\"],\n  [Uint32Array.of, \"Uint32Array.of\"],\n  [Uint8Array, \"Uint8Array\"],\n  [Uint8Array.from, \"Uint8Array.from\"],\n  [Uint8Array.of, \"Uint8Array.of\"],\n  [Uint8ClampedArray, \"Uint8ClampedArray\"],\n  [Uint8ClampedArray.from, \"Uint8ClampedArray.from\"],\n  [Uint8ClampedArray.of, \"Uint8ClampedArray.of\"],\n  [URIError, \"URIError\"],\n  [WeakMap, \"WeakMap\"],\n  [WeakSet, \"WeakSet\"]\n]);\nvar KNOWN_OBJECTS = /* @__PURE__ */ new Map([\n  [Atomics, \"Atomics\"],\n  [console, \"console\"],\n  [globalThis, \"globalThis\"],\n  [globalThis.crypto, \"crypto\"],\n  [Intl, \"Intl\"],\n  [JSON, \"JSON\"],\n  [Math, \"Math\"],\n  [Reflect, \"Reflect\"]\n]);\nfunction toAccess(accessor) {\n  const start = accessor[0];\n  return start === '\"' || start >= \"0\" && start <= \"9\" ? \"[\" + accessor + \"]\" : \".\" + accessor;\n}\n\n// src/html/writer.ts\nvar K_SCOPE_ID = Symbol(\"Scope ID\");\nvar kPendingContexts = Symbol(\"Pending Contexts\");\nvar branchIdKey = Symbol();\nvar tick = globalThis.setImmediate || globalThis.setTimeout || globalThis.queueMicrotask || ((cb) => Promise.resolve().then(cb));\n\n// src/html/attrs.ts\nfunction classAttr(val) {\n  return stringAttr(\"class\", classValue(val));\n}\nfunction styleAttr(val) {\n  return stringAttr(\"style\", styleValue(val));\n}\nvar kSelectedValue = Symbol(\"selectedValue\");\nfunction attr(name2, val) {\n  return isVoid(val) ? \"\" : nonVoidAttr(name2, val);\n}\nfunction stringAttr(name2, val) {\n  return val && ` ${name2}=${escapeAttrValue(val)}`;\n}\nfunction nonVoidAttr(name2, val) {\n  switch (typeof val) {\n    case \"string\":\n      return ` ${name2 + attrAssignment(val)}`;\n    case \"boolean\":\n      return ` ${name2}`;\n    case \"number\":\n      return ` ${name2}=${val}`;\n    case \"object\":\n      if (val instanceof RegExp) {\n        return ` ${name2 + attrAssignment(val.source)}`;\n      }\n      break;\n  }\n  return ` ${name2 + attrAssignment(val + \"\")}`;\n}\nfunction attrAssignment(val) {\n  return val ? `=${escapeAttrValue(val)}` : \"\";\n}\nvar unsafeAttrChars = /[\"'>\\s]/g;\nfunction escapeAttrValue(str) {\n  if (unsafeAttrChars.test(str)) {\n    const c = str[unsafeAttrChars.lastIndex - 1];\n    unsafeAttrChars.lastIndex = 0;\n    return c === '\"' ? `'${str.replace(/'/g, \"&#39;\")}'` : `\"${str.replace(/\"/g, \"&#34;\")}\"`;\n  }\n  return str;\n}\n\n// src/common/compat-meta.ts\nvar prefix = false ? \"$compat_\" : \"$C_\";\nvar RENDERER_REGISTER_ID = prefix + (false ? \"renderer\" : \"r\");\nvar SET_SCOPE_REGISTER_ID = prefix + (false ? \"setScope\" : \"s\");\nvar RENDER_BODY_ID = prefix + (false ? \"renderBody\" : \"b\");\n\n// src/html/compat.ts\nvar K_TAGS_API_STATE = Symbol();\n\n// src/translator/util/to-property-name.ts\nvar import_compiler3 = require(\"@marko/compiler\");\nfunction toPropertyName(name2) {\n  if (/^[a-z_$][a-z0-9_$]*$/i.test(name2)) {\n    return import_compiler3.types.identifier(name2);\n  } else if (/^(?:0|[1-9][0-9]*)$/.test(name2)) {\n    return import_compiler3.types.numericLiteral(parseInt(name2, 10));\n  }\n  return import_compiler3.types.stringLiteral(name2);\n}\nfunction toObjectProperty(name2, value) {\n  return import_compiler3.types.objectProperty(toPropertyName(name2), value);\n}\nfunction toMemberExpression(object, key, optional) {\n  const prop = toPropertyName(key);\n  const computed = prop.type !== \"Identifier\";\n  return optional ? import_compiler3.types.optionalMemberExpression(object, prop, computed, true) : import_compiler3.types.memberExpression(object, prop, computed);\n}\n\n// src/translator/util/runtime.ts\nvar pureFunctions = [\n  \"createTemplate\",\n  \"createRenderer\",\n  \"createRendererWithOwner\",\n  \"value\",\n  \"state\",\n  \"intersection\",\n  \"loopClosure\",\n  \"conditionalClosure\",\n  \"dynamicClosure\",\n  \"loopOf\",\n  \"loopIn\",\n  \"loopTo\",\n  \"conditional\"\n];\nfunction importRuntime(name2) {\n  const { output } = getMarkoOpts();\n  return toMemberExpression(\n    (0, import_babel_utils4.importStar)(currentProgramPath.hub.file, getRuntimePath(output), \"$\"),\n    name2\n  );\n}\nfunction callRuntime(name2, ...args) {\n  const callExpression2 = import_compiler4.types.callExpression(\n    importRuntime(name2),\n    filterArguments(args)\n  );\n  if (pureFunctions.includes(name2)) {\n    callExpression2.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: ` @__PURE__ `\n      }\n    ];\n  }\n  return callExpression2;\n}\nfunction getHTMLRuntime() {\n  return {\n    escapeXML,\n    toString,\n    attr,\n    classAttr,\n    styleAttr,\n    escapeScript,\n    escapeStyle\n  };\n}\nfunction getRuntimePath(output) {\n  const { optimize } = getMarkoOpts();\n  return `${runtime_info_default.name}/${optimize ? \"\" : \"debug/\"}${output === \"html\" ? \"html\" : \"dom\"}`;\n}\nfunction filterArguments(args) {\n  const filteredArgs = [];\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (arg || filteredArgs.length) {\n      filteredArgs[i] = arg || import_compiler4.types.unaryExpression(\"void\", import_compiler4.types.numericLiteral(0));\n    }\n  }\n  return filteredArgs;\n}\nfunction getCompatRuntimeFile() {\n  const markoOpts = getMarkoOpts();\n  return `marko/src/runtime/helpers/tags-compat/${isOutputHTML() ? \"html\" : \"dom\"}${markoOpts.optimize ? \"\" : \"-debug\"}.${markoOpts.modules === \"esm\" ? \"mjs\" : \"js\"}`;\n}\n\n// src/translator/util/sections.ts\nvar import_compiler6 = require(\"@marko/compiler\");\nvar import_babel_utils7 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/is-core-tag.ts\nvar import_babel_utils5 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-tag-name.ts\nfunction getTagName(tag) {\n  return tag.node.name.value;\n}\n\n// src/translator/util/is-core-tag.ts\nvar { taglibId } = runtime_info_default;\nvar htmlTaglibId = \"marko-html\";\nvar interopTaglibId = \"@marko/translator-interop-class-tags\";\nfunction isCoreTag(tag) {\n  if (tag.isMarkoTag()) {\n    const tagDef = (0, import_babel_utils5.getTagDef)(tag);\n    if (tagDef) {\n      switch (tagDef.taglibId) {\n        case taglibId:\n        case interopTaglibId:\n          return true;\n        case htmlTaglibId:\n          switch (tagDef.name) {\n            case \"script\":\n            case \"style\":\n              return true;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\nfunction isCoreTagName(tag, name2) {\n  return isCoreTag(tag) && getTagName(tag) === name2;\n}\nfunction isConditionTag(tag) {\n  if (isCoreTag(tag)) {\n    switch (getTagName(tag)) {\n      case \"if\":\n      case \"else-if\":\n      case \"else\":\n        return true;\n    }\n  }\n  return false;\n}\nfunction isControlFlowTag(tag) {\n  if (isCoreTag(tag)) {\n    switch (getTagName(tag)) {\n      case \"if\":\n      case \"else-if\":\n      case \"else\":\n      case \"for\":\n      case \"await\":\n      case \"try\":\n        return true;\n    }\n  }\n  return false;\n}\n\n// src/translator/util/optional.ts\nvar Sorted = class {\n  constructor(compare) {\n    this.compare = compare;\n  }\n  add(data, item) {\n    return data ? Array.isArray(data) ? addSorted(this.compare, data, item) : joinRepeatable(this.compare, data, item) : item;\n  }\n  union(a, b) {\n    if (a) {\n      if (Array.isArray(a)) {\n        if (b) {\n          if (Array.isArray(b)) {\n            return unionSortedRepeatable(this.compare, a, b);\n          } else {\n            return addSorted(this.compare, a, b);\n          }\n        }\n        return a;\n      }\n      if (b) {\n        if (Array.isArray(b)) {\n          return addSorted(this.compare, [...b], a);\n        }\n        return joinRepeatable(this.compare, b, a);\n      }\n      return a;\n    }\n    return b;\n  }\n  find(data, item) {\n    if (data) {\n      if (Array.isArray(data)) {\n        return findSorted(this.compare, data, item);\n      } else if (this.compare(data, item) === 0) {\n        return data;\n      }\n    }\n  }\n};\nfunction push(data, item) {\n  if (data) {\n    if (Array.isArray(data)) {\n      data.push(item);\n      return data;\n    }\n    return [data, item];\n  }\n  return item;\n}\nfunction concat(a, b) {\n  if (a) {\n    if (b) {\n      if (Array.isArray(a)) {\n        return a.concat(b);\n      } else if (Array.isArray(b)) {\n        return [a, ...b];\n      } else {\n        return [a, b];\n      }\n    }\n    return a;\n  }\n  return b;\n}\nfunction filter(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      const len = data.length;\n      let result;\n      let i = 0;\n      while (i < len) {\n        let item = data[i++];\n        if (cb(item)) {\n          result = item;\n          while (i < len) {\n            item = data[i++];\n            if (cb(item)) {\n              result = [result, item];\n              while (i < len) {\n                item = data[i++];\n                if (cb(item)) {\n                  result.push(item);\n                }\n              }\n              return result;\n            }\n          }\n          return result;\n        }\n      }\n      return result;\n    }\n    if (cb(data)) {\n      return data;\n    }\n  }\n  return void 0;\n}\nfunction forEach(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      let i = 0;\n      for (const item of data) {\n        cb(item, i++);\n      }\n    } else {\n      cb(data, 0);\n    }\n  }\n}\nfunction find(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      return data.find(cb);\n    }\n    if (cb(data, 0)) {\n      return data;\n    }\n  }\n}\nfunction findSorted(compare, data, item) {\n  let max = data.length;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const cur = data[mid];\n    const compareResult = compare(cur, item);\n    if (compareResult === 0) return cur;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n}\nfunction addSorted(compare, data, item) {\n  const len = data.length;\n  let max = len;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(data[mid], item);\n    if (compareResult === 0) return data;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n  const result = new Array(len + 1);\n  for (let i = 0; i < pos; i++) {\n    result[i] = data[i];\n  }\n  let cur = item;\n  while (pos < len) {\n    const next = cur;\n    cur = data[pos];\n    result[pos++] = next;\n  }\n  result[len] = cur;\n  return result;\n}\nfunction unionSortedRepeatable(compare, a, b) {\n  const aLen = a.length;\n  const bLen = b.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  const result = [];\n  while (aIndex < aLen && bIndex < bLen) {\n    const aValue = a[aIndex];\n    const bValue = b[bIndex];\n    const delta = compare(aValue, bValue);\n    if (delta === 0) {\n      aIndex++;\n      bIndex++;\n      result.push(aValue);\n    } else if (delta < 0) {\n      aIndex++;\n      result.push(aValue);\n    } else {\n      bIndex++;\n      result.push(bValue);\n    }\n  }\n  if (aLen === bLen && aIndex === aLen) {\n    return a;\n  }\n  while (aIndex < aLen) {\n    result.push(a[aIndex++]);\n  }\n  while (bIndex < bLen) {\n    result.push(b[bIndex++]);\n  }\n  return result;\n}\nfunction joinRepeatable(compare, a, b) {\n  const compareResult = compare(a, b);\n  return compareResult === 0 ? a : compareResult < 0 ? [a, b] : [b, a];\n}\n\n// src/translator/util/state.ts\nvar createProgramState = (init) => {\n  const map = /* @__PURE__ */ new WeakMap();\n  return [\n    () => {\n      let state = map.get(currentProgramPath);\n      if (!state) {\n        map.set(currentProgramPath, state = init());\n      }\n      return state;\n    },\n    (value) => {\n      map.set(currentProgramPath, value);\n    }\n  ];\n};\nfunction createSectionState(key, init) {\n  return [\n    (section) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      const sectionData = arrayOfSectionData[section.id] ??= init && init(section);\n      return sectionData;\n    },\n    (section, value) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      arrayOfSectionData[section.id] = value;\n    }\n  ];\n}\n\n// src/translator/util/tag-name-type.ts\nvar import_compiler5 = require(\"@marko/compiler\");\nvar import_babel_utils6 = require(\"@marko/compiler/babel-utils\");\nvar MARKO_FILE_REG = /^<.*>$|\\.marko$/;\nfunction analyzeTagNameType(tag) {\n  const extra = tag.node.extra ??= {};\n  if (extra.tagNameType === void 0) {\n    const name2 = tag.get(\"name\");\n    if (name2.isStringLiteral()) {\n      extra.tagNameType = name2.node.value[0] === \"@\" ? 3 /* AttributeTag */ : (0, import_babel_utils6.isNativeTag)(tag) ? 0 /* NativeTag */ : 1 /* CustomTag */;\n      extra.tagNameNullable = extra.tagNameNullable = false;\n    } else {\n      analyzeExpressionTagName(name2, extra);\n    }\n    if (extra.tagNameType === void 0) {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n    if (extra.tagNameType === 1 /* CustomTag */) {\n      const childFile = (0, import_babel_utils6.loadFileForTag)(tag);\n      if (!childFile) {\n        extra.tagNameType = 2 /* DynamicTag */;\n      } else if (childFile.ast.program.extra.featureType === \"class\") {\n        extra.tagNameType = 2 /* DynamicTag */;\n        extra.featureType = \"class\";\n        (currentProgramPath.node.extra ??= {}).needsCompat = true;\n      }\n    }\n  }\n  return extra.tagNameType;\n}\nfunction analyzeExpressionTagName(name2, extra) {\n  const pending = [name2];\n  let path5;\n  let type;\n  let nullable = false;\n  let tagNameImported;\n  while ((path5 = pending.pop()) && type !== 2 /* DynamicTag */) {\n    if (path5.isConditionalExpression()) {\n      pending.push(path5.get(\"consequent\"));\n      if (path5.node.alternate) {\n        pending.push(path5.get(\"alternate\"));\n      }\n    } else if (path5.isLogicalExpression()) {\n      if (path5.node.operator === \"||\") {\n        pending.push(path5.get(\"left\"));\n      } else {\n        nullable = true;\n      }\n      pending.push(path5.get(\"right\"));\n    } else if (path5.isAssignmentExpression()) {\n      pending.push(path5.get(\"right\"));\n    } else if (path5.isBinaryExpression()) {\n      type = path5.node.operator !== \"+\" || type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path5.isStringLiteral() || path5.isTemplateLiteral()) {\n      type = type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path5.isNullLiteral()) {\n      nullable = true;\n    } else if (path5.isIdentifier()) {\n      if (path5.node.name === \"undefined\") {\n        nullable = true;\n        continue;\n      }\n      const binding = path5.scope.getBinding(path5.node.name);\n      if (!binding) {\n        type = 2 /* DynamicTag */;\n        continue;\n      }\n      if (binding.kind === \"module\") {\n        const decl = binding.path.parent;\n        if (MARKO_FILE_REG.test(decl.source.value) && decl.specifiers.some((it) => import_compiler5.types.isImportDefaultSpecifier(it))) {\n          const resolvedImport = (0, import_babel_utils6.resolveTagImport)(name2, decl.source.value) || decl.source.value;\n          if (type === 0 /* NativeTag */ || tagNameImported && tagNameImported !== resolvedImport) {\n            type = 2 /* DynamicTag */;\n            tagNameImported = void 0;\n          } else {\n            type = 1 /* CustomTag */;\n            tagNameImported = resolvedImport;\n          }\n        } else {\n          type = 2 /* DynamicTag */;\n        }\n        continue;\n      }\n      const bindingTag = binding.path;\n      if (bindingTag.isMarkoTag() && binding.kind === \"local\") {\n        const bindingTagName = bindingTag.get(\"name\").node.value;\n        if (bindingTagName === \"const\") {\n          pending.push(\n            bindingTag.get(\"attributes\")[0].get(\"value\")\n          );\n          continue;\n        }\n        if (bindingTagName === \"let\") {\n          type = 2 /* DynamicTag */;\n          continue;\n        }\n        continue;\n      }\n      type = 2 /* DynamicTag */;\n    } else {\n      type = 2 /* DynamicTag */;\n    }\n  }\n  extra.tagNameType = type;\n  extra.tagNameNullable = nullable;\n  extra.tagNameDynamic = true;\n  if (type === 1 /* CustomTag */ && tagNameImported) {\n    extra.tagNameImported = tagNameImported;\n  }\n}\n\n// src/translator/util/sections.ts\nfunction startSection(path5) {\n  const extra = path5.node.extra ??= {};\n  let section = extra.section;\n  if (!section && (path5.type === \"Program\" || path5.get(\"body\").length)) {\n    const parentSection = path5.parentPath ? getOrCreateSection(path5.parentPath) : void 0;\n    const sectionNamePath = path5.parentPath?.get(\n      \"name\"\n    );\n    const sectionName = path5.isProgram() ? \"\" : currentProgramPath.scope.generateUid(\n      sectionNamePath.toString() + \"_content\"\n    );\n    const programExtra = path5.hub.file.path.node.extra ??= {};\n    const sections = programExtra.sections ??= [];\n    section = extra.section = {\n      id: sections.length,\n      name: sectionName,\n      loc: sectionNamePath?.node.loc || void 0,\n      depth: parentSection ? parentSection.depth + 1 : 0,\n      parent: parentSection,\n      params: void 0,\n      closures: void 0,\n      bindings: void 0,\n      assignments: void 0,\n      content: getContentInfo(path5),\n      upstreamExpression: void 0,\n      hasAbortSignal: false,\n      isBranch: false\n    };\n    sections.push(section);\n  }\n  return section;\n}\nfunction getOrCreateSection(path5) {\n  let cur = path5;\n  while (true) {\n    if (cur.type === \"Program\" || cur.type === \"MarkoTagBody\" && !cur.node.attributeTags && analyzeTagNameType(cur.parentPath) !== 0 /* NativeTag */ && cur.parent.name.value !== \"html-comment\") {\n      return startSection(cur);\n    }\n    cur = cur.parentPath;\n  }\n}\nfunction getSectionForBody(body) {\n  return body.node.extra?.section;\n}\nfunction getSection(path5) {\n  let section;\n  let currentPath = path5;\n  while ((section = currentPath.node.extra?.section) === void 0) {\n    currentPath = currentPath.parentPath;\n  }\n  return section;\n}\nvar [getScopeIdIdentifier] = createSectionState(\n  \"scopeIdIdentifier\",\n  (section) => currentProgramPath.scope.generateUidIdentifier(`scope${section.id}_id`)\n);\nvar [getSectionParentIsOwner, setSectionParentIsOwner] = createSectionState(\"parentIsOwner\", () => false);\nvar [_getScopeIdentifier] = createSectionState(\n  \"scopeIdentifier\",\n  () => import_compiler6.types.identifier(\"undefined\")\n);\nvar getScopeIdentifier = (section, ignoreDefault) => {\n  const scopeId = _getScopeIdentifier(section);\n  if (!ignoreDefault && scopeId.name === \"undefined\") {\n    scopeId.name = currentProgramPath.scope.generateUid(`scope${section.id}_`);\n  }\n  return scopeId;\n};\nfunction forEachSection(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  sections?.forEach(fn);\n}\nfunction forEachSectionReverse(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  for (let i = sections.length; i--; ) {\n    fn(sections[i]);\n  }\n}\nfunction getContentInfo(path5) {\n  const body = path5.get(\"body\");\n  const contentInfo = {\n    startType: null,\n    endType: null,\n    singleChild: true\n  };\n  for (let endIndex = body.length; endIndex--; ) {\n    const endType = getNodeContentType(body[endIndex], \"endType\", contentInfo);\n    if (endType !== null) {\n      contentInfo.endType = endType;\n      for (let startIndex = 0; startIndex < endIndex; startIndex++) {\n        const startType = getNodeContentType(body[startIndex], \"startType\");\n        if (startType !== null) {\n          contentInfo.startType = startType;\n          contentInfo.singleChild = false;\n          return contentInfo;\n        }\n      }\n      contentInfo.startType = getNodeContentType(body[endIndex], \"startType\");\n      return contentInfo;\n    }\n  }\n  return null;\n}\nfunction getNodeContentType(path5, extraMember, contentInfo) {\n  switch (path5.type) {\n    case \"MarkoText\":\n      return 4 /* Text */;\n    case \"MarkoPlaceholder\":\n      return 2 /* Placeholder */;\n    case \"MarkoScriptlet\":\n    case \"MarkoComment\":\n    case \"ImportDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportNamedDeclaration\":\n      return null;\n    case \"MarkoTag\": {\n      const tag = path5;\n      if (isCoreTag(tag)) {\n        switch (tag.node.name.value) {\n          case \"html-comment\":\n            return 0 /* Comment */;\n          case \"html-script\":\n          case \"html-style\":\n            return 3 /* Tag */;\n          case \"for\":\n          case \"if\":\n            return 1 /* Dynamic */;\n          default:\n            return null;\n        }\n      } else if ((0, import_babel_utils7.isNativeTag)(tag)) {\n        return 3 /* Tag */;\n      } else if ((0, import_babel_utils7.isAttributeTag)(tag)) {\n        return null;\n      } else if (import_compiler6.types.isStringLiteral(tag.node.name)) {\n        const tagSection = (0, import_babel_utils7.loadFileForTag)(tag)?.ast.program.extra.section;\n        if (tagSection) {\n          if (tagSection.content) {\n            if (contentInfo && !tagSection.content.singleChild) {\n              if (extraMember === \"endType\") {\n                contentInfo.startType = tagSection.content.startType;\n                contentInfo.singleChild = false;\n              }\n            }\n            return tagSection.content[extraMember];\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n  }\n  return 1 /* Dynamic */;\n}\nvar isStatefulSection = (section) => {\n  const upstreamExpression = section.upstreamExpression;\n  return !upstreamExpression || isStatefulReferences(upstreamExpression.referencedBindings);\n};\nvar checkStatefulClosures = (section, immediateOnly) => {\n  return !!find(\n    section.closures,\n    (closure) => (!immediateOnly || section.parent === closure.section) && isStatefulReferences(closure)\n  );\n};\n\n// src/translator/visitors/program/dom.ts\nvar import_compiler18 = require(\"@marko/compiler\");\nvar import_babel_utils10 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-style-file.ts\nvar import_path = __toESM(require(\"path\"));\nfunction getStyleFile(file) {\n  const { filename } = file.opts;\n  const fs = file.markoOpts.fileSystem;\n  const base = getBase(filename);\n  const styleMatch = new RegExp(\n    `^(${escapeRegExp(base)}\\\\.${\"index\" === base ? \"|\" : \"\"})style\\\\.\\\\w+$`\n  );\n  for (const file2 of fs.readdirSync(import_path.default.dirname(filename)).sort()) {\n    if (styleMatch.test(file2)) {\n      return `./${file2}`;\n    }\n  }\n}\nfunction getBase(filename) {\n  const start = filename.lastIndexOf(import_path.default.sep) + 1;\n  const leftDot = filename.indexOf(\".\", start);\n  if (leftDot === -1) {\n    return filename.slice(start);\n  }\n  const rightDot = filename.lastIndexOf(\".\");\n  const closeBracket = leftDot - 1;\n  if (filename[closeBracket] === \"]\") {\n    const openBracket = filename.lastIndexOf(\"[\", closeBracket);\n    if (openBracket > start) {\n      return filename.slice(start, openBracket) + filename.slice(leftDot, rightDot);\n    }\n  }\n  return filename.slice(start, rightDot);\n}\nvar regexpCharsReg = /[\\\\^$.*+?()[\\]{}|]/g;\nfunction escapeRegExp(str) {\n  return str.replace(regexpCharsReg, \"\\\\$&\");\n}\n\n// src/translator/util/signals.ts\nvar import_compiler17 = require(\"@marko/compiler\");\nvar import_babel_utils9 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/core/return.ts\nvar import_compiler11 = require(\"@marko/compiler\");\nvar import_babel_utils8 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-known-attr-values.ts\nfunction getKnownAttrValues(tag) {\n  const attrs2 = {};\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      attrs2[attr2.name] = attr2.value;\n    }\n  }\n  return attrs2;\n}\n\n// src/translator/util/get-parent-tag.ts\nfunction getParentTag(tag) {\n  const parent = tag.parent.type === \"MarkoTagBody\" ? tag.parentPath.parentPath : tag.parentPath;\n  if (parent.type === \"MarkoTag\") {\n    return parent;\n  }\n}\n\n// src/translator/util/plugin-hooks.ts\nvar import_compiler7 = require(\"@marko/compiler\");\nfunction enter(modulePlugin, path5) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path5;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (isFunctionPlugin(plugin)) {\n    plugin(path5, import_compiler7.types);\n  } else if (plugin.enter) {\n    plugin.enter(path5, import_compiler7.types);\n  }\n  return node !== path5.node;\n}\nfunction exit(modulePlugin, path5) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path5;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (!isFunctionPlugin(plugin) && plugin.exit) {\n    plugin.exit(path5, import_compiler7.types);\n  }\n  return node !== path5.node;\n}\nfunction isModulePlugin(plugin) {\n  return Boolean(plugin.default);\n}\nfunction isFunctionPlugin(plugin) {\n  return typeof plugin === \"function\";\n}\n\n// src/translator/util/visitors.ts\nfunction extractVisitors(visitors2) {\n  const result = {\n    migrate: {},\n    transform: {},\n    analyze: {},\n    translate: {}\n  };\n  for (const _name in visitors2) {\n    const name2 = _name;\n    const value = visitors2[name2];\n    if (value.migrate) result.migrate[name2] = value.migrate;\n    if (value.transform) result.transform[name2] = value.transform;\n    if (value.analyze) result.analyze[name2] = value.analyze;\n    if (value.translate) result.translate[name2] = value.translate;\n  }\n  return result;\n}\nfunction translateByTarget({\n  html,\n  dom\n}) {\n  return {\n    enter(path5) {\n      enter(isOutputHTML() ? html : dom, path5);\n    },\n    exit(path5) {\n      exit(isOutputHTML() ? html : dom, path5);\n    }\n  };\n}\n\n// src/translator/util/writer.ts\nvar import_compiler10 = require(\"@marko/compiler\");\n\n// src/translator/util/normalize-string-expression.ts\nvar import_compiler8 = require(\"@marko/compiler\");\nfunction normalizeStringExpression(parts) {\n  const strs = [];\n  const exprs = [];\n  let curStr = parts[0];\n  for (let i = 1; i < parts.length; i++) {\n    let content = parts[i];\n    if (typeof content === \"object\") {\n      if (import_compiler8.types.isStringLiteral(content)) {\n        content = content.value;\n      } else if (import_compiler8.types.isTemplateLiteral(content)) {\n        let nextIndex = i + 1;\n        const exprLen = content.expressions.length;\n        shiftItems(parts, nextIndex, content.quasis.length + exprLen);\n        for (let j = 0; j < exprLen; j++) {\n          parts[nextIndex++] = content.quasis[j].value.raw;\n          parts[nextIndex++] = content.expressions[j];\n        }\n        parts[nextIndex] = content.quasis[exprLen].value.raw;\n        continue;\n      } else {\n        exprs.push(content);\n        strs.push(curStr);\n        curStr = \"\";\n        continue;\n      }\n    }\n    curStr += content;\n  }\n  if (exprs.length) {\n    if (exprs.length === 1 && !curStr && !strs[0]) {\n      return exprs[0];\n    }\n    strs.push(curStr);\n    return import_compiler8.types.templateLiteral(\n      strs.map((raw) => import_compiler8.types.templateElement({ raw })),\n      exprs\n    );\n  } else if (curStr) {\n    return import_compiler8.types.stringLiteral(curStr);\n  }\n}\nfunction appendLiteral(arr, str) {\n  arr[arr.length - 1] += str;\n}\nfunction shiftItems(list, start, offset) {\n  for (let i = list.length - 1; i >= start; i--) {\n    list[i + offset] = list[i];\n  }\n}\n\n// src/translator/util/walks.ts\nvar import_compiler9 = require(\"@marko/compiler\");\nvar [getWalks] = createSectionState(\n  \"walks\",\n  () => [\"\"]\n);\nvar [getWalkComment] = createSectionState(\n  \"walkComment\",\n  () => []\n);\nvar [getSteps] = createSectionState(\"steps\", () => []);\nvar walkCodeToName = {\n  [32 /* Get */]: \"get\",\n  [36 /* Inside */]: \"inside\",\n  [37 /* Replace */]: \"replace\",\n  [38 /* EndChild */]: \"endChild\",\n  [47 /* BeginChild */]: \"beginChild\",\n  [67 /* Next */]: \"next\",\n  [97 /* Over */]: \"over\",\n  [107 /* Out */]: \"out\",\n  [117 /* Multiplier */]: \"multiplier\",\n  [91 /* NextEnd */]: \"nextEnd\",\n  [106 /* OverEnd */]: \"overEnd\",\n  [116 /* OutEnd */]: \"outEnd\",\n  [126 /* MultiplierEnd */]: \"multiplierEnd\"\n};\nfunction enter2(path5) {\n  getSteps(getSection(path5)).push(0 /* Enter */);\n}\nfunction exit2(path5) {\n  getSteps(getSection(path5)).push(1 /* Exit */);\n}\nfunction enterShallow(path5) {\n  getSteps(getSection(path5)).push(0 /* Enter */, 1 /* Exit */);\n}\nfunction injectWalks(path5, expr) {\n  const walks = getWalks(getSection(path5));\n  const walkComment = getWalkComment(getSection(path5));\n  walkComment.push(\n    `${walkCodeToName[47 /* BeginChild */]}`,\n    expr.name,\n    walkCodeToName[38 /* EndChild */]\n  );\n  appendLiteral(walks, String.fromCharCode(47 /* BeginChild */));\n  walks.push(expr, String.fromCharCode(38 /* EndChild */));\n}\nfunction visit(path5, code) {\n  if (isOutputHTML()) {\n    return;\n  }\n  const section = getSection(path5);\n  const steps = getSteps(section);\n  const walks = getWalks(section);\n  const walkComment = getWalkComment(section);\n  let walkString = \"\";\n  if (steps.length) {\n    const walkCodes = [];\n    let depth = 0;\n    for (const step of steps) {\n      if (step === 0 /* Enter */) {\n        depth++;\n        walkCodes.push(67 /* Next */);\n      } else {\n        depth--;\n        if (depth >= 0) {\n          walkCodes.length = walkCodes.lastIndexOf(67 /* Next */);\n          walkCodes.push(97 /* Over */);\n        } else {\n          walkCodes.length = walkCodes.lastIndexOf(107 /* Out */) + 1;\n          walkCodes.push(107 /* Out */);\n          depth = 0;\n        }\n      }\n    }\n    let current = walkCodes[0];\n    let count = 0;\n    for (const walk of walkCodes) {\n      if (walk !== current) {\n        walkComment.push(`${walkCodeToName[current]}(${count})`);\n        walkString += nCodeString(current, count);\n        current = walk;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n    walkComment.push(`${walkCodeToName[current]}(${count})`);\n    walkString += nCodeString(current, count);\n    steps.length = 0;\n  }\n  if (code !== void 0) {\n    if (code !== 32 /* Get */) {\n      writeTo(path5)`<!>`;\n    }\n    walkComment.push(`${walkCodeToName[code]}`);\n    walkString += String.fromCharCode(code);\n  }\n  appendLiteral(walks, walkString);\n}\nfunction nCodeString(code, number) {\n  switch (code) {\n    case 67 /* Next */:\n      return toCharString(number, code, 20 /* Next */);\n    case 97 /* Over */:\n      return toCharString(number, code, 10 /* Over */);\n    case 107 /* Out */:\n      return toCharString(number, code, 10 /* Out */);\n    default:\n      throw new Error(`Unexpected walk code: ${code}`);\n  }\n}\nfunction toCharString(number, startCode, rangeSize) {\n  let result = \"\";\n  if (number >= rangeSize) {\n    const multiplier = Math.floor(number / rangeSize);\n    result += toCharString(\n      multiplier,\n      117 /* Multiplier */,\n      10 /* Multiplier */\n    );\n    number -= multiplier * rangeSize;\n  }\n  result += String.fromCharCode(startCode + number);\n  return result;\n}\nfunction getWalkString(section) {\n  const prefix2 = section.content?.startType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const postfix = section.content?.endType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const walks = getWalks(section);\n  const walkLiteral = normalizeStringExpression([prefix2, ...walks, postfix]) || import_compiler9.types.stringLiteral(\"\");\n  if (walkLiteral.value !== \"\") {\n    walkLiteral.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: \" \" + getWalkComment(section).join(\", \") + \" \"\n      }\n    ];\n  }\n  return walkLiteral;\n}\n\n// src/translator/util/writer.ts\nvar [getWrites] = createSectionState(\n  \"writes\",\n  () => [\"\"]\n);\nvar [getTrailerWrites] = createSectionState(\n  \"trailerWrites\",\n  () => [\"\"]\n);\nfunction writeTo(path5, trailer) {\n  const section = getSection(path5);\n  const get = trailer ? getTrailerWrites : getWrites;\n  return (strs, ...exprs) => {\n    const exprsLen = exprs.length;\n    const writes = get(section);\n    appendLiteral(writes, strs[0]);\n    for (let i = 0; i < exprsLen; i++) {\n      writes.push(exprs[i], strs[i + 1]);\n    }\n  };\n}\nfunction consumeHTML(path5) {\n  const section = getSection(path5);\n  const writes = getWrites(section);\n  const trailers = getTrailerWrites(section);\n  const writeResult = normalizeStringExpression(writes);\n  const trailerResult = normalizeStringExpression(trailers);\n  writes.length = 0;\n  writes[0] = \"\";\n  trailers.length = 0;\n  trailers[0] = \"\";\n  if (writeResult && trailerResult) {\n    return import_compiler10.types.expressionStatement(\n      import_compiler10.types.sequenceExpression([\n        callRuntime(\"write\", writeResult),\n        callRuntime(\"writeTrailers\", trailerResult)\n      ])\n    );\n  } else if (writeResult) {\n    return import_compiler10.types.expressionStatement(callRuntime(\"write\", writeResult));\n  } else if (trailerResult) {\n    return import_compiler10.types.expressionStatement(callRuntime(\"writeTrailers\", trailerResult));\n  }\n}\nfunction flushBefore(path5) {\n  const expr = consumeHTML(path5);\n  if (expr) {\n    path5.insertBefore(expr)[0].skip();\n  }\n}\nfunction flushInto(path5) {\n  const target = path5.isProgram() ? path5 : path5.get(\"body\");\n  const expr = consumeHTML(target);\n  if (expr) {\n    target.pushContainer(\"body\", expr)[0].skip();\n  }\n}\nfunction getSectionMeta(section) {\n  const writePrefix = section.content?.startType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writePostfix = section.content?.endType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writes = getWrites(section);\n  return {\n    setup: getSetup(section),\n    walks: getWalkString(section),\n    writes: normalizeStringExpression([writePrefix, ...writes, writePostfix]) || import_compiler10.types.stringLiteral(\"\")\n  };\n}\nfunction markNode(path5, binding) {\n  const section = getSection(path5);\n  if (binding.type !== 0 /* dom */) {\n    throw path5.buildCodeFrameError(\n      \"Tried to mark a node that was not determined to need a mark during analyze.\"\n    );\n  }\n  if (isOutputHTML()) {\n    writeTo(path5)`${callRuntime(\n      \"markResumeNode\",\n      getScopeIdIdentifier(section),\n      getScopeAccessorLiteral(binding)\n    )}`;\n  }\n}\n\n// src/translator/core/return.ts\nvar tagsWithReturn = /* @__PURE__ */ new WeakSet();\nvar [getSectionReturnValueIdentifier, setReturnValueIdentifier] = createSectionState(\"returnValue\");\nvar return_default = {\n  analyze(tag) {\n    (0, import_babel_utils8.assertNoArgs)(tag);\n    (0, import_babel_utils8.assertNoVar)(tag);\n    (0, import_babel_utils8.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils8.assertAllowedAttributes)(tag, [\"value\", \"valueChange\"]);\n    const parentTag = getParentTag(tag);\n    if (parentTag) {\n      if ((0, import_babel_utils8.isNativeTag)(parentTag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The `return` tag can not be used in a native tag.\"\n        );\n      } else if (isControlFlowTag(parentTag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          `The \\`return\\` tag can not be used under an \\`${parentTag.get(\"name\").toString()}\\` tag.`\n        );\n      }\n    }\n    if (tagsWithReturn.has(tag.parentPath)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        `Cannot have multiple \\`return\\` tags ${tag.parent.type === \"Program\" ? \"for the template\" : \"within a tag's body content\"}.`\n      );\n    } else {\n      tagsWithReturn.add(tag.parentPath);\n    }\n    if (!getKnownAttrValues(tag.node).value) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `return` tag requires a value.\");\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      exit(tag) {\n        const section = getSection(tag);\n        const attrs2 = getKnownAttrValues(tag.node);\n        flushBefore(tag);\n        if (attrs2.valueChange) {\n          getSerializedScopeProperties(section).set(\n            import_compiler11.types.stringLiteral(\"@\" /* TagVariableChange */),\n            attrs2.valueChange\n          );\n        }\n        if (attrs2.value) {\n          const returnId = tag.scope.generateUidIdentifier(\"return\");\n          setReturnValueIdentifier(section, returnId);\n          tag.replaceWith(\n            import_compiler11.types.variableDeclaration(\"const\", [\n              import_compiler11.types.variableDeclarator(returnId, attrs2.value)\n            ])\n          )[0].skip();\n        }\n      }\n    },\n    dom: {\n      exit(tag) {\n        const section = getSection(tag);\n        const attrs2 = getKnownAttrValues(tag.node);\n        if (attrs2.value) {\n          addValue(\n            section,\n            attrs2.value.extra?.referencedBindings,\n            {\n              identifier: importRuntime(\"tagVarSignal\"),\n              hasDownstreamIntersections: () => true\n            },\n            attrs2.value\n          );\n        }\n        if (attrs2.valueChange) {\n          addValue(\n            section,\n            attrs2.valueChange.extra?.referencedBindings,\n            {\n              identifier: importRuntime(\"setTagVarChange\"),\n              hasDownstreamIntersections: () => false\n            },\n            attrs2.valueChange\n          );\n        }\n        tag.remove();\n      }\n    }\n  }),\n  parseOptions: {\n    openTagOnly: true\n  },\n  autocomplete: [\n    {\n      displayText: \"return=<value>\",\n      description: \"Provides a value for use in a parent template.\",\n      snippet: \"return=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#return\"\n    }\n  ]\n};\n\n// src/translator/util/for-each-identifier.ts\nfunction forEachIdentifier(node, cb) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        switch (prop.type) {\n          case \"ObjectProperty\":\n            if (prop.value.type === \"AssignmentPattern\") {\n              forEachIdentifier(prop.value.left, cb);\n            } else {\n              forEachIdentifier(prop.value, cb);\n            }\n            break;\n          case \"RestElement\":\n            forEachIdentifier(prop.argument, cb);\n            break;\n        }\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const el of node.elements) {\n        if (el != null) {\n          switch (el.type) {\n            case \"RestElement\":\n              forEachIdentifier(el.argument, cb);\n              break;\n            case \"AssignmentPattern\":\n              forEachIdentifier(el.left, cb);\n              break;\n            default:\n              forEachIdentifier(el, cb);\n              break;\n          }\n        }\n      }\n      break;\n    case \"Identifier\":\n      cb(node);\n      break;\n  }\n}\n\n// src/translator/util/get-defined-binding-expression.ts\nvar import_compiler12 = require(\"@marko/compiler\");\nfunction getDeclaredBindingExpression(binding) {\n  if (binding.declared || !binding.upstreamAlias) {\n    return import_compiler12.types.identifier(binding.name);\n  } else if (binding.property !== void 0) {\n    return toMemberExpression(\n      getDeclaredBindingExpression(binding.upstreamAlias),\n      binding.property,\n      binding.upstreamAlias.nullable\n    );\n  } else {\n    return getDeclaredBindingExpression(binding.upstreamAlias);\n  }\n}\n\n// src/translator/util/scope-read.ts\nvar import_compiler13 = require(\"@marko/compiler\");\nfunction createScopeReadPattern(section, referencedBindings) {\n  const rootDepth = section.depth;\n  const rootPattern = import_compiler13.types.objectPattern([]);\n  let nestedPatterns;\n  forEach(referencedBindings, (ref) => {\n    if (ref.name.includes(\"#\")) return;\n    const propertyKey = getScopeAccessorLiteral(ref);\n    const propertyValue = import_compiler13.types.identifier(ref.name);\n    const isShorthand = propertyKey.value === propertyValue.name;\n    let pattern = rootPattern;\n    if (ref.section !== section) {\n      if (!nestedPatterns) nestedPatterns = [rootPattern];\n      const relativeDepth = rootDepth - ref.section.depth;\n      let i = nestedPatterns.length;\n      let prev = nestedPatterns[i - 1];\n      for (; i <= relativeDepth; i++) {\n        const nestedPattern = import_compiler13.types.objectPattern([]);\n        prev.properties.push(\n          import_compiler13.types.objectProperty(import_compiler13.types.identifier(\"_\"), nestedPattern)\n        );\n        nestedPatterns.push(nestedPattern);\n        prev = nestedPattern;\n      }\n      pattern = nestedPatterns[relativeDepth];\n    }\n    pattern.properties.push(\n      import_compiler13.types.objectProperty(\n        isShorthand ? propertyValue : propertyKey,\n        propertyValue,\n        false,\n        isShorthand\n      )\n    );\n  });\n  return rootPattern;\n}\nfunction getScopeExpression(section, targetSection) {\n  let scope = scopeIdentifier ?? import_compiler13.types.identifier(\"undefined\");\n  const diff = section.depth - targetSection.depth;\n  for (let i = 0; i < diff; i++) {\n    scope = import_compiler13.types.memberExpression(scope, import_compiler13.types.identifier(\"_\"));\n  }\n  if (diff < 0) {\n    throw new Error(\"Unable to find scope for reference.\");\n  }\n  return scope;\n}\nfunction createScopeReadExpression(section, reference) {\n  return import_compiler13.types.memberExpression(\n    getScopeExpression(section, reference.section),\n    getScopeAccessorLiteral(reference),\n    true\n  );\n}\n\n// src/translator/util/simplify-fn.ts\nvar import_compiler14 = require(\"@marko/compiler\");\nfunction simplifyFunction(fn) {\n  switch (fn.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return fn;\n    default:\n      return import_compiler14.types.functionExpression(\n        null,\n        fn.params,\n        fn.body,\n        fn.async,\n        fn.generator\n      );\n  }\n}\n\n// src/translator/util/to-first-expression-or-block.ts\nvar import_compiler15 = require(\"@marko/compiler\");\nfunction toFirstExpressionOrBlock(stmts) {\n  if (stmts.length === 1 && import_compiler15.types.isExpressionStatement(stmts[0])) {\n    const { expression } = stmts[0];\n    switch (expression.type) {\n      case \"ObjectExpression\":\n      case \"AssignmentExpression\":\n        return toParenthesizedExpressionIfNeeded(expression);\n      default:\n        return expression;\n    }\n  }\n  return import_compiler15.types.blockStatement(stmts);\n}\nfunction toParenthesizedExpressionIfNeeded(expr) {\n  switch (expr.type) {\n    case \"ObjectExpression\":\n    case \"AssignmentExpression\":\n      return import_compiler15.types.parenthesizedExpression(expr);\n    default:\n      return expr;\n  }\n}\n\n// src/translator/util/traverse.ts\nvar import_compiler16 = require(\"@marko/compiler\");\nvar skip = Symbol(\"skip\");\nfunction traverseReplace(container, key, enter3) {\n  const node = container[key];\n  if (node) {\n    if (Array.isArray(node)) {\n      for (let i = node.length; i--; ) {\n        traverseReplace(node, i, enter3);\n      }\n    } else {\n      const keys = import_compiler16.types.VISITOR_KEYS[node.type];\n      for (let i = keys.length; i--; ) {\n        traverseReplace(node, keys[i], enter3);\n      }\n      const replacement = enter3(node, container, key);\n      if (replacement) container[key] = replacement;\n    }\n  }\n}\nfunction traverseContains(node, check) {\n  if (node) {\n    if (Array.isArray(node)) {\n      for (const item of node) {\n        if (traverseContains(item, check)) {\n          return true;\n        }\n      }\n    } else {\n      switch (check(node)) {\n        case true:\n          return true;\n        case skip:\n          return false;\n      }\n      for (const key of import_compiler16.types.VISITOR_KEYS[node.type]) {\n        if (traverseContains(node[key], check)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n// src/translator/util/signals.ts\nvar [getSignals] = createSectionState(\n  \"signals\",\n  () => /* @__PURE__ */ new Map()\n);\nvar [getClosureSignalBuilder, _setClosureSignalBuilder] = createSectionState(\"queue\");\nfunction setClosureSignalBuilder(tag, builder) {\n  _setClosureSignalBuilder(getSectionForBody(tag.get(\"body\")), builder);\n}\nvar [forceResumeScope, _setForceResumeScope] = createSectionState(\"forceResumeScope\");\nfunction setForceResumeScope(section) {\n  _setForceResumeScope(section, true);\n}\nvar [getSerializedScopeProperties] = createSectionState(\"serializedScopeProperties\", () => /* @__PURE__ */ new Map());\nvar unimplementedBuild = () => {\n  return import_compiler17.types.stringLiteral(\"SIGNAL NOT INITIALIZED\");\n};\nfunction getSignal(section, referencedBindings, name2 = generateSignalName(referencedBindings)) {\n  const signals = getSignals(section);\n  let signal = signals.get(referencedBindings);\n  if (!signal) {\n    const exportName = referencedBindings ? !Array.isArray(referencedBindings) && referencedBindings.section === section && referencedBindings.export : !section.parent && currentProgramPath.node.extra.domExports?.setup;\n    signals.set(\n      referencedBindings,\n      signal = {\n        identifier: exportName ? import_compiler17.types.identifier(exportName) : currentProgramPath.scope.generateUidIdentifier(\n          name2 + section.name.replace(\"_\", \"$\")\n        ),\n        referencedBindings,\n        section,\n        values: [],\n        intersection: void 0,\n        render: [],\n        renderReferencedBindings: void 0,\n        effect: [],\n        effectReferencedBindings: void 0,\n        subscribers: [],\n        closures: /* @__PURE__ */ new Map(),\n        hasDownstreamIntersections: () => {\n          let hasDownstreamIntersections = !!signal.intersection;\n          if (!hasDownstreamIntersections) {\n            for (const value of signal.values) {\n              if (value.signal.hasDownstreamIntersections()) {\n                hasDownstreamIntersections = true;\n                break;\n              }\n            }\n          }\n          if (!hasDownstreamIntersections) {\n            if (!Array.isArray(referencedBindings) && referencedBindings) {\n              for (const alias of referencedBindings.aliases) {\n                if (getSignal(section, alias).hasDownstreamIntersections()) {\n                  hasDownstreamIntersections = true;\n                  break;\n                }\n              }\n              if (!hasDownstreamIntersections) {\n                for (const [, alias] of referencedBindings.propertyAliases) {\n                  if (getSignal(section, alias).hasDownstreamIntersections()) {\n                    hasDownstreamIntersections = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          signal.hasDownstreamIntersections = () => hasDownstreamIntersections;\n          return hasDownstreamIntersections;\n        },\n        build: unimplementedBuild,\n        export: !!exportName\n      }\n    );\n    if (isOutputHTML()) {\n      return signal;\n    } else if (!referencedBindings) {\n      signal.build = () => getSignalFn(signal, [scopeIdentifier]);\n    } else if (Array.isArray(referencedBindings)) {\n      subscribe(referencedBindings, signal);\n      signal.build = () => {\n        return callRuntime(\n          \"intersection\",\n          import_compiler17.types.numericLiteral(referencedBindings.length),\n          getSignalFn(signal, [scopeIdentifier], referencedBindings),\n          buildSignalIntersections(signal)\n        );\n      };\n    } else if (referencedBindings.section !== section && bindingUtil.find(section.closures, referencedBindings)) {\n      getSignal(referencedBindings.section, referencedBindings).closures.set(\n        section,\n        signal\n      );\n      signal.build = () => {\n        const builder = getClosureSignalBuilder(section);\n        const ownerScope = getScopeExpression(\n          section,\n          referencedBindings.section\n        );\n        const isImmediateOwner = ownerScope.object === scopeIdentifier;\n        const isDynamicClosure = !isImmediateOwner || !builder;\n        const render = getSignalFn(signal, [\n          scopeIdentifier,\n          import_compiler17.types.identifier(referencedBindings.name)\n        ]);\n        signal.isDynamicClosure = isDynamicClosure;\n        const intersection = buildSignalIntersections(signal);\n        return isDynamicClosure ? callRuntime(\n          \"dynamicClosure\",\n          render,\n          isImmediateOwner ? null : import_compiler17.types.arrowFunctionExpression([scopeIdentifier], ownerScope),\n          intersection\n        ) : builder(signal, render, intersection);\n      };\n      addStatement(\n        \"render\",\n        section,\n        void 0,\n        import_compiler17.types.expressionStatement(\n          import_compiler17.types.callExpression(\n            import_compiler17.types.memberExpression(signal.identifier, import_compiler17.types.identifier(\"_\")),\n            [\n              scopeIdentifier,\n              createScopeReadExpression(section, referencedBindings)\n            ]\n          )\n        )\n      );\n    }\n  }\n  return signal;\n}\nfunction initValue(binding, runtimeHelper = \"value\") {\n  const valueAccessor = getScopeAccessorLiteral(binding);\n  const section = binding.section;\n  const signal = getSignal(section, binding);\n  signal.build = () => {\n    const fn = getSignalFn(signal, [\n      scopeIdentifier,\n      import_compiler17.types.identifier(binding.name)\n    ]);\n    const intersections = buildSignalIntersections(signal);\n    const isParamBinding = !binding.upstreamAlias && (binding.type === 3 /* param */ || binding.type === 2 /* input */);\n    const isNakedAlias = binding.upstreamAlias && !binding.property;\n    const needsGuard = !isNakedAlias && (binding.downstreamExpressions.size || fn.body.body.length > 0);\n    const needsCache = needsGuard || intersections;\n    const needsMarks = isParamBinding || intersections;\n    if (needsCache || needsMarks) {\n      return callRuntime(runtimeHelper, valueAccessor, fn, intersections);\n    } else {\n      return fn;\n    }\n  };\n  signal.valueAccessor = valueAccessor;\n  for (const alias of binding.aliases) {\n    initValue(alias);\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    initValue(alias);\n  }\n  return signal;\n}\nfunction getSignalFn(signal, params, referencedBindings) {\n  const section = signal.section;\n  const binding = signal.referencedBindings;\n  const [scopeIdentifier2, valueIdentifier] = params;\n  const isValueSignal = binding && !Array.isArray(binding) && binding.section === section;\n  if (isValueSignal) {\n    for (const alias of binding.aliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler17.types.expressionStatement(\n          import_compiler17.types.callExpression(aliasSignal.identifier, [\n            scopeIdentifier2,\n            valueIdentifier,\n            ...getTranslatedExtraArgs(aliasSignal)\n          ])\n        )\n      );\n    }\n    for (const [key, alias] of binding.propertyAliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler17.types.expressionStatement(\n          import_compiler17.types.callExpression(aliasSignal.identifier, [\n            scopeIdentifier2,\n            toMemberExpression(valueIdentifier, key, binding.nullable),\n            ...getTranslatedExtraArgs(aliasSignal)\n          ])\n        )\n      );\n    }\n  }\n  for (const value of signal.values) {\n    signal.render.push(\n      import_compiler17.types.expressionStatement(\n        import_compiler17.types.callExpression(value.signal.identifier, [\n          value.scope,\n          value.value,\n          ...getTranslatedExtraArgs(value.signal)\n        ])\n      )\n    );\n  }\n  if (isValueSignal) {\n    const closureEntries = Array.from(signal.closures.entries()).sort(\n      ([a], [b]) => a.id - b.id\n    );\n    for (const [_closureSection, closureSignal] of closureEntries) {\n      if (isStatefulReferences(closureSignal.referencedBindings)) {\n        signal.render.push(\n          import_compiler17.types.expressionStatement(\n            import_compiler17.types.callExpression(closureSignal.identifier, [\n              scopeIdentifier2,\n              valueIdentifier\n            ])\n          )\n        );\n      }\n    }\n  }\n  if (referencedBindings) {\n    signal.render.unshift(\n      import_compiler17.types.variableDeclaration(\"const\", [\n        import_compiler17.types.variableDeclarator(\n          createScopeReadPattern(section, referencedBindings),\n          scopeIdentifier2\n        )\n      ])\n    );\n  }\n  return import_compiler17.types.arrowFunctionExpression(params, import_compiler17.types.blockStatement(signal.render));\n}\nvar hasTranslatedExtraArgs = /* @__PURE__ */ new WeakSet();\nvar emptyExtraArgs = [];\nfunction getTranslatedExtraArgs(signal) {\n  if (signal.extraArgs) {\n    if (!hasTranslatedExtraArgs.has(signal)) {\n      hasTranslatedExtraArgs.add(signal);\n      traverseReplace(signal, \"extraArgs\", replaceRenderNode);\n    }\n    return signal.extraArgs;\n  }\n  return emptyExtraArgs;\n}\nfunction buildSignalIntersections(signal) {\n  let intersections = signal.intersection;\n  const binding = signal.referencedBindings;\n  if (binding && !Array.isArray(binding) && binding.section === signal.section) {\n    for (const alias of binding.aliases) {\n      const signal2 = getSignal(alias.section, alias);\n      if (signal2.hasDownstreamIntersections()) {\n        intersections = push(\n          intersections,\n          import_compiler17.types.identifier(signal2.identifier.name)\n        );\n      }\n    }\n    for (const [, alias] of binding.propertyAliases) {\n      const signal2 = getSignal(alias.section, alias);\n      if (signal2.hasDownstreamIntersections()) {\n        intersections = push(\n          intersections,\n          import_compiler17.types.identifier(signal2.identifier.name)\n        );\n      }\n    }\n  }\n  for (const value of signal.values) {\n    if (value.signal.hasDownstreamIntersections()) {\n      intersections = push(\n        intersections,\n        value.intersectionExpression ?? (import_compiler17.types.isMemberExpression(value.signal.identifier) ? value.signal.identifier : import_compiler17.types.identifier(value.signal.identifier.name))\n      );\n    }\n  }\n  return intersections && import_compiler17.types.arrowFunctionExpression(\n    [],\n    Array.isArray(intersections) ? callRuntime(\"intersections\", import_compiler17.types.arrayExpression(intersections)) : intersections\n  );\n}\nfunction subscribe(provider, subscriber) {\n  if (Array.isArray(provider)) {\n    provider.forEach((p) => subscribe(p, subscriber));\n    return;\n  }\n  const providerSignal = getSignal(subscriber.section, provider);\n  providerSignal.intersection = push(\n    providerSignal.intersection,\n    subscriber.identifier\n  );\n}\nfunction generateSignalName(referencedBindings) {\n  let name2;\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      name2 = \"expr\";\n      for (const ref of referencedBindings) {\n        name2 += `_${ref.name}`;\n      }\n    } else {\n      name2 = referencedBindings.name;\n    }\n  } else {\n    name2 = \"setup\";\n  }\n  return name2;\n}\nfunction finalizeSignalArgs(args) {\n  for (let i = args.length - 1; i >= 0; i--) {\n    const arg = args[i];\n    if (import_compiler17.types.isArrowFunctionExpression(arg) && import_compiler17.types.isBlockStatement(arg.body)) {\n      const body = arg.body.body;\n      if (body.length === 0) {\n        args[i] = import_compiler17.types.numericLiteral(0);\n      } else if (body.length === 1 && import_compiler17.types.isExpressionStatement(body[0])) {\n        arg.body = toParenthesizedExpressionIfNeeded(body[0].expression);\n      }\n    }\n  }\n  for (let i = args.length - 1; import_compiler17.types.isNullLiteral(args[i]); ) {\n    args.length = i--;\n  }\n}\nfunction addStatement(type, targetSection, referencedBindings, statement, usedReferences) {\n  const signal = getSignal(targetSection, referencedBindings);\n  const statements = signal[type] ??= [];\n  const add = type === \"effect\" ? addEffectReferences : addRenderReferences;\n  if (Array.isArray(statement)) {\n    statements.push(...statement);\n  } else {\n    statements.push(statement);\n  }\n  if (usedReferences !== false) {\n    if (usedReferences) {\n      for (const ref of usedReferences) {\n        add(signal, ref);\n      }\n    } else {\n      add(signal, referencedBindings);\n    }\n  }\n}\nfunction addEffectReferences(signal, referencedBindings) {\n  signal.effectReferencedBindings = bindingUtil.union(\n    signal.effectReferencedBindings,\n    referencedBindings\n  );\n}\nfunction addRenderReferences(signal, referencedBindings) {\n  signal.renderReferencedBindings = bindingUtil.union(\n    signal.renderReferencedBindings,\n    referencedBindings\n  );\n}\nfunction addValue(targetSection, referencedBindings, signal, value, scope = scopeIdentifier, intersectionExpression) {\n  getSignal(targetSection, referencedBindings).values.push({\n    signal,\n    value,\n    scope,\n    intersectionExpression\n  });\n}\nfunction getResumeRegisterId(section, referencedBindings, type) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let name2 = \"\";\n  if (referencedBindings) {\n    if (typeof referencedBindings === \"string\") {\n      name2 += `_${referencedBindings}`;\n    } else if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        name2 += `_${ref.name}`;\n      }\n    } else {\n      name2 += `_${referencedBindings.name}`;\n    }\n  }\n  return (0, import_babel_utils9.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}${name2}${type ? \"/\" + type : \"\"}`\n  );\n}\nvar usedRegisterIdsBySection = /* @__PURE__ */ new WeakMap();\nfunction getRegisterUID(section, name2) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let used = usedRegisterIdsBySection.get(section);\n  if (!used) usedRegisterIdsBySection.set(section, used = /* @__PURE__ */ new Set());\n  const baseId = (0, import_babel_utils9.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}/${name2}`\n  );\n  let count = 0;\n  let id = baseId;\n  while (used.has(id)) {\n    id = baseId + \"_\" + ++count;\n  }\n  used.add(id);\n  return id;\n}\nfunction writeSignals(section) {\n  const signals = [...getSignals(section).values()].sort(sortSignals);\n  for (const signal of signals) {\n    traverseReplace(signal, \"render\", replaceRenderNode);\n    for (const value2 of signal.values) {\n      traverseReplace(value2, \"value\", replaceRenderNode);\n    }\n    let effectDeclarator;\n    if (signal.effect.length) {\n      traverseReplace(signal, \"effect\", replaceEffectNode);\n      const effectIdentifier = import_compiler17.types.identifier(`${signal.identifier.name}_effect`);\n      const referencedBindings = signal.effectReferencedBindings;\n      const referencesScope = traverseContains(\n        signal.effect,\n        isScopeIdentifier\n      );\n      effectDeclarator = import_compiler17.types.variableDeclarator(\n        effectIdentifier,\n        callRuntime(\n          \"effect\",\n          import_compiler17.types.stringLiteral(\n            getResumeRegisterId(section, signal.referencedBindings)\n          ),\n          import_compiler17.types.arrowFunctionExpression(\n            referencedBindings ? referencesScope ? [\n              scopeIdentifier,\n              createScopeReadPattern(section, referencedBindings)\n            ] : [createScopeReadPattern(section, referencedBindings)] : referencesScope ? [scopeIdentifier] : [],\n            toFirstExpressionOrBlock(signal.effect)\n          )\n        )\n      );\n      signal.render.push(\n        import_compiler17.types.expressionStatement(\n          import_compiler17.types.callExpression(effectIdentifier, [scopeIdentifier])\n        )\n      );\n    }\n    let value = signal.build();\n    if (import_compiler17.types.isCallExpression(value)) {\n      finalizeSignalArgs(value.arguments);\n    }\n    if (signal.register) {\n      value = callRuntime(\n        \"registerBoundSignal\",\n        import_compiler17.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings, \"var\")\n        ),\n        value\n      );\n    }\n    if (signal.isDynamicClosure && isStatefulReferences(signal.referencedBindings)) {\n      value = callRuntime(\n        \"registerSubscriber\",\n        import_compiler17.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings, \"subscriber\")\n        ),\n        value\n      );\n    }\n    const signalDeclarator = import_compiler17.types.variableDeclarator(signal.identifier, value);\n    let signalDeclaration = !section.parent && !signal.referencedBindings && (import_compiler17.types.isFunctionExpression(value) || import_compiler17.types.isArrowFunctionExpression(value)) ? import_compiler17.types.functionDeclaration(\n      signal.identifier,\n      value.params,\n      import_compiler17.types.isExpression(value.body) ? import_compiler17.types.blockStatement([import_compiler17.types.expressionStatement(value.body)]) : value.body\n    ) : import_compiler17.types.variableDeclaration(\"const\", [signalDeclarator]);\n    if (signal.export) {\n      signalDeclaration = import_compiler17.types.exportNamedDeclaration(signalDeclaration);\n    }\n    currentProgramPath.pushContainer(\n      \"body\",\n      effectDeclarator ? [\n        import_compiler17.types.variableDeclaration(\"const\", [effectDeclarator]),\n        signalDeclaration\n      ] : signalDeclaration\n    );\n  }\n}\nfunction writeRegisteredFns() {\n  const registeredFns = registeredFnsForProgram.get(currentProgramPath.node);\n  const statements = [];\n  if (registeredFns) {\n    for (const registeredFn of registeredFns) {\n      let fn;\n      const params = registeredFn.referencedBindings ? registeredFn.referencesScope ? [\n        scopeIdentifier,\n        import_compiler17.types.assignmentPattern(\n          createScopeReadPattern(\n            registeredFn.section,\n            registeredFn.referencedBindings\n          ),\n          scopeIdentifier\n        )\n      ] : [\n        createScopeReadPattern(\n          registeredFn.section,\n          registeredFn.referencedBindings\n        )\n      ] : registeredFn.referencesScope ? [scopeIdentifier] : void 0;\n      if (params) {\n        fn = import_compiler17.types.functionDeclaration(\n          import_compiler17.types.identifier(registeredFn.id),\n          params,\n          import_compiler17.types.blockStatement(toReturnedFunction(registeredFn.node))\n        );\n      } else if (registeredFn.node.type === \"FunctionDeclaration\" && registeredFn.node.id?.name === registeredFn.id) {\n        fn = registeredFn.node;\n      } else {\n        fn = import_compiler17.types.functionDeclaration(\n          import_compiler17.types.identifier(registeredFn.id),\n          registeredFn.node.params,\n          registeredFn.node.body.type === \"BlockStatement\" ? registeredFn.node.body : import_compiler17.types.blockStatement([import_compiler17.types.returnStatement(registeredFn.node.body)]),\n          registeredFn.node.generator,\n          registeredFn.node.async\n        );\n      }\n      statements.push(fn);\n    }\n    for (const registeredFn of registeredFns) {\n      statements.push(\n        import_compiler17.types.expressionStatement(\n          callRuntime(\n            \"register\",\n            import_compiler17.types.stringLiteral(registeredFn.registerId),\n            import_compiler17.types.identifier(registeredFn.id)\n          )\n        )\n      );\n    }\n    for (const stmt of currentProgramPath.pushContainer(\"body\", statements)) {\n      stmt.skip();\n    }\n  }\n}\nfunction toReturnedFunction(rawFn) {\n  const fn = simplifyFunction(rawFn);\n  return fn.type === \"FunctionDeclaration\" ? [fn, import_compiler17.types.returnStatement(fn.id)] : [import_compiler17.types.returnStatement(fn)];\n}\nfunction sortSignals(a, b) {\n  const aReferencedBindings = getReferencedBindings(a);\n  const bReferencedBindings = getReferencedBindings(b);\n  for (let i = Math.max(aReferencedBindings.length, bReferencedBindings.length) - 1; i >= 0; i--) {\n    const diff = (bReferencedBindings[i] ?? -1) - (aReferencedBindings[i] ?? -1);\n    if (diff !== 0) return diff;\n  }\n  return 0;\n}\nfunction getReferencedBindings({ referencedBindings: reserve }) {\n  if (!reserve) {\n    return [];\n  } else if (Array.isArray(reserve)) {\n    return reserve.map(getMappedId).sort();\n  } else {\n    return [getMappedId(reserve)];\n  }\n}\nfunction getMappedId(reference) {\n  return (reference.type === 0 /* dom */ ? 1 : 0) * 1e4 + reference.id;\n}\nfunction addHTMLEffectCall(section, referencedBindings) {\n  addStatement(\"effect\", section, referencedBindings, void 0, false);\n}\nfunction writeHTMLResumeStatements(path5) {\n  const section = getSectionForBody(path5);\n  if (!section) return;\n  const allSignals = Array.from(getSignals(section).values());\n  const scopeIdIdentifier = getScopeIdIdentifier(section);\n  forEach(section.assignments, (assignment) => {\n    let currentSection = section;\n    while (currentSection !== assignment.section) {\n      getSerializedScopeProperties(currentSection).set(\n        import_compiler17.types.stringLiteral(\"_\"),\n        callRuntime(\n          \"ensureScopeWithId\",\n          getScopeIdIdentifier(currentSection = currentSection.parent)\n        )\n      );\n    }\n  });\n  forEach(section.closures, (closure) => {\n    if (isStatefulReferences(closure)) {\n      let currentSection = section;\n      while (currentSection !== closure.section) {\n        getSerializedScopeProperties(currentSection).set(\n          import_compiler17.types.stringLiteral(\"_\"),\n          callRuntime(\n            \"ensureScopeWithId\",\n            getScopeIdIdentifier(currentSection = currentSection.parent)\n          )\n        );\n      }\n      setForceResumeScope(closure.section);\n      const isImmediateOwner = section.parent?.id === closure.section.id;\n      const isDynamicClosure = !getClosureSignalBuilder(section) || !isImmediateOwner;\n      if (isDynamicClosure) {\n        path5.pushContainer(\n          \"body\",\n          import_compiler17.types.expressionStatement(\n            callRuntime(\n              \"writeEffect\",\n              scopeIdIdentifier,\n              import_compiler17.types.stringLiteral(\n                getResumeRegisterId(section, closure, \"subscriber\")\n              )\n            )\n          )\n        );\n      }\n    }\n  });\n  for (let i = allSignals.length; i--; ) {\n    if (allSignals[i].effect.length) {\n      const signalRefs = allSignals[i].referencedBindings;\n      path5.pushContainer(\n        \"body\",\n        import_compiler17.types.expressionStatement(\n          callRuntime(\n            \"writeEffect\",\n            scopeIdIdentifier,\n            import_compiler17.types.stringLiteral(getResumeRegisterId(section, signalRefs))\n          )\n        )\n      );\n    }\n  }\n  const accessors = /* @__PURE__ */ new Set();\n  const additionalProperties = getSerializedScopeProperties(section);\n  const serializedProperties = [];\n  forEach(section.bindings, (binding) => {\n    if (binding.serialize && binding.type !== 0 /* dom */) {\n      const accessor = getScopeAccessorLiteral(binding);\n      serializedProperties.push(\n        import_compiler17.types.objectProperty(accessor, getDeclaredBindingExpression(binding))\n      );\n      accessors.add(accessor.value);\n    }\n  });\n  for (const [key, value] of additionalProperties) {\n    if (!accessors.has(key.value)) {\n      serializedProperties.push(\n        import_compiler17.types.objectProperty(key, value, !import_compiler17.types.isLiteral(key))\n      );\n      accessors.add(key.value);\n    }\n  }\n  if (serializedProperties.length || forceResumeScope(section)) {\n    let writeScope2 = callRuntime(\n      \"writeScope\",\n      scopeIdIdentifier,\n      import_compiler17.types.objectExpression(serializedProperties)\n    );\n    if (!isOptimize()) {\n      let debugVars;\n      forEach(section.bindings, (binding) => {\n        let root = binding;\n        let access = \"\";\n        while (!root.loc && root.upstreamAlias) {\n          if (root.property !== void 0) {\n            access = toAccess(root.property) + access;\n          }\n          root = root.upstreamAlias;\n        }\n        if (root.loc) {\n          const locStr = import_compiler17.types.stringLiteral(\n            `${root.loc.start.line}:${root.loc.start.column + 1}`\n          );\n          (debugVars ||= []).push(\n            import_compiler17.types.objectProperty(\n              getScopeAccessorLiteral(binding),\n              root !== binding ? import_compiler17.types.arrayExpression([\n                import_compiler17.types.stringLiteral(root.name + access),\n                locStr\n              ]) : locStr\n            )\n          );\n        }\n      });\n      writeScope2 = callRuntime(\n        \"debug\",\n        writeScope2,\n        import_compiler17.types.stringLiteral(path5.hub.file.opts.filenameRelative),\n        section.loc && section.loc.start.line != null ? import_compiler17.types.stringLiteral(\n          `${section.loc.start.line}:${section.loc.start.column + 1}`\n        ) : import_compiler17.types.numericLiteral(0),\n        debugVars && import_compiler17.types.objectExpression(debugVars)\n      );\n    }\n    path5.pushContainer(\"body\", import_compiler17.types.expressionStatement(writeScope2));\n  }\n  const resumeClosestBranch2 = !section.isBranch && (section.hasAbortSignal || !!section.closures || !!find(section.bindings, (binding) => binding.type === 1 /* let */));\n  if (resumeClosestBranch2) {\n    path5.pushContainer(\n      \"body\",\n      import_compiler17.types.expressionStatement(\n        callRuntime(\"resumeClosestBranch\", scopeIdIdentifier)\n      )\n    );\n  }\n  if (path5.get(\"body\").length) {\n    path5.unshiftContainer(\n      \"body\",\n      import_compiler17.types.variableDeclaration(\"const\", [\n        import_compiler17.types.variableDeclarator(scopeIdIdentifier, callRuntime(\"nextScopeId\"))\n      ])\n    );\n  }\n  const returnIdentifier = getSectionReturnValueIdentifier(section);\n  if (returnIdentifier !== void 0) {\n    path5.pushContainer(\"body\", import_compiler17.types.returnStatement(returnIdentifier));\n  }\n}\nfunction getSetup(section) {\n  return getSignals(section).get(void 0)?.identifier;\n}\nfunction replaceRenderNode(node) {\n  return replaceAssignedNode(node) || replaceBindingReadNode(node) || replaceRegisteredFunctionNode(node);\n}\nfunction replaceEffectNode(node) {\n  return replaceAssignedNode(node) || replaceBindingReadNode(node);\n}\nfunction replaceBindingReadNode(node) {\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\": {\n      return getReadReplacement(node);\n    }\n  }\n}\nfunction replaceAssignedNode(node) {\n  switch (node.type) {\n    case \"UpdateExpression\": {\n      const { extra } = node.argument;\n      if (isAssignedBindingExtra(extra)) {\n        const { buildAssignment } = getSignal(\n          extra.assignment.section,\n          extra.assignment\n        );\n        if (buildAssignment) {\n          const replacement = buildAssignment(\n            extra.section,\n            import_compiler17.types.binaryExpression(\n              node.operator === \"++\" ? \"+\" : \"-\",\n              node.argument,\n              import_compiler17.types.numericLiteral(1)\n            )\n          );\n          if (!node.prefix) {\n            return import_compiler17.types.sequenceExpression([replacement, node.argument]);\n          }\n          return replacement;\n        }\n      }\n      break;\n    }\n    case \"AssignmentExpression\":\n      switch (node.left.type) {\n        case \"Identifier\": {\n          const { extra } = node.left;\n          if (isAssignedBindingExtra(extra)) {\n            const { buildAssignment } = getSignal(\n              extra.assignment.section,\n              extra.assignment\n            );\n            if (buildAssignment) {\n              return buildAssignment(\n                extra.section,\n                node.operator === \"=\" ? node.right : import_compiler17.types.binaryExpression(\n                  node.operator.slice(\n                    0,\n                    -1\n                  ),\n                  node.left,\n                  node.right\n                )\n              );\n            }\n          }\n          break;\n        }\n        case \"ArrayPattern\":\n        case \"ObjectPattern\": {\n          let params;\n          let assignments;\n          forEachIdentifier(node.left, (id) => {\n            const { extra } = id;\n            if (isAssignedBindingExtra(extra)) {\n              const signal = getSignal(\n                extra.assignment.section,\n                extra.assignment\n              );\n              if (signal?.buildAssignment) {\n                id.name = currentProgramPath.scope.generateUid(id.name);\n                (params ||= []).push(import_compiler17.types.identifier(id.name));\n                (assignments ||= []).push(\n                  signal.buildAssignment(extra.section, import_compiler17.types.identifier(id.name))\n                );\n              }\n            }\n          });\n          if (params && assignments) {\n            const resultId = currentProgramPath.scope.generateUid(\"result\");\n            return import_compiler17.types.callExpression(\n              import_compiler17.types.arrowFunctionExpression(\n                [import_compiler17.types.identifier(resultId), ...params],\n                import_compiler17.types.sequenceExpression([\n                  import_compiler17.types.assignmentExpression(\n                    \"=\",\n                    node.left,\n                    import_compiler17.types.identifier(resultId)\n                  ),\n                  ...assignments,\n                  import_compiler17.types.identifier(resultId)\n                ])\n              ),\n              [node.right]\n            );\n          }\n          break;\n        }\n      }\n      break;\n  }\n}\nvar registeredFnsForProgram = /* @__PURE__ */ new WeakMap();\nfunction replaceRegisteredFunctionNode(node) {\n  switch (node.type) {\n    case \"ClassMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler17.types.classProperty(node.key, replacement);\n    }\n    case \"ClassPrivateMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler17.types.classPrivateProperty(node.key, replacement);\n    }\n    case \"ObjectMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler17.types.objectProperty(node.key, replacement);\n    }\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\": {\n      return getRegisteredFnExpression(node);\n    }\n    case \"FunctionDeclaration\": {\n      const replacement = getRegisteredFnExpression(node);\n      if (replacement) {\n        return import_compiler17.types.variableDeclaration(\"const\", [\n          import_compiler17.types.variableDeclarator(node.id, replacement)\n        ]);\n      }\n      break;\n    }\n  }\n}\nfunction getRegisteredFnExpression(node) {\n  const { extra } = node;\n  if (isRegisteredFnExtra(extra)) {\n    const id = currentProgramPath.scope.generateUid(extra.name);\n    const referencesScope = extra.referencesScope;\n    const referencedBindings = extra.referencedBindingsInFunction;\n    let registedFns = registeredFnsForProgram.get(currentProgramPath.node);\n    if (!registedFns) {\n      registeredFnsForProgram.set(currentProgramPath.node, registedFns = []);\n    }\n    registedFns.push({\n      id,\n      node,\n      registerId: extra.registerId,\n      section: extra.section,\n      referencesScope,\n      referencedBindings\n    });\n    if (referencesScope || referencedBindings) {\n      return import_compiler17.types.callExpression(import_compiler17.types.identifier(id), [scopeIdentifier]);\n    } else {\n      return import_compiler17.types.identifier(id);\n    }\n  }\n}\n\n// src/translator/visitors/program/dom.ts\nvar dom_default = {\n  translate: {\n    exit(program) {\n      visit(program);\n      const section = getSectionForBody(program);\n      const { walks, writes, setup } = getSectionMeta(section);\n      const domExports = program.node.extra.domExports;\n      const templateIdentifier = import_compiler18.types.identifier(domExports.template);\n      const walksIdentifier = import_compiler18.types.identifier(domExports.walks);\n      const setupIdentifier = import_compiler18.types.identifier(domExports.setup);\n      const paramsBinding = program.node.extra.binding;\n      const programParamsSignal = paramsBinding && bindingHasDownstreamExpressions(paramsBinding) ? initValue(paramsBinding) : void 0;\n      const styleFile = getStyleFile(program.hub.file);\n      if (styleFile) {\n        (0, import_babel_utils10.importDefault)(program.hub.file, styleFile);\n      }\n      forEachSectionReverse((childSection) => {\n        if (childSection !== section) {\n          const tagParamsSignal = childSection.params && initValue(childSection.params);\n          const { walks: walks2, writes: writes2, setup: setup2 } = getSectionMeta(childSection);\n          const identifier = import_compiler18.types.identifier(childSection.name);\n          const renderer = callRuntime(\n            getSectionParentIsOwner(childSection) ? \"createRenderer\" : \"createRendererWithOwner\",\n            writes2,\n            walks2,\n            setup2,\n            tagParamsSignal?.identifier && import_compiler18.types.arrowFunctionExpression([], tagParamsSignal.identifier)\n          );\n          writeSignals(childSection);\n          program.node.body.push(\n            import_compiler18.types.variableDeclaration(\"const\", [\n              import_compiler18.types.variableDeclarator(\n                identifier,\n                isStatefulSection(childSection) ? callRuntime(\n                  \"register\",\n                  import_compiler18.types.stringLiteral(\n                    getResumeRegisterId(childSection, \"renderer\")\n                  ),\n                  renderer\n                ) : renderer\n              )\n            ])\n          );\n        }\n      });\n      writeSignals(section);\n      writeRegisteredFns();\n      if (!setup) {\n        program.node.body.unshift(\n          import_compiler18.types.exportNamedDeclaration(\n            import_compiler18.types.variableDeclaration(\"const\", [\n              import_compiler18.types.variableDeclarator(\n                setupIdentifier,\n                import_compiler18.types.arrowFunctionExpression([], import_compiler18.types.blockStatement([]))\n              )\n            ])\n          )\n        );\n      }\n      program.node.body.unshift(\n        import_compiler18.types.exportNamedDeclaration(\n          import_compiler18.types.variableDeclaration(\"const\", [\n            import_compiler18.types.variableDeclarator(\n              templateIdentifier,\n              writes || import_compiler18.types.stringLiteral(\"\")\n            )\n          ])\n        ),\n        import_compiler18.types.exportNamedDeclaration(\n          import_compiler18.types.variableDeclaration(\"const\", [\n            import_compiler18.types.variableDeclarator(walksIdentifier, walks || import_compiler18.types.stringLiteral(\"\"))\n          ])\n        )\n      );\n      program.node.body.push(\n        import_compiler18.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            import_compiler18.types.stringLiteral(program.hub.file.metadata.marko.id),\n            templateIdentifier,\n            walksIdentifier,\n            setupIdentifier,\n            programParamsSignal?.identifier && import_compiler18.types.arrowFunctionExpression([], programParamsSignal.identifier)\n          )\n        )\n      );\n    }\n  }\n};\n\n// src/translator/visitors/program/html.ts\nvar import_compiler19 = require(\"@marko/compiler\");\n\n// src/translator/util/is-static.ts\nfunction isStatic(path5) {\n  return path5.isImportDeclaration() || path5.isExportDeclaration() || path5.isMarkoScriptlet({ static: true });\n}\n\n// src/translator/visitors/program/html.ts\nvar html_default = {\n  translate: {\n    exit(program) {\n      flushInto(program);\n      writeHTMLResumeStatements(program);\n      traverseReplace(program.node, \"body\", replaceNode);\n      const renderContent = [];\n      for (const child of program.get(\"body\")) {\n        if (!isStatic(child)) {\n          renderContent.push(child.node);\n          child.remove();\n        } else if (child.isMarkoScriptlet()) {\n          if (child.node.target && child.node.target !== \"server\") {\n            child.remove();\n          } else {\n            child.replaceWithMultiple(child.node.body);\n          }\n        }\n      }\n      program.pushContainer(\"body\", [\n        import_compiler19.types.variableDeclaration(\"const\", [\n          import_compiler19.types.variableDeclarator(\n            htmlRendererIdentifier,\n            callRuntime(\n              \"createRenderer\",\n              import_compiler19.types.arrowFunctionExpression(\n                [import_compiler19.types.identifier(\"input\")],\n                import_compiler19.types.blockStatement(renderContent)\n              )\n            )\n          )\n        ]),\n        import_compiler19.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            import_compiler19.types.stringLiteral(program.hub.file.metadata.marko.id),\n            htmlRendererIdentifier\n          )\n        )\n      ]);\n    }\n  }\n};\nfunction replaceNode(node, container) {\n  return replaceBindingReadNode2(node) || replaceRegisteredFunctionNode2(node, container);\n}\nfunction replaceBindingReadNode2(node) {\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\": {\n      const { extra } = node;\n      if (extra && !(extra.read && !extra.read.binding.declared || extra.binding && !extra.binding.declared)) {\n        return getReadReplacement(node);\n      }\n    }\n  }\n}\nfunction replaceRegisteredFunctionNode2(node, container) {\n  switch (node.type) {\n    case \"ClassMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler19.types.classProperty(node.key, replacement);\n    }\n    case \"ClassPrivateMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler19.types.classPrivateProperty(node.key, replacement);\n    }\n    case \"ObjectMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler19.types.objectProperty(node.key, replacement);\n    }\n    case \"FunctionDeclaration\": {\n      const { extra } = node;\n      if (isRegisteredFnExtra(extra)) {\n        let registeredFnDeclarations = registeredFnDeclarationsByBody.get(\n          container\n        );\n        if (!registeredFnDeclarations) {\n          registeredFnDeclarationsByBody.set(\n            container,\n            registeredFnDeclarations = []\n          );\n        }\n        registeredFnDeclarations.push({\n          id: node.id.name,\n          registerId: extra.registerId\n        });\n      }\n      break;\n    }\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\": {\n      return getRegisteredFnExpression2(node);\n    }\n    case \"BlockStatement\":\n    case \"MarkoScriptlet\":\n      addRegisteredDeclarations(node.body);\n      break;\n  }\n}\nvar registeredFnDeclarationsByBody = /* @__PURE__ */ new WeakMap();\nfunction addRegisteredDeclarations(body) {\n  const registeredFnDeclarations = registeredFnDeclarationsByBody.get(body);\n  if (registeredFnDeclarations) {\n    for (const { id, registerId } of registeredFnDeclarations) {\n      body.push(\n        import_compiler19.types.expressionStatement(\n          callRuntime(\n            \"register\",\n            import_compiler19.types.identifier(id),\n            import_compiler19.types.stringLiteral(registerId)\n          )\n        )\n      );\n    }\n  }\n}\nfunction getRegisteredFnExpression2(node) {\n  const { extra } = node;\n  if (isRegisteredFnExtra(extra)) {\n    return callRuntime(\n      \"register\",\n      simplifyFunction(node),\n      import_compiler19.types.stringLiteral(extra.registerId),\n      (extra.referencedBindingsInFunction || extra.referencesScope) && getScopeIdIdentifier(extra.section)\n    );\n  }\n}\n\n// src/translator/visitors/program/index.ts\nvar currentProgramPath;\nvar cleanIdentifier;\nvar htmlRendererIdentifier;\nvar scopeIdentifier;\nfunction isScopeIdentifier(node) {\n  return node === scopeIdentifier;\n}\nvar previousProgramPath = /* @__PURE__ */ new WeakMap();\nvar program_default = {\n  migrate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      program.node.params = [import_compiler20.types.identifier(\"input\")];\n      currentProgramPath = program;\n    },\n    exit() {\n      currentProgramPath.scope.crawl();\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  analyze: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      startSection(program);\n      trackParamsReferences(program, 2 /* input */);\n      program.node.params[0].extra.binding.nullable = false;\n      const { scope } = program;\n      (program.node.extra ??= {}).domExports = {\n        template: scope.generateUid(\"template_\"),\n        walks: scope.generateUid(\"walks_\"),\n        setup: scope.generateUid(\"setup_\"),\n        params: void 0,\n        // TODO look into recursive components with fine grained params.\n        closures: scope.generateUid(\"closures_\")\n      };\n    },\n    exit(program) {\n      finalizeReferences();\n      const {\n        scope,\n        node: { extra }\n      } = program;\n      if (extra.binding && bindingHasDownstreamExpressions(extra.binding)) {\n        extra.domExports.params = buildTemplateExports(extra.binding, scope);\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  translate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      scopeIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"scope\") : null;\n      cleanIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"clean\") : null;\n      htmlRendererIdentifier = isOutputHTML() ? program.scope.generateUidIdentifier(\"renderer\") : null;\n      if (getMarkoOpts().output === \"hydrate\") {\n        const entryFile = program.hub.file;\n        const visitedFiles = /* @__PURE__ */ new Set([\n          (0, import_babel_utils11.resolveRelativePath)(entryFile, entryFile.opts.filename)\n        ]);\n        entry_builder_default.visit(entryFile, entryFile, function visitChild(resolved) {\n          if (!visitedFiles.has(resolved)) {\n            visitedFiles.add(resolved);\n            const file = (0, import_babel_utils11.loadFileForImport)(entryFile, resolved);\n            if (file) {\n              entry_builder_default.visit(\n                file,\n                entryFile,\n                (id) => visitChild(resolveRelativeToEntry(entryFile, file, id))\n              );\n            }\n          }\n        });\n        program.node.body = entry_builder_default.build(entryFile);\n        program.skip();\n        return;\n      }\n    },\n    exit(program) {\n      if (isOutputHTML()) {\n        html_default.translate.exit(program);\n      } else {\n        dom_default.translate.exit(program);\n      }\n      if (program.node.extra?.needsCompat) {\n        const compatFile = getCompatRuntimeFile();\n        const body = [void 0];\n        for (const child of program.node.body) {\n          if (child.type === \"ImportDeclaration\" && child.source.value === compatFile) {\n            body[0] = child;\n          } else {\n            body.push(child);\n          }\n        }\n        body[0] ??= import_compiler20.types.importDeclaration([], import_compiler20.types.stringLiteral(compatFile));\n        program.node.body = body;\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  }\n};\nfunction resolveRelativeToEntry(entryFile, file, req) {\n  return file === entryFile ? (0, import_babel_utils11.resolveRelativePath)(file, req) : (0, import_babel_utils11.resolveRelativePath)(\n    entryFile,\n    req[0] === \".\" ? import_path2.default.join(file.opts.filename, \"..\", req) : req\n  );\n}\nfunction buildTemplateExports(binding, scope) {\n  const templateExport = {\n    id: binding.export ??= scope.generateUid(binding.name + \"_\"),\n    props: void 0\n  };\n  const { aliases, propertyAliases, downstreamExpressions } = binding;\n  if (!downstreamExpressions.size) {\n    templateExport.props = {};\n    for (const [property, alias] of propertyAliases) {\n      templateExport.props[property] = buildTemplateExports(alias, scope);\n    }\n    for (const alias of aliases) {\n      const exports2 = buildTemplateExports(alias, scope);\n      if (exports2.props) {\n        templateExport.props = { ...templateExport.props, ...exports2.props };\n      } else {\n        templateExport.props = void 0;\n        return templateExport;\n      }\n    }\n  }\n  return templateExport;\n}\n\n// src/translator/util/get-root.ts\nfunction getMarkoRoot(path5) {\n  let curPath = path5;\n  do\n    curPath = curPath.parentPath;\n  while (curPath && !isMarko(curPath));\n  return curPath;\n}\nfunction getExprRoot(path5) {\n  let curPath = path5;\n  while (!isMarko(curPath.parentPath)) {\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction getFnRoot(path5) {\n  let curPath = path5;\n  let fnPath;\n  if (curPath.isProgram()) return;\n  while (!isMarko(curPath)) {\n    if (isFunction(curPath)) {\n      fnPath = curPath;\n    } else {\n      switch (curPath.type) {\n        case \"CallExpression\":\n        case \"NewExpression\":\n          fnPath = void 0;\n          break;\n      }\n    }\n    curPath = curPath.parentPath;\n  }\n  return fnPath;\n}\nfunction isMarko(path5) {\n  switch (path5.type) {\n    case \"MarkoTag\":\n    case \"MarkoTagBody\":\n    case \"MarkoAttribute\":\n    case \"MarkoSpreadAttribute\":\n    case \"MarkoPlaceholder\":\n    case \"MarkoScriptlet\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isFunction(path5) {\n  switch (path5.type) {\n    case \"FunctionDeclaration\":\n      return !path5.node.declare;\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ObjectMethod\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// src/translator/util/with-previous-location.ts\nfunction withPreviousLocation(newNode, originalNode) {\n  newNode.start = originalNode.start;\n  newNode.loc = originalNode.loc;\n  newNode.end = originalNode.end;\n  return newNode;\n}\n\n// src/translator/util/references.ts\nvar [getBindings] = createProgramState(() => /* @__PURE__ */ new Set());\nvar [getNextBindingId, setNextBindingId] = createProgramState(() => 0);\nfunction createBinding(name2, type, section, upstreamAlias, upstreamExpression, property, loc = null, declared = false) {\n  const id = getNextBindingId();\n  const binding = {\n    id,\n    name: name2,\n    type,\n    loc,\n    section,\n    property,\n    declared,\n    excludeProperties: void 0,\n    serialize: false,\n    aliases: /* @__PURE__ */ new Set(),\n    propertyAliases: /* @__PURE__ */ new Map(),\n    upstreamAlias,\n    upstreamExpression,\n    downstreamExpressions: /* @__PURE__ */ new Set(),\n    export: void 0,\n    nullable: !upstreamExpression?.confident || upstreamExpression.computed == null\n  };\n  if (property) {\n    if (declared) upstreamAlias.nullable = false;\n    const propBinding = upstreamAlias.propertyAliases.get(property);\n    if (propBinding) {\n      binding.property = void 0;\n      binding.upstreamAlias = propBinding;\n      propBinding.aliases.add(binding);\n    } else {\n      upstreamAlias.propertyAliases.set(property, binding);\n    }\n  } else if (upstreamAlias) {\n    upstreamAlias.aliases.add(binding);\n  }\n  setNextBindingId(id + 1);\n  getBindings().add(binding);\n  return binding;\n}\nfunction trackVarReferences(tag, type, upstreamAlias, upstreamExpression) {\n  const tagVar = tag.node.var;\n  if (tagVar) {\n    const section = getOrCreateSection(tag);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    if (upstreamAlias && upstreamExpression) upstreamExpression.pruned = true;\n    createBindingsAndTrackReferences(\n      tagVar,\n      type,\n      tag.scope,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0\n    );\n  }\n}\nfunction trackParamsReferences(body, type, upstreamAlias, upstreamExpression) {\n  const params = body.node.params;\n  if (body.node.body.length && params.length) {\n    if (upstreamAlias && upstreamExpression) upstreamExpression.pruned = true;\n    const section = getOrCreateSection(body);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    const paramsBinding = canonicalUpstreamAlias || ((body.node.extra ??= {}).binding = createBinding(\n      currentProgramPath.scope.generateUid(\"params_\"),\n      type,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0\n    ));\n    section.params = paramsBinding;\n    for (let i = 0; i < params.length; i++) {\n      createBindingsAndTrackReferences(\n        params[i],\n        type,\n        body.scope,\n        section,\n        paramsBinding,\n        upstreamExpression,\n        i + \"\"\n      );\n    }\n  }\n}\nfunction trackReferencesForBinding(babelBinding) {\n  const { identifier, referencePaths, constantViolations } = babelBinding;\n  const binding = identifier.extra.binding;\n  for (const referencePath of referencePaths) {\n    trackReference(referencePath, binding);\n  }\n  for (const ref of constantViolations) {\n    if (ref.isUpdateExpression()) {\n      trackAssignment(ref.get(\"argument\"), binding);\n    } else if (ref.isAssignmentExpression()) {\n      trackAssignment(ref.get(\"left\"), binding);\n      if (ref.node.operator !== \"=\") {\n        const left = ref.get(\"left\");\n        if (left.isIdentifier()) {\n          trackReference(left, binding);\n        }\n      }\n    }\n  }\n}\nfunction trackAssignment(assignment, binding) {\n  const section = getOrCreateSection(assignment);\n  setReferencesScope(assignment);\n  forEachIdentifier(assignment.node, (id) => {\n    if (id.name === binding.name) {\n      const extra = id.extra ??= {};\n      section.assignments = bindingUtil.add(section.assignments, binding);\n      extra.assignment = binding;\n      extra.section = section;\n    }\n  });\n}\nfunction setReferencesScope(path5) {\n  const fnRoot = getFnRoot(path5);\n  if (fnRoot) {\n    (fnRoot.node.extra ??= {}).referencesScope = true;\n  }\n}\nfunction createBindingsAndTrackReferences(lVal, type, scope, section, upstreamAlias, upstreamExpression, property) {\n  switch (lVal.type) {\n    case \"Identifier\":\n      (lVal.extra ??= {}).binding = createBinding(\n        lVal.name,\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property,\n        lVal.loc,\n        true\n      );\n      trackReferencesForBinding(scope.getBinding(lVal.name));\n      break;\n    case \"ObjectPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        currentProgramPath.scope.generateUid(\"pattern_\"),\n        type,\n        section,\n        upstreamAlias,\n        void 0,\n        property,\n        lVal.loc\n      ));\n      for (const prop of lVal.properties) {\n        if (prop.type === \"RestElement\") {\n          createBindingsAndTrackReferences(\n            prop.argument,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            property\n          );\n        } else {\n          let key;\n          if (prop.key.type === \"Identifier\") {\n            key = prop.key.name;\n          } else if (prop.key.type === \"StringLiteral\") {\n            key = prop.key.value;\n          } else {\n            throw new Error(\"computed keys not supported in object pattern\");\n          }\n          createBindingsAndTrackReferences(\n            prop.value,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            key\n          );\n        }\n      }\n      break;\n    }\n    case \"ArrayPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        currentProgramPath.scope.generateUid(\"pattern_\"),\n        type,\n        section,\n        upstreamAlias,\n        void 0,\n        property,\n        lVal.loc\n      ));\n      let i = -1;\n      for (const element of lVal.elements) {\n        i++;\n        if (element) {\n          if (element.type === \"RestElement\") {\n            createBindingsAndTrackReferences(\n              element.argument,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              property\n            );\n          } else {\n            createBindingsAndTrackReferences(\n              element,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              `${i}`\n            );\n          }\n        }\n      }\n      break;\n    }\n    case \"AssignmentPattern\":\n      createBindingsAndTrackReferences(\n        lVal.left,\n        type,\n        scope,\n        section,\n        upstreamAlias,\n        void 0,\n        property\n      );\n      break;\n  }\n}\nfunction trackReference(referencePath, binding) {\n  let root = referencePath;\n  let reference = binding;\n  let propPath = binding.name;\n  while (true) {\n    const { parent } = root;\n    if (!import_compiler21.types.isMemberExpression(parent)) break;\n    const prop = getMemberExpressionPropString(parent);\n    if (prop === void 0) break;\n    if (reference.propertyAliases.has(prop)) {\n      root = root.parentPath;\n      reference = reference.propertyAliases.get(prop);\n      propPath = reference.name;\n      continue;\n    }\n    if (root.parentPath.parentPath.isCallExpression() && !isEventOrChangeHandler(prop)) {\n      break;\n    }\n    root = root.parentPath;\n    reference = createBinding(\n      propPath += `_${prop.replace(/[^a-zA-Z0-9_$]/g, \"_\")}`,\n      reference.type,\n      reference.section,\n      reference,\n      void 0,\n      prop\n    );\n  }\n  const fnRoot = getFnRoot(root);\n  const exprRoot = getExprRoot(fnRoot || root);\n  const { section } = addReadToExpression(exprRoot, reference, root.node);\n  if (fnRoot) {\n    const readsByFn = getReadsByFunction();\n    const fnExtra = fnRoot.node.extra ??= {};\n    fnExtra.section = section;\n    readsByFn.set(\n      fnExtra,\n      push(readsByFn.get(fnExtra), {\n        binding: reference,\n        node: root.node\n      })\n    );\n  }\n}\nvar [getMergedReferences] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction mergeReferences(section, target, nodes) {\n  (target.extra ??= {}).section = section;\n  getMergedReferences().set(target, nodes);\n}\nfunction compareIntersections(a, b) {\n  const len = a.length;\n  const lenDelta = len - b.length;\n  if (lenDelta !== 0) {\n    return lenDelta;\n  }\n  for (let i = 0; i < len; i++) {\n    const compareResult = bindingUtil.compare(a[i], b[i]);\n    if (compareResult !== 0) {\n      return compareResult;\n    }\n  }\n  return 0;\n}\nfunction finalizeReferences() {\n  const bindings = getBindings();\n  const readsByExpression = getReadsByExpression();\n  const readsByFn = getReadsByFunction();\n  const mergedReferences = getMergedReferences();\n  if (mergedReferences.size) {\n    for (const [target, nodes] of mergedReferences) {\n      const targetExtra = target.extra;\n      let reads = readsByExpression.get(targetExtra);\n      let { isEffect } = targetExtra;\n      for (const node of nodes) {\n        const extra = node?.extra;\n        if (isReferencedExtra(extra)) {\n          isEffect ||= extra.isEffect;\n          const additionalReads = readsByExpression.get(extra);\n          if (additionalReads) {\n            reads = concat(reads, additionalReads);\n            readsByExpression.delete(extra);\n          }\n        }\n      }\n      readsByExpression.set(targetExtra, reads);\n      targetExtra.isEffect = isEffect;\n    }\n  }\n  const intersectionsBySection = /* @__PURE__ */ new Map();\n  for (const [expr, reads] of readsByExpression) {\n    if (isReferencedExtra(expr)) {\n      expr.referencedBindings = resolveReferencedBindings(\n        expr,\n        reads,\n        intersectionsBySection\n      );\n      forEach(expr.referencedBindings, (binding) => {\n        binding.downstreamExpressions.add(expr);\n      });\n    }\n  }\n  for (const [fn, reads] of readsByFn) {\n    fn.referencedBindingsInFunction = resolveReferencedBindings(\n      fn,\n      reads,\n      intersectionsBySection\n    );\n    forEach(fn.referencedBindingsInFunction, (binding) => {\n      binding.serialize = true;\n    });\n  }\n  for (const binding of bindings) {\n    if (binding.type !== 0 /* dom */ && !binding.upstreamAlias) {\n      pruneBinding(bindings, binding);\n    }\n  }\n  for (const binding of bindings) {\n    const { name: name2, section } = binding;\n    if (binding.type !== 0 /* dom */) {\n      if (find(section.bindings, ({ name: name3 }) => name3 === binding.name)) {\n        binding.name = currentProgramPath.scope.generateUid(name2);\n      }\n    }\n    section.bindings = bindingUtil.add(section.bindings, binding);\n    for (const {\n      referencedBindings,\n      isEffect,\n      section: section2\n    } of binding.downstreamExpressions) {\n      if (section2 !== binding.section) {\n        section2.closures = bindingUtil.add(section2.closures, binding);\n      }\n      if (isEffect) {\n        forEach(referencedBindings, (bindingReference) => {\n          bindingReference.serialize = true;\n        });\n      }\n    }\n  }\n  forEachSection((section) => {\n    const intersections = intersectionsBySection.get(section);\n    if (intersections) {\n      for (const intersection of intersections) {\n        const numReferences = intersection.length;\n        for (let i = 0; i < numReferences - 1; i++) {\n          for (let j = i + 1; j < numReferences; j++) {\n            const binding1 = intersection[i];\n            const binding2 = intersection[j];\n            const sources1 = getSourceBindings(binding1);\n            const sources2 = getSourceBindings(binding2);\n            if (!binding1.serialize && !isSuperset(sources1, sources2)) {\n              binding1.serialize = true;\n            }\n            if (!binding2.serialize && !isSuperset(sources2, sources1)) {\n              binding2.serialize = true;\n            }\n          }\n        }\n      }\n    }\n    forEach(section.closures, (binding) => {\n      if (!binding.serialize) {\n        let serialize = false;\n        const sourceSection = binding.section;\n        let currentSection = section;\n        while (currentSection !== sourceSection && !(serialize = !currentSection.upstreamExpression || isStatefulReferences(\n          currentSection.upstreamExpression.referencedBindings\n        ))) {\n          currentSection = currentSection.parent;\n        }\n        binding.serialize = serialize;\n      }\n    });\n  });\n  forEachSection(({ id, bindings: bindings2 }) => {\n    forEach(\n      filter(bindings2, ({ section }) => section.id === id),\n      (binding, i) => {\n        binding.id = i;\n      }\n    );\n  });\n  mergedReferences.clear();\n  readsByExpression.clear();\n  readsByFn.clear();\n}\nfunction isSuperset(set, subset) {\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getSourceBindings(binding) {\n  const derived = /* @__PURE__ */ new Set();\n  const sources = /* @__PURE__ */ new Set();\n  crawl(binding);\n  return sources;\n  function crawl(binding2) {\n    if (binding2.type === 4 /* derived */ || binding2.type === 3 /* param */) {\n      let alias;\n      let curBinding = binding2;\n      while (alias = curBinding.upstreamAlias) {\n        curBinding = alias;\n      }\n      if (curBinding.upstreamExpression) {\n        if (derived.has(curBinding)) return;\n        derived.add(curBinding);\n        forEach(curBinding.upstreamExpression.referencedBindings, crawl);\n      } else {\n        sources.add(curBinding);\n      }\n    } else {\n      sources.add(binding2);\n    }\n  }\n}\nvar bindingUtil = new Sorted(function compareBindings(a, b) {\n  return a.section.id - b.section.id || a.type !== b.type && (a.type === 0 /* dom */ || b.type === 0 /* dom */) ? a.type - b.type || a.id - b.id : a.id - b.id;\n});\nvar [getReadsByExpression] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nvar [getReadsByFunction] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction addReadToExpression(path5, binding, node) {\n  const exprExtra = path5.node.extra ??= {};\n  const readsByExpression = getReadsByExpression();\n  exprExtra.section = getOrCreateSection(path5);\n  readsByExpression.set(\n    exprExtra,\n    push(readsByExpression.get(exprExtra), { binding, node })\n  );\n  return exprExtra;\n}\nfunction dropReferences(node) {\n  if (Array.isArray(node)) {\n    for (const item of node) {\n      (item.extra ??= {}).pruned = true;\n    }\n  } else {\n    (node.extra ??= {}).pruned = true;\n  }\n}\nfunction getCanonicalBinding(binding) {\n  return binding && (binding.property ? binding : binding.upstreamAlias || binding);\n}\nfunction getAllTagReferenceNodes(tag, referenceNodes = []) {\n  if (tag.arguments) {\n    for (const arg of tag.arguments) {\n      referenceNodes.push(arg);\n    }\n  }\n  for (const attr2 of tag.attributes) {\n    referenceNodes.push(attr2.value);\n  }\n  for (const child of tag.body.attributeTags ? tag.body.body : tag.attributeTags) {\n    switch (child.type) {\n      case \"MarkoTag\":\n        getAllTagReferenceNodes(child, referenceNodes);\n        break;\n      case \"MarkoScriptlet\":\n        for (const statement of child.body) {\n          referenceNodes.push(statement);\n        }\n        break;\n    }\n  }\n  return referenceNodes;\n}\nfunction getScopeAccessorLiteral(binding) {\n  if (isOptimize()) {\n    return import_compiler21.types.numericLiteral(binding.id);\n  }\n  return import_compiler21.types.stringLiteral(\n    binding.name + (binding.type === 0 /* dom */ ? `/${binding.id}` : \"\")\n  );\n}\nfunction getReadReplacement(node) {\n  const { extra } = node;\n  if (!extra) return;\n  let { binding, read } = extra;\n  let replacement;\n  if (read) {\n    if (read.props === void 0) {\n      binding = read.binding;\n      read = void 0;\n    } else {\n      binding = void 0;\n    }\n  }\n  if (binding) {\n    if (node.type === \"Identifier\") {\n      if (binding.name !== node.name) {\n        node.name = binding.name;\n      }\n    } else {\n      replacement = import_compiler21.types.identifier(binding.name);\n    }\n  } else if (read) {\n    replacement = toMemberExpression(\n      import_compiler21.types.identifier(read.binding.name),\n      Array.isArray(read.props) ? read.props[0] : read.props\n    );\n    if (Array.isArray(read.props)) {\n      for (let i = 1; i < read.props.length; i++) {\n        replacement = toMemberExpression(replacement, read.props[i]);\n      }\n    }\n  }\n  return replacement && withPreviousLocation(replacement, node);\n}\nfunction pruneBinding(bindings, binding) {\n  let shouldPrune = !binding.downstreamExpressions.size;\n  for (const alias of binding.aliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.aliases.delete(alias);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  for (const [key, alias] of binding.propertyAliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.propertyAliases.delete(key);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  if (shouldPrune) {\n    bindings.delete(binding);\n  }\n  return shouldPrune;\n}\nfunction resolveReferencedBindings(expr, reads, intersectionsBySection) {\n  let referencedBindings;\n  if (Array.isArray(reads)) {\n    for (const read of reads) {\n      let { binding } = read;\n      if (read.node) {\n        const exprReference = (read.node.extra ??= {}).read ??= resolveExpressionReference(reads, binding, void 0);\n        ({ binding } = (read.node.extra ??= {}).read = exprReference);\n      }\n      referencedBindings = bindingUtil.add(referencedBindings, binding);\n    }\n  } else if (reads) {\n    if (reads.node) {\n      (reads.node.extra ??= {}).read = createRead(reads.binding, void 0);\n    }\n    referencedBindings = reads.binding;\n  }\n  if (Array.isArray(referencedBindings)) {\n    const intersections = intersectionsBySection.get(expr.section) || [];\n    const intersection = findSorted(\n      compareIntersections,\n      intersections,\n      referencedBindings\n    );\n    if (intersection) {\n      referencedBindings = intersection;\n    } else {\n      intersectionsBySection.set(\n        expr.section,\n        addSorted(compareIntersections, intersections, referencedBindings)\n      );\n    }\n  }\n  return referencedBindings;\n}\nfunction resolveExpressionReference(reads, readBinding, readProps) {\n  const { upstreamAlias } = readBinding;\n  if (upstreamAlias && Array.isArray(reads)) {\n    const prop = getCanonicalProperty(readBinding);\n    const aliasProps = prop === void 0 ? readProps : push(readProps, prop);\n    for (const { binding } of reads) {\n      if (binding !== readBinding) {\n        let alias = upstreamAlias;\n        while (alias) {\n          if (binding === alias) {\n            return resolveExpressionReference(reads, alias, aliasProps);\n          }\n          alias = alias.upstreamAlias;\n        }\n      }\n    }\n  }\n  return createRead(readBinding, readProps);\n}\nfunction getCanonicalProperty(binding) {\n  return binding.property ?? binding.upstreamAlias?.property;\n}\nfunction createRead(binding, props) {\n  return { binding, props };\n}\nfunction getMemberExpressionPropString(expr) {\n  switch (expr.property.type) {\n    case \"StringLiteral\":\n      return expr.property.value;\n    case \"NumericLiteral\":\n      return \"\" + expr.property.value;\n    case \"Identifier\":\n      if (expr.computed) return;\n      return expr.property.name;\n  }\n}\nfunction isEventOrChangeHandler(prop) {\n  return /^on[-A-Z][a-zA-Z0-9_$]|[a-zA-Z_$][a-zA-Z0-9_$]*Change$/.test(prop);\n}\nfunction isReferencedExtra(extra) {\n  return !!(extra && !extra.pruned && extra.section);\n}\nfunction isAssignedBindingExtra(extra) {\n  return isReferencedExtra(extra) && extra.assignment !== void 0;\n}\nfunction isRegisteredFnExtra(extra) {\n  return isReferencedExtra(extra) && extra.registerId !== void 0;\n}\n\n// src/translator/util/is-stateful.ts\nfunction isStatefulReferences(referencedBindings) {\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        if (isStatefulBinding(ref)) {\n          return true;\n        }\n      }\n    } else {\n      return isStatefulBinding(referencedBindings);\n    }\n  }\n  return false;\n}\nfunction isStatefulBinding(binding) {\n  switch (binding.type) {\n    case 1 /* let */:\n    case 2 /* input */:\n      return true;\n    default:\n      return !binding.upstreamExpression || isStatefulReferences(binding.upstreamExpression.referencedBindings);\n  }\n}\n\n// src/translator/core/await.ts\nvar await_default = {\n  analyze(tag) {\n    (0, import_babel_utils12.assertNoVar)(tag);\n    (0, import_babel_utils12.assertNoArgs)(tag);\n    assertNoSpreadAttrs(tag);\n    (0, import_babel_utils12.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `await` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler22.types.isMarkoAttribute(valueAttr) || valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `await` tag only supports the `value` attribute.\"\n      );\n    }\n    if (!node.body.body.length) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `await` tag requires body content.\");\n    }\n    if (node.body.params.length && (node.body.params.length > 1 || import_compiler22.types.isSpreadElement(node.body.params[0]))) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `await` tag only supports a single parameter.\"\n      );\n    }\n    getOrCreateSection(tag);\n    trackParamsReferences(\n      tag.get(\"body\"),\n      4 /* derived */,\n      void 0,\n      evaluate(valueAttr.value)\n    );\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        flushBefore(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const [valueAttr] = node.attributes;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (isStatefulReferences(valueAttr.extra?.referencedBindings) || checkStatefulClosures(bodySection, true)) {\n          setForceResumeScope(bodySection);\n        }\n        flushInto(tag);\n        writeHTMLResumeStatements(tagBody);\n        tag.replaceWith(\n          import_compiler22.types.expressionStatement(\n            callRuntime(\n              \"fork\",\n              valueAttr.value,\n              import_compiler22.types.arrowFunctionExpression(\n                node.body.params,\n                toFirstExpressionOrBlock(node.body.body)\n              )\n            )\n          )\n        )[0].skip();\n      }\n    },\n    dom: {\n      enter(tag) {\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n      },\n      exit(tag) {\n        tag.remove();\n      }\n    }\n  }),\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to consume asynchronous an data.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#await\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/await.d.marko\"\n};\n\n// src/translator/core/client.ts\nvar import_compiler23 = require(\"@marko/compiler\");\nvar import_babel_utils13 = require(\"@marko/compiler/babel-utils\");\nvar client_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^client\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils13.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler23.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler23.types.markoScriptlet(body, true, \"client\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"client <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the client.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#client-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/const.ts\nvar import_compiler25 = require(\"@marko/compiler\");\nvar import_babel_utils14 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/translate-var.ts\nvar import_compiler24 = require(\"@marko/compiler\");\nfunction translateVar(tag, initialValue, kind = \"const\") {\n  const {\n    node: { var: tagVar }\n  } = tag;\n  if (!tagVar) {\n    return;\n  }\n  tag.insertBefore(\n    import_compiler24.types.variableDeclaration(kind, [import_compiler24.types.variableDeclarator(tagVar, initialValue)])\n  );\n}\n\n// src/translator/core/const.ts\nvar const_default = {\n  analyze(tag) {\n    (0, import_babel_utils14.assertNoArgs)(tag);\n    (0, import_babel_utils14.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a tag variable.\");\n    }\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler25.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `const` tag only supports the `value` attribute.\"\n      );\n    }\n    const upstreamAlias = import_compiler25.types.isIdentifier(valueAttr.value) ? tag.scope.getBinding(valueAttr.value.name)?.identifier.extra?.binding : void 0;\n    trackVarReferences(\n      tag,\n      4 /* derived */,\n      upstreamAlias,\n      evaluate(valueAttr.value)\n      // TODO could perform a more extensive \"nullable\" check.\n    );\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      const { value } = valueAttr;\n      if (isOutputDOM()) {\n        const section = getSection(tag);\n        const varBinding = node.var.extra?.binding;\n        if (varBinding && !varBinding.upstreamAlias) {\n          const derivation = initValue(varBinding);\n          addValue(section, value.extra?.referencedBindings, derivation, value);\n        }\n      } else {\n        translateVar(tag, value);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an constant binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#const\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/const.d.marko\"\n};\n\n// src/translator/core/debug.ts\nvar import_compiler26 = require(\"@marko/compiler\");\nvar import_babel_utils15 = require(\"@marko/compiler/babel-utils\");\nvar debug_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils15.assertNoVar)(tag);\n    (0, import_babel_utils15.assertNoArgs)(tag);\n    (0, import_babel_utils15.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (tag.node.attributes.length > 1 || tag.node.attributes.length === 1 && (!import_compiler26.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\")) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `debug` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const referencedBindings = valueAttr?.value.extra?.referencedBindings;\n      const statement = withPreviousLocation(import_compiler26.types.debuggerStatement(), tag.node);\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Debug on value change.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#debug\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/debug.d.marko\"\n};\n\n// src/translator/core/define.ts\nvar import_compiler31 = require(\"@marko/compiler\");\nvar import_babel_utils20 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/nested-attribute-tags.ts\nvar import_compiler27 = require(\"@marko/compiler\");\nvar import_babel_utils16 = require(\"@marko/compiler/babel-utils\");\nvar attrTagToIdentifierLookup = /* @__PURE__ */ new WeakMap();\nfunction getAttrTagIdentifier(meta) {\n  let name2 = attrTagToIdentifierLookup.get(meta);\n  if (!name2) {\n    name2 = currentProgramPath.scope.generateUid(meta.name);\n    attrTagToIdentifierLookup.set(meta, name2);\n  }\n  return import_compiler27.types.identifier(name2);\n}\nfunction analyzeAttributeTags(tag) {\n  if (tag.node.extra?.attributeTags) return tag.node.extra.attributeTags;\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  if (!attrTags2.length) return;\n  const tagExtra = tag.node.extra ??= {};\n  const lookup = tagExtra.attributeTags = {};\n  const attrTagNodesByName = {};\n  const sampleAttrTagsForControlFlow = /* @__PURE__ */ new Map();\n  for (const child of attrTags2) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils16.isAttributeTag)(child)) {\n        const name2 = getTagName(child);\n        lookup[name2] ||= createAttrTagMeta(name2, [name2]);\n        (attrTagNodesByName[name2] ||= []).push(child);\n        analyzeAttributeTags(child);\n      } else {\n        const isRepeated = (0, import_babel_utils16.isLoopTag)(child);\n        let curGroup;\n        for (const name2 of crawlAttrTags(child, attrTagNodesByName)) {\n          const oldMeta = lookup[name2];\n          if (oldMeta) {\n            if (!curGroup) {\n              curGroup = oldMeta.group;\n            } else if (curGroup !== oldMeta.group) {\n              for (const name3 of oldMeta.group) {\n                lookup[name3].group = curGroup;\n                curGroup.push(name3);\n              }\n            }\n          }\n          let attrTagMeta = lookup[name2];\n          if (!attrTagMeta) {\n            attrTagMeta = lookup[name2] = createAttrTagMeta(name2, []);\n            curGroup = attrTagMeta.group;\n            curGroup.push(name2);\n          }\n          attrTagMeta.dynamic = true;\n          if (isRepeated) {\n            attrTagMeta.repeated = true;\n          }\n          sampleAttrTagsForControlFlow.set(child, name2);\n        }\n      }\n    }\n  }\n  for (const [controlFlowTag, sampleAttrName] of sampleAttrTagsForControlFlow) {\n    (controlFlowTag.node.extra ??= {}).attributeTagGroup = lookup[sampleAttrName].group;\n  }\n  for (const name2 in attrTagNodesByName) {\n    const attrTagMeta = lookup[name2];\n    if (!attrTagMeta.repeated) {\n      const attrTagNodes = attrTagNodesByName[name2];\n      if (attrTagNodes.length > 1) {\n        attrTagMeta.repeated = !attrTagMeta.dynamic || hasRepeatedDynamicAttrTags(attrTagNodes);\n      }\n    }\n  }\n  return lookup;\n}\nfunction createAttrTagMeta(name2, group) {\n  return {\n    name: name2.slice(1),\n    dynamic: false,\n    repeated: false,\n    group\n  };\n}\nfunction crawlAttrTags(tag, attrTagNodesByName, attrTagNames = /* @__PURE__ */ new Set()) {\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  for (const child of attrTags2) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils16.isAttributeTag)(child)) {\n        const tagName = getTagName(child);\n        attrTagNames.add(tagName);\n        (attrTagNodesByName[tagName] ||= []).push(child);\n        analyzeAttributeTags(child);\n      } else {\n        crawlAttrTags(child, attrTagNodesByName, attrTagNames);\n      }\n    }\n  }\n  return attrTagNames;\n}\nfunction hasRepeatedDynamicAttrTags(attrTags2) {\n  let conditionRoot;\n  const seenBranches = /* @__PURE__ */ new Set();\n  for (const attrTag2 of attrTags2) {\n    const parentTag = getParentTag(attrTag2);\n    if (seenBranches.has(parentTag) || !isConditionTag(parentTag)) {\n      return true;\n    }\n    const curConditionRoot = getConditionRoot(parentTag);\n    if (curConditionRoot && curConditionRoot !== (conditionRoot ||= curConditionRoot)) {\n      return true;\n    }\n    seenBranches.add(parentTag);\n  }\n  return false;\n}\nfunction getConditionRoot(tag) {\n  if (getTagName(tag) === \"if\") return tag;\n  let prev = tag.getPrevSibling();\n  while (prev.node) {\n    if (prev.isMarkoTag() && getTagName(prev) === \"if\") {\n      return prev;\n    }\n    prev = prev.getPrevSibling();\n  }\n}\n\n// src/translator/util/translate-attrs.ts\nvar import_compiler30 = require(\"@marko/compiler\");\nvar import_babel_utils19 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/core/for.ts\nvar import_compiler29 = require(\"@marko/compiler\");\nvar import_babel_utils18 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/visitors/tag/native-tag.ts\nvar import_compiler28 = require(\"@marko/compiler\");\nvar import_babel_utils17 = require(\"@marko/compiler/babel-utils\");\nvar kNativeTagBinding = Symbol(\"native tag binding\");\nvar kSerializeMarker = Symbol(\"serialize marker\");\nvar kGetterId = Symbol(\"node getter id\");\nvar htmlSelectArgs = /* @__PURE__ */ new WeakMap();\nfunction assertExclusiveControllableGroups(tag, attrs2) {\n  const exclusiveGroups = [\n    attrs2.open || attrs2.openChange,\n    attrs2.checked || attrs2.checkedChange,\n    attrs2.checkedValue || attrs2.checkedValueChange,\n    attrs2.valueChange\n  ].filter(Boolean);\n  if (exclusiveGroups.length > 1) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The attributes ${exclusiveGroups.map((attr2) => `\"${attr2.name}\"`).join(\", \")} are mutually exclusive.`\n    );\n  }\n}\nfunction getRelatedControllable(tagName, attrs2) {\n  switch (tagName) {\n    case \"input\":\n      if (attrs2.checked || attrs2.checkedChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_checked\",\n          attrs: [attrs2.checked, attrs2.checkedChange]\n        };\n      }\n      if (attrs2.checkedValue || attrs2.checkedValueChange) {\n        return {\n          special: true,\n          helper: \"controllable_input_checkedValue\",\n          attrs: [attrs2.checkedValue, attrs2.checkedValueChange, attrs2.value]\n        };\n      }\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"select\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_select_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"textarea\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_textarea_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"details\":\n    case \"dialog\":\n      if (attrs2.open || attrs2.openChange) {\n        return {\n          special: false,\n          helper: \"controllable_detailsOrDialog_open\",\n          attrs: [attrs2.open, attrs2.openChange]\n        };\n      }\n      break;\n  }\n}\nvar native_tag_default = {\n  transform: {\n    enter(tag) {\n      const tagName = getTagName(tag);\n      if (tagName === \"textarea\" && tag.node.body.body.length) {\n        const parts = [];\n        for (const child of tag.node.body.body) {\n          if (child.type === \"MarkoText\" || child.type === \"MarkoPlaceholder\" && child.escape) {\n            parts.push(child.value);\n          } else {\n            throw tag.hub.file.hub.buildError(\n              child,\n              \"Unexpected content in textarea, only text and placeholders are supported.\",\n              SyntaxError\n            );\n          }\n        }\n        tag.node.attributes.push(\n          import_compiler28.types.markoAttribute(\n            \"value\",\n            normalizeStringExpression(parts) || buildUndefined()\n          )\n        );\n        tag.node.body.body = [];\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils17.assertNoArgs)(tag);\n      (0, import_babel_utils17.assertNoParams)(tag);\n      (0, import_babel_utils17.assertNoAttributeTags)(tag);\n      const { node } = tag;\n      if (node.var && !import_compiler28.types.isIdentifier(node.var)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"Tag variables on native elements cannot be destructured.\"\n        );\n      }\n      const tagName = getTagName(tag);\n      const section = getOrCreateSection(tag);\n      let hasEventHandlers = false;\n      let hasDynamicAttributes = false;\n      const seen = {};\n      const { attributes } = tag.node;\n      let relatedControllable;\n      let spreadReferenceNodes;\n      for (let i = attributes.length; i--; ) {\n        const attr2 = attributes[i];\n        if (import_compiler28.types.isMarkoAttribute(attr2)) {\n          if (seen[attr2.name]) {\n            dropReferences(attr2.value);\n            continue;\n          }\n          seen[attr2.name] = attr2;\n          if (isEventHandler(attr2.name) || isChangeHandler(attr2.name)) {\n            (attr2.value.extra ??= {}).isEffect = true;\n            hasEventHandlers = true;\n          } else if (!evaluate(attr2.value).confident) {\n            hasDynamicAttributes = true;\n          }\n        } else if (import_compiler28.types.isMarkoSpreadAttribute(attr2)) {\n          hasEventHandlers = true;\n          hasDynamicAttributes = true;\n          (attr2.value.extra ??= {}).isEffect = true;\n        }\n        if (spreadReferenceNodes) {\n          spreadReferenceNodes.push(attr2.value);\n        } else if (import_compiler28.types.isMarkoSpreadAttribute(attr2)) {\n          spreadReferenceNodes = [attr2.value];\n          relatedControllable = getRelatedControllable(tagName, seen);\n        }\n      }\n      assertExclusiveControllableGroups(tag, seen);\n      if (spreadReferenceNodes) {\n        if (relatedControllable && !relatedControllable.attrs.every(Boolean)) {\n          for (const attr2 of relatedControllable.attrs) {\n            if (attr2) {\n              spreadReferenceNodes.push(attr2.value);\n            }\n          }\n          relatedControllable = void 0;\n        }\n        mergeReferences(section, tag.node, spreadReferenceNodes);\n      } else {\n        relatedControllable = getRelatedControllable(tagName, seen);\n      }\n      if (relatedControllable) {\n        mergeReferences(\n          section,\n          relatedControllable.attrs.find(Boolean).value,\n          relatedControllable.attrs.map((it) => it?.value)\n        );\n      }\n      if (node.var || hasEventHandlers || hasDynamicAttributes) {\n        currentProgramPath.node.extra.isInteractive ||= hasEventHandlers;\n        const tagName2 = node.name.type === \"StringLiteral\" ? node.name.value : import_compiler28.types.toIdentifier(tag.get(\"name\"));\n        const tagExtra = node.extra ??= {};\n        const bindingName = \"#\" + tagName2;\n        tagExtra[kSerializeMarker] = hasEventHandlers || !!node.var;\n        tagExtra[kNativeTagBinding] = createBinding(\n          bindingName,\n          0 /* dom */,\n          section\n        );\n        if (node.var) {\n          for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n            setReferencesScope(ref);\n            if (!isInvokedFunction(ref)) {\n              tagExtra[kGetterId] = getRegisterUID(section, bindingName);\n              break;\n            }\n          }\n        }\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagName = getTagName(tag);\n      const extra = tag.node.extra;\n      const nodeRef2 = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const name2 = tag.get(\"name\");\n      const tagDef = (0, import_babel_utils17.getTagDef)(tag);\n      const write2 = writeTo(tag);\n      const section = getSection(tag);\n      if (isHTML && extra.tagNameNullable) {\n        flushBefore(tag);\n      }\n      if (tag.has(\"var\")) {\n        const getterId = extra[kGetterId];\n        if (isHTML) {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          for (const reference of references) {\n            let currentSection = getSection(reference);\n            while (currentSection !== section && currentSection.parent) {\n              getSerializedScopeProperties(currentSection).set(\n                import_compiler28.types.stringLiteral(\"_\"),\n                callRuntime(\n                  \"ensureScopeWithId\",\n                  getScopeIdIdentifier(\n                    currentSection = currentSection.parent\n                  )\n                )\n              );\n            }\n          }\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(section),\n              getterId && import_compiler28.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n              `get_${varName}`\n            );\n            currentProgramPath.pushContainer(\n              \"body\",\n              import_compiler28.types.variableDeclaration(\"const\", [\n                import_compiler28.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler28.types.stringLiteral(getterId),\n                    getScopeAccessorLiteral(nodeRef2)\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (isInvokedFunction(reference)) {\n              reference.parentPath.replaceWith(\n                import_compiler28.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, nodeRef2)\n                )\n              );\n            } else if (getterFnIdentifier) {\n              reference.replaceWith(\n                import_compiler28.types.callExpression(getterFnIdentifier, [\n                  getScopeExpression(referenceSection, getSection(tag))\n                ])\n              );\n            }\n          }\n        }\n      }\n      let visitAccessor;\n      if (nodeRef2) {\n        visitAccessor = getScopeAccessorLiteral(nodeRef2);\n        visit(tag, 32 /* Get */);\n      }\n      write2`<${name2.node}`;\n      const usedAttrs = getUsedAttrs(tagName, tag.node);\n      const { staticAttrs, staticControllable, skipExpression } = usedAttrs;\n      let { spreadExpression } = usedAttrs;\n      if (staticControllable) {\n        const { helper, attrs: attrs2 } = staticControllable;\n        const firstAttr = attrs2.find(Boolean);\n        const referencedBindings = firstAttr.value.extra?.referencedBindings;\n        const values = attrs2.map((attr2) => attr2?.value);\n        if (isHTML) {\n          if (tagName !== \"select\" && tagName !== \"textarea\") {\n            write2`${callRuntime(helper, getScopeIdIdentifier(section), visitAccessor, ...values)}`;\n          }\n          addHTMLEffectCall(section, void 0);\n        } else {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            import_compiler28.types.expressionStatement(\n              callRuntime(helper, scopeIdentifier, visitAccessor, ...values)\n            )\n          );\n          addStatement(\n            \"effect\",\n            section,\n            void 0,\n            import_compiler28.types.expressionStatement(\n              callRuntime(`${helper}_effect`, scopeIdentifier, visitAccessor)\n            )\n          );\n        }\n      }\n      let writeAtStartOfBody;\n      if (isHTML) {\n        if (tagName === \"select\") {\n          if (staticControllable) {\n            htmlSelectArgs.set(tag.node, {\n              value: staticControllable.attrs[0]?.value || buildUndefined(),\n              valueChange: staticControllable.attrs[1]?.value || buildUndefined()\n            });\n          } else if (spreadExpression) {\n            const spreadIdentifier = tag.scope.generateUidIdentifier(\"select_input\");\n            tag.insertBefore(\n              import_compiler28.types.variableDeclaration(\"const\", [\n                import_compiler28.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            htmlSelectArgs.set(tag.node, {\n              value: import_compiler28.types.memberExpression(\n                spreadIdentifier,\n                import_compiler28.types.identifier(\"value\")\n              ),\n              valueChange: import_compiler28.types.memberExpression(\n                spreadIdentifier,\n                import_compiler28.types.identifier(\"valueChange\")\n              )\n            });\n            spreadExpression = spreadIdentifier;\n          }\n        } else if (tagName === \"textarea\") {\n          let value;\n          let valueChange;\n          if (staticControllable) {\n            value = staticControllable.attrs[0]?.value;\n            valueChange = staticControllable.attrs[1]?.value;\n          } else if (spreadExpression) {\n            const spreadIdentifier = tag.scope.generateUidIdentifier(\"textarea_input\");\n            tag.insertBefore(\n              import_compiler28.types.variableDeclaration(\"const\", [\n                import_compiler28.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            value = import_compiler28.types.memberExpression(spreadIdentifier, import_compiler28.types.identifier(\"value\"));\n            valueChange = import_compiler28.types.memberExpression(\n              spreadIdentifier,\n              import_compiler28.types.identifier(\"valueChange\")\n            );\n            spreadExpression = spreadIdentifier;\n          }\n          if (value || valueChange) {\n            writeAtStartOfBody = callRuntime(\n              \"controllable_textarea_value\",\n              getScopeIdIdentifier(getSection(tag)),\n              getScopeAccessorLiteral(nodeRef2),\n              value,\n              valueChange\n            );\n          }\n        }\n      }\n      for (const attr2 of staticAttrs) {\n        const { name: name3, value } = attr2;\n        const { confident, computed } = value.extra || {};\n        const valueReferences = value.extra?.referencedBindings;\n        if (isHTML && tagName === \"option\" && name3 === \"value\") {\n          write2`${callRuntime(\"optionValueAttr\", value)}`;\n          continue;\n        }\n        switch (name3) {\n          case \"class\":\n          case \"style\": {\n            const helper = `${name3}Attr`;\n            if (confident) {\n              write2`${getHTMLRuntime()[helper](computed)}`;\n            } else if (isHTML) {\n              write2`${callRuntime(helper, value)}`;\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler28.types.expressionStatement(\n                  callRuntime(\n                    helper,\n                    import_compiler28.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n          }\n          default:\n            if (confident) {\n              write2`${getHTMLRuntime().attr(name3, computed)}`;\n            } else if (isHTML) {\n              if (isEventHandler(name3)) {\n                addHTMLEffectCall(section, valueReferences);\n              } else {\n                write2`${callRuntime(\"attr\", import_compiler28.types.stringLiteral(name3), value)}`;\n              }\n            } else if (isEventHandler(name3)) {\n              addStatement(\n                \"effect\",\n                section,\n                valueReferences,\n                import_compiler28.types.expressionStatement(\n                  callRuntime(\n                    \"on\",\n                    import_compiler28.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler28.types.stringLiteral(getEventHandlerName(name3)),\n                    value\n                  )\n                )\n              );\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler28.types.expressionStatement(\n                  callRuntime(\n                    \"attr\",\n                    import_compiler28.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler28.types.stringLiteral(name3),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n        }\n      }\n      if (spreadExpression) {\n        if (isHTML) {\n          addHTMLEffectCall(section, extra.referencedBindings);\n          if (skipExpression) {\n            write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(section), name2.node)}`;\n          } else {\n            write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(section), name2.node)}`;\n          }\n        } else {\n          if (skipExpression) {\n            addStatement(\n              \"render\",\n              section,\n              extra.referencedBindings,\n              import_compiler28.types.expressionStatement(\n                callRuntime(\n                  \"partialAttrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression,\n                  skipExpression\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              extra.referencedBindings,\n              import_compiler28.types.expressionStatement(\n                callRuntime(\n                  \"attrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression\n                )\n              )\n            );\n          }\n          addStatement(\n            \"effect\",\n            section,\n            extra.referencedBindings,\n            import_compiler28.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            false\n          );\n        }\n      }\n      if (tagDef && tagDef.parseOptions?.openTagOnly) {\n        switch (tagDef.htmlType) {\n          case \"svg\":\n          case \"math\":\n            write2`/>`;\n            break;\n          default:\n            write2`>`;\n            break;\n        }\n      } else {\n        write2`>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(import_compiler28.types.ifStatement(name2.node, consumeHTML(tag)))[0].skip();\n      }\n      if (writeAtStartOfBody) {\n        write2`${writeAtStartOfBody}`;\n      }\n      enter2(tag);\n    },\n    exit(tag) {\n      const extra = tag.node.extra;\n      const nodeRef2 = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const openTagOnly = (0, import_babel_utils17.getTagDef)(tag)?.parseOptions?.openTagOnly;\n      const selectArgs = isHTML && htmlSelectArgs.get(tag.node);\n      const tagName = getTagName(tag);\n      if (isHTML && extra.tagNameNullable) {\n        flushInto(tag);\n      }\n      if (selectArgs) {\n        writeTo(tag)`</${tag.node.name}>`;\n        flushInto(tag);\n        tag.insertBefore(\n          import_compiler28.types.expressionStatement(\n            callRuntime(\n              \"controllable_select_value\",\n              getScopeIdIdentifier(getSection(tag)),\n              getScopeAccessorLiteral(nodeRef2),\n              selectArgs.value,\n              selectArgs.valueChange,\n              import_compiler28.types.arrowFunctionExpression(\n                [],\n                import_compiler28.types.blockStatement(tag.node.body.body)\n              )\n            )\n          )\n        );\n      } else {\n        tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n      }\n      if (!openTagOnly && !selectArgs) {\n        writeTo(\n          tag,\n          isHTML && (tagName === \"html\" || tagName === \"body\")\n        )`</${tag.node.name}>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(\n          import_compiler28.types.ifStatement(tag.node.name, consumeHTML(tag))\n        )[0].skip();\n      }\n      if (nodeRef2 && (extra[kSerializeMarker] || isStatefulReferences(extra.referencedBindings) || tag.node.attributes.some(\n        (attr2) => isStatefulReferences(attr2.value.extra?.referencedBindings)\n      ))) {\n        markNode(tag, nodeRef2);\n      }\n      exit2(tag);\n      tag.remove();\n    }\n  }\n};\nfunction getUsedAttrs(tagName, tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  let staticControllable;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler28.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n        staticControllable = getRelatedControllable(tagName, seen);\n        if (staticControllable && !staticControllable.attrs.every(Boolean)) {\n          for (const attr3 of staticControllable.attrs) {\n            if (attr3) {\n              spreadProps.push(toObjectProperty(attr3.name, attr3.value));\n              maybeStaticAttrs.delete(attr3);\n            }\n          }\n          staticControllable = void 0;\n        }\n      }\n      spreadProps.push(import_compiler28.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  if (!spreadProps) {\n    staticControllable = getRelatedControllable(tagName, seen);\n    if (staticControllable?.special === false && !staticControllable.attrs[1]) {\n      staticControllable = void 0;\n    }\n  }\n  if (staticControllable) {\n    for (const attr2 of staticControllable.attrs) {\n      if (attr2) {\n        maybeStaticAttrs.delete(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    if (staticControllable) {\n      for (const attr2 of staticControllable.attrs) {\n        if (attr2) {\n          (skipProps ||= []).push(\n            toObjectProperty(attr2.name, import_compiler28.types.numericLiteral(1))\n          );\n        }\n      }\n    }\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler28.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler28.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    staticControllable,\n    spreadExpression,\n    skipExpression\n  };\n}\nfunction isChangeHandler(propName) {\n  return /^(?:value|checked(?:Value)?|open)Change/.test(propName);\n}\nfunction buildUndefined() {\n  return import_compiler28.types.unaryExpression(\"void\", import_compiler28.types.numericLiteral(0));\n}\nfunction isInvokedFunction(expr) {\n  const { parent, node } = expr;\n  return parent.type === \"CallExpression\" && parent.callee === node;\n}\n\n// src/translator/core/for.ts\nvar kForMarkerBinding = Symbol(\"for marker binding\");\nvar kOnlyChildInParent = Symbol(\"only child in parent\");\nvar for_default = {\n  analyze(tag) {\n    const tagExtra = tag.node.extra ??= {};\n    const isAttrTag = tag.node.body.attributeTags;\n    let allowAttrs;\n    (0, import_babel_utils18.assertNoVar)(tag);\n    (0, import_babel_utils18.assertNoArgs)(tag);\n    assertNoSpreadAttrs(tag);\n    switch (getForType(tag.node)) {\n      case \"of\":\n        allowAttrs = [\"of\"];\n        break;\n      case \"in\":\n        allowAttrs = [\"in\"];\n        break;\n      case \"to\":\n        allowAttrs = [\"to\", \"from\", \"step\"];\n        break;\n      default:\n        throw tag.buildCodeFrameError(\n          \"Invalid `for` tag, missing an `of=`, `in=`, `to=` attribute.\"\n        );\n    }\n    if (!isAttrTag) {\n      allowAttrs.push(\"by\");\n    }\n    (0, import_babel_utils18.assertAllowedAttributes)(tag, allowAttrs);\n    if (isAttrTag) return;\n    const tagBody = tag.get(\"body\");\n    const bodySection = startSection(tagBody);\n    if (!bodySection) {\n      dropReferences(getAllTagReferenceNodes(tag.node));\n      return;\n    }\n    bodySection.isBranch = true;\n    const section = getOrCreateSection(tag);\n    if (isOnlyChildInParent(tag)) {\n      const parentTag = getParentTag(tag).node;\n      const parentTagName = parentTag.name?.value;\n      (parentTag.extra ??= {})[kNativeTagBinding] ??= createBinding(\n        \"#\" + parentTagName,\n        0 /* dom */,\n        section\n      );\n    } else {\n      tagExtra[kForMarkerBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section\n      );\n    }\n    trackParamsReferences(tagBody, 3 /* param */, void 0, tagExtra);\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n    bodySection.upstreamExpression = tagExtra;\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        if (!isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n        flushBefore(tag);\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const isStateful = isStatefulReferences(tagExtra.referencedBindings);\n        const parentTag = getParentTag(tag);\n        const nodeRef2 = isOnlyChildInParent(tag) ? parentTag.node.extra[kNativeTagBinding] : tag.node.extra[kForMarkerBinding];\n        const forAttrs = getKnownAttrValues(node);\n        const forType = getForType(node);\n        const params = node.body.params;\n        const statements = [];\n        const bodyStatements = node.body.body;\n        const hasStatefulClosures = checkStatefulClosures(bodySection, true);\n        const singleNodeOptimization = bodySection.content === null || bodySection.content.singleChild;\n        let keyExpression;\n        if (isStateful && isOnlyChildInParent(tag)) {\n          parentTag.node.extra[kSerializeMarker] = true;\n        }\n        if (isStateful || hasStatefulClosures) {\n          const defaultParamNames = {\n            of: [\"list\", \"index\"],\n            in: [\"key\", \"value\"],\n            to: [\"value\"]\n          }[forType];\n          const defaultByParamIndex = forType === \"of\" ? 1 : 0;\n          const requiredParamsIndex = forAttrs.by ? defaultParamNames.length - 1 : defaultByParamIndex;\n          setForceResumeScope(bodySection);\n          for (let i = 0; i <= requiredParamsIndex; i++) {\n            const existingParam = params[i];\n            if (!existingParam || !import_compiler29.types.isIdentifier(existingParam)) {\n              const id = params[i] = currentProgramPath.scope.generateUidIdentifier(\n                defaultParamNames[i]\n              );\n              if (existingParam) {\n                bodyStatements.unshift(\n                  import_compiler29.types.variableDeclaration(\"let\", [\n                    import_compiler29.types.variableDeclarator(existingParam, id)\n                  ])\n                );\n              }\n            }\n          }\n          if (forAttrs.by) {\n            if (import_compiler29.types.isStringLiteral(forAttrs.by)) {\n              keyExpression = toMemberExpression(\n                params[0],\n                forAttrs.by.value\n              );\n            } else if (import_compiler29.types.isFunction(forAttrs.by)) {\n              const byIdentifier = currentProgramPath.scope.generateUidIdentifier(\"by\");\n              statements.push(\n                import_compiler29.types.variableDeclaration(\"const\", [\n                  import_compiler29.types.variableDeclarator(byIdentifier, forAttrs.by)\n                ])\n              );\n              keyExpression = import_compiler29.types.callExpression(\n                byIdentifier,\n                params\n              );\n            } else {\n              keyExpression = callRuntime(\n                forTypeToHTMLByRuntime(forType),\n                forAttrs.by,\n                ...params\n              );\n            }\n          } else {\n            keyExpression = params[defaultByParamIndex];\n          }\n          const forScopesIdentifier = getScopeIdentifier(bodySection);\n          statements.push(\n            import_compiler29.types.variableDeclaration(\"const\", [\n              import_compiler29.types.variableDeclarator(\n                forScopesIdentifier,\n                import_compiler29.types.newExpression(import_compiler29.types.identifier(\"Map\"), [])\n              )\n            ])\n          );\n          if (keyExpression && (isStateful || hasStatefulClosures)) {\n            bodyStatements.push(\n              import_compiler29.types.expressionStatement(\n                import_compiler29.types.callExpression(\n                  import_compiler29.types.memberExpression(\n                    getScopeIdentifier(bodySection),\n                    import_compiler29.types.identifier(\"set\")\n                  ),\n                  [\n                    keyExpression,\n                    callRuntime(\n                      \"ensureScopeWithId\",\n                      getScopeIdIdentifier(bodySection)\n                    )\n                  ]\n                )\n              )\n            );\n          }\n          getSerializedScopeProperties(tagSection).set(\n            import_compiler29.types.stringLiteral(\n              getScopeAccessorLiteral(nodeRef2).value + \"(\" /* LoopScopeMap */\n            ),\n            import_compiler29.types.conditionalExpression(\n              import_compiler29.types.memberExpression(forScopesIdentifier, import_compiler29.types.identifier(\"size\")),\n              forScopesIdentifier,\n              import_compiler29.types.identifier(\"undefined\")\n            )\n          );\n        }\n        flushInto(tag);\n        setClosureSignalBuilder(tag, () => {\n        });\n        writeHTMLResumeStatements(tagBody);\n        const forTagArgs = getBaseArgsInForTag(forType, forAttrs);\n        const forTagHTMLRuntime = isStateful ? forTypeToHTMLResumeRuntime(forType, singleNodeOptimization) : forTypeToRuntime(forType);\n        forTagArgs.push(\n          import_compiler29.types.arrowFunctionExpression(params, import_compiler29.types.blockStatement(bodyStatements))\n        );\n        if (isStateful) {\n          forTagArgs.push(\n            getScopeIdIdentifier(tagSection),\n            getScopeAccessorLiteral(nodeRef2)\n          );\n        }\n        statements.push(\n          import_compiler29.types.expressionStatement(callRuntime(forTagHTMLRuntime, ...forTagArgs))\n        );\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        if (!isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const { referencedBindings } = tagExtra;\n        const nodeRef2 = isOnlyChildInParent(tag) ? getParentTag(tag).node.extra[kNativeTagBinding] : tag.node.extra[kForMarkerBinding];\n        setClosureSignalBuilder(tag, (_closureSignal, render, intersection) => {\n          return callRuntime(\n            \"loopClosure\",\n            getScopeAccessorLiteral(nodeRef2),\n            render,\n            intersection\n          );\n        });\n        const forType = getForType(node);\n        const signal = getSignal(tagSection, nodeRef2, \"for\");\n        signal.build = () => {\n          return callRuntime(\n            forTypeToDOMRuntime(forType),\n            getScopeAccessorLiteral(nodeRef2),\n            import_compiler29.types.identifier(bodySection.name)\n          );\n        };\n        const params = node.body.params;\n        signal.hasDownstreamIntersections = () => {\n          if (bodySection.closures) {\n            return true;\n          }\n          for (const param of params) {\n            const binding = param.extra?.binding;\n            if (binding) {\n              for (const {\n                referencedBindings: referencedBindings2\n              } of binding.downstreamExpressions) {\n                if (getSignal(\n                  bodySection,\n                  referencedBindings2\n                ).hasDownstreamIntersections()) {\n                  return true;\n                }\n              }\n            }\n          }\n          return false;\n        };\n        const forAttrs = getKnownAttrValues(node);\n        const loopArgs = getBaseArgsInForTag(forType, forAttrs);\n        if (forAttrs.by) {\n          loopArgs.push(forAttrs.by);\n        }\n        addValue(\n          tagSection,\n          referencedBindings,\n          signal,\n          import_compiler29.types.arrayExpression(loopArgs)\n        );\n        tag.remove();\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  attributes: {\n    of: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over a list of items.\"\n        }\n      ]\n    },\n    in: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over the keys and values of an object.\"\n        }\n      ]\n    },\n    to: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates up to the provided number (inclusive)\"\n        }\n      ]\n    },\n    from: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates starting from the provided number (inclusive)\"\n        }\n      ]\n    },\n    step: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"The amount to increment during each interation (with from/to)\"\n        }\n      ]\n    }\n  },\n  autocomplete: [\n    {\n      snippet: \"for|${1:value, index}| of=${3:array}\",\n      description: \"Use to iterate over lists, object properties, or between ranges.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-a-list\"\n    },\n    {\n      snippet: \"for|${1:name, value}| in=${3:object}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties\"\n    },\n    {\n      snippet: \"for|${1:index}| to=${2:number}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers\"\n    }\n  ]\n};\nfunction buildForRuntimeCall(type, attrs2, params, statements) {\n  return import_compiler29.types.expressionStatement(\n    callRuntime(\n      forTypeToRuntime(type),\n      ...getBaseArgsInForTag(type, attrs2),\n      import_compiler29.types.arrowFunctionExpression(params, import_compiler29.types.blockStatement(statements))\n    )\n  );\n}\nfunction getForType(tag) {\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      switch (attr2.name) {\n        case \"of\":\n        case \"in\":\n        case \"to\":\n          return attr2.name;\n      }\n    }\n  }\n}\nfunction forTypeToRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"forOf\";\n    case \"in\":\n      return \"forIn\";\n    case \"to\":\n      return \"forTo\";\n  }\n}\nfunction forTypeToHTMLResumeRuntime(type, singleNodeOptimization) {\n  if (singleNodeOptimization) {\n    switch (type) {\n      case \"of\":\n        return \"resumeSingleNodeForOf\";\n      case \"in\":\n        return \"resumeSingleNodeForIn\";\n      case \"to\":\n        return \"resumeSingleNodeForTo\";\n    }\n  } else {\n    switch (type) {\n      case \"of\":\n        return \"resumeForOf\";\n      case \"in\":\n        return \"resumeForIn\";\n      case \"to\":\n        return \"resumeForTo\";\n    }\n  }\n}\nfunction forTypeToDOMRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"loopOf\";\n    case \"in\":\n      return \"loopIn\";\n    case \"to\":\n      return \"loopTo\";\n  }\n}\nfunction forTypeToHTMLByRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"forOfBy\";\n    case \"in\":\n      return \"forInBy\";\n    case \"to\":\n      return \"forToBy\";\n  }\n}\nfunction getBaseArgsInForTag(type, attrs2) {\n  switch (type) {\n    case \"in\":\n      return [attrs2.in];\n    case \"of\":\n      return [attrs2.of];\n    case \"to\":\n      return [\n        attrs2.to,\n        attrs2.from || import_compiler29.types.numericLiteral(0),\n        attrs2.step || import_compiler29.types.numericLiteral(1)\n      ];\n  }\n}\nfunction isOnlyChildInParent(tag) {\n  const extra = tag.node.extra;\n  if (extra[kOnlyChildInParent] !== void 0) {\n    return extra[kOnlyChildInParent];\n  }\n  const parentTag = getParentTag(tag);\n  if (parentTag && (0, import_babel_utils18.getTagDef)(parentTag)?.html) {\n    return extra[kOnlyChildInParent] = tag.parent.body.length === 1;\n  }\n  return extra[kOnlyChildInParent] = false;\n}\n\n// src/translator/util/translate-attrs.ts\nvar contentProps = /* @__PURE__ */ new WeakSet();\nfunction translateAttrs(tag, templateExports, statements = [], contentKey = \"content\") {\n  const seen = /* @__PURE__ */ new Set();\n  const properties = [];\n  const attrTagLookup = tag.node.extra?.attributeTags;\n  if (attrTagLookup) {\n    for (const name2 in attrTagLookup) {\n      const attrTagMeta = attrTagLookup[name2];\n      if (usesExport(templateExports, attrTagMeta.name)) {\n        seen.add(attrTagMeta.name);\n        if (attrTagMeta.dynamic) {\n          statements.push(\n            import_compiler30.types.variableDeclaration(\"let\", [\n              import_compiler30.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta))\n            ])\n          );\n          properties.push(\n            toObjectProperty(\n              attrTagMeta.name,\n              getAttrTagIdentifier(attrTagMeta)\n            )\n          );\n        }\n      }\n    }\n    const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils19.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          if (attrTagMeta.dynamic) {\n            i = addDynamicAttrTagStatements(\n              attrTags2,\n              i,\n              attrTagLookup,\n              statements,\n              templateExports,\n              contentKey\n            );\n          } else {\n            const translatedAttrTag = translateAttrs(\n              child,\n              templateExports?.[attrTagMeta.name]?.props,\n              statements,\n              contentKey\n            );\n            if (attrTagMeta.repeated) {\n              const prevProp = findObjectProperty(attrTagMeta.name, properties);\n              if (prevProp) {\n                prevProp.value = callRuntime(\n                  \"attrTags\",\n                  prevProp.value,\n                  propsToExpression(translatedAttrTag.properties)\n                );\n              } else {\n                properties.push(\n                  toObjectProperty(\n                    attrTagMeta.name,\n                    callRuntime(\n                      \"attrTag\",\n                      propsToExpression(translatedAttrTag.properties)\n                    )\n                  )\n                );\n              }\n            } else {\n              properties.push(\n                toObjectProperty(\n                  attrTagMeta.name,\n                  callRuntime(\n                    \"attrTag\",\n                    propsToExpression(translatedAttrTag.properties)\n                  )\n                )\n              );\n            }\n          }\n        } else {\n          i = addDynamicAttrTagStatements(\n            attrTags2,\n            i,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        }\n      }\n    }\n  }\n  if (!seen.has(contentKey) && usesExport(templateExports, contentKey)) {\n    seen.add(contentKey);\n    const contentExpression = buildContent(tag.get(\"body\"));\n    if (contentExpression) {\n      const contentProp = import_compiler30.types.objectProperty(\n        import_compiler30.types.identifier(contentKey),\n        contentExpression\n      );\n      contentProps.add(contentProp);\n      properties.push(contentProp);\n    }\n  }\n  const { attributes } = tag.node;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler30.types.isMarkoSpreadAttribute(attr2)) {\n      properties.push(import_compiler30.types.spreadElement(value));\n    } else if (!seen.has(attr2.name) && usesExport(templateExports, attr2.name)) {\n      seen.add(attr2.name);\n      properties.push(toObjectProperty(attr2.name, value));\n    }\n  }\n  properties.reverse();\n  return { properties, statements };\n}\nfunction getTranslatedBodyContentProperty(props) {\n  for (const prop of props) {\n    if (contentProps.has(prop)) {\n      return prop;\n    }\n  }\n}\nfunction addDynamicAttrTagStatements(attrTags2, index, attrTagLookup, statements, templateExports, contentKey = \"content\") {\n  const tag = attrTags2[index];\n  if (tag.isMarkoTag()) {\n    if ((0, import_babel_utils19.isAttributeTag)(tag)) {\n      const attrTagMeta = attrTagLookup[getTagName(tag)];\n      if (usesExport(templateExports, attrTagMeta.name) && attrTagMeta.dynamic) {\n        const translatedAttrTag = translateAttrs(\n          tag,\n          templateExports?.[attrTagMeta.name]?.props,\n          statements,\n          contentKey\n        );\n        if (attrTagMeta.repeated) {\n          statements.push(\n            import_compiler30.types.expressionStatement(\n              import_compiler30.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTags\",\n                  getAttrTagIdentifier(attrTagMeta),\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        } else {\n          statements.push(\n            import_compiler30.types.expressionStatement(\n              import_compiler30.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTag\",\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        }\n      }\n    } else {\n      switch (getTagName(tag)) {\n        case \"if\":\n          return translateIfAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        case \"for\": {\n          return translateForAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        }\n      }\n    }\n  }\n  return index;\n}\nfunction propsToExpression(props) {\n  return props.length === 1 && import_compiler30.types.isSpreadElement(props[0]) ? props[0].argument : import_compiler30.types.objectExpression(props);\n}\nfunction translateForAttrTag(attrTags2, index, attrTagLookup, statements, templateExports, contentKey) {\n  const forTag = attrTags2[index];\n  const bodyStatements = [];\n  addAllAttrTagsAsDynamic(\n    forTag,\n    attrTagLookup,\n    bodyStatements,\n    templateExports,\n    contentKey\n  );\n  statements.push(\n    buildForRuntimeCall(\n      getForType(forTag.node),\n      getKnownAttrValues(forTag.node),\n      forTag.node.body.params,\n      bodyStatements\n    )\n  );\n  return index;\n}\nfunction translateIfAttrTag(attrTags2, index, attrTagLookup, statements, templateExports, contentKey) {\n  const ifTag = attrTags2[index];\n  const consequentStatements = [];\n  let ifStatement = import_compiler30.types.ifStatement(\n    getConditionTestValue(ifTag),\n    import_compiler30.types.blockStatement(consequentStatements)\n  );\n  statements.push(ifStatement);\n  addAllAttrTagsAsDynamic(\n    ifTag,\n    attrTagLookup,\n    consequentStatements,\n    templateExports,\n    contentKey\n  );\n  let nextIndex = index + 1;\n  while (nextIndex < attrTags2.length) {\n    const nextTag = attrTags2[nextIndex];\n    if (nextTag.isMarkoTag()) {\n      switch (getTagName(nextTag)) {\n        case \"else-if\":\n        case \"else\": {\n          const testValue = getConditionTestValue(nextTag);\n          const alternateStatements = [];\n          addAllAttrTagsAsDynamic(\n            nextTag,\n            attrTagLookup,\n            alternateStatements,\n            templateExports,\n            contentKey\n          );\n          if (testValue) {\n            ifStatement.alternate = ifStatement = import_compiler30.types.ifStatement(\n              testValue,\n              import_compiler30.types.blockStatement(alternateStatements)\n            );\n            nextIndex++;\n            continue;\n          } else {\n            ifStatement.alternate = import_compiler30.types.blockStatement(alternateStatements);\n            break;\n          }\n        }\n      }\n    }\n    break;\n  }\n  return nextIndex - 1;\n}\nfunction addAllAttrTagsAsDynamic(tag, attrTagLookup, statements, templateExports, contentKey) {\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  for (let i = 0; i < attrTags2.length; i++) {\n    i = addDynamicAttrTagStatements(\n      attrTags2,\n      i,\n      attrTagLookup,\n      statements,\n      templateExports,\n      contentKey\n    );\n  }\n}\nfunction usesExport(templateExports, name2) {\n  return !templateExports || !!templateExports[name2];\n}\nfunction findObjectProperty(name2, props) {\n  for (const prop of props) {\n    if (prop.type === \"ObjectProperty\") {\n      switch (prop.key.type) {\n        case \"StringLiteral\":\n          if (prop.key.value === name2) {\n            return prop;\n          }\n          break;\n        case \"Identifier\":\n          if (prop.key.name === name2) {\n            return prop;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\nfunction getConditionTestValue({\n  node: { attributes }\n}) {\n  return attributes.length === 1 ? attributes[0].value : void 0;\n}\nfunction buildContent(body) {\n  const bodySection = body.node.extra?.section;\n  if (bodySection) {\n    if (isOutputHTML()) {\n      return callRuntime(\n        \"register\",\n        callRuntime(\n          \"createRenderer\",\n          import_compiler30.types.arrowFunctionExpression(\n            body.node.params,\n            import_compiler30.types.blockStatement(body.node.body)\n          )\n        ),\n        import_compiler30.types.stringLiteral(getResumeRegisterId(bodySection, \"renderer\")),\n        getScopeIdIdentifier(\n          getSection(\n            getNonAttributeTagParent(body.parentPath)\n          )\n        )\n      );\n    } else {\n      return import_compiler30.types.callExpression(import_compiler30.types.identifier(bodySection.name), [\n        scopeIdentifier\n      ]);\n    }\n  }\n}\nfunction getNonAttributeTagParent(tag) {\n  let cur = tag;\n  while ((0, import_babel_utils19.isAttributeTag)(cur) || (0, import_babel_utils19.isTransparentTag)(cur)) {\n    cur = getParentTag(cur);\n  }\n  return cur;\n}\n\n// src/translator/core/define.ts\nvar define_default = {\n  analyze(tag) {\n    (0, import_babel_utils20.assertNoArgs)(tag);\n    if (!tag.node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `define` tag requires a tag variable.\");\n    }\n    const tagBody = tag.get(\"body\");\n    startSection(tagBody);\n    trackVarReferences(tag, 4 /* derived */);\n    trackParamsReferences(tagBody, 3 /* param */);\n    analyzeAttributeTags(tag);\n    mergeReferences(\n      getOrCreateSection(tag),\n      tag.node,\n      getAllTagReferenceNodes(tag.node)\n    );\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const translatedAttrs = translateAttrs(tag);\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        tag.insertBefore(translatedAttrs.statements);\n        translateVar(tag, propsToExpression(translatedAttrs.properties));\n      } else {\n        const section = getSection(tag);\n        const referencedBindings = node.extra?.referencedBindings;\n        const derivation = initValue(tag.get(\"var\").node.extra.binding);\n        if (translatedAttrs.statements.length) {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            translatedAttrs.statements\n          );\n        }\n        addValue(\n          section,\n          referencedBindings,\n          derivation,\n          propsToExpression(translatedAttrs.properties)\n        );\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a constant object binding that can be rendered.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#define\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/define.d.marko\"\n};\n\n// src/translator/core/effect.ts\nvar import_compiler32 = require(\"@marko/compiler\");\nvar import_babel_utils21 = require(\"@marko/compiler/babel-utils\");\nvar effect_default = {\n  migrate: [\n    (tag) => {\n      (0, import_babel_utils21.assertNoArgs)(tag);\n      (0, import_babel_utils21.assertNoParams)(tag);\n      assertNoBodyContent(tag);\n      (0, import_babel_utils21.assertNoAttributeTags)(tag);\n      assertNoSpreadAttrs(tag);\n      (0, import_babel_utils21.assertAllowedAttributes)(tag, [\"value\"]);\n      (0, import_babel_utils21.diagnosticDeprecate)(tag, {\n        label: \"The 'effect' tag has been replaced by the 'script' tag.\",\n        fix() {\n          const { node } = tag;\n          tag.replaceWith(\n            import_compiler32.types.markoTag(\n              withPreviousLocation(import_compiler32.types.stringLiteral(\"script\"), node.name),\n              node.attributes,\n              node.body,\n              node.arguments,\n              node.var,\n              node.attributeTags\n            )\n          );\n        }\n      });\n    }\n  ],\n  attributes: {},\n  types: runtime_info_default.name + \"/tag-types/effect.d.marko\"\n};\n\n// src/translator/core/export.ts\nvar import_babel_utils22 = require(\"@marko/compiler/babel-utils\");\nvar export_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils22.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"export <value>\"\n    }\n  ]\n};\n\n// src/translator/core/html-comment.ts\nvar import_compiler33 = require(\"@marko/compiler\");\nvar import_babel_utils23 = require(\"@marko/compiler/babel-utils\");\nvar kCommentTagBinding = Symbol(\"comment tag binding\");\nvar kGetterId2 = Symbol(\"node getter id\");\nvar html_comment_default = {\n  analyze(tag) {\n    (0, import_babel_utils23.assertNoArgs)(tag);\n    (0, import_babel_utils23.assertNoParams)(tag);\n    (0, import_babel_utils23.assertNoAttributes)(tag);\n    const tagVar = tag.node.var;\n    let needsBinding = false;\n    let needsGetter = false;\n    if (tagVar) {\n      if (!import_compiler33.types.isIdentifier(tagVar)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"The `html-comment` tag variable cannot be destructured.\"\n        );\n      }\n      needsBinding = true;\n      for (const ref of tag.scope.getBinding(tagVar.name).referencePaths) {\n        if (!ref.parentPath?.isCallExpression()) {\n          needsGetter = true;\n          break;\n        }\n      }\n    }\n    const referenceNodes = [];\n    for (const child of tag.get(\"body\").get(\"body\")) {\n      if (child.isMarkoPlaceholder()) {\n        referenceNodes.push(child.node.value);\n        needsBinding = true;\n      } else if (!child.isMarkoText()) {\n        throw child.buildCodeFrameError(\n          \"Invalid child. Only text is allowed inside an html comment.\"\n        );\n      }\n    }\n    if (needsBinding) {\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      if (needsGetter) {\n        tagExtra[kGetterId2] = getRegisterUID(section, \"comment\");\n      }\n      tagExtra[kCommentTagBinding] = createBinding(\n        \"#comment\",\n        0 /* dom */,\n        section\n      );\n      mergeReferences(section, tag.node, referenceNodes);\n    }\n    tag.skip();\n  },\n  translate(tag) {\n    const tagExtra = tag.node.extra;\n    const commentBinding = tagExtra[kCommentTagBinding];\n    const hasVar = !!tag.node.var;\n    if (hasVar) {\n      const getterId = tagExtra[kGetterId2];\n      if (isOutputHTML()) {\n        translateVar(\n          tag,\n          callRuntime(\n            \"nodeRef\",\n            getterId && getScopeIdIdentifier(getSection(tag)),\n            getterId && import_compiler33.types.stringLiteral(getterId)\n          )\n        );\n      } else {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        let getterFnIdentifier;\n        if (getterId) {\n          getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n            `get_${varName}`\n          );\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler33.types.variableDeclaration(\"const\", [\n              import_compiler33.types.variableDeclarator(\n                getterFnIdentifier,\n                callRuntime(\n                  \"nodeRef\",\n                  import_compiler33.types.stringLiteral(getterId),\n                  getScopeAccessorLiteral(commentBinding)\n                )\n              )\n            ])\n          );\n        }\n        for (const reference of references) {\n          const referenceSection = getSection(reference);\n          if (reference.parentPath?.isCallExpression()) {\n            reference.parentPath.replaceWith(\n              import_compiler33.types.expressionStatement(\n                createScopeReadExpression(referenceSection, commentBinding)\n              )\n            );\n          } else if (getterFnIdentifier) {\n            reference.replaceWith(\n              import_compiler33.types.callExpression(getterFnIdentifier, [\n                getScopeExpression(referenceSection, getSection(tag))\n              ])\n            );\n          }\n        }\n      }\n    }\n    if (tagExtra[kCommentTagBinding]) {\n      visit(tag, 32 /* Get */);\n    }\n    const write2 = writeTo(tag);\n    enter2(tag);\n    write2`<!--`;\n    if (isOutputHTML()) {\n      for (const child of tag.node.body.body) {\n        if (import_compiler33.types.isMarkoText(child)) {\n          write2`${child.value}`;\n        } else if (import_compiler33.types.isMarkoPlaceholder(child)) {\n          write2`${callRuntime(\"escapeXML\", child.value)}`;\n        }\n      }\n    } else {\n      const templateQuasis = [];\n      const templateExpressions = [];\n      let currentQuasi = \"\";\n      for (const child of tag.node.body.body) {\n        if (import_compiler33.types.isMarkoText(child)) {\n          currentQuasi += child.value;\n        } else if (import_compiler33.types.isMarkoPlaceholder(child)) {\n          templateQuasis.push(import_compiler33.types.templateElement({ raw: currentQuasi }));\n          templateExpressions.push(child.value);\n          currentQuasi = \"\";\n        }\n      }\n      if (templateExpressions.length === 0) {\n        write2`${currentQuasi}`;\n      } else {\n        templateQuasis.push(import_compiler33.types.templateElement({ raw: currentQuasi }));\n        addStatement(\n          \"render\",\n          getSection(tag),\n          tagExtra.referencedBindings,\n          import_compiler33.types.expressionStatement(\n            callRuntime(\n              \"data\",\n              import_compiler33.types.memberExpression(\n                scopeIdentifier,\n                getScopeAccessorLiteral(commentBinding),\n                true\n              ),\n              import_compiler33.types.templateLiteral(templateQuasis, templateExpressions)\n            )\n          )\n        );\n      }\n    }\n    exit2(tag);\n    write2`-->`;\n    if (commentBinding) {\n      markNode(tag, commentBinding);\n    }\n    tag.remove();\n  },\n  parseOptions: {\n    text: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an html comment that is not stripped from the output.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#html-comment\"\n    }\n  ]\n};\n\n// src/translator/core/html-script.ts\nvar import_compiler34 = require(\"@marko/compiler\");\nvar import_babel_utils24 = require(\"@marko/compiler/babel-utils\");\nvar kGetterId3 = Symbol(\"node getter id\");\nvar html_script_default = {\n  analyze(tag) {\n    (0, import_babel_utils24.assertNoArgs)(tag);\n    (0, import_babel_utils24.assertNoParams)(tag);\n    const { node } = tag;\n    if (node.var && !import_compiler34.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\n        \"Tag variables on native elements cannot be destructured.\"\n      );\n    }\n    const section = getOrCreateSection(tag);\n    let hasEventHandlers = false;\n    let hasDynamicAttributes = false;\n    const seen = {};\n    const { attributes } = tag.node;\n    let spreadReferenceNodes;\n    for (let i = attributes.length; i--; ) {\n      const attr2 = attributes[i];\n      if (import_compiler34.types.isMarkoAttribute(attr2)) {\n        if (seen[attr2.name]) {\n          dropReferences(attr2.value);\n          continue;\n        }\n        seen[attr2.name] = attr2;\n        if (isEventHandler(attr2.name)) {\n          (attr2.value.extra ??= {}).isEffect = true;\n          hasEventHandlers = true;\n        } else if (!evaluate(attr2.value).confident) {\n          hasDynamicAttributes = true;\n        }\n      } else if (import_compiler34.types.isMarkoSpreadAttribute(attr2)) {\n        hasEventHandlers = true;\n        hasDynamicAttributes = true;\n        (attr2.value.extra ??= {}).isEffect = true;\n      }\n      if (spreadReferenceNodes) {\n        spreadReferenceNodes.push(attr2.value);\n      } else if (import_compiler34.types.isMarkoSpreadAttribute(attr2)) {\n        spreadReferenceNodes = [attr2.value];\n      }\n    }\n    if (spreadReferenceNodes) {\n      mergeReferences(section, tag.node, spreadReferenceNodes);\n    }\n    const bodyPlaceholderNodes = [];\n    let hasBodyPlaceholders = false;\n    for (const child of tag.node.body.body) {\n      if (import_compiler34.types.isMarkoPlaceholder(child)) {\n        bodyPlaceholderNodes.push(child.value);\n        hasBodyPlaceholders = true;\n      } else if (!import_compiler34.types.isMarkoText(child)) {\n        throw tag.hub.buildError(\n          child,\n          \"Invalid child. Only text is allowed inside an html-script.\"\n        );\n      }\n    }\n    if (bodyPlaceholderNodes.length > 1) {\n      mergeReferences(\n        section,\n        bodyPlaceholderNodes[0],\n        bodyPlaceholderNodes.slice(1)\n      );\n    }\n    if (node.var || hasEventHandlers || hasDynamicAttributes || hasBodyPlaceholders) {\n      currentProgramPath.node.extra.isInteractive ||= hasEventHandlers;\n      const tagExtra = node.extra ??= {};\n      const bindingName = \"#script\";\n      tagExtra[kSerializeMarker] = hasEventHandlers || !!node.var;\n      tagExtra[kNativeTagBinding] = createBinding(\n        bindingName,\n        0 /* dom */,\n        section\n      );\n      if (node.var) {\n        for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n          if (!ref.parentPath?.isCallExpression()) {\n            tagExtra[kGetterId3] = getRegisterUID(section, bindingName);\n            break;\n          }\n        }\n      }\n    }\n  },\n  translate(tag) {\n    const tagExtra = tag.node.extra;\n    const nodeRef2 = tagExtra[kNativeTagBinding];\n    const isHTML = isOutputHTML();\n    const write2 = writeTo(tag);\n    const section = getSection(tag);\n    const hasVar = !!tag.node.var;\n    if (hasVar) {\n      const getterId = tagExtra[kGetterId3];\n      if (isHTML) {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        for (const reference of references) {\n          let currentSection = getSection(reference);\n          while (currentSection !== section && currentSection.parent) {\n            getSerializedScopeProperties(currentSection).set(\n              import_compiler34.types.stringLiteral(\"_\"),\n              callRuntime(\n                \"ensureScopeWithId\",\n                getScopeIdIdentifier(currentSection = currentSection.parent)\n              )\n            );\n          }\n        }\n        translateVar(\n          tag,\n          callRuntime(\n            \"nodeRef\",\n            getterId && getScopeIdIdentifier(section),\n            getterId && import_compiler34.types.stringLiteral(getterId)\n          )\n        );\n      } else {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        let getterFnIdentifier;\n        if (getterId) {\n          getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n            `get_${varName}`\n          );\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler34.types.variableDeclaration(\"const\", [\n              import_compiler34.types.variableDeclarator(\n                getterFnIdentifier,\n                callRuntime(\n                  \"nodeRef\",\n                  import_compiler34.types.stringLiteral(getterId),\n                  getScopeAccessorLiteral(nodeRef2)\n                )\n              )\n            ])\n          );\n        }\n        for (const reference of references) {\n          const referenceSection = getSection(reference);\n          if (reference.parentPath?.isCallExpression()) {\n            reference.parentPath.replaceWith(\n              import_compiler34.types.expressionStatement(\n                createScopeReadExpression(referenceSection, nodeRef2)\n              )\n            );\n          } else if (getterFnIdentifier) {\n            reference.replaceWith(\n              import_compiler34.types.callExpression(getterFnIdentifier, [\n                getScopeExpression(referenceSection, getSection(tag))\n              ])\n            );\n          }\n        }\n      }\n    }\n    let visitAccessor;\n    if (nodeRef2) {\n      visitAccessor = getScopeAccessorLiteral(nodeRef2);\n      visit(tag, 32 /* Get */);\n    }\n    write2`<script`;\n    const usedAttrs = getUsedAttrs2(tag.node);\n    const { staticAttrs, skipExpression, spreadExpression } = usedAttrs;\n    for (const attr2 of staticAttrs) {\n      const { name: name2, value } = attr2;\n      const { confident, computed } = value.extra || {};\n      const valueReferences = value.extra?.referencedBindings;\n      switch (name2) {\n        case \"class\":\n        case \"style\": {\n          const helper = `${name2}Attr`;\n          if (confident) {\n            write2`${getHTMLRuntime()[helper](computed)}`;\n          } else if (isHTML) {\n            write2`${callRuntime(helper, value)}`;\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              valueReferences,\n              import_compiler34.types.expressionStatement(\n                callRuntime(\n                  helper,\n                  import_compiler34.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  value\n                )\n              )\n            );\n          }\n          break;\n        }\n        default:\n          if (confident) {\n            write2`${getHTMLRuntime().attr(name2, computed)}`;\n          } else if (isHTML) {\n            if (isEventHandler(name2)) {\n              addHTMLEffectCall(section, valueReferences);\n            } else {\n              write2`${callRuntime(\"attr\", import_compiler34.types.stringLiteral(name2), value)}`;\n            }\n          } else if (isEventHandler(name2)) {\n            addStatement(\n              \"effect\",\n              section,\n              valueReferences,\n              import_compiler34.types.expressionStatement(\n                callRuntime(\n                  \"on\",\n                  import_compiler34.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  import_compiler34.types.stringLiteral(getEventHandlerName(name2)),\n                  value\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              valueReferences,\n              import_compiler34.types.expressionStatement(\n                callRuntime(\n                  \"attr\",\n                  import_compiler34.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  import_compiler34.types.stringLiteral(name2),\n                  value\n                )\n              )\n            );\n          }\n          break;\n      }\n    }\n    if (spreadExpression) {\n      if (isHTML) {\n        addHTMLEffectCall(section, tagExtra.referencedBindings);\n        if (skipExpression) {\n          write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler34.types.stringLiteral(\"script\"))}`;\n        } else {\n          write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler34.types.stringLiteral(\"script\"))}`;\n        }\n      } else {\n        if (skipExpression) {\n          addStatement(\n            \"render\",\n            section,\n            tagExtra.referencedBindings,\n            import_compiler34.types.expressionStatement(\n              callRuntime(\n                \"partialAttrs\",\n                scopeIdentifier,\n                visitAccessor,\n                spreadExpression,\n                skipExpression\n              )\n            )\n          );\n        } else {\n          addStatement(\n            \"render\",\n            section,\n            tagExtra.referencedBindings,\n            import_compiler34.types.expressionStatement(\n              callRuntime(\n                \"attrs\",\n                scopeIdentifier,\n                visitAccessor,\n                spreadExpression\n              )\n            )\n          );\n        }\n        addStatement(\n          \"effect\",\n          section,\n          tagExtra.referencedBindings,\n          import_compiler34.types.expressionStatement(\n            callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n          ),\n          false\n        );\n      }\n    }\n    write2`>`;\n    enter2(tag);\n    if (isOutputHTML()) {\n      for (const child of tag.node.body.body) {\n        if (import_compiler34.types.isMarkoText(child)) {\n          write2`${child.value}`;\n        } else if (import_compiler34.types.isMarkoPlaceholder(child)) {\n          write2`${callRuntime(\"escapeScript\", child.value)}`;\n        }\n      }\n    } else {\n      const templateQuasis = [];\n      const templateExpressions = [];\n      let currentQuasi = \"\";\n      let referencePlaceholder;\n      for (const child of tag.node.body.body) {\n        if (import_compiler34.types.isMarkoText(child)) {\n          currentQuasi += child.value;\n        } else if (import_compiler34.types.isMarkoPlaceholder(child)) {\n          referencePlaceholder ||= child;\n          templateQuasis.push(import_compiler34.types.templateElement({ raw: currentQuasi }));\n          templateExpressions.push(child.value);\n          currentQuasi = \"\";\n        }\n      }\n      if (!referencePlaceholder) {\n        write2`${currentQuasi}`;\n      } else {\n        templateQuasis.push(import_compiler34.types.templateElement({ raw: currentQuasi }));\n        addStatement(\n          \"render\",\n          getSection(tag),\n          referencePlaceholder.value.extra?.referencedBindings,\n          import_compiler34.types.expressionStatement(\n            callRuntime(\n              \"textContent\",\n              import_compiler34.types.memberExpression(scopeIdentifier, visitAccessor, true),\n              import_compiler34.types.templateLiteral(templateQuasis, templateExpressions)\n            )\n          )\n        );\n      }\n    }\n    write2`</script>`;\n    if (nodeRef2) {\n      markNode(tag, nodeRef2);\n    }\n    exit2(tag);\n    tag.remove();\n  },\n  \"@async\": \"#html-async\",\n  \"@crossorigin\": \"#html-crossorigin\",\n  \"@defer\": \"#html-defer\",\n  \"@integrity\": \"#html-integrity\",\n  \"@nomodule\": \"#html-nomodule\",\n  \"@nonce\": \"#html-nonce\",\n  \"@referrerpolicy\": \"#html-referrerpolicy\",\n  \"@src\": \"#html-src\",\n  \"@type\": \"#html-type\",\n  \"attribute-groups\": [\"html-attributes\"],\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  }\n};\nfunction getUsedAttrs2(tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler34.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n      }\n      spreadProps.push(import_compiler34.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler34.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler34.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    spreadExpression,\n    skipExpression\n  };\n}\n\n// src/translator/core/html-style.ts\nvar import_compiler35 = require(\"@marko/compiler\");\nvar import_babel_utils25 = require(\"@marko/compiler/babel-utils\");\nvar kGetterId4 = Symbol(\"node getter id\");\nvar html_style_default = {\n  analyze(tag) {\n    (0, import_babel_utils25.assertNoArgs)(tag);\n    (0, import_babel_utils25.assertNoParams)(tag);\n    const { node } = tag;\n    if (node.var && !import_compiler35.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\n        \"Tag variables on native elements cannot be destructured.\"\n      );\n    }\n    const section = getOrCreateSection(tag);\n    let hasEventHandlers = false;\n    let hasDynamicAttributes = false;\n    const seen = {};\n    const { attributes } = tag.node;\n    let spreadReferenceNodes;\n    for (let i = attributes.length; i--; ) {\n      const attr2 = attributes[i];\n      if (import_compiler35.types.isMarkoAttribute(attr2)) {\n        if (seen[attr2.name]) {\n          dropReferences(attr2.value);\n          continue;\n        }\n        seen[attr2.name] = attr2;\n        if (isEventHandler(attr2.name)) {\n          (attr2.value.extra ??= {}).isEffect = true;\n          hasEventHandlers = true;\n        } else if (!evaluate(attr2.value).confident) {\n          hasDynamicAttributes = true;\n        }\n      } else if (import_compiler35.types.isMarkoSpreadAttribute(attr2)) {\n        hasEventHandlers = true;\n        hasDynamicAttributes = true;\n        (attr2.value.extra ??= {}).isEffect = true;\n      }\n      if (spreadReferenceNodes) {\n        spreadReferenceNodes.push(attr2.value);\n      } else if (import_compiler35.types.isMarkoSpreadAttribute(attr2)) {\n        spreadReferenceNodes = [attr2.value];\n      }\n    }\n    if (spreadReferenceNodes) {\n      mergeReferences(section, tag.node, spreadReferenceNodes);\n    }\n    const bodyPlaceholderNodes = [];\n    let hasBodyPlaceholders = false;\n    for (const child of tag.node.body.body) {\n      if (import_compiler35.types.isMarkoPlaceholder(child)) {\n        bodyPlaceholderNodes.push(child.value);\n        hasBodyPlaceholders = true;\n      } else if (!import_compiler35.types.isMarkoText(child)) {\n        throw tag.hub.buildError(\n          child,\n          \"Invalid child. Only text is allowed inside an html-style.\"\n        );\n      }\n    }\n    if (bodyPlaceholderNodes.length > 1) {\n      mergeReferences(\n        section,\n        bodyPlaceholderNodes[0],\n        bodyPlaceholderNodes.slice(1)\n      );\n    }\n    if (node.var || hasEventHandlers || hasDynamicAttributes || hasBodyPlaceholders) {\n      currentProgramPath.node.extra.isInteractive ||= hasEventHandlers;\n      const tagExtra = node.extra ??= {};\n      const bindingName = \"#style\";\n      tagExtra[kSerializeMarker] = hasEventHandlers || !!node.var;\n      tagExtra[kNativeTagBinding] = createBinding(\n        bindingName,\n        0 /* dom */,\n        section\n      );\n      if (node.var) {\n        for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n          if (!ref.parentPath?.isCallExpression()) {\n            tagExtra[kGetterId4] = getRegisterUID(section, bindingName);\n            break;\n          }\n        }\n      }\n    }\n  },\n  translate(tag) {\n    const tagExtra = tag.node.extra;\n    const nodeRef2 = tagExtra[kNativeTagBinding];\n    const isHTML = isOutputHTML();\n    const write2 = writeTo(tag);\n    const section = getSection(tag);\n    const hasVar = !!tag.node.var;\n    if (hasVar) {\n      const getterId = tagExtra[kGetterId4];\n      if (isHTML) {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        for (const reference of references) {\n          let currentSection = getSection(reference);\n          while (currentSection !== section && currentSection.parent) {\n            getSerializedScopeProperties(currentSection).set(\n              import_compiler35.types.stringLiteral(\"_\"),\n              callRuntime(\n                \"ensureScopeWithId\",\n                getScopeIdIdentifier(currentSection = currentSection.parent)\n              )\n            );\n          }\n        }\n        translateVar(\n          tag,\n          callRuntime(\n            \"nodeRef\",\n            getterId && getScopeIdIdentifier(section),\n            getterId && import_compiler35.types.stringLiteral(getterId)\n          )\n        );\n      } else {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        let getterFnIdentifier;\n        if (getterId) {\n          getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n            `get_${varName}`\n          );\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler35.types.variableDeclaration(\"const\", [\n              import_compiler35.types.variableDeclarator(\n                getterFnIdentifier,\n                callRuntime(\n                  \"nodeRef\",\n                  import_compiler35.types.stringLiteral(getterId),\n                  getScopeAccessorLiteral(nodeRef2)\n                )\n              )\n            ])\n          );\n        }\n        for (const reference of references) {\n          const referenceSection = getSection(reference);\n          if (reference.parentPath?.isCallExpression()) {\n            reference.parentPath.replaceWith(\n              import_compiler35.types.expressionStatement(\n                createScopeReadExpression(referenceSection, nodeRef2)\n              )\n            );\n          } else if (getterFnIdentifier) {\n            reference.replaceWith(\n              import_compiler35.types.callExpression(getterFnIdentifier, [\n                getScopeExpression(referenceSection, getSection(tag))\n              ])\n            );\n          }\n        }\n      }\n    }\n    let visitAccessor;\n    if (nodeRef2) {\n      visitAccessor = getScopeAccessorLiteral(nodeRef2);\n      visit(tag, 32 /* Get */);\n    }\n    write2`<style`;\n    const usedAttrs = getUsedAttrs3(tag.node);\n    const { staticAttrs, skipExpression, spreadExpression } = usedAttrs;\n    for (const attr2 of staticAttrs) {\n      const { name: name2, value } = attr2;\n      const { confident, computed } = value.extra || {};\n      const valueReferences = value.extra?.referencedBindings;\n      switch (name2) {\n        case \"class\":\n        case \"style\": {\n          const helper = `${name2}Attr`;\n          if (confident) {\n            write2`${getHTMLRuntime()[helper](computed)}`;\n          } else if (isHTML) {\n            write2`${callRuntime(helper, value)}`;\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              valueReferences,\n              import_compiler35.types.expressionStatement(\n                callRuntime(\n                  helper,\n                  import_compiler35.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  value\n                )\n              )\n            );\n          }\n          break;\n        }\n        default:\n          if (confident) {\n            write2`${getHTMLRuntime().attr(name2, computed)}`;\n          } else if (isHTML) {\n            if (isEventHandler(name2)) {\n              addHTMLEffectCall(section, valueReferences);\n            } else {\n              write2`${callRuntime(\"attr\", import_compiler35.types.stringLiteral(name2), value)}`;\n            }\n          } else if (isEventHandler(name2)) {\n            addStatement(\n              \"effect\",\n              section,\n              valueReferences,\n              import_compiler35.types.expressionStatement(\n                callRuntime(\n                  \"on\",\n                  import_compiler35.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  import_compiler35.types.stringLiteral(getEventHandlerName(name2)),\n                  value\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              valueReferences,\n              import_compiler35.types.expressionStatement(\n                callRuntime(\n                  \"attr\",\n                  import_compiler35.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  import_compiler35.types.stringLiteral(name2),\n                  value\n                )\n              )\n            );\n          }\n          break;\n      }\n    }\n    if (spreadExpression) {\n      if (isHTML) {\n        addHTMLEffectCall(section, tagExtra.referencedBindings);\n        if (skipExpression) {\n          write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler35.types.stringLiteral(\"style\"))}`;\n        } else {\n          write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler35.types.stringLiteral(\"style\"))}`;\n        }\n      } else {\n        if (skipExpression) {\n          addStatement(\n            \"render\",\n            section,\n            tagExtra.referencedBindings,\n            import_compiler35.types.expressionStatement(\n              callRuntime(\n                \"partialAttrs\",\n                scopeIdentifier,\n                visitAccessor,\n                spreadExpression,\n                skipExpression\n              )\n            )\n          );\n        } else {\n          addStatement(\n            \"render\",\n            section,\n            tagExtra.referencedBindings,\n            import_compiler35.types.expressionStatement(\n              callRuntime(\n                \"attrs\",\n                scopeIdentifier,\n                visitAccessor,\n                spreadExpression\n              )\n            )\n          );\n        }\n        addStatement(\n          \"effect\",\n          section,\n          tagExtra.referencedBindings,\n          import_compiler35.types.expressionStatement(\n            callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n          ),\n          false\n        );\n      }\n    }\n    write2`>`;\n    enter2(tag);\n    if (isOutputHTML()) {\n      for (const child of tag.node.body.body) {\n        if (import_compiler35.types.isMarkoText(child)) {\n          write2`${child.value}`;\n        } else if (import_compiler35.types.isMarkoPlaceholder(child)) {\n          write2`${callRuntime(\"escapeStyle\", child.value)}`;\n        }\n      }\n    } else {\n      const templateQuasis = [];\n      const templateExpressions = [];\n      let currentQuasi = \"\";\n      let referencePlaceholder;\n      for (const child of tag.node.body.body) {\n        if (import_compiler35.types.isMarkoText(child)) {\n          currentQuasi += child.value;\n        } else if (import_compiler35.types.isMarkoPlaceholder(child)) {\n          referencePlaceholder ||= child;\n          templateQuasis.push(import_compiler35.types.templateElement({ raw: currentQuasi }));\n          templateExpressions.push(child.value);\n          currentQuasi = \"\";\n        }\n      }\n      if (!referencePlaceholder) {\n        write2`${currentQuasi}`;\n      } else {\n        templateQuasis.push(import_compiler35.types.templateElement({ raw: currentQuasi }));\n        addStatement(\n          \"render\",\n          getSection(tag),\n          referencePlaceholder.value.extra?.referencedBindings,\n          import_compiler35.types.expressionStatement(\n            callRuntime(\n              \"textContent\",\n              import_compiler35.types.memberExpression(scopeIdentifier, visitAccessor, true),\n              import_compiler35.types.templateLiteral(templateQuasis, templateExpressions)\n            )\n          )\n        );\n      }\n    }\n    write2`</style>`;\n    if (nodeRef2) {\n      markNode(tag, nodeRef2);\n    }\n    exit2(tag);\n    tag.remove();\n  },\n  \"@disabled\": \"#html-disabled\",\n  \"@media\": \"#html-media\",\n  \"@nonce\": \"#html-nonce\",\n  \"@type\": \"#html-type\",\n  \"attribute-groups\": [\"html-attributes\"],\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  }\n};\nfunction getUsedAttrs3(tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler35.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n      }\n      spreadProps.push(import_compiler35.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler35.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler35.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    spreadExpression,\n    skipExpression\n  };\n}\n\n// src/translator/core/id.ts\nvar import_compiler36 = require(\"@marko/compiler\");\nvar import_babel_utils26 = require(\"@marko/compiler/babel-utils\");\nvar id_default = {\n  analyze(tag) {\n    (0, import_babel_utils26.assertNoArgs)(tag);\n    (0, import_babel_utils26.assertNoParams)(tag);\n    (0, import_babel_utils26.assertNoAttributes)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils26.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `id` tag requires a tag variable.\");\n    }\n    if (!import_compiler36.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `id` tag cannot be destructured\");\n    }\n    trackVarReferences(tag, 4 /* derived */);\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const id = isOutputHTML() ? callRuntime(\"nextTagId\") : callRuntime(\"nextTagId\", scopeIdentifier);\n      if (isOutputHTML()) {\n        tag.replaceWith(\n          import_compiler36.types.variableDeclaration(\"const\", [import_compiler36.types.variableDeclarator(node.var, id)])\n        );\n      } else {\n        const source = initValue(node.var.extra.binding);\n        addValue(getSection(tag), void 0, source, id);\n        tag.remove();\n      }\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"id/<name>\",\n      description: \"Use to create a unique identifier.\",\n      snippet: \"id/${1:name}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#id\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/id.d.marko\"\n};\n\n// src/translator/core/if.ts\nvar import_compiler38 = require(\"@marko/compiler\");\nvar import_babel_utils27 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/to-first-statement-or-block.ts\nvar import_compiler37 = require(\"@marko/compiler\");\nfunction toFirstStatementOrBlock(body) {\n  if (Array.isArray(body)) {\n    if (body.length === 1) {\n      return body[0];\n    }\n    return import_compiler37.types.blockStatement(body);\n  }\n  return body;\n}\n\n// src/translator/core/if.ts\nvar kBinding = Symbol(\"if node binding\");\nvar BRANCHES_LOOKUP = /* @__PURE__ */ new WeakMap();\nvar IfTag = {\n  analyze(tag) {\n    assertValidCondition(tag);\n    if (tag.node.body.attributeTags) return;\n    const [isLast, branches] = getBranches(tag, startSection(tag.get(\"body\")));\n    if (isLast) {\n      const [rootTag] = branches[0];\n      const rootExtra = rootTag.node.extra ??= {};\n      const mergeReferenceNodes = [];\n      let singleNodeOptimization = true;\n      for (const [branchTag, branchBodySection] of branches) {\n        if (branchBodySection) {\n          branchBodySection.isBranch = true;\n          branchBodySection.upstreamExpression = rootExtra;\n          if (!(branchBodySection.content === null || branchBodySection.content?.singleChild)) {\n            singleNodeOptimization = false;\n          }\n        }\n        if (branchTag.node.attributes.length) {\n          mergeReferenceNodes.push(branchTag.node.attributes[0].value);\n        }\n      }\n      const section = getOrCreateSection(tag);\n      rootExtra[kBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section,\n        void 0,\n        rootExtra\n      );\n      rootExtra.singleNodeOptimization = singleNodeOptimization;\n      mergeReferences(section, rootTag.node, mergeReferenceNodes);\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (isRoot(tag)) {\n          visit(tag, 37 /* Replace */);\n        }\n        enterShallow(tag);\n        flushBefore(tag);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const [isLast, branches] = getBranches(tag, bodySection);\n        const rootExtra = branches[0][0].node.extra;\n        const nodeRef2 = rootExtra[kBinding];\n        const isStateful = isStatefulReferences(rootExtra.referencedBindings);\n        const singleNodeOptimization = rootExtra.singleNodeOptimization;\n        const hasStatefulClosures = bodySection && checkStatefulClosures(bodySection, true);\n        if (bodySection) {\n          if (isStateful || hasStatefulClosures) {\n            setForceResumeScope(bodySection);\n          }\n          flushInto(tag);\n          setClosureSignalBuilder(tag, () => {\n          });\n          writeHTMLResumeStatements(tagBody);\n        }\n        if (isLast) {\n          const nextTag = tag.getNextSibling();\n          const ifScopeIdIdentifier = tag.scope.generateUidIdentifier(\"ifScopeId\");\n          const ifRendererIdentifier = tag.scope.generateUidIdentifier(\"ifRenderer\");\n          let statement;\n          for (let i = branches.length; i--; ) {\n            const [branchTag, branchBodySection] = branches[i];\n            const bodyStatements = branchTag.node.body.body;\n            if (branchBodySection) {\n              const branchHasStatefulClosures = checkStatefulClosures(\n                branchBodySection,\n                true\n              );\n              if (isStateful) {\n                bodyStatements.push(\n                  import_compiler38.types.expressionStatement(\n                    callRuntime(\n                      \"register\",\n                      import_compiler38.types.assignmentExpression(\n                        \"=\",\n                        ifRendererIdentifier,\n                        callRuntime(\n                          \"createRenderer\",\n                          import_compiler38.types.arrowFunctionExpression([], import_compiler38.types.blockStatement([]))\n                        )\n                      ),\n                      import_compiler38.types.stringLiteral(\n                        getResumeRegisterId(branchBodySection, \"renderer\")\n                      )\n                    )\n                  )\n                );\n              }\n              if (isStateful || branchHasStatefulClosures) {\n                bodyStatements.push(\n                  import_compiler38.types.expressionStatement(\n                    import_compiler38.types.assignmentExpression(\n                      \"=\",\n                      ifScopeIdIdentifier,\n                      getScopeIdIdentifier(branchBodySection)\n                    )\n                  )\n                );\n              }\n            }\n            const [testAttr] = branchTag.node.attributes;\n            const curStatement = toFirstStatementOrBlock(bodyStatements);\n            if (testAttr) {\n              statement = import_compiler38.types.ifStatement(\n                testAttr.value,\n                curStatement,\n                statement\n              );\n            } else {\n              statement = curStatement;\n            }\n            branchTag.remove();\n          }\n          if (!(isStateful || hasStatefulClosures)) {\n            nextTag.insertBefore(statement);\n          } else {\n            if (isStateful) {\n              getSerializedScopeProperties(section).set(\n                import_compiler38.types.stringLiteral(\n                  getScopeAccessorLiteral(nodeRef2).value + \"(\" /* ConditionalRenderer */\n                ),\n                ifRendererIdentifier\n              );\n              const cbNode = import_compiler38.types.arrowFunctionExpression(\n                [],\n                import_compiler38.types.blockStatement([statement])\n              );\n              statement = import_compiler38.types.expressionStatement(\n                singleNodeOptimization ? callRuntime(\n                  \"resumeSingleNodeConditional\",\n                  cbNode,\n                  getScopeIdIdentifier(section),\n                  getScopeAccessorLiteral(nodeRef2)\n                ) : callRuntime(\n                  \"resumeConditional\",\n                  cbNode,\n                  getScopeIdIdentifier(section),\n                  getScopeAccessorLiteral(nodeRef2)\n                )\n              );\n            }\n            nextTag.insertBefore([\n              import_compiler38.types.variableDeclaration(\n                \"let\",\n                [\n                  import_compiler38.types.variableDeclarator(ifScopeIdIdentifier),\n                  isStateful && import_compiler38.types.variableDeclarator(ifRendererIdentifier)\n                ].filter(Boolean)\n              ),\n              statement\n            ]);\n            getSerializedScopeProperties(section).set(\n              import_compiler38.types.stringLiteral(\n                getScopeAccessorLiteral(nodeRef2).value + \"!\" /* ConditionalScope */\n              ),\n              callRuntime(\"getScopeById\", ifScopeIdIdentifier)\n            );\n          }\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n        }\n        if (isRoot(tag)) {\n          visit(tag, 37 /* Replace */);\n        }\n        enterShallow(tag);\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const [isLast, branches] = getBranches(\n          tag,\n          getSectionForBody(tag.get(\"body\"))\n        );\n        if (isLast) {\n          const section = getSection(tag);\n          const rootExtra = branches[0][0].node.extra;\n          const nodeRef2 = rootExtra[kBinding];\n          let expr = import_compiler38.types.nullLiteral();\n          for (let i = branches.length; i--; ) {\n            const [branchTag, branchBodySection] = branches[i];\n            const [testAttr] = branchTag.node.attributes;\n            const consequent = branchBodySection ? import_compiler38.types.identifier(branchBodySection.name) : import_compiler38.types.numericLiteral(0);\n            setClosureSignalBuilder(\n              branchTag,\n              (_closureSignal, render, intersection) => {\n                return callRuntime(\n                  \"conditionalClosure\",\n                  getScopeAccessorLiteral(nodeRef2),\n                  import_compiler38.types.arrowFunctionExpression(\n                    [],\n                    import_compiler38.types.identifier(branchBodySection.name)\n                  ),\n                  render,\n                  intersection\n                );\n              }\n            );\n            branchTag.remove();\n            expr = testAttr ? import_compiler38.types.conditionalExpression(testAttr.value, consequent, expr) : consequent;\n          }\n          const signal = getSignal(section, nodeRef2, \"if\");\n          signal.build = () => {\n            return callRuntime(\n              \"conditional\",\n              getScopeAccessorLiteral(nodeRef2),\n              getSignalFn(signal, [scopeIdentifier])\n            );\n          };\n          signal.hasDownstreamIntersections = () => branches.some(([, bodySection]) => bodySection?.closures);\n          addValue(section, rootExtra.referencedBindings, signal, expr);\n        }\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  autocomplete: [\n    {\n      snippet: \"if=${1:condition}\",\n      description: \"Use to display content only if the condition is met.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseIfTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      snippet: \"else-if=${1:condition}\",\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nfunction assertValidCondition(tag) {\n  (0, import_babel_utils27.assertNoVar)(tag);\n  (0, import_babel_utils27.assertNoArgs)(tag);\n  (0, import_babel_utils27.assertNoParams)(tag);\n  assertHasBody(tag);\n  assertNoSpreadAttrs(tag);\n  switch (getTagName(tag)) {\n    case \"if\":\n      assertHasValueAttribute(tag);\n      break;\n    case \"else-if\":\n      assertHasValueAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n    case \"else\":\n      assertOptionalIfAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n  }\n}\nfunction assertHasPrecedingCondition(tag) {\n  let prev = tag.getPrevSibling();\n  while (prev.node && prev.isMarkoComment()) prev = prev.getPrevSibling();\n  if (!isConditionTag(prev) || getTagName(prev) !== \"else\" && !prev.node.attributes.length) {\n    throw tag.buildCodeFrameError(\n      `The \\`<${getTagName(tag)}>\\` must have a preceding \\`<if=cond>\\`, \\`<else-if=cond>\\`, or \\`<else if=cond>\\`.`\n    );\n  }\n}\nfunction assertHasBody(tag) {\n  if (!(tag.node.body.body.length || tag.node.attributeTags.length)) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${getTagName(tag)}\\` tag requires body content.`\n    );\n  }\n}\nfunction assertHasValueAttribute(tag) {\n  const { node } = tag;\n  const [valueAttr] = node.attributes;\n  if (!import_compiler38.types.isMarkoAttribute(valueAttr) || !valueAttr.default) {\n    throw tag.get(\"name\").buildCodeFrameError(`The \\`${getTagName(tag)}\\` tag requires a value.`);\n  }\n  if (node.attributes.length > 1) {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports the \\`value\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction assertOptionalIfAttribute(tag) {\n  const { node } = tag;\n  const [ifAttr] = node.attributes;\n  if (node.attributes.length > 1 || ifAttr && ifAttr.name !== \"if\") {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports an \\`if=\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction getBranches(tag, bodySection) {\n  const branches = BRANCHES_LOOKUP.get(tag) ?? [];\n  let nextTag = tag.getNextSibling();\n  while (nextTag.isMarkoComment()) nextTag = nextTag.getNextSibling();\n  const isLast = !(isCoreTagName(nextTag, \"else\") || isCoreTagName(nextTag, \"else-if\"));\n  branches.push([tag, bodySection]);\n  if (!isLast) {\n    BRANCHES_LOOKUP.set(nextTag, branches);\n  }\n  return [isLast, branches];\n}\nfunction isRoot(tag) {\n  return isCoreTagName(tag, \"if\");\n}\n\n// src/translator/core/import.ts\nvar import_babel_utils28 = require(\"@marko/compiler/babel-utils\");\nvar import_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils28.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: 'import <scope> from \"<path>\"',\n      description: \"Use to import external modules, follows the same syntax as JavaScript imports.\",\n      snippet: 'import ${2} from \"${1:path}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#importing-external-files\"\n    }\n  ]\n};\n\n// src/translator/core/let.ts\nvar import_compiler39 = require(\"@marko/compiler\");\nvar import_babel_utils29 = require(\"@marko/compiler/babel-utils\");\nvar let_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    let valueAttr;\n    let valueChangeAttr;\n    for (const attr2 of node.attributes) {\n      if (import_compiler39.types.isMarkoAttribute(attr2)) {\n        if (attr2.name === \"value\") {\n          valueAttr = attr2;\n        } else if (attr2.name === \"valueChange\") {\n          valueChangeAttr = attr2;\n        } else {\n          const start = attr2.loc?.start;\n          const end = attr2.loc?.end;\n          const msg = \"The `let` tag only supports the `value` attribute and its change handler.\";\n          if (start == null || end == null) {\n            throw tag.get(\"name\").buildCodeFrameError(msg);\n          } else {\n            throw tag.hub.buildError(\n              { loc: { start, end } },\n              msg,\n              Error\n            );\n          }\n        }\n      }\n    }\n    (0, import_babel_utils29.assertNoArgs)(tag);\n    (0, import_babel_utils29.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    if (!tagVar) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `let` tag requires a tag variable.\");\n    }\n    if (!import_compiler39.types.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `let` tag variable cannot be destructured.\");\n    }\n    if (valueChangeAttr && (0, import_babel_utils29.computeNode)(valueChangeAttr.value)) {\n      throw tag.get(\"attributes\").find((attr2) => attr2.node === valueChangeAttr).get(\"value\").buildCodeFrameError(\n        \"The `let` tag `valueChange` attribute must be a function.\"\n      );\n    }\n    mergeReferences(getOrCreateSection(tag), tag.node, [\n      valueAttr?.value,\n      valueChangeAttr?.value\n    ]);\n    trackVarReferences(tag, 1 /* let */, void 0, tag.node.extra);\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const tagVar = node.var;\n      const valueAttr = node.attributes.find(\n        (attr2) => import_compiler39.types.isMarkoAttribute(attr2) && (attr2.default || attr2.name === \"value\")\n      ) ?? import_compiler39.types.markoAttribute(\"value\", import_compiler39.types.identifier(\"undefined\"));\n      const valueChangeAttr = node.attributes.find(\n        (attr2) => import_compiler39.types.isMarkoAttribute(attr2) && attr2.name === \"valueChange\"\n      );\n      const section = getSection(tag);\n      const binding = tagVar.extra.binding;\n      if (isOutputDOM()) {\n        const signal = initValue(binding, \"state\");\n        const referencedBindings = tag.node.extra.referencedBindings;\n        addValue(section, referencedBindings, signal, valueAttr.value);\n        if (valueChangeAttr) {\n          signal.extraArgs = [valueChangeAttr.value];\n        }\n        signal.buildAssignment = (valueSection, value) => {\n          const scope = getScopeExpression(valueSection, signal.section);\n          return import_compiler39.types.callExpression(signal.identifier, [scope, value]);\n        };\n      } else {\n        translateVar(tag, valueAttr.value);\n        if (valueChangeAttr) {\n          getSerializedScopeProperties(section).set(\n            import_compiler39.types.stringLiteral(\n              getScopeAccessorLiteral(binding).value + \"@\" /* TagVariableChange */\n            ),\n            valueChangeAttr.value\n          );\n        }\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a mutable binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#let\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/let.d.marko\"\n};\n\n// src/translator/core/lifecycle.ts\nvar import_compiler40 = require(\"@marko/compiler\");\nvar import_babel_utils30 = require(\"@marko/compiler/babel-utils\");\nvar kRef = Symbol(\"lifecycle attrs reference\");\nvar lifecycle_default = {\n  analyze(tag) {\n    (0, import_babel_utils30.assertNoArgs)(tag);\n    (0, import_babel_utils30.assertNoVar)(tag);\n    (0, import_babel_utils30.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const tagExtra = node.extra ??= {};\n    const section = getOrCreateSection(tag);\n    tagExtra[kRef] = createBinding(\n      currentProgramPath.scope.generateUid(\"lifecycle\"),\n      4 /* derived */,\n      section,\n      void 0,\n      tagExtra\n    );\n    if (node.attributes.length === 0) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `lifecycle` tag requires at least one attribute.\"\n      );\n    }\n    for (const attr2 of node.attributes) {\n      if (import_compiler40.types.isMarkoSpreadAttribute(attr2)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The `lifecycle` tag does not support `...spread` attributes.\"\n        );\n      }\n      (attr2.value.extra ??= {}).isEffect = true;\n    }\n    (currentProgramPath.node.extra ??= {}).isInteractive = true;\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const section = getSection(tag);\n      const tagExtra = node.extra;\n      const { referencedBindings } = tagExtra;\n      const lifecycleAttrsRef = tagExtra[kRef];\n      if (isOutputDOM()) {\n        const translatedAttrs = translateAttrs(tag);\n        translatedAttrs.statements.push(\n          import_compiler40.types.expressionStatement(\n            callRuntime(\n              \"lifecycle\",\n              scopeIdentifier,\n              getScopeAccessorLiteral(lifecycleAttrsRef),\n              propsToExpression(translatedAttrs.properties)\n            )\n          )\n        );\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          translatedAttrs.statements\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/lifecycle.d.marko\"\n};\n\n// src/translator/core/log.ts\nvar import_compiler41 = require(\"@marko/compiler\");\nvar import_babel_utils31 = require(\"@marko/compiler/babel-utils\");\nvar log_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils31.assertNoArgs)(tag);\n    (0, import_babel_utils31.assertNoVar)(tag);\n    (0, import_babel_utils31.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `log` tag requires a value.\");\n    }\n    if (tag.node.attributes.length > 1 || !import_compiler41.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `log` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      const statement = import_compiler41.types.expressionStatement(\n        import_compiler41.types.callExpression(\n          import_compiler41.types.memberExpression(import_compiler41.types.identifier(\"console\"), import_compiler41.types.identifier(\"log\")),\n          [value]\n        )\n      );\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to log a value to the console.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#log\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/log.d.marko\"\n};\n\n// src/translator/core/script.ts\nvar import_compiler42 = require(\"@marko/compiler\");\nvar import_babel_utils32 = require(\"@marko/compiler/babel-utils\");\nvar htmlScriptTagAlternateMsg = \" For a native html `script` tag use the `html-script` core tag instead.\";\nvar script_default = {\n  parse(tag) {\n    const { node } = tag;\n    const { body } = node.body;\n    if (body.length) {\n      let code = \"\";\n      for (const child of body) {\n        if (child.type !== \"MarkoText\") {\n          throw tag.hub.file.hub.buildError(\n            child,\n            \"Unexpected content in `script` tag. Only javascript and typescript is supported.\" + htmlScriptTagAlternateMsg,\n            SyntaxError\n          );\n        }\n        code += child.value;\n      }\n      const start = body[0]?.start;\n      const end = body[body.length - 1]?.end;\n      const bodyStatements = (0, import_babel_utils32.parseStatements)(tag.hub.file, code, start, end);\n      const valueFn = import_compiler42.types.arrowFunctionExpression(\n        [],\n        import_compiler42.types.blockStatement(bodyStatements),\n        traverseContains(bodyStatements, isAwaitExpression)\n      );\n      node.attributes.push(import_compiler42.types.markoAttribute(\"value\", valueFn));\n      node.body.body = [];\n    }\n  },\n  analyze(tag) {\n    const { node } = tag;\n    (0, import_babel_utils32.assertNoArgs)(tag);\n    (0, import_babel_utils32.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils32.assertNoAttributeTags)(tag);\n    if (node.var) {\n      throw tag.hub.buildError(\n        node.var,\n        \"The `script` tag does not support a tag variable reference.\" + htmlScriptTagAlternateMsg\n      );\n    }\n    let seenValueAttr = false;\n    for (const attr2 of node.attributes) {\n      if (attr2.type === \"MarkoAttribute\" && attr2.name === \"value\") {\n        if (seenValueAttr) {\n          throw tag.hub.buildError(attr2, \"Invalid duplicate value attribute.\");\n        }\n        seenValueAttr = true;\n        (attr2.value.extra ??= {}).isEffect = true;\n        (currentProgramPath.node.extra ??= {}).isInteractive = true;\n      } else {\n        throw tag.hub.buildError(\n          attr2,\n          \"The `script` tag does not support html attributes.\" + htmlScriptTagAlternateMsg\n        );\n      }\n    }\n    if (!seenValueAttr) {\n      dropReferences(getAllTagReferenceNodes(node));\n    }\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      if (!valueAttr) {\n        tag.remove();\n        return;\n      }\n      const section = getSection(tag);\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      if (isOutputDOM()) {\n        const { value: value2 } = valueAttr;\n        const isFunction2 = import_compiler42.types.isFunctionExpression(value2) || import_compiler42.types.isArrowFunctionExpression(value2);\n        let inlineBody = null;\n        if (isFunction2 && !(value2.async || value2.generator)) {\n          if (import_compiler42.types.isBlockStatement(value2.body)) {\n            let hasDeclaration = false;\n            for (const child of value2.body.body) {\n              if (import_compiler42.types.isDeclaration(child)) {\n                hasDeclaration = true;\n                break;\n              }\n            }\n            inlineBody = hasDeclaration ? value2.body : value2.body.body;\n          } else {\n            inlineBody = import_compiler42.types.expressionStatement(value2.body);\n          }\n        }\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          inlineBody || import_compiler42.types.expressionStatement(\n            import_compiler42.types.callExpression(value2, isFunction2 ? [] : [scopeIdentifier])\n          )\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  html: false,\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#script\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/script.d.marko\"\n};\nfunction isAwaitExpression(node) {\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ObjectMethod\":\n    case \"ClassPrivateMethod\":\n      return skip;\n    case \"AwaitExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// src/translator/core/server.ts\nvar import_compiler43 = require(\"@marko/compiler\");\nvar import_babel_utils33 = require(\"@marko/compiler/babel-utils\");\nvar server_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^server\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils33.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler43.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler43.types.markoScriptlet(body, true, \"server\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"server <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the server.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#server-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/static.ts\nvar import_compiler44 = require(\"@marko/compiler\");\nvar import_babel_utils34 = require(\"@marko/compiler/babel-utils\");\nvar static_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^static\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils34.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler44.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler44.types.markoScriptlet(body, true));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"static <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#static-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/style.ts\nvar import_compiler45 = require(\"@marko/compiler\");\nvar import_babel_utils35 = require(\"@marko/compiler/babel-utils\");\nvar import_magic_string = __toESM(require(\"magic-string\"));\nvar import_path3 = __toESM(require(\"path\"));\nvar STYLE_EXT_REG = /^style((?:\\.[a-zA-Z0-9$_-]+)+)?/;\nvar htmlStyleTagAlternateMsg = \" For a native html `style` tag use the `html-style` core tag instead.\";\nvar style_default = {\n  analyze(tag) {\n    (0, import_babel_utils35.assertNoArgs)(tag);\n    (0, import_babel_utils35.assertNoParams)(tag);\n    (0, import_babel_utils35.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    const ext = STYLE_EXT_REG.exec(node.rawValue || \"\")?.[1]?.slice(1);\n    for (const attr2 of node.attributes) {\n      if (attr2.start == null && attr2.type === \"MarkoAttribute\" && attr2.name === \"class\" && attr2.value.type === \"StringLiteral\" && attr2.value.value === ext) {\n        continue;\n      }\n      throw tag.hub.buildError(\n        attr2.value,\n        \"The `style` does not support html attributes.\" + htmlStyleTagAlternateMsg\n      );\n    }\n    for (const child of node.body.body) {\n      if (child.type !== \"MarkoText\") {\n        throw tag.hub.buildError(\n          child,\n          \"The `style` tag currently only supports static content.\" + htmlStyleTagAlternateMsg\n        );\n      }\n    }\n    if (node.body.body.length > 1) {\n      throw tag.hub.buildError(\n        node.name,\n        \"The `style` tag currently only supports static content.\" + htmlStyleTagAlternateMsg\n      );\n    }\n  },\n  translate(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const { filename, sourceMaps } = file.opts;\n    let ext = STYLE_EXT_REG.exec(node.rawValue || \"\")?.[1] || \".css\";\n    if (node.var && !/\\.module\\./.test(ext)) {\n      ext = \".module\" + ext;\n    }\n    const markoText = node.body.body[0];\n    const { resolveVirtualDependency } = getMarkoOpts();\n    const start = (0, import_babel_utils35.getStart)(file, markoText);\n    const end = (0, import_babel_utils35.getEnd)(file, markoText);\n    let code = markoText.value;\n    let map;\n    if (resolveVirtualDependency && sourceMaps && start !== null && end !== null) {\n      const magicString = new import_magic_string.default(file.code, { filename });\n      magicString.remove(0, start);\n      magicString.remove(end, file.code.length);\n      map = magicString.generateMap({\n        source: filename,\n        includeContent: true\n      });\n      if (sourceMaps === \"inline\" || sourceMaps === \"both\") {\n        code += `\n/*# sourceMappingURL=${map.toUrl()}*/`;\n        if (sourceMaps === \"inline\") {\n          map = void 0;\n        }\n      }\n    }\n    const importPath = resolveVirtualDependency?.(filename, {\n      virtualPath: `./${import_path3.default.basename(filename) + ext}`,\n      code,\n      map\n    });\n    if (importPath) {\n      if (!node.var) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler45.types.importDeclaration([], import_compiler45.types.stringLiteral(importPath))\n        );\n      } else if (import_compiler45.types.isIdentifier(node.var)) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler45.types.importDeclaration(\n            [import_compiler45.types.importDefaultSpecifier(node.var)],\n            import_compiler45.types.stringLiteral(importPath)\n          )\n        );\n      } else {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler45.types.variableDeclaration(\"const\", [\n            import_compiler45.types.variableDeclarator(\n              node.var,\n              (0, import_babel_utils35.importDefault)(file, importPath, \"style\")\n            )\n          ])\n        );\n      }\n    }\n    tag.remove();\n  },\n  parseOptions: {\n    html: false,\n    text: true,\n    rawOpenTag: true,\n    preserveWhitespace: true\n  },\n  attributes: {}\n};\n\n// src/translator/core/try.ts\nvar import_compiler46 = require(\"@marko/compiler\");\nvar import_babel_utils36 = require(\"@marko/compiler/babel-utils\");\nvar try_default = {\n  analyze(tag) {\n    (0, import_babel_utils36.assertNoVar)(tag);\n    (0, import_babel_utils36.assertNoArgs)(tag);\n    (0, import_babel_utils36.assertNoParams)(tag);\n    (0, import_babel_utils36.assertNoAttributes)(tag);\n    assertNoSpreadAttrs(tag);\n    analyzeAttributeTags(tag);\n    const { node } = tag;\n    const section = getOrCreateSection(tag);\n    if (!node.body.body.length) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `try` tag requires body content.\");\n    }\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (!getSectionForBody(tag.get(\"body\"))) {\n          tag.remove();\n          return;\n        }\n        setAllSectionsParentIsOwner(tag);\n        flushBefore(tag);\n      },\n      exit(tag) {\n        const tagBody = tag.get(\"body\");\n        const translatedAttrs = translateAttrs(tag);\n        flushInto(tag);\n        writeHTMLResumeStatements(tagBody);\n        tag.insertBefore(translatedAttrs.statements);\n        tag.replaceWith(\n          import_compiler46.types.expressionStatement(\n            callRuntime(\n              \"tryContent\",\n              propsToExpression(translatedAttrs.properties)\n            )\n          )\n        )[0].skip();\n      }\n    },\n    dom: {\n      enter(tag) {\n        setAllSectionsParentIsOwner(tag);\n      },\n      exit(tag) {\n        tag.remove();\n      }\n    }\n  }),\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Used to capture errors and display placeholders for nested content.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#try\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/try.d.marko\"\n};\nfunction setAllSectionsParentIsOwner(tag) {\n  for (const attrTag2 of tag.get(\"attributeTags\")) {\n    if (attrTag2.isMarkoTag()) {\n      setAllSectionsParentIsOwner(attrTag2);\n    }\n  }\n  const bodySection = getSectionForBody(tag.get(\"body\"));\n  if (bodySection) {\n    setSectionParentIsOwner(bodySection, true);\n  }\n}\n\n// src/translator/core/index.ts\nvar core_default = {\n  taglibId: runtime_info_default.taglibId,\n  \"<attrs>\": attrs_default,\n  \"<await>\": await_default,\n  \"<client>\": client_default,\n  \"<const>\": const_default,\n  \"<debug>\": debug_default,\n  \"<define>\": define_default,\n  \"<effect>\": effect_default,\n  \"<else-if>\": ElseIfTag,\n  \"<else>\": ElseTag,\n  \"<export>\": export_default,\n  \"<for>\": for_default,\n  \"<html-comment>\": html_comment_default,\n  \"<html-script>\": html_script_default,\n  \"<html-style>\": html_style_default,\n  \"<id>\": id_default,\n  \"<if>\": IfTag,\n  \"<import>\": import_default,\n  \"<let>\": let_default,\n  \"<lifecycle>\": lifecycle_default,\n  \"<log>\": log_default,\n  \"<return>\": return_default,\n  \"<script>\": script_default,\n  \"<server>\": server_default,\n  \"<static>\": static_default,\n  \"<style>\": style_default,\n  \"<try>\": try_default\n};\n\n// src/translator/visitors/cdata.ts\nvar cdata_default = {\n  translate: {\n    enter(cdata) {\n      throw cdata.buildCodeFrameError(\n        \"CDATA sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/translator/visitors/comment.ts\nvar comment_default = {\n  translate: {\n    exit(comment) {\n      comment.remove();\n    }\n  }\n};\n\n// src/translator/visitors/declaration.ts\nvar declaration_default = {\n  translate: {\n    enter(decl) {\n      throw decl.buildCodeFrameError(\n        \"XML declarations sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/translator/visitors/document-type.ts\nvar document_type_default = {\n  translate: {\n    exit(documentType) {\n      if (isOutputHTML()) {\n        writeTo(documentType)`<!${documentType.node.value}>`;\n      }\n      documentType.remove();\n    }\n  }\n};\n\n// src/translator/visitors/function.ts\nvar import_compiler47 = require(\"@marko/compiler\");\nvar import_babel_utils37 = require(\"@marko/compiler/babel-utils\");\nvar functionIdsBySection = /* @__PURE__ */ new WeakMap();\nvar function_default = {\n  analyze(fn) {\n    if (fn !== getFnRoot(fn)) {\n      return;\n    }\n    const markoRoot = getMarkoRoot(fn);\n    if (markoRoot && (markoRoot.isMarkoPlaceholder() || markoRoot.isMarkoScriptlet() && markoRoot.node.target === \"server\")) {\n      return;\n    }\n    const { node } = fn;\n    const extra = node.extra ??= {};\n    const name2 = extra.name = fn.node.id?.name || (isMarkoAttribute(markoRoot) ? markoRoot.node.default ? import_compiler47.types.toIdentifier(\n      markoRoot.parentPath.has(\"var\") ? markoRoot.parentPath.get(\"var\") : markoRoot.parentPath.get(\"name\")\n    ) : markoRoot.node.name : import_compiler47.types.isVariableDeclarator(fn.parent) && import_compiler47.types.isIdentifier(fn.parent.id) ? fn.parent.id.name : import_compiler47.types.isObjectMethod(node) && import_compiler47.types.isIdentifier(node.key) ? node.key.name : \"anonymous\");\n    if (isMarkoAttribute(markoRoot) && ((0, import_babel_utils37.isNativeTag)(markoRoot.parentPath) && /^on[A-Z-]/.test(markoRoot.node.name) || isCoreTagName(markoRoot.parentPath, \"script\") || isCoreTagName(markoRoot.parentPath, \"lifecycle\") || isCoreTagName(markoRoot.parentPath, \"for\"))) {\n      return;\n    }\n    const {\n      markoOpts,\n      opts: { filename }\n    } = currentProgramPath.hub.file;\n    const section = getSection(fn);\n    let functionNameCounts = functionIdsBySection.get(section);\n    if (!functionNameCounts) {\n      functionNameCounts = /* @__PURE__ */ new Map();\n      functionIdsBySection.set(section, functionNameCounts);\n    }\n    const index = functionNameCounts.get(name2);\n    let id = \"\";\n    if (index === void 0) {\n      functionNameCounts.set(name2, 0);\n    } else {\n      id = `_${index}`;\n    }\n    extra.section = section;\n    extra.registerId = (0, import_babel_utils37.getTemplateId)(\n      markoOpts,\n      filename,\n      `${section.id}/${name2 + id}`\n    );\n  }\n};\nfunction isMarkoAttribute(path5) {\n  return path5 ? path5.isMarkoAttribute() : false;\n}\n\n// src/translator/visitors/import-declaration.ts\nvar import_babel_utils38 = require(\"@marko/compiler/babel-utils\");\nvar import_declaration_default = {\n  analyze(importDecl) {\n    const { node } = importDecl;\n    const { source } = node;\n    const { value } = source;\n    const tagImport = (0, import_babel_utils38.resolveTagImport)(importDecl, value);\n    if (tagImport) {\n      node.extra ??= {};\n      node.extra.tagImport = tagImport;\n      const tags = importDecl.hub.file.metadata.marko.tags;\n      if (!tags.includes(tagImport)) {\n        tags.push(tagImport);\n      }\n    }\n  },\n  translate: {\n    exit(importDecl) {\n      const { node } = importDecl;\n      const { extra } = node;\n      const tagImport = extra?.tagImport;\n      if (tagImport) {\n        node.source.value = tagImport;\n      }\n    }\n  }\n};\n\n// src/translator/visitors/placeholder.ts\nvar import_compiler48 = require(\"@marko/compiler\");\nvar kBinding2 = Symbol(\"placeholder node binding\");\nvar kSiblingText = Symbol(\"placeholder has sibling text\");\nvar placeholder_default = {\n  analyze(placeholder) {\n    const { node } = placeholder;\n    const { confident, computed } = evaluate(node.value);\n    if (!(confident && (node.escape || isVoid2(computed)))) {\n      (node.extra ??= {})[kBinding2] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        getOrCreateSection(placeholder),\n        void 0,\n        node.value.extra\n      );\n      analyzeSiblingText(placeholder);\n    }\n  },\n  translate: {\n    exit(placeholder) {\n      const { node } = placeholder;\n      const { value } = node;\n      const { confident, computed, referencedBindings } = evaluate(value);\n      if (confident && isVoid2(computed)) {\n        placeholder.remove();\n        return;\n      }\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(placeholder);\n      const extra = node.extra || {};\n      const nodeBinding = extra[kBinding2];\n      const canWriteHTML = isHTML || confident && node.escape;\n      const method = canWriteHTML ? node.escape ? \"escapeXML\" : \"toString\" : node.escape ? \"data\" : \"html\";\n      const isStateful = isStatefulReferences(referencedBindings);\n      const siblingText = extra[kSiblingText];\n      if (confident && canWriteHTML) {\n        write2`${getHTMLRuntime()[method](computed)}`;\n      } else {\n        if (siblingText === 1 /* Before */) {\n          if (isHTML && isStateful) {\n            write2`<!>`;\n          }\n          visit(placeholder, 37 /* Replace */);\n        } else if (siblingText === 2 /* After */) {\n          visit(placeholder, 37 /* Replace */);\n        } else {\n          if (!isHTML) write2` `;\n          visit(placeholder, 32 /* Get */);\n        }\n        if (isHTML) {\n          write2`${callRuntime(method, value)}`;\n          if (isStateful) {\n            markNode(placeholder, nodeBinding);\n          }\n        } else {\n          addStatement(\n            \"render\",\n            getSection(placeholder),\n            value.extra?.referencedBindings,\n            import_compiler48.types.expressionStatement(\n              method === \"data\" ? callRuntime(\n                \"data\",\n                import_compiler48.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(nodeBinding),\n                  true\n                ),\n                value\n              ) : callRuntime(\n                \"html\",\n                scopeIdentifier,\n                value,\n                getScopeAccessorLiteral(nodeBinding)\n              )\n            )\n          );\n        }\n      }\n      enterShallow(placeholder);\n      placeholder.remove();\n    }\n  }\n};\nfunction analyzeSiblingText(placeholder) {\n  const placeholderExtra = placeholder.node.extra;\n  let prev = placeholder.getPrevSibling();\n  while (prev.node) {\n    const contentType = getNodeContentType(\n      prev,\n      \"endType\"\n    );\n    if (contentType === null) {\n      prev = prev.getPrevSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 1 /* Before */;\n    } else {\n      break;\n    }\n  }\n  if (!prev.node && import_compiler48.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 1 /* Before */;\n  }\n  let next = placeholder.getNextSibling();\n  while (next.node) {\n    const contentType = getNodeContentType(\n      next,\n      \"startType\"\n    );\n    if (contentType === null) {\n      next = next.getNextSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 2 /* After */;\n    } else {\n      break;\n    }\n  }\n  if (!next.node && import_compiler48.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 2 /* After */;\n  }\n  return placeholderExtra[kSiblingText] = 0 /* None */;\n}\nfunction isVoid2(value) {\n  return value == null || value === false;\n}\n\n// src/translator/visitors/referenced-identifier.ts\nvar import_compiler49 = require(\"@marko/compiler\");\nvar abortIdsByExpressionForSection = /* @__PURE__ */ new WeakMap();\nvar referenced_identifier_default = {\n  migrate(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    switch (name2) {\n      case \"out\":\n        if (import_compiler49.types.isMemberExpression(identifier.parent) && import_compiler49.types.isIdentifier(identifier.parent.property) && identifier.parent.property.name === \"global\") {\n          identifier.parentPath.replaceWith(import_compiler49.types.identifier(\"$global\"));\n        } else {\n          throw identifier.buildCodeFrameError(\n            \"Only `out.global` is supported for compatibility.\"\n          );\n        }\n        break;\n    }\n  },\n  analyze(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    if (name2 === \"$global\") {\n      setReferencesScope(identifier);\n    } else if (name2 === \"$signal\") {\n      const section = getOrCreateSection(identifier);\n      section.hasAbortSignal = true;\n      setReferencesScope(identifier);\n    }\n  },\n  translate(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    switch (name2) {\n      case \"$global\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler49.types.callExpression(importRuntime(\"$global\"), [])\n          );\n        } else {\n          identifier.replaceWith(\n            import_compiler49.types.memberExpression(scopeIdentifier, import_compiler49.types.identifier(\"$global\"))\n          );\n        }\n        break;\n      case \"$signal\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler49.types.callExpression(\n              import_compiler49.types.arrowFunctionExpression(\n                [],\n                import_compiler49.types.blockStatement([\n                  import_compiler49.types.throwStatement(\n                    import_compiler49.types.newExpression(import_compiler49.types.identifier(\"Error\"), [\n                      import_compiler49.types.stringLiteral(\"Cannot use $signal in a server render.\")\n                    ])\n                  )\n                ])\n              ),\n              []\n            )\n          );\n        } else {\n          const section = getSection(identifier);\n          const exprRoot = getExprRoot(identifier);\n          let abortIdsByExpression = abortIdsByExpressionForSection.get(section);\n          let exprId;\n          if (abortIdsByExpression) {\n            exprId = abortIdsByExpression.get(exprRoot);\n          } else {\n            abortIdsByExpression = /* @__PURE__ */ new Map();\n            abortIdsByExpressionForSection.set(section, abortIdsByExpression);\n          }\n          if (!exprId) {\n            exprId = abortIdsByExpression.size;\n            abortIdsByExpression.set(exprRoot, exprId);\n            addStatement(\n              \"render\",\n              section,\n              exprRoot.node.extra?.referencedBindings,\n              import_compiler49.types.expressionStatement(\n                import_compiler49.types.callExpression(importRuntime(\"resetAbortSignal\"), [\n                  scopeIdentifier,\n                  import_compiler49.types.numericLiteral(exprId)\n                ])\n              )\n            );\n          }\n          identifier.replaceWith(\n            import_compiler49.types.callExpression(importRuntime(\"getAbortSignal\"), [\n              scopeIdentifier,\n              import_compiler49.types.numericLiteral(exprId)\n            ])\n          );\n        }\n    }\n  }\n};\n\n// src/translator/visitors/scriptlet.ts\nvar scriptlet_default = {\n  analyze(scriptlet) {\n    if (!scriptlet.node.static) {\n      throw scriptlet.buildCodeFrameError(\n        \"Scriptlets are not supported when using the tags api.\"\n      );\n    }\n    mergeReferences(\n      getOrCreateSection(scriptlet),\n      scriptlet.node,\n      scriptlet.node.body\n    );\n  },\n  translate: {\n    exit(scriptlet) {\n      const { node } = scriptlet;\n      const isHTML = isOutputHTML();\n      if (node.target && node.target !== (isHTML ? \"server\" : \"client\")) {\n        scriptlet.remove();\n        return;\n      }\n      if (isHTML) {\n      } else {\n        traverseReplace(node, \"body\", replaceRegisteredFunctionNode);\n        scriptlet.replaceWithMultiple(node.body);\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/index.ts\nvar import_compiler53 = require(\"@marko/compiler\");\nvar import_babel_utils42 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/visitors/tag/attribute-tag.ts\nvar import_compiler50 = require(\"@marko/compiler\");\nvar import_babel_utils39 = require(\"@marko/compiler/babel-utils\");\nvar attribute_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils39.assertNoVar)(tag);\n      (0, import_babel_utils39.assertNoArgs)(tag);\n      const body = tag.get(\"body\");\n      startSection(body);\n      trackParamsReferences(body, 3 /* param */);\n      if (!(0, import_babel_utils39.findParentTag)(tag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags must be nested within another tag.\");\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/custom-tag.ts\nvar import_compiler51 = require(\"@marko/compiler\");\nvar import_babel_utils40 = require(\"@marko/compiler/babel-utils\");\nvar import_path4 = __toESM(require(\"path\"));\nvar kChildScopeBinding = Symbol(\"custom tag child scope\");\nvar custom_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils40.assertAttributesOrSingleArg)(tag);\n      analyzeAttributeTags(tag);\n      const templateFile = (0, import_babel_utils40.getTagTemplate)(tag);\n      if (!templateFile) {\n        const tagName = getTagName(tag);\n        if (tagName && tag.scope.hasBinding(tagName)) {\n          throw tag.get(\"name\").buildCodeFrameError(\n            `Local variables must be in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n          );\n        }\n        throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n      }\n      const section = getOrCreateSection(tag);\n      const tagBody = tag.get(\"body\");\n      const tagExtra = tag.node.extra ??= {};\n      startSection(tagBody);\n      trackVarReferences(tag, 4 /* derived */);\n      trackParamsReferences(tagBody, 3 /* param */);\n      tagExtra[kChildScopeBinding] = createBinding(\n        \"#childScope\",\n        0 /* dom */,\n        section,\n        void 0,\n        tagExtra\n      );\n      const childFile = (0, import_babel_utils40.loadFileForTag)(tag);\n      if (childFile.opts.filename === tag.hub.file.opts.filename) {\n        mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n      } else {\n        const childProgramExtra = childFile.ast.program.extra;\n        analyzeAttrs(\n          section,\n          tag,\n          childProgramExtra?.domExports.params?.props?.[0]\n        );\n        currentProgramPath.node.extra.hasInteractiveChild = childProgramExtra?.isInteractive || childProgramExtra?.hasInteractiveChild || false;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML(tag);\n      } else {\n        translateDOM(tag);\n      }\n    }\n  }\n};\nfunction translateHTML(tag) {\n  const tagBody = tag.get(\"body\");\n  const { node } = tag;\n  let tagIdentifier;\n  flushInto(tag);\n  writeHTMLResumeStatements(tagBody);\n  if (import_compiler51.types.isStringLiteral(node.name)) {\n    const relativePath = getTagRelativePath(tag);\n    tagIdentifier = isCircularRequest(tag.hub.file, relativePath) ? htmlRendererIdentifier : (0, import_babel_utils40.importDefault)(tag.hub.file, relativePath, getTagName(tag));\n  } else {\n    tagIdentifier = node.name;\n  }\n  const tagVar = node.var;\n  const section = getSection(tag);\n  const childScopeBinding = node.extra[kChildScopeBinding];\n  const peekScopeId = tag.scope.generateUidIdentifier(childScopeBinding?.name);\n  tag.insertBefore(\n    import_compiler51.types.variableDeclaration(\"const\", [\n      import_compiler51.types.variableDeclarator(peekScopeId, callRuntime(\"peekNextScope\"))\n    ])\n  );\n  getSerializedScopeProperties(section).set(\n    getScopeAccessorLiteral(childScopeBinding),\n    callRuntime(\"writeExistingScope\", peekScopeId)\n  );\n  const inputExport = (0, import_babel_utils40.loadFileForTag)(tag)?.ast.program.extra?.domExports?.params?.props?.[0];\n  const { properties, statements } = inputExport ? translateAttrs(tag, inputExport.props) : {\n    properties: [],\n    statements: []\n  };\n  if (tagVar) {\n    statements.push(\n      import_compiler51.types.expressionStatement(\n        callRuntime(\n          \"setTagVar\",\n          getScopeIdIdentifier(section),\n          peekScopeId,\n          import_compiler51.types.stringLiteral(\n            getResumeRegisterId(\n              section,\n              node.var.extra?.binding,\n              // TODO: node.var is not always an identifier.\n              \"var\"\n            )\n          )\n        )\n      )\n    );\n  }\n  if (node.extra.tagNameNullable) {\n    const contentProp = getTranslatedBodyContentProperty(properties);\n    let contentId = void 0;\n    if (contentProp) {\n      const contentExpression = contentProp.value;\n      contentProp.value = contentId = tag.scope.generateUidIdentifier(\"content\");\n      const [contentPath] = tag.insertBefore(\n        import_compiler51.types.variableDeclaration(\"const\", [\n          import_compiler51.types.variableDeclarator(\n            contentId,\n            // TODO: only register if needed (child template analysis)\n            contentExpression\n          )\n        ])\n      );\n      contentPath.skip();\n    }\n    let renderTagExpr = callExpression(\n      tagIdentifier,\n      propsToExpression(properties)\n    );\n    if (tagVar) {\n      translateVar(tag, import_compiler51.types.unaryExpression(\"void\", import_compiler51.types.numericLiteral(0)), \"let\");\n      renderTagExpr = import_compiler51.types.assignmentExpression(\"=\", tagVar, renderTagExpr);\n    }\n    statements.push(\n      import_compiler51.types.ifStatement(\n        tagIdentifier,\n        import_compiler51.types.expressionStatement(renderTagExpr),\n        contentId && callStatement(contentId)\n      )\n    );\n  } else if (tagVar) {\n    translateVar(\n      tag,\n      callExpression(tagIdentifier, propsToExpression(properties))\n    );\n    setForceResumeScope(section);\n  } else {\n    statements.push(\n      callStatement(tagIdentifier, propsToExpression(properties))\n    );\n  }\n  for (const replacement of tag.replaceWithMultiple(statements)) {\n    replacement.skip();\n  }\n}\nfunction translateDOM(tag) {\n  const tagSection = getSection(tag);\n  const { node } = tag;\n  const extra = node.extra;\n  const childScopeBinding = extra[kChildScopeBinding];\n  const write2 = writeTo(tag);\n  const { file } = tag.hub;\n  const tagName = import_compiler51.types.isIdentifier(node.name) ? node.name.name : import_compiler51.types.isStringLiteral(node.name) ? node.name.value : \"tag\";\n  const relativePath = getTagRelativePath(tag);\n  const childFile = (0, import_babel_utils40.loadFileForTag)(tag);\n  const childExports = childFile.ast.program.extra.domExports;\n  const tagIdentifier = importOrSelfReferenceName(\n    file,\n    relativePath,\n    childExports.setup,\n    tagName\n  );\n  const inputExport = childExports.params?.props?.[0];\n  if (inputExport) {\n    writeAttrsToExports(tag, inputExport, `${getTagName(tag) || \"tag\"}_input`, {\n      circular: childFile.opts.filename === file.opts.filename,\n      tagSection,\n      relativePath,\n      childScopeBinding,\n      attrTagCallsByTag: void 0\n    });\n  }\n  write2`${(0, import_babel_utils40.importNamed)(file, relativePath, childExports.template, `${tagName}_template`)}`;\n  injectWalks(\n    tag,\n    (0, import_babel_utils40.importNamed)(file, relativePath, childExports.walks, `${tagName}_walks`)\n  );\n  if (node.var) {\n    const source = initValue(\n      // TODO: support destructuring\n      node.var.extra.binding\n    );\n    source.register = true;\n    source.buildAssignment = (valueSection, value) => {\n      return import_compiler51.types.callExpression(importRuntime(\"tagVarSignalChange\"), [\n        createScopeReadExpression(valueSection, childScopeBinding),\n        value\n      ]);\n    };\n    addStatement(\n      \"render\",\n      tagSection,\n      void 0,\n      import_compiler51.types.expressionStatement(\n        callRuntime(\n          \"setTagVar\",\n          scopeIdentifier,\n          getScopeAccessorLiteral(childScopeBinding),\n          source.identifier\n        )\n      )\n    );\n  }\n  addStatement(\n    \"render\",\n    tagSection,\n    void 0,\n    import_compiler51.types.expressionStatement(\n      import_compiler51.types.callExpression(tagIdentifier, [\n        createScopeReadExpression(tagSection, childScopeBinding)\n      ])\n    )\n  );\n  tag.remove();\n}\nfunction getTagRelativePath(tag) {\n  const {\n    node,\n    hub: { file }\n  } = tag;\n  let relativePath;\n  if (import_compiler51.types.isStringLiteral(node.name)) {\n    const template = (0, import_babel_utils40.getTagTemplate)(tag);\n    relativePath = template && (0, import_babel_utils40.resolveRelativePath)(file, template);\n  } else if (node.extra?.tagNameImported) {\n    relativePath = node.extra.tagNameImported;\n  }\n  if (!relativePath) {\n    const tagName = getTagName(tag);\n    if (tagName && tag.scope.hasBinding(tagName)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        `Local variables must be in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n      );\n    }\n    throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n  }\n  return relativePath;\n}\nfunction analyzeAttrs(section, tag, templateExport) {\n  if (!templateExport) {\n    dropReferences(getAllTagReferenceNodes(tag.node));\n    return;\n  }\n  if (!templateExport.props || tag.node.arguments?.length) {\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n    return;\n  }\n  const attrTagLookup = analyzeAttributeTags(tag);\n  const seen = /* @__PURE__ */ new Set();\n  if (attrTagLookup) {\n    const nodeReferencesByGroup = /* @__PURE__ */ new Map();\n    const analyzeDynamicChildGroup = (group, child) => {\n      const referenceNodes = getAllTagReferenceNodes(child.node);\n      const groupReferences = nodeReferencesByGroup.get(group);\n      if (groupReferences) {\n        groupReferences.referenceNodes = groupReferences.referenceNodes.concat(referenceNodes);\n      } else {\n        nodeReferencesByGroup.set(group, {\n          firstTag: child,\n          referenceNodes\n        });\n      }\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n    for (const child of attrTags2) {\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils40.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExports = templateExport.props[attrTagMeta.name];\n          if (childAttrExports) {\n            if (childAttrExports.props && !attrTagMeta.dynamic) {\n              analyzeAttrs(section, child, childAttrExports);\n            } else {\n              analyzeDynamicChildGroup(attrTagMeta.group, child);\n            }\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        } else {\n          const group = child.node.extra.attributeTagGroup;\n          let childUsesGroupProp = false;\n          for (const name2 of group) {\n            if (templateExport.props[attrTagLookup[name2].name]) {\n              childUsesGroupProp = true;\n              break;\n            }\n          }\n          if (childUsesGroupProp) {\n            analyzeDynamicChildGroup(group, child);\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        }\n      }\n    }\n    for (const { firstTag, referenceNodes } of nodeReferencesByGroup.values()) {\n      mergeReferences(section, firstTag.node, referenceNodes);\n    }\n  }\n  const { attributes } = tag.node;\n  let spreadReferenceNodes;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler51.types.isMarkoAttribute(attr2)) {\n      if (seen.has(attr2.name) || !templateExport.props[attr2.name]) {\n        dropReferences(attr2.value);\n        continue;\n      }\n      seen.add(attr2.name);\n    }\n    if (spreadReferenceNodes) {\n      spreadReferenceNodes.push(attr2.value);\n    } else if (import_compiler51.types.isMarkoSpreadAttribute(attr2)) {\n      spreadReferenceNodes = [attr2.value];\n    }\n  }\n  if (spreadReferenceNodes) {\n    mergeReferences(section, tag.node, spreadReferenceNodes);\n  }\n}\nfunction writeAttrsToExports(tag, templateExport, importAlias, info) {\n  if (tag.node.arguments?.length) {\n    const [arg] = tag.node.arguments;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    addValue(\n      info.tagSection,\n      // technically this should be `arg.extra?.referencedBindings`\n      // but we should probably ensure all other references are dropped in this case before we do that.\n      tag.node.extra?.referencedBindings,\n      identifierToSignal(tagInputIdentifier),\n      import_compiler51.types.isSpreadElement(arg) ? import_compiler51.types.memberExpression(arg.argument, import_compiler51.types.numericLiteral(0), true) : arg,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding),\n      callRuntime(\n        \"inChild\",\n        getScopeAccessorLiteral(info.childScopeBinding),\n        import_compiler51.types.identifier(tagInputIdentifier.name)\n      )\n    );\n    return;\n  }\n  if (!templateExport.props || info.circular) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    const translatedAttrs = translateAttrs(tag);\n    if (translatedAttrs.statements.length) {\n      addStatement(\n        \"render\",\n        info.tagSection,\n        referencedBindings,\n        translatedAttrs.statements\n      );\n    }\n    let translatedProps = propsToExpression(translatedAttrs.properties);\n    if ((0, import_babel_utils40.isAttributeTag)(tag)) {\n      const attrTagName = getTagName(tag);\n      const parentTag = tag.parentPath;\n      const repeated = analyzeAttributeTags(parentTag)?.[attrTagName]?.repeated;\n      if (repeated) {\n        let attrTagCallsForTag = (info.attrTagCallsByTag ||= /* @__PURE__ */ new Map()).get(\n          parentTag\n        );\n        if (!attrTagCallsForTag) {\n          info.attrTagCallsByTag.set(\n            parentTag,\n            attrTagCallsForTag = /* @__PURE__ */ new Map()\n          );\n        }\n        const attrTagCall = attrTagCallsForTag.get(attrTagName);\n        if (attrTagCall) {\n          attrTagCall.expression = callRuntime(\n            \"attrTags\",\n            attrTagCall.expression,\n            translatedProps\n          );\n          return;\n        } else {\n          attrTagCallsForTag.set(\n            attrTagName,\n            translatedProps = import_compiler51.types.parenthesizedExpression(\n              callRuntime(\"attrTag\", translatedProps)\n            )\n          );\n        }\n      } else {\n        translatedProps = callRuntime(\"attrTag\", translatedProps);\n      }\n    }\n    addValue(\n      info.tagSection,\n      referencedBindings,\n      identifierToSignal(tagInputIdentifier),\n      translatedProps,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding),\n      callRuntime(\n        \"inChild\",\n        getScopeAccessorLiteral(info.childScopeBinding),\n        import_compiler51.types.identifier(tagInputIdentifier.name)\n      )\n    );\n    return;\n  }\n  const seen = /* @__PURE__ */ new Set();\n  const attrTagLookup = analyzeAttributeTags(tag);\n  if (attrTagLookup) {\n    const attrTags2 = tag.get(\"attributeTags\");\n    const statementsByGroup = /* @__PURE__ */ new Map();\n    const translateDynamicAttrTagChildInGroup = (group, index) => {\n      const child = attrTags2[index];\n      let statements = statementsByGroup.get(group)?.statements;\n      if (!statements) {\n        statements = [];\n        statementsByGroup.set(group, {\n          referencedBindings: child.node.extra?.referencedBindings,\n          statements\n        });\n      }\n      return addDynamicAttrTagStatements(\n        attrTags2,\n        index,\n        attrTagLookup,\n        statements,\n        templateExport.props\n      );\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils40.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExport = templateExport.props[attrTagMeta.name];\n          if (childAttrExport) {\n            if (attrTagMeta.dynamic) {\n              i = translateDynamicAttrTagChildInGroup(attrTagMeta.group, i);\n            } else {\n              writeAttrsToExports(\n                child,\n                childAttrExport,\n                `${importAlias}_${attrTagMeta.name}`,\n                info\n              );\n            }\n          }\n        } else if (child.node.extra?.attributeTagGroup) {\n          i = translateDynamicAttrTagChildInGroup(\n            child.node.extra.attributeTagGroup,\n            i\n          );\n        }\n      }\n    }\n    for (const [\n      group,\n      { referencedBindings, statements }\n    ] of statementsByGroup) {\n      const decls = [];\n      for (const name2 of group) {\n        const attrTagMeta = attrTagLookup[name2];\n        const childAttrExports = templateExport.props[attrTagMeta.name];\n        if (!childAttrExports) continue;\n        const attrExportIdentifier = importOrSelfReferenceName(\n          tag.hub.file,\n          info.relativePath,\n          childAttrExports.id,\n          `${importAlias}_${attrTagMeta.name}`\n        );\n        decls.push(import_compiler51.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta)));\n        addValue(\n          info.tagSection,\n          referencedBindings,\n          identifierToSignal(attrExportIdentifier),\n          getAttrTagIdentifier(attrTagMeta),\n          createScopeReadExpression(info.tagSection, info.childScopeBinding),\n          callRuntime(\n            \"inChild\",\n            getScopeAccessorLiteral(info.childScopeBinding),\n            import_compiler51.types.identifier(attrExportIdentifier.name)\n          )\n        );\n      }\n      addStatement(\"render\", info.tagSection, referencedBindings, [\n        import_compiler51.types.variableDeclaration(\"let\", decls),\n        ...statements\n      ]);\n    }\n  }\n  const bodySection = tag.node.body.extra?.section;\n  if (bodySection && !seen.has(\"content\")) {\n    seen.add(\"content\");\n    if (templateExport.props.content) {\n      const contentExportIdentifier = (0, import_babel_utils40.importNamed)(\n        tag.hub.file,\n        info.relativePath,\n        templateExport.props.content.id,\n        `${importAlias}_content`\n      );\n      addValue(\n        info.tagSection,\n        void 0,\n        // TODO: pretty sure content needs to have the reference group of it's param defaults.\n        identifierToSignal(contentExportIdentifier),\n        import_compiler51.types.callExpression(import_compiler51.types.identifier(bodySection.name), [scopeIdentifier]),\n        createScopeReadExpression(info.tagSection, info.childScopeBinding),\n        callRuntime(\n          \"inChild\",\n          getScopeAccessorLiteral(info.childScopeBinding),\n          import_compiler51.types.identifier(contentExportIdentifier.name)\n        )\n      );\n    }\n  }\n  const { attributes } = tag.node;\n  const staticAttrs = [];\n  let spreadProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler51.types.isMarkoAttribute(attr2)) {\n      const childAttrExports = templateExport.props[attr2.name];\n      if (!childAttrExports || seen.has(attr2.name)) continue;\n      seen.add(attr2.name);\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n        continue;\n      }\n      staticAttrs.push(attr2);\n    } else if (spreadProps) {\n      spreadProps.push(import_compiler51.types.spreadElement(attr2.value));\n    } else {\n      spreadProps = [import_compiler51.types.spreadElement(attr2.value)];\n    }\n  }\n  for (const attr2 of staticAttrs.reverse()) {\n    const childAttrExports = templateExport.props[attr2.name];\n    const attrExportIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      childAttrExports.id,\n      `${importAlias}_${attr2.name}`\n    );\n    addValue(\n      info.tagSection,\n      attr2.value.extra?.referencedBindings,\n      identifierToSignal(attrExportIdentifier),\n      attr2.value,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding),\n      callRuntime(\n        \"inChild\",\n        getScopeAccessorLiteral(info.childScopeBinding),\n        import_compiler51.types.identifier(attrExportIdentifier.name)\n      )\n    );\n  }\n  const missing = new Set(Object.keys(templateExport.props));\n  for (const name2 of seen) missing.delete(name2);\n  if (missing.size) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    let getMissingPropValue = buildUndefined2;\n    if (spreadProps) {\n      const spreadId = tag.scope.generateUidIdentifier(`${importAlias}_spread`);\n      spreadProps.reverse();\n      getMissingPropValue = (name2) => toMemberExpression(spreadId, name2);\n      addStatement(\"render\", info.tagSection, referencedBindings, [\n        import_compiler51.types.variableDeclaration(\"const\", [\n          import_compiler51.types.variableDeclarator(spreadId, propsToExpression(spreadProps))\n        ])\n      ]);\n    }\n    for (const name2 of missing) {\n      const childAttrExports = templateExport.props[name2];\n      const attrExportIdentifier = importOrSelfReferenceName(\n        tag.hub.file,\n        info.relativePath,\n        childAttrExports.id,\n        `${importAlias}_${name2}`\n      );\n      addValue(\n        info.tagSection,\n        referencedBindings,\n        identifierToSignal(attrExportIdentifier),\n        getMissingPropValue(name2),\n        createScopeReadExpression(info.tagSection, info.childScopeBinding),\n        callRuntime(\n          \"inChild\",\n          getScopeAccessorLiteral(info.childScopeBinding),\n          import_compiler51.types.identifier(attrExportIdentifier.name)\n        )\n      );\n    }\n  }\n}\nfunction importOrSelfReferenceName(file, request, name2, nameHint) {\n  if (isCircularRequest(file, request)) {\n    return import_compiler51.types.identifier(name2);\n  }\n  return (0, import_babel_utils40.importNamed)(file, request, name2, nameHint);\n}\nfunction isCircularRequest(file, request) {\n  const { filename } = file.opts;\n  return request === filename || request[0] === \".\" && import_path4.default.resolve(filename, \"..\", request) === filename;\n}\nfunction callStatement(id, ...args) {\n  return import_compiler51.types.expressionStatement(callExpression(id, ...args));\n}\nfunction callExpression(id, ...args) {\n  return import_compiler51.types.callExpression(id, args.filter(Boolean));\n}\nfunction identifierToSignal(identifier) {\n  return {\n    identifier,\n    hasDownstreamIntersections: always\n  };\n}\nfunction buildUndefined2() {\n  return import_compiler51.types.unaryExpression(\"void\", import_compiler51.types.numericLiteral(0));\n}\nfunction always() {\n  return true;\n}\n\n// src/translator/visitors/tag/dynamic-tag.ts\nvar import_compiler52 = require(\"@marko/compiler\");\nvar import_babel_utils41 = require(\"@marko/compiler/babel-utils\");\nvar kDOMBinding = Symbol(\"dynamic tag dom binding\");\nvar dynamic_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils41.assertAttributesOrArgs)(tag);\n      analyzeAttributeTags(tag);\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      const tagBody = tag.get(\"body\");\n      const domBinding = tagExtra[kDOMBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section,\n        void 0,\n        tagExtra\n      );\n      startSection(tagBody);\n      trackVarReferences(tag, 4 /* derived */);\n      trackParamsReferences(tagBody, 3 /* param */);\n      mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n      addReadToExpression(tag, domBinding);\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag, 37 /* Replace */);\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const extra = node.extra;\n      const nodeRef2 = extra[kDOMBinding];\n      const section = getSection(tag);\n      const isClassAPI = extra.featureType === \"class\";\n      let tagExpression = node.name;\n      if (import_compiler52.types.isStringLiteral(tagExpression)) {\n        tagExpression = (0, import_babel_utils41.importDefault)(\n          tag.hub.file,\n          getTagRelativePath(tag),\n          tagExpression.value\n        );\n      }\n      if (isClassAPI) {\n        if (isOutputHTML()) {\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler52.types.expressionStatement(\n              import_compiler52.types.callExpression(\n                (0, import_babel_utils41.importNamed)(tag.hub.file, getCompatRuntimeFile(), \"s\"),\n                [\n                  import_compiler52.types.identifier(tagExpression.name),\n                  import_compiler52.types.stringLiteral((0, import_babel_utils41.loadFileForTag)(tag).metadata.marko.id)\n                ]\n              )\n            )\n          );\n        } else {\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler52.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                import_compiler52.types.stringLiteral((0, import_babel_utils41.loadFileForTag)(tag).metadata.marko.id),\n                import_compiler52.types.identifier(tagExpression.name)\n              )\n            )\n          );\n        }\n      }\n      const { properties, statements } = translateAttrs(\n        tag,\n        void 0,\n        void 0,\n        isClassAPI ? \"renderBody\" : \"content\"\n      );\n      const args = [];\n      let hasMultipleArgs = false;\n      if (node.arguments?.length) {\n        args.push(...node.arguments);\n        if (properties.length) {\n          hasMultipleArgs = true;\n          args.push(propsToExpression(properties));\n        } else {\n          hasMultipleArgs = node.arguments.length > 1 || import_compiler52.types.isSpreadElement(node.arguments[0]);\n        }\n      } else {\n        const contentProp = getTranslatedBodyContentProperty(properties);\n        if (contentProp) {\n          properties.splice(properties.indexOf(contentProp), 1);\n          args.push(propsToExpression(properties), contentProp.value);\n        } else {\n          args.push(propsToExpression(properties));\n        }\n      }\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        if (node.var) {\n          if (!hasMultipleArgs && args.length === 1) {\n            args.push(import_compiler52.types.unaryExpression(\"void\", import_compiler52.types.numericLiteral(0)));\n          }\n        }\n        const dynamicScopeIdentifier = currentProgramPath.scope.generateUidIdentifier(\"dynamicScope\");\n        const dynamicTagExpr = hasMultipleArgs ? callRuntime(\n          \"dynamicTagArgs\",\n          getScopeIdIdentifier(section),\n          getScopeAccessorLiteral(nodeRef2),\n          tagExpression,\n          import_compiler52.types.arrayExpression(args)\n        ) : callRuntime(\n          \"dynamicTagInput\",\n          getScopeIdIdentifier(section),\n          getScopeAccessorLiteral(nodeRef2),\n          tagExpression,\n          ...args\n        );\n        statements.push(\n          import_compiler52.types.variableDeclaration(\"const\", [\n            import_compiler52.types.variableDeclarator(\n              dynamicScopeIdentifier,\n              callRuntime(\"peekNextScope\")\n            )\n          ])\n        );\n        if (node.var) {\n          statements.push(\n            import_compiler52.types.expressionStatement(\n              callRuntime(\n                \"setTagVar\",\n                getScopeIdIdentifier(section),\n                dynamicScopeIdentifier,\n                import_compiler52.types.stringLiteral(\n                  getResumeRegisterId(\n                    section,\n                    node.var.extra?.binding,\n                    // TODO: node.var is not always an identifier.\n                    \"var\"\n                  )\n                )\n              )\n            ),\n            import_compiler52.types.variableDeclaration(\"const\", [\n              import_compiler52.types.variableDeclarator(node.var, dynamicTagExpr)\n            ])\n          );\n        } else {\n          statements.push(import_compiler52.types.expressionStatement(dynamicTagExpr));\n        }\n        getSerializedScopeProperties(section).set(\n          import_compiler52.types.stringLiteral(\n            getScopeAccessorLiteral(nodeRef2).value + \"!\" /* ConditionalScope */\n          ),\n          callRuntime(\"writeExistingScope\", dynamicScopeIdentifier)\n        );\n        getSerializedScopeProperties(section).set(\n          import_compiler52.types.stringLiteral(\n            getScopeAccessorLiteral(nodeRef2).value + \"(\" /* ConditionalRenderer */\n          ),\n          callRuntime(\n            \"normalizeDynamicRenderer\",\n            import_compiler52.types.isIdentifier(tagExpression) ? import_compiler52.types.identifier(tagExpression.name) : tagExpression\n          )\n        );\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      } else {\n        const section2 = getSection(tag);\n        const bodySection = getSectionForBody(tag.get(\"body\"));\n        const signal = getSignal(section2, nodeRef2, \"dynamicTagName\");\n        signal.build = () => {\n          return callRuntime(\n            \"conditional\",\n            getScopeAccessorLiteral(nodeRef2),\n            getSignalFn(signal, [scopeIdentifier]),\n            buildSignalIntersections(signal)\n          );\n        };\n        signal.hasDownstreamIntersections = () => true;\n        addValue(\n          section2,\n          node.name.extra?.referencedBindings,\n          signal,\n          bodySection ? import_compiler52.types.logicalExpression(\n            \"||\",\n            tagExpression,\n            import_compiler52.types.callExpression(import_compiler52.types.identifier(bodySection.name), [\n              scopeIdentifier\n            ])\n          ) : tagExpression\n        );\n        if (tag.node.var) {\n          const childScopeLiteral = import_compiler52.types.stringLiteral(\n            getScopeAccessorLiteral(extra[kDOMBinding]).value + \"!\" /* ConditionalScope */\n          );\n          const source = initValue(\n            // TODO: support destructuring\n            tag.node.var.extra.binding\n          );\n          source.register = true;\n          source.buildAssignment = (valueSection, value) => {\n            return import_compiler52.types.callExpression(importRuntime(\"tagVarSignalChange\"), [\n              import_compiler52.types.memberExpression(\n                getScopeExpression(source.section, valueSection),\n                childScopeLiteral,\n                true\n              ),\n              value\n            ]);\n          };\n          addStatement(\n            \"render\",\n            section2,\n            nodeRef2,\n            import_compiler52.types.expressionStatement(\n              callRuntime(\n                \"setTagVar\",\n                scopeIdentifier,\n                childScopeLiteral,\n                source.identifier\n              )\n            )\n          );\n        }\n        if (args.length) {\n          const argsOrInput = hasMultipleArgs ? import_compiler52.types.arrayExpression(args) : args[0];\n          const attrsGetter = import_compiler52.types.arrowFunctionExpression(\n            [],\n            statements.length ? import_compiler52.types.blockStatement(\n              statements.concat(import_compiler52.types.returnStatement(argsOrInput))\n            ) : argsOrInput\n          );\n          const id = currentProgramPath.scope.generateUidIdentifier(\n            tag.get(\"name\").toString() + \"_input\"\n          );\n          let added = false;\n          addValue(\n            section2,\n            node.extra?.referencedBindings,\n            {\n              get identifier() {\n                if (!added) {\n                  currentProgramPath.pushContainer(\n                    \"body\",\n                    import_compiler52.types.variableDeclaration(\"const\", [\n                      import_compiler52.types.variableDeclarator(\n                        id,\n                        callRuntime(\n                          \"dynamicTagAttrs\",\n                          getScopeAccessorLiteral(nodeRef2),\n                          bodySection && import_compiler52.types.identifier(bodySection.name),\n                          hasMultipleArgs && import_compiler52.types.numericLiteral(1)\n                        )\n                      )\n                    ])\n                  );\n                  added = true;\n                }\n                return id;\n              },\n              hasDownstreamIntersections: () => true\n            },\n            attrsGetter\n          );\n        }\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/index.ts\nvar TAG_NAME_IDENTIFIER_REG = /^[A-Z][a-zA-Z0-9_$]*$/;\nvar tag_default = {\n  transform: {\n    enter(tag) {\n      const { node } = tag;\n      const { name: name2, attributes } = tag.node;\n      let crawl = false;\n      if (import_compiler53.types.isStringLiteral(name2)) {\n        const tagName = name2.value;\n        if (tag.scope.getBinding(tagName) && TAG_NAME_IDENTIFIER_REG.test(tagName)) {\n          node.name = withPreviousLocation(import_compiler53.types.identifier(tagName), name2);\n          crawl = true;\n        }\n      }\n      for (let i = 0; i < attributes.length; i++) {\n        const attr2 = attributes[i];\n        if (import_compiler53.types.isMarkoAttribute(attr2) && attr2.bound) {\n          attr2.bound = false;\n          const changeValue = getChangeHandler(tag, attr2);\n          if (changeValue === null) {\n            throw tag.hub.buildError(\n              attr2,\n              \"Attributes may only be bound to identifiers or member expressions\"\n            );\n          }\n          attributes.splice(\n            ++i,\n            0,\n            import_compiler53.types.markoAttribute(attr2.name + \"Change\", changeValue)\n          );\n          crawl = true;\n        }\n      }\n      if (crawl) {\n        tag.scope.crawl();\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils42.getTagDef)(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        enter(hook, tag);\n        return;\n      }\n      if (type === 0 /* NativeTag */) {\n        native_tag_default.analyze.enter(tag);\n        return;\n      }\n      switch (type) {\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.analyze.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.analyze.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const hook = (0, import_babel_utils42.getTagDef)(tag)?.analyzer?.hook;\n      if (hook) {\n        exit(hook, tag);\n        return;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils42.getTagDef)(tag);\n      const extra = tag.node.extra;\n      if (tagDef?.translator) {\n        if (tagDef.translator.path) {\n          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);\n        }\n        enter(tagDef.translator.hook, tag);\n        return;\n      }\n      for (const attr2 of tag.get(\"attributes\")) {\n        if (attr2.isMarkoAttribute()) {\n          if (attr2.node.arguments) {\n            throw attr2.buildCodeFrameError(\n              `Unsupported arguments on the \\`${attr2.node.name}\\` attribute.`\n            );\n          }\n          if (attr2.node.modifier) {\n            if ((0, import_babel_utils42.isNativeTag)(attr2.parentPath)) {\n              attr2.node.name += `:${attr2.node.modifier}`;\n            } else {\n              throw attr2.buildCodeFrameError(\n                `Unsupported modifier \\`${attr2.node.modifier}\\`.`\n              );\n            }\n          }\n        }\n      }\n      if (extra.tagNameDynamic && extra.tagNameNullable && !tag.get(\"name\").isIdentifier() && isOutputHTML()) {\n        const tagNameId = tag.scope.generateUidIdentifier(\"tagName\");\n        const [tagNameVarPath] = tag.insertBefore(\n          import_compiler53.types.variableDeclaration(\"const\", [\n            import_compiler53.types.variableDeclarator(tagNameId, tag.node.name)\n          ])\n        );\n        tagNameVarPath.skip();\n        tag.set(\"name\", tagNameId);\n      }\n      switch (extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const translator = (0, import_babel_utils42.getTagDef)(tag)?.translator;\n      if (translator) {\n        exit(translator.hook, tag);\n        return;\n      }\n      switch (tag.node.extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.exit(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.exit(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.exit(tag);\n          break;\n      }\n    }\n  }\n};\nfunction getChangeHandler(tag, attr2) {\n  if (import_compiler53.types.isIdentifier(attr2.value)) {\n    const valueId = tag.scope.generateUidIdentifier(\"new_\" + attr2.value.name);\n    return import_compiler53.types.arrowFunctionExpression(\n      [valueId],\n      import_compiler53.types.blockStatement([\n        import_compiler53.types.expressionStatement(\n          import_compiler53.types.assignmentExpression(\"=\", import_compiler53.types.cloneNode(attr2.value), valueId)\n        )\n      ])\n    );\n  } else if (import_compiler53.types.isMemberExpression(attr2.value)) {\n    const prop = attr2.value.property;\n    if (import_compiler53.types.isPrivateName(prop)) return null;\n    if (import_compiler53.types.isIdentifier(prop)) {\n      return import_compiler53.types.memberExpression(\n        import_compiler53.types.cloneNode(attr2.value.object),\n        import_compiler53.types.identifier(prop.name + \"Change\")\n      );\n    } else {\n      return import_compiler53.types.memberExpression(\n        import_compiler53.types.cloneNode(attr2.value.object),\n        import_compiler53.types.binaryExpression(\"+\", import_compiler53.types.cloneNode(prop), import_compiler53.types.stringLiteral(\"Change\")),\n        true\n      );\n    }\n  }\n  return null;\n}\n\n// src/translator/visitors/text.ts\nvar import_compiler54 = require(\"@marko/compiler\");\nvar text_default = {\n  translate: {\n    exit(text) {\n      writeTo(text)`${text.node.value}`;\n      enterShallow(text);\n      text.remove();\n    }\n  }\n};\n\n// src/translator/index.ts\nvar visitors = extractVisitors({\n  Program: program_default,\n  Function: function_default,\n  ReferencedIdentifier: referenced_identifier_default,\n  ImportDeclaration: import_declaration_default,\n  MarkoDocumentType: document_type_default,\n  MarkoDeclaration: declaration_default,\n  MarkoCDATA: cdata_default,\n  MarkoText: text_default,\n  MarkoTag: tag_default,\n  MarkoPlaceholder: placeholder_default,\n  MarkoScriptlet: scriptlet_default,\n  MarkoComment: comment_default\n});\nvar tagDiscoveryDirs = [\"tags\"];\nvar preferAPI = \"tags\";\nvar { transform, analyze, translate } = visitors;\nvar taglibs = [\n  [\n    __dirname,\n    {\n      ...core_default,\n      migrate: visitors.migrate\n    }\n  ]\n];\nfunction getRuntimeEntryFiles(output, optimize) {\n  return [\n    `${runtime_info_default.name}${optimize ? \"\" : \"/debug\"}/${output === \"html\" ? \"html\" : \"dom\"}`\n  ];\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  analyze,\n  getRuntimeEntryFiles,\n  internalEntryBuilder,\n  preferAPI,\n  tagDiscoveryDirs,\n  taglibs,\n  transform,\n  translate\n});\n"],"names":["mod","__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__copyProps","to","from","except","desc","key","call","get","enumerable","__toESM","isNodeMode","target","__esModule","value","translator_exports","__export","all","name2","analyze","getRuntimeEntryFiles","internalEntryBuilder","entry_builder_default","preferAPI","tagDiscoveryDirs","taglibs","transform","translate","module","exports","runtime_info_default","name","require","taglibId","import_compiler","import_babel_utils","assertNoSpreadAttrs","tag","attr2","isMarkoSpreadAttribute","buildCodeFrameError","node","assertNoBodyContent","body","length","attrs_default","migrate","assertNoArgs","assertNoParams","assertNoAttributes","assertNoAttributeTags","diagnosticDeprecate","label","fix","tagVar","var","type","remove","constTag","types","markoTag","stringLiteral","markoAttribute","identifier","markoTagBody","replaceWith","attributes","autocomplete","displayText","description","snippet","import_compiler22","import_babel_utils12","import_babel_utils2","evaluate","extra","confident","computed","computeNode","import_compiler21","import_compiler20","import_babel_utils11","import_path2","bindingHasDownstreamExpressions","binding","downstreamExpressions","size","alias","aliases","propertyAliases","values","import_compiler2","import_babel_utils3","kState","Symbol","build","entryFile","state","path","imports","map","it","importDeclaration","init","unshift","importSpecifier","markoOpts","optimize","push","expressionStatement","callExpression","visit","file","visitChild","analyzedTags","metadata","marko","resolveRelativePath","opts","filename","hasInteractiveChild","isInteractive","isOutputHTML","getMarkoOpts","output","isOutputDOM","currentProgramPath","hub","isOptimize","import_compiler4","import_babel_utils4","stringifyClassObject","NON_DIMENSIONAL","stringifyStyleObject","test","toDelimitedString","val","delimiter","stringify","result","curDelimiter","Array","isArray","v","part","isEventHandler","getEventHandlerName","slice","toLowerCase","toString","unsafeXMLReg","replaceUnsafeXML","c","escapeXML","str","replace","unsafeScriptReg","escapeScript","unsafeStyleReg","escapeStyle","toAccess","accessor","start","classAttr","stringAttr","styleAttr","attr","attrAssignment","RegExp","source","nonVoidAttr","escapeAttrValue","constructor","async","KNOWN_SYMBOLS2","Map","symbol","set","AggregateError","of","ArrayBuffer","isView","Atomics","add","and","compareExchange","exchange","isLockFree","load","notify","or","store","sub","wait","BigInt","asIntN","asUintN","BigInt64Array","BigUint64Array","Boolean","console","assert","clear","count","countReset","debug","dir","dirxml","error","group","groupCollapsed","groupEnd","info","log","table","time","timeEnd","timeLog","timeStamp","trace","warn","DataView","Date","now","parse","UTC","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","Error","EvalError","Float32Array","Float64Array","Function","globalThis","atob","btoa","clearImmediate","clearInterval","clearTimeout","crypto","getRandomValues","randomUUID","fetch","performance","queueMicrotask","setImmediate","setInterval","setTimeout","structuredClone","URL","URLSearchParams","WritableStream","Int16Array","Int32Array","Int8Array","Intl","Collator","DateTimeFormat","DisplayNames","getCanonicalLocales","ListFormat","Locale","NumberFormat","PluralRules","RelativeTimeFormat","Segmenter","supportedValuesOf","isFinite","isNaN","JSON","groupBy","Math","abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","floor","fround","hypot","imul","log10","log1p","log2","max","min","pow","random","round","sign","sin","sinh","sqrt","tan","tanh","trunc","Number","isInteger","isSafeInteger","parseFloat","parseInt","assign","defineProperties","entries","freeze","fromEntries","getOwnPropertyDescriptors","getOwnPropertySymbols","is","isExtensible","isFrozen","isSealed","keys","preventExtensions","seal","setPrototypeOf","Promise","Proxy","RangeError","ReferenceError","Reflect","apply","construct","deleteProperty","has","ownKeys","Set","String","fromCharCode","fromCodePoint","raw","for","SyntaxError","TypeError","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","URIError","WeakMap","WeakSet","unsafeAttrChars","lastIndex","import_compiler3","toPropertyName","numericLiteral","toObjectProperty","objectProperty","toMemberExpression","object","optional","prop","optionalMemberExpression","memberExpression","pureFunctions","importRuntime","importStar","getRuntimePath","callRuntime","args","callExpression2","filteredArgs","i","arg","unaryExpression","filterArguments","includes","leadingComments","getHTMLRuntime","getCompatRuntimeFile","modules","import_compiler6","import_babel_utils7","import_babel_utils5","getTagName","isCoreTag","isMarkoTag","tagDef","getTagDef","isCoreTagName","isConditionTag","data","item","forEach","cb","find","findSorted","compare","pos","mid","cur","compareResult","addSorted","len","next","joinRepeatable","a","b","createProgramState","createSectionState","section","arrayOfSectionData","id","import_compiler5","import_babel_utils6","MARKO_FILE_REG","analyzeTagNameType","tagNameType","isStringLiteral","isNativeTag","tagNameNullable","pending","path5","tagNameImported","nullable","pop","isConditionalExpression","alternate","isLogicalExpression","operator","isAssignmentExpression","isBinaryExpression","isTemplateLiteral","isNullLiteral","isIdentifier","scope","getBinding","kind","decl","parent","specifiers","some","isImportDefaultSpecifier","resolvedImport","resolveTagImport","bindingTag","bindingTagName","tagNameDynamic","analyzeExpressionTagName","childFile","loadFileForTag","ast","program","featureType","needsCompat","startSection","parentSection","parentPath","getOrCreateSection","sectionNamePath","sectionName","isProgram","generateUid","programExtra","sections","loc","depth","params","closures","bindings","assignments","content","getContentInfo","upstreamExpression","hasAbortSignal","isBranch","attributeTags","getSectionForBody","getSection","currentPath","getScopeIdIdentifier","generateUidIdentifier","getSectionParentIsOwner","setSectionParentIsOwner","_getScopeIdentifier","getScopeIdentifier","ignoreDefault","scopeId","forEachSection","fn","contentInfo","startType","endType","singleChild","endIndex","getNodeContentType","startIndex","extraMember","isAttributeTag","tagSection","isStatefulSection","isStatefulReferences","referencedBindings","checkStatefulClosures","immediateOnly","closure","import_compiler18","import_babel_utils10","import_path","regexpCharsReg","import_compiler17","import_babel_utils9","import_compiler11","import_babel_utils8","getKnownAttrValues","attrs2","getParentTag","import_compiler7","enter","modulePlugin","plugin","isModulePlugin","default","isFunctionPlugin","exit","translateByTarget","html","dom","import_compiler10","import_compiler8","normalizeStringExpression","parts","strs","exprs","curStr","nextIndex","exprLen","expressions","shiftItems","quasis","j","templateLiteral","templateElement","appendLiteral","arr","list","offset","import_compiler9","getWalks","getWalkComment","getSteps","walkCodeToName","enter2","exit2","enterShallow","code","steps","walks","walkComment","walkString","walkCodes","step","lastIndexOf","current","walk","nCodeString","writeTo","number","toCharString","startCode","rangeSize","multiplier","getWalkString","prefix2","postfix","walkLiteral","join","getWrites","getTrailerWrites","trailer","exprsLen","writes","consumeHTML","trailers","writeResult","trailerResult","sequenceExpression","flushBefore","expr","insertBefore","skip","flushInto","pushContainer","getSectionMeta","writePrefix","writePostfix","setup","getSetup","markNode","getScopeAccessorLiteral","tagsWithReturn","getSectionReturnValueIdentifier","setReturnValueIdentifier","return_default","assertNoVar","assertAllowedAttributes","parentTag","isControlFlowTag","valueChange","getSerializedScopeProperties","returnId","variableDeclaration","variableDeclarator","addValue","hasDownstreamIntersections","parseOptions","openTagOnly","descriptionMoreURL","forEachIdentifier","properties","left","argument","el","elements","import_compiler12","getDeclaredBindingExpression","declared","upstreamAlias","property","import_compiler13","createScopeReadPattern","rootDepth","rootPattern","objectPattern","nestedPatterns","ref","propertyKey","propertyValue","isShorthand","pattern","relativeDepth","prev","nestedPattern","getScopeExpression","targetSection","scopeIdentifier","diff","createScopeReadExpression","reference","import_compiler14","simplifyFunction","functionExpression","generator","import_compiler15","toFirstExpressionOrBlock","stmts","isExpressionStatement","expression","toParenthesizedExpressionIfNeeded","blockStatement","parenthesizedExpression","import_compiler16","traverseReplace","container","enter3","VISITOR_KEYS","replacement","traverseContains","check","getSignals","getClosureSignalBuilder","_setClosureSignalBuilder","setClosureSignalBuilder","builder","forceResumeScope","_setForceResumeScope","setForceResumeScope","unimplementedBuild","getSignal","generateSignalName","signals","signal","exportName","export","domExports","intersection","render","renderReferencedBindings","effect","effectReferencedBindings","subscribers","subscribe","getSignalFn","buildSignalIntersections","bindingUtil","ownerScope","isImmediateOwner","isDynamicClosure","arrowFunctionExpression","addStatement","initValue","runtimeHelper","valueAccessor","intersections","isParamBinding","scopeIdentifier2","valueIdentifier","isValueSignal","aliasSignal","getTranslatedExtraArgs","closureEntries","sort","_closureSection","closureSignal","hasTranslatedExtraArgs","emptyExtraArgs","extraArgs","replaceRenderNode","signal2","intersectionExpression","isMemberExpression","arrayExpression","provider","subscriber","p","providerSignal","finalizeSignalArgs","isArrowFunctionExpression","isBlockStatement","statement","usedReferences","statements","addEffectReferences","addRenderReferences","union","getResumeRegisterId","getTemplateId","usedRegisterIdsBySection","getRegisterUID","used","baseId","writeSignals","sortSignals","value2","effectDeclarator","replaceEffectNode","effectIdentifier","referencesScope","isScopeIdentifier","isCallExpression","arguments","register","signalDeclarator","signalDeclaration","isFunctionExpression","functionDeclaration","isExpression","exportNamedDeclaration","toReturnedFunction","rawFn","returnStatement","aReferencedBindings","getReferencedBindings","bReferencedBindings","reserve","getMappedId","addHTMLEffectCall","writeHTMLResumeStatements","allSignals","scopeIdIdentifier","assignment","currentSection","signalRefs","accessors","additionalProperties","serializedProperties","serialize","isLiteral","writeScope2","objectExpression","debugVars","root","access","locStr","line","column","filenameRelative","unshiftContainer","returnIdentifier","replaceAssignedNode","replaceBindingReadNode","replaceRegisteredFunctionNode","getReadReplacement","isAssignedBindingExtra","buildAssignment","binaryExpression","prefix","right","resultId","assignmentExpression","registeredFnsForProgram","getRegisteredFnExpression","classProperty","classPrivateProperty","isRegisteredFnExtra","referencedBindingsInFunction","registedFns","registerId","dom_default","templateIdentifier","template","walksIdentifier","setupIdentifier","paramsBinding","programParamsSignal","styleFile","fs","fileSystem","base","sep","leftDot","indexOf","rightDot","closeBracket","openBracket","getBase","styleMatch","file2","readdirSync","dirname","getStyleFile","importDefault","forEachSectionReverse","childSection","tagParamsSignal","walks2","writes2","setup2","renderer","registeredFns","registeredFn","assignmentPattern","stmt","writeRegisteredFns","exportDefaultDeclaration","import_compiler19","html_default","replaceNode","renderContent","child","isImportDeclaration","isExportDeclaration","isMarkoScriptlet","static","replaceWithMultiple","htmlRendererIdentifier","read","replaceBindingReadNode2","getRegisteredFnExpression2","registeredFnDeclarations","registeredFnDeclarationsByBody","addRegisteredDeclarations","replaceRegisteredFunctionNode2","previousProgramPath","program_default","crawl","trackParamsReferences","getBindings","readsByExpression","getReadsByExpression","readsByFn","getReadsByFunction","mergedReferences","getMergedReferences","nodes","targetExtra","reads","isEffect","isReferencedExtra","additionalReads","concat","delete","intersectionsBySection","resolveReferencedBindings","pruneBinding","name3","section2","bindingReference","numReferences","binding1","binding2","sources1","getSourceBindings","sources2","isSuperset","sourceSection","bindings2","filter","finalizeReferences","buildTemplateExports","visitedFiles","resolved","loadFileForImport","req","resolveRelativeToEntry","compatFile","templateExport","props","exports2","getExprRoot","curPath","isMarko","getFnRoot","fnPath","isFunction","declare","withPreviousLocation","newNode","originalNode","end","getNextBindingId","setNextBindingId","createBinding","excludeProperties","propBinding","trackVarReferences","canonicalUpstreamAlias","getCanonicalBinding","pruned","createBindingsAndTrackReferences","trackAssignment","setReferencesScope","fnRoot","lVal","babelBinding","referencePaths","constantViolations","referencePath","trackReference","isUpdateExpression","trackReferencesForBinding","patternBinding","element","propPath","getMemberExpressionPropString","isEventOrChangeHandler","exprRoot","addReadToExpression","fnExtra","mergeReferences","compareIntersections","lenDelta","subset","elem","derived","sources","curBinding","this","aLen","bLen","aIndex","bIndex","aValue","bValue","delta","unionSortedRepeatable","exprExtra","dropReferences","getAllTagReferenceNodes","referenceNodes","shouldPrune","exprReference","resolveExpressionReference","createRead","readBinding","readProps","aliasProps","isStatefulBinding","await_default","valueAttr","isMarkoAttribute","isSpreadElement","bodySection","tagBody","import_compiler23","import_babel_utils13","client_default","rawValue","trim","parseStatements","markoScriptlet","rawOpenTag","import_compiler25","import_babel_utils14","import_compiler24","translateVar","initialValue","const_default","varBinding","derivation","import_compiler26","import_babel_utils15","debug_default","debuggerStatement","import_babel_utils20","import_compiler27","import_babel_utils16","attrTagToIdentifierLookup","getAttrTagIdentifier","meta","analyzeAttributeTags","attrTags2","lookup","attrTagNodesByName","sampleAttrTagsForControlFlow","createAttrTagMeta","isRepeated","isLoopTag","curGroup","crawlAttrTags","oldMeta","attrTagMeta","dynamic","repeated","controlFlowTag","sampleAttrName","attributeTagGroup","attrTagNodes","hasRepeatedDynamicAttrTags","attrTagNames","tagName","conditionRoot","seenBranches","attrTag2","curConditionRoot","getConditionRoot","getPrevSibling","import_compiler30","import_babel_utils19","import_compiler29","import_babel_utils18","import_compiler28","import_babel_utils17","kNativeTagBinding","kSerializeMarker","kGetterId","htmlSelectArgs","getRelatedControllable","checked","checkedChange","special","helper","attrs","checkedValue","checkedValueChange","open","openChange","native_tag_default","escape","buildError","buildUndefined","hasEventHandlers","hasDynamicAttributes","seen","relatedControllable","spreadReferenceNodes","propName","exclusiveGroups","assertExclusiveControllableGroups","every","tagName2","toIdentifier","tagExtra","bindingName","isInvokedFunction","nodeRef2","isHTML","write2","getterId","varName","references","getterFnIdentifier","referenceSection","visitAccessor","usedAttrs","maybeStaticAttrs","spreadExpression","skipExpression","spreadProps","skipProps","staticControllable","attr3","spreadElement","staticAttrs","reverse","propsToExpression","getUsedAttrs","writeAtStartOfBody","firstAttr","spreadIdentifier","valueReferences","htmlType","ifStatement","selectArgs","callee","kForMarkerBinding","kOnlyChildInParent","for_default","isAttrTag","allowAttrs","getForType","isOnlyChildInParent","parentTagName","isStateful","forAttrs","forType","bodyStatements","hasStatefulClosures","singleNodeOptimization","keyExpression","defaultParamNames","in","defaultByParamIndex","requiredParamsIndex","by","existingParam","byIdentifier","forTypeToHTMLByRuntime","forScopesIdentifier","newExpression","conditionalExpression","forTagArgs","getBaseArgsInForTag","forTagHTMLRuntime","forTypeToHTMLResumeRuntime","forTypeToRuntime","_closureSignal","forTypeToDOMRuntime","param","referencedBindings2","loopArgs","controlFlow","contentProps","translateAttrs","templateExports","contentKey","attrTagLookup","usesExport","addDynamicAttrTagStatements","translatedAttrTag","prevProp","findObjectProperty","contentExpression","isTransparentTag","getNonAttributeTagParent","buildContent","contentProp","getTranslatedBodyContentProperty","index","ifTag","consequentStatements","getConditionTestValue","addAllAttrTagsAsDynamic","nextTag","testValue","alternateStatements","translateIfAttrTag","forTag","buildForRuntimeCall","translateForAttrTag","define_default","translatedAttrs","import_compiler32","import_babel_utils21","effect_default","import_babel_utils22","export_default","import_compiler33","import_babel_utils23","kCommentTagBinding","kGetterId2","html_comment_default","needsBinding","needsGetter","isMarkoPlaceholder","isMarkoText","commentBinding","templateQuasis","templateExpressions","currentQuasi","text","import_compiler34","import_babel_utils24","kGetterId3","html_script_default","bodyPlaceholderNodes","hasBodyPlaceholders","getUsedAttrs2","referencePlaceholder","preserveWhitespace","import_compiler35","import_babel_utils25","kGetterId4","html_style_default","getUsedAttrs3","import_compiler36","import_babel_utils26","id_default","import_compiler38","import_babel_utils27","import_compiler37","kBinding","BRANCHES_LOOKUP","IfTag","assertHasBody","assertHasValueAttribute","assertHasPrecedingCondition","ifAttr","msg","assertOptionalIfAttribute","assertValidCondition","isLast","branches","getBranches","rootTag","rootExtra","mergeReferenceNodes","branchTag","branchBodySection","isRoot","getNextSibling","ifScopeIdIdentifier","ifRendererIdentifier","branchHasStatefulClosures","testAttr","curStatement","cbNode","nullLiteral","consequent","ElseIfTag","ElseTag","isMarkoComment","import_babel_utils28","import_default","import_compiler39","import_babel_utils29","let_default","valueChangeAttr","valueSection","import_compiler40","import_babel_utils30","kRef","lifecycle_default","lifecycleAttrsRef","import_compiler41","import_babel_utils31","log_default","import_compiler42","import_babel_utils32","htmlScriptTagAlternateMsg","script_default","valueFn","isAwaitExpression","seenValueAttr","isFunction2","inlineBody","hasDeclaration","isDeclaration","import_compiler43","import_babel_utils33","server_default","import_compiler44","import_babel_utils34","static_default","import_compiler45","import_babel_utils35","import_magic_string","import_path3","STYLE_EXT_REG","htmlStyleTagAlternateMsg","style_default","ext","exec","sourceMaps","markoText","resolveVirtualDependency","getStart","getEnd","magicString","generateMap","includeContent","toUrl","importPath","virtualPath","basename","importDefaultSpecifier","import_compiler46","import_babel_utils36","try_default","setAllSectionsParentIsOwner","core_default","cdata_default","cdata","comment_default","comment","declaration_default","document_type_default","documentType","import_compiler47","import_babel_utils37","functionIdsBySection","function_default","markoRoot","getMarkoRoot","isVariableDeclarator","isObjectMethod","functionNameCounts","import_babel_utils38","import_declaration_default","importDecl","tagImport","tags","import_compiler48","kBinding2","kSiblingText","placeholder_default","placeholder","isVoid2","placeholderExtra","contentType","analyzeSiblingText","nodeBinding","canWriteHTML","method","siblingText","import_compiler49","abortIdsByExpressionForSection","referenced_identifier_default","hasBinding","throwStatement","exprId","abortIdsByExpression","scriptlet_default","scriptlet","import_compiler53","import_babel_utils42","import_babel_utils39","attribute_tag_default","findParentTag","import_compiler51","import_babel_utils40","import_path4","kChildScopeBinding","custom_tag_default","assertAttributesOrSingleArg","getTagTemplate","charAt","toUpperCase","childProgramExtra","analyzeAttrs","tagIdentifier","relativePath","getTagRelativePath","isCircularRequest","childScopeBinding","peekScopeId","inputExport","contentId","contentPath","renderTagExpr","callStatement","translateHTML","childExports","importOrSelfReferenceName","writeAttrsToExports","circular","attrTagCallsByTag","importNamed","injectWalks","translateDOM","nodeReferencesByGroup","analyzeDynamicChildGroup","groupReferences","firstTag","attrTagName","childAttrExports","childUsesGroupProp","importAlias","tagInputIdentifier","identifierToSignal","translatedProps","attrTagCallsForTag","attrTagCall","statementsByGroup","translateDynamicAttrTagChildInGroup","childAttrExport","decls","attrExportIdentifier","contentExportIdentifier","missing","getMissingPropValue","buildUndefined2","spreadId","request","nameHint","resolve","always","import_compiler52","import_babel_utils41","kDOMBinding","dynamic_tag_default","assertAttributesOrArgs","domBinding","isClassAPI","tagExpression","hasMultipleArgs","splice","dynamicScopeIdentifier","dynamicTagExpr","logicalExpression","childScopeLiteral","argsOrInput","attrsGetter","added","TAG_NAME_IDENTIFIER_REG","tag_default","bound","changeValue","getChangeHandler","hook","analyzer","translator","watchFiles","modifier","tagNameId","tagNameVarPath","valueId","cloneNode","isPrivateName","visitors","visitors2","_name","extractVisitors","Program","ReferencedIdentifier","ImportDeclaration","MarkoDocumentType","MarkoDeclaration","MarkoCDATA","MarkoText","MarkoTag","MarkoPlaceholder","MarkoScriptlet","MarkoComment"],"sourceRoot":""}