{"version":3,"file":"664.f3a818fc.js","mappings":"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","sources":["webpack:///../../browser-shims|sync","webpack:///../../browser-shims/translator.js","webpack:///playground-6.marko","webpack:///./playground/v6/index.marko","webpack:///../../browser-shims/compiler/dist/babel-types/index.js","webpack:///../../browser-shims/compiler/index.js","webpack:///../../browser-shims/compiler/modules.js","webpack:///../../browser-shims/fs.js","webpack:///../../browser-shims/process.js"],"sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"../../browser-shims sync recursive\";\nmodule.exports = webpackEmptyContext;","var __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\")\n    return require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\n// src/visitors/program/index.ts\nimport { types as t10 } from \"@marko/compiler\";\n\n// src/util/marko-config.ts\nfunction isOutputHTML() {\n  return getMarkoOpts().output === \"html\";\n}\nfunction isOutputDOM() {\n  return !isOutputHTML();\n}\nfunction getMarkoOpts() {\n  return currentProgramPath.hub.file.markoOpts;\n}\n\n// src/visitors/program/html.ts\nimport { types as t8 } from \"@marko/compiler\";\n\n// src/util/apply-hydrate.ts\nimport { types as t4 } from \"@marko/compiler\";\n\n// src/util/references.ts\nimport { types as t2 } from \"@marko/compiler\";\n\n// src/util/sorted-arr.ts\nfunction insertInArray(compare, arr, val) {\n  const len = arr.length;\n  let max = len;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(arr[mid], val);\n    if (compareResult === 0)\n      return arr;\n    if (compareResult > 0)\n      max = mid;\n    else\n      pos = mid + 1;\n  }\n  let cur = val;\n  while (pos < len) {\n    const next = cur;\n    cur = arr[pos];\n    arr[pos++] = next;\n  }\n  arr[len] = cur;\n  return arr;\n}\nfunction findIndex(compare, arr, val) {\n  let max = arr.length;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(arr[mid], val);\n    if (compareResult === 0)\n      return mid;\n    if (compareResult > 0)\n      max = mid;\n    else\n      pos = mid + 1;\n  }\n  return -1;\n}\nfunction createSortedCollection(compare) {\n  return {\n    insert(data, val, immutable = false) {\n      if (data) {\n        if (Array.isArray(data)) {\n          return insertInArray(compare, immutable ? [...data] : data, val);\n        } else {\n          const compareResult = compare(data, val);\n          if (compareResult !== 0) {\n            return compareResult < 0 ? [data, val] : [val, data];\n          }\n        }\n      }\n      return val;\n    },\n    find(data, val) {\n      if (data) {\n        if (Array.isArray(data)) {\n          return data[findIndex(compare, data, val)];\n        } else {\n          return data === val ? data : void 0;\n        }\n      }\n    }\n  };\n}\n\n// src/util/tag-name-type.ts\nimport { types as t } from \"@marko/compiler\";\nimport { isNativeTag } from \"@marko/babel-utils\";\nvar MARKO_FILE_REG = /^<.*>$|\\.marko$/;\nfunction analyzeTagNameType(tag) {\n  const extra = tag.node.extra ??= {};\n  if (extra.tagNameType === void 0) {\n    const name = tag.get(\"name\");\n    if (name.isStringLiteral()) {\n      extra.tagNameType = name.node.value[0] === \"@\" ? 3 /* AttributeTag */ : isNativeTag(tag) ? 0 /* NativeTag */ : 1 /* CustomTag */;\n      extra.tagNameNullable = extra.tagNameNullable = false;\n    } else {\n      const pending = [name];\n      let path3;\n      let type = void 0;\n      let nullable = false;\n      while ((path3 = pending.pop()) && type !== 2 /* DynamicTag */) {\n        if (path3.isConditionalExpression()) {\n          pending.push(path3.get(\"consequent\"));\n          if (path3.node.alternate) {\n            pending.push(path3.get(\"alternate\"));\n          }\n        } else if (path3.isLogicalExpression()) {\n          if (path3.node.operator === \"||\") {\n            pending.push(path3.get(\"left\"));\n          } else {\n            nullable = true;\n          }\n          pending.push(path3.get(\"right\"));\n        } else if (path3.isAssignmentExpression()) {\n          pending.push(path3.get(\"right\"));\n        } else if (path3.isBinaryExpression()) {\n          type = path3.node.operator !== \"+\" || type !== void 0 && type !== 0 /* NativeTag */ ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n        } else if (path3.isStringLiteral() || path3.isTemplateLiteral()) {\n          type = type !== void 0 && type !== 0 /* NativeTag */ ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n        } else if (path3.isNullLiteral()) {\n          nullable = true;\n        } else if (path3.isIdentifier()) {\n          if (path3.node.name === \"undefined\") {\n            nullable = true;\n            continue;\n          }\n          const binding = path3.scope.getBinding(path3.node.name);\n          if (!binding) {\n            type = 2 /* DynamicTag */;\n            continue;\n          }\n          if (binding.kind === \"module\") {\n            const decl = binding.path.parent;\n            if (MARKO_FILE_REG.test(decl.source.value) && decl.specifiers.some((it) => t.isImportDefaultSpecifier(it))) {\n              type = type !== void 0 && type !== 1 /* CustomTag */ ? 2 /* DynamicTag */ : 1 /* CustomTag */;\n            } else {\n              type = 2 /* DynamicTag */;\n            }\n            continue;\n          }\n          const bindingTag = binding.path;\n          if (bindingTag.isMarkoTag() && binding.kind === \"local\") {\n            const bindingTagName = bindingTag.get(\"name\").node.value;\n            if (bindingTagName === \"tag\") {\n              type = type !== void 0 && type !== 1 /* CustomTag */ ? 2 /* DynamicTag */ : 1 /* CustomTag */;\n              continue;\n            }\n            if (bindingTagName === \"const\") {\n              pending.push(bindingTag.get(\"attributes\")[0].get(\"value\"));\n              continue;\n            }\n            if (bindingTagName === \"let\") {\n              const defaultAttr = bindingTag.get(\"attributes\")[0];\n              if (defaultAttr.node) {\n                pending.push(defaultAttr.get(\"value\"));\n              } else {\n                nullable = true;\n              }\n              const assignments = binding.constantViolations;\n              for (let i = assignments.length; i--; ) {\n                const assignment = assignments[i];\n                const { operator } = assignment.node;\n                if (operator === \"=\") {\n                  pending.push(assignment.get(\"right\"));\n                } else if (operator === \"+=\") {\n                  type = type !== void 0 && type !== 0 /* NativeTag */ ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n                } else {\n                  type = 2 /* DynamicTag */;\n                  break;\n                }\n              }\n            }\n            continue;\n          }\n          type = 2 /* DynamicTag */;\n        } else {\n          type = 2 /* DynamicTag */;\n        }\n      }\n      extra.tagNameType = type;\n      extra.tagNameNullable = nullable;\n      extra.tagNameDynamic = true;\n    }\n  }\n  return extra.tagNameType;\n}\n\n// src/util/sections.ts\nfunction startSection(path3) {\n  const extra = path3.node.extra ??= {};\n  let sectionId = extra.sectionId;\n  if (sectionId === void 0) {\n    const programExtra = path3.hub.file.path.node.extra ??= {};\n    const sectionNameNode = path3.parent?.name;\n    const sectionName = sectionNameNode?.value ?? sectionNameNode?.name ?? \"dynamic\";\n    sectionId = extra.sectionId = programExtra.nextSectionId || 0;\n    programExtra.nextSectionId = sectionId + 1;\n    programExtra.sectionNames = programExtra.sectionNames ?? [];\n    programExtra.sectionNames[sectionId] = currentProgramPath.scope.generateUid(sectionName + \"Body\");\n  }\n  return sectionId;\n}\nfunction getOrCreateSectionId(path3) {\n  let cur = path3;\n  while (true) {\n    if (cur.type === \"Program\" || cur.type === \"MarkoTagBody\" && analyzeTagNameType(cur.parentPath) !== 0 /* NativeTag */) {\n      return startSection(cur);\n    }\n    cur = cur.parentPath;\n  }\n}\nfunction getSectionId(path3) {\n  let sectionId;\n  let currentPath = path3;\n  while ((sectionId = currentPath.node.extra?.sectionId) === void 0) {\n    currentPath = currentPath.parentPath;\n  }\n  return sectionId;\n}\nfunction createSectionState(key, init) {\n  return [\n    (sectionId) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= [];\n      const sectionData = arrayOfSectionData[sectionId] ??= init && init(sectionId);\n      return sectionData;\n    },\n    (sectionId, value) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= [];\n      arrayOfSectionData[sectionId] = value;\n    }\n  ];\n}\nfunction forEachSectionId(fn) {\n  const { nextSectionId } = currentProgramPath.node.extra;\n  for (let sectionId = 0; sectionId < nextSectionId; sectionId++) {\n    fn(sectionId);\n  }\n}\nfunction forEachSectionIdReverse(fn) {\n  const { nextSectionId } = currentProgramPath.node.extra;\n  for (let sectionId = nextSectionId; sectionId--; ) {\n    fn(sectionId);\n  }\n}\n\n// src/util/reserve.ts\nvar [getReservesByType] = createSectionState(\"reservesByType\", () => [void 0, void 0, void 0]);\nfunction reserveScope(type, sectionId, node, name, size = 0) {\n  const extra = node.extra ??= {};\n  if (extra.reserve) {\n    const reserve2 = extra.reserve;\n    if (size && reserve2.size) {\n      throw new Error(\"Unable to reserve multiple scopes for a node\");\n    } else {\n      reserve2.size = size;\n      reserve2.name += \"_\" + name;\n    }\n    return reserve2;\n  }\n  const reservesByType = getReservesByType(sectionId);\n  const reserve = extra.reserve = {\n    id: 0,\n    type,\n    size,\n    name,\n    sectionId\n  };\n  if (reservesByType[type]) {\n    reserve.id = reservesByType[type].push(reserve) - 1;\n  } else {\n    reservesByType[type] = [reserve];\n  }\n  return reserve;\n}\nfunction assignFinalIds() {\n  forEachSectionId((sectionId) => {\n    let curIndex = 0;\n    for (const reserves of getReservesByType(sectionId)) {\n      if (reserves) {\n        for (const reserve of reserves) {\n          reserve.id = curIndex;\n          curIndex += reserve.size + 1;\n        }\n      }\n    }\n  });\n}\nfunction compareReserves(a, b) {\n  return a.sectionId - b.sectionId || a.type - b.type || a.id - b.id;\n}\nvar { insert: insertReserve } = createSortedCollection(compareReserves);\n\n// src/util/references.ts\nvar [getReferenceGroups] = createSectionState(\"apply\", () => [\n  {\n    sectionId: 0,\n    index: 0,\n    count: 0,\n    references: void 0,\n    apply: t2.identifier(\"\"),\n    hydrate: t2.identifier(\"\")\n  }\n]);\nfunction trackReferences(tag) {\n  if (tag.has(\"var\")) {\n    trackReferencesForBindings(getOrCreateSectionId(tag), tag.get(\"var\"));\n  }\n  const body = tag.get(\"body\");\n  if (body.get(\"body\").length && body.get(\"params\").length) {\n    trackReferencesForBindings(getOrCreateSectionId(body), body);\n  }\n}\nfunction trackReferencesForBindings(sectionId, path3, reserveType = 1 /* Store */) {\n  const scope = path3.scope;\n  const bindings = path3.getBindingIdentifiers();\n  for (const name in bindings) {\n    const references = scope.getBinding(name).referencePaths;\n    const identifier = bindings[name];\n    const binding = reserveScope(reserveType, sectionId, identifier, name);\n    insertReferenceGroup(getReferenceGroups(sectionId), {\n      sectionId,\n      index: 0,\n      count: 0,\n      references: binding,\n      apply: t2.identifier(\"\"),\n      hydrate: t2.identifier(\"\")\n    });\n    for (const reference of references) {\n      const fnRoot = getFnRoot(reference.scope.path);\n      const exprRoot = getExprRoot(fnRoot || reference);\n      const markoRoot = exprRoot.parentPath;\n      if (fnRoot) {\n        const name2 = fnRoot.node.id?.name;\n        if (!name2) {\n          if (markoRoot.isMarkoAttribute() && !markoRoot.node.default) {\n            (fnRoot.node.extra ??= {}).name = markoRoot.node.name;\n          }\n        }\n        updateReferenceGroup(fnRoot, \"references\", binding);\n      }\n      updateReferenceGroup(markoRoot, `${exprRoot.listKey || exprRoot.key}References`, binding);\n    }\n  }\n}\nfunction updateReferenceGroup(path3, extraKey, newBinding) {\n  const sectionId = getOrCreateSectionId(path3);\n  const currentGroup = (path3.node.extra ??= {})[extraKey];\n  const newReferences = insertReserve(currentGroup?.references, newBinding, true);\n  if (currentGroup) {\n    currentGroup.count--;\n  }\n  getOrCreateReferenceGroup(sectionId, newBinding);\n  path3.node.extra[extraKey] = getOrCreateReferenceGroup(sectionId, newReferences);\n}\nfunction mergeReferenceGroups(sectionId, groupEntries) {\n  let newReferences;\n  for (const [extra, key] of groupEntries) {\n    const group = extra[key];\n    const references = group.references;\n    delete extra[key];\n    group.count--;\n    sectionId = group.sectionId;\n    if (references) {\n      if (Array.isArray(references)) {\n        for (const binding of references) {\n          newReferences = insertReserve(newReferences, binding);\n        }\n      } else {\n        newReferences = insertReserve(newReferences, references);\n      }\n    }\n  }\n  return getOrCreateReferenceGroup(sectionId, newReferences);\n}\nfunction getOrCreateReferenceGroup(sectionId, references) {\n  const newGroup = {\n    sectionId,\n    index: 0,\n    count: 1,\n    references,\n    apply: t2.identifier(\"\"),\n    hydrate: t2.identifier(\"\")\n  };\n  const referenceGroups = getReferenceGroups(sectionId);\n  const existingGroup = findReferenceGroup(referenceGroups, newGroup);\n  if (existingGroup) {\n    existingGroup.count++;\n  } else {\n    insertReferenceGroup(referenceGroups, newGroup);\n  }\n  return existingGroup ?? newGroup;\n}\nfunction getExprRoot(path3) {\n  let curPath = path3;\n  while (!isMarkoPath(curPath.parentPath)) {\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction getFnRoot(path3) {\n  let curPath = path3;\n  if (curPath.isProgram())\n    return;\n  while (!isFunctionExpression(curPath)) {\n    if (isMarkoPath(curPath))\n      return;\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction isMarkoPath(path3) {\n  switch (path3.type) {\n    case \"MarkoTag\":\n    case \"MarkoTagBody\":\n    case \"MarkoAttribute\":\n    case \"MarkoSpreadAttribute\":\n    case \"MarkoPlaceholder\":\n    case \"MarkoScriptlet\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isFunctionExpression(path3) {\n  switch (path3.type) {\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\nvar { insert: insertReferenceGroup, find: findReferenceGroup } = createSortedCollection(function compareReferenceGroups({ references: a }, { references: b }) {\n  if (a) {\n    if (b) {\n      if (Array.isArray(a)) {\n        if (Array.isArray(b)) {\n          const len = a.length;\n          const lenDelta = len - b.length;\n          if (lenDelta !== 0) {\n            return lenDelta;\n          }\n          for (let i = 0; i < len; i++) {\n            const compareResult = compareReserves(a[i], b[i]);\n            if (compareResult !== 0) {\n              return compareResult;\n            }\n          }\n          return 0;\n        } else {\n          return 1;\n        }\n      } else if (Array.isArray(b)) {\n        return -1;\n      } else {\n        return compareReserves(a, b);\n      }\n    } else {\n      return 1;\n    }\n  } else {\n    return b ? -1 : 0;\n  }\n});\nfunction finalizeReferences() {\n  const allReferenceGroups = [];\n  forEachSectionId((sectionId) => {\n    const referenceGroups = getReferenceGroups(sectionId).filter((g) => g.count > 0 || !Array.isArray(g.references));\n    referenceGroups.forEach((g, i) => {\n      g.index = i;\n      g.apply.name = generateReferenceGroupName(\"apply\", sectionId, g.references);\n      g.hydrate.name = generateReferenceGroupName(\"hydrate\", sectionId, g.references);\n    });\n    allReferenceGroups[sectionId] = referenceGroups;\n  });\n  (currentProgramPath.node.extra ??= {}).referenceGroups = allReferenceGroups;\n}\nfunction getReferenceGroup(sectionId, lookup, analyze2 = false) {\n  const referenceGroups = analyze2 ? getReferenceGroups(sectionId) : currentProgramPath.node.extra.referenceGroups[sectionId];\n  let found;\n  if (typeof lookup === \"number\") {\n    found = referenceGroups[lookup];\n  } else {\n    found = findReferenceGroup(referenceGroups, {\n      references: lookup\n    });\n  }\n  if (!found) {\n    throw new Error(`Reference group not found for section ${sectionId}: ${lookup}`);\n  }\n  return found;\n}\nfunction generateReferenceGroupName(type, sectionId, references) {\n  let name = type + (sectionId ? currentProgramPath.node.extra.sectionNames[sectionId].replace(\"_\", \"$\") : \"\");\n  if (references) {\n    if (Array.isArray(references)) {\n      name += \"With\";\n      for (const ref of references) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name += `_${references.name}`;\n    }\n  }\n  return currentProgramPath.scope.generateUid(name);\n}\n\n// src/util/runtime.ts\nimport { types as t3 } from \"@marko/compiler\";\nimport { importNamed } from \"@marko/babel-utils\";\nfunction importRuntime(name) {\n  const { output } = getMarkoOpts();\n  return importNamed(currentProgramPath.hub.file, getRuntimePath(output), name);\n}\nfunction callRuntime(name, ...args) {\n  return t3.callExpression(importRuntime(name), args.filter(Boolean));\n}\nfunction getHTMLRuntime() {\n  return getRuntime(\"html\");\n}\nfunction getRuntime(output) {\n  return __require(getRuntimePath(output));\n}\nfunction getRuntimePath(output) {\n  const { optimize } = getMarkoOpts();\n  return `@marko/runtime-fluurt/${false ? \"src\" : optimize ? \"dist\" : \"dist/debug\"}/${output === \"html\" ? \"html\" : \"dom\"}`;\n}\nfunction callRead(reference, targetSectionId) {\n  return t3.memberExpression(getScopeExpression(reference, targetSectionId), t3.numericLiteral(reference.id), true);\n}\nfunction callQueue({ apply, index }, reference, value, targetSectionId) {\n  return callRuntime(\"queue\", getScopeExpression(reference, targetSectionId), apply, t3.numericLiteral(index - 1), value);\n}\nfunction getScopeExpression(reference, sectionId) {\n  const diff = reference.sectionId !== sectionId ? 1 : 0;\n  let scope = scopeIdentifier;\n  for (let i = 0; i < diff; i++) {\n    scope = t3.memberExpression(scope, t3.identifier(\"_\"));\n  }\n  return scope;\n}\n\n// src/util/apply-hydrate.ts\nimport { getTemplateId } from \"@marko/babel-utils\";\nvar [getApplyStatements] = createSectionState(\"applyStatements\", () => []);\nvar [getHydrateStatements] = createSectionState(\"hydrateStatements\", () => []);\nvar [getQueueBuilder, _setQueueBuilder] = createSectionState(\"queue\");\nfunction setQueueBuilder(tag, builder) {\n  _setQueueBuilder(getSectionId(tag.get(\"body\")), builder);\n}\nfunction addStatement(type, targetSectionId, references, statement) {\n  const statementsIndex = references?.index ?? 0;\n  const allStatements = type === \"apply\" ? getApplyStatements(targetSectionId) : getHydrateStatements(targetSectionId);\n  const statements = allStatements[statementsIndex] ??= [];\n  if (Array.isArray(statement)) {\n    statements.push(...statement);\n  } else {\n    statements.push(statement);\n  }\n}\nfunction getHydrateRegisterId(sectionId, references) {\n  const {\n    markoOpts: { optimize },\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let name = \"\";\n  if (references) {\n    if (Array.isArray(references)) {\n      for (const ref of references) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name += `_${references.name}`;\n    }\n  }\n  return getTemplateId(optimize, `${filename}_${sectionId}${name}`);\n}\nfunction writeAllStatementGroups() {\n  forEachSectionIdReverse((sectionId) => {\n    writeHydrateGroups(sectionId);\n    writeApplyGroups(sectionId);\n  });\n}\nvar [getClosurePriorities] = createSectionState(\"closurePriorities\", () => []);\nfunction writeApplyGroups(sectionId) {\n  const allStatements = getApplyStatements(sectionId);\n  const numReferenceGroups = currentProgramPath.node.extra.referenceGroups[sectionId].length;\n  if (!numReferenceGroups)\n    return;\n  for (let i = numReferenceGroups; i--; ) {\n    const statements = allStatements[i] ?? [];\n    if (i === 0 && !statements.length)\n      continue;\n    const referenceGroup = getReferenceGroup(sectionId, i);\n    const { references, apply: identifier } = referenceGroup;\n    const queuePriority = t4.numericLiteral(i - 1);\n    let params;\n    let body;\n    if (references) {\n      if (Array.isArray(references)) {\n        params = references.map((binding) => t4.assignmentPattern(t4.identifier(binding.name), callRead(binding, sectionId)));\n        body = t4.blockStatement(statements);\n        for (const binding of references) {\n          addStatement(\"apply\", sectionId, getReferenceGroup(sectionId, binding), t4.expressionStatement(callRuntime(\"queue\", scopeIdentifier, identifier, queuePriority)));\n        }\n      } else if (references.sectionId !== sectionId) {\n        params = [\n          t4.assignmentPattern(t4.identifier(references.name), callRead(references, sectionId))\n        ];\n        body = t4.blockStatement(statements);\n        const factory = getQueueBuilder(sectionId);\n        if (factory) {\n          const closurePriority = t4.numericLiteral(NaN);\n          getClosurePriorities(references.sectionId).push(closurePriority);\n          addStatement(\"apply\", references.sectionId, getReferenceGroup(references.sectionId, references), t4.expressionStatement(factory(referenceGroup, closurePriority)));\n          addStatement(\"apply\", sectionId, void 0, t4.expressionStatement(callRuntime(\"queue\", scopeIdentifier, identifier, queuePriority)));\n        }\n      } else {\n        const param = t4.identifier(references.name);\n        params = [param];\n        body = t4.blockStatement([\n          t4.ifStatement(callRuntime(\"write\", scopeIdentifier, t4.numericLiteral(references.id), param), t4.blockStatement(statements))\n        ]);\n      }\n    } else {\n      params = [];\n      body = t4.blockStatement(statements);\n    }\n    const [fnPath] = currentProgramPath.pushContainer(\"body\", t4.functionDeclaration(identifier, [scopeIdentifier, ...params], body));\n    fnPath.traverse(bindFunctionsVisitor, { root: fnPath, sectionId });\n  }\n  const closurePriorities = getClosurePriorities(sectionId);\n  for (let i = 0; i < closurePriorities.length; i++) {\n    closurePriorities[i].value = i + allStatements.length;\n  }\n}\nfunction writeHydrateGroups(sectionId) {\n  const allStatements = getHydrateStatements(sectionId);\n  for (let i = allStatements.length; i--; ) {\n    const statements = allStatements[i];\n    if (!statements?.length)\n      continue;\n    const referenceGroup = getReferenceGroup(sectionId, i);\n    const { references, hydrate: identifier } = referenceGroup;\n    const params = references ? (Array.isArray(references) ? references : [references]).map((binding) => t4.assignmentPattern(t4.identifier(binding.name), callRead(binding, sectionId))) : [];\n    const [fnPath] = currentProgramPath.pushContainer(\"body\", [\n      t4.functionDeclaration(identifier, [scopeIdentifier, ...params], t4.blockStatement(statements)),\n      t4.expressionStatement(callRuntime(\"register\", t4.stringLiteral(getHydrateRegisterId(sectionId, references)), identifier))\n    ]);\n    fnPath.traverse(bindFunctionsVisitor, { root: fnPath, sectionId });\n    addStatement(\"apply\", sectionId, getReferenceGroup(sectionId, references), t4.expressionStatement(callRuntime(\"queueHydrate\", scopeIdentifier, identifier)));\n  }\n}\nfunction addHTMLHydrateCall(sectionId, references) {\n  addStatement(\"hydrate\", sectionId, references, void 0);\n}\nfunction writeHTMLHydrateStatements(path3) {\n  const sectionId = getOrCreateSectionId(path3);\n  const allStatements = getHydrateStatements(sectionId);\n  path3.unshiftContainer(\"body\", t4.variableDeclaration(\"const\", [\n    t4.variableDeclarator(scopeIdentifier, callRuntime(\"nextScopeId\"))\n  ]));\n  if (!allStatements.length)\n    return;\n  const refs = [];\n  for (let i = allStatements.length; i--; ) {\n    if (allStatements[i]?.length) {\n      const { references } = getReferenceGroup(sectionId, i);\n      if (references) {\n        if (Array.isArray(references)) {\n          for (const ref of references) {\n            insertReserve(refs, ref);\n          }\n        } else {\n          insertReserve(refs, references);\n        }\n      }\n      path3.pushContainer(\"body\", t4.expressionStatement(callRuntime(\"writeHydrateCall\", scopeIdentifier, t4.stringLiteral(getHydrateRegisterId(sectionId, references)))));\n    }\n  }\n  path3.pushContainer(\"body\", t4.expressionStatement(callRuntime(\"writeHydrateScope\", scopeIdentifier, t4.objectExpression(refs.reduce((acc, ref) => {\n    acc.push(t4.objectProperty(t4.numericLiteral(ref.id), t4.identifier(ref.name)));\n    return acc;\n  }, [])))));\n}\nvar bindFunctionsVisitor = {\n  FunctionExpression: { exit: bindFunction },\n  ArrowFunctionExpression: { exit: bindFunction }\n};\nfunction bindFunction(fn, { root, sectionId }) {\n  const { node } = fn;\n  const { extra } = node;\n  const references = extra?.references?.references;\n  const program = fn.hub.file.path;\n  const functionIdentifier = program.scope.generateUidIdentifier(extra?.name);\n  if (references) {\n    if (node.body.type !== \"BlockStatement\") {\n      node.body = t4.blockStatement([t4.returnStatement(node.body)]);\n    }\n    node.body.body.unshift(t4.variableDeclaration(\"const\", (Array.isArray(references) ? references : [references]).map((binding) => t4.variableDeclarator(t4.identifier(binding.name), callRead(binding, sectionId)))));\n  }\n  root.insertBefore(t4.variableDeclaration(\"const\", [\n    t4.variableDeclarator(functionIdentifier, node)\n  ]));\n  node.params.unshift(scopeIdentifier);\n  fn.replaceWith(callRuntime(\"bind\", scopeIdentifier, functionIdentifier));\n}\nfunction getDefaultApply(sectionId) {\n  const [firstApplyStatements] = getApplyStatements(sectionId);\n  return firstApplyStatements ? getReferenceGroup(sectionId, 0).apply : t4.nullLiteral();\n}\n\n// src/util/writer.ts\nimport { types as t7 } from \"@marko/compiler\";\n\n// src/util/to-template-string-or-literal.ts\nimport { types as t5 } from \"@marko/compiler\";\nfunction toTemplateOrStringLiteral(parts) {\n  const strs = [];\n  const exprs = [];\n  let curStr = parts[0];\n  for (let i = 1; i < parts.length; i++) {\n    let content = parts[i];\n    if (typeof content === \"object\") {\n      if (t5.isStringLiteral(content)) {\n        content = content.value;\n      } else if (t5.isTemplateLiteral(content)) {\n        let nextIndex = i + 1;\n        const exprLen = content.expressions.length;\n        shiftItems(parts, nextIndex, content.quasis.length + exprLen);\n        for (let j = 0; j < exprLen; j++) {\n          parts[nextIndex++] = content.quasis[j].value.raw;\n          parts[nextIndex++] = content.expressions[j];\n        }\n        parts[nextIndex] = content.quasis[exprLen].value.raw;\n        continue;\n      } else {\n        exprs.push(content);\n        strs.push(curStr);\n        curStr = \"\";\n        continue;\n      }\n    }\n    curStr += content;\n  }\n  if (exprs.length) {\n    strs.push(curStr);\n    return t5.templateLiteral(strs.map((raw) => t5.templateElement({ raw })), exprs);\n  } else if (curStr) {\n    return t5.stringLiteral(curStr);\n  }\n}\nfunction appendLiteral(arr, str) {\n  arr[arr.length - 1] += str;\n}\nfunction shiftItems(list, start, offset) {\n  for (let i = list.length - 1; i >= start; i--) {\n    list[i + offset] = list[i];\n  }\n}\n\n// src/util/walks.ts\nimport { types as t6 } from \"@marko/compiler\";\nvar [getWalks] = createSectionState(\"walks\", () => [\"\"]);\nvar [getWalkComment] = createSectionState(\"walkComment\", () => []);\nvar [getSteps] = createSectionState(\"steps\", () => []);\nvar walkCodeToName = {\n  [32 /* Get */]: \"get\",\n  [33 /* Before */]: \"before\",\n  [35 /* After */]: \"after\",\n  [36 /* Inside */]: \"inside\",\n  [37 /* Replace */]: \"replace\",\n  [38 /* EndChild */]: \"endChild\",\n  [40 /* Skip */]: \"skip\",\n  [47 /* BeginChild */]: \"beginChild\",\n  [67 /* Next */]: \"next\",\n  [97 /* Over */]: \"over\",\n  [107 /* Out */]: \"out\",\n  [117 /* Multiplier */]: \"multiplier\",\n  [46 /* SkipEnd */]: \"skipEnd\",\n  [66 /* BeginChildEnd */]: \"beginChildEnd\",\n  [91 /* NextEnd */]: \"nextEnd\",\n  [106 /* OverEnd */]: \"overEnd\",\n  [116 /* OutEnd */]: \"outEnd\",\n  [126 /* MultiplierEnd */]: \"multiplierEnd\"\n};\nfunction enter(path3) {\n  getSteps(getSectionId(path3)).push(0 /* enter */);\n}\nfunction exit(path3) {\n  getSteps(getSectionId(path3)).push(1 /* exit */);\n}\nfunction enterShallow(path3) {\n  getSteps(getSectionId(path3)).push(0 /* enter */, 1 /* exit */);\n}\nfunction injectWalks(path3, childIndex, expr) {\n  const walks = getWalks(getSectionId(path3));\n  const walkComment = getWalkComment(getSectionId(path3));\n  walkComment.push(`${walkCodeToName[47 /* BeginChild */]}(${childIndex})`, expr.name, walkCodeToName[38 /* EndChild */]);\n  appendLiteral(walks, nCodeString(47 /* BeginChild */, childIndex));\n  walks.push(expr, String.fromCharCode(38 /* EndChild */));\n}\nfunction visit(path3, code) {\n  const { reserve } = path3.node.extra;\n  if (code && (!reserve || reserve.type !== 0 /* Visit */)) {\n    throw path3.buildCodeFrameError(\"Tried to visit a node that was not marked as needing to visit during analyze.\");\n  }\n  const sectionId = getSectionId(path3);\n  const steps = getSteps(sectionId);\n  const walks = getWalks(sectionId);\n  const walkComment = getWalkComment(sectionId);\n  if (code && isOutputHTML()) {\n    writeTo(path3)`${callRuntime(\"markHydrateNode\", scopeIdentifier, t6.numericLiteral(reserve.id))}`;\n  } else {\n    let walkString = \"\";\n    if (steps.length) {\n      const walks2 = [];\n      let depth = 0;\n      for (const step of steps) {\n        if (step === 0 /* enter */) {\n          depth++;\n          walks2.push(67 /* Next */);\n        } else {\n          depth--;\n          if (depth >= 0) {\n            walks2.length = walks2.lastIndexOf(67 /* Next */);\n            walks2.push(97 /* Over */);\n          } else {\n            walks2.length = walks2.lastIndexOf(107 /* Out */) + 1;\n            walks2.push(107 /* Out */);\n            depth = 0;\n          }\n        }\n      }\n      let current = walks2[0];\n      let count = 0;\n      for (const walk of walks2) {\n        if (walk !== current) {\n          walkComment.push(`${walkCodeToName[current]}(${count})`);\n          walkString += nCodeString(current, count);\n          current = walk;\n          count = 1;\n        } else {\n          count++;\n        }\n      }\n      walkComment.push(`${walkCodeToName[current]}(${count})`);\n      walkString += nCodeString(current, count);\n      steps.length = 0;\n    }\n    if (code !== void 0) {\n      if (code !== 32 /* Get */) {\n        writeTo(path3)`<!>`;\n      }\n      walkComment.push(`${walkCodeToName[code]}`);\n      walkString += String.fromCharCode(code);\n    }\n    if (reserve?.size) {\n      walkComment.push(`${walkCodeToName[40 /* Skip */]}(${reserve.size})`);\n      walkString += nCodeString(40 /* Skip */, reserve.size);\n    }\n    appendLiteral(walks, walkString);\n  }\n}\nfunction nCodeString(code, number) {\n  switch (code) {\n    case 67 /* Next */:\n      return toCharString(number, code, 20 /* Next */);\n    case 97 /* Over */:\n      return toCharString(number, code, 10 /* Over */);\n    case 107 /* Out */:\n      return toCharString(number, code, 10 /* Out */);\n    case 47 /* BeginChild */:\n      return toCharString(number, code, 20 /* BeginChild */);\n    case 40 /* Skip */:\n      return toCharString(number, code, 7 /* Skip */);\n    default:\n      throw new Error(`Unexpected walk code: ${code}`);\n  }\n}\nfunction toCharString(number, startCode, rangeSize) {\n  let result = \"\";\n  if (number >= rangeSize) {\n    const multiplier = Math.floor(number / rangeSize);\n    result += toCharString(multiplier, 117 /* Multiplier */, 10 /* Multiplier */);\n    number -= multiplier * rangeSize;\n  }\n  result += String.fromCharCode(startCode + number);\n  return result;\n}\nfunction getWalkString(sectionId) {\n  const walkLiteral = toTemplateOrStringLiteral(getWalks(sectionId)) || t6.stringLiteral(\"\");\n  if (walkLiteral.value !== \"\") {\n    walkLiteral.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: \" \" + getWalkComment(sectionId).join(\", \") + \" \"\n      }\n    ];\n  }\n  return walkLiteral;\n}\n\n// src/util/writer.ts\nvar [getRenderer] = createSectionState(\"renderer\", (sectionId) => {\n  const name = currentProgramPath.node.extra.sectionNames[sectionId];\n  return t7.identifier(name);\n});\nvar [getWrites] = createSectionState(\"writes\", () => [\"\"]);\nfunction writeTo(path3) {\n  const sectionId = getSectionId(path3);\n  return (strs, ...exprs) => {\n    const exprsLen = exprs.length;\n    const writes = getWrites(sectionId);\n    appendLiteral(writes, strs[0]);\n    for (let i = 0; i < exprsLen; i++) {\n      writes.push(exprs[i], strs[i + 1]);\n    }\n  };\n}\nfunction consumeHTML(path3) {\n  const writes = getWrites(getSectionId(path3));\n  const result = toTemplateOrStringLiteral(writes);\n  writes.length = 0;\n  writes[0] = \"\";\n  if (result) {\n    return t7.expressionStatement(callRuntime(\"write\", result));\n  }\n}\nfunction hasPendingHTML(path3) {\n  const writes = getWrites(getSectionId(path3));\n  return Boolean(writes.length > 1 || writes[0]);\n}\nfunction flushBefore(path3) {\n  const expr = consumeHTML(path3);\n  if (expr) {\n    path3.insertBefore(expr)[0].skip();\n  }\n}\nfunction flushInto(path3) {\n  const target = path3.isProgram() ? path3 : path3.get(\"body\");\n  const expr = consumeHTML(target);\n  if (expr) {\n    target.pushContainer(\"body\", expr)[0].skip();\n  }\n}\nfunction getSectionMeta(sectionId) {\n  const writes = getWrites(sectionId);\n  return {\n    apply: getDefaultApply(sectionId),\n    walks: getWalkString(sectionId),\n    writes: toTemplateOrStringLiteral(writes) || t7.stringLiteral(\"\")\n  };\n}\n\n// src/util/is-static.ts\nfunction isStatic(path3) {\n  return path3.isImportDeclaration() || path3.isExportDeclaration() || path3.isMarkoScriptlet({ static: true });\n}\n\n// src/visitors/program/html.ts\nvar html_default = {\n  translate: {\n    exit(program) {\n      flushInto(program);\n      writeHTMLHydrateStatements(program);\n      const renderContent = [];\n      for (const child of program.get(\"body\")) {\n        if (!isStatic(child)) {\n          renderContent.push(child.node);\n          child.remove();\n        } else if (child.isMarkoScriptlet()) {\n          child.replaceWithMultiple(child.node.body);\n        }\n      }\n      const rendererId = program.scope.generateUidIdentifier(\"renderer\");\n      const { attrs } = program.node.extra;\n      program.pushContainer(\"body\", [\n        t8.variableDeclaration(\"const\", [\n          t8.variableDeclarator(rendererId, t8.arrowFunctionExpression([attrs ? attrs.var : t8.identifier(\"input\")], t8.blockStatement(renderContent)))\n        ]),\n        t8.exportDefaultDeclaration(rendererId),\n        t8.exportNamedDeclaration(t8.variableDeclaration(\"const\", [\n          t8.variableDeclarator(t8.identifier(\"render\"), callRuntime(\"createRenderer\", rendererId))\n        ]))\n      ]);\n    }\n  }\n};\n\n// src/visitors/program/dom.ts\nimport { types as t9 } from \"@marko/compiler\";\nvar dom_default = {\n  translate: {\n    exit(program) {\n      visit(program);\n      const sectionId = getSectionId(program);\n      const templateIdentifier = t9.identifier(\"template\");\n      const walksIdentifier = t9.identifier(\"walks\");\n      const applyIdentifier = t9.identifier(\"apply\");\n      const applyAttrsIdentifier = t9.identifier(\"applyAttrs\");\n      const { attrs } = program.node.extra;\n      const { walks, writes, apply } = getSectionMeta(sectionId);\n      writeAllStatementGroups();\n      const childRendererDeclarators = [];\n      forEachSectionId((childSectionId) => {\n        if (childSectionId !== sectionId) {\n          const { walks: walks2, writes: writes2, apply: apply2 } = getSectionMeta(childSectionId);\n          const identifier = getRenderer(childSectionId);\n          childRendererDeclarators.push(t9.variableDeclarator(identifier, callRuntime(\"createRenderer\", writes2, walks2, apply2)));\n        }\n      });\n      if (attrs) {\n        const exportSpecifiers = [];\n        program.node.body.push(t9.exportNamedDeclaration(t9.variableDeclaration(\"const\", [\n          t9.variableDeclarator(applyAttrsIdentifier, t9.functionExpression(null, [scopeIdentifier, attrs.var], t9.blockStatement(Object.keys(attrs.bindings).map((name) => {\n            const bindingIdentifier = attrs.bindings[name];\n            const { apply: applyIdentifier2 } = getReferenceGroup(sectionId, bindingIdentifier.extra.reserve);\n            exportSpecifiers.push(t9.exportSpecifier(applyIdentifier2, bindingIdentifier.extra.reserve.exportIdentifier));\n            return t9.expressionStatement(t9.callExpression(applyIdentifier2, [\n              scopeIdentifier,\n              bindingIdentifier\n            ]));\n          }))))\n        ])), t9.exportNamedDeclaration(null, exportSpecifiers));\n      }\n      program.node.body.push(t9.exportNamedDeclaration(t9.variableDeclaration(\"const\", [\n        t9.variableDeclarator(templateIdentifier, writes || t9.stringLiteral(\"\"))\n      ])), t9.exportNamedDeclaration(t9.variableDeclaration(\"const\", [\n        t9.variableDeclarator(walksIdentifier, walks || t9.stringLiteral(\"\"))\n      ])), t9.exportNamedDeclaration(t9.variableDeclaration(\"const\", [\n        t9.variableDeclarator(applyIdentifier, t9.isNullLiteral(apply) ? t9.functionExpression(null, [], t9.blockStatement([])) : apply)\n      ])));\n      if (childRendererDeclarators.length) {\n        program.node.body.push(t9.variableDeclaration(\"const\", childRendererDeclarators));\n      }\n      program.node.body.push(t9.exportDefaultDeclaration(callRuntime(\"createRenderFn\", templateIdentifier, walksIdentifier, applyIdentifier, attrs && applyAttrsIdentifier)));\n    }\n  }\n};\n\n// src/visitors/program/index.ts\nvar currentProgramPath;\nvar scopeIdentifier;\nvar previousProgramPath = /* @__PURE__ */ new WeakMap();\nvar program_default = {\n  migrate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n    },\n    exit() {\n      currentProgramPath.scope.crawl();\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  analyze: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      startSection(program);\n    },\n    exit() {\n      assignFinalIds();\n      finalizeReferences();\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  translate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      scopeIdentifier = program.scope.generateUidIdentifier(\"scope\");\n      if (getMarkoOpts().output === \"hydrate\") {\n        program.skip();\n        program.node.body = [\n          t10.importDeclaration([], t10.stringLiteral(program.hub.file.opts.filename))\n        ];\n        if (program.node.extra.hasInteractiveChild || program.node.extra.isInteractive) {\n          program.node.body.push(t10.expressionStatement(callRuntime(\"init\")));\n        }\n        return;\n      }\n    },\n    exit(program) {\n      if (isOutputHTML()) {\n        html_default.translate.exit(program);\n      } else {\n        dom_default.translate.exit(program);\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  }\n};\n\n// src/visitors/import-declaration.ts\nimport { resolveTagImport } from \"@marko/babel-utils\";\nvar import_declaration_default = {\n  translate: {\n    exit(path3) {\n      const source = path3.get(\"source\");\n      const request = source.node.value;\n      source.node.value = resolveTagImport(source, request) || request;\n    }\n  }\n};\n\n// src/visitors/document-type.ts\nvar document_type_default = {\n  translate(documentType) {\n    if (isOutputHTML()) {\n      writeTo(documentType)`<!${documentType.node.value}>`;\n    }\n    documentType.remove();\n  }\n};\n\n// src/visitors/declaration.ts\nvar declaration_default = {\n  translate(declaration) {\n    if (isOutputHTML()) {\n      writeTo(declaration)`<?${declaration.node.value}?>`;\n    }\n    declaration.remove();\n  }\n};\n\n// src/visitors/cdata.ts\nvar cdata_default = {\n  translate(cdata) {\n    if (isOutputHTML()) {\n      writeTo(cdata)`<![CDATA[${cdata.node.value}]]>`;\n    }\n    cdata.remove();\n  }\n};\n\n// src/visitors/text.ts\nvar text_default = {\n  translate(text) {\n    writeTo(text)`${text.node.value}`;\n    enterShallow(text);\n    text.remove();\n  }\n};\n\n// src/visitors/tag/index.ts\nimport { types as t20 } from \"@marko/compiler\";\nimport {\n  assertNoArgs,\n  getTagDef as getTagDef3,\n  isNativeTag as isNativeTag2\n} from \"@marko/babel-utils\";\n\n// src/util/plugin-hooks.ts\nimport { types as t11 } from \"@marko/compiler\";\nfunction enter2(modulePlugin, path3) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path3;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (isFunctionPlugin(plugin)) {\n    plugin(path3, t11);\n  } else if (plugin.enter) {\n    plugin.enter(path3, t11);\n  }\n  return node !== path3.node;\n}\nfunction exit2(modulePlugin, path3) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path3;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (!isFunctionPlugin(plugin) && plugin.exit) {\n    plugin.exit(path3, t11);\n  }\n  return node !== path3.node;\n}\nfunction isModulePlugin(plugin) {\n  return Boolean(plugin.default);\n}\nfunction isFunctionPlugin(plugin) {\n  return typeof plugin === \"function\";\n}\n\n// src/visitors/tag/native-tag.ts\nimport { types as t15 } from \"@marko/compiler\";\nimport { getTagDef } from \"@marko/babel-utils\";\n\n// src/util/attrs-to-object.ts\nimport { types as t13 } from \"@marko/compiler\";\n\n// src/util/to-property-name.ts\nimport { types as t12 } from \"@marko/compiler\";\nvar IDENTIFIER_REG = /^[0-9A-Z_$]+$/i;\nfunction toPropertyName(name) {\n  return IDENTIFIER_REG.test(name) ? t12.identifier(name) : t12.stringLiteral(name);\n}\n\n// src/util/attrs-to-object.ts\nfunction attrsToObject(tag, withRenderBody = false) {\n  const { node } = tag;\n  let result = t13.objectExpression([]);\n  const resultExtra = result.extra = {};\n  for (const attr of node.attributes) {\n    const value = attr.value;\n    if (t13.isMarkoSpreadAttribute(attr)) {\n      result.properties.push(t13.spreadElement(value));\n    } else {\n      result.properties.push(t13.objectProperty(toPropertyName(attr.name), value));\n    }\n  }\n  if (withRenderBody) {\n    const { body, params } = node.body;\n    let hoistedControlFlows = node.extra.hoistedControlFlows;\n    if (hoistedControlFlows) {\n      for (const child of tag.get(\"body\").get(\"body\")) {\n        tag.insertBefore(child.node);\n        child.remove();\n        if (child.isConditional() || child.isLoop()) {\n          if (!--hoistedControlFlows) {\n            break;\n          }\n        }\n      }\n    }\n    if (body.length) {\n      result.properties.push(t13.objectMethod(\"method\", t13.identifier(\"renderBody\"), params, t13.blockStatement(body)));\n    }\n  }\n  if (result.properties.length) {\n    if (result.properties.length === 1) {\n      const [prop] = result.properties;\n      if (t13.isSpreadElement(prop)) {\n        result = prop.argument;\n        result.extra = resultExtra;\n      }\n    }\n    return result;\n  }\n}\nfunction getRenderBodyProp(attrsObject) {\n  if (t13.isObjectExpression(attrsObject)) {\n    const lastProp = attrsObject.properties[attrsObject.properties.length - 1];\n    if (t13.isObjectMethod(lastProp) && lastProp.key.name === \"renderBody\") {\n      return lastProp;\n    }\n  }\n}\n\n// src/util/translate-var.ts\nimport { types as t14 } from \"@marko/compiler\";\nfunction translateVar(tag, initialValue, kind = \"const\") {\n  const {\n    node: { var: tagVar }\n  } = tag;\n  if (!tagVar) {\n    return;\n  }\n  tag.get(\"var\").remove();\n  tag.insertBefore(t14.variableDeclaration(kind, [\n    t14.variableDeclarator(t14.cloneDeep(tagVar), initialValue)\n  ]));\n  tag.hub.file.path.scope.crawl();\n}\n\n// src/util/evaluate.ts\nfunction evaluate(path3) {\n  let { extra } = path3.node;\n  if (!extra) {\n    extra = path3.node.extra = {};\n  }\n  if (extra.confident === void 0) {\n    const value = path3.get(\"value\");\n    const { confident, value: computed } = value.evaluate();\n    extra.computed = computed;\n    extra.confident = confident;\n  }\n  return extra;\n}\n\n// src/visitors/tag/native-tag.ts\nvar native_tag_default = {\n  analyze: {\n    enter(tag) {\n      const { node } = tag;\n      const attrs = tag.get(\"attributes\");\n      let sectionId = tag.has(\"var\") ? getOrCreateSectionId(tag) : void 0;\n      if (attrs.some(isSpreadAttr)) {\n      } else {\n        for (const attr of attrs) {\n          const attrNode = attr.node;\n          const { name } = attrNode;\n          if (name.startsWith(\"on\")) {\n            sectionId ??= getOrCreateSectionId(tag);\n            (currentProgramPath.node.extra ?? {}).isInteractive = true;\n          } else if (!evaluate(attr).confident) {\n            sectionId ??= getOrCreateSectionId(tag);\n          }\n        }\n      }\n      if (sectionId !== void 0) {\n        reserveScope(0 /* Visit */, sectionId, node, node.name.value);\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { extra } = tag.node;\n      const isHTML = isOutputHTML();\n      const name = tag.get(\"name\");\n      const attrs = tag.get(\"attributes\");\n      const tagDef = getTagDef(tag);\n      const hasSpread = attrs.some((attr) => attr.isMarkoSpreadAttribute());\n      const write = writeTo(tag);\n      const sectionId = getSectionId(tag);\n      if (isHTML) {\n        if (extra.tagNameNullable) {\n          flushBefore(tag);\n        }\n        translateVar(tag, t15.unaryExpression(\"void\", t15.numericLiteral(0)));\n      }\n      let visitIndex;\n      if (extra.reserve) {\n        visitIndex = t15.numericLiteral(extra.reserve.id);\n        visit(tag, 32 /* Get */);\n      }\n      write`<${name.node}`;\n      if (hasSpread) {\n        const attrsCallExpr = callRuntime(\"attrs\", scopeIdentifier, attrsToObject(tag));\n        if (isHTML) {\n          write`${attrsCallExpr}`;\n        } else {\n          tag.insertBefore(t15.expressionStatement(attrsCallExpr));\n        }\n      } else {\n        for (const attr of attrs) {\n          const name2 = attr.node.name;\n          const extra2 = attr.node.extra ?? {};\n          const value = attr.get(\"value\");\n          const { confident, computed, valueReferences } = extra2;\n          switch (name2) {\n            case \"class\":\n            case \"style\": {\n              const helper = `${name2}Attr`;\n              if (confident) {\n                write`${getHTMLRuntime()[helper](computed)}`;\n              } else if (isHTML) {\n                write`${callRuntime(helper, value.node)}`;\n              } else {\n                addStatement(\"apply\", sectionId, valueReferences, t15.expressionStatement(callRuntime(helper, t15.memberExpression(scopeIdentifier, visitIndex, true), value.node)));\n              }\n              break;\n            }\n            default:\n              if (confident) {\n                write`${getHTMLRuntime().attr(name2, computed)}`;\n              } else if (isHTML) {\n                if (name2.startsWith(\"on\")) {\n                  addHTMLHydrateCall(sectionId, extra2.valueReferences);\n                } else {\n                  write`${callRuntime(\"attr\", t15.stringLiteral(name2), value.node)}`;\n                }\n              } else if (name2.startsWith(\"on\")) {\n                addStatement(\"hydrate\", sectionId, extra2.valueReferences, t15.expressionStatement(callRuntime(\"on\", t15.memberExpression(scopeIdentifier, visitIndex, true), t15.stringLiteral(name2.slice(2)), value.node)));\n              } else {\n                addStatement(\"apply\", sectionId, valueReferences, t15.expressionStatement(callRuntime(\"attr\", t15.memberExpression(scopeIdentifier, visitIndex, true), t15.stringLiteral(name2), value.node)));\n              }\n              break;\n          }\n        }\n      }\n      let emptyBody = false;\n      if (tagDef && tagDef.parseOptions?.openTagOnly) {\n        switch (tagDef.htmlType) {\n          case \"svg\":\n          case \"math\":\n            write`/>`;\n            break;\n          default:\n            write`>`;\n            break;\n        }\n        emptyBody = true;\n      } else if (tag.node.body.body.length) {\n        write`>`;\n      } else {\n        write`></${name.node}>`;\n        emptyBody = true;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(t15.ifStatement(name.node, consumeHTML(tag)))[0].skip();\n      }\n      if (emptyBody) {\n        enterShallow(tag);\n        tag.remove();\n      } else {\n        enter(tag);\n      }\n    },\n    exit(tag) {\n      const { extra } = tag.node;\n      const isHTML = isOutputHTML();\n      if (isHTML && extra.tagNameNullable) {\n        flushInto(tag);\n      }\n      tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n      writeTo(tag)`</${tag.node.name}>`;\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(t15.ifStatement(tag.node.name, consumeHTML(tag)))[0].skip();\n      }\n      exit(tag);\n      tag.remove();\n    }\n  }\n};\nfunction isSpreadAttr(attr) {\n  return attr.type === \"MarkoSpreadAttribute\";\n}\n\n// src/visitors/tag/custom-tag.ts\nimport { types as t16 } from \"@marko/compiler\";\nimport {\n  getTagDef as getTagDef2,\n  importNamed as importNamed2,\n  importDefault,\n  resolveRelativePath,\n  loadFileForTag\n} from \"@marko/babel-utils\";\nvar custom_tag_default = {\n  analyze: {\n    enter(tag) {\n      trackReferences(tag);\n      const body = tag.get(\"body\");\n      if (body.get(\"body\").length) {\n        startSection(body);\n      }\n      if (getTagDef2(tag)?.template) {\n        reserveScope(1 /* Store */, getOrCreateSectionId(tag), tag.node, \"child\");\n      }\n      const childFile = loadFileForTag(tag);\n      const childProgramExtra = childFile?.ast.program.extra;\n      const hasInteractiveChild = childProgramExtra?.isInteractive || childProgramExtra?.hasInteractiveChild;\n      if (hasInteractiveChild) {\n        (currentProgramPath.node.extra ?? {}).hasInteractiveChild = true;\n      }\n    },\n    exit(tag) {\n      const tagDef = getTagDef2(tag);\n      const template = tagDef?.template;\n      const sectionId = getOrCreateSectionId(tag);\n      if (template) {\n        tag.node.extra.attrsReferences = mergeReferenceGroups(sectionId, tag.node.attributes.filter((attr) => attr.extra?.valueReferences).map((attr) => [attr.extra, \"valueReferences\"]));\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const tagSectionId = getSectionId(tag);\n      const tagBody = tag.get(\"body\");\n      const tagBodySectionId = getSectionId(tagBody);\n      const isHTML = isOutputHTML();\n      const { node } = tag;\n      const write = writeTo(tag);\n      const binding = node.extra.reserve;\n      let tagIdentifier;\n      let tagAttrsIdentifier;\n      if (isHTML) {\n        flushInto(tag);\n        writeHTMLHydrateStatements(tagBody);\n      }\n      if (t16.isStringLiteral(node.name)) {\n        const { file } = tag.hub;\n        const tagName = node.name.value;\n        const tags = file.metadata.marko.tags;\n        const tagDef = getTagDef2(tag);\n        const template = tagDef?.template;\n        const relativePath = template && resolveRelativePath(file, template);\n        const childFile = loadFileForTag(tag);\n        const childProgram = childFile.ast.program;\n        if (!relativePath) {\n          throw tag.get(\"name\").buildCodeFrameError(`Unable to find entry point for custom tag <${tagName}>.`);\n        }\n        if (isHTML) {\n          tagIdentifier = importDefault(file, relativePath, tagName);\n        } else {\n          tagIdentifier = importNamed2(file, relativePath, \"apply\", tagName);\n          if (childProgram.extra.attrs) {\n            tagAttrsIdentifier = importNamed2(file, relativePath, \"applyAttrs\", `${tagName}_attrs`);\n          }\n          write`${importNamed2(file, relativePath, \"template\", `${tagName}_template`)}`;\n          injectWalks(tag, binding.id, importNamed2(file, relativePath, \"walks\", `${tagName}_walks`));\n        }\n        if (!tags.includes(relativePath)) {\n          tags.push(relativePath);\n        }\n      } else {\n        tagIdentifier = node.name;\n      }\n      const tagVar = node.var;\n      const attrsObject = attrsToObject(tag, true);\n      const renderBodyProp = getRenderBodyProp(attrsObject);\n      if (isHTML && node.extra.tagNameNullable) {\n        let renderBodyId = void 0;\n        let renderTagExpr = callExpression(tagIdentifier, attrsToObject(tag));\n        if (renderBodyProp) {\n          renderBodyId = tag.scope.generateUidIdentifier(\"renderBody\");\n          const [renderBodyPath] = tag.insertBefore(t16.functionDeclaration(renderBodyId, renderBodyProp.params, renderBodyProp.body));\n          renderBodyPath.skip();\n          attrsObject.properties[attrsObject.properties.length - 1] = t16.objectProperty(t16.identifier(\"renderBody\"), renderBodyId);\n        }\n        if (tagVar) {\n          translateVar(tag, t16.unaryExpression(\"void\", t16.numericLiteral(0)), \"let\");\n          renderTagExpr = t16.assignmentExpression(\"=\", tagVar, renderTagExpr);\n        }\n        tag.replaceWith(t16.ifStatement(tagIdentifier, t16.expressionStatement(renderTagExpr), renderBodyId && callStatement(renderBodyId)))[0].skip();\n      } else {\n        if (isHTML) {\n          if (tagVar) {\n            translateVar(tag, callExpression(tagIdentifier, attrsObject));\n            tag.remove();\n          } else {\n            tag.replaceWith(callStatement(tagIdentifier, attrsObject))[0].skip();\n          }\n        } else {\n          if (renderBodyProp) {\n            const { walks, writes } = getSectionMeta(tagBodySectionId);\n            attrsObject.properties.pop();\n            attrsObject.properties.push(t16.objectProperty(t16.identifier(\"renderBody\"), callRuntime(\"createRenderer\", writes || t16.stringLiteral(\"\"), walks || t16.stringLiteral(\"\"), t16.arrowFunctionExpression(renderBodyProp.params, renderBodyProp.body))));\n          }\n          addStatement(\"apply\", tagSectionId, void 0, t16.expressionStatement(t16.callExpression(tagIdentifier, [callRead(binding, tagSectionId)])));\n          if (attrsObject && tagAttrsIdentifier) {\n            addStatement(\"apply\", tagSectionId, tag.node.extra.attrsReferences, t16.expressionStatement(t16.callExpression(tagAttrsIdentifier, [\n              callRead(binding, tagSectionId),\n              attrsObject\n            ])));\n          }\n          tag.remove();\n        }\n      }\n    }\n  }\n};\nfunction callStatement(id, ...args) {\n  return t16.expressionStatement(callExpression(id, ...args));\n}\nfunction callExpression(id, ...args) {\n  return t16.callExpression(id, args.filter(Boolean));\n}\n\n// src/visitors/tag/dynamic-tag.ts\nimport { types as t18 } from \"@marko/compiler\";\n\n// src/util/to-first-expression-or-block.ts\nimport { types as t17 } from \"@marko/compiler\";\nfunction toFirstExpressionOrBlock(body) {\n  const nodes = body.body;\n  if (nodes.length === 1 && t17.isExpressionStatement(nodes[0])) {\n    return nodes[0].expression;\n  }\n  if (t17.isBlockStatement(body)) {\n    return body;\n  }\n  return t17.blockStatement(nodes);\n}\n\n// src/visitors/tag/dynamic-tag.ts\nvar dynamic_tag_default = {\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const tagBodySectionId = getSectionId(tag.get(\"body\"));\n      const attrsObject = attrsToObject(tag, true);\n      const renderBodyProp = getRenderBodyProp(attrsObject);\n      const args = [node.name, attrsObject || t18.nullLiteral()];\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      } else {\n        args.unshift(scopeIdentifier);\n      }\n      if (renderBodyProp) {\n        attrsObject.properties.pop();\n        let fnExpr = t18.arrowFunctionExpression(renderBodyProp.params, toFirstExpressionOrBlock(renderBodyProp.body));\n        if (isOutputDOM()) {\n          const { walks, writes } = getSectionMeta(tagBodySectionId);\n          fnExpr = callRuntime(\"createRenderer\", writes || t18.stringLiteral(\"\"), walks || t18.stringLiteral(\"\"), fnExpr);\n        }\n        args.push(fnExpr);\n      }\n      const dynamicTagExpr = callRuntime(\"dynamicTag\", ...args);\n      if (node.var) {\n        translateVar(tag, dynamicTagExpr);\n        tag.remove();\n      } else if (isOutputHTML()) {\n        tag.replaceWith(t18.expressionStatement(dynamicTagExpr))[0].skip();\n      } else {\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/visitors/tag/attribute-tag.ts\nimport { types as t19 } from \"@marko/compiler\";\nimport { findParentTag, assertNoVar } from \"@marko/babel-utils\";\nvar attribute_tag_default = {\n  translate: {\n    enter(tag) {\n      if (hasPendingHTML(tag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\"Dynamic @tags cannot be mixed with body content.\");\n      }\n    },\n    exit(tag) {\n      assertNoVar(tag);\n      flushInto(tag);\n      const parentTag = findParentTag(tag);\n      if (!parentTag) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags must be nested within another tag.\");\n      }\n      const parentExtra = parentTag.node.extra;\n      if (parentExtra.tagNameType === 0 /* NativeTag */) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags cannot be nested under native tags.\");\n      }\n      const attrName = tag.node.name.value.slice(1);\n      const info = parentExtra.nestedAttributeTags[attrName];\n      const attrsObject = attrsToObject(tag, true) || t19.objectExpression([]);\n      if (info.dynamic) {\n        if (!info.identifier) {\n          info.identifier = parentTag.scope.generateUidIdentifier(attrName);\n          parentTag.insertBefore(info.repeated ? t19.variableDeclaration(\"const\", [\n            t19.variableDeclarator(info.identifier, t19.arrayExpression([]))\n          ]) : t19.variableDeclaration(\"let\", [\n            t19.variableDeclarator(info.identifier)\n          ]));\n          parentTag.pushContainer(\"attributes\", t19.markoAttribute(attrName, info.identifier));\n        }\n        tag.replaceWith(t19.expressionStatement(info.repeated ? t19.callExpression(t19.memberExpression(info.identifier, t19.identifier(\"push\")), [attrsObject]) : t19.assignmentExpression(\"=\", info.identifier, attrsObject)));\n      } else if (info.repeated) {\n        const existingAttr = parentTag.get(\"attributes\").find((attr) => attr.node.name === attrName);\n        if (existingAttr) {\n          existingAttr.get(\"value\").pushContainer(\"elements\", attrsObject);\n        } else {\n          parentTag.pushContainer(\"attributes\", t19.markoAttribute(attrName, t19.arrayExpression([attrsObject])));\n        }\n        tag.remove();\n      } else {\n        parentTag.pushContainer(\"attributes\", t19.markoAttribute(attrName, attrsObject));\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/util/nested-attribute-tags.ts\nimport {\n  isAttributeTag,\n  isTransparentTag,\n  isLoopTag\n} from \"@marko/babel-utils\";\nfunction analyzeAttributeTags(tag) {\n  const { extra } = tag.node;\n  extra.nestedAttributeTags = {};\n  extra.hoistedControlFlows = 0;\n  analyzeChildren(extra, false, false, tag);\n}\nfunction analyzeChildren(rootExtra, repeated, dynamic, tag) {\n  let hasAttributeTags = false;\n  for (const child of tag.get(\"body\").get(\"body\")) {\n    if (child.isMarkoTag()) {\n      if (analyzeChild(rootExtra, repeated, dynamic, child)) {\n        hasAttributeTags = true;\n      }\n    }\n  }\n  return hasAttributeTags;\n}\nfunction analyzeChild(rootExtra, repeated, dynamic, tag) {\n  if (isTransparentTag(tag)) {\n    if (analyzeChildren(rootExtra, repeated || isLoopTag(tag), true, tag)) {\n      if (!isTransparentTag(tag.parentPath.parentPath)) {\n        rootExtra.hoistedControlFlows++;\n      }\n      return true;\n    }\n  } else if (isAttributeTag(tag)) {\n    const attrName = tag.node.name.value.slice(1);\n    const lookup = rootExtra.nestedAttributeTags;\n    const existing = lookup[attrName];\n    const info = existing || (lookup[attrName] = {\n      dynamic: false,\n      repeated: false\n    });\n    info.dynamic ||= dynamic;\n    info.repeated ||= repeated || existing !== void 0;\n    return true;\n  }\n  return false;\n}\n\n// src/visitors/tag/index.ts\nvar tag_default = {\n  analyze: {\n    enter(tag) {\n      const tagDef = getTagDef3(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        enter2(hook, tag);\n        return;\n      }\n      switch (analyzeTagNameType(tag)) {\n        case 0 /* NativeTag */:\n          native_tag_default.analyze.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          break;\n        case 2 /* DynamicTag */:\n          break;\n      }\n    },\n    exit(tag) {\n      const tagDef = getTagDef3(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        exit2(hook, tag);\n        return;\n      }\n      if (type === 0 /* NativeTag */) {\n        return;\n      }\n      analyzeAttributeTags(tag);\n      switch (type) {\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          break;\n        case 2 /* DynamicTag */:\n          break;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagDef = getTagDef3(tag);\n      const extra = tag.node.extra;\n      assertNoArgs(tag);\n      if (tagDef?.translator) {\n        if (tagDef.translator.path) {\n          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);\n        }\n        enter2(tagDef.translator.hook, tag);\n        return;\n      }\n      for (const attr of tag.get(\"attributes\")) {\n        if (attr.isMarkoAttribute()) {\n          if (attr.node.arguments) {\n            throw attr.buildCodeFrameError(`Unsupported arguments on the \"${attr.node.name}\" attribute.`);\n          }\n          if (attr.node.modifier) {\n            if (isNativeTag2(attr.parentPath)) {\n              attr.node.name += `:${attr.node.modifier}`;\n            } else {\n              throw attr.buildCodeFrameError(`Unsupported modifier \"${attr.node.modifier}\".`);\n            }\n          }\n        }\n      }\n      let { tagNameType } = extra;\n      if (extra.tagNameDynamic) {\n        if (extra.tagNameNullable && !tag.get(\"name\").isIdentifier()) {\n          const tagNameId = tag.scope.generateUidIdentifier(\"tagName\");\n          const [tagNameVarPath] = tag.insertBefore(t20.variableDeclaration(\"const\", [\n            t20.variableDeclarator(tagNameId, tag.node.name)\n          ]));\n          tagNameVarPath.skip();\n          tag.set(\"name\", tagNameId);\n        }\n        if (tagNameType !== 2 /* DynamicTag */ && !isOutputHTML()) {\n          tagNameType = 2 /* DynamicTag */;\n        }\n      }\n      switch (tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const translator = getTagDef3(tag)?.translator;\n      if (translator) {\n        exit2(translator.hook, tag);\n        return;\n      }\n      const { extra } = tag.node;\n      let { tagNameType } = extra;\n      if (extra.tagNameDynamic && tagNameType !== 2 /* DynamicTag */ && (!isOutputHTML() || tagNameType === void 0)) {\n        tagNameType = 2 /* DynamicTag */;\n      }\n      switch (tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.exit(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.exit(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.exit(tag);\n          break;\n      }\n    }\n  }\n};\n\n// src/visitors/placeholder.ts\nimport { types as t21 } from \"@marko/compiler\";\nimport { isNativeTag as isNativeTag3 } from \"@marko/babel-utils\";\n\n// src/util/is-core-tag.ts\nimport { getTagDef as getTagDef4 } from \"@marko/babel-utils\";\nvar taglibId = \"marko-core\";\nfunction isCoreTag(tag) {\n  return tag.isMarkoTag() && getTagDef4(tag)?.taglibId === taglibId;\n}\nfunction isCoreTagName(tag, name) {\n  return isCoreTag(tag) && tag.node.name.value === name;\n}\n\n// src/visitors/placeholder.ts\nvar ESCAPE_TYPES = {\n  script: \"escapeScript\",\n  style: \"escapeStyle\"\n};\nvar placeholder_default = {\n  analyze(placeholder) {\n    const { node } = placeholder;\n    const { confident, computed } = evaluate(placeholder);\n    if (!(confident && (node.escape || !computed))) {\n      reserveScope(0 /* Visit */, getOrCreateSectionId(placeholder), node, \"placeholder\");\n      needsMarker(placeholder);\n    }\n  },\n  translate(placeholder) {\n    const isHTML = isOutputHTML();\n    const write = writeTo(placeholder);\n    const extra = placeholder.node.extra;\n    const { confident, computed, valueReferences, reserve } = extra;\n    const canWriteHTML = isHTML || confident && (placeholder.node.escape || !computed);\n    const method = canWriteHTML ? placeholder.node.escape ? ESCAPE_TYPES[getParentTagName(placeholder)] || \"escapeXML\" : \"toString\" : placeholder.node.escape ? \"data\" : \"html\";\n    if (confident && canWriteHTML) {\n      write`${getHTMLRuntime()[method](computed)}`;\n    } else {\n      if (extra.needsMarker) {\n        visit(placeholder, 37 /* Replace */);\n      } else {\n        if (!isHTML)\n          write` `;\n        visit(placeholder, 32 /* Get */);\n      }\n      if (isHTML) {\n        write`${callRuntime(method, placeholder.node.value)}`;\n      } else {\n        addStatement(\"apply\", getSectionId(placeholder), valueReferences, t21.expressionStatement(callRuntime(method, t21.memberExpression(scopeIdentifier, t21.numericLiteral(reserve.id), true), placeholder.node.value)));\n      }\n    }\n    enterShallow(placeholder);\n    placeholder.remove();\n  }\n};\nfunction getParentTagName({ parentPath }) {\n  return parentPath.isMarkoTag() && isNativeTag3(parentPath) && parentPath.node.name.value || \"\";\n}\nfunction noOutput(path3) {\n  return t21.isMarkoComment(path3) || t21.isMarkoTag(path3) && isCoreTag(path3) && [\"let\", \"const\", \"effect\", \"lifecycle\", \"attrs\", \"get\", \"id\"].includes(path3.node.name.value);\n}\nfunction needsMarker(placeholder) {\n  let prev = placeholder.getPrevSibling();\n  while (prev.node && noOutput(prev)) {\n    prev = prev.getPrevSibling();\n  }\n  if ((prev.node || t21.isProgram(placeholder.parentPath)) && !(t21.isMarkoTag(prev) && isNativeTag3(prev))) {\n    return placeholder.node.extra.needsMarker = true;\n  }\n  let next = placeholder.getNextSibling();\n  while (next.node && noOutput(next)) {\n    next = next.getNextSibling();\n  }\n  if ((next.node || t21.isProgram(placeholder.parentPath)) && !(t21.isMarkoTag(next) && isNativeTag3(next))) {\n    return placeholder.node.extra.needsMarker = true;\n  }\n  return placeholder.node.extra.needsMarker = false;\n}\n\n// src/visitors/scriptlet.ts\nvar scriptlet_default = {\n  translate(scriptlet) {\n    if (isOutputHTML()) {\n      if (scriptlet.node.static)\n        return;\n      scriptlet.replaceWithMultiple(scriptlet.node.body);\n    } else {\n      if (scriptlet.node.static) {\n        scriptlet.replaceWithMultiple(scriptlet.node.body);\n      } else {\n        addStatement(\"apply\", getSectionId(scriptlet), scriptlet.node.extra?.bodyReferences, scriptlet.node.body);\n        scriptlet.remove();\n      }\n    }\n  }\n};\n\n// src/visitors/comment.ts\nvar ieConditionalCommentRegExp = /^\\[if |<!\\[endif\\]$/;\nvar comment_default = {\n  translate(comment) {\n    if (isOutputHTML()) {\n      const { value } = comment.node;\n      if (ieConditionalCommentRegExp.test(value)) {\n        writeTo(comment)`<!--${value}-->`;\n      }\n    }\n    comment.remove();\n  }\n};\n\n// src/core/import.ts\nimport { parseScript } from \"@marko/babel-utils\";\nvar import_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(parseScript(tag.hub.file, node.rawValue, node.start).body[0]);\n  },\n  parseOptions: {\n    rootOnly: true,\n    rawOpenTag: true,\n    openTagOnly: true,\n    ignoreAttributes: true,\n    relaxRequireCommas: true\n  },\n  autocomplete: [\n    {\n      displayText: 'import <scope> from \"<path>\"',\n      description: \"Use to import external modules, follows the same syntax as JavaScript imports.\",\n      snippet: 'import ${2} from \"${1:path}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#importing-external-files\"\n    }\n  ]\n};\n\n// src/core/export.ts\nimport { parseScript as parseScript2 } from \"@marko/babel-utils\";\nvar export_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(parseScript2(tag.hub.file, node.rawValue, node.start).body[0]);\n  },\n  parseOptions: {\n    rootOnly: true,\n    rawOpenTag: true,\n    openTagOnly: true,\n    ignoreAttributes: true,\n    relaxRequireCommas: true\n  },\n  autocomplete: [\n    {\n      displayText: \"export <value>\"\n    }\n  ]\n};\n\n// src/core/attrs.ts\nvar attrs_default = {\n  analyze(tag) {\n    if (tag.has(\"var\")) {\n      const varPath = tag.get(\"var\");\n      const bindings = varPath.getBindingIdentifiers();\n      const sectionId = getOrCreateSectionId(tag);\n      trackReferencesForBindings(sectionId, varPath, 2 /* Attr */);\n      for (const key in bindings) {\n        const binding = bindings[key].extra.reserve;\n        binding.exportIdentifier = getReferenceGroup(sectionId, binding, true).apply;\n      }\n      (currentProgramPath.node.extra ??= {}).attrs = {\n        bindings,\n        var: varPath.node\n      };\n    }\n  },\n  translate(tag) {\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"attrs/{ ... }\",\n      description: \"Use to receive the attributes passed into this template.\",\n      snippet: \"attrs/{ $1 }$2\"\n    }\n  ]\n};\n\n// src/core/condition/if.ts\nimport { types as t23 } from \"@marko/compiler\";\nimport { assertNoParams, assertNoVar as assertNoVar2 } from \"@marko/babel-utils\";\n\n// src/util/to-first-statement-or-block.ts\nimport { types as t22 } from \"@marko/compiler\";\nfunction toFirstStatementOrBlock(body) {\n  const nodes = body.body;\n  if (nodes.length === 1) {\n    return nodes[0];\n  }\n  if (t22.isBlockStatement(body)) {\n    return body;\n  }\n  return t22.blockStatement(nodes);\n}\n\n// src/core/condition/if.ts\nvar if_default = {\n  analyze: {\n    enter(tag) {\n      reserveScope(0 /* Visit */, getOrCreateSectionId(tag), tag.node, \"if\", 3);\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      analyzeAttributeTags(tag);\n      exitBranchAnalyze(tag);\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [testAttr] = node.attributes;\n      assertNoVar2(tag);\n      assertNoParams(tag);\n      if (!t23.isMarkoAttribute(testAttr) || !testAttr.default) {\n        throw tag.get(\"name\").buildCodeFrameError(`The '<if>' tag requires a default attribute like '<if=condition>'.`);\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<if>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n        }\n      }\n      visit(tag, 37 /* Replace */);\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      exitBranchTranslate(tag);\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      snippet: \"if=${1:condition}\",\n      description: \"Use to display content only if the condition is met.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar BRANCHES_LOOKUP = /* @__PURE__ */ new WeakMap();\nfunction getBranches(tag, bodySectionId) {\n  const branches = BRANCHES_LOOKUP.get(tag) ?? [];\n  const nextTag = tag.getNextSibling();\n  const isLast = !(isCoreTagName(nextTag, \"else\") || isCoreTagName(nextTag, \"else-if\"));\n  branches.push({\n    tag,\n    sectionId: bodySectionId\n  });\n  if (!isLast) {\n    BRANCHES_LOOKUP.set(nextTag, branches);\n  }\n  return [isLast, branches];\n}\nfunction exitBranchAnalyze(tag) {\n  const sectionId = getOrCreateSectionId(tag);\n  const tagBody = tag.get(\"body\");\n  const bodySectionId = getOrCreateSectionId(tagBody);\n  const [isLast, branches] = getBranches(tag, bodySectionId);\n  if (isLast) {\n    branches[0].tag.node.extra.conditionalReferences = mergeReferenceGroups(sectionId, branches.filter(({ tag: tag2 }) => tag2.node.attributes[0]?.extra?.valueReferences).map(({ tag: tag2 }) => [tag2.node.attributes[0].extra, \"valueReferences\"]));\n  }\n}\nfunction exitBranchTranslate(tag) {\n  const tagBody = tag.get(\"body\");\n  const bodySectionId = getSectionId(tagBody);\n  const [isLast, branches] = getBranches(tag, bodySectionId);\n  if (isOutputHTML()) {\n    flushInto(tag);\n    writeHTMLHydrateStatements(tagBody);\n  }\n  if (isLast) {\n    if (isOutputDOM()) {\n      const sectionId = getSectionId(tag);\n      const { extra } = branches[0].tag.node;\n      let expr = t23.nullLiteral();\n      for (let i = branches.length; i--; ) {\n        const { tag: tag2, sectionId: sectionId2 } = branches[i];\n        const [testAttr] = tag2.node.attributes;\n        const id = getRenderer(sectionId2);\n        setQueueBuilder(tag2, ({ apply, index }, closurePriority) => {\n          return callRuntime(\"queueInBranch\", scopeIdentifier, t23.numericLiteral(extra.reserve.id), getRenderer(sectionId2), apply, t23.numericLiteral(index), closurePriority);\n        });\n        tag2.remove();\n        if (testAttr) {\n          expr = t23.conditionalExpression(testAttr.value, id, expr);\n        } else {\n          expr = id;\n        }\n      }\n      addStatement(\"apply\", sectionId, extra.conditionalReferences, t23.expressionStatement(callRuntime(\"setConditionalRenderer\", scopeIdentifier, t23.numericLiteral(extra.reserve.id), expr)));\n    } else {\n      const nextTag = tag.getNextSibling();\n      let statement;\n      for (let i = branches.length; i--; ) {\n        const { tag: tag2 } = branches[i];\n        const [testAttr] = tag2.node.attributes;\n        const curStatement = toFirstStatementOrBlock(tag2.node.body);\n        if (testAttr) {\n          statement = t23.ifStatement(testAttr.value, curStatement, statement);\n        } else {\n          statement = curStatement;\n        }\n        tag2.remove();\n      }\n      nextTag.insertBefore(statement);\n    }\n  }\n}\n\n// src/core/condition/else-if.ts\nimport { types as t24 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams2, assertNoVar as assertNoVar3 } from \"@marko/babel-utils\";\nvar else_if_default = {\n  analyze: {\n    enter(tag) {\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      exitBranchAnalyze(tag);\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [defaultAttr] = node.attributes;\n      assertNoVar3(tag);\n      assertNoParams2(tag);\n      if (!t24.isMarkoAttribute(defaultAttr) || !defaultAttr.default) {\n        throw tag.get(\"name\").buildCodeFrameError(`The '<else-if>' tag requires a default attribute like '<else-if=condition>'.`);\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<else-if>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n        }\n      }\n    },\n    exit(tag) {\n      exitBranchTranslate(tag);\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      snippet: \"else-if=${1:condition}\",\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\n\n// src/core/condition/else.ts\nimport { assertNoParams as assertNoParams3, assertNoVar as assertNoVar4 } from \"@marko/babel-utils\";\nvar else_default = {\n  analyze: {\n    enter(tag) {\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      exitBranchAnalyze(tag);\n    }\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [testAttr] = node.attributes;\n      assertNoVar4(tag);\n      assertNoParams3(tag);\n      if (node.attributes.length > 1 || testAttr && testAttr.name !== \"if\") {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<else>' tag only supports an if attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n        }\n      }\n    },\n    exit(tag) {\n      exitBranchTranslate(tag);\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\n\n// src/core/const.ts\nimport { types as t25 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams4 } from \"@marko/babel-utils\";\n\n// src/util/assert.ts\nfunction assertNoSpreadAttrs(tag) {\n  for (const attr of tag.get(\"attributes\")) {\n    if (attr.isMarkoSpreadAttribute()) {\n      throw attr.buildCodeFrameError(`The <${tag.get(\"name\")}> tag does not support ...spread attributes.`);\n    }\n  }\n}\nfunction assertNoBodyContent(tag) {\n  if (tag.node.body.body.length) {\n    throw tag.get(\"name\").buildCodeFrameError(`The <${tag.get(\"name\")}> tag does not support body content.`);\n  }\n}\n\n// src/core/const.ts\nvar const_default = {\n  translate(tag) {\n    const { node } = tag;\n    const [defaultAttr] = node.attributes;\n    assertNoParams4(tag);\n    assertNoBodyContent(tag);\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'const' tag requires a tag variable.\");\n    }\n    if (!defaultAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'const' tag requires a default attribute.\");\n    }\n    if (node.attributes.length > 1 || !t25.isMarkoAttribute(defaultAttr) || !defaultAttr.default && defaultAttr.name !== \"default\") {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'const' tag only supports the 'default' attribute.\");\n    }\n    if (isOutputDOM()) {\n      const sectionId = getSectionId(tag);\n      const identifiers = Object.values(tag.get(\"var\").getBindingIdentifiers());\n      addStatement(\"apply\", sectionId, defaultAttr.extra?.valueReferences, identifiers.length === 1 ? t25.expressionStatement(t25.callExpression(getReferenceGroup(sectionId, identifiers[0].extra.reserve).apply, [scopeIdentifier, defaultAttr.value])) : [\n        t25.variableDeclaration(\"const\", [\n          t25.variableDeclarator(node.var, defaultAttr.value)\n        ]),\n        ...identifiers.map((identifier) => t25.expressionStatement(t25.callExpression(getReferenceGroup(sectionId, identifier.extra.reserve).apply, [t25.identifier(identifier.name)])))\n      ]);\n    } else {\n      translateVar(tag, defaultAttr.value);\n    }\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an constant binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#const\"\n    }\n  ]\n};\n\n// src/core/effect.ts\nimport { types as t26 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams5 } from \"@marko/babel-utils\";\nvar effect_default = {\n  analyze(tag) {\n    const sectionId = getSectionId(tag);\n    reserveScope(1 /* Store */, sectionId, tag.node, \"cleanup\");\n    (currentProgramPath.node.extra ?? {}).isInteractive = true;\n  },\n  translate(tag) {\n    const { node } = tag;\n    const [defaultAttr] = node.attributes;\n    assertNoParams5(tag);\n    assertNoBodyContent(tag);\n    if (!defaultAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'effect' tag requires a default attribute.\");\n    }\n    if (node.attributes.length > 1 || !t26.isMarkoAttribute(defaultAttr) || !defaultAttr.default && defaultAttr.name !== \"default\") {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'effect' tag only supports the 'default' attribute.\");\n    }\n    const sectionId = getSectionId(tag);\n    if (isOutputDOM()) {\n      const cleanupIndex = tag.node.extra.reserve.id;\n      const { value } = defaultAttr;\n      let inlineStatements = null;\n      if (t26.isFunctionExpression(value) || t26.isArrowFunctionExpression(value) && t26.isBlockStatement(value.body)) {\n        inlineStatements = value.body.body;\n        t26.traverse(value.body, (node2) => {\n          if (t26.isReturnStatement(node2)) {\n            inlineStatements = null;\n          }\n        });\n      }\n      addStatement(\"hydrate\", sectionId, defaultAttr.extra?.valueReferences, inlineStatements || t26.expressionStatement(callRuntime(\"userEffect\", scopeIdentifier, t26.numericLiteral(cleanupIndex), defaultAttr.value)));\n    } else {\n      addHTMLHydrateCall(sectionId, defaultAttr.extra?.valueReferences);\n    }\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ]\n};\n\n// src/core/for.ts\nimport { types as t27 } from \"@marko/compiler\";\nimport {\n  assertAllowedAttributes,\n  assertNoVar as assertNoVar5,\n  getTagDef as getTagDef5\n} from \"@marko/babel-utils\";\nvar for_default = {\n  analyze: {\n    enter(tag) {\n      const isOnlyChild = checkOnlyChild(tag);\n      reserveScope(0 /* Visit */, getOrCreateSectionId(tag), isOnlyChild ? tag.parentPath.parent : tag.node, \"for\", 3);\n      custom_tag_default.analyze.enter(tag);\n    },\n    exit(tag) {\n      analyzeAttributeTags(tag);\n    }\n  },\n  translate: {\n    enter(tag) {\n      validateFor(tag);\n      if (!isOutputHTML() && Object.keys(tag.node.extra.nestedAttributeTags).length) {\n        tag.remove();\n        return;\n      }\n      const {\n        extra: { isOnlyChild }\n      } = tag.node;\n      if (!isOnlyChild) {\n        visit(tag, 37 /* Replace */);\n        enterShallow(tag);\n      }\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML.exit(tag);\n      } else {\n        translateDOM.exit(tag);\n      }\n    }\n  },\n  attributes: {\n    of: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over a list of items.\"\n        }\n      ]\n    },\n    in: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over the keys and values of an object.\"\n        }\n      ]\n    },\n    to: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates up to the provided number (inclusive)\"\n        }\n      ]\n    },\n    from: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates starting from the provided number (inclusive)\"\n        }\n      ]\n    },\n    step: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"The amount to increment during each interation (with from/to)\"\n        }\n      ]\n    }\n  },\n  autocomplete: [\n    {\n      snippet: \"for|${1:value, index}| of=${3:array}\",\n      description: \"Use to iterate over lists, object properties, or between ranges.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-a-list\"\n    },\n    {\n      snippet: \"for|${1:name, value}| in=${3:object}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties\"\n    },\n    {\n      snippet: \"for|${1:index}| from=${2:number} to=${3:number} step=${4:number}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers\"\n    }\n  ]\n};\nvar translateDOM = {\n  exit(tag) {\n    const bodySectionId = getSectionId(tag.get(\"body\"));\n    const sectionId = getSectionId(tag);\n    const { node } = tag;\n    const {\n      attributes,\n      body: { params },\n      extra: { isOnlyChild }\n    } = node;\n    const {\n      extra: { reserve }\n    } = isOnlyChild ? tag.parentPath.parent : tag.node;\n    const ofAttr = findName(attributes, \"of\");\n    const byAttr = findName(attributes, \"by\");\n    setQueueBuilder(tag, ({ apply, index }, closurePriority) => {\n      return callRuntime(\"queueForEach\", scopeIdentifier, t27.numericLiteral(reserve.id), apply, t27.numericLiteral(index), closurePriority);\n    });\n    if (ofAttr) {\n      const ofAttrValue = ofAttr.value;\n      const [valParam] = params;\n      if (!t27.isIdentifier(valParam)) {\n        throw tag.buildCodeFrameError(`Invalid 'for of' tag, |value| parameter must be an identifier.`);\n      }\n      const rendererId = getRenderer(bodySectionId);\n      tag.remove();\n      addStatement(\"apply\", sectionId, ofAttr.extra?.valueReferences, t27.expressionStatement(callRuntime(\"setLoopOf\", scopeIdentifier, t27.numericLiteral(reserve.id), ofAttrValue, rendererId, byAttr ? byAttr.value : t27.nullLiteral(), getReferenceGroup(bodySectionId, valParam.extra.reserve).apply)));\n    }\n  }\n};\nvar translateHTML = {\n  exit(tag) {\n    const tagBody = tag.get(\"body\");\n    const { node } = tag;\n    const {\n      attributes,\n      body: { body, params }\n    } = node;\n    const namePath = tag.get(\"name\");\n    const ofAttr = findName(attributes, \"of\");\n    const inAttr = findName(attributes, \"in\");\n    const fromAttr = findName(attributes, \"from\");\n    const toAttr = findName(attributes, \"to\");\n    const block = t27.blockStatement(body);\n    let forNode;\n    flushInto(tag);\n    writeHTMLHydrateStatements(tagBody);\n    if (inAttr) {\n      const [keyParam, valParam] = params;\n      if (valParam) {\n        block.body.unshift(t27.variableDeclaration(\"const\", [\n          t27.variableDeclarator(valParam, t27.memberExpression(inAttr.value, keyParam, true))\n        ]));\n      }\n      forNode = t27.forInStatement(t27.variableDeclaration(\"const\", [t27.variableDeclarator(keyParam)]), inAttr.value, block);\n    } else if (ofAttr) {\n      let ofAttrValue = ofAttr.value;\n      const [valParam, keyParam, loopParam] = params;\n      if (!valParam) {\n        throw namePath.buildCodeFrameError(\"Invalid 'for of' tag, missing |value, index| params.\");\n      }\n      forNode = [];\n      if (keyParam) {\n        const indexName = tag.scope.generateUidIdentifierBasedOnNode(keyParam, \"i\");\n        forNode.push(t27.variableDeclaration(\"let\", [\n          t27.variableDeclarator(indexName, t27.numericLiteral(0))\n        ]));\n        block.body.unshift(t27.variableDeclaration(\"let\", [\n          t27.variableDeclarator(keyParam, t27.updateExpression(\"++\", indexName))\n        ]));\n      }\n      if (loopParam) {\n        if (t27.isIdentifier(loopParam)) {\n          ofAttrValue = loopParam;\n        }\n        forNode.push(t27.variableDeclaration(\"const\", [\n          t27.variableDeclarator(loopParam, ofAttr.value)\n        ]));\n      }\n      forNode.push(t27.forOfStatement(t27.variableDeclaration(\"const\", [t27.variableDeclarator(valParam)]), ofAttrValue, block));\n    } else if (fromAttr && toAttr) {\n      const stepAttr = findName(attributes, \"step\") || {\n        value: t27.numericLiteral(1)\n      };\n      const stepValue = stepAttr ? stepAttr.value : t27.numericLiteral(1);\n      const [indexParam] = params;\n      const stepsName = tag.scope.generateUidIdentifier(\"steps\");\n      const stepName = tag.scope.generateUidIdentifier(\"step\");\n      if (indexParam) {\n        block.body.unshift(t27.variableDeclaration(\"const\", [\n          t27.variableDeclarator(indexParam, t27.binaryExpression(\"+\", fromAttr.value, t27.binaryExpression(\"*\", stepName, stepValue)))\n        ]));\n      }\n      forNode = t27.forStatement(t27.variableDeclaration(\"let\", [\n        t27.variableDeclarator(stepsName, t27.binaryExpression(\"/\", t27.binaryExpression(\"-\", toAttr.value, fromAttr.value), stepValue)),\n        t27.variableDeclarator(stepName, t27.numericLiteral(0))\n      ]), t27.binaryExpression(\"<=\", stepName, stepsName), t27.updateExpression(\"++\", stepName), block);\n    }\n    block.body.push(t27.expressionStatement(callRuntime(\"maybeFlush\")));\n    tag.replaceWithMultiple([].concat(forNode));\n  }\n};\nfunction findName(arr, value) {\n  return arr.find((obj) => t27.isMarkoAttribute(obj) && obj.name === value);\n}\nfunction validateFor(tag) {\n  const attrs = tag.node.attributes;\n  const hasParams = tag.node.body.params.length > 0;\n  assertNoVar5(tag);\n  if (findName(attrs, \"of\")) {\n    assertAllowedAttributes(tag, [\"of\", \"by\"]);\n    if (!hasParams) {\n      throw tag.buildCodeFrameError(`Invalid 'for of' tag, missing |value, index| params.`);\n    }\n  } else if (findName(attrs, \"in\")) {\n    assertAllowedAttributes(tag, [\"in\", \"by\"]);\n    if (!hasParams) {\n      throw tag.buildCodeFrameError(`Invalid 'for in' tag, missing |key, value| params.`);\n    }\n  } else if (findName(attrs, \"from\") && findName(attrs, \"to\")) {\n    assertAllowedAttributes(tag, [\"from\", \"to\", \"step\", \"by\"]);\n  } else {\n    throw tag.buildCodeFrameError(\"Invalid 'for' tag, missing an 'of', 'in' or 'to' attribute.\");\n  }\n}\nfunction checkOnlyChild(tag) {\n  tag.node.extra ??= {};\n  if (t27.isMarkoTag(tag.parentPath?.parent) && getTagDef5(tag.parentPath.parentPath)?.html) {\n    return tag.node.extra.isOnlyChild = tag.parent.body.length === 1;\n  }\n  return tag.node.extra.isOnlyChild = false;\n}\n\n// src/core/get.ts\nimport path from \"path\";\nimport { types as t28 } from \"@marko/compiler\";\nimport {\n  resolveTagImport as resolveTagImport2,\n  getTemplateId as getTemplateId2,\n  assertNoParams as assertNoParams6\n} from \"@marko/babel-utils\";\nvar get_default = {\n  translate(tag) {\n    assertNoParams6(tag);\n    assertNoBodyContent(tag);\n    flushBefore(tag);\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const [defaultAttr] = node.attributes;\n    let refId;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"<get> requires a variable to be defined, eg <get/NAME>.\");\n    }\n    if (defaultAttr === void 0) {\n      refId = \"$\";\n    } else {\n      if (!t28.isMarkoAttribute(defaultAttr) || !defaultAttr.default || !t28.isStringLiteral(defaultAttr.value)) {\n        throw tag.get(\"name\").buildCodeFrameError(`The '<get>' tag requires default attribute that is a string that resolves to a Marko file like '<get/val=\"../file.marko\">' or '<get/val=\"<tag-name>\">'.`);\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<get>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n        }\n      }\n      const defaultAttrValue = tag.get(\"attributes\")[0].get(\"value\");\n      if (defaultAttr.value.value === \".\") {\n        refId = file.metadata.marko.id;\n      } else {\n        const relativeReferencePath = resolveTagImport2(defaultAttrValue, defaultAttrValue.node.value);\n        if (!relativeReferencePath) {\n          throw defaultAttrValue.buildCodeFrameError(\"Unable to resolve template provided to '<get>' tag.\");\n        }\n        refId = getTemplateId2(file.markoOpts.optimize, path.resolve(file.opts.filename, \"..\", relativeReferencePath));\n      }\n    }\n    if (isOutputHTML()) {\n      tag.replaceWith(t28.variableDeclaration(\"const\", [\n        t28.variableDeclarator(node.var, callRuntime(\"getInContext\", t28.stringLiteral(refId)))\n      ]));\n    } else {\n      tag.remove();\n    }\n  },\n  autocomplete: [\n    {\n      displayText: 'get/<name>=\"<from>\"',\n      description: \"Gets a value provided from another template.\",\n      snippet: 'get/${1:name}=\"${2:from}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#get\"\n    }\n  ]\n};\n\n// src/core/html-comment.ts\nimport {\n  assertNoAttributeTags,\n  assertNoAttributes,\n  assertNoParams as assertNoParams7,\n  assertNoVar as assertNoVar6\n} from \"@marko/babel-utils\";\nvar html_comment_default = {\n  analyze() {\n  },\n  translate: {\n    enter(tag) {\n      enter(tag);\n      writeTo(tag)`<!--`;\n    },\n    exit(tag) {\n      assertNoVar6(tag);\n      assertNoParams7(tag);\n      assertNoAttributes(tag);\n      assertNoAttributeTags(tag);\n      exit(tag);\n      writeTo(tag)`-->`;\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    state: \"parsed-text\"\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an html comment that is not stripped from the output.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#html-comment\"\n    }\n  ]\n};\n\n// src/core/let.ts\nimport { types as t30 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams8 } from \"@marko/babel-utils\";\n\n// src/util/replace-assignments.ts\nimport { types as t29 } from \"@marko/compiler\";\nfunction replaceAssignments(binding, map) {\n  for (const assignment of binding.constantViolations) {\n    let value;\n    if (assignment.isUpdateExpression()) {\n      value = t29.binaryExpression(assignment.node.operator === \"++\" ? \"+\" : \"-\", binding.identifier, t29.numericLiteral(1));\n    } else if (assignment.isAssignmentExpression()) {\n      value = assignment.node.operator === \"=\" ? assignment.node.right : t29.binaryExpression(assignment.node.operator.slice(0, -1), binding.identifier, assignment.node.right);\n    }\n    if (value) {\n      assignment.parentPath.replaceWith(map(assignment, value));\n    }\n  }\n}\n\n// src/core/let.ts\nvar let_default = {\n  translate(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    const [defaultAttr] = node.attributes;\n    assertNoParams8(tag);\n    assertNoBodyContent(tag);\n    if (!tagVar) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'let' tag requires a tag variable.\");\n    }\n    if (!t30.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The 'let' cannot be destructured.\");\n    }\n    if (!defaultAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'let' tag requires a default attribute.\");\n    }\n    if (node.attributes.length > 1 || !t30.isMarkoAttribute(defaultAttr) || !defaultAttr.default && defaultAttr.name !== \"default\") {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'let' tag only supports the 'default' attribute.\");\n    }\n    if (isOutputDOM()) {\n      const sectionId = getSectionId(tag);\n      const binding = tagVar.extra.reserve;\n      const referenceGroup = getReferenceGroup(sectionId, binding);\n      addStatement(\"apply\", sectionId, defaultAttr.extra?.valueReferences, t30.expressionStatement(t30.callExpression(referenceGroup.apply, [\n        scopeIdentifier,\n        defaultAttr.value\n      ])));\n      replaceAssignments(tag.scope.getBinding(binding.name), (assignment, value) => callQueue(referenceGroup, binding, value, getSectionId(assignment)));\n    } else {\n      translateVar(tag, defaultAttr.value);\n    }\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a mutable binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#let\"\n    }\n  ]\n};\n\n// src/core/set.ts\nimport { types as t31 } from \"@marko/compiler\";\nimport { assertNoParams as assertNoParams9, assertNoVar as assertNoVar7 } from \"@marko/babel-utils\";\nvar set_default = {\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n      const { node } = tag;\n      const [defaultAttr] = node.attributes;\n      if (!node.body.body.length) {\n        throw tag.buildCodeFrameError(`The '<set>' tag requires body content that the context is forwarded through.`);\n      }\n      if (!t31.isMarkoAttribute(defaultAttr) || !defaultAttr.default) {\n        throw tag.get(\"name\").buildCodeFrameError(`The '<set>' tag requires default attribute like '<set=val>'.`);\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<set>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n        }\n      }\n      tag.insertBefore(t31.expressionStatement(callRuntime(\"pushContext\", t31.stringLiteral(tag.hub.file.metadata.marko.id), defaultAttr.value)));\n    },\n    exit(tag) {\n      assertNoParams9(tag);\n      assertNoVar7(tag);\n      if (isOutputHTML()) {\n        flushInto(tag);\n      }\n      tag.insertAfter(t31.expressionStatement(callRuntime(\"popContext\")));\n      tag.replaceWithMultiple(tag.node.body.body);\n    }\n  },\n  autocomplete: [\n    {\n      displayText: \"set=<value>\",\n      description: \"Sets a value which can be read from a child template.\",\n      snippet: \"set=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#set\"\n    }\n  ]\n};\n\n// src/core/style.ts\nimport path2 from \"path\";\nimport { assertNoParams as assertNoParams10, assertNoVar as assertNoVar8 } from \"@marko/babel-utils\";\nimport { types as t32 } from \"@marko/compiler\";\nvar style_default = {\n  translate(tag) {\n    const {\n      hub: { file }\n    } = tag;\n    assertNoVar8(tag);\n    assertNoParams10(tag);\n    assertNoSpreadAttrs(tag);\n    let type = \"text/css\";\n    const attrs = tag.get(\"attributes\");\n    const base = path2.basename(file.opts.sourceFileName);\n    const typeAttr = attrs.find((attr) => attr.isMarkoAttribute() && attr.node.name === \"type\");\n    if (typeAttr) {\n      const typeValue = typeAttr.get(\"value\");\n      if (typeValue.isStringLiteral()) {\n        type = typeValue.node.value;\n      } else {\n        throw typeValue.buildCodeFrameError(`<style> \"type\" attribute can only be a string literal.`);\n      }\n    }\n    if (type === \"text/css\") {\n      type = \"css\";\n    }\n    const body = tag.get(\"body\").get(\"body\");\n    const markoText = body[0];\n    if (body.length !== 1 || !markoText.isMarkoText()) {\n      throw (markoText.isMarkoText() ? body[1] : body[0]).buildCodeFrameError(\"The '<style>' tag currently only supports static content.\");\n    }\n    const { resolveVirtualDependency } = getMarkoOpts();\n    if (resolveVirtualDependency) {\n      const importPath = resolveVirtualDependency(file.opts.filename, {\n        type,\n        code: markoText.node.value,\n        startPos: markoText.node.start,\n        endPos: markoText.node.end,\n        path: `./${base}`,\n        virtualPath: `./${base}.${type}`\n      });\n      currentProgramPath.pushContainer(\"body\", t32.importDeclaration([], t32.stringLiteral(importPath)));\n    }\n    tag.remove();\n  },\n  attributes: {\n    type: { enum: [\"css\", \"less\", \"scss\", \"text/css\"] }\n  }\n};\n\n// src/core/tag.ts\nimport { types as t33 } from \"@marko/compiler\";\nvar tag_default2 = {\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n      if (!tag.node.var) {\n        throw tag.get(\"name\").buildCodeFrameError(\"<tag> requires a variable to be defined, eg <tag/NAME>.\");\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        flushInto(tag);\n      }\n      tag.replaceWith(t33.variableDeclaration(\"const\", [\n        t33.variableDeclarator(tag.node.var, t33.arrowFunctionExpression(tag.node.body.params, toFirstExpressionOrBlock(tag.node.body)))\n      ]));\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"tag/<name>|<params>|\",\n      description: \"Creates a reusable fragment within the template.\",\n      snippet: \"tag/${1:name}|${2:param1, param2}|\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#tag\"\n    }\n  ]\n};\n\n// src/core/yield.ts\nimport { types as t34 } from \"@marko/compiler\";\nimport { assertNoVar as assertNoVar9, assertNoParams as assertNoParams11 } from \"@marko/babel-utils\";\nvar RETURN_IDENTIFIERS = /* @__PURE__ */ new WeakMap();\nvar yield_default = {\n  translate(tag) {\n    assertNoVar9(tag);\n    assertNoParams11(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    flushBefore(tag);\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const [defaultAttr, onNextAttr] = node.attributes;\n    if (!t34.isMarkoAttribute(defaultAttr) || !defaultAttr.default) {\n      throw tag.get(\"name\").buildCodeFrameError(`The '<yield>' tag requires default attribute like '<yield=VALUE>'.`);\n    }\n    if (onNextAttr && onNextAttr.name === \"onnext\") {\n      if (isOutputHTML()) {\n        tag.get(\"attributes\")[1].remove();\n      }\n    }\n    if (node.attributes.length > 1) {\n      const start = node.attributes[1].loc?.start;\n      const end = node.attributes[node.attributes.length - 1].loc?.end;\n      const msg = `The '<yield>' tag only supports a default attribute.`;\n      if (start == null || end == null) {\n        throw tag.get(\"name\").buildCodeFrameError(msg);\n      } else {\n        throw tag.hub.buildError({ loc: { start, end } }, msg, Error);\n      }\n    }\n    let returnId = RETURN_IDENTIFIERS.get(file);\n    if (!returnId) {\n      const program = file.path;\n      RETURN_IDENTIFIERS.set(file, returnId = program.scope.generateDeclaredUidIdentifier(\"return\"));\n      program.pushContainer(\"body\", t34.returnStatement(returnId))[0].skip();\n    }\n    if (isOutputHTML()) {\n      tag.replaceWith(t34.assignmentExpression(\"=\", returnId, defaultAttr.value))[0].skip();\n    }\n  },\n  autocomplete: [\n    {\n      displayText: \"yield=<value>\",\n      description: \"Provides a value for use in a parent template.\",\n      snippet: \"yield=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#yield\"\n    }\n  ]\n};\n\n// src/core/static.ts\nimport { types as t35 } from \"@marko/compiler\";\nimport { parseScript as parseScript3 } from \"@marko/babel-utils\";\nvar static_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^static\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let { body } = parseScript3(file, code, start);\n    if (body.length === 1 && t35.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(t35.markoScriptlet(body, true));\n  },\n  \"parse-options\": {\n    rootOnly: true,\n    rawOpenTag: true,\n    openTagOnly: true,\n    ignoreAttributes: true\n  },\n  autocomplete: [\n    {\n      displayText: \"static <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#static-javascript\"\n    }\n  ]\n};\n\n// src/core/noop.ts\nvar noop_default = {\n  migrate: [(tag) => tag.remove()]\n};\n\n// src/core/__flush_here_and_after__.ts\nvar flush_here_and_after_default = {\n  migrate: [\n    (tag) => {\n      tag.replaceWithMultiple(tag.node.body.body);\n      currentProgramPath.scope.crawl();\n    }\n  ]\n};\n\n// src/core/index.ts\nvar core_default = {\n  taglibId,\n  \"<import>\": import_default,\n  \"<export>\": export_default,\n  \"<attrs>\": attrs_default,\n  \"<if>\": if_default,\n  \"<else-if>\": else_if_default,\n  \"<else>\": else_default,\n  \"<for>\": for_default,\n  \"<let>\": let_default,\n  \"<const>\": const_default,\n  \"<effect>\": effect_default,\n  \"<html-comment>\": html_comment_default,\n  \"<tag>\": tag_default2,\n  \"<set>\": set_default,\n  \"<get>\": get_default,\n  \"<yield>\": yield_default,\n  \"<style>\": style_default,\n  \"<await-reorderer>\": noop_default,\n  \"<init-widgets>\": noop_default,\n  \"<init-components>\": noop_default,\n  \"<static>\": static_default,\n  \"<__flush_here_and_after__>\": flush_here_and_after_default\n};\n\n// src/visitors/referenced-identifier.ts\nimport { types as t36 } from \"@marko/compiler\";\nvar outGlobalIdentifiers = /* @__PURE__ */ new WeakMap();\nvar hasAttrsTag = /* @__PURE__ */ new WeakSet();\nvar referenced_identifier_default = {\n  migrate(identifier) {\n    const { name } = identifier.node;\n    if (identifier.scope.hasBinding(name))\n      return;\n    switch (identifier.node.name) {\n      case \"input\": {\n        if (!hasAttrsTag.has(currentProgramPath)) {\n          hasAttrsTag.add(currentProgramPath);\n          insertAfterStatic(t36.markoTag(t36.stringLiteral(\"attrs\"), void 0, t36.markoTagBody(), void 0, identifier.node));\n        }\n        break;\n      }\n      case \"out\":\n        if (t36.isMemberExpression(identifier.parent) && t36.isIdentifier(identifier.parent.property) && identifier.parent.property.name === \"global\") {\n          let globalIdentifier = outGlobalIdentifiers.get(currentProgramPath);\n          if (!globalIdentifier) {\n            globalIdentifier = currentProgramPath.scope.generateUidIdentifier(\"$global\");\n            outGlobalIdentifiers.set(currentProgramPath, globalIdentifier);\n            insertAfterStatic(t36.markoTag(t36.stringLiteral(\"get\"), void 0, t36.markoTagBody(), void 0, globalIdentifier));\n          }\n          identifier.parentPath.replaceWith(globalIdentifier);\n        } else {\n          throw identifier.buildCodeFrameError(\"Only out.global is supported for compatibility.\");\n        }\n        break;\n    }\n  }\n};\nfunction insertAfterStatic(node) {\n  for (const child of currentProgramPath.get(\"body\")) {\n    if (!isStatic(child)) {\n      child.insertBefore(node);\n      return;\n    }\n  }\n  currentProgramPath.unshiftContainer(\"body\", node);\n}\n\n// src/index.ts\nvar visitors = {\n  Program: program_default,\n  ReferencedIdentifier: referenced_identifier_default,\n  ImportDeclaration: import_declaration_default,\n  MarkoDocumentType: document_type_default,\n  MarkoDeclaration: declaration_default,\n  MarkoCDATA: cdata_default,\n  MarkoText: text_default,\n  MarkoTag: tag_default,\n  MarkoPlaceholder: placeholder_default,\n  MarkoScriptlet: scriptlet_default,\n  MarkoComment: comment_default\n};\nvar getVisitorOfType = (typename) => Object.entries(visitors).reduce((visitor, [name, value]) => {\n  if (typename in value) {\n    visitor[name] = value[typename];\n  }\n  return visitor;\n}, {});\nvar analyze = getVisitorOfType(\"analyze\");\nvar translate = getVisitorOfType(\"translate\");\nvar taglibs = [\n  [\n    __dirname,\n    {\n      ...core_default,\n      migrate: getVisitorOfType(\"migrate\")\n    }\n  ]\n];\nexport {\n  analyze,\n  taglibs,\n  translate\n};\n//# sourceMappingURL=index.esm.js.map\n","import * as fluurtTranslator from \"../../../../../browser-shims/translator\"\n\n<hash-value/files = [{ \n  name:\"index.marko\", \n  path:\"/components/index.marko\", \n  content:\"<let/count=0/>\\n<button onclick() { count++ }>\\n  ${count}\\n</button>\"\n}]/>\n<repl getTranslator() { return fluurtTranslator } files:=files/>","import { register, init } from \"marko/dist/runtime/components/index.js\";\nimport \"../../../components/app-layout/style.css\";\nimport \"../../../components/app-layout/favicon.png\";\nimport \"../../../components/app-layout/components/layout-header/style.css\";\nimport \"../../../logos/marko.svg\";\nimport \"../../../components/app-layout/components/layout-search/style.css\";\nimport \"../../../components/app-layout/components/layout-search/search.png\";\nimport component_0 from \"../../../components/app-layout/components/layout-search/component-browser.js\";\nregister(\"HkYzEWAp\", component_0);\nimport component_1 from \"../../../components/app-layout/components/layout-header/component-browser.js\";\nregister(\"OIKmBXjW\", component_1);\nimport \"../../../components/app-layout/components/layout-sidebar/style.css\";\nimport component_2 from \"../../../components/app-layout/components/layout-sidebar/components/version-switcher/component-browser.js\";\nregister(\"07hv1F0+\", component_2);\nimport component_3 from \"../../../components/app-layout/components/layout-sidebar/component-browser.js\";\nregister(\"mFesaajv\", component_3);\nimport \"../../../components/app-footer/style.css\";\nimport \"../../../components/app-footer/openjsf.png\";\nimport \"../../../components/app-footer/osi.png\";\nimport \"../../../components/app-footer/ebay.svg\";\nimport \"../../../components/discord-link/index.marko.css!=!/Users/mirawlings/dev/marko-js/website/node_modules/@marko/webpack/dist/loader/index.js!/Users/mirawlings/dev/marko-js/website/src/components/discord-link/index.marko?virtual=./index.marko.css\";\nimport \"../../../logos/discord.svg\";\nimport \"./components/playground-6.marko\";\ninit();","module.exports = require(\"../../../../node_modules/@marko/compiler/dist/babel-types\");\n","// We don't bring in the full Marko compiler, but the ast types are needed.\nexports.types = require(\"./dist/babel-types\");\n","module.exports = require(\"../../node_modules/@marko/compiler/modules\");\n","module.exports = require(\"memfs\");\n","module.exports = {\n  env: {},\n  browser: true,\n  cwd() {\n    return \"/\"\n  }\n}"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","id","module","exports","__require","require","isOutputHTML","getMarkoOpts","output","isOutputDOM","currentProgramPath","hub","file","markoOpts","createSortedCollection","compare","insert","data","val","immutable","Array","isArray","arr","len","length","max","pos","mid","compareResult","cur","next","insertInArray","find","findIndex","MARKO_FILE_REG","analyzeTagNameType","tag","extra","node","tagNameType","name","get","isStringLiteral","value","isNativeTag","tagNameNullable","pending","path3","type","nullable","pop","isConditionalExpression","push","alternate","isLogicalExpression","operator","isAssignmentExpression","isBinaryExpression","isTemplateLiteral","isNullLiteral","isIdentifier","binding","scope","getBinding","kind","decl","path","parent","test","source","specifiers","some","it","t","bindingTag","isMarkoTag","bindingTagName","defaultAttr","assignments","constantViolations","i","assignment","tagNameDynamic","startSection","sectionId","programExtra","sectionNameNode","sectionName","nextSectionId","sectionNames","generateUid","getOrCreateSectionId","parentPath","getSectionId","currentPath","createSectionState","key","init","arrayOfSectionData","state","forEachSectionId","fn","getReservesByType","reserveScope","size","reserve","reserve2","reservesByType","compareReserves","a","b","insertReserve","getReferenceGroups","index","count","references","apply","t2","hydrate","trackReferencesForBindings","reserveType","bindings","getBindingIdentifiers","referencePaths","insertReferenceGroup","reference","fnRoot","getFnRoot","exprRoot","getExprRoot","markoRoot","name2","isMarkoAttribute","default","updateReferenceGroup","listKey","extraKey","newBinding","currentGroup","newReferences","getOrCreateReferenceGroup","mergeReferenceGroups","groupEntries","group","newGroup","referenceGroups","existingGroup","findReferenceGroup","curPath","isMarkoPath","isProgram","isFunctionExpression","lenDelta","getReferenceGroup","lookup","analyze2","found","generateReferenceGroupName","replace","ref","importRuntime","importNamed","getRuntimePath","callRuntime","args","t3","filter","Boolean","getHTMLRuntime","optimize","callRead","targetSectionId","getScopeExpression","diff","scopeIdentifier","getApplyStatements","getHydrateStatements","getQueueBuilder","_setQueueBuilder","setQueueBuilder","builder","addStatement","statement","statementsIndex","allStatements","statements","getHydrateRegisterId","opts","filename","getTemplateId","getClosurePriorities","addHTMLHydrateCall","writeHTMLHydrateStatements","unshiftContainer","t4","refs","pushContainer","reduce","acc","bindFunctionsVisitor","FunctionExpression","exit","bindFunction","ArrowFunctionExpression","root","functionIdentifier","generateUidIdentifier","body","unshift","map","insertBefore","params","replaceWith","getDefaultApply","firstApplyStatements","toTemplateOrStringLiteral","parts","strs","exprs","curStr","content","t5","nextIndex","exprLen","expressions","shiftItems","quasis","j","raw","appendLiteral","str","list","start","offset","getWalks","getWalkComment","getSteps","walkCodeToName","enter","enterShallow","visit","buildCodeFrameError","steps","walks","walkComment","writeTo","t6","walkString","walks2","depth","step","lastIndexOf","current","walk","nCodeString","String","fromCharCode","number","toCharString","startCode","rangeSize","result","multiplier","Math","floor","getWalkString","walkLiteral","leadingComments","join","getRenderer","t7","getWrites","exprsLen","writes","consumeHTML","flushBefore","expr","skip","flushInto","target","getSectionMeta","isStatic","isImportDeclaration","isExportDeclaration","isMarkoScriptlet","static","html_default","translate","program","renderContent","child","replaceWithMultiple","remove","rendererId","attrs","t8","var","dom_default","templateIdentifier","t9","walksIdentifier","applyIdentifier","applyAttrsIdentifier","forEachSectionIdReverse","referenceGroup","identifier","fnPath","traverse","writeHydrateGroups","numReferenceGroups","queuePriority","factory","closurePriority","NaN","param","closurePriorities","writeApplyGroups","childRendererDeclarators","childSectionId","writes2","apply2","exportSpecifiers","Object","bindingIdentifier","applyIdentifier2","exportIdentifier","previousProgramPath","WeakMap","program_default","migrate","set","crawl","analyze","curIndex","reserves","allReferenceGroups","g","forEach","finalizeReferences","t10","hasInteractiveChild","isInteractive","import_declaration_default","request","resolveTagImport","document_type_default","documentType","declaration_default","declaration","cdata_default","cdata","text_default","text","enter2","modulePlugin","plugin","isModulePlugin","isFunctionPlugin","t11","exit2","IDENTIFIER_REG","toPropertyName","t12","attrsToObject","withRenderBody","t13","resultExtra","attr","attributes","properties","hoistedControlFlows","isConditional","isLoop","prop","argument","getRenderBodyProp","attrsObject","lastProp","translateVar","initialValue","tagVar","t14","evaluate","confident","computed","native_tag_default","has","isSpreadAttr","attrNode","startsWith","isHTML","tagDef","getTagDef","hasSpread","isMarkoSpreadAttribute","write","visitIndex","t15","attrsCallExpr","extra2","valueReferences","helper","slice","emptyBody","parseOptions","openTagOnly","htmlType","custom_tag_default","trackReferences","getTagDef2","template","childProgramExtra","loadFileForTag","ast","attrsReferences","tagSectionId","tagBody","tagBodySectionId","tagIdentifier","tagAttrsIdentifier","t16","tagName","tags","metadata","marko","relativePath","resolveRelativePath","childProgram","importDefault","importNamed2","childIndex","injectWalks","includes","renderBodyProp","renderBodyId","renderTagExpr","callExpression","renderBodyPath","callStatement","toFirstExpressionOrBlock","nodes","t17","expression","dynamic_tag_default","t18","fnExpr","dynamicTagExpr","attribute_tag_default","hasPendingHTML","assertNoVar","parentTag","findParentTag","parentExtra","attrName","info","nestedAttributeTags","t19","dynamic","repeated","existingAttr","analyzeAttributeTags","analyzeChildren","rootExtra","hasAttributeTags","analyzeChild","isTransparentTag","isLoopTag","isAttributeTag","existing","tag_default","hook","getTagDef3","analyzer","assertNoArgs","translator","watchFiles","arguments","modifier","isNativeTag2","tagNameId","tagNameVarPath","t20","taglibId","isCoreTag","getTagDef4","isCoreTagName","ESCAPE_TYPES","script","style","placeholder_default","placeholder","escape","prev","getPrevSibling","noOutput","t21","isNativeTag3","needsMarker","getNextSibling","canWriteHTML","method","getParentTagName","scriptlet_default","scriptlet","bodyReferences","ieConditionalCommentRegExp","comment_default","comment","import_default","parse","parseScript","rawValue","rootOnly","rawOpenTag","ignoreAttributes","relaxRequireCommas","autocomplete","displayText","description","snippet","descriptionMoreURL","export_default","parseScript2","attrs_default","varPath","toFirstStatementOrBlock","t22","if_default","exitBranchAnalyze","testAttr","assertNoVar2","assertNoParams","t23","loc","end","msg","buildError","exitBranchTranslate","BRANCHES_LOOKUP","getBranches","bodySectionId","branches","nextTag","isLast","conditionalReferences","tag2","sectionId2","curStatement","else_if_default","assertNoVar3","assertNoParams2","t24","else_default","assertNoVar4","assertNoParams3","assertNoSpreadAttrs","assertNoBodyContent","const_default","assertNoParams4","t25","identifiers","values","effect_default","assertNoParams5","t26","cleanupIndex","inlineStatements","node2","for_default","isOnlyChild","t27","getTagDef5","html","checkOnlyChild","hasParams","assertNoVar5","findName","assertAllowedAttributes","validateFor","translateHTML","translateDOM","of","in","to","from","ofAttr","byAttr","ofAttrValue","valParam","namePath","inAttr","fromAttr","toAttr","block","forNode","keyParam","loopParam","indexName","generateUidIdentifierBasedOnNode","stepAttr","stepValue","indexParam","stepsName","stepName","concat","obj","get_default","assertNoParams6","refId","t28","defaultAttrValue","relativeReferencePath","resolveTagImport2","getTemplateId2","html_comment_default","assertNoVar6","assertNoParams7","assertNoAttributes","assertNoAttributeTags","let_default","assertNoParams8","t30","isUpdateExpression","t29","right","replaceAssignments","callQueue","set_default","t31","assertNoParams9","assertNoVar7","insertAfter","style_default","assertNoVar8","assertNoParams10","base","path2","sourceFileName","typeAttr","typeValue","markoText","isMarkoText","resolveVirtualDependency","importPath","startPos","endPos","virtualPath","t32","enum","tag_default2","t33","RETURN_IDENTIFIERS","noop_default","core_default","assertNoVar9","assertNoParams11","onNextAttr","t34","returnId","generateDeclaredUidIdentifier","trim","parseScript3","t35","outGlobalIdentifiers","hasAttrsTag","WeakSet","insertAfterStatic","visitors","Program","ReferencedIdentifier","hasBinding","add","t36","property","globalIdentifier","ImportDeclaration","MarkoDocumentType","MarkoDeclaration","MarkoCDATA","MarkoText","MarkoTag","MarkoPlaceholder","MarkoScriptlet","MarkoComment","getVisitorOfType","typename","entries","visitor","taglibs","files","fluurtTranslator","register","types","env","browser","cwd"],"sourceRoot":""}