{"version":3,"file":"136.da03a50b.js","mappings":"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","sources":["webpack:///../src/index.ts","webpack:///../src/util/is-core-tag.ts","webpack:///../src/visitors/program/index.ts","webpack:///../src/util/marko-config.ts","webpack:///../src/util/get-root.ts","webpack:///../src/util/optional.ts","webpack:///../src/util/reserve.ts","webpack:///../src/util/sections.ts","webpack:///../src/util/tag-name-type.ts","webpack:///../src/util/with-previous-location.ts","webpack:///../src/util/references.ts","webpack:///../src/util/runtime.ts","webpack:///../../runtime-tags/src/html/content.ts","webpack:///../../runtime-tags/src/common/helpers.ts","webpack:///../../runtime-tags/src/html/attrs.ts","webpack:///../../runtime-tags/src/html/serializer.ts","webpack:///../../runtime-tags/src/html/writer.ts","webpack:///../../runtime-tags/src/html/reorder-runtime.ts","webpack:///../src/util/scope-read.ts","webpack:///../src/visitors/program/dom.ts","webpack:///../src/util/signals.ts","webpack:///../src/core/return.ts","webpack:///../src/util/assert.ts","webpack:///../src/util/writer.ts","webpack:///../src/util/to-template-string-or-literal.ts","webpack:///../src/util/walks.ts","webpack:///../src/visitors/program/html.ts","webpack:///../src/util/is-static.ts","webpack:///../src/core/__flush_here_and_after__.ts","webpack:///../src/core/attrs.ts","webpack:///../src/core/condition/else.ts","webpack:///../src/visitors/tag/custom-tag.ts","webpack:///../src/util/attrs-to-object.ts","webpack:///../src/util/to-property-name.ts","webpack:///../src/util/translate-var.ts","webpack:///../src/core/condition/if.ts","webpack:///../src/util/nested-attribute-tags.ts","webpack:///../src/util/to-first-statement-or-block.ts","webpack:///../src/core/condition/else-if.ts","webpack:///../src/core/const.ts","webpack:///../src/core/define.ts","webpack:///../src/core/effect.ts","webpack:///../src/core/export.ts","webpack:///../src/core/for.ts","webpack:///../src/core/html-comment.ts","webpack:///../src/core/id.ts","webpack:///../src/core/import.ts","webpack:///../src/core/let.ts","webpack:///../src/util/replace-assignments.ts","webpack:///../src/core/lifecycle.ts","webpack:///../src/core/noop.ts","webpack:///../src/core/static.ts","webpack:///../src/core/style.ts","webpack:///../src/core/index.ts","webpack:///../src/visitors/assignment-expression.ts","webpack:///../src/visitors/cdata.ts","webpack:///../src/visitors/comment.ts","webpack:///../src/visitors/declaration.ts","webpack:///../src/visitors/document-type.ts","webpack:///../src/visitors/function.ts","webpack:///../src/visitors/import-declaration.ts","webpack:///../src/visitors/placeholder.ts","webpack:///../src/util/evaluate.ts","webpack:///../src/visitors/referenced-identifier.ts","webpack:///../src/visitors/scriptlet.ts","webpack:///../src/visitors/tag/index.ts","webpack:///../src/util/plugin-hooks.ts","webpack:///../src/visitors/tag/attribute-tag.ts","webpack:///../src/visitors/tag/dynamic-tag.ts","webpack:///../src/util/to-first-expression-or-block.ts","webpack:///../src/visitors/tag/native-tag.ts","webpack:///../src/visitors/text.ts","webpack:///../src/visitors/update-expression.ts"],"sourcesContent":["import type { types as t } from \"@marko/compiler\";\nimport coreTagLib from \"./core\";\nimport AssignmentExpression from \"./visitors/assignment-expression\";\nimport MarkoCDATA from \"./visitors/cdata\";\nimport MarkoComment from \"./visitors/comment\";\nimport MarkoDeclaration from \"./visitors/declaration\";\nimport MarkoDocumentType from \"./visitors/document-type\";\nimport Function from \"./visitors/function\";\nimport ImportDeclaration from \"./visitors/import-declaration\";\nimport MarkoPlaceholder from \"./visitors/placeholder\";\nimport Program from \"./visitors/program\";\nimport ReferencedIdentifier from \"./visitors/referenced-identifier\";\nimport MarkoScriptlet from \"./visitors/scriptlet\";\nimport MarkoTag from \"./visitors/tag\";\nimport MarkoText from \"./visitors/text\";\nimport UpdateExpression from \"./visitors/update-expression\";\n\nconst visitors = {\n  Program,\n  Function,\n  AssignmentExpression,\n  UpdateExpression,\n  ReferencedIdentifier,\n  ImportDeclaration,\n  MarkoDocumentType,\n  MarkoDeclaration,\n  MarkoCDATA,\n  MarkoText,\n  MarkoTag,\n  MarkoPlaceholder,\n  MarkoScriptlet,\n  MarkoComment,\n};\n\nconst getVisitorOfType = (\n  typename: \"migrate\" | \"analyze\" | \"translate\",\n): t.Visitor =>\n  Object.entries(visitors).reduce((visitor, [name, value]) => {\n    if (typename in value) {\n      visitor[name as any] = (value as any)[typename];\n    }\n    return visitor;\n  }, {} as t.Visitor);\n\nexport const analyze = getVisitorOfType(\"analyze\");\nexport const translate = getVisitorOfType(\"translate\");\nexport const taglibs = [\n  [\n    __dirname,\n    {\n      ...coreTagLib,\n      migrate: getVisitorOfType(\"migrate\"),\n    },\n  ],\n];\n\n/* eslint-disable @typescript-eslint/no-empty-interface */\ndeclare module \"@marko/compiler/dist/types\" {\n  // This is extended by individual helpers.\n  export interface ProgramExtra {}\n  export interface FunctionExpressionExtra {}\n  export interface ArrowFunctionExpressionExtra {}\n  export interface MarkoTagExtra {}\n  export interface MarkoTagBodyExtra {}\n  export interface MarkoAttributeExtra {}\n  export interface MarkoSpreadAttributeExtra {}\n  export interface MarkoPlaceholderExtra {}\n\n  export interface Program {\n    extra: ProgramExtra & NodeExtra;\n  }\n\n  export interface FunctionExpression {\n    extra?: FunctionExpressionExtra & NodeExtra;\n  }\n\n  export interface ArrowFunctionExpression {\n    extra?: ArrowFunctionExpressionExtra & NodeExtra;\n  }\n\n  export interface MarkoTag {\n    extra?: MarkoTagExtra & NodeExtra;\n  }\n\n  export interface MarkoTagBody {\n    extra?: MarkoTagBodyExtra & NodeExtra;\n  }\n\n  export interface MarkoAttribute {\n    extra?: MarkoAttributeExtra & NodeExtra;\n  }\n\n  export interface MarkoSpreadAttribute {\n    extra?: MarkoSpreadAttributeExtra & NodeExtra;\n  }\n\n  export interface MarkoPlaceholder {\n    extra?: MarkoPlaceholderExtra & NodeExtra;\n  }\n}\n","import { getTagDef } from \"@marko/babel-utils\";\nimport type { types as t } from \"@marko/compiler\";\nexport const taglibId = \"marko-core\";\n\nexport function isCoreTag(\n  tag: t.NodePath,\n): tag is t.NodePath<t.MarkoTag & { name: t.StringLiteral }> {\n  return tag.isMarkoTag() && getTagDef(tag)?.taglibId === taglibId;\n}\n\nexport function isCoreTagName(tag: t.NodePath, name: string) {\n  return isCoreTag(tag) && tag.node.name.value === name;\n}\n","import { types as t } from \"@marko/compiler\";\nimport {\n  getMarkoOpts,\n  isOutputDOM,\n  isOutputHTML,\n} from \"../../util/marko-config\";\nimport { finalizeIntersections } from \"../../util/references\";\nimport { assignFinalIds } from \"../../util/reserve\";\nimport { callRuntime } from \"../../util/runtime\";\nimport { startSection } from \"../../util/sections\";\nimport programDOM from \"./dom\";\nimport programHTML from \"./html\";\n\nexport let currentProgramPath: t.NodePath<t.Program>;\nexport let scopeIdentifier: t.Identifier;\nexport let cleanIdentifier: t.Identifier;\n\nconst previousProgramPath: WeakMap<\n  t.NodePath<t.Program>,\n  t.NodePath<t.Program> | undefined\n> = new WeakMap();\n\nexport default {\n  migrate: {\n    enter(program: t.NodePath<t.Program>) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n    },\n    exit() {\n      currentProgramPath.scope.crawl();\n      currentProgramPath = previousProgramPath.get(currentProgramPath)!;\n    },\n  },\n  analyze: {\n    enter(program: t.NodePath<t.Program>) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      startSection(program);\n    },\n\n    exit() {\n      assignFinalIds();\n      finalizeIntersections();\n      currentProgramPath = previousProgramPath.get(currentProgramPath)!;\n    },\n  },\n  translate: {\n    enter(program: t.NodePath<t.Program>) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      scopeIdentifier = isOutputDOM()\n        ? program.scope.generateUidIdentifier(\"scope\")\n        : (null as any as t.Identifier);\n      cleanIdentifier = isOutputDOM()\n        ? program.scope.generateUidIdentifier(\"clean\")\n        : (null as any as t.Identifier);\n      if (getMarkoOpts().output === (\"hydrate\" as \"html\")) {\n        program.skip();\n        program.node.body = [\n          t.importDeclaration(\n            [],\n            t.stringLiteral(program.hub.file.opts.filename as string),\n          ),\n        ];\n        if (\n          program.node.extra.hasInteractiveChild ||\n          program.node.extra.isInteractive\n        ) {\n          program.node.body.push(t.expressionStatement(callRuntime(\"init\")));\n        }\n        return;\n      }\n    },\n    exit(program: t.NodePath<t.Program>) {\n      if (isOutputHTML()) {\n        programHTML.translate.exit(program);\n      } else {\n        programDOM.translate.exit(program);\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath)!;\n    },\n  },\n};\n","import { currentProgramPath } from \"../visitors/program\";\n\nexport function isOutputHTML() {\n  return getMarkoOpts().output === \"html\";\n}\n\nexport function isOutputDOM() {\n  return !isOutputHTML();\n}\n\nexport function getMarkoOpts() {\n  return currentProgramPath.hub.file.markoOpts;\n}\n\nexport function isOptimize() {\n  return getMarkoOpts().optimize;\n}\n","import type { types as t } from \"@marko/compiler\";\nimport type { References } from \"./references\";\ntype MarkoExprRootPath = t.NodePath<\n  | t.MarkoTag\n  | t.MarkoTagBody\n  | t.MarkoAttribute\n  | t.MarkoSpreadAttribute\n  | t.MarkoPlaceholder\n>;\n\nexport function getExprRoot(path: t.NodePath<t.Node>) {\n  let curPath = path;\n  while (!isMarko(curPath.parentPath!)) {\n    curPath = curPath.parentPath!;\n  }\n\n  return curPath as t.NodePath<\n    t.Node & {\n      extra?: {\n        references?: References;\n      };\n    }\n  > & {\n    parentPath: MarkoExprRootPath;\n  };\n}\n\nexport function getFnRoot(path: t.NodePath<t.Node>) {\n  let curPath = path;\n  if (curPath.isProgram()) return;\n\n  while (!isFunctionExpression(curPath)) {\n    if (isMarko(curPath)) return;\n    curPath = (curPath as t.NodePath<t.Node>).parentPath!;\n  }\n\n  return curPath as\n    | undefined\n    | t.NodePath<\n        (t.FunctionExpression | t.ArrowFunctionExpression) & {\n          extra?: {\n            references?: References;\n          };\n        }\n      >;\n}\n\nfunction isMarko(path: t.NodePath<any>): path is MarkoExprRootPath {\n  switch (path.type) {\n    case \"MarkoTag\":\n    case \"MarkoTagBody\":\n    case \"MarkoAttribute\":\n    case \"MarkoSpreadAttribute\":\n    case \"MarkoPlaceholder\":\n    case \"MarkoScriptlet\":\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction isFunctionExpression(\n  path: t.NodePath<any>,\n): path is t.NodePath<t.FunctionExpression | t.ArrowFunctionExpression> {\n  switch (path.type) {\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\n","export type Many<T> = [T, T, ...T[]];\nexport type OneMany<T> = T | Many<T>;\nexport type Opt<T> = undefined | OneMany<T>;\nexport type Compare<T> = (a: T, b: T) => number;\nexport class Sorted<T> {\n  constructor(public compare: Compare<T>) {}\n  add(data: Opt<T>, item: T): OneMany<T> {\n    return data\n      ? Array.isArray(data)\n        ? (addSorted(this.compare, data, item) as Many<T>)\n        : joinRepeatable(this.compare, data, item)\n      : item;\n  }\n\n  union(a: Opt<T>, b: Opt<T>): Opt<T> {\n    if (a) {\n      if (Array.isArray(a)) {\n        if (b) {\n          if (Array.isArray(b)) {\n            return unionSortedRepeatable(this.compare, a, b);\n          } else {\n            return addSorted(this.compare, a, b) as OneMany<T>;\n          }\n        }\n\n        return a;\n      }\n\n      if (b) {\n        if (Array.isArray(b)) {\n          return addSorted(this.compare, b, a) as Many<T>;\n        }\n\n        return joinRepeatable(this.compare, b, a);\n      }\n\n      return a;\n    }\n\n    return b;\n  }\n  find(data: Opt<T>, item: T): T | undefined {\n    if (data) {\n      if (Array.isArray(data)) {\n        return findSorted(this.compare, data, item);\n      } else if (this.compare(data, item) === 0) {\n        return data;\n      }\n    }\n  }\n}\n\nexport function push<T>(data: Opt<T>, item: T): Opt<T> {\n  if (data) {\n    if (Array.isArray(data)) {\n      data.push(item);\n      return data;\n    }\n\n    return [data, item];\n  }\n\n  return item;\n}\n\nexport function size<T>(data: Opt<T>) {\n  return data ? (Array.isArray(data) ? data.length : 1) : 0;\n}\n\nexport function filter<T>(data: Opt<T>, cb: (item: T) => boolean): Opt<T> {\n  if (data) {\n    if (Array.isArray(data)) {\n      const len = data.length;\n      let result: Opt<T>;\n      let i = 0;\n\n      while (i < len) {\n        let item = data[i++];\n\n        if (cb(item)) {\n          result = item;\n\n          while (i < len) {\n            item = data[i++];\n\n            if (cb(item)) {\n              result = [result, item];\n\n              while (i < len) {\n                item = data[i++];\n\n                if (cb(item)) {\n                  result.push(item);\n                }\n              }\n\n              return result;\n            }\n          }\n\n          return result;\n        }\n      }\n\n      return result;\n    }\n\n    if (cb(data)) {\n      return data;\n    }\n  }\n\n  return undefined;\n}\n\nexport function forEach<T>(data: Opt<T>, cb: (item: T) => void): void {\n  if (data) {\n    if (Array.isArray(data)) {\n      for (const item of data) {\n        cb(item);\n      }\n    } else {\n      cb(data);\n    }\n  }\n}\n\nexport function findSorted<T>(\n  compare: Compare<T>,\n  data: T[],\n  item: T,\n): T | undefined {\n  let max = data.length;\n  let pos = 0;\n\n  while (pos < max) {\n    const mid = (pos + max) >>> 1;\n    const cur = data[mid];\n    const compareResult = compare(cur, item);\n    if (compareResult === 0) return cur;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n}\n\nexport function addSorted<T>(compare: Compare<T>, data: T[], item: T): T[] {\n  const len = data.length;\n  let max = len;\n  let pos = 0;\n\n  while (pos < max) {\n    const mid = (pos + max) >>> 1;\n    const compareResult = compare(data[mid], item);\n    if (compareResult === 0) return data;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n\n  const result = new Array(len + 1) as Many<T>;\n  for (let i = 0; i < pos; i++) {\n    result[i] = data[i];\n  }\n\n  let cur = item;\n  while (pos < len) {\n    const next = cur;\n    cur = data[pos];\n    result[pos++] = next;\n  }\n\n  result[len] = cur;\n\n  return result;\n}\n\nfunction unionSortedRepeatable<T>(\n  compare: Compare<T>,\n  a: Many<T>,\n  b: Many<T>,\n): Many<T> {\n  const aLen = a.length;\n  const bLen = b.length;\n  let aIndex = 0;\n  let bIndex = 0;\n\n  // Since both sides are Repeated<T> we can safely assume that the first 2 elements are present in either array.\n  const result: Many<T> = [\n    compare(a[aIndex], b[bIndex]) <= 0 ? a[aIndex++] : b[bIndex++],\n    compare(a[aIndex], b[bIndex]) <= 0 ? a[aIndex++] : b[bIndex++],\n  ];\n\n  while (aIndex < aLen && bIndex < bLen) {\n    result.push(compare(a[aIndex], b[bIndex]) <= 0 ? a[aIndex++] : b[bIndex++]);\n  }\n\n  if (aLen === bLen && aIndex === aLen) {\n    // If the arrays are the same length and we consumed all of `a` then the data\n    // is the same and we return `a` the original array.\n    return a;\n  }\n\n  while (aIndex < aLen) {\n    result.push(a[aIndex++]);\n  }\n\n  while (bIndex < bLen) {\n    result.push(b[bIndex++]);\n  }\n\n  return result;\n}\n\nfunction joinRepeatable<T>(compare: Compare<T>, a: T, b: T): OneMany<T> {\n  const compareResult = compare(a, b);\n  return compareResult === 0 ? a : compareResult < 0 ? [a, b] : [b, a];\n}\n","import { types as t } from \"@marko/compiler\";\nimport { isOptimize } from \"./marko-config\";\nimport { Sorted } from \"./optional\";\nimport { type Section, createSectionState, forEachSection } from \"./sections\";\n\nconst [getReservesByType] = createSectionState<Array<Reserve[] | undefined>>(\n  \"reservesByType\",\n  () => [undefined, undefined, undefined],\n);\n\nexport enum ReserveType {\n  Visit = 0,\n  Store = 1,\n}\n\nexport interface Reserve {\n  type: ReserveType;\n  section: Section;\n  debugKey: string;\n  name: string;\n  id: number;\n}\n\ndeclare module \"@marko/compiler/dist/types\" {\n  export interface NodeExtra {\n    reserve?: Reserve;\n  }\n\n  export interface MarkoTagBodyExtra {\n    section?: Section;\n  }\n}\n\nexport function reserveScope(\n  type: ReserveType,\n  section: Section,\n  node:\n    | t.MarkoTag\n    | t.MarkoAttribute\n    | t.MarkoPlaceholder\n    | t.Identifier\n    | t.MarkoTagBody,\n  name: string,\n  debugKey: string = name,\n): Reserve {\n  const extra = (node.extra ??= {});\n\n  if (extra.reserve) {\n    const reserve = extra.reserve as Reserve;\n    reserve.name += \"_\" + name;\n    return reserve;\n  }\n\n  const reservesByType = getReservesByType(section);\n  const reserve = (extra.reserve = {\n    id: 0,\n    type,\n    name,\n    debugKey,\n    section,\n  });\n\n  if (reservesByType[type]) {\n    reserve.id = reservesByType[type]!.push(reserve) - 1;\n  } else {\n    reservesByType[type] = [reserve];\n  }\n\n  return reserve;\n}\n\nexport function assignFinalIds() {\n  forEachSection((section) => {\n    let curIndex = 0;\n    for (const reserves of getReservesByType(section)) {\n      if (reserves) {\n        for (const reserve of reserves) {\n          reserve.id = curIndex;\n          curIndex += 1;\n        }\n      }\n    }\n  });\n}\n\nexport function getScopeAccessorLiteral(reserve: Reserve) {\n  if (isOptimize()) {\n    return t.numericLiteral(reserve.id);\n  }\n\n  return t.stringLiteral(\n    reserve.debugKey +\n      (reserve.type === ReserveType.Visit ? `/${reserve.id}` : \"\"),\n  );\n}\n\nexport const reserveUtil = new Sorted(function compareReserves(\n  a: Reserve,\n  b: Reserve,\n) {\n  return a.section.id - b.section.id || a.type - b.type || a.id - b.id;\n});\n","import {\n  isAttributeTag,\n  isNativeTag,\n  loadFileForTag,\n} from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { currentProgramPath } from \"../visitors/program\";\nimport type { Reserve } from \"./reserve\";\nimport analyzeTagNameType, { TagNameType } from \"./tag-name-type\";\n\nexport enum ContentType {\n  Static,\n  Dynamic,\n  Empty,\n}\n\nexport type Section = {\n  id: number;\n  name: string;\n  depth: number;\n  parent?: Section;\n  closures?: Reserve[];\n  startNodeContentType: ContentType;\n  endNodeContentType: ContentType;\n};\n\ndeclare module \"@marko/compiler/dist/types\" {\n  export interface ProgramExtra {\n    section?: Section;\n    sections?: Section[];\n  }\n\n  export interface MarkoTagBodyExtra {\n    section?: Section;\n  }\n}\n\nexport function startSection(\n  path: t.NodePath<t.MarkoTagBody | t.Program>,\n): Section {\n  const extra = (path.node.extra ??= {});\n  let section = extra.section;\n\n  if (!section) {\n    const parentSection = path.parentPath\n      ? getOrCreateSection(path.parentPath)\n      : undefined;\n    const sectionNamePath = (path.parentPath as t.NodePath<t.MarkoTag>)?.get(\n      \"name\",\n    );\n    const sectionName = path.isProgram()\n      ? \"\"\n      : currentProgramPath.scope.generateUid(\n          sectionNamePath.toString() + \"Body\",\n        );\n    const programExtra = (path.hub.file.path.node.extra ??= {});\n    const sections = (programExtra.sections ??= []);\n    section = extra.section = {\n      id: sections.length,\n      name: sectionName,\n      depth: parentSection ? parentSection.depth + 1 : 0,\n      parent: parentSection,\n      startNodeContentType: getStartNodeContentType(path),\n      endNodeContentType: getEndNodeContentType(path),\n    };\n    sections.push(section);\n  }\n\n  return section;\n}\n\nexport function getOrCreateSection(path: t.NodePath<any>) {\n  let cur = path;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (\n      cur.type === \"Program\" ||\n      (cur.type === \"MarkoTagBody\" &&\n        analyzeTagNameType(cur.parentPath as t.NodePath<t.MarkoTag>) !==\n          TagNameType.NativeTag)\n    ) {\n      return startSection(cur);\n    }\n\n    cur = cur.parentPath!;\n  }\n}\n\nexport function getSection(path: t.NodePath) {\n  let section: Section;\n  let currentPath = path;\n  while ((section = currentPath.node.extra?.section as Section) === undefined) {\n    currentPath = currentPath.parentPath!;\n  }\n\n  _setSectionPath(\n    section,\n    currentPath as t.NodePath<t.MarkoTagBody | t.Program>,\n  );\n  return section;\n}\n\nexport function getParentSection(path: t.NodePath) {\n  return getSection(path.parentPath!);\n}\n\nexport function createSectionState<T = unknown>(\n  key: string,\n  init?: ((section: Section) => T) | (() => T),\n) {\n  return [\n    (section: Section): T => {\n      const arrayOfSectionData = (currentProgramPath.state[key] ??= {});\n      const sectionData = (arrayOfSectionData[section.id] ??=\n        init && init(section));\n      return sectionData as T;\n    },\n    (section: Section, value: T): void => {\n      const arrayOfSectionData = (currentProgramPath.state[key] ??= {});\n      arrayOfSectionData[section.id] = value;\n    },\n  ] as const;\n}\n\nexport const [getScopeIdIdentifier] = createSectionState<t.Identifier>(\n  \"scopeIdIdentifier\",\n  (section) =>\n    currentProgramPath.scope.generateUidIdentifier(`scope${section.id}_id`),\n);\n\nconst [getSectionPath, _setSectionPath] =\n  createSectionState<t.NodePath<t.MarkoTagBody | t.Program>>(\"sectionPath\");\nexport { getSectionPath };\n\nconst [_getScopeIdentifier] = createSectionState<t.Identifier>(\n  \"scopeIdentifier\",\n  () => t.identifier(\"undefined\"),\n);\n\nexport const getScopeIdentifier = (\n  section: Section,\n  ignoreDefault?: boolean,\n) => {\n  const scopeId = _getScopeIdentifier(section);\n  if (!ignoreDefault && scopeId.name === \"undefined\") {\n    scopeId.name = currentProgramPath.scope.generateUid(`scope${section.id}_`);\n  }\n  return scopeId;\n};\n\nexport function forEachSection(fn: (section: Section) => void) {\n  const { sections } = currentProgramPath.node.extra;\n  sections?.forEach(fn);\n}\n\nexport function forEachSectionReverse(fn: (section: Section) => void) {\n  const { sections } = currentProgramPath.node.extra;\n  for (let i = sections!.length; i--; ) {\n    fn(sections![i]);\n  }\n}\n\nfunction getStartNodeContentType(path: t.NodePath<t.Program | t.MarkoTagBody>) {\n  for (const child of path.get(\"body\")) {\n    const contentType = getNodeContentType(child, \"startNodeContentType\");\n    if (contentType !== ContentType.Empty) {\n      return contentType;\n    }\n  }\n  return ContentType.Empty;\n}\n\nfunction getEndNodeContentType(path: t.NodePath<t.Program | t.MarkoTagBody>) {\n  const body = path.get(\"body\");\n  for (let i = body.length; i--; ) {\n    const contentType = getNodeContentType(body[i], \"endNodeContentType\");\n    if (contentType !== ContentType.Empty) {\n      return contentType;\n    }\n  }\n  return ContentType.Empty;\n}\n\n/**\n * @returns null if the node should be skipped\n */\nfunction getNodeContentType(\n  path: t.NodePath<t.Statement>,\n  extraMember: \"startNodeContentType\" | \"endNodeContentType\",\n) {\n  if (\n    t.isMarkoText(path) ||\n    t.isMarkoComment(path) ||\n    t.isMarkoPlaceholder(path) ||\n    t.isMarkoCDATA(path)\n  ) {\n    return ContentType.Static;\n  }\n  if (t.isMarkoScriptlet(path)) {\n    return ContentType.Empty;\n  }\n  if (t.isMarkoTag(path.node)) {\n    const tag = path as t.NodePath<t.MarkoTag>;\n    if (isNativeTag(tag)) {\n      return ContentType.Static;\n    }\n    if (isAttributeTag(tag)) {\n      return ContentType.Empty;\n    }\n    if (t.isStringLiteral(path.node.name)) {\n      switch (path.node.name.value) {\n        case \"let\":\n        case \"const\":\n        case \"attrs\":\n        case \"effect\":\n        case \"lifecycle\":\n        case \"return\":\n        case \"id\":\n        case \"define\":\n          return ContentType.Empty;\n      }\n      const tagSection = loadFileForTag(tag)?.ast.program.extra.section;\n      if (tagSection) {\n        return tagSection[extraMember] ?? ContentType.Empty;\n      }\n    }\n  }\n  return ContentType.Dynamic;\n}\n","import {\n  isNativeTag,\n  loadFileForTag,\n  resolveTagImport,\n} from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport type { MarkoTagExtra } from \"@marko/compiler/babel-types\";\nimport withPreviousLocation from \"./with-previous-location\";\n\ndeclare module \"@marko/compiler/dist/types\" {\n  export interface MarkoTagExtra {\n    tagNameType?: TagNameType;\n    tagNameNullable?: boolean;\n    tagNameDynamic?: boolean;\n    tagNameImported?: string;\n    tagNameDefine?: boolean;\n  }\n}\n\nexport enum TagNameType {\n  NativeTag,\n  CustomTag,\n  DynamicTag,\n  AttributeTag,\n}\n\nconst MARKO_FILE_REG = /^<.*>$|\\.marko$/;\n\nexport default function analyzeTagNameType(tag: t.NodePath<t.MarkoTag>) {\n  const extra = (tag.node.extra ??= {});\n\n  if (extra.tagNameType === undefined) {\n    const name = tag.get(\"name\");\n\n    if (name.isStringLiteral()) {\n      extra.tagNameType =\n        name.node.value[0] === \"@\"\n          ? TagNameType.AttributeTag\n          : isNativeTag(tag)\n            ? TagNameType.NativeTag\n            : TagNameType.CustomTag;\n\n      if (extra.tagNameType === TagNameType.CustomTag) {\n        if (\n          t.isValidIdentifier(name.node.value) &&\n          tag.scope.hasBinding(name.node.value)\n        ) {\n          const tagIdentifier = withPreviousLocation(\n            t.identifier(name.node.value),\n            name.node,\n          );\n          tagIdentifier.extra = {\n            references: tag.scope.getBinding(name.node.value)?.identifier?.extra\n              ?.reserve,\n          };\n          analyzeExpressionTagName(name.replaceWith(tagIdentifier)[0], extra);\n        } else {\n          const childFile = loadFileForTag(tag);\n          const childProgram = childFile?.ast.program;\n          if (childProgram?.extra!.___featureType === \"class\") {\n            extra.tagNameType = TagNameType.DynamicTag;\n            extra.___featureType = \"class\";\n          }\n        }\n      }\n\n      extra.tagNameNullable = extra.tagNameNullable = false;\n    } else {\n      analyzeExpressionTagName(name, extra);\n    }\n\n    if (extra.tagNameType === undefined) {\n      extra.tagNameType = TagNameType.DynamicTag;\n    }\n  }\n\n  return extra.tagNameType;\n}\n\nfunction analyzeExpressionTagName(\n  name: t.NodePath<t.Expression>,\n  extra: MarkoTagExtra,\n) {\n  const pending = [name] as t.NodePath<t.Expression>[];\n  let path: (typeof pending)[0] | undefined;\n  let type: TagNameType | undefined = undefined;\n  let nullable = false;\n\n  while ((path = pending.pop()) && type !== TagNameType.DynamicTag) {\n    if (path.isConditionalExpression()) {\n      pending.push(path.get(\"consequent\"));\n\n      if (path.node.alternate) {\n        pending.push(path.get(\"alternate\"));\n      }\n    } else if (path.isLogicalExpression()) {\n      if (path.node.operator === \"||\") {\n        pending.push(path.get(\"left\"));\n      } else {\n        nullable = true;\n      }\n\n      pending.push(path.get(\"right\"));\n    } else if (path.isAssignmentExpression()) {\n      pending.push(path.get(\"right\"));\n    } else if (path.isBinaryExpression()) {\n      type =\n        path.node.operator !== \"+\" ||\n        type !== undefined /* && type !== TagNameTypes.NativeTag*/\n          ? TagNameType.DynamicTag\n          : TagNameType.NativeTag;\n    } else if (path.isStringLiteral() || path.isTemplateLiteral()) {\n      type =\n        type !== undefined /* && type !== TagNameTypes.NativeTag */\n          ? TagNameType.DynamicTag\n          : TagNameType.NativeTag;\n    } else if (path.isNullLiteral()) {\n      nullable = true;\n    } else if (path.isIdentifier()) {\n      if (path.node.name === \"undefined\") {\n        nullable = true;\n        continue;\n      }\n\n      const binding = path.scope.getBinding(path.node.name);\n\n      if (!binding) {\n        type = TagNameType.DynamicTag;\n        continue;\n      }\n\n      if (binding.kind === \"module\") {\n        const decl = binding.path.parent as t.ImportDeclaration;\n        if (\n          MARKO_FILE_REG.test(decl.source.value) &&\n          decl.specifiers.some((it) => t.isImportDefaultSpecifier(it))\n        ) {\n          const resolvedImport =\n            resolveTagImport(name, decl.source.value) || decl.source.value;\n          if (\n            type === TagNameType.NativeTag ||\n            (extra.tagNameImported && extra.tagNameImported !== resolvedImport)\n          ) {\n            type = TagNameType.DynamicTag;\n            extra.tagNameImported = undefined;\n          } else {\n            type = TagNameType.CustomTag;\n            extra.tagNameImported = resolvedImport;\n          }\n        } else {\n          type = TagNameType.DynamicTag;\n        }\n\n        continue;\n      }\n\n      const bindingTag = binding.path as t.NodePath<t.MarkoTag>;\n\n      if (\n        bindingTag.isMarkoTag() &&\n        (binding.kind as typeof binding.kind & \"local\") === \"local\"\n      ) {\n        const bindingTagName = (bindingTag.get(\"name\").node as t.StringLiteral)\n          .value;\n\n        if (bindingTagName === \"define\") {\n          // TODO: Make work as a custom tag on the DOM\n          // type =\n          //   (type !== undefined && type !== TagNameTypes.CustomTag)\n          //     ? TagNameTypes.DynamicTag\n          //     : TagNameTypes.CustomTag;\n          type = TagNameType.DynamicTag;\n          extra.tagNameDefine = true;\n          continue;\n        }\n\n        if (bindingTagName === \"const\") {\n          pending.push(\n            (\n              bindingTag.get(\"attributes\")[0] as t.NodePath<t.MarkoAttribute>\n            ).get(\"value\"),\n          );\n          continue;\n        }\n\n        if (bindingTagName === \"let\") {\n          type = TagNameType.DynamicTag;\n          continue;\n          // TODO: Optimize for when we are certain that this is either always a string or always a custom tag\n        }\n\n        continue;\n      }\n\n      type = TagNameType.DynamicTag;\n    } else {\n      type = TagNameType.DynamicTag;\n    }\n  }\n\n  // DOM implementation requires non strings actually be a dynamic tag call.\n  extra.tagNameType = type!;\n  extra.tagNameNullable = nullable;\n  extra.tagNameDynamic = true;\n}\n","import type { types as t } from \"@marko/compiler\";\n\nexport default function withPreviousLocation<T extends t.Node>(\n  newNode: T,\n  originalNode: t.Node,\n): T {\n  newNode.start = originalNode.start;\n  newNode.loc = originalNode.loc;\n  newNode.end = originalNode.end;\n  return newNode;\n}\n","import type { types as t } from \"@marko/compiler\";\nimport { currentProgramPath } from \"../visitors/program\";\nimport { getExprRoot, getFnRoot } from \"./get-root\";\nimport { addSorted, findSorted, type Opt, type Many } from \"./optional\";\nimport {\n  type Reserve,\n  ReserveType,\n  reserveUtil,\n  reserveScope,\n} from \"./reserve\";\nimport {\n  type Section,\n  createSectionState,\n  forEachSection,\n  getOrCreateSection,\n} from \"./sections\";\n\nconst intersectionSubscribeCounts = new WeakMap<Reserve[], number>();\nconst [getIntersectionsBySection, setIntersectionsBySection] =\n  createSectionState<Intersection[]>(\"intersectionsBySection\", () => []);\n\nexport interface IntersectionsBySection {\n  [sectionId: number]: Intersection[];\n}\nexport type Intersection = Many<Reserve>;\nexport type References = Opt<Reserve>;\n\ndeclare module \"@marko/compiler/dist/types\" {\n  export interface ProgramExtra {\n    intersectionsBySection?: IntersectionsBySection;\n  }\n\n  export interface NodeExtra {\n    references?: References;\n  }\n\n  // TODO: remove\n  export interface FunctionExpressionExtra {\n    name?: string;\n  }\n\n  // TODO: remove\n  export interface ArrowFunctionExpressionExtra {\n    name?: string;\n  }\n}\n\nexport default function trackReferences(tag: t.NodePath<t.MarkoTag>) {\n  if (tag.has(\"var\")) {\n    trackReferencesForBindings(getOrCreateSection(tag), tag.get(\"var\"));\n  }\n\n  const body = tag.get(\"body\");\n  if (body.get(\"body\").length && body.get(\"params\").length) {\n    trackReferencesForBindings(getOrCreateSection(body), body);\n  }\n}\n\nexport function trackReferencesForBindings(\n  section: Section,\n  path: t.NodePath<any>,\n) {\n  const scope = path.scope;\n  const identifiers = path.getBindingIdentifiers();\n\n  for (const name in identifiers) {\n    const { referencePaths, constantViolations } = scope.getBinding(name)!;\n    const binding = reserveScope(\n      ReserveType.Store,\n      section,\n      identifiers[name],\n      name,\n    );\n\n    for (const reference of referencePaths) {\n      addBindingToReference(binding, reference);\n    }\n\n    for (const reference of constantViolations) {\n      /*\n       * https://github.com/babel/babel/issues/11313\n       * We need this so we can handle `+=` and friends\n       */\n      if (\n        reference.isAssignmentExpression() &&\n        reference.node.operator !== \"=\"\n      ) {\n        addBindingToReference(binding, reference);\n      }\n    }\n  }\n}\n\nfunction addBindingToReference(binding: Reserve, reference: t.NodePath) {\n  const fnRoot = getFnRoot(reference.scope.path);\n  const exprRoot = getExprRoot(fnRoot || reference);\n  const markoRoot = exprRoot.parentPath;\n  const extra = (exprRoot.node.extra ??= {});\n  const previousReferences = extra.references;\n  let newReferences = reserveUtil.add(previousReferences, binding);\n\n  if (previousReferences !== newReferences) {\n    const section = getOrCreateSection(exprRoot);\n    if (isIntersection(previousReferences)) {\n      removeSubscriber(getIntersection(section, previousReferences));\n    }\n\n    if (isIntersection(newReferences)) {\n      newReferences = getIntersection(section, newReferences);\n      addSubscriber(newReferences);\n    }\n\n    if (section !== binding.section) {\n      section.closures ??= [];\n      section.closures.push(binding);\n    }\n\n    extra.references = newReferences;\n  }\n\n  // TODO: remove\n  if (fnRoot) {\n    const name = (fnRoot.node as t.FunctionExpression).id?.name;\n    let fnExtra = extra;\n\n    if (fnRoot !== exprRoot) {\n      fnExtra = fnRoot.node.extra ??= {};\n      fnExtra.references = reserveUtil.add(fnExtra.references, binding);\n    }\n\n    if (!name) {\n      if (markoRoot.isMarkoAttribute() && !markoRoot.node.default) {\n        fnExtra.name = markoRoot.node.name;\n      }\n    }\n  }\n}\n\nexport function addReference(target: t.NodePath, reference: Reserve) {\n  const { node } = target;\n  const extra = (node.extra ??= {});\n  const previousReferences = extra.references;\n  const section = getOrCreateSection(target);\n  let newReferences = reserveUtil.add(previousReferences, reference);\n\n  if (previousReferences !== newReferences) {\n    if (isIntersection(newReferences)) {\n      newReferences = getIntersection(section, newReferences);\n      addSubscriber(newReferences);\n    }\n\n    if (isIntersection(previousReferences)) {\n      removeSubscriber(getIntersection(section, previousReferences));\n    }\n\n    extra.references = newReferences;\n  }\n\n  return newReferences;\n}\n\nexport function mergeReferences(\n  target: t.NodePath,\n  nodes: (t.Node | undefined)[],\n) {\n  let newReferences: References;\n  for (const node of nodes) {\n    const extra = node?.extra;\n    if (extra) {\n      if (isIntersection(extra.references)) {\n        removeSubscriber(\n          getIntersection(getOrCreateSection(target), extra.references),\n        );\n      }\n      newReferences = reserveUtil.union(newReferences, extra.references);\n    }\n  }\n\n  if (isIntersection(newReferences)) {\n    newReferences = getIntersection(getOrCreateSection(target), newReferences);\n    addSubscriber(newReferences);\n  }\n\n  (target.node.extra ??= {}).references = newReferences;\n\n  return newReferences;\n}\n\n/**\n * reference group priority is sorted by number of references,\n * then if needed by reference order.\n */\nfunction compareIntersections(a: Intersection, b: Intersection) {\n  const len = a.length;\n  const lenDelta = len - b.length;\n  if (lenDelta !== 0) {\n    return lenDelta;\n  }\n\n  for (let i = 0; i < len; i++) {\n    const compareResult = reserveUtil.compare(a[i], b[i]);\n    if (compareResult !== 0) {\n      return compareResult;\n    }\n  }\n\n  return 0;\n}\n\nexport function finalizeIntersections() {\n  const intersectionsBySection: IntersectionsBySection =\n    ((currentProgramPath.node.extra ??= {}).intersectionsBySection = {});\n  forEachSection((section) => {\n    intersectionsBySection[section.id] = getIntersectionsBySection(\n      section,\n    ).filter(\n      (intersection) => intersectionSubscribeCounts.get(intersection)! > 0,\n    );\n  });\n}\n\nfunction getIntersection(section: Section, references: Intersection) {\n  const intersections = getIntersectionsBySection(section);\n  let intersection = findSorted(\n    compareIntersections,\n    intersections,\n    references,\n  );\n\n  if (!intersection) {\n    intersection = references;\n    setIntersectionsBySection(\n      section,\n      addSorted(compareIntersections, intersections, references),\n    );\n  }\n\n  return intersection;\n}\n\nfunction addSubscriber(intersection: Intersection) {\n  intersectionSubscribeCounts.set(\n    intersection,\n    (intersectionSubscribeCounts.get(intersection) || 0) + 1,\n  );\n\n  return intersection;\n}\n\nfunction removeSubscriber(intersection: Intersection) {\n  intersectionSubscribeCounts.set(\n    intersection,\n    intersectionSubscribeCounts.get(intersection)! - 1,\n  );\n\n  return intersection;\n}\n\nfunction isIntersection(references: References): references is Intersection {\n  return Array.isArray(references);\n}\n","import { importNamed } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport {\n  attr,\n  classAttr,\n  escapeScript,\n  escapeStyle,\n  escapeXML,\n  styleAttr,\n  toString,\n} from \"@marko/runtime-tags/html\";\nimport { currentProgramPath } from \"../visitors/program\";\nimport { getMarkoOpts } from \"./marko-config\";\nimport type { Reserve } from \"./reserve\";\nimport { getScopeExpression } from \"./scope-read\";\nimport type { Section } from \"./sections\";\n\ntype Falsy = false | 0 | \"\" | null | undefined;\n\nconst pureFunctions: Array<keyof typeof import(\"@marko/runtime-tags/dom\")> = [\n  \"createTemplate\",\n  \"createRenderer\",\n  \"value\",\n  \"intersection\",\n  \"closure\",\n  \"dynamicClosure\",\n  \"loopOf\",\n  \"loopIn\",\n  \"loopTo\",\n  \"conditional\",\n  \"bindFunction\",\n  \"bindRenderer\",\n];\n\nexport function importRuntime(\n  name:\n    | keyof typeof import(\"@marko/runtime-tags/dom\")\n    | keyof typeof import(\"@marko/runtime-tags/html\"),\n) {\n  const { output } = getMarkoOpts();\n  return importNamed(currentProgramPath.hub.file, getRuntimePath(output), name);\n}\n\nexport function callRuntime(\n  name:\n    | keyof typeof import(\"@marko/runtime-tags/dom\")\n    | keyof typeof import(\"@marko/runtime-tags/html\"),\n  ...args: Array<Parameters<typeof t.callExpression>[1][number] | Falsy>\n) {\n  const callExpression = t.callExpression(\n    importRuntime(name),\n    filterArguments(args),\n  );\n  if (\n    pureFunctions.includes(\n      name as keyof typeof import(\"@marko/runtime-tags/dom\"),\n    )\n  ) {\n    callExpression.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: ` @__PURE__ `,\n      } as t.CommentBlock,\n    ];\n  }\n  return callExpression;\n}\n\nexport function getHTMLRuntime() {\n  return {\n    escapeXML,\n    toString,\n    attr,\n    classAttr,\n    styleAttr,\n    escapeScript,\n    escapeStyle,\n  };\n}\n\nfunction getRuntimePath(output: string) {\n  const { optimize } = getMarkoOpts();\n  return `@marko/runtime-tags/${\n    optimize ? \"\" : \"debug/\"\n  }${output === \"html\" ? \"html\" : \"dom\"}`;\n}\n\nexport function callQueue(\n  identifier: t.Identifier,\n  reference: Reserve,\n  value: t.Expression,\n  section: Section,\n) {\n  return callRuntime(\n    \"queueSource\",\n    getScopeExpression(section, reference.section),\n    identifier,\n    value,\n  );\n}\n\nfunction filterArguments<A>(args: (A | Falsy)[]) {\n  const filteredArgs = [];\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (arg || filteredArgs.length) {\n      filteredArgs[i] = arg || t.unaryExpression(\"void\", t.numericLiteral(0));\n    }\n  }\n  return filteredArgs as A[];\n}\n","export function toString(val: unknown) {\n  return val || val === 0 ? val + \"\" : \"\";\n}\n\nexport const escapeXML = escapeIfNeeded((val: string) => {\n  let result = \"\";\n  let lastPos = 0;\n\n  for (let i = 0, len = val.length; i < len; i++) {\n    let replacement: string;\n\n    switch (val[i]) {\n      case \"<\":\n        replacement = \"&lt;\";\n        break;\n      case \"&\":\n        replacement = \"&amp;\";\n        break;\n      default:\n        continue;\n    }\n\n    result += val.slice(lastPos, i) + replacement;\n    lastPos = i + 1;\n  }\n\n  if (lastPos) {\n    return result + val.slice(lastPos);\n  }\n\n  return val;\n});\n\nexport const escapeScript = escapeIfNeeded(escapeTagEnding(\"script\"));\nexport const escapeStyle = escapeIfNeeded(escapeTagEnding(\"style\"));\nfunction escapeTagEnding(tagName: string) {\n  const openTag = `</${tagName}`;\n  const escaped = `<\\\\/${tagName}`;\n\n  return (val: string) => {\n    let result = \"\";\n    let lastPos = 0;\n    let i = val.indexOf(openTag, lastPos);\n\n    while (i !== -1) {\n      result += val.slice(lastPos, i) + escaped;\n      lastPos = i + 1;\n      i = val.indexOf(openTag, lastPos);\n    }\n\n    if (lastPos) {\n      return result + val.slice(lastPos);\n    }\n\n    return val;\n  };\n}\n\nexport function escapeAttrValue(val: string) {\n  const len = val.length;\n  let i = 0;\n  do {\n    switch (val[i]) {\n      case '\"':\n        return quoteValue(val, i + 1, \"'\", \"&#39;\");\n      case \"'\":\n      case \">\":\n      case \" \":\n      case \"\\t\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\f\":\n        return quoteValue(val, i + 1, '\"', \"&#34;\");\n      default:\n        i++;\n        break;\n    }\n  } while (i < len);\n\n  return val;\n}\n\nfunction escapeIfNeeded(escape: (val: string) => string) {\n  return (val: unknown) => {\n    if (!val && val !== 0) {\n      return \"&zwj;\";\n    }\n\n    switch (typeof val) {\n      case \"string\":\n        return escape(val);\n      case \"boolean\":\n        return \"true\";\n      case \"number\":\n        return val + \"\";\n      default:\n        return escape(val + \"\");\n    }\n  };\n}\n\nfunction quoteValue(\n  val: string,\n  startPos: number,\n  quote: string,\n  escaped: string,\n) {\n  let result = quote;\n  let lastPos = 0;\n\n  for (let i = startPos, len = val.length; i < len; i++) {\n    if (val[i] === quote) {\n      result += val.slice(lastPos, i) + escaped;\n      lastPos = i + 1;\n    }\n  }\n\n  return result + (lastPos ? val.slice(lastPos) : val) + quote;\n}\n","export function classValue(value: unknown) {\n  return toDelimitedString(value, \" \", stringifyClassObject);\n}\n\nfunction stringifyClassObject(name: string, value: unknown) {\n  if (isVoid(value)) {\n    return \"\";\n  }\n\n  return name;\n}\n\nexport function styleValue(value: unknown) {\n  return toDelimitedString(value, \";\", stringifyStyleObject);\n}\n\nconst NON_DIMENSIONAL = /^(--|ta|or|li|z)|n-c|i(do|nk|m|t)|w$|we/;\nfunction stringifyStyleObject(name: string, value: unknown) {\n  if (isVoid(value)) {\n    return \"\";\n  }\n\n  if (typeof value === \"number\" && value && !NON_DIMENSIONAL.test(name)) {\n    (value as unknown as string) += \"px\";\n  }\n\n  return `${name}:${value}`;\n}\n\nfunction toDelimitedString(\n  val: unknown,\n  delimiter: string,\n  stringify: (n: string, v: unknown) => string | undefined,\n) {\n  switch (typeof val) {\n    case \"string\":\n      return val;\n    case \"object\":\n      if (val !== null) {\n        let result = \"\";\n        let curDelimiter = \"\";\n\n        if (Array.isArray(val)) {\n          for (const v of val) {\n            const part = toDelimitedString(v, delimiter, stringify);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        } else {\n          for (const name in val) {\n            const v = (val as Record<string, unknown>)[name];\n            const part = stringify(name, v);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        }\n\n        return result;\n      }\n  }\n\n  return \"\";\n}\n\nexport function isVoid(value: unknown) {\n  return value == null || value === false;\n}\n\nexport function alphaEncode(num: number): string {\n  return num < 52\n    ? String.fromCharCode(num < 26 ? num + 97 : num + (65 - 26))\n    : alphaEncode((num / 52) | 0) + alphaEncode(num % 52);\n}\n","import { classValue, isVoid, styleValue } from \"../common/helpers\";\nimport { escapeAttrValue } from \"./content\";\n\nexport function classAttr(val: unknown) {\n  return stringAttr(\"class\", classValue(val));\n}\n\nexport function styleAttr(val: unknown) {\n  return stringAttr(\"style\", styleValue(val));\n}\n\nexport function attr(name: string, val: unknown) {\n  return isVoid(val) ? \"\" : nonVoidUntypedAttr(name, val);\n}\n\nexport function attrs(data: Record<string, unknown>) {\n  let result = \"\";\n\n  for (const name in data) {\n    if (/^on[A-Z-]/.test(name)) {\n      continue;\n    }\n\n    const val = data[name];\n\n    switch (name) {\n      case \"class\":\n        result += classAttr(val);\n        break;\n      case \"style\":\n        result += styleAttr(val);\n        break;\n      case \"renderBody\":\n        break;\n      default:\n        if (!(isVoid(val) || isInvalidAttrName(name))) {\n          result += nonVoidUntypedAttr(name, val);\n        }\n    }\n  }\n\n  return result;\n}\n\nfunction stringAttr(name: string, val: string) {\n  return val && ` ${name}=${escapeAttrValue(val)}`;\n}\n\nfunction nonVoidUntypedAttr(name: string, val: unknown) {\n  switch (typeof val) {\n    case \"string\":\n      return ` ${name + attrAssignment(val)}`;\n    case \"boolean\":\n      return ` ${name}`;\n    case \"number\":\n      return ` ${name}=${val}`;\n    case \"object\":\n      if (val instanceof RegExp) {\n        return ` ${name}=${escapeAttrValue(val.source)}`;\n      }\n    // eslint-disable-next-line no-fallthrough\n    default:\n      return ` ${name + attrAssignment(val + \"\")}`;\n  }\n}\n\nfunction attrAssignment(val: string) {\n  return val ? `=${escapeAttrValue(val)}` : \"\";\n}\n\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// Technically the above includes more invalid characters for attributes.\n// In practice however the only character that does not become an attribute name\n// is when there is a >.\nfunction isInvalidAttrName(name: string) {\n  for (let i = name.length; i--; ) {\n    if (name[i] === \">\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n","/* eslint \"@typescript-eslint/ban-types\": [\"error\", { \"types\": { \"object\": false }, \"extendDefaults\": true }] */\n\nconst { hasOwnProperty } = Object.prototype;\nconst PARAM_BIND = \"b\";\nconst PARAM_SCOPE = \"s\";\nconst REF_START_CHARS = \"hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_\"; // Avoids chars that could evaluate to a reserved word.\nconst REF_START_CHARS_LEN = REF_START_CHARS.length;\nconst REF_CHARS =\n  \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_\";\nconst REF_CHARS_LEN = REF_CHARS.length;\nconst SYMBOL_REGISTRY_ID = Symbol(\"REGISTRY_ID\");\nconst SYMBOL_SCOPE = Symbol(\"SCOPE\");\nconst SYMBOL_SERIALIZE = Symbol(\"SERIALIZE\");\n\nclass Scope {}\nexport const serializedScope = (scopeId: string | number) => {\n  const scope = new Scope();\n  if (MARKO_DEBUG) {\n    (scope as any).id = scopeId;\n  }\n  return makeSerializable(scope, (s, a) => {\n    s.value(s.scopeLookup.get(scopeId as number), a);\n  });\n};\n\nexport type Serializable<T> = T & {\n  [SYMBOL_REGISTRY_ID]?: string;\n  [SYMBOL_SCOPE]?: number;\n  [SYMBOL_SERIALIZE]?: (s: Serializer, accessor: string | number) => void;\n};\n\nexport function register<T>(\n  entry: T,\n  registryId: string,\n  scopeId?: number,\n): Serializable<T> {\n  (entry as Serializable<T>)[SYMBOL_REGISTRY_ID] = registryId;\n  (entry as Serializable<T>)[SYMBOL_SCOPE] = scopeId;\n  return entry as Serializable<T>;\n}\n\nexport function getRegistryInfo(entry: Serializable<unknown>) {\n  return [entry[SYMBOL_REGISTRY_ID], entry[SYMBOL_SCOPE]];\n}\n\nexport function makeSerializable<T>(\n  object: T,\n  serialize: (s: Serializer, accessor: string | number) => void,\n): T {\n  (object as Serializable<T>)[SYMBOL_SERIALIZE] = serialize;\n  return object;\n}\n\nexport function stringify(root: unknown) {\n  return new Serializer(new Map()).stringify(root);\n}\nexport class Serializer {\n  // TODO: hoist these back out?\n  STACK: object[] = [];\n  BUFFER: string[] = [\"\"];\n  ASSIGNMENTS: Map<string, string> = new Map();\n  INDEX_OR_REF: WeakMap<object, number | string> = new WeakMap();\n  REF_COUNT = 0;\n  // These stay\n  PARENTS: WeakMap<object, object> = new WeakMap();\n  KEYS: WeakMap<object, number | string> = new WeakMap();\n  VALUES: Map<unknown, string | unknown> = new Map();\n  scopeLookup: Map<number, any>;\n\n  constructor(scopeLookup: Map<number, any>) {\n    this.scopeLookup = scopeLookup;\n    this.BUFFER.pop();\n  }\n\n  stringify(root: unknown) {\n    if (this.writeProp(root, \"\")) {\n      const { BUFFER, REF_COUNT, ASSIGNMENTS, INDEX_OR_REF } = this;\n\n      let result = BUFFER[0];\n\n      for (let i = 1, len = BUFFER.length; i < len; i++) {\n        result += BUFFER[i];\n      }\n\n      if (REF_COUNT) {\n        if (ASSIGNMENTS.size) {\n          let ref = INDEX_OR_REF.get(root as object);\n\n          if (typeof ref === \"number\") {\n            ref = toRefParam(this.REF_COUNT++);\n            result = ref + \"=\" + result;\n          }\n\n          for (const [assignmentRef, assignments] of ASSIGNMENTS) {\n            result += \",\" + assignments + assignmentRef;\n          }\n\n          result += \",\" + ref;\n          this.ASSIGNMENTS = new Map();\n        }\n\n        result =\n          \"(\" +\n          PARAM_BIND +\n          \",\" +\n          PARAM_SCOPE +\n          \",\" +\n          this.refParamsString() +\n          \")=>(\" +\n          result +\n          \")\";\n      } else if (root && (root as object).constructor === Object) {\n        result = \"(\" + PARAM_BIND + \",\" + PARAM_SCOPE + \")=>(\" + result + \")\";\n      }\n\n      BUFFER.length = 0;\n      this.INDEX_OR_REF = new WeakMap();\n\n      return result;\n    }\n\n    return \"void 0\";\n  }\n\n  code(code: string) {\n    this.BUFFER.push(code);\n    return this;\n  }\n\n  value(value: unknown, accessor: string | number = \"\") {\n    // TODO: this should not push the same value twice\n    // this should be serialized in some way so we can access these values across flushes\n    if (\n      !this.writeProp(value, accessor) &&\n      !this.STACK.includes(value as object)\n    ) {\n      this.BUFFER.push(\"void 0\");\n    }\n    return this;\n  }\n\n  writeProp(cur: unknown, accessor: string | number): boolean {\n    const { BUFFER } = this;\n    switch (typeof cur) {\n      case \"string\":\n        BUFFER.push(quote(cur, 0));\n        break;\n\n      case \"number\":\n        BUFFER.push(cur + \"\");\n        break;\n\n      case \"boolean\":\n        BUFFER.push(cur ? \"!0\" : \"!1\");\n        break;\n\n      case \"function\":\n      case \"object\":\n        if (cur === null) {\n          BUFFER.push(\"null\");\n        } else {\n          const ref = this.getRef(cur, accessor);\n\n          switch (ref) {\n            case true:\n              return false;\n            case false:\n              switch (cur.constructor) {\n                case Object:\n                  this.writeObject(cur as Record<string, unknown>);\n                  break;\n\n                case Array:\n                  this.writeArray(cur as unknown[]);\n                  break;\n\n                case Date:\n                  BUFFER.push(\n                    'new Date(\"' + (cur as Date).toISOString() + '\")',\n                  );\n                  break;\n\n                case RegExp:\n                  BUFFER.push(cur + \"\");\n                  break;\n\n                case Map:\n                  BUFFER.push(\"new Map(\");\n                  this.writeArray(\n                    Array.from(cur as Map<unknown, unknown> | Set<unknown>),\n                  );\n                  BUFFER.push(\")\");\n                  break;\n\n                case Set:\n                  BUFFER.push(\"new Set(\");\n                  this.writeArray(\n                    Array.from(cur as Map<unknown, unknown> | Set<unknown>),\n                  );\n                  BUFFER.push(\")\");\n                  break;\n\n                case undefined:\n                  BUFFER.push(\"Object.assign(Object.create(null),\");\n                  this.writeObject(cur as Record<string, unknown>);\n                  BUFFER.push(\"))\");\n                  break;\n\n                default:\n                  return this.writeRegistered(\n                    cur as Serializable<unknown>,\n                    accessor,\n                  );\n              }\n              break;\n\n            default:\n              BUFFER.push(ref);\n              break;\n          }\n        }\n        break;\n\n      default:\n        return false;\n    }\n\n    return true;\n  }\n\n  writeRegistered(value: Serializable<unknown>, accessor: string | number) {\n    const {\n      [SYMBOL_REGISTRY_ID]: registryId,\n      [SYMBOL_SCOPE]: scopeId,\n      [SYMBOL_SERIALIZE]: serialize,\n    } = value;\n    const { BUFFER } = this;\n    if (registryId) {\n      // ASSERT: fnId and scopeId don't need `quote` escaping\n      const scope =\n        scopeId !== undefined\n          ? this.scopeLookup.get(scopeId) ?? false\n          : undefined;\n      const ref = scope && this.getRef(scope, \"\");\n      if (ref === true) {\n        const { STACK, INDEX_OR_REF, ASSIGNMENTS } = this;\n        const parent = STACK[STACK.length - 1];\n        const parentRef = INDEX_OR_REF.get(parent) as string;\n        const resolvedRef = INDEX_OR_REF.get(scope);\n        ASSIGNMENTS.set(\n          `${PARAM_BIND}(\"${registryId}\",${resolvedRef})`,\n          (ASSIGNMENTS.get(ref) || \"\") +\n            toAssignment(parentRef, accessor) +\n            \"=\",\n        );\n        return false;\n      } else if (ref === false) {\n        throw new Error(\n          \"The scope has not yet been defined. This needs to be fixed in the serializer.\",\n        );\n      } else {\n        BUFFER.push(`${PARAM_BIND}(\"${registryId}\"${ref ? \",\" + ref : \"\"})`);\n        return true;\n      }\n    } else if (serialize) {\n      const prevSize = BUFFER.length;\n      serialize(this, accessor);\n      return prevSize !== BUFFER.length;\n    }\n    return false;\n  }\n\n  writeObject(obj: Record<string | symbol, unknown>) {\n    const { STACK, BUFFER } = this;\n\n    let sep = \"{\";\n    STACK.push(obj);\n\n    for (const key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        const val = obj[key];\n        const escapedKey = toObjectKey(key);\n        BUFFER.push(sep + escapedKey + \":\");\n        if (this.writeProp(val, escapedKey)) {\n          sep = \",\";\n        } else {\n          BUFFER.pop();\n        }\n      }\n    }\n\n    if (sep === \"{\") {\n      BUFFER.push(\"{}\");\n    } else {\n      BUFFER.push(\"}\");\n    }\n\n    STACK.pop();\n  }\n\n  writeArray(arr: unknown[]) {\n    const { STACK, BUFFER } = this;\n\n    BUFFER.push(\"[\");\n    STACK.push(arr);\n\n    this.writeProp(arr[0], 0);\n\n    for (let i = 1, len = arr.length; i < len; i++) {\n      BUFFER.push(\",\");\n      this.writeProp(arr[i], i);\n    }\n\n    STACK.pop();\n    BUFFER.push(\"]\");\n  }\n\n  getRef(cur: object, accessor: string | number) {\n    const { STACK, BUFFER, INDEX_OR_REF, ASSIGNMENTS, PARENTS, KEYS } = this;\n\n    let ref = INDEX_OR_REF.get(cur);\n\n    if (ref === undefined) {\n      INDEX_OR_REF.set(cur, BUFFER.length);\n\n      let knownParent = PARENTS.get(cur);\n\n      if (knownParent === undefined) {\n        const parent = STACK[STACK.length - 1];\n        if (!parent) {\n          // this.VALUES.set(cur, undefined);\n        } else {\n          // this.VALUES.delete(cur);\n          PARENTS.set(cur, parent!);\n          KEYS.set(cur, toObjectKey(accessor));\n        }\n        return false;\n      } else {\n        let ref = \"\";\n        while (knownParent) {\n          ref = toPropertyAccess(KEYS.get(cur)!) + ref;\n          knownParent = PARENTS.get((cur = knownParent));\n        }\n        return PARAM_SCOPE + ref;\n      }\n    }\n\n    if (typeof ref === \"number\") {\n      ref = this.insertAndGetRef(cur, ref);\n      // if (this.VALUES.has(cur)) {\n      //   this.VALUES.set(cur, ref);\n      // }\n    }\n\n    if (STACK.includes(cur)) {\n      const parent = STACK[STACK.length - 1];\n      let parentRef = INDEX_OR_REF.get(parent) as string | number;\n\n      if (typeof parentRef === \"number\") {\n        parentRef = this.insertAndGetRef(parent, parentRef);\n      }\n\n      if (accessor !== \"\") {\n        ASSIGNMENTS.set(\n          ref,\n          (ASSIGNMENTS.get(ref) || \"\") +\n            toAssignment(parentRef, accessor) +\n            \"=\",\n        );\n      }\n      return true;\n    }\n\n    return ref;\n  }\n\n  insertAndGetRef(obj: object, pos: number) {\n    const ref = toRefParam(this.REF_COUNT++);\n    this.INDEX_OR_REF.set(obj, ref);\n    if (pos) {\n      this.BUFFER[pos - 1] += ref + \"=\";\n    } else {\n      this.BUFFER[pos] = ref + \"=\" + this.BUFFER[pos];\n    }\n\n    return ref;\n  }\n\n  refParamsString() {\n    let result = REF_START_CHARS[0];\n\n    for (let i = 1; i < this.REF_COUNT; i++) {\n      result += \",\" + toRefParam(i);\n    }\n\n    this.REF_COUNT = 0;\n    return result;\n  }\n}\n\n// function toObjectKey(name: string) {\n//   const invalidPropertyPos = getInvalidPropertyPos(name);\n//   return invalidPropertyPos === -1 ? name : quote(name, invalidPropertyPos);\n// }\n\nfunction toAssignment(parent: string, key: string | number) {\n  return parent + toPropertyAccess(key);\n}\n\nfunction toPropertyAccess(key: string | number) {\n  return typeof key === \"number\" || key[0] === '\"'\n    ? \"[\" + key + \"]\"\n    : \".\" + key;\n}\n\nfunction toObjectKey(name: string | number) {\n  if (typeof name !== \"string\") return name;\n\n  let char = name[0];\n  if (char >= \"0\" && char <= \"9\") {\n    // numeric\n    for (let i = 1, len = name.length; i < len; i++) {\n      char = name[i];\n      if (!(char >= \"0\" && char <= \"9\")) {\n        return quote(name, i);\n      }\n    }\n    return parseInt(name, 10);\n  } else {\n    // or valid identifier\n    for (let i = 0, len = name.length; i < len; i++) {\n      char = name[i];\n      if (\n        !(\n          (char >= \"a\" && char <= \"z\") ||\n          (char >= \"A\" && char <= \"Z\") ||\n          (char >= \"0\" && char <= \"9\") ||\n          char === \"$\" ||\n          char === \"_\"\n        )\n      ) {\n        return quote(name, i);\n      }\n    }\n  }\n\n  return name;\n}\n\n// Creates a JavaScript double quoted string and escapes all characters not listed as DoubleStringCharacters on\n// Also includes \"<\" to escape \"</script>\" and \"\\\" to avoid invalid escapes in the output.\n// http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.4\nfunction quote(str: string, startPos: number): string {\n  let result = \"\";\n  let lastPos = 0;\n\n  for (let i = startPos, len = str.length; i < len; i++) {\n    let replacement: string;\n    switch (str[i]) {\n      case '\"':\n        replacement = '\\\\\"';\n        break;\n      case \"\\\\\":\n        replacement = \"\\\\\\\\\";\n        break;\n      case \"<\":\n        replacement = \"\\\\x3C\";\n        break;\n      case \"\\n\":\n        replacement = \"\\\\n\";\n        break;\n      case \"\\r\":\n        replacement = \"\\\\r\";\n        break;\n      case \"\\u2028\":\n        replacement = \"\\\\u2028\";\n        break;\n      case \"\\u2029\":\n        replacement = \"\\\\u2029\";\n        break;\n      default:\n        continue;\n    }\n\n    result += str.slice(lastPos, i) + replacement;\n    lastPos = i + 1;\n  }\n\n  if (lastPos === startPos) {\n    result = str;\n  } else {\n    result += str.slice(lastPos);\n  }\n\n  return '\"' + result + '\"';\n}\n\nfunction toRefParam(index: number) {\n  let mod = index % REF_START_CHARS_LEN;\n  let ref = REF_START_CHARS[mod];\n  index = (index - mod) / REF_START_CHARS_LEN;\n\n  while (index > 0) {\n    mod = index % REF_CHARS_LEN;\n    ref += REF_CHARS[mod];\n    index = (index - mod) / REF_CHARS_LEN;\n  }\n\n  return ref;\n}\n","import { type Accessor, type Renderer, ResumeSymbol } from \"../common/types\";\nimport reorderRuntime from \"./reorder-runtime\";\nimport { Serializer, serializedScope } from \"./serializer\";\n\nconst runtimeId = ResumeSymbol.DefaultRuntimeId;\nconst reorderRuntimeString = String(reorderRuntime).replace(\n  \"RUNTIME_ID\",\n  runtimeId,\n);\n\ntype PartialScope = Record<string | number, unknown> | unknown[];\n\nexport interface Writable {\n  write(data: string): void;\n  end(): void;\n  flush?(): void;\n  emit(name: string, data: unknown): void;\n}\n\ninterface Buffer {\n  stream?: Writable;\n  pending: boolean;\n  flushed: boolean;\n  disabled: boolean;\n  next: Buffer | null;\n  prev: Buffer | null;\n  content: string;\n  calls: string;\n  scopes: Record<string, PartialScope> | null;\n  onAsync?: (complete: boolean, isPlaceholder?: boolean) => void;\n  onReject?: (err: Error) => void;\n}\n\ninterface StreamData {\n  scopeId: number;\n  tagId: number;\n  placeholderId: number;\n  scopeLookup: Map<number, PartialScope>;\n  runtimeFlushed: boolean;\n  global: Record<string, unknown>;\n  serializer?: Serializer;\n}\n\nlet $_buffer: Buffer | null = null;\nexport let $_streamData: StreamData | null = null;\n\nexport function createRenderFn(renderer: Renderer) {\n  type Input = Parameters<Renderer>[0];\n  return (\n    stream: Writable,\n    input: Input = {},\n    $global?: Record<string, unknown>,\n    streamState: Partial<StreamData> = {},\n  ) => {\n    let remainingChildren = 1;\n\n    const originalBuffer = $_buffer;\n    const originalStreamState = $_streamData;\n    const reject = (err: Error) => {\n      stream.emit(\"error\", err);\n    };\n    const async = (complete: boolean) => {\n      remainingChildren += complete ? -1 : 1;\n      if (!remainingChildren) {\n        setImmediate(() => stream.end());\n      }\n    };\n\n    $_buffer = createInitialBuffer(stream);\n    streamState.global = $global;\n    $_streamData = createStreamState(streamState);\n\n    $_buffer.onReject = reject;\n    $_buffer.onAsync = async;\n\n    try {\n      scheduleFlush();\n      renderer(input);\n      async(true);\n    } catch (err) {\n      reject(err as Error);\n    } finally {\n      $_buffer = originalBuffer;\n      $_streamData = originalStreamState;\n    }\n  };\n}\n\nexport function write(data: string) {\n  $_buffer!.content += data;\n}\n\nconst TARGET_BUFFER_SIZE = 64000;\nexport function maybeFlush() {\n  if (!$_buffer!.prev && $_buffer!.content.length > TARGET_BUFFER_SIZE) {\n    // TODO: figure out if we can do this\n    // The idea is to flush in a `<for>` if the buffer gets too large.\n    //\n    // However, a synchronous flush will break the owner scope reference\n    //   as things are currently implemented: the owner scope object will\n    //   not have been created if you flush in a scope that closes over it\n    // However, a scheduled flush will be too late:\n    //   the entire contents of the `<for>` will have been written\n    //   by the time the flush occurs defeating the purpose\n    // Additionally, because we aren't eagerly merging buffers,\n    //   buffer.content.length isn't necessarily 100% accurate\n  }\n}\n\nexport function scheduleFlush() {\n  const buffer = $_buffer!;\n  const streamState = $_streamData!;\n  if (!buffer.prev) {\n    setImmediate(() => flushToStream(buffer, streamState));\n  }\n}\n\nfunction flushToStream(buffer: Buffer, streamState: StreamData) {\n  while (buffer.prev) buffer = buffer.prev;\n  if (buffer.disabled) return;\n\n  const stream = buffer.stream!;\n\n  let { content, calls, scopes } = buffer;\n  buffer.flushed = true;\n  while (!buffer.pending && buffer.next) {\n    // TODO: we shouldn't need to clear here\n    clearBuffer(buffer);\n    buffer = buffer.next;\n    buffer.prev = null;\n    buffer.flushed = true;\n    content += buffer.content;\n    calls += buffer.calls;\n    if (buffer.scopes) {\n      if (scopes) {\n        Object.assign(scopes, buffer.scopes);\n      } else {\n        scopes = buffer.scopes;\n      }\n    }\n  }\n  const data = content + getResumeScript(calls, scopes, streamState);\n\n  if (data) {\n    stream.write(data);\n    stream.flush?.();\n  }\n\n  // TODO: we should only have to call clearBuffer if the buffer is pending\n  // (which means it will flush again in the future). Otherwise, it can just\n  // be garbage collected.\n  clearBuffer(buffer);\n}\n\nfunction createStreamState(state: Partial<StreamData>): StreamData {\n  state.scopeId ??= 0;\n  state.tagId ??= 0;\n  state.placeholderId ??= 0;\n  state.scopeLookup ??= new Map();\n  state.runtimeFlushed ??= false;\n  return state as StreamData;\n}\n\nfunction createNextBuffer(prevBuffer: Buffer): Buffer {\n  const newBuffer = {\n    stream: prevBuffer.stream,\n    pending: false,\n    flushed: false,\n    disabled: false,\n    prev: prevBuffer,\n    next: prevBuffer?.next ?? null,\n    content: \"\",\n    calls: \"\",\n    scopes: null,\n    onReject: prevBuffer.onReject,\n    onAsync: prevBuffer.onAsync,\n  };\n  if (prevBuffer.next) {\n    prevBuffer.next.prev = prevBuffer;\n  }\n  prevBuffer.next = newBuffer;\n  return newBuffer;\n}\n\nfunction createDetatchedBuffer(parentBuffer: Buffer): Buffer {\n  return {\n    stream: parentBuffer.stream,\n    pending: false,\n    flushed: false,\n    disabled: true,\n    prev: null,\n    next: null,\n    content: \"\",\n    calls: \"\",\n    scopes: null,\n    onReject: parentBuffer.onReject,\n    onAsync: parentBuffer.onAsync,\n  };\n}\n\nfunction createInitialBuffer(stream: Writable): Buffer {\n  return {\n    stream,\n    pending: false,\n    flushed: false,\n    disabled: false,\n    prev: null,\n    next: null,\n    content: \"\",\n    calls: \"\",\n    scopes: null,\n    onReject: undefined,\n    onAsync: undefined,\n  };\n}\n\nexport async function fork<T>(\n  promise: Promise<T>,\n  renderResult: (result: T) => void,\n) {\n  const originalBuffer = $_buffer!;\n  const originalStreamState = $_streamData!;\n\n  scheduleFlush();\n  $_buffer!.pending = true;\n  $_buffer!.onAsync?.(false);\n  $_buffer = createNextBuffer($_buffer!);\n\n  try {\n    let result;\n    try {\n      result = await promise;\n      originalBuffer!.pending = false;\n    } finally {\n      $_buffer = originalBuffer;\n      $_streamData = originalStreamState;\n      scheduleFlush();\n    }\n    renderResult(result);\n  } catch (err) {\n    $_buffer!.onReject?.(err as Error);\n  } finally {\n    $_buffer!.onAsync?.(true);\n    clearScope();\n  }\n}\n\nexport function tryCatch(\n  renderBody: () => void,\n  renderError: (err: Error) => void,\n) {\n  const id = nextPlaceholderId();\n  let err: Error | null = null;\n\n  const originalBuffer = $_buffer!;\n  const tryBuffer = createDetatchedBuffer(originalBuffer);\n  let finalTryBuffer: Buffer;\n\n  tryBuffer.onReject = (asyncErr) => {\n    const errorBuffer = createDetatchedBuffer(originalBuffer);\n    $_buffer = errorBuffer;\n    renderError(asyncErr);\n    const finalErrorBuffer = $_buffer;\n    replaceBuffers(\n      id,\n      tryBuffer,\n      finalTryBuffer,\n      errorBuffer,\n      finalErrorBuffer,\n    );\n  };\n\n  try {\n    $_buffer = tryBuffer;\n    renderBody();\n  } catch (_err) {\n    err = _err as Error;\n  } finally {\n    if (err) {\n      $_buffer = originalBuffer;\n      renderError(err);\n    } else {\n      tryBuffer.disabled = false;\n      originalBuffer.next = tryBuffer;\n      tryBuffer.prev = originalBuffer;\n      if ($_buffer !== tryBuffer) {\n        tryBuffer.content = `<!${marker(id)}>` + tryBuffer.content;\n        markReplaceEnd(id);\n        finalTryBuffer = $_buffer!;\n        $_buffer = createNextBuffer(finalTryBuffer);\n      }\n      $_buffer.onReject = originalBuffer.onReject;\n    }\n  }\n}\n\nexport function tryPlaceholder(\n  renderBody: () => void,\n  renderPlaceholder: () => void,\n) {\n  const originalBuffer = $_buffer!;\n  const asyncBuffer = createDetatchedBuffer(originalBuffer);\n  let id: number,\n    placeholderBuffer: Buffer,\n    finalPlaceholderBuffer: Buffer,\n    finalAsyncBuffer: Buffer;\n  let remainingChildren = 0;\n  let remainingPlaceholders = 0;\n\n  asyncBuffer.onAsync = (complete: boolean, isPlaceholder?: boolean) => {\n    const delta = complete ? -1 : 1;\n    if (isPlaceholder) {\n      remainingPlaceholders += delta;\n    } else {\n      remainingChildren += delta;\n    }\n    if (!remainingChildren) {\n      if (!isPlaceholder) {\n        // last child has finished, replace the placeholder\n        // however, the replacement content may contain its own placeholder(s)\n        replaceBuffers(\n          id,\n          placeholderBuffer,\n          finalPlaceholderBuffer,\n          asyncBuffer,\n          finalAsyncBuffer,\n        );\n      }\n      if (!remainingPlaceholders) {\n        // all async content under this placeholder is complete\n        originalBuffer.onAsync?.(true, true);\n      }\n    }\n  };\n\n  $_buffer = asyncBuffer;\n  renderBody();\n\n  if ($_buffer === asyncBuffer) {\n    originalBuffer.next = asyncBuffer;\n    asyncBuffer.prev = originalBuffer;\n    asyncBuffer.disabled = false;\n    asyncBuffer.onAsync = originalBuffer.onAsync;\n  } else {\n    id = nextPlaceholderId();\n    placeholderBuffer = createNextBuffer(originalBuffer);\n    finalAsyncBuffer = $_buffer;\n    $_buffer = placeholderBuffer;\n    markReplaceStart(id);\n    renderPlaceholder();\n    markReplaceEnd(id);\n    finalPlaceholderBuffer = $_buffer;\n    $_buffer = createNextBuffer(finalPlaceholderBuffer);\n    originalBuffer.onAsync?.(false, true);\n  }\n}\n\nfunction clearBuffer(buffer: Buffer) {\n  buffer.content = \"\";\n  buffer.calls = \"\";\n  buffer.scopes = null;\n}\n\nfunction clearScope() {\n  $_buffer = $_streamData = null;\n}\n\n/* Async */\n\nexport function markReplaceStart(id: number) {\n  return ($_buffer!.content += `<!${marker(id)}>`);\n}\n\nexport function markReplaceEnd(id: number) {\n  return ($_buffer!.content += `<!${marker(id)}/>`);\n}\n\nfunction replaceBuffers(\n  id: number,\n  placeholderStart: Buffer,\n  placeholderEnd: Buffer,\n  replacementStart: Buffer,\n  replacementEnd: Buffer,\n) {\n  if (placeholderStart.flushed) {\n    addReplacementWrapper(id, replacementStart, replacementEnd);\n\n    let next: Buffer | null = placeholderEnd.next;\n    if (placeholderEnd.flushed) {\n      while (next && !next.pending && next.flushed) {\n        next = next.next;\n      }\n    } else {\n      // TODO: ensure the remaining original content cannot flush\n    }\n\n    if (next) {\n      replacementStart.next = next;\n      next.prev = replacementEnd;\n    }\n\n    $_buffer = replacementStart;\n    scheduleFlush();\n  } else {\n    const prev = placeholderStart.prev;\n    const next = placeholderEnd.next;\n    if (prev) {\n      prev.next = replacementStart;\n      replacementStart.prev = prev;\n    }\n    if (next) {\n      next.prev = replacementEnd;\n      replacementEnd.next = next;\n    }\n  }\n\n  replacementStart.disabled = false;\n}\n\nfunction addReplacementWrapper(\n  id: number,\n  replacementStart: Buffer,\n  replacementEnd: Buffer,\n) {\n  let runtimeCall = runtimeId + ResumeSymbol.VarReorderRuntime;\n  if (!$_streamData!.runtimeFlushed) {\n    runtimeCall = `(${runtimeCall}=${reorderRuntimeString})`;\n    $_streamData!.runtimeFlushed = true;\n  }\n  replacementStart.content =\n    `<t id=\"${marker(id)}\">` + replacementStart.content;\n  replacementEnd.content += `</t><script>${runtimeCall}(${id})</script>`;\n}\n\nfunction marker(id: number) {\n  return `${runtimeId}$${id}`;\n}\n\n/* Hydration */\n\nexport function nextTagId() {\n  return \"s\" + $_streamData!.tagId++;\n}\n\nexport function nextPlaceholderId() {\n  return $_streamData!.placeholderId++;\n}\n\nexport function nextScopeId() {\n  return $_streamData!.scopeId++;\n}\n\nexport function peekNextScopeId() {\n  return $_streamData!.scopeId;\n}\n\nexport function peekSerializedScope() {\n  return serializedScope(peekNextScopeId());\n}\n\nexport function writeEffect(scopeId: number, fnId: string) {\n  $_buffer!.calls += `${scopeId},\"${fnId}\",`;\n}\n\nexport function writeScope(\n  scopeId: number,\n  scope: PartialScope,\n  assignTo:\n    | PartialScope\n    | PartialScope[]\n    | undefined = $_streamData!.scopeLookup.get(scopeId),\n) {\n  if (assignTo !== undefined) {\n    if (Array.isArray(assignTo)) {\n      assignTo.push(scope);\n    } else {\n      scope = Object.assign(assignTo, scope);\n    }\n  }\n  $_buffer!.scopes ??= {\n    $global: getFilteredGlobals($_streamData!.global) as any,\n  };\n  $_buffer!.scopes[scopeId] = scope;\n  $_streamData!.scopeLookup.set(scopeId, scope);\n}\n\nexport function markResumeNode(scopeId: number, index: Accessor) {\n  // TODO: can we only include the scope id when it differs from the prvious node marker?\n  return `<!${runtimeId}${ResumeSymbol.Node}${scopeId} ${index}>`;\n}\n\nexport function markResumeScopeStart(scopeId: number, key?: string) {\n  return `<!${runtimeId}${ResumeSymbol.SectionStart}${scopeId}${\n    key ? \" \" + key : \"\"\n  }>`;\n}\n\nexport function markResumeControlEnd(scopeId: number, index: Accessor) {\n  return `<!${runtimeId}${ResumeSymbol.SectionEnd}${scopeId} ${index}>`;\n}\n\nexport function markResumeControlSingleNodeEnd(\n  scopeId: number,\n  index: Accessor,\n  childScopeIds?: number | number[],\n) {\n  return `<!${runtimeId}${\n    ResumeSymbol.SectionSingleNodesEnd\n  }${scopeId} ${index} ${childScopeIds ?? \"\"}>`;\n}\n\nfunction getResumeScript(\n  calls: string,\n  scopes: Buffer[\"scopes\"],\n  streamState: StreamData,\n) {\n  if (calls || scopes) {\n    let isFirstFlush;\n    let serializer = streamState.serializer;\n    if ((isFirstFlush = !serializer)) {\n      serializer = streamState.serializer = new Serializer(\n        streamState.scopeLookup,\n      );\n    }\n    return `<script>${\n      isFirstFlush\n        ? `(${runtimeId + ResumeSymbol.VarResume}=[])`\n        : runtimeId + ResumeSymbol.VarResume\n    }.push(${serializer.stringify(scopes)},[${calls}])</script>`;\n  }\n  return \"\";\n}\n\nfunction getFilteredGlobals($global: Record<string, unknown>) {\n  if (!$global) return undefined;\n\n  const serializedGlobals = $global.serializedGlobals as\n    | string[]\n    | Record<string, boolean>\n    | undefined;\n\n  if (!serializedGlobals) return undefined;\n\n  let filtered: undefined | Record<string, unknown>;\n\n  if (Array.isArray(serializedGlobals)) {\n    for (const key of serializedGlobals) {\n      const value = $global[key];\n      if (value !== undefined) {\n        if (filtered) {\n          filtered[key] = value;\n        } else {\n          filtered = { [key]: value };\n        }\n      }\n    }\n  } else {\n    for (const key in serializedGlobals) {\n      if (serializedGlobals[key]) {\n        const value = $global[key];\n        if (value !== undefined) {\n          if (filtered) {\n            filtered[key] = value;\n          } else {\n            filtered = { [key]: value };\n          }\n        }\n      }\n    }\n  }\n\n  return filtered;\n}\n","/* tslint:disable */\n\nimport type { CommentWalker } from \"../common/types\";\n\nexport default function (\n  id: string,\n  doc: Document,\n  walker: TreeWalker,\n  node: Comment,\n  replacementNode: Node,\n  targetParent: ParentNode & Node,\n  targetNode: Node | null | undefined,\n  refNode: Node | null | undefined,\n  nextNode: Node | null | undefined,\n  runtimePrefix: string,\n) {\n  runtimePrefix = \"RUNTIME_ID$\";\n  id = runtimePrefix + id;\n  doc = document;\n  walker =\n    (doc as any)[runtimePrefix + \"w\"] ||\n    ((doc as any)[runtimePrefix + \"w\"] = doc.createTreeWalker(\n      doc,\n      128 /** NodeFilter.SHOW_COMMENT */,\n    ) as CommentWalker);\n  while ((node = walker.nextNode() as Comment)) {\n    if (node.data.indexOf(runtimePrefix) === 0) {\n      (walker as any)[node.data] = node;\n    }\n  }\n\n  replacementNode = doc.getElementById(id)!;\n  targetNode = (walker as any)[id];\n  targetParent = targetNode!.parentNode!;\n\n  while ((refNode = replacementNode.firstChild)) {\n    targetParent.insertBefore(refNode, targetNode!);\n  }\n\n  nextNode = replacementNode.parentNode!;\n  nextNode.removeChild(replacementNode.nextSibling!);\n  nextNode.removeChild(replacementNode);\n\n  refNode = (walker as any)[id + \"/\"];\n\n  while (\n    targetNode &&\n    ((nextNode = targetNode!.nextSibling),\n    targetParent.removeChild(targetNode!) !== refNode)\n  ) {\n    targetNode = nextNode;\n  }\n}\n","import { types as t } from \"@marko/compiler\";\nimport { scopeIdentifier } from \"../visitors/program\";\nimport { forEach } from \"./optional\";\nimport type { References } from \"./references\";\nimport { type Reserve, getScopeAccessorLiteral } from \"./reserve\";\nimport type { Section } from \"./sections\";\n\nexport function createScopeReadPattern(\n  section: Section,\n  references: References,\n) {\n  const rootDepth = section.depth;\n  const rootPattern = t.objectPattern([]);\n  let nestedPatterns: t.ObjectPattern[] | undefined;\n  forEach(references, (ref) => {\n    // TODO: need a better way to exclude internal references\n    if (ref.name.includes(\"#\")) return;\n\n    const propertyKey = getScopeAccessorLiteral(ref);\n    const propertyValue = t.identifier(ref.name);\n    const isShorthand = propertyKey.value === propertyValue.name;\n    let pattern: t.ObjectPattern = rootPattern;\n    if (ref.section !== section) {\n      if (!nestedPatterns) nestedPatterns = [rootPattern];\n\n      const relativeDepth = rootDepth - ref.section.depth;\n      let i = nestedPatterns.length;\n      let prev = nestedPatterns[i - 1];\n      for (; i <= relativeDepth; i++) {\n        const nestedPattern = t.objectPattern([]);\n        prev.properties.push(\n          t.objectProperty(t.identifier(\"_\"), nestedPattern),\n        );\n        nestedPatterns.push(nestedPattern);\n        prev = nestedPattern;\n      }\n\n      pattern = nestedPatterns[relativeDepth];\n    }\n\n    pattern.properties.push(\n      t.objectProperty(\n        isShorthand ? propertyValue : propertyKey,\n        propertyValue,\n        false,\n        isShorthand,\n      ),\n    );\n  });\n\n  return rootPattern;\n}\n\nexport function getScopeExpression(section: Section, targetSection: Section) {\n  let scope: t.Expression = scopeIdentifier ?? t.identifier(\"undefined\");\n  const diff = section.depth - targetSection.depth;\n  for (let i = 0; i < diff; i++) {\n    scope = t.memberExpression(scope, t.identifier(\"_\"));\n  }\n  if (diff < 0) {\n    // TODO: handle hoisted references\n    throw new Error(\"Unable to find scope for reference.\");\n  }\n  return scope;\n}\n\nexport function createScopeReadExpression(\n  section: Section,\n  reference: Reserve,\n) {\n  return t.memberExpression(\n    getScopeExpression(section, reference.section),\n    getScopeAccessorLiteral(reference),\n    true,\n  );\n}\n","import { getTemplateId } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { callRuntime } from \"../../util/runtime\";\nimport {\n  forEachSectionReverse,\n  getSection,\n  getSectionPath,\n} from \"../../util/sections\";\nimport {\n  getClosures,\n  getDestructureSignal,\n  getResumeRegisterId,\n  getSignal,\n  getTagParamsSignal,\n  writeSignals,\n} from \"../../util/signals\";\nimport { visit } from \"../../util/walks\";\nimport * as writer from \"../../util/writer\";\n\nexport default {\n  translate: {\n    exit(program: t.NodePath<t.Program>) {\n      visit(program);\n      const section = getSection(program);\n      const templateIdentifier = t.identifier(\"template\");\n      const walksIdentifier = t.identifier(\"walks\");\n      const setupIdentifier = t.identifier(\"setup\");\n      const argsSignalIdentifier = t.identifier(\"args\");\n      const closuresIdentifier = t.identifier(\"closures\");\n      const { args } = program.node.extra;\n      const { walks, writes, setup } = writer.getSectionMeta(section);\n\n      forEachSectionReverse((childSection) => {\n        const sectionPath = getSectionPath(childSection);\n        const tagParamsSignal = sectionPath.isProgram()\n          ? undefined\n          : getTagParamsSignal(\n              (sectionPath as t.NodePath<t.MarkoTagBody>).get(\"params\"),\n            );\n        writeSignals(childSection);\n\n        if (childSection !== section) {\n          const { walks, writes, setup, register } =\n            writer.getSectionMeta(childSection);\n          const closures = getClosures(childSection);\n          const identifier = writer.getRenderer(childSection);\n          const renderer = callRuntime(\n            \"createRenderer\",\n            writes,\n            walks,\n            setup,\n            closures.length && t.arrayExpression(closures),\n            undefined,\n            tagParamsSignal?.build(),\n          );\n          program.node.body.push(\n            t.variableDeclaration(\"const\", [\n              t.variableDeclarator(\n                identifier,\n                //eslint-disable-next-line no-constant-condition\n                register || true\n                  ? callRuntime(\n                      \"register\",\n                      t.stringLiteral(\n                        getResumeRegisterId(childSection, \"renderer\"),\n                      ),\n                      renderer,\n                    )\n                  : renderer,\n              ),\n            ]),\n          );\n        }\n      });\n\n      if (args) {\n        const exportSpecifiers: t.ExportSpecifier[] = [];\n\n        for (const name in args.bindings) {\n          const bindingIdentifier = args.bindings[name];\n          const signalIdentifier = getSignal(\n            section,\n            bindingIdentifier.extra!.reserve,\n          ).identifier;\n          exportSpecifiers.push(\n            t.exportSpecifier(signalIdentifier, signalIdentifier),\n          );\n        }\n\n        program.node.body.push(\n          t.exportNamedDeclaration(\n            t.variableDeclaration(\"const\", [\n              t.variableDeclarator(\n                argsSignalIdentifier,\n                t.isIdentifier(args.var)\n                  ? getSignal(section, args.var.extra!.reserve!).identifier\n                  : getDestructureSignal(args.bindings, args.var)?.build(),\n              ),\n            ]),\n          ),\n          t.exportNamedDeclaration(null, exportSpecifiers),\n        );\n      }\n\n      const closures = getClosures(section);\n\n      program.node.body.push(\n        t.exportNamedDeclaration(\n          t.variableDeclaration(\"const\", [\n            t.variableDeclarator(\n              templateIdentifier,\n              writes || t.stringLiteral(\"\"),\n            ),\n          ]),\n        ),\n        t.exportNamedDeclaration(\n          t.variableDeclaration(\"const\", [\n            t.variableDeclarator(walksIdentifier, walks || t.stringLiteral(\"\")),\n          ]),\n        ),\n        t.exportNamedDeclaration(\n          t.variableDeclaration(\"const\", [\n            t.variableDeclarator(\n              setupIdentifier,\n              t.isNullLiteral(setup) || !setup\n                ? t.functionExpression(null, [], t.blockStatement([]))\n                : setup,\n            ),\n          ]),\n        ),\n      );\n      if (closures.length) {\n        program.node.body.push(\n          t.exportNamedDeclaration(\n            t.variableDeclaration(\"const\", [\n              t.variableDeclarator(\n                closuresIdentifier,\n                t.arrayExpression(closures),\n              ),\n            ]),\n          ),\n        );\n      }\n      const {\n        markoOpts: { optimize },\n        opts: { filename },\n      } = program.hub.file;\n      program.node.body.push(\n        t.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            callRuntime(\n              \"createRenderer\",\n              templateIdentifier,\n              walksIdentifier,\n              setupIdentifier,\n              closures.length && closuresIdentifier,\n              undefined,\n              args! && argsSignalIdentifier,\n            ),\n            t.stringLiteral(getTemplateId(optimize, `${filename}`)),\n          ),\n        ),\n      );\n    },\n  },\n};\n","import { getTemplateId } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { AccessorChar } from \"@marko/runtime-tags/common/types\";\nimport { returnId } from \"../core/return\";\nimport {\n  cleanIdentifier,\n  currentProgramPath,\n  scopeIdentifier,\n} from \"../visitors/program\";\nimport { isOutputHTML } from \"./marko-config\";\nimport { type Opt, type OneMany, push, forEach } from \"./optional\";\nimport type { References } from \"./references\";\nimport {\n  type Reserve,\n  ReserveType,\n  getScopeAccessorLiteral,\n  reserveUtil,\n} from \"./reserve\";\nimport { callRuntime } from \"./runtime\";\nimport { createScopeReadPattern, getScopeExpression } from \"./scope-read\";\nimport {\n  type Section,\n  createSectionState,\n  getOrCreateSection,\n  getScopeIdIdentifier,\n  getSection,\n} from \"./sections\";\n\nexport type subscribeBuilder = (subscriber: t.Expression) => t.Expression;\nexport type registerScopeBuilder = (scope: t.Expression) => t.Expression;\n\nexport type Signal = {\n  identifier: t.Identifier;\n  valueAccessor?: t.Expression;\n  reserve: Opt<Reserve>;\n  section: Section;\n  build: () => t.Expression;\n  register?: boolean;\n  isDynamicClosure?: boolean;\n  values: Array<{\n    signal: {\n      identifier: t.Identifier;\n      hasDownstreamIntersections: () => boolean;\n      buildDeclaration?: () => t.VariableDeclaration;\n    };\n    value: t.Expression;\n    scope: t.Expression;\n    intersectionExpression?: t.Expression;\n  }>;\n  intersection: Opt<t.Expression>;\n  render: t.Statement[];\n  effect: t.Statement[];\n  effectInlineReferences: Opt<Reserve>;\n  closures: Map<Section, Signal>;\n  hasDownstreamIntersections: () => boolean;\n  hasDynamicSubscribers?: true;\n};\n\nconst [getSignals] = createSectionState<Map<unknown, Signal>>(\n  \"signals\",\n  () => new Map(),\n);\nconst [getSubscribeBuilder, _setSubscribeBuilder] = createSectionState<\n  subscribeBuilder | undefined\n>(\"queue\");\nexport function setSubscriberBuilder(\n  tag: t.NodePath<t.MarkoTag>,\n  builder: subscribeBuilder,\n) {\n  _setSubscribeBuilder(getSection(tag.get(\"body\")), builder);\n}\n\nexport const [getClosures] = createSectionState<t.ArrayExpression[\"elements\"]>(\n  \"closures\",\n  () => [],\n);\nexport const addClosure = (\n  fromSection: Section,\n  toSection: Section,\n  closure: t.Expression,\n) => {\n  let currentSection: Section | undefined = fromSection;\n  while (currentSection !== undefined && currentSection !== toSection) {\n    getClosures(currentSection).push(closure);\n    currentSection = currentSection.parent;\n  }\n};\n\nconst [forceResumeScope, _setForceResumeScope] = createSectionState<\n  undefined | true\n>(\"forceResumeScope\");\nexport function setForceResumeScope(section: Section) {\n  _setForceResumeScope(section, true);\n}\nexport const [getSerializedScopeProperties] = createSectionState<\n  Map<t.StringLiteral | t.NumericLiteral, t.Expression>\n>(\"serializedScopeProperties\", () => new Map());\n\nconst [getRegisterScopeBuilder, _setRegisterScopeBuilder] = createSectionState<\n  registerScopeBuilder | undefined\n>(\"register\");\nexport function setRegisterScopeBuilder(\n  tag: t.NodePath<t.MarkoTag>,\n  builder: registerScopeBuilder,\n) {\n  _setRegisterScopeBuilder(getSection(tag.get(\"body\")), builder);\n}\n\nconst unimplementedBuild = () => {\n  return t.stringLiteral(\"SIGNAL NOT INITIALIZED\");\n};\n\nexport function getSignal(section: Section, reserve?: OneMany<Reserve>) {\n  const signals = getSignals(section);\n  let signal = signals.get(reserve)!;\n  if (!signal) {\n    signals.set(\n      reserve,\n      (signal = {\n        identifier: t.identifier(generateSignalName(section, reserve)),\n        reserve,\n        section,\n        values: [],\n        intersection: undefined,\n        render: [],\n        effect: [],\n        effectInlineReferences: undefined,\n        subscribers: [],\n        closures: new Map(),\n        hasDownstreamIntersections: () => {\n          if (\n            signal.intersection ||\n            signal.closures.size ||\n            signal.values.some((v) => v.signal.hasDownstreamIntersections())\n          ) {\n            signal.hasDownstreamIntersections = () => true;\n            return true;\n          } else {\n            signal.hasDownstreamIntersections = () => false;\n            return false;\n          }\n        },\n        build: unimplementedBuild,\n      } as Signal),\n    );\n\n    if (isOutputHTML()) {\n      return signal;\n    } else if (!reserve) {\n      signal.build = () => getSignalFn(signal, [scopeIdentifier]);\n    } else if (Array.isArray(reserve)) {\n      subscribe(reserve, signal);\n      signal.build = () => {\n        return callRuntime(\n          \"intersection\",\n          t.numericLiteral(reserve.length),\n          getSignalFn(signal, [scopeIdentifier], reserve),\n        );\n      };\n    } else if (reserve.section !== section) {\n      const provider = getSignal(reserve.section, reserve);\n      addClosure(\n        section,\n        section.parent! /*reserve.section*/,\n        signal.identifier,\n      );\n      provider.closures.set(section, signal);\n      signal.build = () => {\n        const builder = getSubscribeBuilder(section);\n        const ownerScope = getScopeExpression(section, reserve.section);\n        const isImmediateOwner =\n          (ownerScope as t.MemberExpression).object === scopeIdentifier;\n        const isDynamicClosure = (signal.isDynamicClosure = !(\n          isImmediateOwner && builder\n        ));\n        return callRuntime(\n          isDynamicClosure ? \"dynamicClosure\" : \"closure\",\n          getScopeAccessorLiteral(reserve),\n          getSignalFn(signal, [scopeIdentifier, t.identifier(reserve.name)]),\n          isImmediateOwner\n            ? null\n            : t.arrowFunctionExpression([scopeIdentifier], ownerScope),\n          buildSignalIntersections(signal),\n          buildSignalValuesWithIntersections(signal),\n        );\n      };\n    }\n  }\n  return signal;\n}\n\nexport function initValue(\n  reserve: Reserve,\n  valueAccessor = getScopeAccessorLiteral(reserve),\n) {\n  const section = reserve.section;\n  const signal = getSignal(section, reserve);\n  signal.build = () => {\n    const fn = getSignalFn(signal, [\n      scopeIdentifier,\n      t.identifier(reserve.name),\n    ]);\n    const intersections = buildSignalIntersections(signal);\n    const valuesWithIntersections = buildSignalValuesWithIntersections(signal);\n    if (\n      (fn.body as t.BlockStatement).body.length > 0 ||\n      intersections ||\n      valuesWithIntersections\n    ) {\n      return callRuntime(\n        \"value\",\n        valueAccessor,\n        fn,\n        intersections,\n        valuesWithIntersections,\n      );\n    } else {\n      return fn;\n    }\n  };\n  signal.valueAccessor = valueAccessor;\n  return signal;\n}\n\nexport function getSignalFn(\n  signal: Signal,\n  params: Array<t.Identifier | t.Pattern>,\n  references?: References,\n) {\n  const section = signal.section;\n\n  for (const value of signal.values) {\n    signal.render.push(\n      t.expressionStatement(\n        t.callExpression(value.signal.identifier, [value.scope, value.value]),\n      ),\n    );\n  }\n\n  if (references) {\n    signal.render.unshift(\n      t.variableDeclaration(\"const\", [\n        t.variableDeclarator(\n          createScopeReadPattern(section, references),\n          scopeIdentifier,\n        ),\n      ]),\n    );\n  }\n\n  return t.arrowFunctionExpression(params, t.blockStatement(signal.render));\n}\n\nexport function buildSignalIntersections(signal: Signal) {\n  const section = signal.section;\n  let intersections = signal.intersection;\n\n  // In order to ensure correct topological ordering, closures must be called last\n  // with closures higher in the tree called before calling closures lower in the tree\n  // TODO: use a repeatable of signals sorted by section\n  const closureEntries = Array.from(signal.closures.entries()).sort(\n    ([a], [b]) => a.id - b.id,\n  );\n  for (const [closureSection, closureSignal] of closureEntries) {\n    const builder = getSubscribeBuilder(closureSection);\n    const isImmediateOwner = closureSection.parent === section;\n    if (builder && isImmediateOwner) {\n      intersections = push(intersections, builder(closureSignal.identifier));\n    } else if (!signal.hasDynamicSubscribers) {\n      signal.hasDynamicSubscribers = true;\n    }\n  }\n  if (signal.hasDynamicSubscribers) {\n    signal.hasDynamicSubscribers = true;\n    intersections = push(\n      intersections,\n      callRuntime(\"dynamicSubscribers\", signal.valueAccessor),\n    );\n  }\n\n  return Array.isArray(intersections)\n    ? callRuntime(\"intersections\", t.arrayExpression(intersections))\n    : intersections;\n}\n\nexport function buildSignalValuesWithIntersections(signal: Signal) {\n  let valuesWithIntersections: Opt<t.Expression>;\n\n  for (const value of signal.values) {\n    if (value.signal.hasDownstreamIntersections()) {\n      valuesWithIntersections = push(\n        valuesWithIntersections,\n        value.intersectionExpression ??\n          t.identifier(value.signal.identifier.name),\n      );\n    }\n  }\n\n  return Array.isArray(valuesWithIntersections)\n    ? callRuntime(\"values\", t.arrayExpression(valuesWithIntersections))\n    : valuesWithIntersections;\n}\n\nexport function getTagVarSignal(varPath: t.NodePath<t.LVal | null>) {\n  if (varPath.isIdentifier()) {\n    return initValue(varPath.node.extra!.reserve!);\n  } else {\n    return getDestructureSignal(\n      Object.values(varPath.getBindingIdentifiers()) as t.Identifier[],\n      varPath.node!,\n    )!;\n  }\n}\n\nexport function getTagParamsSignal(\n  paramsPaths: t.NodePath<t.Identifier | t.RestElement | t.Pattern>[],\n  pattern: t.ArrayPattern = t.arrayPattern(\n    paramsPaths.map((path) => path.node!),\n  ),\n) {\n  const parameterBindings = paramsPaths.reduce((bindingsLookup, path) => {\n    return Object.assign(bindingsLookup, path.getBindingIdentifiers());\n  }, {});\n  return getDestructureSignal(parameterBindings, pattern);\n}\n\nexport function getDestructureSignal(\n  bindingsByName: Record<string, t.Identifier> | t.Identifier[],\n  destructurePattern: t.LVal,\n) {\n  const bindings = Array.isArray(bindingsByName)\n    ? bindingsByName\n    : Object.values(bindingsByName);\n  if (bindings.length) {\n    const valueIdentifier =\n      currentProgramPath.scope.generateUidIdentifier(\"destructure\");\n    const bindingSignals = bindings.map((binding) =>\n      initValue(binding.extra?.reserve as Reserve),\n    );\n\n    const declarations = t.variableDeclaration(\n      \"let\",\n      bindings.map((binding) => t.variableDeclarator(binding)),\n    );\n\n    return {\n      get identifier() {\n        const name =\n          currentProgramPath.scope.generateUidIdentifier(\"destructure\");\n        currentProgramPath.pushContainer(\"body\", [\n          t.variableDeclaration(\"const\", [\n            t.variableDeclarator(name, this.build(true)),\n          ]),\n        ]);\n        return name;\n      },\n      build(canCallOnlyWhenDirty?: boolean) {\n        if (canCallOnlyWhenDirty && !this.hasDownstreamIntersections()) {\n          return t.arrowFunctionExpression(\n            [scopeIdentifier, destructurePattern as t.Pattern],\n            t.blockStatement(\n              bindingSignals.map((signal, i) =>\n                t.expressionStatement(\n                  t.callExpression(signal.identifier, [\n                    scopeIdentifier,\n                    bindings[i],\n                  ]),\n                ),\n              ),\n            ),\n          );\n        }\n        return t.arrowFunctionExpression(\n          [scopeIdentifier, valueIdentifier, cleanIdentifier],\n          t.blockStatement([\n            declarations,\n            t.ifStatement(\n              t.unaryExpression(\"!\", cleanIdentifier),\n              t.expressionStatement(\n                t.assignmentExpression(\n                  \"=\",\n                  destructurePattern,\n                  valueIdentifier,\n                ),\n              ),\n            ),\n            ...bindingSignals.map((signal, i) =>\n              t.expressionStatement(\n                t.callExpression(signal.identifier, [\n                  scopeIdentifier,\n                  bindings[i],\n                  cleanIdentifier,\n                ]),\n              ),\n            ),\n          ]),\n        );\n      },\n      hasDownstreamIntersections() {\n        return bindings.some((binding) => {\n          const reserve = binding.extra!.reserve!;\n          const signal = getSignal(reserve.section, reserve);\n          return signal.hasDownstreamIntersections();\n        });\n      },\n    };\n  }\n}\n\nexport function subscribe(\n  provider: undefined | Reserve | Reserve[],\n  subscriber: Signal,\n) {\n  if (Array.isArray(provider)) {\n    provider.forEach((p) => subscribe(p, subscriber));\n    return;\n  }\n  const providerSignal = getSignal(subscriber.section, provider);\n  providerSignal.intersection = push(\n    providerSignal.intersection,\n    subscriber.identifier,\n  );\n}\n\nfunction generateSignalName(\n  section: Section,\n  references?: undefined | Reserve | Reserve[],\n) {\n  let name;\n\n  if (references) {\n    if (Array.isArray(references)) {\n      name = \"expr\";\n      for (const ref of references) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name = references.name;\n    }\n  } else {\n    name = \"setup\";\n  }\n\n  name += section.name.replace(\"_\", \"$\");\n  return currentProgramPath.scope.generateUid(name);\n}\n\nexport function queueSource(\n  source: Signal,\n  value: t.Expression,\n  targetSection: Section,\n) {\n  return callRuntime(\n    \"queueSource\",\n    getScopeExpression(targetSection, source.section),\n    source.identifier,\n    value,\n  );\n}\n\nexport function finalizeSignalArgs(args: t.Expression[]) {\n  for (let i = args.length - 1; i >= 0; i--) {\n    const arg = args[i];\n    if (t.isArrowFunctionExpression(arg)) {\n      const body = (arg.body as t.BlockStatement).body;\n      if (body) {\n        if (body.length === 0) {\n          args[i] = t.nullLiteral();\n        } else if (body.length === 1 && t.isExpressionStatement(body[0])) {\n          arg.body = body[0].expression;\n        }\n      }\n    }\n  }\n\n  for (let i = args.length - 1; t.isNullLiteral(args[i]); ) {\n    args.length = i--;\n  }\n}\nexport function addStatement(\n  type: \"effect\",\n  targetSection: Section,\n  references: References,\n  statement: t.Statement | t.Statement[],\n  originalNodes: t.Expression | t.Expression[],\n  isInlined?: boolean,\n): void;\nexport function addStatement(\n  type: \"render\",\n  targetSection: Section,\n  references: References,\n  statement: t.Statement | t.Statement[],\n): void;\nexport function addStatement(\n  type: \"render\" | \"effect\",\n  targetSection: Section,\n  references: References,\n  statement: t.Statement | t.Statement[],\n  originalNodes?: t.Expression | t.Expression[],\n  isInlined?: boolean,\n): void {\n  const signal = getSignal(targetSection, references);\n  const statements = (signal[type] ??= []);\n\n  if (Array.isArray(statement)) {\n    statements.push(...statement);\n  } else {\n    statements.push(statement);\n  }\n\n  if (type === \"effect\") {\n    if (Array.isArray(originalNodes)) {\n      for (const node of originalNodes) {\n        if (isInlined || !t.isFunction(node)) {\n          addEffectReferences(signal, node);\n        }\n      }\n    } else {\n      if (isInlined || !t.isFunction(originalNodes)) {\n        addEffectReferences(signal, originalNodes!);\n      }\n    }\n  }\n}\n\nexport function addValue(\n  targetSection: Section,\n  references: References,\n  signal: Signal[\"values\"][number][\"signal\"],\n  value: t.Expression,\n  scope: t.Expression = scopeIdentifier,\n  intersectionExpression?: t.Expression,\n) {\n  getSignal(targetSection, references).values.push({\n    signal,\n    value,\n    scope,\n    intersectionExpression,\n  });\n}\n\nexport function addEffectReferences(signal: Signal, expression: t.Expression) {\n  signal.effectInlineReferences = reserveUtil.union(\n    signal.effectInlineReferences,\n    (expression as t.FunctionExpression).extra?.references,\n  );\n}\n\nexport function getResumeRegisterId(\n  section: Section,\n  references: string | References,\n  type?: string,\n) {\n  const {\n    markoOpts: { optimize },\n    opts: { filename },\n  } = currentProgramPath.hub.file;\n  let name = \"\";\n  if (references) {\n    if (typeof references === \"string\") {\n      name += `_${references}`;\n    } else if (Array.isArray(references)) {\n      for (const ref of references) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name += `_${references.name}`;\n    }\n  }\n  return getTemplateId(\n    optimize,\n    `${filename}_${section.id}${name}${type ? \"/\" + type : \"\"}`,\n  );\n}\n\nexport function writeSignals(section: Section) {\n  const signals = [...getSignals(section).values()].sort(sortSignals);\n  for (const signal of signals) {\n    let effectDeclarator;\n    if (signal.effect.length) {\n      const effectIdentifier = t.identifier(`${signal.identifier.name}_effect`);\n\n      if (signal.effectInlineReferences) {\n        signal.effect.unshift(\n          t.variableDeclaration(\"const\", [\n            t.variableDeclarator(\n              createScopeReadPattern(section, signal.effectInlineReferences),\n              scopeIdentifier,\n            ),\n          ]),\n        );\n      }\n\n      effectDeclarator = t.variableDeclarator(\n        effectIdentifier,\n        callRuntime(\n          \"register\",\n          t.stringLiteral(getResumeRegisterId(section, signal.reserve)),\n          t.arrowFunctionExpression(\n            [scopeIdentifier],\n            signal.effect.length === 1 &&\n              t.isExpressionStatement(signal.effect[0])\n              ? signal.effect[0].expression\n              : t.blockStatement(signal.effect),\n          ),\n        ),\n      );\n      signal.render.push(\n        t.expressionStatement(\n          callRuntime(\"queueEffect\", scopeIdentifier, effectIdentifier),\n        ),\n      );\n    }\n\n    let value = signal.build();\n\n    if (t.isCallExpression(value)) {\n      finalizeSignalArgs(value.arguments as any as t.Expression[]);\n    }\n\n    if (signal.register) {\n      value = callRuntime(\n        \"register\",\n        t.stringLiteral(getResumeRegisterId(section, signal.reserve)),\n        value,\n      );\n    }\n\n    if (signal.isDynamicClosure) {\n      value = callRuntime(\n        \"registerSubscriber\",\n        t.stringLiteral(\n          getResumeRegisterId(section, signal.reserve, \"subscriber\"),\n        ),\n        value,\n      );\n    }\n\n    const signalDeclarator = t.variableDeclarator(signal.identifier, value);\n    const roots = currentProgramPath.pushContainer(\n      \"body\",\n      effectDeclarator\n        ? [\n            t.variableDeclaration(\"const\", [effectDeclarator]),\n            t.variableDeclaration(\"const\", [signalDeclarator]),\n          ]\n        : t.variableDeclaration(\"const\", [signalDeclarator]),\n    );\n\n    for (const root of roots) {\n      root.traverse(bindFunctionsVisitor, { root, section });\n    }\n  }\n}\n\nfunction sortSignals(a: Signal, b: Signal) {\n  const aReserves = getReserves(a);\n  const bReserves = getReserves(b);\n\n  for (let i = Math.max(aReserves.length, bReserves.length) - 1; i >= 0; i--) {\n    const diff = (bReserves[i] ?? -1) - (aReserves[i] ?? -1);\n    if (diff !== 0) return diff;\n  }\n\n  return 0;\n}\n\nfunction getReserves({ reserve }: Signal) {\n  if (!reserve) {\n    return [];\n  } else if (Array.isArray(reserve)) {\n    return reserve.map(getMappedId).sort();\n  } else {\n    return [getMappedId(reserve)];\n  }\n}\n\nfunction getMappedId(reserve: Reserve) {\n  return (reserve.type === 0 ? 1 : 0) * 10000 + reserve.id;\n}\n\nexport function addHTMLEffectCall(section: Section, references?: References) {\n  // TODO: this should not add an undefined statement.\n  addStatement(\"effect\", section, references, undefined as any, []);\n}\n\nexport function writeHTMLResumeStatements(\n  path: t.NodePath<t.MarkoTagBody | t.Program>,\n  tagVarIdentifier?: t.Identifier,\n) {\n  const section = getOrCreateSection(path);\n  const intersections =\n    currentProgramPath.node.extra.intersectionsBySection?.[section.id];\n  const allSignals = Array.from(getSignals(section).values());\n  const scopeIdIdentifier = getScopeIdIdentifier(section);\n  const closures = section.closures;\n\n  let serializedReferences: Opt<Reserve>;\n\n  // TODO: currently reserves do not know what their references are.\n  // ideally we calculate that in analyze and use that to find intersections.\n  if (intersections) {\n    for (const intersection of intersections) {\n      for (const reference of intersection) {\n        if (reference.type !== ReserveType.Visit) {\n          // TODO: this should not be needed\n          serializedReferences = reserveUtil.add(\n            serializedReferences,\n            reference,\n          );\n        }\n      }\n    }\n  }\n\n  if (closures) {\n    for (const closure of closures) {\n      let currentSection = section;\n      while (currentSection !== closure.section) {\n        getSerializedScopeProperties(currentSection).set(\n          t.stringLiteral(\"_\"),\n          callRuntime(\n            \"serializedScope\",\n            getScopeIdIdentifier((currentSection = currentSection.parent!)),\n          ),\n        );\n      }\n    }\n  }\n\n  for (let i = allSignals.length; i--; ) {\n    if (allSignals[i].effect.length) {\n      const signalRefs = allSignals[i].reserve;\n      serializedReferences = reserveUtil.union(\n        serializedReferences,\n        signalRefs,\n      );\n      path.pushContainer(\n        \"body\",\n        t.expressionStatement(\n          callRuntime(\n            \"writeEffect\",\n            scopeIdIdentifier,\n            t.stringLiteral(getResumeRegisterId(section, signalRefs)),\n          ),\n        ),\n      );\n    }\n  }\n\n  const accessors = new Set<string | number>();\n  const additionalProperties = getSerializedScopeProperties(section);\n  const serializedProperties: t.ObjectProperty[] = [];\n  forEach(serializedReferences, (ref) => {\n    const accessor = getScopeAccessorLiteral(ref);\n    if (ref.section.id === section.id) {\n      serializedProperties.push(\n        t.objectProperty(accessor, t.identifier(ref.name)),\n      );\n      accessors.add(accessor.value);\n    } else {\n      const isImmediateOwner = section.parent?.id === ref.section.id;\n      // TODO: getSubscribeBuilder is not the right check\n      // the builder shouldn't get set for the HTML output\n      // we're setting it to an empty builder from if/for purely for this check\n      const isDynamicClosure =\n        !getSubscribeBuilder(section) || !isImmediateOwner;\n      if (isDynamicClosure) {\n        path.pushContainer(\n          \"body\",\n          t.expressionStatement(\n            callRuntime(\n              \"writeEffect\",\n              scopeIdIdentifier,\n              t.stringLiteral(getResumeRegisterId(section, ref, \"subscriber\")),\n            ),\n          ),\n        );\n      }\n      getSerializedScopeProperties(ref.section).set(\n        accessor,\n        t.identifier(ref.name),\n      );\n    }\n  });\n\n  if (tagVarIdentifier && returnId(section) !== undefined) {\n    serializedProperties.push(\n      t.objectProperty(\n        t.stringLiteral(AccessorChar.TagVariable),\n        tagVarIdentifier,\n      ),\n    );\n  }\n\n  for (const [key, value] of additionalProperties) {\n    if (!accessors.has(key.value)) {\n      serializedProperties.push(\n        t.objectProperty(key, value, !t.isLiteral(key)),\n      );\n      accessors.add(key.value);\n    }\n  }\n\n  if (serializedProperties.length || forceResumeScope(section)) {\n    const builder = getRegisterScopeBuilder(section);\n    path.pushContainer(\n      \"body\",\n      t.expressionStatement(\n        callRuntime(\n          \"writeScope\",\n          scopeIdIdentifier,\n          builder\n            ? builder(t.objectExpression(serializedProperties))\n            : t.objectExpression(serializedProperties),\n        ),\n      ),\n    );\n  }\n\n  if (path.get(\"body\").length) {\n    path.unshiftContainer(\n      \"body\",\n      t.variableDeclaration(\"const\", [\n        t.variableDeclarator(scopeIdIdentifier, callRuntime(\"nextScopeId\")),\n      ]),\n    );\n  }\n}\n\nconst bindFunctionsVisitor: t.Visitor<{\n  root: t.NodePath<any>;\n  section: Section;\n}> = {\n  FunctionExpression: { exit: bindFunction },\n  ArrowFunctionExpression: { exit: bindFunction },\n};\n\nfunction bindFunction(\n  fn: t.NodePath<t.FunctionExpression | t.ArrowFunctionExpression>,\n  { root, section }: { root: t.NodePath<any>; section: Section },\n) {\n  const { node } = fn;\n  const { extra } = node;\n  const references = extra?.references;\n  const program = fn.hub.file.path;\n  const functionIdentifier = program.scope.generateUidIdentifier(extra?.name);\n\n  if (references) {\n    if (node.body.type !== \"BlockStatement\") {\n      node.body = t.blockStatement([t.returnStatement(node.body)]);\n    }\n\n    node.body.body.unshift(\n      t.variableDeclaration(\"const\", [\n        t.variableDeclarator(\n          createScopeReadPattern(section, references),\n          scopeIdentifier,\n        ),\n      ]),\n    );\n  }\n\n  let parent: t.NodePath | null = fn.parentPath;\n  while (parent) {\n    if (parent.isFunction()) return;\n    if (parent === root) return;\n    parent = parent.parentPath;\n  }\n\n  root.insertBefore(\n    t.variableDeclaration(\"const\", [\n      t.variableDeclarator(functionIdentifier, node),\n    ]),\n  );\n\n  node.params.unshift(scopeIdentifier);\n  fn.replaceWith(\n    callRuntime(\"bindFunction\", scopeIdentifier, functionIdentifier),\n  );\n}\n\nexport function getSetup(section: Section) {\n  return getSignals(section).get(undefined)?.identifier;\n}\n","import { type Tag, assertNoParams, assertNoVar } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { assertNoBodyContent, assertNoSpreadAttrs } from \"../util/assert\";\nimport { isOutputHTML } from \"../util/marko-config\";\nimport { importRuntime } from \"../util/runtime\";\nimport { createSectionState, getSection } from \"../util/sections\";\nimport { addValue } from \"../util/signals\";\nimport * as writer from \"../util/writer\";\n\nconst [returnId, _setReturnId] = createSectionState<t.Identifier | undefined>(\n  \"returnId\",\n);\nexport { returnId };\n\nexport default {\n  translate(tag) {\n    assertNoVar(tag);\n    assertNoParams(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n\n    const section = getSection(tag);\n\n    const {\n      node,\n      hub: { file },\n    } = tag;\n    const [defaultAttr] = node.attributes;\n\n    if (!t.isMarkoAttribute(defaultAttr) || !defaultAttr.default) {\n      throw tag\n        .get(\"name\")\n        .buildCodeFrameError(\n          `The '<return>' tag requires default attribute like '<return=VALUE>'.`,\n        );\n    }\n\n    if (node.attributes.length > 1) {\n      const start = node.attributes[1].loc?.start;\n      const end = node.attributes[node.attributes.length - 1].loc?.end;\n      const msg = `The '<return>' tag only supports a default attribute.`;\n\n      if (start == null || end == null) {\n        throw tag.get(\"name\").buildCodeFrameError(msg);\n      } else {\n        throw tag.hub.buildError(\n          { loc: { start, end } } as unknown as t.Node,\n          msg,\n          Error,\n        );\n      }\n    }\n\n    const { value } = defaultAttr;\n\n    if (isOutputHTML()) {\n      writer.flushBefore(tag);\n      const returnId = file.path.scope.generateUidIdentifier(\"return\");\n      _setReturnId(section, returnId);\n\n      tag\n        .replaceWith(\n          t.variableDeclaration(\"const\", [\n            t.variableDeclarator(returnId, value),\n          ]),\n        )[0]\n        .skip();\n    } else {\n      addValue(\n        section,\n        value.extra?.references,\n        {\n          identifier: importRuntime(\"tagVarSignal\"),\n          hasDownstreamIntersections: () => true,\n        },\n        value,\n      );\n\n      tag.remove();\n    }\n  },\n  autocomplete: [\n    {\n      displayText: \"return=<value>\",\n      description: \"Provides a value for use in a parent template.\",\n      snippet: \"return=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#return\",\n    },\n  ],\n} as Tag;\n","import type { types as t } from \"@marko/compiler\";\n\nexport function assertNoSpreadAttrs(tag: t.NodePath<t.MarkoTag>) {\n  for (const attr of tag.get(\"attributes\")) {\n    if (attr.isMarkoSpreadAttribute()) {\n      throw attr.buildCodeFrameError(\n        `The <${tag.get(\"name\")}> tag does not support ...spread attributes.`,\n      );\n    }\n  }\n}\n\nexport function assertNoBodyContent(tag: t.NodePath<t.MarkoTag>) {\n  if (tag.node.body.body.length) {\n    throw tag\n      .get(\"name\")\n      .buildCodeFrameError(\n        `The <${tag.get(\"name\")}> tag does not support body content.`,\n      );\n  }\n}\n","import { types as t } from \"@marko/compiler\";\nimport {\n  type Section,\n  createSectionState,\n  getScopeIdIdentifier,\n  getSection,\n  ContentType,\n} from \"../util/sections\";\nimport { isOutputHTML } from \"./marko-config\";\nimport { ReserveType, getScopeAccessorLiteral } from \"./reserve\";\nimport { callRuntime } from \"./runtime\";\nimport { getSetup } from \"./signals\";\nimport toTemplateOrStringLiteral, {\n  appendLiteral,\n} from \"./to-template-string-or-literal\";\nimport { getWalkString } from \"./walks\";\n\nconst [getRenderer] = createSectionState<t.Identifier>(\n  \"renderer\",\n  (section: Section) => t.identifier(section.name),\n);\n\nexport { getRenderer };\n\nconst [getWrites] = createSectionState<(string | t.Expression)[]>(\n  \"writes\",\n  () => [\"\"],\n);\n\nconst [getRegisterRenderer, setRegisterRenderer] = createSectionState<boolean>(\n  \"registerRenderer\",\n  () => false,\n);\n\nexport { setRegisterRenderer };\n\nexport function writeTo(path: t.NodePath<any>) {\n  const section = getSection(path);\n  return (\n    strs: TemplateStringsArray,\n    ...exprs: Array<string | t.Expression>\n  ): void => {\n    const exprsLen = exprs.length;\n    const writes = getWrites(section);\n    appendLiteral(writes, strs[0]);\n\n    for (let i = 0; i < exprsLen; i++) {\n      writes.push(exprs[i], strs[i + 1]);\n    }\n  };\n}\n\nexport function consumeHTML(path: t.NodePath<any>) {\n  const writes = getWrites(getSection(path));\n  const result = toTemplateOrStringLiteral(writes);\n\n  writes.length = 0;\n  writes[0] = \"\";\n\n  if (result) {\n    return t.expressionStatement(callRuntime(\"write\", result));\n  }\n}\n\nexport function hasPendingHTML(\n  path: t.NodePath<t.MarkoTag> | t.NodePath<t.Program>,\n) {\n  const writes = getWrites(getSection(path));\n  return Boolean(writes.length > 1 || writes[0]);\n}\n\nexport function flushBefore(path: t.NodePath<any>) {\n  const expr = consumeHTML(path);\n  if (expr) {\n    path.insertBefore(expr)[0].skip();\n  }\n}\n\nexport function flushInto(\n  path: t.NodePath<t.MarkoTag> | t.NodePath<t.Program>,\n) {\n  const target = (path.isProgram() ? path : path.get(\"body\")) as t.NodePath<\n    t.Program | t.MarkoTagBody\n  >;\n  const expr = consumeHTML(target);\n  if (expr) {\n    target.pushContainer(\"body\", expr)[0].skip();\n  }\n}\n\nexport function getSectionMeta(section: Section) {\n  const writePrefix =\n    section.startNodeContentType === ContentType.Dynamic ? \"<!>\" : \"\";\n  const writePostfix =\n    section.endNodeContentType === ContentType.Dynamic ? \"<!>\" : \"\";\n  const writes = getWrites(section);\n  return {\n    setup: getSetup(section),\n    walks: getWalkString(section),\n    writes:\n      toTemplateOrStringLiteral([writePrefix, ...writes, writePostfix]) ||\n      t.stringLiteral(\"\"),\n    register: getRegisterRenderer(section),\n  };\n}\n\nexport function markNode(path: t.NodePath<t.MarkoTag | t.MarkoPlaceholder>) {\n  const section = getSection(path);\n  const { reserve } = path.node.extra!;\n\n  if (reserve?.type !== ReserveType.Visit) {\n    throw path.buildCodeFrameError(\n      \"Tried to mark a node that was not determined to need a mark during analyze.\",\n    );\n  }\n\n  if (isOutputHTML()) {\n    writeTo(path)`${callRuntime(\n      \"markResumeNode\",\n      getScopeIdIdentifier(section),\n      getScopeAccessorLiteral(reserve!),\n    )}`;\n  }\n}\n","import { types as t } from \"@marko/compiler\";\n\nexport default function toTemplateOrStringLiteral(\n  parts: (string | t.Expression)[],\n): t.StringLiteral | t.TemplateLiteral | undefined {\n  const strs: string[] = [];\n  const exprs: t.Expression[] = [];\n  let curStr: string = parts[0] as string;\n\n  for (let i = 1; i < parts.length; i++) {\n    let content = parts[i];\n\n    if (typeof content === \"object\") {\n      if (t.isStringLiteral(content)) {\n        content = content.value;\n      } else if (t.isTemplateLiteral(content)) {\n        let nextIndex = i + 1;\n        const exprLen = content.expressions.length;\n        shiftItems(parts, nextIndex, content.quasis.length + exprLen);\n\n        for (let j = 0; j < exprLen; j++) {\n          parts[nextIndex++] = content.quasis[j].value.raw;\n          parts[nextIndex++] = content.expressions[j] as t.Expression;\n        }\n\n        parts[nextIndex] = content.quasis[exprLen].value.raw;\n        continue;\n      } else {\n        exprs.push(content);\n        strs.push(curStr);\n        curStr = \"\";\n        continue;\n      }\n    }\n\n    curStr += content;\n  }\n\n  if (exprs.length) {\n    strs.push(curStr);\n\n    return t.templateLiteral(\n      strs.map((raw) => t.templateElement({ raw })),\n      exprs,\n    );\n  } else if (curStr) {\n    return t.stringLiteral(curStr);\n  }\n}\n\nexport function appendLiteral(arr: unknown[], str: string) {\n  arr[arr.length - 1] += str;\n}\n\nfunction shiftItems(list: unknown[], start: number, offset: number) {\n  for (let i = list.length - 1; i >= start; i--) {\n    list[i + offset] = list[i];\n  }\n}\n","import { types as t } from \"@marko/compiler\";\nimport { WalkCode, WalkRangeSize } from \"@marko/runtime-tags/common/types\";\nimport { ReserveType } from \"../util/reserve\";\nimport {\n  type Section,\n  createSectionState,\n  getSection,\n  ContentType,\n} from \"../util/sections\";\nimport { isOutputHTML } from \"./marko-config\";\nimport toTemplateOrStringLiteral, {\n  appendLiteral,\n} from \"./to-template-string-or-literal\";\nimport { writeTo } from \"./writer\";\n\nconst [getWalks] = createSectionState<(string | t.Expression)[]>(\n  \"walks\",\n  () => [\"\"],\n);\nconst [getWalkComment] = createSectionState<(string | t.Expression)[]>(\n  \"walkComment\",\n  () => [],\n);\nconst [getSteps] = createSectionState<Step[]>(\"steps\", () => []);\n\nexport enum Step {\n  Enter,\n  Exit,\n}\n\nconst walkCodeToName = {\n  [WalkCode.Get]: \"get\",\n  [WalkCode.Before]: \"before\",\n  [WalkCode.After]: \"after\",\n  [WalkCode.Inside]: \"inside\",\n  [WalkCode.Replace]: \"replace\",\n  [WalkCode.EndChild]: \"endChild\",\n  [WalkCode.BeginChild]: \"beginChild\",\n  [WalkCode.Next]: \"next\",\n  [WalkCode.Over]: \"over\",\n  [WalkCode.Out]: \"out\",\n  [WalkCode.Multiplier]: \"multiplier\",\n  [WalkCode.NextEnd]: \"nextEnd\",\n  [WalkCode.OverEnd]: \"overEnd\",\n  [WalkCode.OutEnd]: \"outEnd\",\n  [WalkCode.MultiplierEnd]: \"multiplierEnd\",\n};\n\ntype VisitCodes =\n  | WalkCode.Get\n  | WalkCode.Before\n  | WalkCode.After\n  | WalkCode.Inside\n  | WalkCode.Replace;\n\nexport function enter(path: t.NodePath<any>) {\n  getSteps(getSection(path)).push(Step.Enter);\n}\n\nexport function exit(path: t.NodePath<any>) {\n  getSteps(getSection(path)).push(Step.Exit);\n}\n\nexport function enterShallow(path: t.NodePath<any>) {\n  getSteps(getSection(path)).push(Step.Enter, Step.Exit);\n}\n\nexport function injectWalks(path: t.NodePath<any>, expr: t.Expression) {\n  const walks = getWalks(getSection(path));\n  const walkComment = getWalkComment(getSection(path));\n  walkComment.push(\n    `${walkCodeToName[WalkCode.BeginChild]}`,\n    (expr as t.Identifier).name,\n    walkCodeToName[WalkCode.EndChild],\n  );\n  appendLiteral(walks, String.fromCharCode(WalkCode.BeginChild));\n  walks.push(expr, String.fromCharCode(WalkCode.EndChild));\n}\n\nexport function visit(\n  path: t.NodePath<t.MarkoTag | t.MarkoPlaceholder | t.Program>,\n  code?: VisitCodes,\n) {\n  const { reserve } = path.node.extra!;\n  if (code && (!reserve || reserve.type !== ReserveType.Visit)) {\n    throw path.buildCodeFrameError(\n      \"Tried to visit a node that was not marked as needing to visit during analyze.\",\n    );\n  }\n\n  if (isOutputHTML()) {\n    return;\n  }\n\n  const section = getSection(path);\n  const steps = getSteps(section);\n  const walks = getWalks(section);\n  const walkComment = getWalkComment(section);\n\n  let walkString = \"\";\n\n  if (steps.length) {\n    const walks: WalkCode[] = [];\n    let depth = 0;\n\n    for (const step of steps) {\n      if (step === Step.Enter) {\n        depth++;\n        walks.push(WalkCode.Next);\n      } else {\n        depth--;\n        if (depth >= 0) {\n          // delete back to and including previous NEXT\n          walks.length = walks.lastIndexOf(WalkCode.Next);\n          walks.push(WalkCode.Over);\n        } else {\n          // delete back to previous OUT\n          walks.length = walks.lastIndexOf(WalkCode.Out) + 1;\n          walks.push(WalkCode.Out);\n          depth = 0;\n        }\n      }\n    }\n\n    let current = walks[0];\n    let count = 0;\n\n    for (const walk of walks) {\n      if (walk !== current) {\n        walkComment.push(`${walkCodeToName[current]}(${count})`);\n        walkString += nCodeString(current, count);\n        current = walk;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n\n    walkComment.push(`${walkCodeToName[current]}(${count})`);\n    walkString += nCodeString(current, count);\n    steps.length = 0;\n  }\n\n  if (code !== undefined) {\n    if (code !== WalkCode.Get) {\n      writeTo(path)`<!>`;\n    }\n    walkComment.push(`${walkCodeToName[code]}`);\n    walkString += String.fromCharCode(code);\n  }\n\n  appendLiteral(walks, walkString);\n}\n\nfunction nCodeString(code: WalkCode, number: number) {\n  switch (code) {\n    case WalkCode.Next:\n      return toCharString(number, code, WalkRangeSize.Next);\n    case WalkCode.Over:\n      return toCharString(number, code, WalkRangeSize.Over);\n    case WalkCode.Out:\n      return toCharString(number, code, WalkRangeSize.Out);\n    default:\n      throw new Error(`Unexpected walk code: ${code}`);\n  }\n}\n\nfunction toCharString(number: number, startCode: number, rangeSize: number) {\n  let result = \"\";\n\n  if (number >= rangeSize) {\n    const multiplier = Math.floor(number / rangeSize);\n    result += toCharString(\n      multiplier,\n      WalkCode.Multiplier,\n      WalkRangeSize.Multiplier,\n    );\n    number -= multiplier * rangeSize;\n  }\n\n  result += String.fromCharCode(startCode + number);\n  return result;\n}\n\nexport function getWalkString(section: Section) {\n  const prefix =\n    section.startNodeContentType === ContentType.Dynamic\n      ? String.fromCharCode(WalkCode.Next + 1)\n      : \"\";\n  const postfix =\n    section.endNodeContentType === ContentType.Dynamic\n      ? String.fromCharCode(WalkCode.Next + 1)\n      : \"\";\n  const walks = getWalks(section);\n  const walkLiteral =\n    toTemplateOrStringLiteral([prefix, ...walks, postfix]) ||\n    t.stringLiteral(\"\");\n  if ((walkLiteral as t.StringLiteral).value !== \"\") {\n    walkLiteral.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: \" \" + getWalkComment(section).join(\", \") + \" \",\n      } as t.CommentBlock,\n    ] as const;\n  }\n  return walkLiteral;\n}\n","import { getTemplateId } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { returnId } from \"../../core/return\";\nimport isStatic from \"../../util/is-static\";\nimport { callRuntime } from \"../../util/runtime\";\nimport { getSection } from \"../../util/sections\";\nimport { writeHTMLResumeStatements } from \"../../util/signals\";\nimport { flushInto } from \"../../util/writer\";\n\nexport default {\n  translate: {\n    exit(program: t.NodePath<t.Program>) {\n      const section = getSection(program);\n      const tagVarIdentifier = program.scope.generateUidIdentifier(\"tagVar\");\n\n      flushInto(program);\n      writeHTMLResumeStatements(program, tagVarIdentifier);\n\n      const returnIdentifier = returnId(section);\n      if (returnIdentifier !== undefined) {\n        program.pushContainer(\"body\", t.returnStatement(returnIdentifier));\n      }\n\n      const renderContent: t.Statement[] = [];\n\n      for (const child of program.get(\"body\")) {\n        if (!isStatic(child)) {\n          renderContent.push(child.node);\n          child.remove();\n        } else if (child.isMarkoScriptlet()) {\n          child.replaceWithMultiple(child.node.body);\n        }\n      }\n\n      const rendererId = program.scope.generateUidIdentifier(\"renderer\");\n      const { args } = program.node.extra;\n      const {\n        markoOpts: { optimize },\n        opts: { filename },\n      } = program.hub.file;\n      program.pushContainer(\"body\", [\n        t.variableDeclaration(\"const\", [\n          t.variableDeclarator(\n            rendererId,\n            callRuntime(\n              \"createRenderer\",\n              t.arrowFunctionExpression(\n                [\n                  args ? (args.var as any) : t.identifier(\"input\"),\n                  tagVarIdentifier,\n                ],\n                t.blockStatement(renderContent),\n              ),\n            ),\n          ),\n        ]),\n\n        t.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            rendererId,\n            t.stringLiteral(getTemplateId(optimize, `${filename}`)),\n          ),\n        ),\n      ]);\n    },\n  },\n};\n","import type { types as t } from \"@marko/compiler\";\nexport default function isStatic(path: t.NodePath<any>) {\n  return (\n    path.isImportDeclaration() ||\n    path.isExportDeclaration() ||\n    path.isMarkoScriptlet({ static: true })\n  );\n}\n","import type { Tag } from \"@marko/babel-utils\";\nimport { currentProgramPath } from \"../visitors/program\";\n\nexport default {\n  migrate: [\n    (tag) => {\n      // TODO: this is kinda just \"flush here\" right now\n      // but it should replicate the behavior of the tag in Marko 5\n      tag.replaceWithMultiple(tag.node.body.body);\n      currentProgramPath.scope.crawl();\n    },\n  ],\n} as Tag;\n","import type { Tag } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { isOutputHTML } from \"../util/marko-config\";\nimport { trackReferencesForBindings } from \"../util/references\";\nimport { getOrCreateSection } from \"../util/sections\";\nimport { initValue } from \"../util/signals\";\nimport { currentProgramPath } from \"../visitors/program\";\n\ndeclare module \"@marko/compiler/dist/types\" {\n  export interface ProgramExtra {\n    args?: {\n      bindings: Record<string, t.Identifier>;\n      var: NonNullable<t.MarkoTag[\"var\"]>;\n    };\n  }\n}\n\nexport default {\n  analyze(tag) {\n    if (tag.has(\"var\")) {\n      const varPath = tag.get(\"var\");\n      const bindings = varPath.getBindingIdentifiers() as any as Record<\n        string,\n        t.Identifier\n      >;\n      trackReferencesForBindings(getOrCreateSection(tag), varPath);\n      (currentProgramPath.node.extra ??= {}).args = {\n        bindings,\n        var: isOutputHTML() ? varPath.node! : t.arrayPattern([varPath.node!]),\n        // pathsToId: getPathsToId(varPath.node)\n      };\n    }\n  },\n  translate(tag) {\n    const bindings = currentProgramPath.node.extra?.args?.bindings;\n    if (bindings) {\n      for (const key in bindings) {\n        initValue(bindings[key].extra!.reserve!);\n      }\n    }\n\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"attrs/{ ... }\",\n      description: \"Use to receive the attributes passed into this template.\",\n      snippet: \"attrs/{ $1 }$2\",\n    },\n  ],\n} as Tag;\n","import { type Tag, assertNoParams, assertNoVar } from \"@marko/babel-utils\";\nimport type { types as t } from \"@marko/compiler\";\nimport customTag from \"../../visitors/tag/custom-tag\";\nimport {\n  enterBranchTranslate,\n  exitBranchAnalyze,\n  exitBranchTranslate,\n} from \"./if\";\n\nexport default {\n  analyze: {\n    enter(tag) {\n      customTag.analyze.enter(tag);\n    },\n    exit(tag) {\n      exitBranchAnalyze(tag);\n    },\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [testAttr] = node.attributes;\n\n      assertNoVar(tag);\n      assertNoParams(tag);\n\n      if (\n        node.attributes.length > 1 ||\n        (testAttr && (testAttr as t.MarkoAttribute).name !== \"if\")\n      ) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<else>' tag only supports an if attribute.`;\n\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError(\n            { loc: { start, end } } as unknown as t.Node,\n            msg,\n            Error,\n          );\n        }\n      }\n\n      enterBranchTranslate(tag);\n    },\n    exit(tag) {\n      exitBranchTranslate(tag);\n    },\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description:\n        \"Use after an <if> or <else-if> tag to display content if those conditions do not match.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\",\n    },\n  ],\n} as Tag;\n","import {\n  assertAttributesOrArgs,\n  assertAttributesOrSingleArg,\n  getTagTemplate,\n  importDefault,\n  importNamed,\n  loadFileForTag,\n  resolveRelativePath,\n} from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport attrsToObject, { getRenderBodyProp } from \"../../util/attrs-to-object\";\nimport { isOutputHTML } from \"../../util/marko-config\";\nimport trackReferences, { mergeReferences } from \"../../util/references\";\nimport {\n  ReserveType,\n  getScopeAccessorLiteral,\n  reserveScope,\n} from \"../../util/reserve\";\nimport { callRuntime } from \"../../util/runtime\";\nimport { createScopeReadExpression } from \"../../util/scope-read\";\nimport {\n  getOrCreateSection,\n  getScopeIdIdentifier,\n  getSection,\n  startSection,\n} from \"../../util/sections\";\nimport {\n  addStatement,\n  addValue,\n  getClosures,\n  getResumeRegisterId,\n  getSerializedScopeProperties,\n  initValue,\n  setForceResumeScope,\n  writeHTMLResumeStatements,\n} from \"../../util/signals\";\nimport translateVar from \"../../util/translate-var\";\nimport * as walks from \"../../util/walks\";\nimport * as writer from \"../../util/writer\";\nimport { currentProgramPath, scopeIdentifier } from \"../program\";\n\ndeclare module \"@marko/compiler/dist/types\" {\n  export interface ProgramExtra {\n    hasInteractiveChild?: boolean;\n  }\n}\n\nexport default {\n  analyze: {\n    enter(tag: t.NodePath<t.MarkoTag>) {\n      trackReferences(tag);\n\n      const body = tag.get(\"body\");\n      if (body.get(\"body\").length) {\n        startSection(body);\n      }\n\n      if (getTagTemplate(tag)) {\n        reserveScope(\n          ReserveType.Visit,\n          getOrCreateSection(tag),\n          tag.node,\n          \"#childScope\",\n        );\n      }\n\n      const childFile = loadFileForTag(tag)!;\n      const childProgramExtra = childFile?.ast.program.extra;\n      const hasInteractiveChild =\n        childProgramExtra?.isInteractive ||\n        childProgramExtra?.hasInteractiveChild;\n\n      if (hasInteractiveChild) {\n        (currentProgramPath.node.extra ?? {}).hasInteractiveChild = true;\n        // TODO: should check individual inputs to see if they are intersecting with state\n      }\n    },\n    exit(tag: t.NodePath<t.MarkoTag>) {\n      // TODO: only if dynamic attributes\n      const template = getTagTemplate(tag);\n      if (template) {\n        mergeReferences(\n          tag,\n          tag.node.attributes.map((attr) => attr.value),\n        );\n      }\n    },\n  },\n  translate: {\n    enter(tag: t.NodePath<t.MarkoTag>) {\n      if (tag.node.extra?.tagNameDefine) {\n        assertAttributesOrArgs(tag);\n      } else {\n        assertAttributesOrSingleArg(tag);\n      }\n\n      walks.visit(tag);\n      if (isOutputHTML()) {\n        writer.flushBefore(tag);\n      }\n    },\n    exit(tag: t.NodePath<t.MarkoTag>) {\n      if (isOutputHTML()) {\n        translateHTML(tag);\n      } else {\n        translateDOM(tag);\n      }\n    },\n  },\n};\n\nfunction translateHTML(tag: t.NodePath<t.MarkoTag>) {\n  const tagBody = tag.get(\"body\");\n  const { node } = tag;\n  let tagIdentifier: t.Expression;\n\n  writer.flushInto(tag);\n  writeHTMLResumeStatements(tagBody);\n\n  if (node.extra!.tagNameDefine) {\n    tagIdentifier = t.memberExpression(node.name, t.identifier(\"renderBody\"));\n  } else if (t.isStringLiteral(node.name)) {\n    const { file } = tag.hub;\n    const tagName = node.name.value;\n    const relativePath = getTagRelativePath(tag);\n\n    tagIdentifier = t.memberExpression(\n      importDefault(file, relativePath, tagName),\n      t.identifier(\"_\"),\n    );\n  } else {\n    tagIdentifier = t.memberExpression(node.name, t.identifier(\"_\"));\n  }\n\n  const tagVar = node.var;\n  const attrsObject = attrsToObject(tag, true);\n  const renderBodyProp = getRenderBodyProp(attrsObject);\n  const section = getSection(tag);\n  const binding = node.extra!.reserve!;\n  const peekScopeId = tag.scope.generateUidIdentifier(binding.name);\n  tag.insertBefore(\n    t.variableDeclaration(\"const\", [\n      t.variableDeclarator(peekScopeId, callRuntime(\"peekSerializedScope\")),\n    ]),\n  );\n\n  getSerializedScopeProperties(section).set(\n    getScopeAccessorLiteral(node.extra!.reserve!),\n    peekScopeId,\n  );\n\n  if (node.extra!.tagNameNullable) {\n    let renderBodyId: t.Identifier | undefined = undefined;\n    let renderTagExpr: t.Expression = callExpression(\n      tagIdentifier,\n      attrsToObject(tag),\n    );\n\n    if (renderBodyProp) {\n      const renderBodySection = getSection(tag.get(\"body\"));\n      renderBodyId = tag.scope.generateUidIdentifier(\"renderBody\");\n      const [renderBodyPath] = tag.insertBefore(\n        t.variableDeclaration(\"const\", [\n          t.variableDeclarator(\n            renderBodyId,\n            // TODO: only register if needed (child template analysis)\n            callRuntime(\n              \"register\",\n              callRuntime(\n                \"createRenderer\",\n                t.arrowFunctionExpression(\n                  renderBodyProp.params,\n                  renderBodyProp.body,\n                ),\n              ),\n              t.stringLiteral(\n                getResumeRegisterId(renderBodySection, \"renderer\"),\n              ),\n              getScopeIdIdentifier(section),\n            ),\n          ),\n        ]),\n      );\n\n      renderBodyPath.skip();\n\n      (attrsObject as t.ObjectExpression).properties[\n        (attrsObject as t.ObjectExpression).properties.length - 1\n      ] = t.objectProperty(t.identifier(\"renderBody\"), renderBodyId);\n    }\n\n    if (tagVar) {\n      translateVar(tag, t.unaryExpression(\"void\", t.numericLiteral(0)), \"let\");\n      renderTagExpr = t.assignmentExpression(\"=\", tagVar, renderTagExpr);\n    }\n\n    tag\n      .replaceWith(\n        t.ifStatement(\n          tagIdentifier,\n          t.expressionStatement(renderTagExpr),\n          renderBodyId && callStatement(renderBodyId),\n        ),\n      )[0]\n      .skip();\n  } else if (tagVar) {\n    translateVar(\n      tag,\n      callExpression(\n        tagIdentifier,\n        attrsObject,\n        callRuntime(\n          \"register\",\n          callRuntime(\n            \"createRenderer\",\n            t.arrowFunctionExpression([], t.blockStatement([])),\n          ),\n          t.stringLiteral(\n            getResumeRegisterId(\n              section,\n              (node.var as t.Identifier).extra?.reserve,\n            ),\n          ),\n          getScopeIdIdentifier(section),\n        ),\n      ),\n    );\n    setForceResumeScope(section);\n    tag.remove();\n  } else {\n    tag.replaceWith(callStatement(tagIdentifier, attrsObject))[0].skip();\n  }\n}\n\nfunction translateDOM(tag: t.NodePath<t.MarkoTag>) {\n  const tagSection = getSection(tag);\n  const tagBody = tag.get(\"body\");\n  const tagBodySection = getSection(tagBody);\n  const { node } = tag;\n  const extra = node.extra!;\n  const write = writer.writeTo(tag);\n  const binding = extra.reserve!;\n  const { file } = tag.hub;\n  const tagName = t.isIdentifier(node.name)\n    ? node.name.name\n    : (node.name as t.StringLiteral).value;\n  const relativePath = getTagRelativePath(tag);\n  const childFile = loadFileForTag(tag)!;\n  const childProgram = childFile.ast.program;\n  const tagIdentifier = importNamed(file, relativePath, \"setup\", tagName);\n  let tagAttrsIdentifier: t.Identifier | undefined;\n  if (childProgram.extra.args) {\n    tagAttrsIdentifier = importNamed(\n      file,\n      relativePath,\n      \"args\",\n      `${tagName}_args`,\n    );\n  }\n  write`${importNamed(file, relativePath, \"template\", `${tagName}_template`)}`;\n  walks.injectWalks(\n    tag,\n    importNamed(file, relativePath, \"walks\", `${tagName}_walks`),\n  );\n\n  if (childProgram.extra.closures) {\n    getClosures(tagSection).push(\n      callRuntime(\n        \"childClosures\",\n        importNamed(file, relativePath, \"closures\", `${tagName}_closures`),\n        getScopeAccessorLiteral(binding),\n      ),\n    );\n  }\n\n  let attrsObject = attrsToObject(tag);\n\n  if (tagBodySection !== tagSection) {\n    attrsObject ??= t.objectExpression([]);\n    (attrsObject as t.ObjectExpression).properties.push(\n      t.objectProperty(\n        t.identifier(\"renderBody\"),\n        callRuntime(\n          \"bindRenderer\",\n          scopeIdentifier,\n          writer.getRenderer(tagBodySection),\n        ),\n      ),\n    );\n  }\n\n  if (node.var) {\n    const source = initValue(\n      // TODO: support destructuring\n      node.var.extra!.reserve!,\n    );\n    source.register = true;\n    addStatement(\n      \"render\",\n      tagSection,\n      undefined,\n      t.expressionStatement(\n        callRuntime(\n          \"setTagVar\",\n          scopeIdentifier,\n          getScopeAccessorLiteral(binding),\n          source.identifier,\n        ),\n      ),\n    );\n  }\n  addStatement(\n    \"render\",\n    tagSection,\n    undefined,\n    t.expressionStatement(\n      t.callExpression(tagIdentifier, [\n        createScopeReadExpression(tagSection, binding),\n      ]),\n    ),\n  );\n  if (attrsObject && tagAttrsIdentifier) {\n    addValue(\n      tagSection,\n      extra.references,\n      {\n        identifier: tagAttrsIdentifier,\n        hasDownstreamIntersections: () => true,\n      },\n      t.arrayExpression([attrsObject]),\n      createScopeReadExpression(tagSection, binding),\n      callRuntime(\n        \"inChild\",\n        getScopeAccessorLiteral(binding),\n        t.identifier(tagAttrsIdentifier.name),\n      ),\n    );\n  }\n  tag.remove();\n}\n\nexport function getTagRelativePath(tag: t.NodePath<t.MarkoTag>) {\n  const {\n    node,\n    hub: { file },\n  } = tag;\n  const nameIsString = t.isStringLiteral(node.name);\n  let relativePath: string | undefined;\n\n  if (nameIsString) {\n    const template = getTagTemplate(tag);\n    relativePath = template && resolveRelativePath(file, template);\n  } else if (node.extra?.tagNameImported) {\n    relativePath = node.extra.tagNameImported;\n  }\n\n  if (!relativePath) {\n    throw tag\n      .get(\"name\")\n      .buildCodeFrameError(\n        `Unable to find entry point for custom tag <${\n          nameIsString ? (node.name as t.StringLiteral).value : node.name\n        }>.`,\n      );\n  }\n\n  const tags = file.metadata.marko.tags!;\n  if (!tags.includes(relativePath)) {\n    tags.push(relativePath);\n  }\n\n  return relativePath;\n}\n\nfunction callStatement(\n  id: t.Expression,\n  ...args: Array<t.Expression | undefined>\n) {\n  return t.expressionStatement(callExpression(id, ...args));\n}\n\nfunction callExpression(\n  id: t.Expression,\n  ...args: Array<t.Expression | undefined>\n) {\n  return t.callExpression(id, args.filter(Boolean) as t.Expression[]);\n}\n","import { types as t } from \"@marko/compiler\";\nimport { currentProgramPath, scopeIdentifier } from \"../visitors/program\";\nimport { isOutputHTML } from \"./marko-config\";\nimport { forEach } from \"./optional\";\nimport { getScopeAccessorLiteral } from \"./reserve\";\nimport { callRuntime } from \"./runtime\";\nimport { createScopeReadPattern } from \"./scope-read\";\nimport { getScopeIdIdentifier, getSection, type Section } from \"./sections\";\nimport { getSerializedScopeProperties } from \"./signals\";\nimport toPropertyName from \"./to-property-name\";\n\nconst htmlHoistFunctionVisitor: t.Visitor<{ section: Section }> = {\n  FunctionExpression: { exit: htmlFunctionVisit },\n  ArrowFunctionExpression: { exit: htmlFunctionVisit },\n};\n\nconst domHoistFunctionVisitor: t.Visitor<{ section: Section }> = {\n  FunctionExpression: { exit: domFunctionVisit },\n  ArrowFunctionExpression: { exit: domFunctionVisit },\n};\n\nfunction htmlFunctionVisit(\n  fn: t.NodePath<t.FunctionExpression | t.ArrowFunctionExpression>,\n  state: { section: Section },\n) {\n  const serializedScopeProperties = getSerializedScopeProperties(state.section);\n  const extra = fn.node.extra!;\n  forEach(extra.references, (ref) => {\n    serializedScopeProperties.set(\n      getScopeAccessorLiteral(ref),\n      t.identifier(ref.name),\n    );\n  });\n  fn.replaceWith(\n    callRuntime(\n      \"register\",\n      fn.node,\n      t.stringLiteral(extra.registerId!),\n      getScopeIdIdentifier(state.section),\n    ),\n  )[0].skip();\n}\n\nfunction domFunctionVisit(\n  fn: t.NodePath<t.FunctionExpression | t.ArrowFunctionExpression>,\n  state: { section: Section },\n) {\n  const { node } = fn;\n  const extra = node.extra!;\n  const fnId = currentProgramPath.scope.generateUidIdentifier(extra.name);\n\n  if (extra.references) {\n    if (node.body.type !== \"BlockStatement\") {\n      node.body = t.blockStatement([t.returnStatement(node.body)]);\n    }\n\n    node.body.body.unshift(\n      t.variableDeclaration(\"const\", [\n        t.variableDeclarator(\n          createScopeReadPattern(state.section, extra.references),\n          scopeIdentifier,\n        ),\n      ]),\n    );\n  }\n\n  node.params.unshift(scopeIdentifier);\n  currentProgramPath\n    .pushContainer(\n      \"body\",\n      t.variableDeclaration(\"const\", [\n        t.variableDeclarator(\n          fnId,\n          callRuntime(\"register\", t.stringLiteral(extra.registerId!), node),\n        ),\n      ]),\n    )[0]\n    .skip();\n\n  fn.replaceWith(callRuntime(\"bindFunction\", scopeIdentifier, fnId))[0].skip();\n}\n\nexport default function attrsToObject(\n  tag: t.NodePath<t.MarkoTag>,\n  withRenderBody = false,\n): t.Expression {\n  const { node } = tag;\n  let result: t.Expression = t.objectExpression([]);\n  const resultExtra = (result.extra = {});\n  const section = getSection(tag);\n  const hoistVisitor = isOutputHTML()\n    ? htmlHoistFunctionVisitor\n    : domHoistFunctionVisitor;\n\n  for (const attr of tag.get(\"attributes\")) {\n    attr.traverse(hoistVisitor, { section });\n    const value = attr.node.value!;\n\n    if (attr.isMarkoSpreadAttribute()) {\n      result.properties.push(t.spreadElement(value));\n    } else {\n      result.properties.push(\n        t.objectProperty(\n          toPropertyName((attr as t.NodePath<t.MarkoAttribute>).node.name),\n          value,\n        ),\n      );\n    }\n  }\n\n  if (withRenderBody) {\n    const { body, params } = node.body;\n    let hoistedControlFlows = node.extra!.hoistedControlFlows;\n\n    if (hoistedControlFlows) {\n      for (const child of tag.get(\"body\").get(\"body\")) {\n        tag.insertBefore(child.node);\n        child.remove();\n\n        if (child.isConditional() || child.isLoop()) {\n          if (!--hoistedControlFlows) {\n            break;\n          }\n        }\n      }\n    }\n\n    if (body.length) {\n      (result as t.ObjectExpression).properties.push(\n        t.objectMethod(\n          \"method\",\n          t.identifier(\"renderBody\"),\n          params,\n          t.blockStatement(body),\n        ),\n      );\n    }\n  }\n\n  if (result.properties.length) {\n    if (result.properties.length === 1) {\n      const [prop] = result.properties;\n\n      if (t.isSpreadElement(prop)) {\n        result = prop.argument;\n        result.extra = resultExtra;\n      }\n    }\n  }\n\n  if (node.arguments?.length) {\n    if ((result as t.ObjectExpression).properties.length) {\n      result = t.arrayExpression([...node.arguments, result]);\n    } else if (node.arguments.length == 1) {\n      const arg = node.arguments[0];\n      result = t.isSpreadElement(arg) ? arg.argument : arg;\n    } else {\n      result = t.arrayExpression(node.arguments);\n    }\n  }\n\n  return result;\n}\n\nexport function getRenderBodyProp(\n  attrsObject: ReturnType<typeof attrsToObject>,\n) {\n  if (t.isObjectExpression(attrsObject)) {\n    // renderBody prop is always added last.\n    const lastProp = attrsObject.properties[attrsObject.properties.length - 1];\n\n    if (\n      t.isObjectMethod(lastProp) &&\n      (lastProp.key as t.Identifier).name === \"renderBody\"\n    ) {\n      return lastProp;\n    }\n  }\n}\n","import { types as t } from \"@marko/compiler\";\n\nconst IDENTIFIER_REG = /^[0-9A-Z_$]+$/i;\n\nexport default function toPropertyName(name: string) {\n  return IDENTIFIER_REG.test(name) ? t.identifier(name) : t.stringLiteral(name);\n}\n","import { types as t } from \"@marko/compiler\";\n\nexport default function translateVar(\n  tag: t.NodePath<t.MarkoTag>,\n  initialValue: t.Expression,\n  kind: \"let\" | \"const\" = \"const\",\n) {\n  const {\n    node: { var: tagVar },\n  } = tag;\n\n  if (!tagVar) {\n    return;\n  }\n\n  tag.get(\"var\").remove();\n  tag.insertBefore(\n    t.variableDeclaration(kind, [\n      t.variableDeclarator(t.cloneDeep(tagVar), initialValue),\n    ]),\n  );\n  tag.hub.file.path.scope.crawl();\n}\n","import { type Tag, assertNoParams, assertNoVar } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { WalkCode } from \"@marko/runtime-tags/common/types\";\nimport { isCoreTagName } from \"../../util/is-core-tag\";\nimport { isOutputDOM, isOutputHTML } from \"../../util/marko-config\";\nimport analyzeAttributeTags from \"../../util/nested-attribute-tags\";\nimport { mergeReferences } from \"../../util/references\";\nimport {\n  ReserveType,\n  getScopeAccessorLiteral,\n  reserveScope,\n} from \"../../util/reserve\";\nimport { callRuntime } from \"../../util/runtime\";\nimport {\n  type Section,\n  getOrCreateSection,\n  getScopeIdIdentifier,\n  getScopeIdentifier,\n  getSection,\n} from \"../../util/sections\";\nimport {\n  addValue,\n  getClosures,\n  getResumeRegisterId,\n  getSerializedScopeProperties,\n  getSignal,\n  getSignalFn,\n  setForceResumeScope,\n  setRegisterScopeBuilder,\n  setSubscriberBuilder,\n  writeHTMLResumeStatements,\n} from \"../../util/signals\";\nimport toFirstStatementOrBlock from \"../../util/to-first-statement-or-block\";\nimport * as walks from \"../../util/walks\";\nimport * as writer from \"../../util/writer\";\nimport { scopeIdentifier } from \"../../visitors/program\";\nimport customTag from \"../../visitors/tag/custom-tag\";\n\nexport default {\n  analyze: {\n    enter(tag) {\n      reserveScope(\n        ReserveType.Visit,\n        getOrCreateSection(tag),\n        tag.node,\n        tag.scope.generateUid(\"if\"),\n        \"#text\",\n      );\n      customTag.analyze.enter(tag);\n    },\n    exit(tag) {\n      analyzeAttributeTags(tag);\n      exitBranchAnalyze(tag);\n    },\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [testAttr] = node.attributes;\n\n      assertNoVar(tag);\n      assertNoParams(tag);\n\n      if (!t.isMarkoAttribute(testAttr) || !testAttr.default) {\n        throw tag\n          .get(\"name\")\n          .buildCodeFrameError(\n            `The '<if>' tag requires a default attribute like '<if=condition>'.`,\n          );\n      }\n\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<if>' tag only supports a default attribute.`;\n\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError(\n            { loc: { start, end } } as unknown as t.Node,\n            msg,\n            Error,\n          );\n        }\n      }\n\n      walks.visit(tag, WalkCode.Replace);\n      walks.enterShallow(tag);\n      if (isOutputHTML()) {\n        writer.flushBefore(tag);\n      }\n      enterBranchTranslate(tag);\n    },\n    exit(tag) {\n      exitBranchTranslate(tag);\n    },\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      snippet: \"if=${1:condition}\",\n      description: \"Use to display content only if the condition is met.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\",\n    },\n  ],\n} as Tag;\n\nconst BRANCHES_LOOKUP = new WeakMap<\n  t.NodePath<t.MarkoTag>,\n  {\n    tag: t.NodePath<t.MarkoTag>;\n    section: Section;\n  }[]\n>();\n\nfunction getBranches(tag: t.NodePath<t.MarkoTag>, bodySection: Section) {\n  const branches = BRANCHES_LOOKUP.get(tag) ?? [];\n  const nextTag = tag.getNextSibling();\n  const isLast = !(\n    isCoreTagName(nextTag, \"else\") || isCoreTagName(nextTag, \"else-if\")\n  );\n\n  branches.push({\n    tag,\n    section: bodySection,\n  });\n\n  if (!isLast) {\n    BRANCHES_LOOKUP.set(nextTag as t.NodePath<t.MarkoTag>, branches);\n  }\n\n  return [isLast, branches] as const;\n}\n\nfunction getRoot(tag: t.NodePath<t.MarkoTag>) {\n  if (isCoreTagName(tag, \"if\")) {\n    return tag;\n  }\n  return BRANCHES_LOOKUP.get(tag)![0].tag;\n}\n\nexport function exitBranchAnalyze(tag: t.NodePath<t.MarkoTag>) {\n  const tagBody = tag.get(\"body\");\n  const bodySection = getOrCreateSection(tagBody);\n  const [isLast, branches] = getBranches(tag, bodySection);\n  if (isLast) {\n    const rootTag = branches[0].tag;\n    const rootExtra = rootTag.node.extra!;\n    const references = mergeReferences(\n      rootTag,\n      branches.map(({ tag }) => tag.node.attributes[0]?.value),\n    );\n    rootExtra.isStateful = !!references;\n    rootExtra.singleNodeOptimization = branches.every(({ tag }) => {\n      return tag.node.body.body.length === 1;\n    });\n  }\n}\n\nexport function enterBranchTranslate(tag: t.NodePath<t.MarkoTag>) {\n  const tagBody = tag.get(\"body\");\n  const bodySection = getSection(tagBody);\n  const rootExtra = getRoot(tag).node.extra!;\n  const isStateful = rootExtra.isStateful;\n  const singleNodeOptimization = rootExtra.singleNodeOptimization;\n\n  if (isOutputHTML() && isStateful && !singleNodeOptimization) {\n    writer.writeTo(tagBody)`${callRuntime(\n      \"markResumeScopeStart\",\n      getScopeIdIdentifier(bodySection),\n    )}`;\n  }\n}\n\nexport function exitBranchTranslate(tag: t.NodePath<t.MarkoTag>) {\n  const tagBody = tag.get(\"body\");\n  const section = getSection(tag);\n  const bodySection = getSection(tagBody);\n  const [isLast, branches] = getBranches(tag, bodySection);\n  const rootExtra = branches[0].tag.node.extra!;\n  const isStateful = rootExtra.isStateful;\n  const singleNodeOptimization = rootExtra.singleNodeOptimization;\n\n  if (isOutputHTML()) {\n    if (isStateful) {\n      setRegisterScopeBuilder(tag, (scope: t.Expression) => {\n        return t.assignmentExpression(\n          \"=\",\n          getScopeIdentifier(bodySection),\n          scope,\n        );\n      });\n      setForceResumeScope(bodySection);\n    }\n    writer.flushInto(tag);\n    // TODO: this is a hack to get around the fact that we don't have a way to\n    // know if a scope requires dynamic subscriptions\n    setSubscriberBuilder(tag, (() => {}) as any);\n    writeHTMLResumeStatements(tagBody);\n  }\n\n  if (isLast) {\n    const extra = branches[0].tag.node.extra!;\n    if (isOutputDOM()) {\n      let expr: t.Expression = t.nullLiteral();\n\n      for (let i = branches.length; i--; ) {\n        const { tag, section } = branches[i];\n        const [testAttr] = tag.node.attributes;\n        const id = writer.getRenderer(section);\n\n        setSubscriberBuilder(tag, (subscriber) => {\n          return callRuntime(\n            \"inConditionalScope\",\n            subscriber,\n            getScopeAccessorLiteral(extra.reserve!),\n            /*writer.getRenderer(section)*/\n          );\n        });\n\n        if (isStateful) {\n          writer.setRegisterRenderer(section, true);\n        }\n\n        tag.remove();\n\n        if (testAttr) {\n          expr = t.conditionalExpression(testAttr.value, id, expr);\n        } else {\n          expr = id;\n        }\n      }\n\n      const signal = getSignal(section, extra.reserve);\n      signal.build = () => {\n        return callRuntime(\n          \"conditional\",\n          getScopeAccessorLiteral(extra.reserve!),\n          getSignalFn(signal, [scopeIdentifier]),\n        );\n      };\n      signal.hasDownstreamIntersections = () =>\n        branches.some((b) => getClosures(b.section).length > 0);\n      addValue(section, extra.references, signal, expr);\n    } else {\n      const write = writer.writeTo(tag);\n      const nextTag = tag.getNextSibling();\n      const ifScopeIdIdentifier = tag.scope.generateUidIdentifier(\"ifScopeId\");\n      const ifScopeIdentifier = getScopeIdentifier(branches[0].section);\n      const ifRendererIdentifier =\n        tag.scope.generateUidIdentifier(\"ifRenderer\");\n\n      let statement: t.Statement | undefined;\n      for (let i = branches.length; i--; ) {\n        const { tag, section } = branches[i];\n        const branchScopeIdentifier = getScopeIdentifier(section, true);\n        branchScopeIdentifier.name = ifScopeIdentifier.name;\n\n        if (isStateful) {\n          tag.node.body.body.push(\n            t.expressionStatement(\n              callRuntime(\n                \"register\",\n                t.assignmentExpression(\n                  \"=\",\n                  ifRendererIdentifier,\n                  callRuntime(\n                    \"createRenderer\",\n                    t.arrowFunctionExpression([], t.blockStatement([])),\n                  ),\n                ),\n                t.stringLiteral(getResumeRegisterId(section, \"renderer\")),\n              ),\n            ) as any,\n          );\n\n          if (singleNodeOptimization) {\n            tag.node.body.body.push(\n              t.expressionStatement(\n                t.assignmentExpression(\n                  \"=\",\n                  ifScopeIdIdentifier,\n                  getScopeIdIdentifier(section),\n                ),\n              ) as any,\n            );\n          }\n        }\n\n        const [testAttr] = tag.node.attributes;\n        const curStatement = toFirstStatementOrBlock(tag.node.body);\n\n        if (testAttr) {\n          statement = t.ifStatement(testAttr.value, curStatement, statement);\n        } else {\n          statement = curStatement;\n        }\n\n        tag.remove();\n      }\n\n      if (!isStateful) {\n        nextTag.insertBefore(statement!);\n      } else {\n        nextTag.insertBefore([\n          t.variableDeclaration(\n            \"let\",\n            [\n              singleNodeOptimization &&\n                t.variableDeclarator(ifScopeIdIdentifier),\n              t.variableDeclarator(ifScopeIdentifier),\n              t.variableDeclarator(ifRendererIdentifier),\n            ].filter(Boolean) as t.VariableDeclarator[],\n          ),\n          statement!,\n        ]);\n        if (singleNodeOptimization) {\n          write`${callRuntime(\n            \"markResumeControlSingleNodeEnd\",\n            getScopeIdIdentifier(section),\n            getScopeAccessorLiteral(extra.reserve!),\n            ifScopeIdIdentifier,\n          )}`;\n        } else {\n          write`${callRuntime(\n            \"markResumeControlEnd\",\n            getScopeIdIdentifier(section),\n            getScopeAccessorLiteral(extra.reserve!),\n          )}`;\n        }\n        getSerializedScopeProperties(section).set(\n          t.stringLiteral(getScopeAccessorLiteral(extra.reserve!).value + \"!\"),\n          ifScopeIdentifier,\n        );\n        getSerializedScopeProperties(section).set(\n          t.stringLiteral(getScopeAccessorLiteral(extra.reserve!).value + \"(\"),\n          ifRendererIdentifier,\n        );\n      }\n    }\n  }\n}\n","import {\n  isAttributeTag,\n  isLoopTag,\n  isTransparentTag,\n} from \"@marko/babel-utils\";\nimport type { types as t } from \"@marko/compiler\";\n\ntype Lookup = Record<\n  string,\n  {\n    identifier?: t.Identifier;\n    dynamic: boolean;\n    repeated: boolean;\n  }\n>;\n\ndeclare module \"@marko/compiler/dist/types\" {\n  export interface MarkoTagExtra {\n    hoistedControlFlows?: number;\n    nestedAttributeTags?: Lookup;\n  }\n}\n\nexport default function analyzeAttributeTags(tag: t.NodePath<t.MarkoTag>) {\n  const extra = (tag.node.extra ??= {});\n  extra.nestedAttributeTags = {};\n  extra.hoistedControlFlows = 0;\n  analyzeChildren(extra, false, false, tag);\n}\n\nfunction analyzeChildren(\n  rootExtra: NonNullable<t.MarkoTag[\"extra\"]>,\n  repeated: boolean,\n  dynamic: boolean,\n  tag: t.NodePath<t.MarkoTag>,\n) {\n  let hasAttributeTags = false;\n  for (const child of tag.get(\"body\").get(\"body\")) {\n    if (child.isMarkoTag()) {\n      if (analyzeChild(rootExtra, repeated, dynamic, child)) {\n        hasAttributeTags = true;\n      }\n    }\n  }\n\n  return hasAttributeTags;\n}\n\nfunction analyzeChild(\n  rootExtra: NonNullable<t.MarkoTag[\"extra\"]>,\n  repeated: boolean,\n  dynamic: boolean,\n  tag: t.NodePath<t.MarkoTag>,\n) {\n  if (isTransparentTag(tag)) {\n    if (analyzeChildren(rootExtra, repeated || isLoopTag(tag), true, tag)) {\n      if (\n        !isTransparentTag(tag.parentPath.parentPath as t.NodePath<t.MarkoTag>)\n      ) {\n        rootExtra.hoistedControlFlows!++;\n      }\n      return true;\n    }\n  } else if (isAttributeTag(tag)) {\n    const attrName = (tag.node.name as t.StringLiteral).value.slice(1);\n    const lookup = rootExtra.nestedAttributeTags!;\n    const existing = lookup[attrName];\n    const info =\n      existing ||\n      (lookup[attrName] = {\n        dynamic: false,\n        repeated: false,\n      });\n\n    info.dynamic ||= dynamic;\n    info.repeated ||= repeated || existing !== undefined;\n    return true;\n  }\n\n  return false;\n}\n","import { types as t } from \"@marko/compiler\";\nexport default function toFirstStatementOrBlock(\n  body: t.BlockStatement | t.MarkoTagBody,\n) {\n  const nodes = body.body;\n\n  if (nodes.length === 1) {\n    return nodes[0];\n  }\n\n  if (t.isBlockStatement(body)) {\n    return body;\n  }\n\n  return t.blockStatement(nodes);\n}\n","import { type Tag, assertNoParams, assertNoVar } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport customTag from \"../../visitors/tag/custom-tag\";\nimport {\n  enterBranchTranslate,\n  exitBranchAnalyze,\n  exitBranchTranslate,\n} from \"./if\";\n\nexport default {\n  analyze: {\n    enter(tag) {\n      customTag.analyze.enter(tag);\n    },\n    exit(tag) {\n      exitBranchAnalyze(tag);\n    },\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [defaultAttr] = node.attributes;\n\n      assertNoVar(tag);\n      assertNoParams(tag);\n\n      if (!t.isMarkoAttribute(defaultAttr) || !defaultAttr.default) {\n        throw tag\n          .get(\"name\")\n          .buildCodeFrameError(\n            `The '<else-if>' tag requires a default attribute like '<else-if=condition>'.`,\n          );\n      }\n\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<else-if>' tag only supports a default attribute.`;\n\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError(\n            { loc: { start, end } } as unknown as t.Node,\n            msg,\n            Error,\n          );\n        }\n      }\n\n      enterBranchTranslate(tag);\n    },\n    exit(tag) {\n      exitBranchTranslate(tag);\n    },\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      snippet: \"else-if=${1:condition}\",\n      description:\n        \"Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\",\n    },\n  ],\n} as Tag;\n","import { type Tag, assertNoParams } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { assertNoBodyContent } from \"../util/assert\";\nimport { isOutputDOM } from \"../util/marko-config\";\nimport { getSection } from \"../util/sections\";\nimport { addValue, getTagVarSignal } from \"../util/signals\";\nimport translateVar from \"../util/translate-var\";\n\nexport default {\n  translate(tag) {\n    const { node } = tag;\n    const [defaultAttr] = node.attributes;\n\n    assertNoParams(tag);\n    assertNoBodyContent(tag);\n\n    if (!node.var) {\n      throw tag\n        .get(\"name\")\n        .buildCodeFrameError(\"The 'const' tag requires a tag variable.\");\n    }\n\n    if (!defaultAttr) {\n      throw tag\n        .get(\"name\")\n        .buildCodeFrameError(\"The 'const' tag requires a default attribute.\");\n    }\n\n    if (\n      node.attributes.length > 1 ||\n      !t.isMarkoAttribute(defaultAttr) ||\n      (!defaultAttr.default && defaultAttr.name !== \"value\")\n    ) {\n      throw tag\n        .get(\"name\")\n        .buildCodeFrameError(\n          \"The 'const' tag only supports the 'default' attribute.\",\n        );\n    }\n\n    const { value } = defaultAttr;\n\n    if (isOutputDOM()) {\n      const section = getSection(tag);\n      const derivation = getTagVarSignal(tag.get(\"var\"))!;\n\n      // TODO: optimize for cases like `const/x=y`\n      addValue(section, value.extra?.references, derivation, value);\n    } else {\n      translateVar(tag, value);\n    }\n\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an constant binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#const\",\n    },\n  ],\n} as Tag;\n","import { type Tag } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport attrsToObject from \"../util/attrs-to-object\";\nimport { isOutputHTML } from \"../util/marko-config\";\nimport { mergeReferences } from \"../util/references\";\nimport { callRuntime } from \"../util/runtime\";\nimport { getSection } from \"../util/sections\";\nimport {\n  addValue,\n  getTagVarSignal,\n  writeHTMLResumeStatements,\n} from \"../util/signals\";\nimport translateVar from \"../util/translate-var\";\nimport * as writer from \"../util/writer\";\nimport { scopeIdentifier } from \"../visitors/program\";\nimport customTag from \"../visitors/tag/custom-tag\";\n\nexport default {\n  analyze: {\n    enter(tag: t.NodePath<t.MarkoTag>) {\n      customTag.analyze.enter(tag);\n    },\n    exit(tag: t.NodePath<t.MarkoTag>) {\n      customTag.analyze.exit(tag);\n      mergeReferences(\n        tag,\n        tag.node.attributes.map((attr) => attr.value),\n      );\n    },\n  },\n  translate: {\n    enter(tag) {\n      if (!tag.node.var) {\n        throw tag\n          .get(\"name\")\n          .buildCodeFrameError(\n            \"<define> requires a variable to be specified, eg <define/NAME>.\",\n          );\n      }\n      if (isOutputHTML()) {\n        writer.flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n\n      if (isOutputHTML()) {\n        writer.flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        const attrs = attrsToObject(tag, true);\n        translateVar(tag, attrs);\n      } else {\n        const section = getSection(tag);\n        const tagBody = tag.get(\"body\");\n        const tagBodySection = getSection(tagBody);\n        const references = node.extra?.references;\n        const derivation = getTagVarSignal(tag.get(\"var\"))!;\n\n        let attrsObject = attrsToObject(tag);\n        if (tagBodySection !== section) {\n          attrsObject ??= t.objectExpression([]);\n          (attrsObject as t.ObjectExpression).properties.push(\n            t.objectProperty(\n              t.identifier(\"renderBody\"),\n              callRuntime(\n                \"bindRenderer\",\n                scopeIdentifier,\n                writer.getRenderer(tagBodySection),\n              ),\n            ),\n          );\n        }\n\n        addValue(section, references, derivation, attrsObject);\n      }\n\n      tag.remove();\n    },\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description:\n        \"Use to create a constant object binding that can be rendered.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#define\",\n    },\n  ],\n} as Tag;\n","import { type Tag, assertNoParams } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { assertNoBodyContent } from \"../util/assert\";\nimport { isOutputDOM } from \"../util/marko-config\";\nimport { getSection } from \"../util/sections\";\nimport { addHTMLEffectCall, addStatement } from \"../util/signals\";\nimport { currentProgramPath, scopeIdentifier } from \"../visitors/program\";\n\ndeclare module \"@marko/compiler/dist/types\" {\n  export interface ProgramExtra {\n    isInteractive?: boolean;\n  }\n}\n\nexport default {\n  analyze() {\n    (currentProgramPath.node.extra ??= {}).isInteractive = true;\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [defaultAttr] = node.attributes;\n\n      assertNoParams(tag);\n      assertNoBodyContent(tag);\n\n      if (!defaultAttr) {\n        throw tag\n          .get(\"name\")\n          .buildCodeFrameError(\n            \"The 'effect' tag requires a default attribute.\",\n          );\n      }\n\n      if (\n        node.attributes.length > 1 ||\n        !t.isMarkoAttribute(defaultAttr) ||\n        (!defaultAttr.default && defaultAttr.name !== \"value\")\n      ) {\n        throw tag\n          .get(\"name\")\n          .buildCodeFrameError(\n            \"The 'effect' tag only supports the 'default' attribute.\",\n          );\n      }\n\n      const section = getSection(tag);\n      const { value } = defaultAttr;\n      const references = value.extra?.references;\n      if (isOutputDOM()) {\n        const { value } = defaultAttr;\n        let inlineBody: t.Statement | t.Statement[] | null = null;\n        if (\n          t.isFunctionExpression(value) ||\n          t.isArrowFunctionExpression(value)\n        ) {\n          if (t.isBlockStatement(value.body)) {\n            let hasDeclaration = false;\n            for (const child of value.body.body) {\n              if (t.isDeclaration(child)) {\n                hasDeclaration = true;\n                break;\n              }\n            }\n\n            inlineBody = hasDeclaration ? value.body : value.body.body;\n          } else {\n            inlineBody = t.expressionStatement(value.body);\n          }\n        }\n        addStatement(\n          \"effect\",\n          section,\n          references,\n          inlineBody ||\n            t.expressionStatement(t.callExpression(value, [scopeIdentifier])),\n          value,\n          !!inlineBody,\n        );\n      } else {\n        addHTMLEffectCall(section, references);\n      }\n\n      tag.remove();\n    },\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\",\n    },\n  ],\n} as Tag;\n","import { type Tag, parseStatements } from \"@marko/babel-utils\";\n\nexport default {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      parseStatements(tag.hub.file, node.rawValue!, node.start!, node.end!)[0],\n    );\n  },\n  parseOptions: {\n    rootOnly: true,\n    rawOpenTag: true,\n    openTagOnly: true,\n    ignoreAttributes: true,\n    relaxRequireCommas: true,\n  },\n  autocomplete: [\n    {\n      displayText: \"export <value>\",\n    },\n  ],\n} as Tag;\n","import {\n  type Tag,\n  assertAllowedAttributes,\n  assertNoVar,\n  getTagDef,\n} from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { AccessorChar, WalkCode } from \"@marko/runtime-tags/common/types\";\nimport { isOutputHTML } from \"../util/marko-config\";\nimport analyzeAttributeTags from \"../util/nested-attribute-tags\";\nimport { mergeReferences } from \"../util/references\";\nimport {\n  ReserveType,\n  getScopeAccessorLiteral,\n  reserveScope,\n} from \"../util/reserve\";\nimport { callRuntime } from \"../util/runtime\";\nimport {\n  getOrCreateSection,\n  getScopeIdIdentifier,\n  getScopeIdentifier,\n  getSection,\n} from \"../util/sections\";\nimport {\n  addValue,\n  getClosures,\n  getSerializedScopeProperties,\n  getSignal,\n  setForceResumeScope,\n  setRegisterScopeBuilder,\n  setSubscriberBuilder,\n  writeHTMLResumeStatements,\n} from \"../util/signals\";\nimport * as walks from \"../util/walks\";\nimport * as writer from \"../util/writer\";\nimport { currentProgramPath } from \"../visitors/program\";\nimport customTag from \"../visitors/tag/custom-tag\";\n\nexport default {\n  analyze: {\n    enter(tag) {\n      tag.node.extra ??= {};\n      const isOnlyChild = checkOnlyChild(tag);\n      const parentTag = (\n        isOnlyChild ? tag.parentPath.parent : undefined\n      ) as t.MarkoTag;\n      const parentTagName = (parentTag?.name as t.StringLiteral)?.value;\n      reserveScope(\n        ReserveType.Visit,\n        getOrCreateSection(tag),\n        isOnlyChild ? parentTag : tag.node,\n        tag.scope.generateUid(\"for\"),\n        isOnlyChild ? `#${parentTagName}` : \"#text\",\n      );\n      customTag.analyze.enter(tag);\n    },\n    exit(tag) {\n      const extra = tag.node.extra!;\n      analyzeAttributeTags(tag);\n\n      mergeReferences(\n        tag,\n        tag.node.attributes.map((attr) => attr.value),\n      );\n\n      extra.isStateful =\n        !!extra.references &&\n        !(\n          extra.nestedAttributeTags &&\n          Object.keys(extra.nestedAttributeTags).length\n        );\n      extra.singleNodeOptimization = tag.node.body.body.length === 1;\n    },\n  },\n  translate: {\n    enter(tag) {\n      validateFor(tag);\n\n      const tagBody = tag.get(\"body\");\n      const bodySection = getSection(tagBody);\n      const { isStateful, singleNodeOptimization, isOnlyChild } =\n        tag.node.extra!;\n      if (!isOnlyChild) {\n        walks.visit(tag, WalkCode.Replace);\n        walks.enterShallow(tag);\n      }\n      if (isOutputHTML()) {\n        writer.flushBefore(tag);\n        if (isStateful && !singleNodeOptimization) {\n          writer.writeTo(tagBody)`${callRuntime(\n            \"markResumeScopeStart\",\n            getScopeIdIdentifier(bodySection),\n          )}`;\n        }\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML.exit(tag);\n      } else {\n        translateDOM.exit(tag);\n      }\n    },\n  },\n  attributes: {\n    of: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over a list of items.\",\n        },\n      ],\n    },\n    in: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over the keys and values of an object.\",\n        },\n      ],\n    },\n    to: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates up to the provided number (inclusive)\",\n        },\n      ],\n    },\n    from: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates starting from the provided number (inclusive)\",\n        },\n      ],\n    },\n    step: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description:\n            \"The amount to increment during each interation (with from/to)\",\n        },\n      ],\n    },\n  },\n  autocomplete: [\n    {\n      snippet: \"for|${1:value, index}| of=${3:array}\",\n      description:\n        \"Use to iterate over lists, object properties, or between ranges.\",\n      descriptionMoreURL:\n        \"https://markojs.com/docs/core-tags/#iterating-over-a-list\",\n    },\n    {\n      snippet: \"for|${1:name, value}| in=${3:object}\",\n      descriptionMoreURL:\n        \"https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties\",\n    },\n    {\n      snippet:\n        \"for|${1:index}| from=${2:number} to=${3:number} step=${4:number}\",\n      descriptionMoreURL:\n        \"https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers\",\n    },\n  ],\n} as Tag;\n\nconst translateDOM = {\n  exit(tag: t.NodePath<t.MarkoTag>) {\n    const tagBody = tag.get(\"body\");\n    const tagSection = getSection(tag);\n    const bodySection = getSection(tagBody);\n    const { node } = tag;\n    const { attributes } = node;\n    const { isOnlyChild, references } = node.extra!;\n    const { reserve } = (\n      isOnlyChild ? (tag.parentPath.parent as t.MarkoTag) : tag.node\n    ).extra!;\n    const paramIdentifiers = Object.values(\n      tagBody.getBindingIdentifiers(),\n    ) as t.Identifier[];\n\n    setSubscriberBuilder(tag, (signal: t.Expression) => {\n      return callRuntime(\n        \"inLoopScope\",\n        signal,\n        getScopeAccessorLiteral(reserve!),\n      );\n    });\n\n    tag.remove();\n\n    const rendererId = writer.getRenderer(bodySection);\n\n    const ofAttr = findName(attributes, \"of\");\n    const toAttr = findName(attributes, \"to\");\n    const inAttr = findName(attributes, \"in\");\n\n    const loopArgs: t.Expression[] = [];\n    let loopKind: \"loopOf\" | \"loopIn\" | \"loopTo\";\n    if (ofAttr) {\n      loopKind = \"loopOf\";\n      loopArgs.push(ofAttr.value);\n    } else if (inAttr) {\n      loopKind = \"loopIn\";\n      loopArgs.push(inAttr.value);\n    } else if (toAttr) {\n      const fromAttr = findName(attributes, \"from\");\n      const stepAttr = findName(attributes, \"step\");\n      loopKind = \"loopTo\";\n      loopArgs.push(\n        toAttr.value,\n        fromAttr ? fromAttr.value : t.numericLiteral(0),\n        stepAttr ? stepAttr.value : t.numericLiteral(1),\n      );\n    } else {\n      throw tag\n        .get(\"name\")\n        .buildCodeFrameError(\n          \"Invalid <for> tag. Expected either an 'of', 'to', or 'in' attribute.\",\n        );\n    }\n\n    const byAttr = findName(attributes, \"by\");\n    if (byAttr) {\n      loopArgs.push(byAttr.value);\n    }\n\n    const signal = getSignal(tagSection, reserve);\n    signal.build = () => {\n      return callRuntime(\n        loopKind,\n        getScopeAccessorLiteral(reserve!),\n        rendererId,\n      );\n    };\n\n    signal.hasDownstreamIntersections = () => {\n      for (const identifier of paramIdentifiers) {\n        if (\n          getSignal(\n            bodySection,\n            identifier.extra!.reserve,\n          ).hasDownstreamIntersections()\n        ) {\n          return true;\n        }\n      }\n\n      return getClosures(bodySection).length > 0;\n    };\n\n    addValue(tagSection, references, signal, t.arrayExpression(loopArgs));\n  },\n};\n\nconst translateHTML = {\n  exit(tag: t.NodePath<t.MarkoTag>) {\n    const tagBody = tag.get(\"body\");\n    const tagSection = getSection(tag);\n    const bodySection = getSection(tagBody);\n    const { node } = tag;\n    const {\n      attributes,\n      body: { body, params },\n    } = node;\n    const extra = node.extra!;\n    const { isStateful, singleNodeOptimization, isOnlyChild } = extra;\n    const { reserve } = (\n      isOnlyChild ? (tag.parentPath.parent as t.MarkoTag) : node\n    ).extra!;\n    const namePath = tag.get(\"name\");\n    const ofAttr = findName(attributes, \"of\");\n    const inAttr = findName(attributes, \"in\");\n    const toAttr = findName(attributes, \"to\");\n    const byAttr = findName(attributes, \"by\");\n    const block = t.blockStatement(body);\n    const write = writer.writeTo(tag);\n    const replacement: t.Node[] = [];\n    let byParams: t.Expression[];\n    let keyExpression: t.Expression | undefined = t.identifier(\"NOO\");\n\n    if (isStateful || bodySection.closures) {\n      setRegisterScopeBuilder(tag, (scope: t.Expression) => {\n        const tempScopeIdentifier =\n          currentProgramPath.scope.generateUidIdentifier(\"s\");\n        return t.callExpression(\n          t.arrowFunctionExpression(\n            [tempScopeIdentifier],\n            t.sequenceExpression([\n              t.callExpression(\n                t.memberExpression(\n                  getScopeIdentifier(bodySection),\n                  t.identifier(\"set\"),\n                ),\n                [keyExpression!, tempScopeIdentifier],\n              ),\n              tempScopeIdentifier,\n            ]),\n          ),\n          [scope],\n        );\n      });\n      setForceResumeScope(bodySection);\n    }\n\n    if (byAttr && isStateful) {\n      const byIdentifier = currentProgramPath.scope.generateUidIdentifier(\"by\");\n      replacement.push(\n        t.variableDeclaration(\"const\", [\n          t.variableDeclarator(byIdentifier, byAttr.value!),\n        ]),\n      );\n      byParams = [];\n      keyExpression = t.callExpression(byIdentifier, byParams);\n    }\n\n    if (inAttr) {\n      const [keyParam, valParam] = params;\n\n      keyExpression = keyParam as t.Identifier;\n\n      if (valParam) {\n        // TODO: account for keyParam being a non identifier.\n        block.body.unshift(\n          t.variableDeclaration(\"const\", [\n            t.variableDeclarator(\n              valParam,\n              t.memberExpression(inAttr.value!, keyParam as t.Identifier, true),\n            ),\n          ]),\n        );\n      }\n\n      replacement.push(\n        t.forInStatement(\n          t.variableDeclaration(\"const\", [t.variableDeclarator(keyParam)]),\n          inAttr.value!,\n          block,\n        ),\n      );\n    } else if (ofAttr) {\n      let ofAttrValue = ofAttr.value!;\n      // eslint-disable-next-line prefer-const\n      let [valParam, indexParam, loopParam] = params;\n\n      if (!valParam) {\n        throw namePath.buildCodeFrameError(\n          \"Invalid 'for of' tag, missing |value, index| params.\",\n        );\n      }\n\n      if (!t.isIdentifier(valParam) && byParams!) {\n        const tempValParam =\n          currentProgramPath.scope.generateUidIdentifier(\"v\");\n        block.body.unshift(\n          t.variableDeclaration(\"const\", [\n            t.variableDeclarator(valParam, tempValParam),\n          ]),\n        );\n        valParam = tempValParam;\n      }\n\n      if (indexParam || isStateful || bodySection.closures) {\n        indexParam ??= currentProgramPath.scope.generateUidIdentifier(\"i\");\n        const indexName = tag.scope.generateUidIdentifierBasedOnNode(\n          indexParam,\n          \"i\",\n        );\n        replacement.push(\n          t.variableDeclaration(\"let\", [\n            t.variableDeclarator(indexName, t.numericLiteral(0)),\n          ]),\n        );\n\n        block.body.unshift(\n          t.variableDeclaration(\"let\", [\n            t.variableDeclarator(\n              indexParam,\n              t.updateExpression(\"++\", indexName),\n            ),\n          ]),\n        );\n      }\n\n      if (loopParam) {\n        if (t.isIdentifier(loopParam)) {\n          ofAttrValue = loopParam;\n        }\n\n        replacement.push(\n          t.variableDeclaration(\"const\", [\n            t.variableDeclarator(loopParam, ofAttr.value),\n          ]),\n        );\n      }\n\n      if (byParams!) {\n        byParams.push(valParam as t.Identifier, indexParam as t.Identifier);\n      } else {\n        keyExpression = indexParam as t.Identifier;\n      }\n\n      replacement.push(\n        t.forOfStatement(\n          t.variableDeclaration(\"const\", [t.variableDeclarator(valParam)]),\n          ofAttrValue,\n          block,\n        ),\n      );\n    } else if (toAttr) {\n      const stepValue =\n        findName(attributes, \"step\")?.value ?? t.numericLiteral(1);\n      const fromValue =\n        findName(attributes, \"from\")?.value ?? t.numericLiteral(0);\n      let [indexParam] = params;\n      const stepsName = tag.scope.generateUidIdentifier(\"steps\");\n      const indexName = tag.scope.generateUidIdentifier(\"i\");\n      const stepName = tag.scope.generateUidIdentifier(\"step\");\n      const fromName = tag.scope.generateUidIdentifier(\"from\");\n\n      if (indexParam || isStateful || bodySection.closures) {\n        indexParam ??= currentProgramPath.scope.generateUidIdentifier(\"i\");\n        keyExpression = indexParam as t.Identifier;\n        block.body.unshift(\n          t.variableDeclaration(\"const\", [\n            t.variableDeclarator(\n              indexParam,\n              t.binaryExpression(\n                \"+\",\n                fromName,\n                t.binaryExpression(\"*\", indexName, stepName),\n              ),\n            ),\n          ]),\n        );\n      }\n\n      replacement.push(\n        t.forStatement(\n          t.variableDeclaration(\"let\", [\n            t.variableDeclarator(\n              fromName,\n              t.logicalExpression(\"??\", fromValue, t.numericLiteral(0)),\n            ),\n            t.variableDeclarator(\n              stepName,\n              t.logicalExpression(\"??\", stepValue, t.numericLiteral(1)),\n            ),\n            t.variableDeclarator(\n              stepsName,\n              t.binaryExpression(\n                \"/\",\n                t.binaryExpression(\"-\", toAttr.value, fromName),\n                stepName,\n              ),\n            ),\n            t.variableDeclarator(indexName, t.numericLiteral(0)),\n          ]),\n          t.binaryExpression(\"<=\", indexName, stepsName),\n          t.updateExpression(\"++\", indexName),\n          block,\n        ),\n      );\n    }\n\n    if (isStateful || bodySection.closures) {\n      const forScopeIdsIdentifier =\n        tag.scope.generateUidIdentifier(\"forScopeIds\");\n      const forScopesIdentifier = getScopeIdentifier(bodySection);\n\n      replacement.unshift(\n        t.variableDeclaration(\n          \"const\",\n          [\n            singleNodeOptimization &&\n              t.variableDeclarator(\n                forScopeIdsIdentifier,\n                t.arrayExpression([]),\n              ),\n            t.variableDeclarator(\n              forScopesIdentifier,\n              t.newExpression(t.identifier(\"Map\"), []),\n            ),\n          ].filter(Boolean) as t.VariableDeclarator[],\n        ),\n      );\n\n      if (singleNodeOptimization) {\n        block.body.push(\n          t.expressionStatement(\n            t.callExpression(\n              t.memberExpression(forScopeIdsIdentifier, t.identifier(\"push\")),\n              [getScopeIdIdentifier(bodySection)],\n            ),\n          ),\n        );\n        write`${callRuntime(\n          \"markResumeControlSingleNodeEnd\",\n          getScopeIdIdentifier(tagSection),\n          getScopeAccessorLiteral(reserve!),\n          forScopeIdsIdentifier,\n        )}`;\n      } else {\n        write`${callRuntime(\n          \"markResumeControlEnd\",\n          getScopeIdIdentifier(tagSection),\n          getScopeAccessorLiteral(reserve!),\n        )}`;\n      }\n      getSerializedScopeProperties(tagSection).set(\n        t.stringLiteral(\n          getScopeAccessorLiteral(reserve!).value + AccessorChar.LoopScopeMap,\n        ),\n        t.conditionalExpression(\n          t.memberExpression(forScopesIdentifier, t.identifier(\"size\")),\n          forScopesIdentifier,\n          t.identifier(\"undefined\"),\n        ),\n      );\n    }\n\n    writer.flushInto(tag);\n    // TODO: this is a hack to get around the fact that we don't have a way to\n    // know if a scope requires dynamic subscriptions\n    setSubscriberBuilder(tag, (() => {}) as any);\n    writeHTMLResumeStatements(tagBody);\n\n    block.body.push(t.expressionStatement(callRuntime(\"maybeFlush\")));\n\n    tag.replaceWithMultiple(replacement);\n  },\n};\n\nfunction findName(\n  arr: (t.MarkoAttribute | t.MarkoSpreadAttribute)[],\n  value: string,\n) {\n  return arr.find((obj) => t.isMarkoAttribute(obj) && obj.name === value);\n}\n\nfunction validateFor(tag: t.NodePath<t.MarkoTag>) {\n  const attrs = tag.node.attributes;\n  const hasParams = tag.node.body.params.length > 0;\n\n  assertNoVar(tag);\n\n  if (findName(attrs, \"of\")) {\n    assertAllowedAttributes(tag, [\"of\", \"by\"]);\n    if (!hasParams) {\n      throw tag.buildCodeFrameError(\n        `Invalid 'for of' tag, missing |value, index| params.`,\n      );\n    }\n  } else if (findName(attrs, \"in\")) {\n    assertAllowedAttributes(tag, [\"in\", \"by\"]);\n    if (!hasParams) {\n      throw tag.buildCodeFrameError(\n        `Invalid 'for in' tag, missing |key, value| params.`,\n      );\n    }\n  } else if (findName(attrs, \"to\")) {\n    assertAllowedAttributes(tag, [\"from\", \"to\", \"step\", \"by\"]);\n  } else {\n    throw tag.buildCodeFrameError(\n      \"Invalid 'for' tag, missing an 'of', 'in' or 'to' attribute.\",\n    );\n  }\n}\n\nfunction checkOnlyChild(tag: t.NodePath<t.MarkoTag>) {\n  const extra = tag.node.extra!;\n  if (\n    t.isMarkoTag(tag.parentPath?.parent) &&\n    getTagDef(tag.parentPath!.parentPath! as t.NodePath<t.MarkoTag>)?.html\n  ) {\n    return (extra.isOnlyChild =\n      (tag.parent as t.MarkoTagBody).body.length === 1);\n  }\n  return (extra.isOnlyChild = false);\n}\n","import {\n  type Tag,\n  assertNoAttributeTags,\n  assertNoAttributes,\n  assertNoParams,\n  assertNoVar,\n} from \"@marko/babel-utils\";\nimport * as walks from \"../util/walks\";\nimport * as writer from \"../util/writer\";\n\nexport default {\n  analyze() {\n    // skip default custom tag analysis\n  },\n  translate: {\n    enter(tag) {\n      walks.enter(tag);\n      writer.writeTo(tag)`<!--`;\n      // TODO: for the DOM side this needs to normalize placeholders and text content into a string.\n      // This should also error if other tags are discovered, including control flow probably.\n    },\n    exit(tag) {\n      assertNoVar(tag);\n      assertNoParams(tag);\n      assertNoAttributes(tag);\n      assertNoAttributeTags(tag);\n      walks.exit(tag);\n      writer.writeTo(tag)`-->`;\n      tag.remove();\n    },\n  },\n  parseOptions: {\n    // TODO: fix the types for Tag or parseOptions or something\n    text: true,\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description:\n        \"Use to create an html comment that is not stripped from the output.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#html-comment\",\n    },\n  ],\n} as Tag;\n","import {\n  type Tag,\n  assertNoArgs,\n  assertNoAttributes,\n  assertNoParams,\n} from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { assertNoBodyContent } from \"../util/assert\";\nimport { isOutputHTML } from \"../util/marko-config\";\nimport { callRuntime } from \"../util/runtime\";\nimport { getSection } from \"../util/sections\";\nimport { addValue, initValue } from \"../util/signals\";\n\nexport default {\n  translate(tag) {\n    const { node } = tag;\n    const { var: tagVar } = node;\n    const id = callRuntime(\"nextTagId\");\n\n    assertNoArgs(tag);\n    assertNoAttributes(tag);\n    assertNoBodyContent(tag);\n    assertNoParams(tag);\n\n    if (!node.var) {\n      throw tag\n        .get(\"name\")\n        .buildCodeFrameError(\"The 'id' tag requires a tag variable.\");\n    }\n\n    if (!t.isIdentifier(tagVar)) {\n      throw tag\n        .get(\"var\")\n        .buildCodeFrameError(\"The 'id' tag cannot be destructured\");\n    }\n\n    if (isOutputHTML()) {\n      tag.replaceWith(\n        t.variableDeclaration(\"const\", [t.variableDeclarator(node.var, id)]),\n      );\n    } else {\n      const source = initValue(tagVar.extra!.reserve!);\n      addValue(getSection(tag), undefined, source, id);\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"id/<name>\",\n      description: \"Use to create a unique identifier.\",\n      snippet: \"id/${1:name}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#id\",\n    },\n  ],\n} as Tag;\n","import { type Tag, parseStatements } from \"@marko/babel-utils\";\n\nexport default {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      parseStatements(tag.hub.file, node.rawValue!, node.start!, node.end!)[0],\n    );\n  },\n  parseOptions: {\n    rootOnly: true,\n    rawOpenTag: true,\n    openTagOnly: true,\n    ignoreAttributes: true,\n    relaxRequireCommas: true,\n  },\n  autocomplete: [\n    {\n      displayText: 'import <scope> from \"<path>\"',\n      description:\n        \"Use to import external modules, follows the same syntax as JavaScript imports.\",\n      snippet: 'import ${2} from \"${1:path}\"',\n      descriptionMoreURL:\n        \"https://markojs.com/docs/syntax/#importing-external-files\",\n    },\n  ],\n} as Tag;\n","import { type Tag, assertNoParams } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { assertNoBodyContent } from \"../util/assert\";\nimport { isOutputDOM } from \"../util/marko-config\";\nimport { registerAssignmentGenerator } from \"../util/replace-assignments\";\nimport { getScopeAccessorLiteral } from \"../util/reserve\";\nimport { callRuntime } from \"../util/runtime\";\nimport { getSection } from \"../util/sections\";\nimport { addValue, initValue, queueSource } from \"../util/signals\";\nimport translateVar from \"../util/translate-var\";\nimport { currentProgramPath } from \"../visitors/program\";\n\nexport default {\n  translate(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    const defaultAttr =\n      node.attributes.find(\n        (attr) =>\n          t.isMarkoAttribute(attr) && (attr.default || attr.name === \"value\"),\n      ) ?? t.markoAttribute(\"value\", t.identifier(\"undefined\"));\n\n    assertNoParams(tag);\n    assertNoBodyContent(tag);\n\n    if (!tagVar) {\n      throw tag\n        .get(\"name\")\n        .buildCodeFrameError(\"The 'let' tag requires a tag variable.\");\n    }\n\n    if (!t.isIdentifier(tagVar)) {\n      throw tag\n        .get(\"var\")\n        .buildCodeFrameError(\"The 'let' cannot be destructured.\");\n    }\n\n    if (isOutputDOM()) {\n      const section = getSection(tag);\n      const binding = tagVar.extra!.reserve!;\n      const source = initValue(binding);\n      const references = defaultAttr.value.extra?.references;\n      const isSetup = !references;\n\n      if (!isSetup) {\n        let initValueId: t.Identifier | undefined;\n        addValue(\n          section,\n          references,\n          {\n            get identifier() {\n              if (!initValueId) {\n                initValueId = tag.scope.generateUidIdentifier(\n                  source.identifier.name + \"_init\",\n                );\n                currentProgramPath.pushContainer(\n                  \"body\",\n                  t.variableDeclaration(\"const\", [\n                    t.variableDeclarator(\n                      initValueId,\n                      callRuntime(\n                        \"initValue\",\n                        getScopeAccessorLiteral(binding),\n                        source.identifier,\n                      ),\n                    ),\n                  ]),\n                );\n              }\n\n              return initValueId;\n            },\n            hasDownstreamIntersections() {\n              return source.hasDownstreamIntersections();\n            },\n          },\n          defaultAttr.value,\n        );\n      } else {\n        addValue(section, references, source, defaultAttr.value);\n      }\n\n      registerAssignmentGenerator(\n        tag.scope.getBinding(binding.name)!,\n        (assignment, value) =>\n          queueSource(source, value, getSection(assignment)),\n      );\n    } else {\n      translateVar(tag, defaultAttr.value);\n    }\n\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a mutable binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#let\",\n    },\n  ],\n} as Tag;\n","import type { types as t } from \"@marko/compiler\";\n\nconst assignmentGeneratorMaps = new WeakMap<\n  t.Node,\n  Record<string, (assignment: t.NodePath, value: t.Expression) => t.Expression>\n>();\n\nexport function getAssignmentGenerator(\n  assignment: t.NodePath,\n  identifier: string,\n) {\n  return assignmentGeneratorMaps.get(assignment.node)?.[identifier];\n}\n\nexport function registerAssignmentGenerator(\n  binding: t.Binding,\n  map: (assignment: t.NodePath, value: t.Expression) => t.Expression,\n): void {\n  for (const assignment of binding.constantViolations) {\n    let generatorMap = assignmentGeneratorMaps.get(assignment.node);\n    if (!generatorMap) {\n      generatorMap = {};\n      assignmentGeneratorMaps.set(assignment.node, generatorMap);\n    }\n    generatorMap[binding.identifier.name] = map;\n  }\n}\n","import { type Tag, assertNoParams } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { assertNoBodyContent } from \"../util/assert\";\nimport attrsToObject from \"../util/attrs-to-object\";\nimport { isOutputDOM } from \"../util/marko-config\";\nimport { mergeReferences } from \"../util/references\";\nimport {\n  ReserveType,\n  getScopeAccessorLiteral,\n  reserveScope,\n} from \"../util/reserve\";\nimport { callRuntime } from \"../util/runtime\";\nimport { getOrCreateSection, getSection } from \"../util/sections\";\nimport { addHTMLEffectCall, addStatement } from \"../util/signals\";\nimport { currentProgramPath, scopeIdentifier } from \"../visitors/program\";\nimport customTag from \"../visitors/tag/custom-tag\";\n\ndeclare module \"@marko/compiler/dist/types\" {\n  export interface ProgramExtra {\n    isInteractive?: boolean;\n  }\n}\n\nexport default {\n  analyze: {\n    enter(tag) {\n      customTag.analyze.enter(tag);\n      reserveScope(\n        ReserveType.Store,\n        getOrCreateSection(tag),\n        tag.node,\n        tag.scope.generateUid(\"lifecycle\"),\n      );\n      (currentProgramPath.node.extra ??= {}).isInteractive = true;\n    },\n    exit(tag) {\n      customTag.analyze.exit(tag);\n      mergeReferences(\n        tag,\n        tag.node.attributes.map((attr) => attr.value),\n      );\n    },\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n\n      assertNoParams(tag);\n      assertNoBodyContent(tag);\n\n      // TODO: Check attributes?\n      // if (\n      //   node.attributes.length > 1 ||\n      //   !t.isMarkoAttribute(defaultAttr) ||\n      //   (!defaultAttr.default && defaultAttr.name !== \"default\")\n      // ) {\n      //   throw tag\n      //     .get(\"name\")\n      //     .buildCodeFrameError(\n      //       \"The 'lifecycle' tag only supports the 'default' attribute.\"\n      //     );\n      // }\n\n      const section = getSection(tag);\n      const { references } = node.extra!;\n\n      if (isOutputDOM()) {\n        const attrsObject = attrsToObject(tag);\n        addStatement(\n          \"effect\",\n          section,\n          references,\n          t.expressionStatement(\n            callRuntime(\n              \"lifecycle\",\n              scopeIdentifier,\n              getScopeAccessorLiteral(tag.node.extra!.reserve!),\n              attrsObject,\n            ),\n          ),\n          node.attributes.map((a) => a.value),\n        );\n      } else {\n        addHTMLEffectCall(section, references);\n      }\n\n      tag.remove();\n    },\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\",\n    },\n  ],\n} as Tag;\n","import type { Tag } from \"@marko/babel-utils\";\n\nexport default {\n  migrate: [(tag) => tag.remove()],\n} as Tag;\n","import { parseStatements } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nexport default {\n  parse(tag: t.NodePath<t.MarkoTag>) {\n    const {\n      node,\n      hub: { file },\n    } = tag;\n    const rawValue = node.rawValue!;\n    const code = rawValue.replace(/^static\\s*/, \"\").trim();\n    const start = node.name.start! + (rawValue.length - code.length);\n    let body = parseStatements(file, code, start, start + code.length);\n    if (body.length === 1 && t.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n\n    tag.replaceWith(t.markoScriptlet(body, true));\n  },\n  \"parse-options\": {\n    rootOnly: true,\n    rawOpenTag: true,\n    openTagOnly: true,\n    ignoreAttributes: true,\n  },\n  autocomplete: [\n    {\n      displayText: \"static <statement>\",\n      description:\n        \"A JavaScript statement which is only evaluated once your template is loaded.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#static-javascript\",\n    },\n  ],\n};\n","import path from \"path\";\nimport { type Tag, assertNoParams, importDefault } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { assertNoSpreadAttrs } from \"../util/assert\";\nimport { getMarkoOpts } from \"../util/marko-config\";\nimport { currentProgramPath } from \"../visitors/program\";\n\nexport default {\n  translate(tag) {\n    const {\n      hub: { file },\n    } = tag;\n\n    assertNoParams(tag);\n    assertNoSpreadAttrs(tag);\n\n    let type = \"text/css\";\n    const attrs = tag.get(\"attributes\");\n\n    const base = path.basename(file.opts.sourceFileName as string);\n\n    const typeAttr = attrs.find(\n      (attr) => attr.isMarkoAttribute() && attr.node.name === \"type\",\n    );\n    const classAttr = attrs.find(\n      (attr) => attr.isMarkoAttribute() && attr.node.name === \"class\",\n    );\n\n    if (typeAttr && classAttr) {\n      throw classAttr.buildCodeFrameError(\n        `<style> must only use \"type\" or \"class\" and not both.`,\n      );\n    } else if (typeAttr) {\n      const typeValue = typeAttr.get(\"value\");\n      if (typeValue.isStringLiteral()) {\n        type = typeValue.node.value;\n      } else {\n        throw typeValue.buildCodeFrameError(\n          `<style> \"type\" attribute can only be a string literal.`,\n        );\n      }\n    } else if (classAttr) {\n      const classValue = classAttr.get(\"value\");\n      if (classValue.isStringLiteral()) {\n        type = classValue.node.value;\n      } else {\n        throw classValue.buildCodeFrameError(\n          `<style> \"class\" attribute can only be a string literal.`,\n        );\n      }\n    }\n\n    if (type === \"text/css\") {\n      type = \"css\";\n    }\n\n    if (tag.node.var && !type.startsWith(\"module\")) {\n      type = \"module.\" + type;\n    }\n\n    const body = tag.get(\"body\").get(\"body\");\n    const markoText = body[0]!;\n\n    if (body.length !== 1 || !markoText.isMarkoText()) {\n      throw (markoText.isMarkoText() ? body[1] : body[0]).buildCodeFrameError(\n        \"The '<style>' tag currently only supports static content.\",\n      );\n    }\n\n    const { resolveVirtualDependency } = getMarkoOpts();\n\n    if (resolveVirtualDependency) {\n      const importPath = resolveVirtualDependency(\n        file.opts.filename as string,\n        {\n          type,\n          code: markoText.node.value,\n          startPos: markoText.node.start!,\n          endPos: markoText.node.end!,\n          path: `./${base}`,\n          virtualPath: `./${base}.${type}`,\n        } as any,\n      );\n\n      if (!tag.node.var) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          t.importDeclaration([], t.stringLiteral(importPath)),\n        );\n      } else if (t.isIdentifier(tag.node.var)) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          t.importDeclaration(\n            [t.importDefaultSpecifier(tag.node.var)],\n            t.stringLiteral(importPath),\n          ),\n        );\n      } else {\n        currentProgramPath.pushContainer(\n          \"body\",\n          t.variableDeclaration(\"const\", [\n            t.variableDeclarator(\n              tag.node.var,\n              importDefault(file, importPath, \"style\"),\n            ),\n          ]),\n        );\n      }\n    }\n\n    tag.remove();\n  },\n  attributes: {\n    type: { enum: [\"css\", \"less\", \"scss\", \"text/css\"] },\n  },\n} as Tag;\n","import { taglibId } from \"../util/is-core-tag\";\nimport FlushHereAndAfter from \"./__flush_here_and_after__\";\nimport AttrsTag from \"./attrs\";\nimport ElseTag from \"./condition/else\";\nimport ElseIfTag from \"./condition/else-if\";\nimport IfTag from \"./condition/if\";\nimport ConstTag from \"./const\";\nimport DefineTag from \"./define\";\nimport EffectTag from \"./effect\";\nimport ExportTag from \"./export\";\nimport ForTag from \"./for\";\nimport HTMLCommentTag from \"./html-comment\";\nimport IdTag from \"./id\";\nimport ImportTag from \"./import\";\nimport LetTag from \"./let\";\nimport LifecycleTag from \"./lifecycle\";\nimport NoopTag from \"./noop\";\nimport ReturnTag from \"./return\";\nimport StaticTag from \"./static\";\nimport StyleTag from \"./style\";\n\nexport default {\n  taglibId,\n  \"<import>\": ImportTag,\n  \"<export>\": ExportTag,\n  \"<attrs>\": AttrsTag,\n  \"<if>\": IfTag,\n  \"<else-if>\": ElseIfTag,\n  \"<else>\": ElseTag,\n  \"<for>\": ForTag,\n  \"<let>\": LetTag,\n  \"<const>\": ConstTag,\n  \"<define>\": DefineTag,\n  \"<effect>\": EffectTag,\n  \"<lifecycle>\": LifecycleTag,\n  \"<id>\": IdTag,\n  \"<html-comment>\": HTMLCommentTag,\n  \"<return>\": ReturnTag,\n  \"<style>\": StyleTag,\n  \"<await-reorderer>\": NoopTag,\n  \"<init-widgets>\": NoopTag,\n  \"<init-components>\": NoopTag,\n  \"<static>\": StaticTag,\n  \"<__flush_here_and_after__>\": FlushHereAndAfter,\n};\n","import { types as t } from \"@marko/compiler\";\nimport { isOutputDOM } from \"../util/marko-config\";\nimport { getAssignmentGenerator } from \"../util/replace-assignments\";\n\nexport default {\n  translate: {\n    exit(assignment: t.NodePath<t.AssignmentExpression>) {\n      if (isOutputDOM()) {\n        if (\n          assignment.node.left.type === \"ObjectPattern\" ||\n          assignment.node.left.type === \"ArrayPattern\"\n        ) {\n          handleDestructure(assignment, assignment.node.left);\n        } else {\n          const generator = getAssignmentGenerator(\n            assignment,\n            (assignment.node.left as t.Identifier).name,\n          );\n\n          if (generator) {\n            assignment.replaceWith(\n              generator(\n                assignment,\n                assignment.node.operator === \"=\"\n                  ? assignment.node.right\n                  : t.binaryExpression(\n                      assignment.node.operator.slice(\n                        0,\n                        -1,\n                      ) as t.BinaryExpression[\"operator\"],\n                      assignment.node.left as t.Identifier,\n                      assignment.node.right,\n                    ),\n              ),\n            );\n          }\n        }\n      }\n    },\n  },\n};\n\nfunction handleDestructure(\n  assignment: t.NodePath,\n  node: t.LVal | t.ObjectProperty | t.ObjectProperty[\"value\"],\n  ctx?: {\n    statement: t.NodePath;\n    end: t.NodePath;\n  },\n  replace?: (value: t.Identifier) => void,\n) {\n  if (!ctx) {\n    ctx = {\n      statement: assignment.getStatementParent()!,\n      end: assignment.getStatementParent()!,\n    };\n  }\n\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        handleDestructure(assignment, prop, ctx);\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const i in node.elements) {\n        if (node.elements[i] === null) continue;\n\n        handleDestructure(\n          assignment,\n          node.elements[i]!,\n          ctx,\n          (id) => (node.elements[i] = id),\n        );\n      }\n      break;\n    case \"RestElement\":\n      handleDestructure(\n        assignment,\n        node.argument,\n        ctx,\n        (id) => (node.argument = id),\n      );\n      break;\n    case \"ObjectProperty\":\n      handleDestructure(assignment, node.value, ctx, (id) => (node.value = id));\n      break;\n    case \"Identifier\":\n      {\n        const generator = getAssignmentGenerator(assignment, node.name);\n        if (generator) {\n          const valueId = ctx.statement.scope.generateUidIdentifier(node.name);\n\n          ctx.statement.insertBefore(\n            t.variableDeclaration(\"let\", [t.variableDeclarator(valueId)]),\n          );\n          replace?.(valueId);\n          [ctx.end] = ctx.end.insertAfter(\n            t.expressionStatement(generator(ctx.statement, valueId)),\n          );\n        }\n      }\n      break;\n  }\n}\n","import type { types as t } from \"@marko/compiler\";\nimport { isOutputHTML } from \"../util/marko-config\";\nimport * as writer from \"../util/writer\";\n\nexport default {\n  translate: {\n    exit(cdata: t.NodePath<t.MarkoCDATA>) {\n      if (isOutputHTML()) {\n        writer.writeTo(cdata)`<![CDATA[${cdata.node.value}]]>`;\n      }\n      cdata.remove();\n    },\n  },\n};\n","import type { types as t } from \"@marko/compiler\";\nimport { isOutputHTML } from \"../util/marko-config\";\nimport * as writer from \"../util/writer\";\nconst ieConditionalCommentRegExp = /^\\[if |<!\\[endif\\]$/;\n\nexport default {\n  translate: {\n    exit(comment: t.NodePath<t.MarkoComment>) {\n      if (isOutputHTML()) {\n        const { value } = comment.node;\n\n        if (ieConditionalCommentRegExp.test(value)) {\n          writer.writeTo(comment)`<!--${value}-->`;\n        }\n      }\n\n      comment.remove();\n    },\n  },\n};\n","import type { types as t } from \"@marko/compiler\";\nimport { isOutputHTML } from \"../util/marko-config\";\nimport * as writer from \"../util/writer\";\n\nexport default {\n  translate: {\n    exit(declaration: t.NodePath<t.MarkoDeclaration>) {\n      if (isOutputHTML()) {\n        writer.writeTo(declaration)`<?${declaration.node.value}?>`;\n      }\n\n      declaration.remove();\n    },\n  },\n};\n","import type { types as t } from \"@marko/compiler\";\nimport { isOutputHTML } from \"../util/marko-config\";\nimport * as writer from \"../util/writer\";\n\nexport default {\n  translate: {\n    exit(documentType: t.NodePath<t.MarkoDocumentType>) {\n      if (isOutputHTML()) {\n        writer.writeTo(documentType)`<!${documentType.node.value}>`;\n      }\n      documentType.remove();\n    },\n  },\n};\n","import { getTemplateId } from \"@marko/babel-utils\";\nimport type { types as t } from \"@marko/compiler\";\nimport { getSection, type Section } from \"../util/sections\";\nimport { currentProgramPath } from \"./program\";\nconst functionIdsBySection = new WeakMap<Section, Map<string, number>>();\n\ndeclare module \"@marko/compiler/dist/types\" {\n  export interface NodeExtra {\n    registerId?: string;\n  }\n}\n\nexport default {\n  analyze: {\n    exit(fn: t.NodePath<t.Function>) {\n      const { node } = fn;\n      const extra = (node.extra ??= {});\n      const {\n        markoOpts: { optimize },\n        opts: { filename },\n      } = currentProgramPath.hub.file;\n\n      const section = getSection(fn);\n      let functionNameCounts = functionIdsBySection.get(section);\n      if (!functionNameCounts) {\n        functionNameCounts = new Map();\n        functionIdsBySection.set(section, functionNameCounts);\n      }\n\n      const name = (extra.name as string | undefined) || \"anonymous\";\n      const index = functionNameCounts.get(name);\n      let id = \"\";\n      if (index === undefined) {\n        functionNameCounts.set(name, 0);\n      } else {\n        id = `_${index}`;\n      }\n\n      extra.registerId = getTemplateId(\n        optimize,\n        `${filename}_${section.id}/${name + id}`,\n      );\n    },\n  },\n};\n","import { resolveTagImport } from \"@marko/babel-utils\";\nimport type { types as t } from \"@marko/compiler\";\n\nexport default {\n  translate: {\n    exit(path: t.NodePath<t.ImportDeclaration>) {\n      const source = path.get(\"source\");\n      const request = source.node.value;\n      source.node.value = resolveTagImport(source, request) || request;\n    },\n  },\n};\n","import { isNativeTag } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { WalkCode } from \"@marko/runtime-tags/common/types\";\nimport evaluate from \"../util/evaluate\";\nimport { isCoreTag } from \"../util/is-core-tag\";\nimport { isOutputHTML } from \"../util/marko-config\";\nimport {\n  ReserveType,\n  getScopeAccessorLiteral,\n  reserveScope,\n} from \"../util/reserve\";\nimport { callRuntime, getHTMLRuntime } from \"../util/runtime\";\nimport { getOrCreateSection, getSection } from \"../util/sections\";\nimport { addStatement } from \"../util/signals\";\nimport * as walks from \"../util/walks\";\nimport * as writer from \"../util/writer\";\nimport { scopeIdentifier } from \"./program\";\n\nconst ESCAPE_TYPES = {\n  script: \"escapeScript\",\n  style: \"escapeStyle\",\n} as Record<string, string>;\n\ntype HTMLMethod = \"escapeScript\" | \"escapeStyle\" | \"escapeXML\" | \"toString\";\ntype DOMMethod = \"html\" | \"data\";\n\nexport default {\n  analyze(placeholder: t.NodePath<t.MarkoPlaceholder>) {\n    const { node } = placeholder;\n    const { confident, computed } = evaluate(placeholder);\n\n    if (!(confident && (node.escape || !computed))) {\n      reserveScope(\n        ReserveType.Visit,\n        getOrCreateSection(placeholder),\n        node,\n        placeholder.scope.generateUid(\"placeholder\"),\n        \"#text\",\n      );\n      needsMarker(placeholder);\n    }\n  },\n  translate: {\n    exit(placeholder: t.NodePath<t.MarkoPlaceholder>) {\n      const isHTML = isOutputHTML();\n      const write = writer.writeTo(placeholder);\n      const { node } = placeholder;\n      const { value } = node;\n      const extra = node.extra!;\n      const { confident, computed, reserve } = extra;\n      const canWriteHTML = isHTML || (confident && (node.escape || !computed));\n      const method = canWriteHTML\n        ? node.escape\n          ? ESCAPE_TYPES[getParentTagName(placeholder)] || \"escapeXML\"\n          : \"toString\"\n        : node.escape\n          ? \"data\"\n          : \"html\";\n\n      if (confident && canWriteHTML) {\n        write`${getHTMLRuntime()[method as HTMLMethod](computed)}`;\n      } else {\n        if (extra.needsMarker) {\n          walks.visit(placeholder, WalkCode.Replace);\n        } else {\n          if (!isHTML) write` `;\n          walks.visit(placeholder, WalkCode.Get);\n        }\n\n        if (isHTML) {\n          write`${callRuntime(method as HTMLMethod | DOMMethod, value)}`;\n          writer.markNode(placeholder);\n        } else {\n          addStatement(\n            \"render\",\n            getSection(placeholder),\n            value.extra?.references,\n            t.expressionStatement(\n              method === \"data\"\n                ? callRuntime(\n                    \"data\",\n                    t.memberExpression(\n                      scopeIdentifier,\n                      getScopeAccessorLiteral(reserve!),\n                      true,\n                    ),\n                    value,\n                  )\n                : callRuntime(\n                    \"html\",\n                    scopeIdentifier,\n                    value,\n                    getScopeAccessorLiteral(reserve!),\n                  ),\n            ),\n          );\n        }\n      }\n\n      walks.enterShallow(placeholder);\n      placeholder.remove();\n    },\n  },\n};\n\nfunction getParentTagName({ parentPath }: t.NodePath<t.MarkoPlaceholder>) {\n  return (\n    (parentPath.isMarkoTag() &&\n      isNativeTag(parentPath) &&\n      (parentPath.node.name as t.StringLiteral).value) ||\n    \"\"\n  );\n}\n\nfunction noOutput(path: t.NodePath<t.Node>) {\n  return (\n    t.isMarkoComment(path) ||\n    (t.isMarkoTag(path) &&\n      isCoreTag(path) &&\n      [\"let\", \"const\", \"effect\", \"lifecycle\", \"attrs\", \"get\", \"id\"].includes(\n        path.node.name.value,\n      ))\n  );\n}\n\nfunction needsMarker(placeholder: t.NodePath<t.MarkoPlaceholder>) {\n  let prev = placeholder.getPrevSibling();\n\n  while (prev.node && noOutput(prev)) {\n    prev = prev.getPrevSibling();\n  }\n  if (\n    (prev.node || t.isProgram(placeholder.parentPath)) &&\n    !(t.isMarkoTag(prev) && isNativeTag(prev as t.NodePath<t.MarkoTag>))\n  ) {\n    return (placeholder.node.extra!.needsMarker = true);\n  }\n\n  let next = placeholder.getNextSibling();\n  while (next.node && noOutput(next)) {\n    next = next.getNextSibling();\n  }\n  if (\n    (next.node || t.isProgram(placeholder.parentPath)) &&\n    !(t.isMarkoTag(next) && isNativeTag(next as t.NodePath<t.MarkoTag>))\n  ) {\n    return (placeholder.node.extra!.needsMarker = true);\n  }\n\n  return (placeholder.node.extra!.needsMarker = false);\n}\n","import { computeNode } from \"@marko/babel-utils\";\nimport type { types as t } from \"@marko/compiler\";\n\ndeclare module \"@marko/compiler/dist/types\" {\n  export interface MarkoAttributeExtra {\n    confident?: boolean;\n    computed?: unknown;\n  }\n\n  export interface MarkoSpreadAttributeExtra {\n    confident?: boolean;\n    computed?: unknown;\n  }\n\n  export interface MarkoPlaceholderExtra {\n    confident?: boolean;\n    computed?: unknown;\n  }\n}\n\nexport default function evaluate(\n  path: t.NodePath<\n    t.MarkoAttribute | t.MarkoSpreadAttribute | t.MarkoPlaceholder\n  >,\n) {\n  let { extra } = path.node;\n\n  if (!extra) {\n    extra = path.node.extra = {};\n  }\n\n  if (extra.confident === undefined) {\n    const computed = computeNode(path.node.value);\n    if (computed) {\n      extra.computed = computed.value;\n      extra.confident = true;\n    } else {\n      extra.computed = undefined;\n      extra.confident = false;\n    }\n  }\n\n  return extra as typeof extra & {\n    confident: boolean;\n    computed: unknown;\n  };\n}\n\nexport function getEvaluated(\n  path: t.NodePath<\n    t.MarkoAttribute | t.MarkoSpreadAttribute | t.MarkoPlaceholder\n  >,\n) {\n  const { extra } = path.node;\n\n  if (!extra || extra.confident === undefined) {\n    throw path.buildCodeFrameError(\"Node was not analyzed.\");\n  }\n\n  return extra as typeof extra & {\n    confident: boolean;\n    computed: unknown;\n  };\n}\n","import { types as t } from \"@marko/compiler\";\nimport { getExprRoot } from \"../util/get-root\";\nimport isStatic from \"../util/is-static\";\nimport { isOutputHTML } from \"../util/marko-config\";\nimport { importRuntime } from \"../util/runtime\";\nimport { getSection, type Section } from \"../util/sections\";\nimport { addStatement } from \"../util/signals\";\nimport { currentProgramPath, scopeIdentifier } from \"./program\";\n\nconst programsWithInputReference = new WeakSet<t.NodePath<t.Program>>();\nconst abortIdsByExpressionForSection = new WeakMap<\n  Section,\n  Map<t.NodePath<t.Node>, number>\n>();\n\nexport default {\n  migrate(identifier: t.NodePath<t.Identifier>) {\n    const { name } = identifier.node;\n    if (identifier.scope.hasBinding(name)) return;\n    switch (name) {\n      case \"input\": {\n        if (!programsWithInputReference.has(currentProgramPath)) {\n          programsWithInputReference.add(currentProgramPath);\n          insertAfterStatic(\n            t.markoTag(\n              t.stringLiteral(\"attrs\"),\n              undefined,\n              t.markoTagBody(),\n              undefined,\n              identifier.node,\n            ),\n          );\n        }\n        break;\n      }\n      case \"out\":\n        if (\n          t.isMemberExpression(identifier.parent) &&\n          t.isIdentifier(identifier.parent.property) &&\n          identifier.parent.property.name === \"global\"\n        ) {\n          identifier.parentPath.replaceWith(t.identifier(\"$global\"));\n        } else {\n          throw identifier.buildCodeFrameError(\n            \"Only out.global is supported for compatibility.\",\n          );\n        }\n        break;\n    }\n  },\n  translate(identifier: t.NodePath<t.Identifier>) {\n    const { name } = identifier.node;\n    if (identifier.scope.hasBinding(name)) return;\n    switch (name) {\n      case \"$global\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            t.memberExpression(\n              importRuntime(\"$_streamData\"),\n              t.identifier(\"global\"),\n            ),\n          );\n        } else {\n          identifier.replaceWith(\n            t.memberExpression(scopeIdentifier, t.identifier(\"$global\")),\n          );\n        }\n        break;\n      case \"$signal\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            t.callExpression(\n              t.arrowFunctionExpression(\n                [],\n                t.blockStatement([\n                  t.throwStatement(\n                    t.newExpression(t.identifier(\"Error\"), [\n                      t.stringLiteral(\"Cannot use $signal in a server render.\"),\n                    ]),\n                  ),\n                ]),\n              ),\n              [],\n            ),\n          );\n        } else {\n          const section = getSection(identifier);\n          const exprRoot = getExprRoot(identifier);\n          let abortIdsByExpression =\n            abortIdsByExpressionForSection.get(section);\n          let exprId: number | undefined;\n\n          if (abortIdsByExpression) {\n            exprId = abortIdsByExpression.get(exprRoot);\n          } else {\n            abortIdsByExpression = new Map();\n            abortIdsByExpressionForSection.set(section, abortIdsByExpression);\n          }\n\n          if (!exprId) {\n            exprId = abortIdsByExpression.size;\n            abortIdsByExpression.set(exprRoot, exprId);\n            addStatement(\n              \"render\",\n              section,\n              exprRoot.node.extra?.references,\n              t.expressionStatement(\n                t.callExpression(importRuntime(\"resetAbortSignal\"), [\n                  scopeIdentifier,\n                  t.numericLiteral(exprId),\n                ]),\n              ),\n            );\n          }\n\n          identifier.replaceWith(\n            t.callExpression(importRuntime(\"getAbortSignal\"), [\n              scopeIdentifier,\n              t.numericLiteral(exprId),\n            ]),\n          );\n        }\n    }\n  },\n};\n\nfunction insertAfterStatic(node: t.Statement) {\n  for (const child of currentProgramPath.get(\"body\")) {\n    if (!isStatic(child)) {\n      child.insertBefore(node);\n      return;\n    }\n  }\n\n  currentProgramPath.unshiftContainer(\"body\", node);\n}\n","import type { types as t } from \"@marko/compiler\";\nimport { isOutputHTML } from \"../util/marko-config\";\nimport { mergeReferences } from \"../util/references\";\nimport { getSection } from \"../util/sections\";\nimport { addStatement } from \"../util/signals\";\n\nexport default {\n  analyze: {\n    exit(scriptlet: t.NodePath<t.MarkoScriptlet>) {\n      mergeReferences(scriptlet, scriptlet.node.body);\n    },\n  },\n  translate: {\n    exit(scriptlet: t.NodePath<t.MarkoScriptlet>) {\n      const { node } = scriptlet;\n      if (isOutputHTML()) {\n        if (node.static) return; // handled in program exit for html currently.\n        scriptlet.replaceWithMultiple(node.body);\n      } else {\n        if (node.static) {\n          scriptlet.replaceWithMultiple(node.body);\n        } else {\n          addStatement(\n            \"render\",\n            getSection(scriptlet),\n            node.extra?.references,\n            node.body,\n          );\n          scriptlet.remove();\n        }\n      }\n    },\n  },\n};\n","import { type Plugin, getTagDef, isNativeTag } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { isOutputHTML } from \"../../util/marko-config\";\nimport analyzeAttributeTags from \"../../util/nested-attribute-tags\";\nimport * as hooks from \"../../util/plugin-hooks\";\nimport analyzeTagNameType, { TagNameType } from \"../../util/tag-name-type\";\nimport AttributeTag from \"./attribute-tag\";\nimport CustomTag from \"./custom-tag\";\nimport DynamicTag from \"./dynamic-tag\";\nimport NativeTag from \"./native-tag\";\n\nexport default {\n  analyze: {\n    enter(tag: t.NodePath<t.MarkoTag>) {\n      const tagDef = getTagDef(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook as Plugin;\n\n      if (hook) {\n        hooks.enter(hook, tag);\n        return;\n      }\n\n      switch (type) {\n        case TagNameType.NativeTag:\n          NativeTag.analyze.enter(tag);\n          break;\n        case TagNameType.CustomTag:\n          CustomTag.analyze.enter(tag);\n          break;\n        case TagNameType.AttributeTag:\n          AttributeTag.analyze.enter(tag);\n          break;\n        case TagNameType.DynamicTag:\n          DynamicTag.analyze.enter(tag);\n          break;\n      }\n    },\n    exit(tag: t.NodePath<t.MarkoTag>) {\n      const tagDef = getTagDef(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook as Plugin;\n\n      if (hook) {\n        hooks.exit(hook, tag);\n        return;\n      }\n\n      if (type === TagNameType.NativeTag) {\n        // NativeTag.analyze.exit(tag);\n        return;\n      }\n\n      analyzeAttributeTags(tag);\n      switch (type) {\n        case TagNameType.CustomTag:\n          CustomTag.analyze.exit(tag);\n          break;\n        case TagNameType.AttributeTag:\n          // AttributeTag.analyze.exit(tag);\n          break;\n        case TagNameType.DynamicTag:\n          DynamicTag.analyze.exit(tag);\n          break;\n      }\n    },\n  },\n  translate: {\n    enter(tag: t.NodePath<t.MarkoTag>) {\n      const tagDef = getTagDef(tag);\n      const extra = tag.node.extra!;\n\n      if (tagDef?.translator) {\n        if (tagDef.translator.path) {\n          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);\n        }\n        hooks.enter(tagDef.translator.hook, tag);\n        return;\n      }\n\n      for (const attr of tag.get(\"attributes\")) {\n        if (attr.isMarkoAttribute()) {\n          if (attr.node.arguments) {\n            throw attr.buildCodeFrameError(\n              `Unsupported arguments on the \"${attr.node.name}\" attribute.`,\n            );\n          }\n\n          if (attr.node.modifier) {\n            if (isNativeTag(attr.parentPath as t.NodePath<t.MarkoTag>)) {\n              attr.node.name += `:${attr.node.modifier}`;\n            } else {\n              throw attr.buildCodeFrameError(\n                `Unsupported modifier \"${attr.node.modifier}\".`,\n              );\n            }\n          }\n        }\n      }\n\n      if (\n        extra.tagNameDynamic &&\n        extra.tagNameNullable &&\n        !tag.get(\"name\").isIdentifier() &&\n        isOutputHTML()\n      ) {\n        const tagNameId = tag.scope.generateUidIdentifier(\"tagName\");\n        const [tagNameVarPath] = tag.insertBefore(\n          t.variableDeclaration(\"const\", [\n            t.variableDeclarator(tagNameId, tag.node.name),\n          ]),\n        );\n\n        tagNameVarPath.skip();\n        tag.set(\"name\", tagNameId);\n      }\n\n      switch (extra.tagNameType) {\n        case TagNameType.NativeTag:\n          NativeTag.translate.enter(tag);\n          break;\n        case TagNameType.CustomTag:\n          CustomTag.translate.enter(tag);\n          break;\n        case TagNameType.DynamicTag:\n          DynamicTag.translate.enter(tag);\n          break;\n        case TagNameType.AttributeTag:\n          AttributeTag.translate.enter(tag);\n          break;\n      }\n    },\n\n    exit(tag: t.NodePath<t.MarkoTag>) {\n      const translator = getTagDef(tag)?.translator;\n\n      if (translator) {\n        hooks.exit(translator.hook, tag);\n        return;\n      }\n\n      switch (tag.node.extra!.tagNameType) {\n        case TagNameType.NativeTag:\n          NativeTag.translate.exit(tag);\n          break;\n        case TagNameType.CustomTag:\n          CustomTag.translate.exit(tag);\n          break;\n        case TagNameType.DynamicTag:\n          DynamicTag.translate.exit(tag);\n          break;\n        case TagNameType.AttributeTag:\n          AttributeTag.translate.exit(tag);\n          break;\n      }\n    },\n  },\n};\n","import type {\n  EnterExitPlugin,\n  FunctionPlugin,\n  ModulePlugin,\n  Plugin,\n} from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\n\nexport function enter<T extends t.Node>(\n  modulePlugin: Plugin | void,\n  path: t.NodePath<T>,\n) {\n  if (!modulePlugin) {\n    return false;\n  }\n\n  const { node } = path;\n  const plugin = isModulePlugin(modulePlugin)\n    ? modulePlugin.default\n    : modulePlugin;\n\n  if (isFunctionPlugin(plugin)) {\n    plugin(path, t);\n  } else if (plugin.enter) {\n    plugin.enter(path, t);\n  }\n\n  return node !== path.node;\n}\n\nexport function exit<T extends t.Node>(\n  modulePlugin: Plugin | void,\n  path: t.NodePath<T>,\n) {\n  if (!modulePlugin) {\n    return false;\n  }\n\n  const { node } = path;\n  const plugin = isModulePlugin(modulePlugin)\n    ? modulePlugin.default\n    : modulePlugin;\n\n  if (!isFunctionPlugin(plugin) && plugin.exit) {\n    plugin.exit(path, t);\n  }\n\n  return node !== path.node;\n}\n\nfunction isModulePlugin(plugin: Plugin): plugin is ModulePlugin {\n  return Boolean((plugin as ModulePlugin).default);\n}\n\nfunction isFunctionPlugin(\n  plugin: EnterExitPlugin | FunctionPlugin,\n): plugin is FunctionPlugin {\n  return typeof plugin === \"function\";\n}\n","import { assertNoArgs, assertNoVar, findParentTag } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport attrsToObject from \"../../util/attrs-to-object\";\nimport { getSection, startSection } from \"../../util/sections\";\nimport { TagNameType } from \"../../util/tag-name-type\";\nimport * as writer from \"../../util/writer\";\n\nexport default {\n  analyze: {\n    enter(tag: t.NodePath<t.MarkoTag>) {\n      const body = tag.get(\"body\");\n      if (body.get(\"body\").length) {\n        startSection(body);\n      }\n    },\n  },\n  translate: {\n    enter(tag: t.NodePath<t.MarkoTag>) {\n      assertNoArgs(tag);\n\n      getSection(tag.get(\"body\"));\n      if (writer.hasPendingHTML(tag)) {\n        throw tag\n          .get(\"name\")\n          .buildCodeFrameError(\n            \"Dynamic @tags cannot be mixed with body content.\",\n          );\n      }\n    },\n    exit(tag: t.NodePath<t.MarkoTag>) {\n      assertNoVar(tag);\n      writer.flushInto(tag);\n\n      const parentTag = findParentTag(tag);\n\n      if (!parentTag) {\n        throw tag\n          .get(\"name\")\n          .buildCodeFrameError(\"@tags must be nested within another tag.\");\n      }\n\n      const parentExtra = parentTag.node.extra!;\n\n      if (parentExtra.tagNameType === TagNameType.NativeTag) {\n        throw tag\n          .get(\"name\")\n          .buildCodeFrameError(\"@tags cannot be nested under native tags.\");\n      }\n\n      const attrName = (tag.node.name as t.StringLiteral).value.slice(1);\n      const info = parentExtra.nestedAttributeTags![attrName];\n      const attrsObject = attrsToObject(tag, true);\n\n      if (info.dynamic) {\n        if (!info.identifier) {\n          info.identifier = parentTag.scope.generateUidIdentifier(attrName);\n          parentTag.insertBefore(\n            info.repeated\n              ? t.variableDeclaration(\"const\", [\n                  t.variableDeclarator(info.identifier, t.arrayExpression([])),\n                ])\n              : t.variableDeclaration(\"let\", [\n                  t.variableDeclarator(info.identifier),\n                ]),\n          );\n\n          parentTag.pushContainer(\n            \"attributes\",\n            t.markoAttribute(attrName, info.identifier),\n          );\n        }\n\n        tag.replaceWith(\n          t.expressionStatement(\n            info.repeated\n              ? t.callExpression(\n                  t.memberExpression(info.identifier, t.identifier(\"push\")),\n                  [attrsObject],\n                )\n              : t.assignmentExpression(\"=\", info.identifier, attrsObject),\n          ),\n        );\n      } else if (info.repeated) {\n        const existingAttr = parentTag\n          .get(\"attributes\")\n          .find((attr) => (attr.node as t.MarkoAttribute).name === attrName);\n\n        if (existingAttr) {\n          (\n            existingAttr.get(\"value\") as t.NodePath<t.ArrayExpression>\n          ).pushContainer(\"elements\", attrsObject);\n        } else {\n          parentTag.pushContainer(\n            \"attributes\",\n            t.markoAttribute(attrName, t.arrayExpression([attrsObject])),\n          );\n        }\n\n        tag.remove();\n      } else {\n        parentTag.pushContainer(\n          \"attributes\",\n          t.markoAttribute(attrName, attrsObject),\n        );\n        tag.remove();\n      }\n    },\n  },\n};\n","import {\n  assertAttributesOrArgs,\n  getTemplateId,\n  importDefault,\n  importNamed,\n  loadFileForTag,\n} from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { WalkCode } from \"@marko/runtime-tags/common/types\";\nimport attrsToObject, { getRenderBodyProp } from \"../../util/attrs-to-object\";\nimport { isOptimize, isOutputHTML } from \"../../util/marko-config\";\nimport { addReference, mergeReferences } from \"../../util/references\";\nimport {\n  ReserveType,\n  getScopeAccessorLiteral,\n  reserveScope,\n} from \"../../util/reserve\";\nimport { callRuntime } from \"../../util/runtime\";\nimport {\n  getOrCreateSection,\n  getScopeIdIdentifier,\n  getSection,\n} from \"../../util/sections\";\nimport {\n  addValue,\n  buildSignalIntersections,\n  buildSignalValuesWithIntersections,\n  getResumeRegisterId,\n  getSerializedScopeProperties,\n  getSignal,\n  getSignalFn,\n  writeHTMLResumeStatements,\n} from \"../../util/signals\";\nimport toFirstExpressionOrBlock from \"../../util/to-first-expression-or-block\";\nimport translateVar from \"../../util/translate-var\";\nimport * as walks from \"../../util/walks\";\nimport * as writer from \"../../util/writer\";\nimport { currentProgramPath, scopeIdentifier } from \"../program\";\nimport customTag, { getTagRelativePath } from \"./custom-tag\";\n\nexport default {\n  analyze: {\n    enter(tag: t.NodePath<t.MarkoTag>) {\n      reserveScope(\n        ReserveType.Visit,\n        getOrCreateSection(tag),\n        tag.node as any as t.Identifier,\n        tag.scope.generateUid(\"dynamicTagName\"),\n        \"#text\",\n      );\n\n      customTag.analyze.enter(tag);\n    },\n    exit(tag: t.NodePath<t.MarkoTag>) {\n      const extra = (tag.node.extra ??= {});\n      const referenceNodes: t.Node[] = [];\n      if (tag.node.arguments) {\n        for (const arg of tag.node.arguments) {\n          referenceNodes.push(arg);\n        }\n      }\n\n      for (const attr of tag.node.attributes) {\n        referenceNodes.push(attr.value);\n      }\n\n      mergeReferences(tag, referenceNodes);\n      addReference(tag, extra.reserve!);\n    },\n  },\n  translate: {\n    enter(tag: t.NodePath<t.MarkoTag>) {\n      walks.visit(tag, WalkCode.Replace);\n      assertAttributesOrArgs(tag);\n\n      walks.enterShallow(tag);\n\n      if (isOutputHTML()) {\n        writer.flushBefore(tag);\n      }\n    },\n    exit(tag: t.NodePath<t.MarkoTag>) {\n      const { node } = tag;\n      const extra = node.extra!;\n      const tagNameReserve = extra.reserve!;\n      let tagExpression = node.name;\n\n      if (node.extra!.tagNameDefine) {\n        tagExpression = t.memberExpression(\n          node.name,\n          t.identifier(\"renderBody\"),\n        );\n      } else if (t.isStringLiteral(tagExpression)) {\n        const { file } = tag.hub;\n        const relativePath = getTagRelativePath(tag);\n        tagExpression = importDefault(file, relativePath, tagExpression.value);\n      }\n\n      if (extra.___featureType === \"class\") {\n        importDefault(\n          tag.hub.file,\n          `marko/src/runtime/helpers/tags-compat-${\n            isOutputHTML() ? \"html\" : \"dom\"\n          }.js`,\n          \"marko_tags_compat\",\n        );\n\n        if (isOutputHTML()) {\n          const serialized5to6 = importNamed(\n            tag.hub.file,\n            `marko/src/runtime/helpers/tags-compat-html.js`,\n            \"serialized5to6\",\n          );\n          currentProgramPath.pushContainer(\n            \"body\",\n            t.expressionStatement(\n              t.callExpression(serialized5to6, [\n                t.identifier((tagExpression as t.Identifier).name),\n                t.stringLiteral(\n                  getTemplateId(\n                    isOptimize(),\n                    loadFileForTag(tag)!.metadata.marko.id,\n                  ),\n                ),\n              ]),\n            ),\n          );\n        } else {\n          currentProgramPath.pushContainer(\n            \"body\",\n            t.expressionStatement(\n              callRuntime(\n                \"register\",\n                t.stringLiteral(\n                  getTemplateId(\n                    isOptimize(),\n                    loadFileForTag(tag)!.metadata.marko.id,\n                  ),\n                ),\n                t.identifier((tagExpression as t.Identifier).name),\n              ),\n            ),\n          );\n        }\n      }\n\n      if (isOutputHTML()) {\n        writer.flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        const attrsObject = attrsToObject(tag, true);\n        const renderBodyProp = getRenderBodyProp(attrsObject);\n        const args: (t.Expression | t.SpreadElement)[] = [\n          tagExpression,\n          attrsObject,\n        ];\n\n        if (t.isObjectExpression(attrsObject) && renderBodyProp) {\n          const section = getSection(tag);\n          const renderBodySection = getSection(tag.get(\"body\"));\n          attrsObject.properties.pop();\n          args.push(\n            // TODO: omit register if dynamic tag is string only\n            callRuntime(\n              \"register\",\n              callRuntime(\n                \"createRenderer\",\n                t.arrowFunctionExpression(\n                  renderBodyProp.params,\n                  toFirstExpressionOrBlock(renderBodyProp.body),\n                ),\n              ),\n              t.stringLiteral(\n                getResumeRegisterId(renderBodySection, \"renderer\"),\n              ),\n              getScopeIdIdentifier(section),\n            ),\n          );\n        }\n\n        const dynamicScopeIdentifier =\n          currentProgramPath.scope.generateUidIdentifier(\"dynamicScope\");\n        const dynamicTagExpr = t.isArrayExpression(attrsObject)\n          ? callRuntime(\"dynamicTagArgs\", ...args)\n          : callRuntime(\"dynamicTagInput\", ...args);\n        if (node.var) {\n          // TODO: This breaks now that _dynamicTag returns a scope\n          translateVar(tag, dynamicTagExpr);\n          tag.remove();\n        } else {\n          tag\n            .replaceWith(\n              t.variableDeclaration(\"const\", [\n                t.variableDeclarator(dynamicScopeIdentifier, dynamicTagExpr),\n              ]),\n            )[0]\n            .skip();\n        }\n        const section = getSection(tag);\n        writer.writeTo(tag)`${callRuntime(\n          \"markResumeControlEnd\",\n          getScopeIdIdentifier(section),\n          getScopeAccessorLiteral(tagNameReserve),\n        )}`;\n\n        getSerializedScopeProperties(section).set(\n          t.stringLiteral(getScopeAccessorLiteral(tagNameReserve).value + \"!\"),\n          dynamicScopeIdentifier,\n        );\n        getSerializedScopeProperties(section).set(\n          t.stringLiteral(getScopeAccessorLiteral(tagNameReserve).value + \"(\"),\n          t.isIdentifier(tagExpression)\n            ? t.identifier(tagExpression.name)\n            : tagExpression,\n        );\n      } else {\n        const section = getSection(tag);\n        const bodySection = getSection(tag.get(\"body\"));\n        const hasBody = section !== bodySection;\n        const renderBodyIdentifier = hasBody && writer.getRenderer(bodySection);\n        const signal = getSignal(section, tagNameReserve);\n        signal.build = () => {\n          return callRuntime(\n            \"conditional\",\n            getScopeAccessorLiteral(tagNameReserve),\n            getSignalFn(signal, [scopeIdentifier]),\n            buildSignalIntersections(signal),\n            buildSignalValuesWithIntersections(signal),\n          );\n        };\n        signal.hasDownstreamIntersections = () => true;\n        addValue(\n          section,\n          node.name.extra?.references,\n          signal,\n          renderBodyIdentifier\n            ? t.logicalExpression(\"||\", tagExpression, renderBodyIdentifier)\n            : tagExpression,\n        );\n\n        const attrsObject = attrsToObject(tag, true);\n        const emptyAttrs =\n          t.isObjectExpression(attrsObject) && !attrsObject.properties.length;\n        if (!emptyAttrs || renderBodyIdentifier) {\n          const attrsGetter = t.arrowFunctionExpression([], attrsObject);\n          const id = currentProgramPath.scope.generateUidIdentifier(\n            tag.get(\"name\").toString() + \"_input\",\n          );\n          let added = false;\n          addValue(\n            section,\n            node.extra?.references,\n            {\n              get identifier() {\n                if (!added) {\n                  currentProgramPath.pushContainer(\n                    \"body\",\n                    t.variableDeclaration(\"const\", [\n                      t.variableDeclarator(\n                        id,\n                        callRuntime(\n                          \"dynamicTagAttrs\",\n                          getScopeAccessorLiteral(tagNameReserve),\n                          renderBodyIdentifier,\n                          t.isArrayExpression(attrsObject)\n                            ? t.booleanLiteral(true)\n                            : false,\n                        ),\n                      ),\n                    ]),\n                  );\n                  added = true;\n                }\n                return id;\n              },\n              hasDownstreamIntersections: () => true,\n            },\n            attrsGetter,\n          );\n        }\n\n        tag.remove();\n      }\n    },\n  },\n};\n","import { types as t } from \"@marko/compiler\";\nexport default function toFirstExpressionOrBlock(\n  body: t.BlockStatement | t.MarkoTagBody,\n) {\n  const nodes = body.body;\n  if (nodes.length === 1 && t.isExpressionStatement(nodes[0])) {\n    return nodes[0].expression;\n  }\n\n  if (t.isBlockStatement(body)) {\n    return body;\n  }\n\n  return t.blockStatement(nodes);\n}\n","import { assertNoArgs, getTagDef } from \"@marko/babel-utils\";\nimport { types as t } from \"@marko/compiler\";\nimport { WalkCode } from \"@marko/runtime-tags/common/types\";\nimport attrsToObject from \"../../util/attrs-to-object\";\nimport evaluate from \"../../util/evaluate\";\nimport { isOutputHTML } from \"../../util/marko-config\";\nimport { mergeReferences } from \"../../util/references\";\nimport {\n  ReserveType,\n  getScopeAccessorLiteral,\n  reserveScope,\n} from \"../../util/reserve\";\nimport { callRuntime, getHTMLRuntime } from \"../../util/runtime\";\nimport {\n  createScopeReadExpression,\n  getScopeExpression,\n} from \"../../util/scope-read\";\nimport { getOrCreateSection, getSection } from \"../../util/sections\";\nimport { addHTMLEffectCall, addStatement } from \"../../util/signals\";\nimport translateVar from \"../../util/translate-var\";\nimport * as walks from \"../../util/walks\";\nimport * as writer from \"../../util/writer\";\nimport { currentProgramPath, scopeIdentifier } from \"../program\";\n\ndeclare module \"@marko/compiler/dist/types\" {\n  export interface ProgramExtra {\n    isInteractive?: boolean;\n  }\n}\n\nexport default {\n  analyze: {\n    enter(tag: t.NodePath<t.MarkoTag>) {\n      const { node } = tag;\n      const attrs = tag.get(\"attributes\");\n      let section = tag.has(\"var\") ? getOrCreateSection(tag) : undefined;\n      let isInteractive = false;\n\n      /**\n       * The reason this seems like it does more work than it needs to\n       * is because `evaluate` has side effects so it needs to be run\n       * for every attribute that isn't an event handler or a spread\n       */\n      for (const attr of attrs) {\n        if (isSpreadAttr(attr)) {\n          section ??= getOrCreateSection(tag);\n          mergeReferences(\n            tag,\n            attrs.map((attr) => attr.node.value),\n          );\n          isInteractive = true;\n          break;\n        } else if (isEventHandler((attr.node as t.MarkoAttribute).name)) {\n          section ??= getOrCreateSection(tag);\n          isInteractive = true;\n        } else if (!evaluate(attr).confident) {\n          section ??= getOrCreateSection(tag);\n        }\n      }\n\n      if (section !== undefined) {\n        currentProgramPath.node.extra.isInteractive = isInteractive;\n        const tagName =\n          node.name.type === \"StringLiteral\"\n            ? node.name.value\n            : t.toIdentifier(tag.get(\"name\"));\n        const varName = node.var\n          ? node.var.type === \"Identifier\"\n            ? node.var.name\n            : t.toIdentifier(tag.get(\"var\"))\n          : tagName;\n        reserveScope(ReserveType.Visit, section, node, varName, `#${tagName}`);\n      }\n    },\n  },\n  translate: {\n    enter(tag: t.NodePath<t.MarkoTag>) {\n      assertNoArgs(tag);\n\n      const extra = tag.node.extra!;\n      const isHTML = isOutputHTML();\n      const name = tag.get(\"name\");\n      const attrs = tag.get(\"attributes\");\n      const tagDef = getTagDef(tag);\n      const hasSpread = attrs.some((attr) => attr.isMarkoSpreadAttribute());\n      const write = writer.writeTo(tag);\n      const section = getSection(tag);\n\n      // TODO: throw error if var is not an identifier (like let)\n\n      if (isHTML && extra.tagNameNullable) {\n        writer.flushBefore(tag);\n      }\n\n      if (tag.has(\"var\")) {\n        if (isHTML) {\n          translateVar(\n            tag,\n            t.arrowFunctionExpression(\n              [],\n              t.blockStatement([\n                t.throwStatement(\n                  t.newExpression(t.identifier(\"Error\"), [\n                    t.stringLiteral(\"Cannot reference DOM node from server\"),\n                  ]),\n                ),\n              ]),\n            ),\n          );\n        } else {\n          const varName = (tag.node.var as t.Identifier).name;\n          const references = tag.scope.getBinding(varName)!.referencePaths;\n          let createElFunction = undefined;\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (reference.parentPath?.isCallExpression()) {\n              reference.parentPath.replaceWith(\n                t.expressionStatement(\n                  createScopeReadExpression(referenceSection, extra.reserve!),\n                ),\n              );\n            } else {\n              createElFunction ??= t.identifier(varName + \"_getter\");\n              reference.replaceWith(\n                callRuntime(\n                  \"bindFunction\",\n                  getScopeExpression(referenceSection, extra.reserve!.section),\n                  createElFunction,\n                ),\n              );\n            }\n          }\n          if (createElFunction) {\n            currentProgramPath.pushContainer(\n              \"body\",\n              t.variableDeclaration(\"const\", [\n                t.variableDeclarator(\n                  createElFunction,\n                  t.arrowFunctionExpression(\n                    [scopeIdentifier],\n                    t.memberExpression(\n                      scopeIdentifier,\n                      getScopeAccessorLiteral(extra.reserve!),\n                      true,\n                    ),\n                  ),\n                ),\n              ]),\n            );\n          }\n        }\n      }\n\n      let visitAccessor: t.StringLiteral | t.NumericLiteral | undefined;\n      if (extra.reserve) {\n        visitAccessor = getScopeAccessorLiteral(extra.reserve);\n        walks.visit(tag, WalkCode.Get);\n      }\n\n      write`<${name.node}`;\n\n      if (hasSpread) {\n        if (isHTML) {\n          write`${callRuntime(\"attrs\", attrsToObject(tag)!)}`;\n        } else {\n          addStatement(\n            \"render\",\n            section,\n            extra.references,\n            t.expressionStatement(\n              callRuntime(\n                \"attrs\",\n                scopeIdentifier,\n                visitAccessor,\n                attrsToObject(tag)!,\n              ),\n            ),\n          );\n        }\n      } else {\n        // TODO: #129 this should iterate backward and filter out duplicated attrs.\n        for (const attr of attrs as t.NodePath<t.MarkoAttribute>[]) {\n          const name = attr.node.name;\n          const value = attr.get(\"value\");\n          const { confident, computed } = attr.node.extra ?? {};\n          const valueReferences = value.node.extra?.references;\n\n          switch (name) {\n            case \"class\":\n            case \"style\": {\n              const helper = `${name}Attr` as const;\n              if (confident) {\n                write`${getHTMLRuntime()[helper](computed)}`;\n              } else if (isHTML) {\n                write`${callRuntime(helper, value.node)}`;\n              } else {\n                addStatement(\n                  \"render\",\n                  section,\n                  valueReferences,\n                  t.expressionStatement(\n                    callRuntime(\n                      helper,\n                      t.memberExpression(scopeIdentifier, visitAccessor!, true),\n                      value.node,\n                    ),\n                  ),\n                );\n              }\n              break;\n            }\n            default:\n              if (confident) {\n                write`${getHTMLRuntime().attr(name, computed)}`;\n              } else if (isHTML) {\n                if (isEventHandler(name)) {\n                  addHTMLEffectCall(section, valueReferences);\n                } else {\n                  write`${callRuntime(\n                    \"attr\",\n                    t.stringLiteral(name),\n                    value.node,\n                  )}`;\n                }\n              } else if (isEventHandler(name)) {\n                addStatement(\n                  \"effect\",\n                  section,\n                  valueReferences,\n                  t.expressionStatement(\n                    callRuntime(\n                      \"on\",\n                      t.memberExpression(scopeIdentifier, visitAccessor!, true),\n                      t.stringLiteral(getEventHandlerName(name)),\n                      value.node,\n                    ),\n                  ),\n                  value.node,\n                );\n              } else {\n                addStatement(\n                  \"render\",\n                  section,\n                  valueReferences,\n                  t.expressionStatement(\n                    callRuntime(\n                      \"attr\",\n                      t.memberExpression(scopeIdentifier, visitAccessor!, true),\n                      t.stringLiteral(name),\n                      value.node,\n                    ),\n                  ),\n                );\n              }\n\n              break;\n          }\n        }\n      }\n\n      if (tagDef && tagDef.parseOptions?.openTagOnly) {\n        switch (tagDef.htmlType) {\n          case \"svg\":\n          case \"math\":\n            write`/>`;\n            break;\n          default:\n            write`>`;\n            break;\n        }\n      } else {\n        write`>`;\n      }\n\n      if (isHTML && extra.tagNameNullable) {\n        tag\n          .insertBefore(t.ifStatement(name.node, writer.consumeHTML(tag)!))[0]\n          .skip();\n      }\n\n      walks.enter(tag);\n    },\n    exit(tag: t.NodePath<t.MarkoTag>) {\n      const extra = tag.node.extra!;\n      const isHTML = isOutputHTML();\n      const openTagOnly = getTagDef(tag)?.parseOptions?.openTagOnly;\n\n      if (isHTML && extra.tagNameNullable) {\n        writer.flushInto(tag);\n      }\n\n      tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n\n      if (!openTagOnly) {\n        writer.writeTo(tag)`</${tag.node.name}>`;\n      }\n\n      // dynamic tag stuff\n      if (isHTML && extra.tagNameNullable) {\n        tag\n          .insertBefore(\n            t.ifStatement(tag.node.name, writer.consumeHTML(tag)!),\n          )[0]\n          .skip();\n      }\n\n      if (extra.reserve) {\n        writer.markNode(tag);\n      }\n\n      walks.exit(tag);\n      tag.remove();\n    },\n  },\n};\n\nfunction isSpreadAttr(\n  attr: t.NodePath<t.MarkoAttribute | t.MarkoSpreadAttribute>,\n): attr is t.NodePath<t.MarkoSpreadAttribute> {\n  return attr.type === \"MarkoSpreadAttribute\";\n}\n\nfunction isEventHandler(propName: string) {\n  return /^on[A-Z-]/.test(propName);\n}\n\nfunction getEventHandlerName(propName: string) {\n  return propName.charAt(2) === \"-\"\n    ? propName.slice(3)\n    : propName.charAt(2).toLowerCase() + propName.slice(3);\n}\n","import { types as t } from \"@marko/compiler\";\nimport { isOutputHTML } from \"../util/marko-config\";\nimport * as walks from \"../util/walks\";\nimport * as writer from \"../util/writer\";\n\nexport default {\n  translate: {\n    exit(text: t.NodePath<t.MarkoText>) {\n      const followingSiblings = (text.container as t.Statement[]).slice(\n        (text.key as number) + 1,\n      );\n      let needsSeparator = false;\n      if (isOutputHTML()) {\n        for (const sibling of followingSiblings) {\n          if (t.isMarkoPlaceholder(sibling)) {\n            needsSeparator = true;\n            break;\n          } else if (t.isMarkoTag(sibling) || t.isMarkoText(sibling)) {\n            break;\n          }\n        }\n      }\n      writer.writeTo(text)`${text.node.value}${needsSeparator ? \"<!>\" : \"\"}`;\n      walks.enterShallow(text);\n\n      text.remove();\n    },\n  },\n};\n","import { types as t } from \"@marko/compiler\";\nimport { isOutputDOM } from \"../util/marko-config\";\nimport { getAssignmentGenerator } from \"../util/replace-assignments\";\n\nexport default {\n  translate: {\n    exit(assignment: t.NodePath<t.UpdateExpression>) {\n      if (isOutputDOM()) {\n        const generator = getAssignmentGenerator(\n          assignment,\n          (assignment.node.argument as t.Identifier).name,\n        );\n\n        if (generator) {\n          const replacement = generator(\n            assignment,\n            t.binaryExpression(\n              assignment.node.operator === \"++\" ? \"+\" : \"-\",\n              assignment.node.argument,\n              t.numericLiteral(1),\n            ),\n          );\n          assignment.replaceWith(\n            assignment.node.prefix ||\n              assignment.parentPath.isExpressionStatement()\n              ? replacement\n              : t.sequenceExpression([replacement, assignment.node.argument]),\n          );\n        }\n      }\n    },\n  },\n};\n"],"names":["src_exports","__export","analyze","taglibs","translate","module","exports","import_babel_utils","require","taglibId","isCoreTag","tag","isMarkoTag","getTagDef","isCoreTagName","name","node","value","import_compiler13","isOutputHTML","getMarkoOpts","output","isOutputDOM","currentProgramPath","hub","file","markoOpts","isOptimize","optimize","getExprRoot","path2","curPath","isMarko","parentPath","type","isFunctionExpression","push","data","item","Array","isArray","forEach","cb","findSorted","compare","max","length","pos","mid","cur","compareResult","addSorted","len","result","i","next","joinRepeatable","a","b","import_compiler3","import_babel_utils3","import_compiler2","import_babel_utils2","import_compiler","MARKO_FILE_REG","analyzeTagNameType","extra","tagNameType","get","isStringLiteral","isNativeTag","types","isValidIdentifier","scope","hasBinding","tagIdentifier","newNode","identifier","originalNode","start","loc","end","references","getBinding","reserve","analyzeExpressionTagName","replaceWith","childFile","loadFileForTag","childProgram","ast","program","___featureType","tagNameNullable","pending","nullable","pop","isConditionalExpression","alternate","isLogicalExpression","operator","isAssignmentExpression","isBinaryExpression","isTemplateLiteral","isNullLiteral","isIdentifier","binding","kind","decl","path","parent","test","source","specifiers","some","it","isImportDefaultSpecifier","resolvedImport","resolveTagImport","tagNameImported","bindingTag","bindingTagName","tagNameDefine","tagNameDynamic","startSection","section","parentSection","getOrCreateSection","sectionNamePath","sectionName","isProgram","generateUid","toString","programExtra","sections","id","depth","startNodeContentType","getStartNodeContentType","endNodeContentType","getEndNodeContentType","getSection","currentPath","_setSectionPath","createSectionState","key","init","arrayOfSectionData","state","getScopeIdIdentifier","generateUidIdentifier","getSectionPath","_getScopeIdentifier","getScopeIdentifier","ignoreDefault","scopeId","forEachSection","fn","child","contentType","getNodeContentType","body","extraMember","isMarkoText","isMarkoComment","isMarkoPlaceholder","isMarkoCDATA","isMarkoScriptlet","isAttributeTag","tagSection","getReservesByType","reserveScope","debugKey","reserve2","reservesByType","getScopeAccessorLiteral","numericLiteral","stringLiteral","reserveUtil","constructor","add","this","union","aLen","bLen","aIndex","bIndex","unionSortedRepeatable","find","intersectionSubscribeCounts","WeakMap","getIntersectionsBySection","setIntersectionsBySection","trackReferencesForBindings","identifiers","getBindingIdentifiers","referencePaths","constantViolations","reference","addBindingToReference","fnRoot","getFnRoot","exprRoot","markoRoot","previousReferences","newReferences","isIntersection","removeSubscriber","getIntersection","addSubscriber","closures","fnExtra","isMarkoAttribute","default","mergeReferences","target","nodes","compareIntersections","lenDelta","intersections","intersection","set","import_babel_utils4","import_compiler5","val","escapeXML","escapeIfNeeded","lastPos","replacement","slice","escapeScript","escapeTagEnding","escapeStyle","tagName","openTag","escaped","indexOf","escapeAttrValue","quoteValue","escape","startPos","quote","stringifyClassObject","isVoid","NON_DIMENSIONAL","stringifyStyleObject","toDelimitedString","delimiter","stringify","curDelimiter","v","part","classAttr","stringAttr","styleAttr","attr","attrAssignment","RegExp","nonVoidUntypedAttr","hasOwnProperty","Object","prototype","Symbol","String","doc","walker","replacementNode","targetParent","targetNode","refNode","nextNode","runtimePrefix","document","createTreeWalker","getElementById","parentNode","firstChild","insertBefore","removeChild","nextSibling","replace","import_compiler4","createScopeReadPattern","rootDepth","rootPattern","objectPattern","nestedPatterns","ref","includes","propertyKey","propertyValue","isShorthand","pattern","relativeDepth","prev","nestedPattern","properties","objectProperty","getScopeExpression","targetSection","scopeIdentifier","diff","memberExpression","Error","createScopeReadExpression","pureFunctions","importRuntime","importNamed","getRuntimePath","callRuntime","args","callExpression2","callExpression","filteredArgs","arg","unaryExpression","filterArguments","leadingComments","getHTMLRuntime","import_babel_utils7","import_compiler11","import_babel_utils6","import_compiler10","import_babel_utils5","import_compiler9","assertNoSpreadAttrs","attr2","isMarkoSpreadAttribute","buildCodeFrameError","assertNoBodyContent","import_compiler8","import_compiler6","toTemplateOrStringLiteral","parts","strs","exprs","curStr","content","nextIndex","exprLen","expressions","shiftItems","quasis","j","raw","templateLiteral","map","templateElement","appendLiteral","arr","str","list","offset","import_compiler7","getWalks","getWalkComment","getSteps","walkCodeToName","enter","exit","enterShallow","visit","code","steps","walks","walkComment","walkString","walks2","step","lastIndexOf","current","count","walk","nCodeString","writeTo","fromCharCode","number","toCharString","startCode","rangeSize","multiplier","Math","floor","getWalkString","prefix","postfix","walkLiteral","join","getRenderer","getWrites","getRegisterRenderer","setRegisterRenderer","exprsLen","writes","consumeHTML","expressionStatement","flushBefore","expr","skip","flushInto","pushContainer","getSectionMeta","writePrefix","writePostfix","setup","getSetup","register","markNode","returnId","_setReturnId","return_default","assertNoVar","assertNoParams","defaultAttr","attributes","msg","buildError","returnId2","variableDeclaration","variableDeclarator","addValue","hasDownstreamIntersections","remove","autocomplete","displayText","description","snippet","descriptionMoreURL","getSignals","Map","getSubscribeBuilder","_setSubscribeBuilder","setSubscriberBuilder","builder","getClosures","addClosure","fromSection","toSection","closure","currentSection","forceResumeScope","_setForceResumeScope","setForceResumeScope","getSerializedScopeProperties","getRegisterScopeBuilder","_setRegisterScopeBuilder","setRegisterScopeBuilder","unimplementedBuild","getSignal","signals","signal","generateSignalName","values","render","effect","effectInlineReferences","subscribers","size","build","subscribe","getSignalFn","provider","ownerScope","isImmediateOwner","object","isDynamicClosure","arrowFunctionExpression","buildSignalIntersections","buildSignalValuesWithIntersections","initValue","valueAccessor","valuesWithIntersections","params","unshift","blockStatement","closureEntries","from","entries","sort","closureSection","closureSignal","hasDynamicSubscribers","arrayExpression","intersectionExpression","getTagVarSignal","varPath","getDestructureSignal","bindingsByName","destructurePattern","bindings","valueIdentifier","bindingSignals","declarations","canCallOnlyWhenDirty","cleanIdentifier","ifStatement","assignmentExpression","subscriber","p","providerSignal","finalizeSignalArgs","isArrowFunctionExpression","nullLiteral","isExpressionStatement","expression","addStatement","statement","originalNodes","isInlined","statements","isFunction","addEffectReferences","getResumeRegisterId","opts","filename","getTemplateId","sortSignals","aReserves","getReserves","bReserves","getMappedId","addHTMLEffectCall","writeHTMLResumeStatements","tagVarIdentifier","intersectionsBySection","allSignals","scopeIdIdentifier","serializedReferences","signalRefs","accessors","Set","additionalProperties","serializedProperties","accessor","has","isLiteral","objectExpression","unshiftContainer","bindFunctionsVisitor","FunctionExpression","bindFunction","ArrowFunctionExpression","root","functionIdentifier","returnStatement","dom_default","templateIdentifier","walksIdentifier","setupIdentifier","argsSignalIdentifier","closuresIdentifier","forEachSectionReverse","childSection","sectionPath","tagParamsSignal","paramsPaths","arrayPattern","reduce","bindingsLookup","assign","getTagParamsSignal","effectDeclarator","effectIdentifier","isCallExpression","arguments","signalDeclarator","roots","traverse","writeSignals","writes2","setup2","register2","closures2","renderer","exportSpecifiers","bindingIdentifier","signalIdentifier","exportSpecifier","exportNamedDeclaration","var","functionExpression","exportDefaultDeclaration","import_babel_utils8","import_compiler12","isStatic","isImportDeclaration","isExportDeclaration","static","html_default","returnIdentifier","renderContent","replaceWithMultiple","rendererId","previousProgramPath","program_default","migrate","crawl","curIndex","reserves","filter","finalizeIntersections","importDeclaration","hasInteractiveChild","isInteractive","flush_here_and_after_default","import_compiler14","attrs_default","import_babel_utils12","import_babel_utils9","import_compiler18","import_compiler16","import_compiler15","IDENTIFIER_REG","htmlHoistFunctionVisitor","htmlFunctionVisit","domHoistFunctionVisitor","domFunctionVisit","serializedScopeProperties","registerId","fnId","attrsToObject","withRenderBody","resultExtra","hoistVisitor","spreadElement","hoistedControlFlows","isConditional","isLoop","objectMethod","prop","isSpreadElement","argument","getRenderBodyProp","attrsObject","isObjectExpression","lastProp","isObjectMethod","import_compiler17","translateVar","initialValue","tagVar","cloneDeep","custom_tag_default","trackReferences","getTagTemplate","childProgramExtra","assertAttributesOrArgs","assertAttributesOrSingleArg","tagBody","relativePath","getTagRelativePath","importDefault","renderBodyProp","peekScopeId","renderBodyId","renderTagExpr","renderBodySection","renderBodyPath","callStatement","translateHTML","tagBodySection","write2","tagAttrsIdentifier","injectWalks","translateDOM","nameIsString","template","resolveRelativePath","tags","metadata","marko","Boolean","import_babel_utils11","import_compiler20","import_babel_utils10","analyzeAttributeTags","nestedAttributeTags","analyzeChildren","rootExtra","repeated","dynamic","hasAttributeTags","analyzeChild","isTransparentTag","isLoopTag","attrName","lookup","existing","info","import_compiler19","toFirstStatementOrBlock","isBlockStatement","if_default","exitBranchAnalyze","testAttr","enterBranchTranslate","exitBranchTranslate","BRANCHES_LOOKUP","getBranches","bodySection","branches","nextTag","getNextSibling","isLast","rootTag","tag2","isStateful","singleNodeOptimization","every","getRoot","section2","conditionalExpression","ifScopeIdIdentifier","ifScopeIdentifier","ifRendererIdentifier","curStatement","else_default","import_babel_utils13","import_compiler21","else_if_default","import_babel_utils14","import_compiler22","const_default","derivation","import_compiler23","define_default","import_babel_utils16","import_compiler24","effect_default","value2","inlineBody","hasDeclaration","isDeclaration","import_babel_utils17","export_default","parse","parseStatements","rawValue","parseOptions","rootOnly","rawOpenTag","openTagOnly","ignoreAttributes","relaxRequireCommas","import_babel_utils18","import_compiler25","for_default","isOnlyChild","html","checkOnlyChild","parentTag","parentTagName","keys","attrs2","hasParams","findName","assertAllowedAttributes","validateFor","translateHTML2","translateDOM2","of","in","to","paramIdentifiers","signal2","ofAttr","toAttr","inAttr","loopArgs","loopKind","fromAttr","stepAttr","byAttr","namePath","block","byParams","keyExpression","tempScopeIdentifier","sequenceExpression","byIdentifier","keyParam","valParam","forInStatement","ofAttrValue","indexParam","loopParam","tempValParam","indexName","generateUidIdentifierBasedOnNode","updateExpression","forOfStatement","stepValue","fromValue","stepsName","stepName","fromName","binaryExpression","forStatement","logicalExpression","forScopeIdsIdentifier","forScopesIdentifier","newExpression","obj","import_babel_utils19","html_comment_default","assertNoAttributes","assertNoAttributeTags","text","import_babel_utils20","import_compiler26","id_default","assertNoArgs","import_babel_utils21","import_default","import_babel_utils22","import_compiler27","assignmentGeneratorMaps","getAssignmentGenerator","assignment","let_default","markoAttribute","initValueId","generatorMap","registerAssignmentGenerator","queueSource","import_babel_utils23","import_compiler28","lifecycle_default","noop_default","import_babel_utils24","import_compiler29","static_default","trim","markoScriptlet","import_path","__toESM","import_babel_utils25","import_compiler30","core_default","base","basename","sourceFileName","typeAttr","classAttr2","typeValue","classValue2","startsWith","markoText","resolveVirtualDependency","importPath","endPos","virtualPath","importDefaultSpecifier","enum","import_compiler31","assignment_expression_default","left","handleDestructure","generator","right","ctx","getStatementParent","elements","valueId","insertAfter","cdata_default","cdata","ieConditionalCommentRegExp","comment_default","comment","declaration_default","declaration","document_type_default","documentType","import_babel_utils26","functionIdsBySection","function_default","functionNameCounts","index","import_babel_utils27","import_declaration_default","request","import_babel_utils29","import_compiler32","import_babel_utils28","evaluate","confident","computed","computeNode","ESCAPE_TYPES","script","style","placeholder_default","placeholder","getPrevSibling","noOutput","needsMarker","isHTML","canWriteHTML","method","getParentTagName","import_compiler33","programsWithInputReference","WeakSet","abortIdsByExpressionForSection","referenced_identifier_default","insertAfterStatic","markoTag","markoTagBody","isMemberExpression","property","throwStatement","exprId","abortIdsByExpression","scriptlet_default","scriptlet","import_babel_utils33","import_compiler39","import_compiler34","enter2","modulePlugin","plugin","isModulePlugin","isFunctionPlugin","exit2","import_babel_utils30","import_compiler35","attribute_tag_default","hasPendingHTML","findParentTag","parentExtra","existingAttr","import_babel_utils31","import_compiler37","import_compiler36","dynamic_tag_default","referenceNodes","addReference","tagNameReserve","tagExpression","serialized5to6","toFirstExpressionOrBlock","dynamicScopeIdentifier","dynamicTagExpr","isArrayExpression","renderBodyIdentifier","attrsGetter","added","booleanLiteral","import_babel_utils32","import_compiler38","native_tag_default","isSpreadAttr","attr3","isEventHandler","toIdentifier","tagDef","hasSpread","varName","createElFunction","referenceSection","visitAccessor","name2","valueReferences","helper","propName","charAt","toLowerCase","htmlType","tag_default","hook","analyzer","translator","watchFiles","modifier","tagNameId","tagNameVarPath","import_compiler40","text_default","followingSiblings","container","needsSeparator","sibling","import_compiler41","visitors","Program","Function","AssignmentExpression","UpdateExpression","ReferencedIdentifier","ImportDeclaration","MarkoDocumentType","MarkoDeclaration","MarkoCDATA","MarkoText","MarkoTag","MarkoPlaceholder","MarkoScriptlet","MarkoComment","getVisitorOfType","typename","visitor"],"sourceRoot":""}