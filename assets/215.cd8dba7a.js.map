{"version":3,"file":"215.cd8dba7a.js","mappings":"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","sources":["webpack:///../../node_modules/@marko/translator-tags/dist/index.js"],"sourcesContent":["\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  analyze: () => analyze,\n  getRuntimeEntryFiles: () => getRuntimeEntryFiles,\n  internalEntryBuilder: () => entry_builder_default,\n  taglibs: () => taglibs,\n  transform: () => transform,\n  translate: () => translate\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/util/is-core-tag.ts\nvar import_babel_utils = require(\"@marko/babel-utils\");\n\n// src/util/get-tag-name.ts\nfunction getTagName(tag) {\n  return tag.node.name.value;\n}\n\n// src/util/is-core-tag.ts\nvar taglibId = \"marko-core\";\nvar interopTaglibId = \"@marko/translator-interop-class-tags\";\nfunction isCoreTag(tag) {\n  const id = tag.isMarkoTag() && (0, import_babel_utils.getTagDef)(tag)?.taglibId;\n  return id === taglibId || id === interopTaglibId;\n}\nfunction isCoreTagName(tag, name) {\n  return isCoreTag(tag) && getTagName(tag) === name;\n}\nfunction isConditionTag(tag) {\n  if (isCoreTag(tag)) {\n    switch (getTagName(tag)) {\n      case \"if\":\n      case \"else-if\":\n      case \"else\":\n        return true;\n    }\n  }\n  return false;\n}\n\n// src/core/__flush_here_and_after__.ts\nvar import_babel_utils2 = require(\"@marko/babel-utils\");\nvar flush_here_and_after_default = {\n  transform: [\n    (tag) => {\n      if ((0, import_babel_utils2.getTagDef)(tag)?.renderer) {\n        return;\n      }\n      tag.replaceWithMultiple(tag.node.body.body);\n    }\n  ]\n};\n\n// src/core/attrs.ts\nvar import_compiler = require(\"@marko/compiler\");\nvar attrs_default = {\n  migrate: [\n    (tag) => {\n      const tagVar = tag.node.var;\n      if (tagVar && !(tagVar.type === \"Identifier\" && tagVar.name === \"input\")) {\n        const constTag = import_compiler.types.markoTag(\n          import_compiler.types.stringLiteral(\"const\"),\n          [import_compiler.types.markoAttribute(\"value\", import_compiler.types.identifier(\"input\"))],\n          import_compiler.types.markoTagBody([])\n        );\n        constTag.var = tagVar;\n        tag.replaceWith(constTag);\n      } else {\n        tag.remove();\n      }\n    }\n  ],\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"attrs/{ ... }\",\n      description: \"Use to receive the attributes passed into this template.\",\n      snippet: \"attrs/{ $1 }$2\"\n    }\n  ]\n};\n\n// src/core/client.ts\nvar import_babel_utils3 = require(\"@marko/babel-utils\");\nvar import_compiler2 = require(\"@marko/compiler\");\nvar client_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^client\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils3.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler2.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler2.types.markoScriptlet(body, true, \"client\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"client <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the client.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#client-javascript\"\n    }\n  ]\n};\n\n// src/core/const.ts\nvar import_babel_utils11 = require(\"@marko/babel-utils\");\nvar import_compiler19 = require(\"@marko/compiler\");\n\n// src/util/assert.ts\nfunction assertNoSpreadAttrs(tag) {\n  for (const attr2 of tag.get(\"attributes\")) {\n    if (attr2.isMarkoSpreadAttribute()) {\n      throw attr2.buildCodeFrameError(\n        `The \\`${tag.get(\"name\").node.value}\\` tag does not support \\`...spread\\` attributes.`\n      );\n    }\n  }\n}\nfunction assertNoBodyContent(tag) {\n  if (tag.node.body.body.length) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${tag.get(\"name\").node.value}\\` tag does not support body content.`\n    );\n  }\n}\n\n// src/visitors/program/index.ts\nvar import_babel_utils10 = require(\"@marko/babel-utils\");\nvar import_compiler17 = require(\"@marko/compiler\");\nvar import_path = __toESM(require(\"path\"));\n\n// src/util/binding-has-downstream-expressions.ts\nfunction bindingHasDownstreamExpressions(binding) {\n  if (binding.downstreamExpressions.size) return true;\n  for (const alias of binding.aliases) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  return false;\n}\n\n// src/util/entry-builder.ts\nvar import_babel_utils4 = require(\"@marko/babel-utils\");\nvar import_compiler3 = require(\"@marko/compiler\");\nvar kState = Symbol();\nvar entry_builder_default = {\n  build(entryFile) {\n    const state = entryFile[kState];\n    if (!state) {\n      throw entryFile.path.buildCodeFrameError(\n        \"Unable to build hydrate code, no files were visited before finalizing the build\"\n      );\n    }\n    const body = state.imports.map(\n      (it) => import_compiler3.types.importDeclaration([], import_compiler3.types.stringLiteral(it))\n    );\n    if (state.init) {\n      body.unshift(\n        import_compiler3.types.importDeclaration(\n          [import_compiler3.types.importSpecifier(import_compiler3.types.identifier(\"init\"), import_compiler3.types.identifier(\"init\"))],\n          import_compiler3.types.stringLiteral(\n            `@marko/runtime-tags/${entryFile.markoOpts.optimize ? \"\" : \"debug/\"}dom`\n          )\n        )\n      );\n      body.push(\n        import_compiler3.types.expressionStatement(import_compiler3.types.callExpression(import_compiler3.types.identifier(\"init\"), []))\n      );\n    }\n    return body;\n  },\n  visit(file, entryFile, visitChild) {\n    const state = entryFile[kState] ||= {\n      imports: [],\n      init: false\n    };\n    const { analyzedTags } = file.metadata.marko;\n    state.imports.push(\n      (0, import_babel_utils4.resolveRelativePath)(entryFile, file.opts.filename)\n    );\n    state.init ||= file.path.node.extra.hasInteractiveChild || file.path.node.extra.isInteractive || false;\n    for (const tag of analyzedTags || []) {\n      visitChild(tag);\n    }\n  }\n};\n\n// src/util/references.ts\nvar import_compiler6 = require(\"@marko/compiler\");\n\n// src/util/get-root.ts\nfunction getMarkoRoot(path4) {\n  let curPath = path4;\n  do\n    curPath = curPath.parentPath;\n  while (curPath && !isMarko(curPath));\n  return curPath;\n}\nfunction getExprRoot(path4) {\n  let curPath = path4;\n  while (!isMarko(curPath.parentPath)) {\n    curPath = curPath.parentPath;\n    if (curPath.type === \"AssignmentExpression\") {\n      const destructRoot = getDestructureRoot(curPath);\n      if (isMarko(destructRoot.parentPath)) {\n        curPath = curPath.get(\"right\");\n        break;\n      }\n      curPath = destructRoot.parentPath;\n    }\n  }\n  return curPath;\n}\nfunction getFnRoot(path4) {\n  let curPath = path4;\n  if (curPath.isProgram()) return;\n  while (!isFunctionExpression(curPath)) {\n    if (isMarko(curPath)) return;\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction isMarko(path4) {\n  switch (path4.type) {\n    case \"MarkoTag\":\n    case \"MarkoTagBody\":\n    case \"MarkoAttribute\":\n    case \"MarkoSpreadAttribute\":\n    case \"MarkoPlaceholder\":\n    case \"MarkoScriptlet\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isFunctionExpression(path4) {\n  switch (path4.type) {\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction getDestructureRoot(path4) {\n  switch (path4.parent.type) {\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"ObjectProperty\":\n      return getDestructureRoot(path4.parentPath);\n    default:\n      return path4;\n  }\n}\n\n// src/util/is-stateful.ts\nfunction isStatefulReferences(referencedBindings) {\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        if (isStatefulBinding(ref)) {\n          return true;\n        }\n      }\n    } else {\n      return isStatefulBinding(referencedBindings);\n    }\n  }\n  return false;\n}\nfunction isStatefulBinding(binding) {\n  switch (binding.type) {\n    case 1 /* let */:\n    case 2 /* input */:\n      return true;\n    default:\n      return !binding.upstreamExpression || isStatefulReferences(binding.upstreamExpression.referencedBindings);\n  }\n}\n\n// src/util/optional.ts\nvar Sorted = class {\n  constructor(compare) {\n    this.compare = compare;\n  }\n  add(data, item) {\n    return data ? Array.isArray(data) ? addSorted(this.compare, data, item) : joinRepeatable(this.compare, data, item) : item;\n  }\n  union(a, b) {\n    if (a) {\n      if (Array.isArray(a)) {\n        if (b) {\n          if (Array.isArray(b)) {\n            return unionSortedRepeatable(this.compare, a, b);\n          } else {\n            return addSorted(this.compare, a, b);\n          }\n        }\n        return a;\n      }\n      if (b) {\n        if (Array.isArray(b)) {\n          return addSorted(this.compare, [...b], a);\n        }\n        return joinRepeatable(this.compare, b, a);\n      }\n      return a;\n    }\n    return b;\n  }\n  find(data, item) {\n    if (data) {\n      if (Array.isArray(data)) {\n        return findSorted(this.compare, data, item);\n      } else if (this.compare(data, item) === 0) {\n        return data;\n      }\n    }\n  }\n};\nfunction push(data, item) {\n  if (data) {\n    if (Array.isArray(data)) {\n      data.push(item);\n      return data;\n    }\n    return [data, item];\n  }\n  return item;\n}\nfunction size(data) {\n  return data ? Array.isArray(data) ? data.length : 1 : 0;\n}\nfunction filter(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      const len = data.length;\n      let result;\n      let i = 0;\n      while (i < len) {\n        let item = data[i++];\n        if (cb(item)) {\n          result = item;\n          while (i < len) {\n            item = data[i++];\n            if (cb(item)) {\n              result = [result, item];\n              while (i < len) {\n                item = data[i++];\n                if (cb(item)) {\n                  result.push(item);\n                }\n              }\n              return result;\n            }\n          }\n          return result;\n        }\n      }\n      return result;\n    }\n    if (cb(data)) {\n      return data;\n    }\n  }\n  return void 0;\n}\nfunction forEach(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      let i = 0;\n      for (const item of data) {\n        cb(item, i++);\n      }\n    } else {\n      cb(data, 0);\n    }\n  }\n}\nfunction find(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      return data.find(cb);\n    }\n    if (cb(data, 0)) {\n      return data;\n    }\n  }\n}\nfunction map(data, cb) {\n  return data ? Array.isArray(data) ? data.map(cb) : [cb(data, 0)] : [];\n}\nfunction findSorted(compare, data, item) {\n  let max = data.length;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const cur = data[mid];\n    const compareResult = compare(cur, item);\n    if (compareResult === 0) return cur;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n}\nfunction addSorted(compare, data, item) {\n  const len = data.length;\n  let max = len;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(data[mid], item);\n    if (compareResult === 0) return data;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n  const result = new Array(len + 1);\n  for (let i = 0; i < pos; i++) {\n    result[i] = data[i];\n  }\n  let cur = item;\n  while (pos < len) {\n    const next = cur;\n    cur = data[pos];\n    result[pos++] = next;\n  }\n  result[len] = cur;\n  return result;\n}\nfunction unionSortedRepeatable(compare, a, b) {\n  const aLen = a.length;\n  const bLen = b.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  const result = [];\n  while (aIndex < aLen && bIndex < bLen) {\n    const aValue = a[aIndex];\n    const bValue = b[bIndex];\n    const delta = compare(aValue, bValue);\n    if (delta === 0) {\n      aIndex++;\n      bIndex++;\n      result.push(aValue);\n    } else if (delta < 0) {\n      aIndex++;\n      result.push(aValue);\n    } else {\n      bIndex++;\n      result.push(bValue);\n    }\n  }\n  if (aLen === bLen && aIndex === aLen) {\n    return a;\n  }\n  while (aIndex < aLen) {\n    result.push(a[aIndex++]);\n  }\n  while (bIndex < bLen) {\n    result.push(b[bIndex++]);\n  }\n  return result;\n}\nfunction joinRepeatable(compare, a, b) {\n  const compareResult = compare(a, b);\n  return compareResult === 0 ? a : compareResult < 0 ? [a, b] : [b, a];\n}\n\n// src/util/sections.ts\nvar import_babel_utils6 = require(\"@marko/babel-utils\");\nvar import_compiler5 = require(\"@marko/compiler\");\n\n// src/util/state.ts\nvar createProgramState = (init) => {\n  const map2 = /* @__PURE__ */ new WeakMap();\n  return [\n    () => {\n      let state = map2.get(currentProgramPath);\n      if (!state) {\n        map2.set(currentProgramPath, state = init());\n      }\n      return state;\n    },\n    (value) => {\n      map2.set(currentProgramPath, value);\n    }\n  ];\n};\nfunction createSectionState(key, init) {\n  return [\n    (section) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      const sectionData = arrayOfSectionData[section.id] ??= init && init(section);\n      return sectionData;\n    },\n    (section, value) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      arrayOfSectionData[section.id] = value;\n    }\n  ];\n}\n\n// src/util/tag-name-type.ts\nvar import_babel_utils5 = require(\"@marko/babel-utils\");\nvar import_compiler4 = require(\"@marko/compiler\");\n\n// src/util/with-previous-location.ts\nfunction withPreviousLocation(newNode, originalNode) {\n  newNode.start = originalNode.start;\n  newNode.loc = originalNode.loc;\n  newNode.end = originalNode.end;\n  return newNode;\n}\n\n// src/util/tag-name-type.ts\nvar MARKO_FILE_REG = /^<.*>$|\\.marko$/;\nvar TAG_NAME_IDENTIFIER_REG = /^[A-Z][a-zA-Z0-9_$]*$/;\nfunction analyzeTagNameType(tag) {\n  const extra = tag.node.extra ??= {};\n  if (extra.tagNameType === void 0) {\n    const name = tag.get(\"name\");\n    if (name.isStringLiteral()) {\n      extra.tagNameType = name.node.value[0] === \"@\" ? 3 /* AttributeTag */ : (0, import_babel_utils5.isNativeTag)(tag) ? 0 /* NativeTag */ : 1 /* CustomTag */;\n      if (extra.tagNameType === 1 /* CustomTag */) {\n        const bindingName = name.node.value;\n        const bindingIdentifier = tag.scope.getBinding(bindingName)?.identifier;\n        if (bindingIdentifier && TAG_NAME_IDENTIFIER_REG.test(bindingIdentifier.name)) {\n          const tagIdentifier = withPreviousLocation(\n            import_compiler4.types.identifier(bindingName),\n            name.node\n          );\n          tagIdentifier.extra = {\n            referencedBindings: bindingIdentifier.extra?.binding\n          };\n          analyzeExpressionTagName(name.replaceWith(tagIdentifier)[0], extra);\n        }\n      }\n      extra.tagNameNullable = extra.tagNameNullable = false;\n    } else {\n      analyzeExpressionTagName(name, extra);\n    }\n    if (extra.tagNameType === void 0) {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n    if (extra.tagNameType === 1 /* CustomTag */) {\n      const childFile = (0, import_babel_utils5.loadFileForTag)(tag);\n      if (!childFile) {\n        extra.tagNameType = 2 /* DynamicTag */;\n      } else if (childFile.ast.program.extra.featureType === \"class\") {\n        extra.tagNameType = 2 /* DynamicTag */;\n        extra.featureType = \"class\";\n      }\n    }\n  }\n  return extra.tagNameType;\n}\nfunction analyzeExpressionTagName(name, extra) {\n  const pending = [name];\n  let path4;\n  let type;\n  let nullable = false;\n  let tagNameImported;\n  while ((path4 = pending.pop()) && type !== 2 /* DynamicTag */) {\n    if (path4.isConditionalExpression()) {\n      pending.push(path4.get(\"consequent\"));\n      if (path4.node.alternate) {\n        pending.push(path4.get(\"alternate\"));\n      }\n    } else if (path4.isLogicalExpression()) {\n      if (path4.node.operator === \"||\") {\n        pending.push(path4.get(\"left\"));\n      } else {\n        nullable = true;\n      }\n      pending.push(path4.get(\"right\"));\n    } else if (path4.isAssignmentExpression()) {\n      pending.push(path4.get(\"right\"));\n    } else if (path4.isBinaryExpression()) {\n      type = path4.node.operator !== \"+\" || type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path4.isStringLiteral() || path4.isTemplateLiteral()) {\n      type = type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path4.isNullLiteral()) {\n      nullable = true;\n    } else if (path4.isIdentifier()) {\n      if (path4.node.name === \"undefined\") {\n        nullable = true;\n        continue;\n      }\n      const binding = path4.scope.getBinding(path4.node.name);\n      if (!binding) {\n        type = 2 /* DynamicTag */;\n        continue;\n      }\n      if (binding.kind === \"module\") {\n        const decl = binding.path.parent;\n        if (MARKO_FILE_REG.test(decl.source.value) && decl.specifiers.some((it) => import_compiler4.types.isImportDefaultSpecifier(it))) {\n          const resolvedImport = (0, import_babel_utils5.resolveTagImport)(name, decl.source.value) || decl.source.value;\n          if (type === 0 /* NativeTag */ || tagNameImported && tagNameImported !== resolvedImport) {\n            type = 2 /* DynamicTag */;\n            tagNameImported = void 0;\n          } else {\n            type = 1 /* CustomTag */;\n            tagNameImported = resolvedImport;\n          }\n        } else {\n          type = 2 /* DynamicTag */;\n        }\n        continue;\n      }\n      const bindingTag = binding.path;\n      if (bindingTag.isMarkoTag() && binding.kind === \"local\") {\n        const bindingTagName = bindingTag.get(\"name\").node.value;\n        if (bindingTagName === \"const\") {\n          pending.push(\n            bindingTag.get(\"attributes\")[0].get(\"value\")\n          );\n          continue;\n        }\n        if (bindingTagName === \"let\") {\n          type = 2 /* DynamicTag */;\n          continue;\n        }\n        continue;\n      }\n      type = 2 /* DynamicTag */;\n    } else {\n      type = 2 /* DynamicTag */;\n    }\n  }\n  extra.tagNameType = type;\n  extra.tagNameNullable = nullable;\n  extra.tagNameDynamic = true;\n  if (type === 1 /* CustomTag */ && tagNameImported) {\n    extra.tagNameImported = tagNameImported;\n  }\n}\n\n// src/util/sections.ts\nfunction startSection(path4) {\n  const extra = path4.node.extra ??= {};\n  let section = extra.section;\n  if (!section && (path4.type === \"Program\" || path4.get(\"body\").length)) {\n    const parentSection = path4.parentPath ? getOrCreateSection(path4.parentPath) : void 0;\n    const sectionNamePath = path4.parentPath?.get(\n      \"name\"\n    );\n    const sectionName = path4.isProgram() ? \"\" : currentProgramPath.scope.generateUid(\n      sectionNamePath.toString() + \"Body\"\n    );\n    const programExtra = path4.hub.file.path.node.extra ??= {};\n    const sections = programExtra.sections ??= [];\n    section = extra.section = {\n      id: sections.length,\n      name: sectionName,\n      depth: parentSection ? parentSection.depth + 1 : 0,\n      parent: parentSection,\n      params: void 0,\n      closures: void 0,\n      bindings: void 0,\n      content: getContentInfo(path4),\n      upstreamExpression: void 0,\n      hasCleanup: false\n    };\n    sections.push(section);\n  }\n  return section;\n}\nfunction getOrCreateSection(path4) {\n  let cur = path4;\n  while (true) {\n    if (cur.type === \"Program\" || cur.type === \"MarkoTagBody\" && !cur.node.attributeTags && analyzeTagNameType(cur.parentPath) !== 0 /* NativeTag */ && cur.parent.name.value !== \"html-comment\") {\n      return startSection(cur);\n    }\n    cur = cur.parentPath;\n  }\n}\nfunction getSectionForBody(body) {\n  return body.node.extra?.section;\n}\nfunction getSection(path4) {\n  let section;\n  let currentPath = path4;\n  while ((section = currentPath.node.extra?.section) === void 0) {\n    currentPath = currentPath.parentPath;\n  }\n  return section;\n}\nvar [getScopeIdIdentifier] = createSectionState(\n  \"scopeIdIdentifier\",\n  (section) => currentProgramPath.scope.generateUidIdentifier(`scope${section.id}_id`)\n);\nvar [getSectionParentIsOwner, setSectionParentIsOwner] = createSectionState(\"parentIsOwner\", () => false);\nvar [_getScopeIdentifier] = createSectionState(\n  \"scopeIdentifier\",\n  () => import_compiler5.types.identifier(\"undefined\")\n);\nvar getScopeIdentifier = (section, ignoreDefault) => {\n  const scopeId = _getScopeIdentifier(section);\n  if (!ignoreDefault && scopeId.name === \"undefined\") {\n    scopeId.name = currentProgramPath.scope.generateUid(`scope${section.id}_`);\n  }\n  return scopeId;\n};\nfunction forEachSection(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  sections?.forEach(fn);\n}\nfunction forEachSectionReverse(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  for (let i = sections.length; i--; ) {\n    fn(sections[i]);\n  }\n}\nfunction getContentInfo(path4) {\n  const body = path4.get(\"body\");\n  const contentInfo = {\n    startType: null,\n    endType: null,\n    singleChild: true\n  };\n  for (let endIndex = body.length; endIndex--; ) {\n    const endType = getNodeContentType(body[endIndex], \"endType\", contentInfo);\n    if (endType !== null) {\n      contentInfo.endType = endType;\n      for (let startIndex = 0; startIndex < endIndex; startIndex++) {\n        const startType = getNodeContentType(body[startIndex], \"startType\");\n        if (startType !== null) {\n          contentInfo.startType = startType;\n          contentInfo.singleChild = false;\n          return contentInfo;\n        }\n      }\n      contentInfo.startType = getNodeContentType(body[endIndex], \"startType\");\n      return contentInfo;\n    }\n  }\n  return null;\n}\nfunction getNodeContentType(path4, extraMember, contentInfo) {\n  if (import_compiler5.types.isMarkoText(path4)) {\n    return 4 /* Text */;\n  }\n  if (import_compiler5.types.isMarkoPlaceholder(path4)) {\n    return 2 /* Placeholder */;\n  }\n  if (import_compiler5.types.isMarkoScriptlet(path4) || import_compiler5.types.isMarkoComment(path4)) {\n    return null;\n  }\n  if (import_compiler5.types.isMarkoTag(path4.node)) {\n    const tag = path4;\n    if ((0, import_babel_utils6.isNativeTag)(tag)) {\n      return 3 /* Tag */;\n    }\n    if ((0, import_babel_utils6.isAttributeTag)(tag)) {\n      return null;\n    }\n    if (import_compiler5.types.isStringLiteral(path4.node.name)) {\n      switch (path4.node.name.value) {\n        case \"html-comment\":\n          return 0 /* Comment */;\n        case \"let\":\n        case \"const\":\n        case \"attrs\":\n        case \"effect\":\n        case \"lifecycle\":\n        case \"return\":\n        case \"id\":\n        case \"define\":\n          return null;\n      }\n      const tagSection = (0, import_babel_utils6.loadFileForTag)(tag)?.ast.program.extra.section;\n      if (tagSection) {\n        if (tagSection.content) {\n          if (contentInfo && !tagSection.content.singleChild) {\n            if (extraMember === \"endType\") {\n              contentInfo.startType = tagSection.content.startType;\n              contentInfo.singleChild = false;\n            }\n          }\n          return tagSection.content[extraMember];\n        } else {\n          return null;\n        }\n      }\n    }\n  }\n  return 1 /* Dynamic */;\n}\nvar isStatefulSection = (section) => {\n  const upstreamExpression = section.upstreamExpression;\n  return !upstreamExpression || isStatefulReferences(upstreamExpression.referencedBindings);\n};\nvar checkStatefulClosures = (section, immediateOnly) => {\n  return !!find(\n    section.closures,\n    (closure) => (!immediateOnly || section.parent === closure.section) && isStatefulReferences(closure)\n  );\n};\n\n// src/util/references.ts\nvar [getBindings] = createProgramState(() => /* @__PURE__ */ new Set());\nvar [getNextBindingId, setNextBindingId] = createProgramState(() => 0);\nfunction createBinding(name, type, section, upstreamAlias, upstreamExpression, property) {\n  const id = getNextBindingId();\n  const binding = {\n    id,\n    name,\n    type,\n    section,\n    property,\n    excludeProperties: void 0,\n    serialize: false,\n    aliases: /* @__PURE__ */ new Set(),\n    propertyAliases: /* @__PURE__ */ new Map(),\n    upstreamAlias,\n    upstreamExpression,\n    downstreamExpressions: /* @__PURE__ */ new Set(),\n    export: void 0\n  };\n  if (property) {\n    const propBinding = upstreamAlias.propertyAliases.get(property);\n    if (propBinding) {\n      binding.property = void 0;\n      binding.upstreamAlias = propBinding;\n      propBinding.aliases.add(binding);\n    } else {\n      upstreamAlias.propertyAliases.set(property, binding);\n    }\n  } else if (upstreamAlias) {\n    upstreamAlias.aliases.add(binding);\n  }\n  setNextBindingId(id + 1);\n  getBindings().add(binding);\n  return binding;\n}\nfunction trackVarReferences(tag, type, upstreamAlias, upstreamExpression, changeBinding) {\n  const tagVar = tag.node.var;\n  if (tagVar) {\n    const section = getOrCreateSection(tag);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    upstreamAlias?.downstreamExpressions.delete(upstreamExpression);\n    createBindingsAndTrackReferences(\n      tagVar,\n      type,\n      tag.scope,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0,\n      changeBinding\n    );\n  }\n}\nfunction trackParamsReferences(body, type, upstreamAlias, upstreamExpression) {\n  const params = body.node.params;\n  if (body.node.body.length && params.length) {\n    upstreamAlias?.downstreamExpressions.delete(upstreamExpression);\n    const section = getOrCreateSection(body);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    const paramsBinding = canonicalUpstreamAlias || ((body.node.extra ??= {}).binding = createBinding(\n      body.scope.generateUid(\"params_\"),\n      type,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0\n    ));\n    section.params = paramsBinding;\n    for (let i = 0; i < params.length; i++) {\n      createBindingsAndTrackReferences(\n        params[i],\n        type,\n        body.scope,\n        section,\n        paramsBinding,\n        void 0,\n        i + \"\"\n      );\n    }\n  }\n}\nfunction trackReferencesForBinding(babelBinding, changeBinding) {\n  const { identifier, referencePaths, constantViolations } = babelBinding;\n  const binding = identifier.extra.binding;\n  for (const referencePath of referencePaths) {\n    trackReference(referencePath, binding);\n  }\n  for (const referencePath of constantViolations) {\n    const node = referencePath.node;\n    if (import_compiler6.types.isAssignmentExpression(node)) {\n      assignBinding(node.left, binding);\n    }\n    if (import_compiler6.types.isUpdateExpression(node)) {\n      assignBinding(node.argument, binding);\n    }\n    if (import_compiler6.types.isAssignmentExpression(node) && import_compiler6.types.isIdentifier(node.left) && node.operator !== \"=\") {\n      trackReference(\n        referencePath.get(\n          \"left\"\n        ),\n        binding\n      );\n    }\n    if (changeBinding) {\n      if (referencePath.isUpdateExpression()) {\n        trackReference(\n          referencePath.get(\"argument\"),\n          changeBinding\n        );\n      } else if (referencePath.isAssignmentExpression()) {\n        trackReference(\n          referencePath.get(\"left\"),\n          changeBinding\n        );\n      }\n    }\n  }\n}\nfunction assignBinding(node, binding) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        assignBinding(prop, binding);\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const element of node.elements) {\n        if (element !== null) {\n          assignBinding(element, binding);\n        }\n      }\n      break;\n    case \"RestElement\":\n      assignBinding(node.argument, binding);\n      break;\n    case \"ObjectProperty\":\n      assignBinding(node.value, binding);\n      break;\n    case \"Identifier\":\n      if (node.name === binding.name) {\n        (node.extra ??= {}).source = binding;\n      }\n      break;\n  }\n}\nfunction createBindingsAndTrackReferences(lVal, type, scope, section, upstreamAlias, upstreamExpression, property, changeBinding) {\n  switch (lVal.type) {\n    case \"Identifier\":\n      (lVal.extra ??= {}).binding = createBinding(\n        lVal.name,\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      );\n      trackReferencesForBinding(scope.getBinding(lVal.name), changeBinding);\n      break;\n    case \"ObjectPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        scope.generateUid(\"pattern_\"),\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      ));\n      for (const prop of lVal.properties) {\n        if (prop.type === \"RestElement\") {\n          createBindingsAndTrackReferences(\n            prop.argument,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            property\n          );\n        } else {\n          let key;\n          if (prop.key.type === \"Identifier\") {\n            key = prop.key.name;\n          } else if (prop.key.type === \"StringLiteral\") {\n            key = prop.key.value;\n          } else {\n            throw new Error(\"computed keys not supported in object pattern\");\n          }\n          createBindingsAndTrackReferences(\n            prop.value,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            key\n          );\n        }\n      }\n      break;\n    }\n    case \"ArrayPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        scope.generateUid(\"pattern_\"),\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      ));\n      let i = -1;\n      for (const element of lVal.elements) {\n        i++;\n        if (element) {\n          if (element.type === \"RestElement\") {\n            createBindingsAndTrackReferences(\n              element.argument,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              property\n            );\n          } else {\n            createBindingsAndTrackReferences(\n              element,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              `${i}`\n            );\n          }\n        }\n      }\n      break;\n    }\n    case \"AssignmentPattern\":\n      createBindingsAndTrackReferences(\n        lVal.left,\n        type,\n        scope,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      );\n      break;\n  }\n}\nfunction trackReference(referencePath, binding) {\n  const fnRoot = getFnRoot(referencePath.scope.path);\n  const exprRoot = getExprRoot(fnRoot || referencePath);\n  const section = getOrCreateSection(exprRoot);\n  const reference = binding;\n  const exprExtra = exprRoot.node.extra ??= {};\n  addReferenceToExpression(exprRoot, binding);\n  assignBinding(referencePath.node, binding);\n  if (fnRoot) {\n    let fnExtra = exprExtra;\n    if (fnRoot !== exprRoot) {\n      fnExtra = fnRoot.node.extra ??= {};\n      fnExtra.referencedBindings = addReference(\n        section,\n        fnExtra.referencedBindings,\n        reference\n      );\n    }\n  }\n}\nvar [getMergedReferences] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction mergeReferences(section, target, nodes) {\n  getMergedReferences().set(target, { section, nodes });\n}\nfunction compareIntersections(a, b) {\n  const len = a.length;\n  const lenDelta = len - b.length;\n  if (lenDelta !== 0) {\n    return lenDelta;\n  }\n  for (let i = 0; i < len; i++) {\n    const compareResult = bindingUtil.compare(a[i], b[i]);\n    if (compareResult !== 0) {\n      return compareResult;\n    }\n  }\n  return 0;\n}\nfunction finalizeReferences() {\n  const droppedReferences = getDroppedReferences();\n  if (droppedReferences.size) {\n    for (const expr of droppedReferences) {\n      const { extra } = expr;\n      if (extra && extra.referencedBindings) {\n        forEach(extra.referencedBindings, ({ downstreamExpressions }) => {\n          downstreamExpressions.delete(extra);\n        });\n        extra.referencedBindings = void 0;\n      }\n    }\n    droppedReferences.clear();\n  }\n  const mergedReferences = getMergedReferences();\n  if (mergedReferences.size) {\n    for (const [target, { section, nodes }] of mergedReferences) {\n      const targetExtra = target.extra ??= {};\n      let { referencedBindings, isEffect } = targetExtra;\n      for (const node of nodes) {\n        const extra = node?.extra;\n        if (extra) {\n          const additionalBindings = extra.referencedBindings;\n          isEffect ||= extra.isEffect;\n          if (additionalBindings) {\n            referencedBindings = bindingUtil.union(\n              referencedBindings,\n              additionalBindings\n            );\n            forEach(additionalBindings, ({ downstreamExpressions }) => {\n              downstreamExpressions.delete(extra);\n              downstreamExpressions.add(targetExtra);\n            });\n          }\n        }\n      }\n      referencedBindings = findReferences(section, referencedBindings);\n      targetExtra.referencedBindings = referencedBindings;\n      targetExtra.isEffect = isEffect;\n    }\n    mergedReferences.clear();\n  }\n  const bindings = getBindings();\n  for (const binding of bindings) {\n    if (binding.type !== 0 /* dom */ && !binding.upstreamAlias) {\n      if (pruneBinding(bindings, binding)) {\n        const { upstreamExpression } = binding;\n        if (upstreamExpression) {\n          forEach(\n            upstreamExpression.referencedBindings,\n            (referencedBinding) => {\n              referencedBinding.downstreamExpressions.delete(\n                upstreamExpression\n              );\n              pruneBinding(bindings, referencedBinding);\n            }\n          );\n        }\n      }\n    }\n  }\n  const intersections = /* @__PURE__ */ new Set();\n  for (const binding of bindings) {\n    const { name, section } = binding;\n    if (binding.type !== 0 /* dom */) {\n      if (find(section.bindings, ({ name: name2 }) => name2 === binding.name)) {\n        binding.name = currentProgramPath.scope.generateUid(name);\n      }\n    }\n    section.bindings = bindingUtil.add(section.bindings, binding);\n    for (const {\n      referencedBindings,\n      isEffect\n    } of binding.downstreamExpressions) {\n      if (Array.isArray(referencedBindings)) {\n        intersections.add(referencedBindings);\n      }\n      forEach(referencedBindings, (bindingReference) => {\n        if (isEffect) {\n          bindingReference.serialize = true;\n        }\n      });\n    }\n  }\n  for (const intersection of intersections) {\n    const numReferences = intersection.length;\n    for (let i = 0; i < numReferences - 1; i++) {\n      for (let j = i + 1; j < numReferences; j++) {\n        const binding1 = intersection[i];\n        const binding2 = intersection[j];\n        const sources1 = getSourceBindings(binding1);\n        const sources2 = getSourceBindings(binding2);\n        if (!binding1.serialize && !isSuperset(sources1, sources2)) {\n          binding1.serialize = true;\n        }\n        if (!binding2.serialize && !isSuperset(sources2, sources1)) {\n          binding2.serialize = true;\n        }\n      }\n    }\n  }\n  forEachSection((section) => {\n    forEach(section.closures, (binding) => {\n      if (!binding.serialize) {\n        let serialize = false;\n        const sourceSection = binding.section;\n        let currentSection = section;\n        while (currentSection !== sourceSection && !(serialize = !currentSection.upstreamExpression || isStatefulReferences(\n          currentSection.upstreamExpression.referencedBindings\n        ))) {\n          currentSection = currentSection.parent;\n        }\n        binding.serialize = serialize;\n      }\n    });\n  });\n  forEachSection(({ id, bindings: bindings2 }) => {\n    forEach(\n      filter(bindings2, ({ section }) => section.id === id),\n      (binding, i) => {\n        binding.id = i;\n      }\n    );\n  });\n}\nfunction isSuperset(set, subset) {\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getSourceBindings(binding) {\n  const derived = /* @__PURE__ */ new Set();\n  const sources = /* @__PURE__ */ new Set();\n  crawl(binding);\n  return sources;\n  function crawl(binding2) {\n    if (binding2.type === 4 /* derived */ || binding2.type === 3 /* param */) {\n      let alias;\n      let curBinding = binding2;\n      while (alias = curBinding.upstreamAlias) {\n        curBinding = alias;\n      }\n      if (curBinding.upstreamExpression) {\n        if (derived.has(curBinding)) return;\n        derived.add(curBinding);\n        forEach(curBinding.upstreamExpression.referencedBindings, crawl);\n      } else {\n        sources.add(curBinding);\n      }\n    } else {\n      sources.add(binding2);\n    }\n  }\n}\nvar bindingUtil = new Sorted(function compareBindings(a, b) {\n  return a.section.id - b.section.id || a.type !== b.type && (a.type === 0 /* dom */ || b.type === 0 /* dom */) ? a.type - b.type || a.id - b.id : a.id - b.id;\n});\nvar [getIntersections, setIntersections] = createSectionState(\n  \"intersections\",\n  () => []\n);\nfunction addReferenceToExpression(path4, binding) {\n  const exprExtra = path4.node.extra ??= {};\n  const section = getOrCreateSection(path4);\n  exprExtra.referencedBindings = addReference(\n    section,\n    exprExtra.referencedBindings,\n    binding\n  );\n  binding.downstreamExpressions.add(exprExtra);\n}\nvar [getDroppedReferences] = createProgramState(() => /* @__PURE__ */ new Set());\nfunction dropReferences(node) {\n  const droppedReferences = getDroppedReferences();\n  if (Array.isArray(node)) {\n    for (const item of node) {\n      droppedReferences.add(item);\n    }\n  } else {\n    droppedReferences.add(node);\n  }\n}\nfunction getCanonicalBinding(binding) {\n  return binding && (binding.property ? binding : binding.upstreamAlias || binding);\n}\nfunction getAllTagReferenceNodes(tag, referenceNodes = []) {\n  if (tag.arguments) {\n    for (const arg of tag.arguments) {\n      referenceNodes.push(arg);\n    }\n  }\n  for (const attr2 of tag.attributes) {\n    referenceNodes.push(attr2.value);\n  }\n  for (const child of tag.body.attributeTags ? tag.body.body : tag.attributeTags) {\n    switch (child.type) {\n      case \"MarkoTag\":\n        getAllTagReferenceNodes(child, referenceNodes);\n        break;\n      case \"MarkoScriptlet\":\n        for (const statement of child.body) {\n          referenceNodes.push(statement);\n        }\n        break;\n    }\n  }\n  return referenceNodes;\n}\nfunction addReference(section, referencedBindings, binding) {\n  if (section !== binding.section) {\n    section.closures = bindingUtil.add(section.closures, binding);\n  }\n  const newIntersection = bindingUtil.add(referencedBindings, binding);\n  return findReferences(section, newIntersection);\n}\nfunction findReferences(section, referencedBindings) {\n  if (!referencedBindings || !Array.isArray(referencedBindings)) {\n    return referencedBindings;\n  }\n  const intersections = getIntersections(section);\n  let intersection = findSorted(\n    compareIntersections,\n    intersections,\n    referencedBindings\n  );\n  if (!intersection) {\n    setIntersections(\n      section,\n      addSorted(compareIntersections, intersections, referencedBindings)\n    );\n    intersection = referencedBindings;\n  }\n  return intersection;\n}\nfunction getScopeAccessorLiteral(binding) {\n  if (isOptimize()) {\n    return import_compiler6.types.numericLiteral(binding.id);\n  }\n  return import_compiler6.types.stringLiteral(\n    binding.name + (binding.type === 0 /* dom */ ? `/${binding.id}` : \"\")\n  );\n}\nfunction pruneBinding(bindings, binding) {\n  let shouldPrune = !binding.downstreamExpressions.size;\n  for (const alias of binding.aliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.aliases.delete(alias);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  for (const [key, alias] of binding.propertyAliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.propertyAliases.delete(key);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  if (shouldPrune) {\n    bindings.delete(binding);\n  }\n  return shouldPrune;\n}\n\n// src/visitors/program/dom.ts\nvar import_compiler15 = require(\"@marko/compiler\");\n\n// src/util/runtime.ts\nvar import_babel_utils7 = require(\"@marko/babel-utils\");\nvar import_compiler7 = require(\"@marko/compiler\");\n\n// ../runtime-tags/src/common/attr-tag.ts\nvar rest = false ? Symbol(\"Attribute Tag\") : Symbol();\n\n// ../runtime-tags/src/common/helpers.ts\nfunction classValue(value) {\n  return toDelimitedString(value, \" \", stringifyClassObject);\n}\nfunction stringifyClassObject(name, value) {\n  return value ? name : \"\";\n}\nfunction styleValue(value) {\n  return toDelimitedString(value, \";\", stringifyStyleObject);\n}\nvar NON_DIMENSIONAL = /^(--|ta|or|li|z)|n-c|i(do|nk|m|t)|w$|we/;\nfunction stringifyStyleObject(name, value) {\n  return value || value === 0 ? `${name}:${typeof value === \"number\" && value && !NON_DIMENSIONAL.test(name) ? value + \"px\" : value}` : \"\";\n}\nfunction toDelimitedString(val, delimiter, stringify) {\n  switch (typeof val) {\n    case \"string\":\n      return val;\n    case \"object\":\n      if (val !== null) {\n        let result = \"\";\n        let curDelimiter = \"\";\n        if (Array.isArray(val)) {\n          for (const v of val) {\n            const part = toDelimitedString(v, delimiter, stringify);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        } else {\n          for (const name in val) {\n            const v = val[name];\n            const part = stringify(name, v);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        }\n        return result;\n      }\n  }\n  return \"\";\n}\nfunction isEventHandler(name) {\n  return /^on[A-Z-]/.test(name);\n}\nfunction getEventHandlerName(name) {\n  return name[2] === \"-\" ? name.slice(3) : name.slice(2).toLowerCase();\n}\nfunction isVoid(value) {\n  return value == null || value === false;\n}\n\n// ../runtime-tags/src/html/content.ts\nfunction toString(val) {\n  return val ? val + \"\" : val === 0 ? \"0\" : \"\";\n}\nvar unsafeXMLReg = /[<&]/g;\nvar replaceUnsafeXML = (c) => c === \"&\" ? \"&amp;\" : \"&lt;\";\nvar escapeXMLStr = (str) => unsafeXMLReg.test(str) ? str.replace(unsafeXMLReg, replaceUnsafeXML) : str;\nfunction escapeXML(val) {\n  return val ? escapeXMLStr(val + \"\") : val === 0 ? \"0\" : \"&zwj;\";\n}\nvar unsafeScriptReg = /<\\/script/g;\nvar escapeScriptStr = (str) => unsafeScriptReg.test(str) ? str.replace(unsafeScriptReg, \"\\\\x3C/script\") : str;\nfunction escapeScript(val) {\n  return val ? escapeScriptStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\nvar unsafeStyleReg = /<\\/style/g;\nvar escapeStyleStr = (str) => unsafeStyleReg.test(str) ? str.replace(unsafeStyleReg, \"\\\\3C/style\") : str;\nfunction escapeStyle(val) {\n  return val ? escapeStyleStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\n\n// ../runtime-tags/src/html/serializer.ts\nvar { hasOwnProperty } = {};\nvar Generator = function* () {\n}().constructor;\nvar AsyncGenerator = async function* () {\n}().constructor;\nvar KNOWN_SYMBOLS = (() => {\n  const KNOWN_SYMBOLS2 = /* @__PURE__ */ new Map();\n  for (const name of Object.getOwnPropertyNames(Symbol)) {\n    const symbol = Symbol[name];\n    if (typeof symbol === \"symbol\") {\n      KNOWN_SYMBOLS2.set(symbol, \"Symbol.\" + name);\n    }\n  }\n  return KNOWN_SYMBOLS2;\n})();\nvar KNOWN_FUNCTIONS = /* @__PURE__ */ new Map([\n  // This is by no means an exhaustive list,\n  // but it should cover most of the built-in functions.\n  [AggregateError, \"AggregateError\"],\n  [Array, \"Array\"],\n  [Array.from, \"Array.from\"],\n  [Array.isArray, \"Array.isArray\"],\n  [Array.of, \"Array.of\"],\n  [ArrayBuffer, \"ArrayBuffer\"],\n  [ArrayBuffer.isView, \"ArrayBuffer.isView\"],\n  [Atomics.add, \"Atomics.add\"],\n  [Atomics.and, \"Atomics.and\"],\n  [Atomics.compareExchange, \"Atomics.compareExchange\"],\n  [Atomics.exchange, \"Atomics.exchange\"],\n  [Atomics.isLockFree, \"Atomics.isLockFree\"],\n  [Atomics.load, \"Atomics.load\"],\n  [Atomics.notify, \"Atomics.notify\"],\n  [Atomics.or, \"Atomics.or\"],\n  [Atomics.store, \"Atomics.store\"],\n  [Atomics.sub, \"Atomics.sub\"],\n  [Atomics.wait, \"Atomics.wait\"],\n  [BigInt, \"BigInt\"],\n  [BigInt.asIntN, \"BigInt.asIntN\"],\n  [BigInt.asUintN, \"BigInt.asUintN\"],\n  [BigInt64Array, \"BigInt64Array\"],\n  [BigInt64Array.from, \"BigInt64Array.from\"],\n  [BigInt64Array.of, \"BigInt64Array.of\"],\n  [BigUint64Array, \"BigUint64Array\"],\n  [BigUint64Array.from, \"BigUint64Array.from\"],\n  [BigUint64Array.of, \"BigUint64Array.of\"],\n  [Boolean, \"Boolean\"],\n  [console.assert, \"console.assert\"],\n  [console.clear, \"console.clear\"],\n  [console.count, \"console.count\"],\n  [console.countReset, \"console.countReset\"],\n  [console.debug, \"console.debug\"],\n  [console.dir, \"console.dir\"],\n  [console.dirxml, \"console.dirxml\"],\n  [console.error, \"console.error\"],\n  [console.group, \"console.group\"],\n  [console.groupCollapsed, \"console.groupCollapsed\"],\n  [console.groupEnd, \"console.groupEnd\"],\n  [console.info, \"console.info\"],\n  [console.log, \"console.log\"],\n  [console.table, \"console.table\"],\n  [console.time, \"console.time\"],\n  [console.timeEnd, \"console.timeEnd\"],\n  [console.timeLog, \"console.timeLog\"],\n  [console.timeStamp, \"console.timeStamp\"],\n  [console.trace, \"console.trace\"],\n  [console.warn, \"console.warn\"],\n  [DataView, \"DataView\"],\n  [Date, \"Date\"],\n  [Date.now, \"Date.now\"],\n  [Date.parse, \"Date.parse\"],\n  [Date.UTC, \"Date.UTC\"],\n  [decodeURI, \"decodeURI\"],\n  [decodeURIComponent, \"decodeURIComponent\"],\n  [encodeURI, \"encodeURI\"],\n  [encodeURIComponent, \"encodeURIComponent\"],\n  [Error, \"Error\"],\n  [EvalError, \"EvalError\"],\n  [Float32Array, \"Float32Array\"],\n  [Float32Array.from, \"Float32Array.from\"],\n  [Float32Array.of, \"Float32Array.of\"],\n  [Float64Array, \"Float64Array\"],\n  [Float64Array.from, \"Float64Array.from\"],\n  [Float64Array.of, \"Float64Array.of\"],\n  [Function, \"Function\"],\n  [globalThis.atob, \"atob\"],\n  [globalThis.btoa, \"btoa\"],\n  [globalThis.clearImmediate, \"clearImmediate\"],\n  [globalThis.clearInterval, \"clearInterval\"],\n  [globalThis.clearTimeout, \"clearTimeout\"],\n  [globalThis.crypto?.getRandomValues, \"crypto.getRandomValues\"],\n  [globalThis.crypto?.randomUUID, \"crypto.randomUUID\"],\n  [globalThis.fetch, \"fetch\"],\n  [globalThis.performance?.now, \"performance.now\"],\n  [globalThis.queueMicrotask, \"queueMicrotask\"],\n  [globalThis.setImmediate, \"setImmediate\"],\n  [globalThis.setInterval, \"setInterval\"],\n  [globalThis.setTimeout, \"setTimeout\"],\n  [globalThis.structuredClone, \"structuredClone\"],\n  [globalThis.URL, \"URL\"],\n  [globalThis.URLSearchParams, \"URLSearchParams\"],\n  [globalThis.WritableStream, \"WritableStream\"],\n  [Int16Array, \"Int16Array\"],\n  [Int16Array.from, \"Int16Array.from\"],\n  [Int16Array.of, \"Int16Array.of\"],\n  [Int32Array, \"Int32Array\"],\n  [Int32Array.from, \"Int32Array.from\"],\n  [Int32Array.of, \"Int32Array.of\"],\n  [Int8Array, \"Int8Array\"],\n  [Int8Array.from, \"Int8Array.from\"],\n  [Int8Array.of, \"Int8Array.of\"],\n  [Intl.Collator, \"Intl.Collator\"],\n  [Intl.DateTimeFormat, \"Intl.DateTimeFormat\"],\n  [Intl.DisplayNames, \"Intl.DisplayNames\"],\n  [Intl.getCanonicalLocales, \"Intl.getCanonicalLocales\"],\n  [Intl.ListFormat, \"Intl.ListFormat\"],\n  [Intl.Locale, \"Intl.Locale\"],\n  [Intl.NumberFormat, \"Intl.NumberFormat\"],\n  [Intl.PluralRules, \"Intl.PluralRules\"],\n  [Intl.RelativeTimeFormat, \"Intl.RelativeTimeFormat\"],\n  [Intl.Segmenter, \"Intl.Segmenter\"],\n  [Intl.supportedValuesOf, \"Intl.supportedValuesOf\"],\n  [isFinite, \"isFinite\"],\n  [isNaN, \"isNaN\"],\n  [JSON.parse, \"JSON.parse\"],\n  [JSON.stringify, \"JSON.stringify\"],\n  [Map, \"Map\"],\n  [Map.groupBy, \"Map.groupBy\"],\n  [Math.abs, \"Math.abs\"],\n  [Math.acos, \"Math.acos\"],\n  [Math.acosh, \"Math.acosh\"],\n  [Math.asin, \"Math.asin\"],\n  [Math.asinh, \"Math.asinh\"],\n  [Math.atan, \"Math.atan\"],\n  [Math.atan2, \"Math.atan2\"],\n  [Math.atanh, \"Math.atanh\"],\n  [Math.cbrt, \"Math.cbrt\"],\n  [Math.ceil, \"Math.ceil\"],\n  [Math.clz32, \"Math.clz32\"],\n  [Math.cos, \"Math.cos\"],\n  [Math.cosh, \"Math.cosh\"],\n  [Math.exp, \"Math.exp\"],\n  [Math.expm1, \"Math.expm1\"],\n  [Math.floor, \"Math.floor\"],\n  [Math.fround, \"Math.fround\"],\n  [Math.hypot, \"Math.hypot\"],\n  [Math.imul, \"Math.imul\"],\n  [Math.log, \"Math.log\"],\n  [Math.log10, \"Math.log10\"],\n  [Math.log1p, \"Math.log1p\"],\n  [Math.log2, \"Math.log2\"],\n  [Math.max, \"Math.max\"],\n  [Math.min, \"Math.min\"],\n  [Math.pow, \"Math.pow\"],\n  [Math.random, \"Math.random\"],\n  [Math.round, \"Math.round\"],\n  [Math.sign, \"Math.sign\"],\n  [Math.sin, \"Math.sin\"],\n  [Math.sinh, \"Math.sinh\"],\n  [Math.sqrt, \"Math.sqrt\"],\n  [Math.tan, \"Math.tan\"],\n  [Math.tanh, \"Math.tanh\"],\n  [Math.trunc, \"Math.trunc\"],\n  [Number, \"Number\"],\n  [Number.isFinite, \"Number.isFinite\"],\n  [Number.isInteger, \"Number.isInteger\"],\n  [Number.isNaN, \"Number.isNaN\"],\n  [Number.isSafeInteger, \"Number.isSafeInteger\"],\n  [Number.parseFloat, \"Number.parseFloat\"],\n  [Number.parseInt, \"Number.parseInt\"],\n  [Object, \"Object\"],\n  [Object.assign, \"Object.assign\"],\n  [Object.create, \"Object.create\"],\n  [Object.defineProperties, \"Object.defineProperties\"],\n  [Object.defineProperty, \"Object.defineProperty\"],\n  [Object.entries, \"Object.entries\"],\n  [Object.freeze, \"Object.freeze\"],\n  [Object.fromEntries, \"Object.fromEntries\"],\n  [Object.getOwnPropertyDescriptor, \"Object.getOwnPropertyDescriptor\"],\n  [Object.getOwnPropertyDescriptors, \"Object.getOwnPropertyDescriptors\"],\n  [Object.getOwnPropertyNames, \"Object.getOwnPropertyNames\"],\n  [Object.getOwnPropertySymbols, \"Object.getOwnPropertySymbols\"],\n  [Object.getPrototypeOf, \"Object.getPrototypeOf\"],\n  [Object.is, \"Object.is\"],\n  [Object.isExtensible, \"Object.isExtensible\"],\n  [Object.isFrozen, \"Object.isFrozen\"],\n  [Object.isSealed, \"Object.isSealed\"],\n  [Object.keys, \"Object.keys\"],\n  [Object.preventExtensions, \"Object.preventExtensions\"],\n  [Object.seal, \"Object.seal\"],\n  [Object.setPrototypeOf, \"Object.setPrototypeOf\"],\n  [Object.values, \"Object.values\"],\n  [parseFloat, \"parseFloat\"],\n  [parseInt, \"parseInt\"],\n  [Promise, \"Promise\"],\n  [Proxy, \"Proxy\"],\n  [RangeError, \"RangeError\"],\n  [ReferenceError, \"ReferenceError\"],\n  [Reflect.apply, \"Reflect.apply\"],\n  [Reflect.construct, \"Reflect.construct\"],\n  [Reflect.defineProperty, \"Reflect.defineProperty\"],\n  [Reflect.deleteProperty, \"Reflect.deleteProperty\"],\n  [Reflect.get, \"Reflect.get\"],\n  [Reflect.getOwnPropertyDescriptor, \"Reflect.getOwnPropertyDescriptor\"],\n  [Reflect.getPrototypeOf, \"Reflect.getPrototypeOf\"],\n  [Reflect.has, \"Reflect.has\"],\n  [Reflect.isExtensible, \"Reflect.isExtensible\"],\n  [Reflect.ownKeys, \"Reflect.ownKeys\"],\n  [Reflect.preventExtensions, \"Reflect.preventExtensions\"],\n  [Reflect.set, \"Reflect.set\"],\n  [Reflect.setPrototypeOf, \"Reflect.setPrototypeOf\"],\n  [RegExp, \"RegExp\"],\n  [Set, \"Set\"],\n  [String, \"String\"],\n  [String.fromCharCode, \"String.fromCharCode\"],\n  [String.fromCodePoint, \"String.fromCodePoint\"],\n  [String.raw, \"String.raw\"],\n  [Symbol, \"Symbol\"],\n  [Symbol.for, \"Symbol.for\"],\n  [SyntaxError, \"SyntaxError\"],\n  [TypeError, \"TypeError\"],\n  [Uint16Array, \"Uint16Array\"],\n  [Uint16Array.from, \"Uint16Array.from\"],\n  [Uint16Array.of, \"Uint16Array.of\"],\n  [Uint32Array, \"Uint32Array\"],\n  [Uint32Array.from, \"Uint32Array.from\"],\n  [Uint32Array.of, \"Uint32Array.of\"],\n  [Uint8Array, \"Uint8Array\"],\n  [Uint8Array.from, \"Uint8Array.from\"],\n  [Uint8Array.of, \"Uint8Array.of\"],\n  [Uint8ClampedArray, \"Uint8ClampedArray\"],\n  [Uint8ClampedArray.from, \"Uint8ClampedArray.from\"],\n  [Uint8ClampedArray.of, \"Uint8ClampedArray.of\"],\n  [URIError, \"URIError\"],\n  [WeakMap, \"WeakMap\"],\n  [WeakSet, \"WeakSet\"]\n]);\nvar KNOWN_OBJECTS = /* @__PURE__ */ new Map([\n  [Atomics, \"Atomics\"],\n  [console, \"console\"],\n  [globalThis, \"globalThis\"],\n  [globalThis.crypto, \"crypto\"],\n  [Intl, \"Intl\"],\n  [JSON, \"JSON\"],\n  [Math, \"Math\"],\n  [Reflect, \"Reflect\"]\n]);\n\n// ../runtime-tags/src/html/writer.ts\nvar K_SCOPE_ID = Symbol(\"Scope ID\");\nvar kPendingContexts = Symbol(\"Pending Contexts\");\nvar tick = globalThis.setImmediate || globalThis.setTimeout || globalThis.queueMicrotask || ((cb) => Promise.resolve().then(cb));\n\n// ../runtime-tags/src/html/attrs.ts\nfunction classAttr(val) {\n  return stringAttr(\"class\", classValue(val));\n}\nfunction styleAttr(val) {\n  return stringAttr(\"style\", styleValue(val));\n}\nvar kSelectedValue = Symbol(\"selectedValue\");\nfunction attr(name, val) {\n  return isVoid(val) ? \"\" : nonVoidAttr(name, val);\n}\nfunction stringAttr(name, val) {\n  return val && ` ${name}=${escapeAttrValue(val)}`;\n}\nfunction nonVoidAttr(name, val) {\n  switch (typeof val) {\n    case \"string\":\n      return ` ${name + attrAssignment(val)}`;\n    case \"boolean\":\n      return ` ${name}`;\n    case \"number\":\n      return ` ${name}=${val}`;\n    case \"object\":\n      if (val instanceof RegExp) {\n        return ` ${name + attrAssignment(val.source)}`;\n      }\n      break;\n  }\n  return ` ${name + attrAssignment(val + \"\")}`;\n}\nfunction attrAssignment(val) {\n  return val ? `=${escapeAttrValue(val)}` : \"\";\n}\nvar unsafeAttrChars = /[\"'>\\s]/g;\nfunction escapeAttrValue(str) {\n  if (unsafeAttrChars.test(str)) {\n    const c = str[unsafeAttrChars.lastIndex - 1];\n    unsafeAttrChars.lastIndex = 0;\n    return c === '\"' ? `'${str.replace(/'/g, \"&#39;\")}'` : `\"${str.replace(/\"/g, \"&#34;\")}\"`;\n  }\n  return str;\n}\n\n// ../runtime-tags/src/common/compat-meta.ts\nvar prefix = false ? \"$compat_\" : \"$C_\";\nvar RENDERER_REGISTER_ID = prefix + (false ? \"renderer\" : \"r\");\nvar SET_SCOPE_REGISTER_ID = prefix + (false ? \"setScope\" : \"s\");\n\n// ../runtime-tags/src/html/compat.ts\nvar K_TAGS_API_STATE = Symbol();\n\n// src/util/runtime.ts\nvar pureFunctions = [\n  \"createTemplate\",\n  \"createRenderer\",\n  \"createRendererWithOwner\",\n  \"value\",\n  \"state\",\n  \"intersection\",\n  \"closure\",\n  \"dynamicClosure\",\n  \"loopOf\",\n  \"loopIn\",\n  \"loopTo\",\n  \"conditional\"\n];\nfunction importRuntime(name) {\n  const { output } = getMarkoOpts();\n  return import_compiler7.types.memberExpression(\n    (0, import_babel_utils7.importStar)(currentProgramPath.hub.file, getRuntimePath(output), \"$\"),\n    import_compiler7.types.identifier(name)\n  );\n}\nfunction callRuntime(name, ...args) {\n  const callExpression2 = import_compiler7.types.callExpression(\n    importRuntime(name),\n    filterArguments(args)\n  );\n  if (pureFunctions.includes(\n    name\n  )) {\n    callExpression2.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: ` @__PURE__ `\n      }\n    ];\n  }\n  return callExpression2;\n}\nfunction getHTMLRuntime() {\n  return {\n    escapeXML,\n    toString,\n    attr,\n    classAttr,\n    styleAttr,\n    escapeScript,\n    escapeStyle\n  };\n}\nfunction getRuntimePath(output) {\n  const { optimize } = getMarkoOpts();\n  return `@marko/runtime-tags/${optimize ? \"\" : \"debug/\"}${output === \"html\" ? \"html\" : \"dom\"}`;\n}\nfunction filterArguments(args) {\n  const filteredArgs = [];\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (arg || filteredArgs.length) {\n      filteredArgs[i] = arg || import_compiler7.types.unaryExpression(\"void\", import_compiler7.types.numericLiteral(0));\n    }\n  }\n  return filteredArgs;\n}\n\n// src/util/signals.ts\nvar import_babel_utils9 = require(\"@marko/babel-utils\");\nvar import_compiler14 = require(\"@marko/compiler\");\n\n// src/core/return.ts\nvar import_babel_utils8 = require(\"@marko/babel-utils\");\nvar import_compiler12 = require(\"@marko/compiler\");\n\n// src/util/get-known-attr-values.ts\nfunction getKnownAttrValues(tag) {\n  const attrs2 = {};\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      attrs2[attr2.name] = attr2.value;\n    }\n  }\n  return attrs2;\n}\n\n// src/util/plugin-hooks.ts\nvar import_compiler8 = require(\"@marko/compiler\");\nfunction enter(modulePlugin, path4) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path4;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (isFunctionPlugin(plugin)) {\n    plugin(path4, import_compiler8.types);\n  } else if (plugin.enter) {\n    plugin.enter(path4, import_compiler8.types);\n  }\n  return node !== path4.node;\n}\nfunction exit(modulePlugin, path4) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path4;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (!isFunctionPlugin(plugin) && plugin.exit) {\n    plugin.exit(path4, import_compiler8.types);\n  }\n  return node !== path4.node;\n}\nfunction isModulePlugin(plugin) {\n  return Boolean(plugin.default);\n}\nfunction isFunctionPlugin(plugin) {\n  return typeof plugin === \"function\";\n}\n\n// src/util/visitors.ts\nfunction extractVisitors(visitors2) {\n  const result = {\n    migrate: {},\n    transform: {},\n    analyze: {},\n    translate: {}\n  };\n  for (const _name in visitors2) {\n    const name = _name;\n    const value = visitors2[name];\n    if (value.migrate) result.migrate[name] = value.migrate;\n    if (value.transform) result.transform[name] = value.transform;\n    if (value.analyze) result.analyze[name] = value.analyze;\n    if (value.translate) result.translate[name] = value.translate;\n  }\n  return result;\n}\nfunction translateByTarget({\n  html,\n  dom\n}) {\n  return {\n    enter(path4) {\n      enter(isOutputHTML() ? html : dom, path4);\n    },\n    exit(path4) {\n      exit(isOutputHTML() ? html : dom, path4);\n    }\n  };\n}\n\n// src/util/writer.ts\nvar import_compiler11 = require(\"@marko/compiler\");\n\n// src/util/to-template-string-or-literal.ts\nvar import_compiler9 = require(\"@marko/compiler\");\nfunction toTemplateOrStringLiteral(parts) {\n  const strs = [];\n  const exprs = [];\n  let curStr = parts[0];\n  for (let i = 1; i < parts.length; i++) {\n    let content = parts[i];\n    if (typeof content === \"object\") {\n      if (import_compiler9.types.isStringLiteral(content)) {\n        content = content.value;\n      } else if (import_compiler9.types.isTemplateLiteral(content)) {\n        let nextIndex = i + 1;\n        const exprLen = content.expressions.length;\n        shiftItems(parts, nextIndex, content.quasis.length + exprLen);\n        for (let j = 0; j < exprLen; j++) {\n          parts[nextIndex++] = content.quasis[j].value.raw;\n          parts[nextIndex++] = content.expressions[j];\n        }\n        parts[nextIndex] = content.quasis[exprLen].value.raw;\n        continue;\n      } else {\n        exprs.push(content);\n        strs.push(curStr);\n        curStr = \"\";\n        continue;\n      }\n    }\n    curStr += content;\n  }\n  if (exprs.length) {\n    strs.push(curStr);\n    return import_compiler9.types.templateLiteral(\n      strs.map((raw) => import_compiler9.types.templateElement({ raw })),\n      exprs\n    );\n  } else if (curStr) {\n    return import_compiler9.types.stringLiteral(curStr);\n  }\n}\nfunction appendLiteral(arr, str) {\n  arr[arr.length - 1] += str;\n}\nfunction shiftItems(list, start, offset) {\n  for (let i = list.length - 1; i >= start; i--) {\n    list[i + offset] = list[i];\n  }\n}\n\n// src/util/walks.ts\nvar import_compiler10 = require(\"@marko/compiler\");\nvar [getWalks] = createSectionState(\n  \"walks\",\n  () => [\"\"]\n);\nvar [getWalkComment] = createSectionState(\n  \"walkComment\",\n  () => []\n);\nvar [getSteps] = createSectionState(\"steps\", () => []);\nvar walkCodeToName = {\n  [32 /* Get */]: \"get\",\n  [36 /* Inside */]: \"inside\",\n  [37 /* Replace */]: \"replace\",\n  [38 /* EndChild */]: \"endChild\",\n  [47 /* BeginChild */]: \"beginChild\",\n  [67 /* Next */]: \"next\",\n  [97 /* Over */]: \"over\",\n  [107 /* Out */]: \"out\",\n  [117 /* Multiplier */]: \"multiplier\",\n  [91 /* NextEnd */]: \"nextEnd\",\n  [106 /* OverEnd */]: \"overEnd\",\n  [116 /* OutEnd */]: \"outEnd\",\n  [126 /* MultiplierEnd */]: \"multiplierEnd\"\n};\nfunction enter2(path4) {\n  getSteps(getSection(path4)).push(0 /* Enter */);\n}\nfunction exit2(path4) {\n  getSteps(getSection(path4)).push(1 /* Exit */);\n}\nfunction enterShallow(path4) {\n  getSteps(getSection(path4)).push(0 /* Enter */, 1 /* Exit */);\n}\nfunction injectWalks(path4, expr) {\n  const walks = getWalks(getSection(path4));\n  const walkComment = getWalkComment(getSection(path4));\n  walkComment.push(\n    `${walkCodeToName[47 /* BeginChild */]}`,\n    expr.name,\n    walkCodeToName[38 /* EndChild */]\n  );\n  appendLiteral(walks, String.fromCharCode(47 /* BeginChild */));\n  walks.push(expr, String.fromCharCode(38 /* EndChild */));\n}\nfunction visit(path4, code) {\n  if (isOutputHTML()) {\n    return;\n  }\n  const section = getSection(path4);\n  const steps = getSteps(section);\n  const walks = getWalks(section);\n  const walkComment = getWalkComment(section);\n  let walkString = \"\";\n  if (steps.length) {\n    const walkCodes = [];\n    let depth = 0;\n    for (const step of steps) {\n      if (step === 0 /* Enter */) {\n        depth++;\n        walkCodes.push(67 /* Next */);\n      } else {\n        depth--;\n        if (depth >= 0) {\n          walkCodes.length = walkCodes.lastIndexOf(67 /* Next */);\n          walkCodes.push(97 /* Over */);\n        } else {\n          walkCodes.length = walkCodes.lastIndexOf(107 /* Out */) + 1;\n          walkCodes.push(107 /* Out */);\n          depth = 0;\n        }\n      }\n    }\n    let current = walkCodes[0];\n    let count = 0;\n    for (const walk of walkCodes) {\n      if (walk !== current) {\n        walkComment.push(`${walkCodeToName[current]}(${count})`);\n        walkString += nCodeString(current, count);\n        current = walk;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n    walkComment.push(`${walkCodeToName[current]}(${count})`);\n    walkString += nCodeString(current, count);\n    steps.length = 0;\n  }\n  if (code !== void 0) {\n    if (code !== 32 /* Get */) {\n      writeTo(path4)`<!>`;\n    }\n    walkComment.push(`${walkCodeToName[code]}`);\n    walkString += String.fromCharCode(code);\n  }\n  appendLiteral(walks, walkString);\n}\nfunction nCodeString(code, number) {\n  switch (code) {\n    case 67 /* Next */:\n      return toCharString(number, code, 20 /* Next */);\n    case 97 /* Over */:\n      return toCharString(number, code, 10 /* Over */);\n    case 107 /* Out */:\n      return toCharString(number, code, 10 /* Out */);\n    default:\n      throw new Error(`Unexpected walk code: ${code}`);\n  }\n}\nfunction toCharString(number, startCode, rangeSize) {\n  let result = \"\";\n  if (number >= rangeSize) {\n    const multiplier = Math.floor(number / rangeSize);\n    result += toCharString(\n      multiplier,\n      117 /* Multiplier */,\n      10 /* Multiplier */\n    );\n    number -= multiplier * rangeSize;\n  }\n  result += String.fromCharCode(startCode + number);\n  return result;\n}\nfunction getWalkString(section) {\n  const prefix2 = section.content?.startType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const postfix = section.content?.endType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const walks = getWalks(section);\n  const walkLiteral = toTemplateOrStringLiteral([prefix2, ...walks, postfix]) || import_compiler10.types.stringLiteral(\"\");\n  if (walkLiteral.value !== \"\") {\n    walkLiteral.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: \" \" + getWalkComment(section).join(\", \") + \" \"\n      }\n    ];\n  }\n  return walkLiteral;\n}\n\n// src/util/writer.ts\nvar [getWrites] = createSectionState(\n  \"writes\",\n  () => [\"\"]\n);\nfunction writeTo(path4) {\n  const section = getSection(path4);\n  return (strs, ...exprs) => {\n    const exprsLen = exprs.length;\n    const writes = getWrites(section);\n    appendLiteral(writes, strs[0]);\n    for (let i = 0; i < exprsLen; i++) {\n      writes.push(exprs[i], strs[i + 1]);\n    }\n  };\n}\nfunction consumeHTML(path4) {\n  const writes = getWrites(getSection(path4));\n  const result = toTemplateOrStringLiteral(writes);\n  writes.length = 0;\n  writes[0] = \"\";\n  if (result) {\n    return import_compiler11.types.expressionStatement(callRuntime(\"write\", result));\n  }\n}\nfunction flushBefore(path4) {\n  const expr = consumeHTML(path4);\n  if (expr) {\n    path4.insertBefore(expr)[0].skip();\n  }\n}\nfunction flushInto(path4) {\n  const target = path4.isProgram() ? path4 : path4.get(\"body\");\n  const expr = consumeHTML(target);\n  if (expr) {\n    target.pushContainer(\"body\", expr)[0].skip();\n  }\n}\nfunction getSectionMeta(section) {\n  const writePrefix = section.content?.startType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writePostfix = section.content?.endType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writes = getWrites(section);\n  return {\n    setup: getSetup(section),\n    walks: getWalkString(section),\n    writes: toTemplateOrStringLiteral([writePrefix, ...writes, writePostfix]) || import_compiler11.types.stringLiteral(\"\")\n  };\n}\nfunction markNode(path4, binding) {\n  const section = getSection(path4);\n  if (binding.type !== 0 /* dom */) {\n    throw path4.buildCodeFrameError(\n      \"Tried to mark a node that was not determined to need a mark during analyze.\"\n    );\n  }\n  if (isOutputHTML()) {\n    writeTo(path4)`${callRuntime(\n      \"markResumeNode\",\n      getScopeIdIdentifier(section),\n      getScopeAccessorLiteral(binding)\n    )}`;\n  }\n}\n\n// src/core/return.ts\nvar [returnId, _setReturnId] = createSectionState(\n  \"returnId\"\n);\nvar usedTag = /* @__PURE__ */ new WeakSet();\nvar return_default = {\n  analyze(tag) {\n    (0, import_babel_utils8.assertNoArgs)(tag);\n    (0, import_babel_utils8.assertNoVar)(tag);\n    (0, import_babel_utils8.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils8.assertAllowedAttributes)(tag, [\"value\", \"valueChange\"]);\n    if (usedTag.has(tag.hub)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `return` tag can only be used once per template.\"\n      );\n    }\n    usedTag.add(tag.hub);\n    if (!getKnownAttrValues(tag.node).value) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `return` tag requires a value.\");\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      exit(tag) {\n        const section = getSection(tag);\n        const attrs2 = getKnownAttrValues(tag.node);\n        flushBefore(tag);\n        if (attrs2.valueChange) {\n          getSerializedScopeProperties(section).set(\n            import_compiler12.types.stringLiteral(\"@\" /* TagVariableChange */),\n            attrs2.valueChange\n          );\n        }\n        if (attrs2.value) {\n          const returnId2 = tag.hub.file.path.scope.generateUidIdentifier(\"return\");\n          _setReturnId(section, returnId2);\n          tag.replaceWith(\n            import_compiler12.types.variableDeclaration(\"const\", [\n              import_compiler12.types.variableDeclarator(returnId2, attrs2.value)\n            ])\n          )[0].skip();\n        }\n      }\n    },\n    dom: {\n      exit(tag) {\n        const section = getSection(tag);\n        const attrs2 = getKnownAttrValues(tag.node);\n        if (attrs2.value) {\n          addValue(\n            section,\n            attrs2.value.extra?.referencedBindings,\n            {\n              identifier: importRuntime(\"tagVarSignal\"),\n              hasDownstreamIntersections: () => true\n            },\n            attrs2.value\n          );\n        }\n        if (attrs2.valueChange) {\n          addValue(\n            section,\n            attrs2.valueChange.extra?.referencedBindings,\n            {\n              identifier: importRuntime(\"setTagVarChange\"),\n              hasDownstreamIntersections: () => false\n            },\n            attrs2.valueChange\n          );\n        }\n        tag.remove();\n      }\n    }\n  }),\n  autocomplete: [\n    {\n      displayText: \"return=<value>\",\n      description: \"Provides a value for use in a parent template.\",\n      snippet: \"return=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#return\"\n    }\n  ]\n};\n\n// src/util/scope-read.ts\nvar import_compiler13 = require(\"@marko/compiler\");\nfunction createScopeReadPattern(section, referencedBindings) {\n  const rootDepth = section.depth;\n  const rootPattern = import_compiler13.types.objectPattern([]);\n  let nestedPatterns;\n  forEach(referencedBindings, (ref) => {\n    if (ref.name.includes(\"#\")) return;\n    const propertyKey = getScopeAccessorLiteral(ref);\n    const propertyValue = import_compiler13.types.identifier(ref.name);\n    const isShorthand = propertyKey.value === propertyValue.name;\n    let pattern = rootPattern;\n    if (ref.section !== section) {\n      if (!nestedPatterns) nestedPatterns = [rootPattern];\n      const relativeDepth = rootDepth - ref.section.depth;\n      let i = nestedPatterns.length;\n      let prev = nestedPatterns[i - 1];\n      for (; i <= relativeDepth; i++) {\n        const nestedPattern = import_compiler13.types.objectPattern([]);\n        prev.properties.push(\n          import_compiler13.types.objectProperty(import_compiler13.types.identifier(\"_\"), nestedPattern)\n        );\n        nestedPatterns.push(nestedPattern);\n        prev = nestedPattern;\n      }\n      pattern = nestedPatterns[relativeDepth];\n    }\n    pattern.properties.push(\n      import_compiler13.types.objectProperty(\n        isShorthand ? propertyValue : propertyKey,\n        propertyValue,\n        false,\n        isShorthand\n      )\n    );\n  });\n  return rootPattern;\n}\nfunction getScopeExpression(section, targetSection) {\n  let scope = scopeIdentifier ?? import_compiler13.types.identifier(\"undefined\");\n  const diff = section.depth - targetSection.depth;\n  for (let i = 0; i < diff; i++) {\n    scope = import_compiler13.types.memberExpression(scope, import_compiler13.types.identifier(\"_\"));\n  }\n  if (diff < 0) {\n    throw new Error(\"Unable to find scope for reference.\");\n  }\n  return scope;\n}\nfunction createScopeReadExpression(section, reference) {\n  return import_compiler13.types.memberExpression(\n    getScopeExpression(section, reference.section),\n    getScopeAccessorLiteral(reference),\n    true\n  );\n}\n\n// src/util/signals.ts\nvar [getSignals] = createSectionState(\n  \"signals\",\n  () => /* @__PURE__ */ new Map()\n);\nvar [getSubscribeBuilder, _setSubscribeBuilder] = createSectionState(\"queue\");\nfunction setSubscriberBuilder(tag, builder) {\n  _setSubscribeBuilder(getSectionForBody(tag.get(\"body\")), builder);\n}\nvar [forceResumeScope, _setForceResumeScope] = createSectionState(\"forceResumeScope\");\nfunction setForceResumeScope(section) {\n  _setForceResumeScope(section, true);\n}\nvar [getSerializedScopeProperties] = createSectionState(\"serializedScopeProperties\", () => /* @__PURE__ */ new Map());\nvar unimplementedBuild = () => {\n  return import_compiler14.types.stringLiteral(\"SIGNAL NOT INITIALIZED\");\n};\nfunction getSignal(section, referencedBindings, name = generateSignalName(referencedBindings)) {\n  const signals = getSignals(section);\n  let signal = signals.get(referencedBindings);\n  if (!signal) {\n    const exportName = referencedBindings ? !Array.isArray(referencedBindings) && referencedBindings.section === section && referencedBindings.export : !section.parent && currentProgramPath.node.extra.domExports?.setup;\n    signals.set(\n      referencedBindings,\n      signal = {\n        identifier: exportName ? import_compiler14.types.identifier(exportName) : currentProgramPath.scope.generateUidIdentifier(\n          name + section.name.replace(\"_\", \"$\")\n        ),\n        referencedBindings,\n        section,\n        values: [],\n        intersection: void 0,\n        render: [],\n        effect: [],\n        effectInlineReferences: void 0,\n        subscribers: [],\n        closures: /* @__PURE__ */ new Map(),\n        hasDownstreamIntersections: () => {\n          let hasDownstreamIntersections = !!(signal.intersection || signal.closures.size);\n          if (!hasDownstreamIntersections) {\n            for (const value of signal.values) {\n              if (value.signal.hasDownstreamIntersections()) {\n                hasDownstreamIntersections = true;\n                break;\n              }\n            }\n          }\n          if (!hasDownstreamIntersections) {\n            if (!Array.isArray(referencedBindings) && referencedBindings) {\n              for (const alias of referencedBindings.aliases) {\n                if (getSignal(section, alias).hasDownstreamIntersections()) {\n                  hasDownstreamIntersections = true;\n                  break;\n                }\n              }\n              if (!hasDownstreamIntersections) {\n                for (const [, alias] of referencedBindings.propertyAliases) {\n                  if (getSignal(section, alias).hasDownstreamIntersections()) {\n                    hasDownstreamIntersections = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          signal.hasDownstreamIntersections = () => hasDownstreamIntersections;\n          return hasDownstreamIntersections;\n        },\n        build: unimplementedBuild,\n        export: !!exportName\n      }\n    );\n    if (isOutputHTML()) {\n      return signal;\n    } else if (!referencedBindings) {\n      signal.build = () => getSignalFn(signal, [scopeIdentifier]);\n    } else if (Array.isArray(referencedBindings)) {\n      subscribe(referencedBindings, signal);\n      signal.build = () => {\n        return callRuntime(\n          \"intersection\",\n          import_compiler14.types.numericLiteral(referencedBindings.length),\n          getSignalFn(signal, [scopeIdentifier], referencedBindings),\n          buildSignalIntersections(signal)\n        );\n      };\n    } else if (referencedBindings.section !== section) {\n      getSignal(referencedBindings.section, referencedBindings).closures.set(\n        section,\n        signal\n      );\n      signal.build = () => {\n        const builder = getSubscribeBuilder(section);\n        const ownerScope = getScopeExpression(\n          section,\n          referencedBindings.section\n        );\n        const isImmediateOwner = ownerScope.object === scopeIdentifier;\n        const isDynamicClosure = signal.isDynamicClosure = !(isImmediateOwner && builder);\n        return callRuntime(\n          isDynamicClosure ? \"dynamicClosure\" : \"closure\",\n          getScopeAccessorLiteral(referencedBindings),\n          getSignalFn(signal, [\n            scopeIdentifier,\n            import_compiler14.types.identifier(referencedBindings.name)\n          ]),\n          isImmediateOwner ? null : import_compiler14.types.arrowFunctionExpression([scopeIdentifier], ownerScope),\n          buildSignalIntersections(signal)\n        );\n      };\n    }\n  }\n  return signal;\n}\nfunction initValue(binding, runtimeHelper = \"value\") {\n  const valueAccessor = getScopeAccessorLiteral(binding);\n  const section = binding.section;\n  const signal = getSignal(section, binding);\n  signal.build = () => {\n    const fn = getSignalFn(signal, [\n      scopeIdentifier,\n      import_compiler14.types.identifier(binding.name)\n    ]);\n    const intersections = buildSignalIntersections(signal);\n    const isParamBinding = !binding.upstreamAlias && (binding.type === 3 /* param */ || binding.type === 2 /* input */);\n    const isNakedAlias = binding.upstreamAlias && !binding.property;\n    const needsGuard = !isNakedAlias && (binding.downstreamExpressions.size || fn.body.body.length > 0);\n    const needsCache = needsGuard || intersections;\n    const needsMarks = isParamBinding || intersections;\n    if (needsCache || needsMarks) {\n      return callRuntime(runtimeHelper, valueAccessor, fn, intersections);\n    } else {\n      return fn;\n    }\n  };\n  signal.valueAccessor = valueAccessor;\n  for (const alias of binding.aliases) {\n    initValue(alias);\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    initValue(alias);\n  }\n  return signal;\n}\nfunction getSignalFn(signal, params, referencedBindings) {\n  const section = signal.section;\n  const binding = signal.referencedBindings;\n  if (binding && !Array.isArray(binding) && binding.section === section) {\n    const [scopeIdentifier2, valueIdentifier] = params;\n    for (const alias of binding.aliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler14.types.expressionStatement(\n          import_compiler14.types.callExpression(aliasSignal.identifier, [\n            scopeIdentifier2,\n            valueIdentifier,\n            ...aliasSignal.extraArgs || []\n          ])\n        )\n      );\n    }\n    for (const [key, alias] of binding.propertyAliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler14.types.expressionStatement(\n          import_compiler14.types.callExpression(aliasSignal.identifier, [\n            scopeIdentifier2,\n            toMemberExpression(valueIdentifier, key),\n            ...aliasSignal.extraArgs || []\n          ])\n        )\n      );\n    }\n  }\n  for (const value of signal.values) {\n    signal.render.push(\n      import_compiler14.types.expressionStatement(\n        import_compiler14.types.callExpression(value.signal.identifier, [\n          value.scope,\n          value.value,\n          ...value.signal.extraArgs || []\n        ])\n      )\n    );\n  }\n  if (referencedBindings) {\n    signal.render.unshift(\n      import_compiler14.types.variableDeclaration(\"const\", [\n        import_compiler14.types.variableDeclarator(\n          createScopeReadPattern(section, referencedBindings),\n          scopeIdentifier\n        )\n      ])\n    );\n  }\n  return import_compiler14.types.arrowFunctionExpression(params, import_compiler14.types.blockStatement(signal.render));\n}\nfunction buildSignalIntersections(signal) {\n  const section = signal.section;\n  let intersections = signal.intersection;\n  const binding = signal.referencedBindings;\n  if (binding && !Array.isArray(binding) && binding.section === signal.section) {\n    for (const alias of binding.aliases) {\n      const signal2 = getSignal(alias.section, alias);\n      if (signal2.hasDownstreamIntersections()) {\n        intersections = push(\n          intersections,\n          import_compiler14.types.identifier(signal2.identifier.name)\n        );\n      }\n    }\n    for (const [, alias] of binding.propertyAliases) {\n      const signal2 = getSignal(alias.section, alias);\n      if (signal2.hasDownstreamIntersections()) {\n        intersections = push(\n          intersections,\n          import_compiler14.types.identifier(signal2.identifier.name)\n        );\n      }\n    }\n  }\n  for (const value of signal.values) {\n    if (value.signal.hasDownstreamIntersections()) {\n      intersections = push(\n        intersections,\n        value.intersectionExpression ?? (import_compiler14.types.isMemberExpression(value.signal.identifier) ? value.signal.identifier : import_compiler14.types.identifier(value.signal.identifier.name))\n      );\n    }\n  }\n  const closureEntries = Array.from(signal.closures.entries()).sort(\n    ([a], [b]) => a.id - b.id\n  );\n  for (const [closureSection, closureSignal] of closureEntries) {\n    const builder = getSubscribeBuilder(closureSection);\n    const isImmediateOwner = closureSection.parent === section;\n    if (builder && isImmediateOwner) {\n      intersections = push(intersections, builder(closureSignal.identifier));\n    } else if (!signal.hasDynamicSubscribers) {\n      signal.hasDynamicSubscribers = true;\n    }\n  }\n  if (signal.hasDynamicSubscribers) {\n    signal.hasDynamicSubscribers = true;\n    intersections = push(\n      intersections,\n      callRuntime(\"dynamicSubscribers\", signal.valueAccessor)\n    );\n  }\n  return intersections && import_compiler14.types.arrowFunctionExpression(\n    [],\n    Array.isArray(intersections) ? callRuntime(\"intersections\", import_compiler14.types.arrayExpression(intersections)) : intersections\n  );\n}\nfunction subscribe(provider, subscriber) {\n  if (Array.isArray(provider)) {\n    provider.forEach((p) => subscribe(p, subscriber));\n    return;\n  }\n  const providerSignal = getSignal(subscriber.section, provider);\n  providerSignal.intersection = push(\n    providerSignal.intersection,\n    subscriber.identifier\n  );\n}\nfunction generateSignalName(referencedBindings) {\n  let name;\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      name = \"expr\";\n      for (const ref of referencedBindings) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name = referencedBindings.name;\n    }\n  } else {\n    name = \"setup\";\n  }\n  return name;\n}\nfunction finalizeSignalArgs(args) {\n  for (let i = args.length - 1; i >= 0; i--) {\n    const arg = args[i];\n    if (import_compiler14.types.isArrowFunctionExpression(arg)) {\n      const body = arg.body.body;\n      if (body) {\n        if (body.length === 0) {\n          args[i] = import_compiler14.types.numericLiteral(0);\n        } else if (body.length === 1 && import_compiler14.types.isExpressionStatement(body[0])) {\n          arg.body = body[0].expression;\n        }\n      }\n    }\n  }\n  for (let i = args.length - 1; import_compiler14.types.isNullLiteral(args[i]); ) {\n    args.length = i--;\n  }\n}\nfunction addStatement(type, targetSection, referencedBindings, statement, originalNodes, isInlined) {\n  const signal = getSignal(targetSection, referencedBindings);\n  const statements = signal[type] ??= [];\n  if (Array.isArray(statement)) {\n    statements.push(...statement);\n  } else {\n    statements.push(statement);\n  }\n  if (type === \"effect\") {\n    if (Array.isArray(originalNodes)) {\n      for (const node of originalNodes) {\n        if (isInlined || !import_compiler14.types.isFunction(node)) {\n          addEffectReferences(signal, node);\n        }\n      }\n    } else if (originalNodes && (isInlined || !import_compiler14.types.isFunction(originalNodes))) {\n      addEffectReferences(signal, originalNodes);\n    }\n  }\n}\nfunction addValue(targetSection, referencedBindings, signal, value, scope = scopeIdentifier, intersectionExpression) {\n  getSignal(targetSection, referencedBindings).values.push({\n    signal,\n    value,\n    scope,\n    intersectionExpression\n  });\n}\nfunction addEffectReferences(signal, expression) {\n  signal.effectInlineReferences = bindingUtil.union(\n    signal.effectInlineReferences,\n    expression.extra?.referencedBindings\n  );\n}\nfunction getResumeRegisterId(section, referencedBindings, type) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let name = \"\";\n  if (referencedBindings) {\n    if (typeof referencedBindings === \"string\") {\n      name += `_${referencedBindings}`;\n    } else if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name += `_${referencedBindings.name}`;\n    }\n  }\n  return (0, import_babel_utils9.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}${name}${type ? \"/\" + type : \"\"}`\n  );\n}\nvar usedRegisterIdsBySection = /* @__PURE__ */ new WeakMap();\nfunction getRegisterUID(section, name) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let used = usedRegisterIdsBySection.get(section);\n  if (!used) usedRegisterIdsBySection.set(section, used = /* @__PURE__ */ new Set());\n  const baseId = (0, import_babel_utils9.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}/${name}`\n  );\n  let count = 0;\n  let id = baseId;\n  while (used.has(id)) {\n    id = baseId + \"_\" + ++count;\n  }\n  used.add(id);\n  return id;\n}\nfunction renameBindings() {\n  import_compiler14.types.traverseFast(currentProgramPath.node, (node) => {\n    if (import_compiler14.types.isIdentifier(node)) {\n      const binding = node.extra && (node.extra.source || node.extra.binding);\n      if (binding && binding.name !== node.name) {\n        node.name = binding.name;\n      }\n    }\n  });\n}\nfunction replaceAssignments() {\n  if (currentProgramPath.node.extra.assignments) {\n    for (const [valueSection, assignment] of currentProgramPath.node.extra.assignments) {\n      const { node } = assignment;\n      if (node.type === \"UpdateExpression\") {\n        const binding = node.argument.extra?.source;\n        if (binding) {\n          const { buildAssignment } = getSignal(binding.section, binding);\n          if (buildAssignment) {\n            const replacement = buildAssignment(\n              valueSection,\n              import_compiler14.types.binaryExpression(\n                node.operator === \"++\" ? \"+\" : \"-\",\n                node.argument,\n                import_compiler14.types.numericLiteral(1)\n              )\n            );\n            assignment.replaceWith(\n              node.prefix || assignment.parentPath.isExpressionStatement() ? replacement : import_compiler14.types.sequenceExpression([replacement, node.argument])\n            );\n          }\n        }\n      } else {\n        if (node.left.type === \"ObjectPattern\" || node.left.type === \"ArrayPattern\") {\n          handleDestructure(assignment, node.left, valueSection);\n        } else if (node.left.type === \"Identifier\") {\n          const binding = node.left.extra?.source;\n          if (binding) {\n            const { buildAssignment } = getSignal(binding.section, binding);\n            if (buildAssignment) {\n              const replacement = buildAssignment(\n                valueSection,\n                node.operator === \"=\" ? node.right : import_compiler14.types.binaryExpression(\n                  node.operator.slice(\n                    0,\n                    -1\n                  ),\n                  node.left,\n                  node.right\n                )\n              );\n              assignment.replaceWith(replacement);\n            }\n          }\n        }\n      }\n    }\n  }\n}\nfunction writeSignals(section) {\n  const signals = [...getSignals(section).values()].sort(sortSignals);\n  for (const signal of signals) {\n    let effectDeclarator;\n    if (signal.effect.length) {\n      const effectIdentifier = import_compiler14.types.identifier(`${signal.identifier.name}_effect`);\n      if (signal.effectInlineReferences) {\n        signal.effect.unshift(\n          import_compiler14.types.variableDeclaration(\"const\", [\n            import_compiler14.types.variableDeclarator(\n              createScopeReadPattern(section, signal.effectInlineReferences),\n              scopeIdentifier\n            )\n          ])\n        );\n      }\n      effectDeclarator = import_compiler14.types.variableDeclarator(\n        effectIdentifier,\n        callRuntime(\n          \"effect\",\n          import_compiler14.types.stringLiteral(\n            getResumeRegisterId(section, signal.referencedBindings)\n          ),\n          import_compiler14.types.arrowFunctionExpression(\n            [scopeIdentifier],\n            signal.effect.length === 1 && import_compiler14.types.isExpressionStatement(signal.effect[0]) ? signal.effect[0].expression : import_compiler14.types.blockStatement(signal.effect)\n          )\n        )\n      );\n      signal.render.push(\n        import_compiler14.types.expressionStatement(\n          import_compiler14.types.callExpression(effectIdentifier, [scopeIdentifier])\n        )\n      );\n    }\n    let value = signal.build();\n    if (import_compiler14.types.isCallExpression(value)) {\n      finalizeSignalArgs(value.arguments);\n    }\n    if (signal.register) {\n      value = callRuntime(\n        \"registerBoundSignal\",\n        import_compiler14.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings)\n        ),\n        value\n      );\n    }\n    if (signal.isDynamicClosure && isStatefulReferences(signal.referencedBindings)) {\n      value = callRuntime(\n        \"registerSubscriber\",\n        import_compiler14.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings, \"subscriber\")\n        ),\n        value\n      );\n    }\n    const signalDeclarator = import_compiler14.types.variableDeclarator(signal.identifier, value);\n    let signalDeclaration = !section.parent && !signal.referencedBindings && (import_compiler14.types.isFunctionExpression(value) || import_compiler14.types.isArrowFunctionExpression(value)) ? import_compiler14.types.functionDeclaration(\n      signal.identifier,\n      value.params,\n      import_compiler14.types.isExpression(value.body) ? import_compiler14.types.blockStatement([import_compiler14.types.expressionStatement(value.body)]) : value.body\n    ) : import_compiler14.types.variableDeclaration(\"const\", [signalDeclarator]);\n    if (signal.export) {\n      signalDeclaration = import_compiler14.types.exportNamedDeclaration(signalDeclaration);\n    }\n    const roots = currentProgramPath.pushContainer(\n      \"body\",\n      effectDeclarator ? [\n        import_compiler14.types.variableDeclaration(\"const\", [effectDeclarator]),\n        signalDeclaration\n      ] : signalDeclaration\n    );\n    for (const root of roots) {\n      root.traverse(bindFunctionsVisitor, { root, section });\n    }\n  }\n}\nfunction sortSignals(a, b) {\n  const aReferencedBindings = getReferencedBindings(a);\n  const bReferencedBindings = getReferencedBindings(b);\n  for (let i = Math.max(aReferencedBindings.length, bReferencedBindings.length) - 1; i >= 0; i--) {\n    const diff = (bReferencedBindings[i] ?? -1) - (aReferencedBindings[i] ?? -1);\n    if (diff !== 0) return diff;\n  }\n  return 0;\n}\nfunction getReferencedBindings({ referencedBindings: reserve }) {\n  if (!reserve) {\n    return [];\n  } else if (Array.isArray(reserve)) {\n    return reserve.map(getMappedId).sort();\n  } else {\n    return [getMappedId(reserve)];\n  }\n}\nfunction getMappedId(reference) {\n  return (reference.type === 0 /* dom */ ? 1 : 0) * 1e4 + reference.id;\n}\nfunction addHTMLEffectCall(section, referencedBindings) {\n  addStatement(\"effect\", section, referencedBindings, void 0, []);\n}\nfunction writeHTMLResumeStatements(path4, tagVarIdentifier) {\n  const section = getSectionForBody(path4);\n  if (!section) return;\n  const allSignals = Array.from(getSignals(section).values());\n  const scopeIdIdentifier = getScopeIdIdentifier(section);\n  forEach(section.closures, (closure) => {\n    if (isStatefulReferences(closure)) {\n      let currentSection = section;\n      while (currentSection !== closure.section) {\n        getSerializedScopeProperties(currentSection).set(\n          import_compiler14.types.stringLiteral(\"_\"),\n          callRuntime(\n            \"ensureScopeWithId\",\n            getScopeIdIdentifier(currentSection = currentSection.parent)\n          )\n        );\n      }\n      setForceResumeScope(closure.section);\n      const isImmediateOwner = section.parent?.id === closure.section.id;\n      const isDynamicClosure = !getSubscribeBuilder(section) || !isImmediateOwner;\n      if (isDynamicClosure) {\n        path4.pushContainer(\n          \"body\",\n          import_compiler14.types.expressionStatement(\n            callRuntime(\n              \"writeEffect\",\n              scopeIdIdentifier,\n              import_compiler14.types.stringLiteral(\n                getResumeRegisterId(section, closure, \"subscriber\")\n              )\n            )\n          )\n        );\n      }\n    }\n  });\n  for (let i = allSignals.length; i--; ) {\n    if (allSignals[i].effect.length) {\n      const signalRefs = allSignals[i].referencedBindings;\n      path4.pushContainer(\n        \"body\",\n        import_compiler14.types.expressionStatement(\n          callRuntime(\n            \"writeEffect\",\n            scopeIdIdentifier,\n            import_compiler14.types.stringLiteral(getResumeRegisterId(section, signalRefs))\n          )\n        )\n      );\n    }\n  }\n  const accessors = /* @__PURE__ */ new Set();\n  const additionalProperties = getSerializedScopeProperties(section);\n  const serializedProperties = [];\n  forEach(section.bindings, (binding) => {\n    if (binding.serialize && binding.type !== 0 /* dom */) {\n      const accessor = getScopeAccessorLiteral(binding);\n      serializedProperties.push(\n        import_compiler14.types.objectProperty(accessor, import_compiler14.types.identifier(binding.name))\n      );\n      accessors.add(accessor.value);\n    }\n  });\n  if (tagVarIdentifier && returnId(section) !== void 0) {\n    serializedProperties.push(\n      import_compiler14.types.objectProperty(\n        import_compiler14.types.stringLiteral(\"/\" /* TagVariable */),\n        tagVarIdentifier\n      )\n    );\n  }\n  for (const [key, value] of additionalProperties) {\n    if (!accessors.has(key.value)) {\n      serializedProperties.push(\n        import_compiler14.types.objectProperty(key, value, !import_compiler14.types.isLiteral(key))\n      );\n      accessors.add(key.value);\n    }\n  }\n  if (serializedProperties.length || forceResumeScope(section)) {\n    path4.pushContainer(\n      \"body\",\n      import_compiler14.types.expressionStatement(\n        callRuntime(\n          \"writeScope\",\n          scopeIdIdentifier,\n          import_compiler14.types.objectExpression(serializedProperties)\n        )\n      )\n    );\n  }\n  if (path4.get(\"body\").length) {\n    path4.unshiftContainer(\n      \"body\",\n      import_compiler14.types.variableDeclaration(\"const\", [\n        import_compiler14.types.variableDeclarator(scopeIdIdentifier, callRuntime(\"nextScopeId\"))\n      ])\n    );\n  }\n}\nvar bindFunctionsVisitor = {\n  FunctionExpression: { exit: bindFunction },\n  ArrowFunctionExpression: { exit: bindFunction }\n};\nfunction handleDestructure(assignment, node, section, ctx, replace) {\n  if (!ctx) {\n    ctx = {\n      statement: assignment.getStatementParent(),\n      end: assignment.getStatementParent()\n    };\n  }\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        handleDestructure(assignment, prop, section, ctx);\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const i in node.elements) {\n        if (node.elements[i] === null) continue;\n        handleDestructure(\n          assignment,\n          node.elements[i],\n          section,\n          ctx,\n          (id) => node.elements[i] = id\n        );\n      }\n      break;\n    case \"RestElement\":\n      handleDestructure(\n        assignment,\n        node.argument,\n        section,\n        ctx,\n        (id) => node.argument = id\n      );\n      break;\n    case \"ObjectProperty\":\n      handleDestructure(\n        assignment,\n        node.value,\n        section,\n        ctx,\n        (id) => node.value = id\n      );\n      break;\n    case \"Identifier\":\n      {\n        const binding = node.extra?.source;\n        if (binding) {\n          const { buildAssignment } = getSignal(binding.section, binding);\n          if (buildAssignment) {\n            const valueId = ctx.statement.scope.generateUidIdentifier(\n              node.name\n            );\n            ctx.statement.insertBefore(\n              import_compiler14.types.variableDeclaration(\"let\", [import_compiler14.types.variableDeclarator(valueId)])\n            );\n            replace?.(valueId);\n            [ctx.end] = ctx.end.insertAfter(\n              import_compiler14.types.expressionStatement(buildAssignment(section, valueId))\n            );\n          }\n        }\n      }\n      break;\n  }\n}\nfunction bindFunction(fn, { root, section }) {\n  const { node } = fn;\n  const { extra } = node;\n  if (!extra?.referencedBindings) return;\n  const { name, referencedBindings } = extra;\n  const fnId = fn.hub.file.path.scope.generateUidIdentifier(name);\n  root.insertBefore(\n    import_compiler14.types.variableDeclaration(\"const\", [\n      import_compiler14.types.variableDeclarator(\n        fnId,\n        import_compiler14.types.arrowFunctionExpression(\n          [scopeIdentifier],\n          referencedBindings ? import_compiler14.types.blockStatement([\n            import_compiler14.types.variableDeclaration(\"const\", [\n              import_compiler14.types.variableDeclarator(\n                createScopeReadPattern(section, referencedBindings),\n                scopeIdentifier\n              )\n            ]),\n            import_compiler14.types.returnStatement(node)\n          ]) : node\n        )\n      )\n    ])\n  )[0].skip();\n  fn.replaceWith(import_compiler14.types.callExpression(fnId, [scopeIdentifier]))[0].skip();\n}\nfunction getSetup(section) {\n  return getSignals(section).get(void 0)?.identifier;\n}\nfunction toMemberExpression(value, key) {\n  const keyLiteral = keyToNode(key);\n  return import_compiler14.types.memberExpression(\n    value,\n    keyLiteral,\n    keyLiteral.type !== \"Identifier\"\n  );\n}\nfunction keyToNode(key) {\n  if (/^[a-z_$][a-z0-9_$]*$/i.test(key)) {\n    return import_compiler14.types.identifier(key);\n  } else if (/^(?:0|[1-9][0-9]*)$/.test(key)) {\n    return import_compiler14.types.numericLiteral(parseInt(key, 10));\n  }\n  return import_compiler14.types.stringLiteral(key);\n}\n\n// src/visitors/program/dom.ts\nvar dom_default = {\n  translate: {\n    exit(program) {\n      visit(program);\n      const section = getSectionForBody(program);\n      const { walks, writes, setup } = getSectionMeta(section);\n      const domExports = program.node.extra.domExports;\n      const templateIdentifier = import_compiler15.types.identifier(domExports.template);\n      const walksIdentifier = import_compiler15.types.identifier(domExports.walks);\n      const setupIdentifier = import_compiler15.types.identifier(domExports.setup);\n      const closuresIdentifier = import_compiler15.types.identifier(domExports.closures);\n      const paramsBinding = program.node.extra.binding;\n      const programParamsSignal = paramsBinding && bindingHasDownstreamExpressions(paramsBinding) ? initValue(paramsBinding) : void 0;\n      replaceAssignments();\n      forEachSectionReverse((childSection) => {\n        if (childSection !== section) {\n          const tagParamsSignal = childSection.params && initValue(childSection.params);\n          const { walks: walks2, writes: writes2, setup: setup2 } = getSectionMeta(childSection);\n          const closures2 = getSectionClosuresExpr(childSection);\n          const identifier = import_compiler15.types.identifier(childSection.name);\n          const renderer = callRuntime(\n            getSectionParentIsOwner(childSection) ? \"createRenderer\" : \"createRendererWithOwner\",\n            writes2,\n            walks2,\n            setup2,\n            closures2 && import_compiler15.types.arrowFunctionExpression([], closures2),\n            tagParamsSignal?.identifier && import_compiler15.types.arrowFunctionExpression([], tagParamsSignal.identifier)\n          );\n          writeSignals(childSection);\n          program.node.body.push(\n            import_compiler15.types.variableDeclaration(\"const\", [\n              import_compiler15.types.variableDeclarator(\n                identifier,\n                isStatefulSection(childSection) ? callRuntime(\n                  \"register\",\n                  import_compiler15.types.stringLiteral(\n                    getResumeRegisterId(childSection, \"renderer\")\n                  ),\n                  renderer\n                ) : renderer\n              )\n            ])\n          );\n        }\n      });\n      const closures = getSectionClosuresExpr(section);\n      writeSignals(section);\n      renameBindings();\n      if (!setup) {\n        program.node.body.unshift(\n          import_compiler15.types.exportNamedDeclaration(\n            import_compiler15.types.variableDeclaration(\"const\", [\n              import_compiler15.types.variableDeclarator(\n                setupIdentifier,\n                import_compiler15.types.arrowFunctionExpression([], import_compiler15.types.blockStatement([]))\n              )\n            ])\n          )\n        );\n      }\n      program.node.body.unshift(\n        import_compiler15.types.exportNamedDeclaration(\n          import_compiler15.types.variableDeclaration(\"const\", [\n            import_compiler15.types.variableDeclarator(\n              templateIdentifier,\n              writes || import_compiler15.types.stringLiteral(\"\")\n            )\n          ])\n        ),\n        import_compiler15.types.exportNamedDeclaration(\n          import_compiler15.types.variableDeclaration(\"const\", [\n            import_compiler15.types.variableDeclarator(walksIdentifier, walks || import_compiler15.types.stringLiteral(\"\"))\n          ])\n        )\n      );\n      if (closures) {\n        program.node.body.push(\n          import_compiler15.types.exportNamedDeclaration(\n            import_compiler15.types.variableDeclaration(\"const\", [\n              import_compiler15.types.variableDeclarator(closuresIdentifier, closures)\n            ])\n          )\n        );\n      }\n      program.node.body.push(\n        import_compiler15.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            import_compiler15.types.stringLiteral(program.hub.file.metadata.marko.id),\n            templateIdentifier,\n            walksIdentifier,\n            setupIdentifier,\n            closures && import_compiler15.types.arrowFunctionExpression([], closuresIdentifier),\n            programParamsSignal?.identifier && import_compiler15.types.arrowFunctionExpression([], programParamsSignal.identifier)\n          )\n        )\n      );\n    }\n  }\n};\nfunction getSectionClosuresExpr(section) {\n  if (section.closures) {\n    return import_compiler15.types.arrayExpression(\n      map(\n        section.closures,\n        (closure) => getSignal(section, closure).identifier\n      ).reverse()\n    );\n  }\n}\n\n// src/visitors/program/html.ts\nvar import_compiler16 = require(\"@marko/compiler\");\n\n// src/util/is-static.ts\nfunction isStatic(path4) {\n  return path4.isImportDeclaration() || path4.isExportDeclaration() || path4.isMarkoScriptlet({ static: true });\n}\n\n// src/visitors/program/html.ts\nvar html_default = {\n  translate: {\n    exit(program) {\n      const section = getSectionForBody(program);\n      const tagVarIdentifier = program.scope.generateUidIdentifier(\"tagVar\");\n      flushInto(program);\n      writeHTMLResumeStatements(program, tagVarIdentifier);\n      renameBindings();\n      const returnIdentifier = returnId(section);\n      if (returnIdentifier !== void 0) {\n        program.pushContainer(\"body\", import_compiler16.types.returnStatement(returnIdentifier));\n      }\n      const renderContent = [];\n      for (const child of program.get(\"body\")) {\n        if (!isStatic(child)) {\n          renderContent.push(child.node);\n          child.remove();\n        } else if (child.isMarkoScriptlet()) {\n          if (child.node.target && child.node.target !== \"server\") {\n            child.remove();\n          } else {\n            child.replaceWithMultiple(child.node.body);\n          }\n        }\n      }\n      program.pushContainer(\"body\", [\n        import_compiler16.types.variableDeclaration(\"const\", [\n          import_compiler16.types.variableDeclarator(\n            htmlRendererIdentifier,\n            callRuntime(\n              \"createRenderer\",\n              import_compiler16.types.arrowFunctionExpression(\n                [import_compiler16.types.identifier(\"input\"), tagVarIdentifier],\n                import_compiler16.types.blockStatement(renderContent)\n              )\n            )\n          )\n        ]),\n        import_compiler16.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            import_compiler16.types.stringLiteral(program.hub.file.metadata.marko.id),\n            htmlRendererIdentifier\n          )\n        )\n      ]);\n    }\n  }\n};\n\n// src/visitors/program/index.ts\nvar currentProgramPath;\nvar scopeIdentifier;\nvar cleanIdentifier;\nvar htmlRendererIdentifier;\nvar previousProgramPath = /* @__PURE__ */ new WeakMap();\nvar program_default = {\n  migrate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      program.node.params = [import_compiler17.types.identifier(\"input\")];\n      currentProgramPath = program;\n    },\n    exit() {\n      currentProgramPath.scope.crawl();\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  analyze: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      startSection(program);\n      trackParamsReferences(program, 2 /* input */);\n      const { scope } = program;\n      (program.node.extra ??= {}).domExports = {\n        template: scope.generateUid(\"template_\"),\n        walks: scope.generateUid(\"walks_\"),\n        setup: scope.generateUid(\"setup_\"),\n        params: void 0,\n        // TODO look into recursive components with fine grained params.\n        closures: scope.generateUid(\"closures_\")\n      };\n    },\n    exit(program) {\n      finalizeReferences();\n      const {\n        scope,\n        node: { extra }\n      } = program;\n      if (extra.binding && bindingHasDownstreamExpressions(extra.binding)) {\n        extra.domExports.params = buildTemplateExports(extra.binding, scope);\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  translate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      scopeIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"scope\") : null;\n      cleanIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"clean\") : null;\n      htmlRendererIdentifier = isOutputHTML() ? program.scope.generateUidIdentifier(\"renderer\") : null;\n      if (getMarkoOpts().output === \"hydrate\") {\n        const entryFile = program.hub.file;\n        const visitedFiles = /* @__PURE__ */ new Set([\n          (0, import_babel_utils10.resolveRelativePath)(entryFile, entryFile.opts.filename)\n        ]);\n        entry_builder_default.visit(entryFile, entryFile, function visitChild(resolved) {\n          if (!visitedFiles.has(resolved)) {\n            visitedFiles.add(resolved);\n            const file = (0, import_babel_utils10.loadFileForImport)(entryFile, resolved);\n            if (file) {\n              entry_builder_default.visit(\n                file,\n                entryFile,\n                (id) => visitChild(resolveRelativeToEntry(entryFile, file, id))\n              );\n            }\n          }\n        });\n        program.node.body = entry_builder_default.build(entryFile);\n        program.skip();\n        return;\n      }\n    },\n    exit(program) {\n      if (isOutputHTML()) {\n        html_default.translate.exit(program);\n      } else {\n        dom_default.translate.exit(program);\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  }\n};\nfunction resolveRelativeToEntry(entryFile, file, req) {\n  return file === entryFile ? (0, import_babel_utils10.resolveRelativePath)(file, req) : (0, import_babel_utils10.resolveRelativePath)(\n    entryFile,\n    req[0] === \".\" ? import_path.default.join(file.opts.filename, \"..\", req) : req\n  );\n}\nfunction buildTemplateExports(binding, scope) {\n  const templateExport = {\n    id: binding.export ??= scope.generateUid(binding.name + \"_\"),\n    props: void 0\n  };\n  const { aliases, propertyAliases, downstreamExpressions } = binding;\n  if (!downstreamExpressions.size) {\n    templateExport.props = {};\n    for (const [property, alias] of propertyAliases) {\n      templateExport.props[property] = buildTemplateExports(alias, scope);\n    }\n    for (const alias of aliases) {\n      const exports2 = buildTemplateExports(alias, scope);\n      if (exports2.props) {\n        templateExport.props = { ...templateExport.props, ...exports2.props };\n      } else {\n        templateExport.props = void 0;\n        return templateExport;\n      }\n    }\n  }\n  return templateExport;\n}\n\n// src/util/marko-config.ts\nfunction isOutputHTML() {\n  return getMarkoOpts().output === \"html\";\n}\nfunction isOutputDOM() {\n  return !isOutputHTML();\n}\nfunction getMarkoOpts() {\n  return currentProgramPath.hub.file.markoOpts;\n}\nfunction isOptimize() {\n  return getMarkoOpts().optimize;\n}\n\n// src/util/translate-var.ts\nvar import_compiler18 = require(\"@marko/compiler\");\nfunction translateVar(tag, initialValue, kind = \"const\") {\n  const {\n    node: { var: tagVar }\n  } = tag;\n  if (!tagVar) {\n    return;\n  }\n  tag.insertBefore(\n    import_compiler18.types.variableDeclaration(kind, [import_compiler18.types.variableDeclarator(tagVar, initialValue)])\n  );\n}\n\n// src/core/const.ts\nvar const_default = {\n  analyze(tag) {\n    (0, import_babel_utils11.assertNoArgs)(tag);\n    (0, import_babel_utils11.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a tag variable.\");\n    }\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler19.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `const` tag only supports the `value` attribute.\"\n      );\n    }\n    const upstreamAlias = import_compiler19.types.isIdentifier(valueAttr.value) ? tag.scope.getBinding(valueAttr.value.name)?.identifier.extra?.binding : void 0;\n    trackVarReferences(\n      tag,\n      4 /* derived */,\n      upstreamAlias,\n      valueAttr.value.extra ??= {}\n    );\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      const { value } = valueAttr;\n      if (isOutputDOM()) {\n        const section = getSection(tag);\n        const varBinding = node.var.extra?.binding;\n        if (varBinding && !varBinding.upstreamAlias) {\n          const derivation = initValue(varBinding);\n          addValue(section, value.extra?.referencedBindings, derivation, value);\n        }\n      } else {\n        translateVar(tag, value);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an constant binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#const\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/const.d.marko\"\n};\n\n// src/core/debug.ts\nvar import_babel_utils12 = require(\"@marko/babel-utils\");\nvar import_compiler20 = require(\"@marko/compiler\");\nvar debug_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils12.assertNoVar)(tag);\n    (0, import_babel_utils12.assertNoArgs)(tag);\n    (0, import_babel_utils12.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (tag.node.attributes.length > 1 || tag.node.attributes.length === 1 && (!import_compiler20.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\")) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `debug` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const referencedBindings = valueAttr?.value.extra?.referencedBindings;\n      const statement = withPreviousLocation(import_compiler20.types.debuggerStatement(), tag.node);\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Debug on value change.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#debug\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/debug.d.marko\"\n};\n\n// src/core/define.ts\nvar import_babel_utils19 = require(\"@marko/babel-utils\");\nvar import_compiler29 = require(\"@marko/compiler\");\n\n// src/util/translate-attrs.ts\nvar import_babel_utils18 = require(\"@marko/babel-utils\");\nvar import_compiler28 = require(\"@marko/compiler\");\n\n// src/core/for.ts\nvar import_babel_utils16 = require(\"@marko/babel-utils\");\nvar import_compiler26 = require(\"@marko/compiler\");\n\n// src/util/get-parent-tag.ts\nfunction getParentTag(tag) {\n  const parent = tag.parent.type === \"MarkoTagBody\" ? tag.parentPath.parentPath : tag.parentPath;\n  if (parent.type === \"MarkoTag\") {\n    return parent;\n  }\n}\n\n// src/visitors/tag/native-tag.ts\nvar import_babel_utils15 = require(\"@marko/babel-utils\");\nvar import_compiler25 = require(\"@marko/compiler\");\n\n// src/util/evaluate.ts\nvar import_babel_utils13 = require(\"@marko/babel-utils\");\nfunction evaluate(path4) {\n  let { extra } = path4.node;\n  if (!extra) {\n    extra = path4.node.extra = {};\n  }\n  if (extra.confident === void 0) {\n    const computed = (0, import_babel_utils13.computeNode)(path4.node.value);\n    if (computed) {\n      extra.computed = computed.value;\n      extra.confident = true;\n    } else {\n      extra.computed = void 0;\n      extra.confident = false;\n    }\n  }\n  return extra;\n}\n\n// src/util/to-property-name.ts\nvar import_compiler21 = require(\"@marko/compiler\");\nvar IDENTIFIER_REG = /^[0-9A-Z_$]+$/i;\nfunction toPropertyName(name) {\n  return IDENTIFIER_REG.test(name) ? import_compiler21.types.identifier(name) : import_compiler21.types.stringLiteral(name);\n}\n\n// src/visitors/assignment-expression.ts\nvar import_compiler22 = require(\"@marko/compiler\");\nvar assignment_expression_default = {\n  translate: {\n    exit(assignment) {\n      if (isOutputDOM()) {\n        handleDestructure2(assignment, assignment.node.left);\n      }\n    }\n  }\n};\nfunction handleDestructure2(assignment, node) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        handleDestructure2(assignment, prop);\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const i in node.elements) {\n        if (node.elements[i] === null) continue;\n        handleDestructure2(assignment, node.elements[i]);\n      }\n      break;\n    case \"RestElement\":\n      handleDestructure2(assignment, node.argument);\n      break;\n    case \"ObjectProperty\":\n      handleDestructure2(assignment, node.value);\n      break;\n    case \"Identifier\": {\n      const source = node.extra?.source;\n      if (source) {\n        const section = getSection(assignment);\n        (currentProgramPath.node.extra.assignments ??= []).push([\n          section,\n          assignment\n        ]);\n      }\n      break;\n    }\n  }\n}\n\n// src/visitors/function.ts\nvar import_babel_utils14 = require(\"@marko/babel-utils\");\nvar import_compiler23 = require(\"@marko/compiler\");\nvar functionIdsBySection = /* @__PURE__ */ new WeakMap();\nvar registeredFunctions = /* @__PURE__ */ new WeakSet();\nvar function_default = {\n  analyze(fn) {\n    const markoRoot = getMarkoRoot(fn);\n    const isStatic2 = !markoRoot || markoRoot.isMarkoScriptlet({ static: true });\n    if (!isFunction(fn, isStatic2)) return;\n    if (markoRoot && (markoRoot.isMarkoPlaceholder() || markoRoot.isMarkoScriptlet({ target: \"server\" }))) {\n      return;\n    }\n    const { node } = fn;\n    const extra = node.extra ??= {};\n    const name = extra.name = fn.node.id?.name || (isMarkoAttribute(markoRoot) ? markoRoot.node.default ? import_compiler23.types.toIdentifier(\n      markoRoot.parentPath.has(\"var\") ? markoRoot.parentPath.get(\"var\") : markoRoot.parentPath.get(\"name\")\n    ) : markoRoot.node.name : \"anonymous\");\n    if (isMarkoAttribute(markoRoot) && ((0, import_babel_utils14.isNativeTag)(markoRoot.parentPath) && /^on[A-Z-]/.test(markoRoot.node.name) || isCoreTagName(markoRoot.parentPath, \"effect\") || isCoreTagName(markoRoot.parentPath, \"lifecycle\") || isCoreTagName(markoRoot.parentPath, \"for\") || isCoreTagName(markoRoot.parentPath, \"do\"))) {\n      return;\n    }\n    const {\n      markoOpts,\n      opts: { filename }\n    } = currentProgramPath.hub.file;\n    const section = getSection(fn);\n    let functionNameCounts = functionIdsBySection.get(section);\n    if (!functionNameCounts) {\n      functionNameCounts = /* @__PURE__ */ new Map();\n      functionIdsBySection.set(section, functionNameCounts);\n    }\n    const index = functionNameCounts.get(name);\n    let id = \"\";\n    if (index === void 0) {\n      functionNameCounts.set(name, 0);\n    } else {\n      id = `_${index}`;\n    }\n    extra.registerId = (0, import_babel_utils14.getTemplateId)(\n      markoOpts,\n      filename,\n      `${section.id}/${name + id}`\n    );\n  },\n  translate: {\n    exit(fn) {\n      const markoRoot = getMarkoRoot(fn);\n      const isStatic2 = !markoRoot || markoRoot.isMarkoScriptlet({ static: true });\n      if (!isFunction(fn, isStatic2)) return;\n      const { node } = fn;\n      const { extra } = node;\n      if (!extra?.registerId) return;\n      if (registeredFunctions.has(node)) return;\n      const section = getSection(fn);\n      if (!section) return;\n      registeredFunctions.add(node);\n      if (isOutputHTML()) {\n        const serializedScopeProperties = getSerializedScopeProperties(section);\n        forEach(extra.referencedBindings, (ref) => {\n          serializedScopeProperties.set(\n            getScopeAccessorLiteral(ref),\n            import_compiler23.types.identifier(ref.name)\n          );\n        });\n        if (import_compiler23.types.isFunctionDeclaration(node)) {\n          currentProgramPath.unshiftContainer(\n            \"body\",\n            import_compiler23.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                node.id,\n                import_compiler23.types.stringLiteral(extra.registerId),\n                isStatic2 ? void 0 : getScopeIdIdentifier(section)\n              )\n            )\n          )[0].skip();\n        } else {\n          const replacement = callRuntime(\n            \"register\",\n            node,\n            import_compiler23.types.stringLiteral(extra.registerId),\n            isStatic2 ? void 0 : getScopeIdIdentifier(section)\n          );\n          if (isMarko(fn.parentPath)) {\n            replacement.extra = node.extra;\n          }\n          fn.replaceWith(replacement)[0].skip();\n        }\n      } else {\n        const { referencedBindings } = extra;\n        const fnId = currentProgramPath.scope.generateUidIdentifier(extra.name);\n        if (import_compiler23.types.isFunctionDeclaration(node)) {\n          currentProgramPath.unshiftContainer(\n            \"body\",\n            import_compiler23.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                import_compiler23.types.stringLiteral(extra.registerId),\n                node.id\n              )\n            )\n          )[0].skip();\n        } else if (isStatic2) {\n          const replacement = callRuntime(\n            \"register\",\n            import_compiler23.types.stringLiteral(extra.registerId),\n            node\n          );\n          if (isMarko(fn.parentPath)) {\n            replacement.extra = node.extra;\n          }\n          fn.replaceWith(replacement)[0].skip();\n        } else {\n          const replacement = import_compiler23.types.callExpression(fnId, [scopeIdentifier]);\n          if (isMarko(fn.parentPath)) {\n            replacement.extra = node.extra;\n          }\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler23.types.variableDeclaration(\"const\", [\n              import_compiler23.types.variableDeclarator(\n                fnId,\n                callRuntime(\n                  \"register\",\n                  import_compiler23.types.stringLiteral(extra.registerId),\n                  import_compiler23.types.arrowFunctionExpression(\n                    [scopeIdentifier],\n                    referencedBindings ? import_compiler23.types.blockStatement([\n                      import_compiler23.types.variableDeclaration(\"const\", [\n                        import_compiler23.types.variableDeclarator(\n                          createScopeReadPattern(\n                            section,\n                            referencedBindings\n                          ),\n                          scopeIdentifier\n                        )\n                      ]),\n                      import_compiler23.types.returnStatement(node)\n                    ]) : node\n                  )\n                )\n              )\n            ])\n          )[0].skip();\n          fn.replaceWith(replacement)[0].skip();\n        }\n      }\n    }\n  }\n};\nfunction isFunction(fn, isStatic2) {\n  switch (fn.node.type) {\n    case \"FunctionDeclaration\":\n      return isStatic2;\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isMarkoAttribute(path4) {\n  return path4 ? path4.isMarkoAttribute() : false;\n}\n\n// src/visitors/update-expression.ts\nvar import_compiler24 = require(\"@marko/compiler\");\nvar update_expression_default = {\n  translate: {\n    exit(expr) {\n      if (isOutputDOM()) {\n        const source = expr.node.argument.extra?.source;\n        if (source) {\n          const section = getSection(expr);\n          (currentProgramPath.node.extra.assignments ??= []).push([\n            section,\n            expr\n          ]);\n        }\n      }\n    }\n  }\n};\n\n// src/visitors/tag/native-tag.ts\nvar kNativeTagBinding = Symbol(\"native tag binding\");\nvar kSerializeMarker = Symbol(\"serialize marker\");\nvar kGetterId = Symbol(\"node getter id\");\nvar htmlSelectArgs = /* @__PURE__ */ new WeakMap();\nfunction assertExclusiveControllableGroups(tag, attrs2) {\n  const exclusiveGroups = [\n    attrs2.open || attrs2.openChange,\n    attrs2.checked || attrs2.checkedChange,\n    attrs2.checkedValue || attrs2.checkedValueChange,\n    attrs2.valueChange\n  ].filter(Boolean);\n  if (exclusiveGroups.length > 1) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The attributes ${exclusiveGroups.map((attr2) => `\"${attr2.name}\"`).join(\", \")} are mutually exclusive.`\n    );\n  }\n}\nfunction getRelatedControllable(tagName, attrs2) {\n  switch (tagName) {\n    case \"input\":\n      if (attrs2.checked || attrs2.checkedChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_checked\",\n          attrs: [attrs2.checked, attrs2.checkedChange]\n        };\n      }\n      if (attrs2.checkedValue || attrs2.checkedValueChange) {\n        return {\n          special: true,\n          helper: \"controllable_input_checkedValue\",\n          attrs: [attrs2.checkedValue, attrs2.checkedValueChange, attrs2.value]\n        };\n      }\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"select\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_select_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"textarea\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_textarea_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"details\":\n    case \"dialog\":\n      if (attrs2.open || attrs2.openChange) {\n        return {\n          special: false,\n          helper: \"controllable_detailsOrDialog_open\",\n          attrs: [attrs2.open, attrs2.openChange]\n        };\n      }\n      break;\n  }\n}\nvar native_tag_default = {\n  transform: {\n    enter(tag) {\n      const tagName = getTagName(tag);\n      if (tagName === \"textarea\" && tag.node.body.body.length) {\n        const parts = [];\n        for (const child of tag.node.body.body) {\n          if (child.type === \"MarkoText\" || child.type === \"MarkoPlaceholder\" && child.escape) {\n            parts.push(child.value);\n          } else {\n            throw tag.hub.file.hub.buildError(\n              child,\n              \"Unexpected content in textarea, only text and placeholders are supported.\",\n              SyntaxError\n            );\n          }\n        }\n        tag.node.attributes.push(\n          import_compiler25.types.markoAttribute(\n            \"value\",\n            toTemplateOrStringLiteral(parts) || buildUndefined()\n          )\n        );\n        tag.node.body.body = [];\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils15.assertNoArgs)(tag);\n      (0, import_babel_utils15.assertNoParams)(tag);\n      (0, import_babel_utils15.assertNoAttributeTags)(tag);\n      const { node } = tag;\n      if (node.var && !import_compiler25.types.isIdentifier(node.var)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"Tag variables on native elements cannot be destructured.\"\n        );\n      }\n      const tagName = getTagName(tag);\n      const section = getOrCreateSection(tag);\n      let hasEventHandlers = false;\n      let hasDynamicAttributes = false;\n      const seen = {};\n      const { attributes } = tag.node;\n      let relatedControllable;\n      let spreadReferenceNodes;\n      for (let i = attributes.length; i--; ) {\n        const attr2 = attributes[i];\n        if (import_compiler25.types.isMarkoAttribute(attr2)) {\n          if (seen[attr2.name]) {\n            dropReferences(attr2.value);\n            continue;\n          }\n          seen[attr2.name] = attr2;\n          if (isEventHandler(attr2.name) || isChangeHandler(attr2.name)) {\n            (attr2.value.extra ??= {}).isEffect = true;\n            hasEventHandlers = true;\n          } else if (!evaluate(tag.get(\"attributes\")[i]).confident) {\n            hasDynamicAttributes = true;\n          }\n        } else if (import_compiler25.types.isMarkoSpreadAttribute(attr2)) {\n          hasEventHandlers = true;\n          hasDynamicAttributes = true;\n          (attr2.value.extra ??= {}).isEffect = true;\n        }\n        if (spreadReferenceNodes) {\n          spreadReferenceNodes.push(attr2.value);\n        } else if (import_compiler25.types.isMarkoSpreadAttribute(attr2)) {\n          spreadReferenceNodes = [attr2.value];\n          relatedControllable = getRelatedControllable(tagName, seen);\n        }\n      }\n      assertExclusiveControllableGroups(tag, seen);\n      if (spreadReferenceNodes) {\n        if (relatedControllable && !relatedControllable.attrs.every(Boolean)) {\n          for (const attr2 of relatedControllable.attrs) {\n            if (attr2) {\n              spreadReferenceNodes.push(attr2.value);\n            }\n          }\n          relatedControllable = void 0;\n        }\n        mergeReferences(section, tag.node, spreadReferenceNodes);\n      } else {\n        relatedControllable = getRelatedControllable(tagName, seen);\n      }\n      if (relatedControllable) {\n        mergeReferences(\n          section,\n          relatedControllable.attrs.find(Boolean),\n          relatedControllable.attrs.map((it) => it?.value)\n        );\n      }\n      if (node.var || hasEventHandlers || hasDynamicAttributes) {\n        currentProgramPath.node.extra.isInteractive ||= hasEventHandlers;\n        const tagName2 = node.name.type === \"StringLiteral\" ? node.name.value : import_compiler25.types.toIdentifier(tag.get(\"name\"));\n        const tagExtra = node.extra ??= {};\n        const bindingName = \"#\" + tagName2;\n        tagExtra[kSerializeMarker] = hasEventHandlers || !!node.var;\n        tagExtra[kNativeTagBinding] = createBinding(\n          bindingName,\n          0 /* dom */,\n          section\n        );\n        if (node.var) {\n          for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n            if (!ref.parentPath?.isCallExpression()) {\n              tagExtra[kGetterId] = getRegisterUID(section, bindingName);\n              break;\n            }\n          }\n        }\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagName = getTagName(tag);\n      const extra = tag.node.extra;\n      const nodeRef2 = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const name = tag.get(\"name\");\n      const tagDef = (0, import_babel_utils15.getTagDef)(tag);\n      const write2 = writeTo(tag);\n      const section = getSection(tag);\n      if (isHTML && extra.tagNameNullable) {\n        flushBefore(tag);\n      }\n      if (tag.has(\"var\")) {\n        const getterId = extra[kGetterId];\n        if (isHTML) {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          for (const reference of references) {\n            let currentSection = getSection(reference);\n            while (currentSection !== section && currentSection.parent) {\n              getSerializedScopeProperties(currentSection).set(\n                import_compiler25.types.stringLiteral(\"_\"),\n                callRuntime(\n                  \"ensureScopeWithId\",\n                  getScopeIdIdentifier(\n                    currentSection = currentSection.parent\n                  )\n                )\n              );\n            }\n          }\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(section),\n              getterId && import_compiler25.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n              `get_${varName}`\n            );\n            currentProgramPath.pushContainer(\n              \"body\",\n              import_compiler25.types.variableDeclaration(\"const\", [\n                import_compiler25.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler25.types.stringLiteral(getterId),\n                    getScopeAccessorLiteral(nodeRef2)\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (reference.parentPath?.isCallExpression()) {\n              reference.parentPath.replaceWith(\n                import_compiler25.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, nodeRef2)\n                )\n              );\n            } else if (getterFnIdentifier) {\n              reference.replaceWith(\n                import_compiler25.types.callExpression(getterFnIdentifier, [\n                  getScopeExpression(referenceSection, getSection(tag))\n                ])\n              );\n            }\n          }\n        }\n      }\n      let visitAccessor;\n      if (nodeRef2) {\n        visitAccessor = getScopeAccessorLiteral(nodeRef2);\n        visit(tag, 32 /* Get */);\n      }\n      write2`<${name.node}`;\n      const usedAttrs = getUsedAttrs(tagName, tag.node);\n      const { staticAttrs, staticControllable, skipExpression } = usedAttrs;\n      let { spreadExpression } = usedAttrs;\n      if (staticControllable) {\n        const { helper, attrs: attrs2 } = staticControllable;\n        const changeAttr = attrs2[1];\n        const firstAttr = attrs2.find(Boolean);\n        const referencedBindings = firstAttr.value.extra?.referencedBindings;\n        if (changeAttr) {\n          tag.get(\"attributes\").find((it) => it.node === changeAttr).traverse(HoistVisitors);\n        }\n        const values = attrs2.map((attr2) => attr2?.value);\n        if (isHTML) {\n          if (tagName !== \"select\" && tagName !== \"textarea\") {\n            write2`${callRuntime(helper, getScopeIdIdentifier(section), visitAccessor, ...values)}`;\n          }\n          addHTMLEffectCall(section, void 0);\n        } else {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            import_compiler25.types.expressionStatement(\n              callRuntime(helper, scopeIdentifier, visitAccessor, ...values)\n            )\n          );\n          addStatement(\n            \"effect\",\n            section,\n            void 0,\n            import_compiler25.types.expressionStatement(\n              callRuntime(`${helper}_effect`, scopeIdentifier, visitAccessor)\n            )\n          );\n        }\n      }\n      let writeAtStartOfBody;\n      if (isHTML) {\n        if (tagName === \"select\") {\n          if (staticControllable) {\n            htmlSelectArgs.set(tag.node, {\n              value: staticControllable.attrs[0]?.value || buildUndefined(),\n              valueChange: staticControllable.attrs[1]?.value || buildUndefined()\n            });\n          } else if (spreadExpression) {\n            const spreadIdentifier = tag.scope.generateUidIdentifier(\"select_input\");\n            tag.insertBefore(\n              import_compiler25.types.variableDeclaration(\"const\", [\n                import_compiler25.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            htmlSelectArgs.set(tag.node, {\n              value: import_compiler25.types.memberExpression(\n                spreadIdentifier,\n                import_compiler25.types.identifier(\"value\")\n              ),\n              valueChange: import_compiler25.types.memberExpression(\n                spreadIdentifier,\n                import_compiler25.types.identifier(\"valueChange\")\n              )\n            });\n            spreadExpression = spreadIdentifier;\n          }\n        } else if (tagName === \"textarea\") {\n          let value;\n          let valueChange;\n          if (staticControllable) {\n            value = staticControllable.attrs[0]?.value;\n            valueChange = staticControllable.attrs[1]?.value;\n          } else if (spreadExpression) {\n            const spreadIdentifier = tag.scope.generateUidIdentifier(\"textarea_input\");\n            tag.insertBefore(\n              import_compiler25.types.variableDeclaration(\"const\", [\n                import_compiler25.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            value = import_compiler25.types.memberExpression(spreadIdentifier, import_compiler25.types.identifier(\"value\"));\n            valueChange = import_compiler25.types.memberExpression(\n              spreadIdentifier,\n              import_compiler25.types.identifier(\"valueChange\")\n            );\n            spreadExpression = spreadIdentifier;\n          }\n          if (value || valueChange) {\n            writeAtStartOfBody = callRuntime(\n              \"controllable_textarea_value\",\n              getScopeIdIdentifier(getSection(tag)),\n              getScopeAccessorLiteral(nodeRef2),\n              value,\n              valueChange\n            );\n          }\n        }\n      }\n      for (const attr2 of staticAttrs) {\n        const { name: name2, value } = attr2;\n        const { confident, computed } = attr2.extra ?? {};\n        const valueReferences = value.extra?.referencedBindings;\n        if (isHTML && tagName === \"option\" && name2 === \"value\") {\n          write2`${callRuntime(\"optionValueAttr\", value)}`;\n          continue;\n        }\n        switch (name2) {\n          case \"class\":\n          case \"style\": {\n            const helper = `${name2}Attr`;\n            if (confident) {\n              write2`${getHTMLRuntime()[helper](computed)}`;\n            } else if (isHTML) {\n              write2`${callRuntime(helper, value)}`;\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler25.types.expressionStatement(\n                  callRuntime(\n                    helper,\n                    import_compiler25.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n          }\n          default:\n            if (confident) {\n              write2`${getHTMLRuntime().attr(name2, computed)}`;\n            } else if (isHTML) {\n              if (isEventHandler(name2)) {\n                addHTMLEffectCall(section, valueReferences);\n              } else {\n                write2`${callRuntime(\"attr\", import_compiler25.types.stringLiteral(name2), value)}`;\n              }\n            } else if (isEventHandler(name2)) {\n              addStatement(\n                \"effect\",\n                section,\n                valueReferences,\n                import_compiler25.types.expressionStatement(\n                  callRuntime(\n                    \"on\",\n                    import_compiler25.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler25.types.stringLiteral(getEventHandlerName(name2)),\n                    value\n                  )\n                ),\n                value\n              );\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler25.types.expressionStatement(\n                  callRuntime(\n                    \"attr\",\n                    import_compiler25.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler25.types.stringLiteral(name2),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n        }\n      }\n      if (spreadExpression) {\n        if (isHTML) {\n          addHTMLEffectCall(section, extra.referencedBindings);\n          if (skipExpression) {\n            write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(section), name.node)}`;\n          } else {\n            write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(section), name.node)}`;\n          }\n        } else {\n          if (skipExpression) {\n            addStatement(\n              \"render\",\n              section,\n              extra.referencedBindings,\n              import_compiler25.types.expressionStatement(\n                callRuntime(\n                  \"partialAttrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression,\n                  skipExpression\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              extra.referencedBindings,\n              import_compiler25.types.expressionStatement(\n                callRuntime(\n                  \"attrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression\n                )\n              )\n            );\n          }\n          addStatement(\n            \"effect\",\n            section,\n            extra.referencedBindings,\n            import_compiler25.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            spreadExpression\n          );\n        }\n      }\n      if (tagDef && tagDef.parseOptions?.openTagOnly) {\n        switch (tagDef.htmlType) {\n          case \"svg\":\n          case \"math\":\n            write2`/>`;\n            break;\n          default:\n            write2`>`;\n            break;\n        }\n      } else {\n        write2`>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(import_compiler25.types.ifStatement(name.node, consumeHTML(tag)))[0].skip();\n      }\n      if (writeAtStartOfBody) {\n        write2`${writeAtStartOfBody}`;\n      }\n      enter2(tag);\n    },\n    exit(tag) {\n      const extra = tag.node.extra;\n      const nodeRef2 = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const openTagOnly = (0, import_babel_utils15.getTagDef)(tag)?.parseOptions?.openTagOnly;\n      const selectArgs = isHTML && htmlSelectArgs.get(tag.node);\n      if (isHTML && extra.tagNameNullable) {\n        flushInto(tag);\n      }\n      if (selectArgs) {\n        writeTo(tag)`</${tag.node.name}>`;\n        flushInto(tag);\n        tag.insertBefore(\n          import_compiler25.types.expressionStatement(\n            callRuntime(\n              \"controllable_select_value\",\n              getScopeIdIdentifier(getSection(tag)),\n              getScopeAccessorLiteral(nodeRef2),\n              selectArgs.value,\n              selectArgs.valueChange,\n              import_compiler25.types.arrowFunctionExpression(\n                [],\n                import_compiler25.types.blockStatement(tag.node.body.body)\n              )\n            )\n          )\n        );\n      } else {\n        tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n      }\n      if (!openTagOnly && !selectArgs) {\n        writeTo(tag)`</${tag.node.name}>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(\n          import_compiler25.types.ifStatement(tag.node.name, consumeHTML(tag))\n        )[0].skip();\n      }\n      if (nodeRef2 && (extra[kSerializeMarker] || tag.node.attributes.some(\n        (attr2) => isStatefulReferences(attr2.value.extra?.referencedBindings)\n      ))) {\n        markNode(tag, nodeRef2);\n      }\n      exit2(tag);\n      tag.remove();\n    }\n  }\n};\nfunction getUsedAttrs(tagName, tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  let staticControllable;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler25.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n        staticControllable = getRelatedControllable(tagName, seen);\n        if (staticControllable && !staticControllable.attrs.every(Boolean)) {\n          for (const attr3 of staticControllable.attrs) {\n            if (attr3) {\n              spreadProps.push(attrToObjectProperty(attr3));\n              maybeStaticAttrs.delete(attr3);\n            }\n          }\n          staticControllable = void 0;\n        }\n      }\n      spreadProps.push(import_compiler25.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(attrToObjectProperty(attr2));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  if (!spreadProps) {\n    staticControllable = getRelatedControllable(tagName, seen);\n    if (staticControllable?.special === false && !staticControllable.attrs[1]) {\n      staticControllable = void 0;\n    }\n  }\n  if (staticControllable) {\n    for (const attr2 of staticControllable.attrs) {\n      if (attr2) {\n        maybeStaticAttrs.delete(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    if (staticControllable) {\n      for (const attr2 of staticControllable.attrs) {\n        if (attr2) {\n          (skipProps ||= []).push(\n            import_compiler25.types.objectProperty(toPropertyName(attr2.name), import_compiler25.types.numericLiteral(1))\n          );\n        }\n      }\n    }\n    for (const { name } of staticAttrs) {\n      (skipProps ||= []).push(\n        import_compiler25.types.objectProperty(toPropertyName(name), import_compiler25.types.numericLiteral(1))\n      );\n    }\n    if (skipProps) {\n      skipExpression = import_compiler25.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    staticControllable,\n    spreadExpression,\n    skipExpression\n  };\n}\nfunction isChangeHandler(propName) {\n  return /^(?:value|checked(?:Values?)?|open)Change/.test(propName);\n}\nfunction attrToObjectProperty(attr2) {\n  return import_compiler25.types.objectProperty(toPropertyName(attr2.name), attr2.value);\n}\nvar HoistVisitors = {\n  Function: function_default.translate,\n  UpdateExpression: update_expression_default.translate,\n  AssignmentExpression: assignment_expression_default.translate\n};\nfunction buildUndefined() {\n  return import_compiler25.types.unaryExpression(\"void\", import_compiler25.types.numericLiteral(0));\n}\n\n// src/core/for.ts\nvar kForMarkerBinding = Symbol(\"for marker binding\");\nvar kForScopeStartIndex = Symbol(\"for scope start index\");\nvar kOnlyChildInParent = Symbol(\"only child in parent\");\nvar for_default = {\n  analyze(tag) {\n    const tagExtra = tag.node.extra ??= {};\n    const isAttrTag = tag.node.body.attributeTags;\n    let allowAttrs;\n    (0, import_babel_utils16.assertNoVar)(tag);\n    (0, import_babel_utils16.assertNoArgs)(tag);\n    assertNoSpreadAttrs(tag);\n    switch (getForType(tag.node)) {\n      case \"of\":\n        allowAttrs = [\"of\"];\n        break;\n      case \"in\":\n        allowAttrs = [\"in\"];\n        break;\n      case \"to\":\n        allowAttrs = [\"to\", \"from\", \"step\"];\n        break;\n      default:\n        throw tag.buildCodeFrameError(\n          \"Invalid `for` tag, missing an `of=`, `in=`, `to=` attribute.\"\n        );\n    }\n    if (!isAttrTag) {\n      allowAttrs.push(\"by\");\n    }\n    (0, import_babel_utils16.assertAllowedAttributes)(tag, allowAttrs);\n    if (isAttrTag) return;\n    const tagBody = tag.get(\"body\");\n    const bodySection = startSection(tagBody);\n    if (!bodySection) {\n      dropReferences(getAllTagReferenceNodes(tag.node));\n      return;\n    }\n    const section = getOrCreateSection(tag);\n    if (isOnlyChildInParent(tag)) {\n      const parentTag = getParentTag(tag).node;\n      const parentTagName = parentTag.name?.value;\n      (parentTag.extra ??= {})[kNativeTagBinding] ??= createBinding(\n        \"#\" + parentTagName,\n        0 /* dom */,\n        section\n      );\n    } else {\n      tagExtra[kForMarkerBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section\n      );\n    }\n    trackParamsReferences(tagBody, 3 /* param */, void 0, tagExtra);\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n    bodySection.upstreamExpression = tagExtra;\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        const tagExtra = tag.node.extra;\n        const isStateful = isStatefulReferences(tagExtra.referencedBindings);\n        setSectionParentIsOwner(bodySection, true);\n        if (!isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n        flushBefore(tag);\n        if (isStateful && !bodySection.content?.singleChild) {\n          tagExtra[kForScopeStartIndex] = tag.scope.generateUidIdentifier(\"k\");\n          writeTo(tagBody)`${callRuntime(\n            \"markResumeScopeStart\",\n            getScopeIdIdentifier(bodySection),\n            import_compiler26.types.updateExpression(\"++\", tagExtra[kForScopeStartIndex])\n          )}`;\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const isStateful = isStatefulReferences(tagExtra.referencedBindings);\n        const parentTag = getParentTag(tag);\n        const nodeRef2 = isOnlyChildInParent(tag) ? parentTag.node.extra[kNativeTagBinding] : tag.node.extra[kForMarkerBinding];\n        const forAttrs = getKnownAttrValues(node);\n        const forType = getForType(node);\n        const params = node.body.params;\n        const statements = [];\n        const bodyStatements = node.body.body;\n        const hasStatefulClosures = checkStatefulClosures(bodySection, true);\n        let keyExpression;\n        if (isStateful && isOnlyChildInParent(tag)) {\n          parentTag.node.extra[kSerializeMarker] = true;\n        }\n        if (tagExtra[kForScopeStartIndex]) {\n          statements.push(\n            import_compiler26.types.variableDeclaration(\"let\", [\n              import_compiler26.types.variableDeclarator(\n                tagExtra[kForScopeStartIndex],\n                import_compiler26.types.numericLiteral(0)\n              )\n            ])\n          );\n        }\n        if (isStateful || hasStatefulClosures) {\n          const singleNodeOptimization = bodySection.content === null || bodySection.content.singleChild;\n          const defaultParamNames = {\n            of: [\"list\", \"index\"],\n            in: [\"key\", \"value\"],\n            to: [\"value\"]\n          }[forType];\n          const defaultByParamIndex = forType === \"of\" ? 1 : 0;\n          const requiredParamsIndex = forAttrs.by ? defaultParamNames.length - 1 : defaultByParamIndex;\n          setForceResumeScope(bodySection);\n          for (let i = 0; i <= requiredParamsIndex; i++) {\n            const existingParam = params[i];\n            if (!existingParam || !import_compiler26.types.isIdentifier(existingParam)) {\n              const id = params[i] = currentProgramPath.scope.generateUidIdentifier(\n                defaultParamNames[i]\n              );\n              if (existingParam) {\n                bodyStatements.unshift(\n                  import_compiler26.types.variableDeclaration(\"let\", [\n                    import_compiler26.types.variableDeclarator(existingParam, id)\n                  ])\n                );\n              }\n            }\n          }\n          if (forAttrs.by) {\n            const byIdentifier = currentProgramPath.scope.generateUidIdentifier(\"by\");\n            statements.push(\n              import_compiler26.types.variableDeclaration(\"const\", [\n                import_compiler26.types.variableDeclarator(byIdentifier, forAttrs.by)\n              ])\n            );\n            keyExpression = import_compiler26.types.callExpression(\n              byIdentifier,\n              params\n            );\n          } else {\n            keyExpression = params[defaultByParamIndex];\n          }\n          const write2 = writeTo(tag);\n          const forScopeIdsIdentifier = tag.scope.generateUidIdentifier(\"forScopeIds\");\n          const forScopesIdentifier = getScopeIdentifier(bodySection);\n          statements.push(\n            import_compiler26.types.variableDeclaration(\n              \"const\",\n              [\n                isStateful && singleNodeOptimization && import_compiler26.types.variableDeclarator(\n                  forScopeIdsIdentifier,\n                  import_compiler26.types.arrayExpression([])\n                ),\n                import_compiler26.types.variableDeclarator(\n                  forScopesIdentifier,\n                  import_compiler26.types.newExpression(import_compiler26.types.identifier(\"Map\"), [])\n                )\n              ].filter(Boolean)\n            )\n          );\n          if (isStateful) {\n            if (singleNodeOptimization) {\n              bodyStatements.push(\n                import_compiler26.types.expressionStatement(\n                  import_compiler26.types.callExpression(\n                    import_compiler26.types.memberExpression(\n                      forScopeIdsIdentifier,\n                      import_compiler26.types.identifier(\"push\")\n                    ),\n                    [getScopeIdIdentifier(bodySection)]\n                  )\n                )\n              );\n              write2`${callRuntime(\n                \"markResumeControlSingleNodeEnd\",\n                getScopeIdIdentifier(tagSection),\n                getScopeAccessorLiteral(nodeRef2),\n                forScopeIdsIdentifier\n              )}`;\n            } else {\n              write2`${callRuntime(\n                \"markResumeControlEnd\",\n                getScopeIdIdentifier(tagSection),\n                getScopeAccessorLiteral(nodeRef2)\n              )}`;\n            }\n          }\n          getSerializedScopeProperties(tagSection).set(\n            import_compiler26.types.stringLiteral(\n              getScopeAccessorLiteral(nodeRef2).value + \"(\" /* LoopScopeMap */\n            ),\n            import_compiler26.types.conditionalExpression(\n              import_compiler26.types.memberExpression(forScopesIdentifier, import_compiler26.types.identifier(\"size\")),\n              forScopesIdentifier,\n              import_compiler26.types.identifier(\"undefined\")\n            )\n          );\n        }\n        flushInto(tag);\n        setSubscriberBuilder(tag, () => {\n        });\n        writeHTMLResumeStatements(tagBody);\n        if (keyExpression && (isStateful || hasStatefulClosures)) {\n          bodyStatements.push(\n            import_compiler26.types.expressionStatement(\n              import_compiler26.types.callExpression(\n                import_compiler26.types.memberExpression(\n                  getScopeIdentifier(bodySection),\n                  import_compiler26.types.identifier(\"set\")\n                ),\n                [\n                  keyExpression,\n                  callRuntime(\n                    \"getScopeById\",\n                    getScopeIdIdentifier(bodySection)\n                  )\n                ]\n              )\n            )\n          );\n        }\n        statements.push(\n          buildForRuntimeCall(forType, forAttrs, params, bodyStatements)\n        );\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        if (!isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const { referencedBindings } = tagExtra;\n        const nodeRef2 = isOnlyChildInParent(tag) ? getParentTag(tag).node.extra[kNativeTagBinding] : tag.node.extra[kForMarkerBinding];\n        setSubscriberBuilder(tag, (signal2) => {\n          return callRuntime(\n            \"inLoopScope\",\n            signal2,\n            getScopeAccessorLiteral(nodeRef2)\n          );\n        });\n        const forType = getForType(node);\n        const signal = getSignal(tagSection, nodeRef2, \"for\");\n        signal.build = () => {\n          return callRuntime(\n            forTypeToDOMRuntime(forType),\n            getScopeAccessorLiteral(nodeRef2),\n            import_compiler26.types.identifier(bodySection.name)\n          );\n        };\n        const params = node.body.params;\n        signal.hasDownstreamIntersections = () => {\n          if (bodySection.closures) {\n            return true;\n          }\n          for (const param of params) {\n            const binding = param.extra?.binding;\n            if (binding) {\n              for (const {\n                referencedBindings: referencedBindings2\n              } of binding.downstreamExpressions) {\n                if (getSignal(\n                  bodySection,\n                  referencedBindings2\n                ).hasDownstreamIntersections()) {\n                  return true;\n                }\n              }\n            }\n          }\n          return false;\n        };\n        const forAttrs = getKnownAttrValues(node);\n        const loopArgs = getBaseArgsInForTag(forType, forAttrs);\n        if (forAttrs.by) {\n          loopArgs.push(forAttrs.by);\n        }\n        addValue(\n          tagSection,\n          referencedBindings,\n          signal,\n          import_compiler26.types.arrayExpression(loopArgs)\n        );\n        tag.remove();\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  attributes: {\n    of: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over a list of items.\"\n        }\n      ]\n    },\n    in: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over the keys and values of an object.\"\n        }\n      ]\n    },\n    to: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates up to the provided number (inclusive)\"\n        }\n      ]\n    },\n    from: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates starting from the provided number (inclusive)\"\n        }\n      ]\n    },\n    step: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"The amount to increment during each interation (with from/to)\"\n        }\n      ]\n    }\n  },\n  autocomplete: [\n    {\n      snippet: \"for|${1:value, index}| of=${3:array}\",\n      description: \"Use to iterate over lists, object properties, or between ranges.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-a-list\"\n    },\n    {\n      snippet: \"for|${1:name, value}| in=${3:object}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties\"\n    },\n    {\n      snippet: \"for|${1:index}| to=${2:number}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers\"\n    }\n  ]\n};\nfunction buildForRuntimeCall(type, attrs2, params, statements) {\n  return import_compiler26.types.expressionStatement(\n    callRuntime(\n      forTypeToRuntime(type),\n      ...getBaseArgsInForTag(type, attrs2),\n      import_compiler26.types.arrowFunctionExpression(params, import_compiler26.types.blockStatement(statements))\n    )\n  );\n}\nfunction getForType(tag) {\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      switch (attr2.name) {\n        case \"of\":\n        case \"in\":\n        case \"to\":\n          return attr2.name;\n      }\n    }\n  }\n}\nfunction forTypeToRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"forOf\";\n    case \"in\":\n      return \"forIn\";\n    case \"to\":\n      return \"forTo\";\n  }\n}\nfunction forTypeToDOMRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"loopOf\";\n    case \"in\":\n      return \"loopIn\";\n    case \"to\":\n      return \"loopTo\";\n  }\n}\nfunction getBaseArgsInForTag(type, attrs2) {\n  switch (type) {\n    case \"in\":\n      return [attrs2.in];\n    case \"of\":\n      return [attrs2.of];\n    case \"to\":\n      return [\n        attrs2.to,\n        attrs2.from || import_compiler26.types.numericLiteral(0),\n        attrs2.step || import_compiler26.types.numericLiteral(1)\n      ];\n  }\n}\nfunction isOnlyChildInParent(tag) {\n  const extra = tag.node.extra;\n  if (extra[kOnlyChildInParent] !== void 0) {\n    return extra[kOnlyChildInParent];\n  }\n  const parentTag = getParentTag(tag);\n  if (parentTag && (0, import_babel_utils16.getTagDef)(parentTag)?.html) {\n    return extra[kOnlyChildInParent] = tag.parent.body.length === 1;\n  }\n  return extra[kOnlyChildInParent] = false;\n}\n\n// src/util/nested-attribute-tags.ts\nvar import_babel_utils17 = require(\"@marko/babel-utils\");\nvar import_compiler27 = require(\"@marko/compiler\");\nvar attrTagToIdentifierLookup = /* @__PURE__ */ new WeakMap();\nfunction getAttrTagIdentifier(meta) {\n  let name = attrTagToIdentifierLookup.get(meta);\n  if (!name) {\n    name = currentProgramPath.scope.generateUid(meta.name);\n    attrTagToIdentifierLookup.set(meta, name);\n  }\n  return import_compiler27.types.identifier(name);\n}\nfunction analyzeAttributeTags(tag) {\n  if (tag.node.extra?.attributeTags) return tag.node.extra.attributeTags;\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  if (!attrTags2.length) return;\n  const tagExtra = tag.node.extra ??= {};\n  const lookup = tagExtra.attributeTags = {};\n  const attrTagNodesByName = {};\n  const sampleAttrTagsForControlFlow = /* @__PURE__ */ new Map();\n  for (const child of attrTags2) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils17.isAttributeTag)(child)) {\n        const name = getTagName(child);\n        lookup[name] ||= createAttrTagMeta(name, [name]);\n        analyzeAttributeTags(child);\n      } else {\n        const isRepeated = (0, import_babel_utils17.isLoopTag)(child);\n        let curGroup;\n        for (const name of crawlAttrTags(child, attrTagNodesByName)) {\n          const oldMeta = lookup[name];\n          if (oldMeta) {\n            if (!curGroup) {\n              curGroup = oldMeta.group;\n            } else if (curGroup !== oldMeta.group) {\n              for (const name2 of oldMeta.group) {\n                lookup[name2].group = curGroup;\n                curGroup.push(name2);\n              }\n            }\n          }\n          let attrTagMeta = lookup[name];\n          if (!attrTagMeta) {\n            attrTagMeta = lookup[name] = createAttrTagMeta(name, []);\n            curGroup = attrTagMeta.group;\n            curGroup.push(name);\n          }\n          attrTagMeta.dynamic = true;\n          if (isRepeated) {\n            attrTagMeta.repeated = true;\n          }\n          sampleAttrTagsForControlFlow.set(child, name);\n        }\n      }\n    }\n  }\n  for (const [controlFlowTag, sampleAttrName] of sampleAttrTagsForControlFlow) {\n    (controlFlowTag.node.extra ??= {}).attributeTagGroup = lookup[sampleAttrName].group;\n  }\n  for (const name in attrTagNodesByName) {\n    const attrTagMeta = lookup[name];\n    if (!attrTagMeta.repeated) {\n      const attrTagNodes = attrTagNodesByName[name];\n      if (attrTagNodes.length > 1) {\n        attrTagMeta.repeated = !attrTagMeta.dynamic || hasRepeatedDynamicAttrTags(attrTagNodes);\n      }\n    }\n  }\n  return lookup;\n}\nfunction createAttrTagMeta(name, group) {\n  return {\n    name: name.slice(1),\n    dynamic: false,\n    repeated: false,\n    group\n  };\n}\nfunction crawlAttrTags(tag, attrTagNodesByName, attrTagNames = /* @__PURE__ */ new Set()) {\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  for (const child of attrTags2) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils17.isAttributeTag)(child)) {\n        const tagName = getTagName(child);\n        attrTagNames.add(tagName);\n        (attrTagNodesByName[tagName] ||= []).push(child);\n        analyzeAttributeTags(child);\n      } else {\n        crawlAttrTags(child, attrTagNodesByName, attrTagNames);\n      }\n    }\n  }\n  return attrTagNames;\n}\nfunction hasRepeatedDynamicAttrTags(attrTags2) {\n  let conditionRoot;\n  const seenBranches = /* @__PURE__ */ new Set();\n  for (const attrTag2 of attrTags2) {\n    const parentTag = getParentTag(attrTag2);\n    if (seenBranches.has(parentTag) || !isConditionTag(parentTag)) {\n      return true;\n    }\n    const curConditionRoot = getConditionRoot(parentTag);\n    if (curConditionRoot && curConditionRoot !== (conditionRoot ||= curConditionRoot)) {\n      return true;\n    }\n    seenBranches.add(parentTag);\n  }\n  return false;\n}\nfunction getConditionRoot(tag) {\n  if (getTagName(tag) === \"if\") return tag;\n  let prev = tag.getPrevSibling();\n  while (prev.node) {\n    if (prev.isMarkoTag() && getTagName(prev) === \"if\") {\n      return prev;\n    }\n    prev = prev.getPrevSibling();\n  }\n}\n\n// src/util/translate-attrs.ts\nvar renderBodyProps = /* @__PURE__ */ new WeakSet();\nfunction translateAttrs(tag, templateExports, statements = []) {\n  const seen = /* @__PURE__ */ new Set();\n  const properties = [];\n  const attrTagLookup = tag.node.extra?.attributeTags;\n  if (attrTagLookup) {\n    for (const name in attrTagLookup) {\n      const attrTagMeta = attrTagLookup[name];\n      if (usesExport(templateExports, attrTagMeta.name)) {\n        seen.add(attrTagMeta.name);\n        if (attrTagMeta.dynamic) {\n          statements.push(\n            import_compiler28.types.variableDeclaration(\"let\", [\n              import_compiler28.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta))\n            ])\n          );\n          properties.push(\n            import_compiler28.types.objectProperty(\n              toPropertyName(attrTagMeta.name),\n              getAttrTagIdentifier(attrTagMeta)\n            )\n          );\n        }\n      }\n    }\n    const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils18.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          if (attrTagMeta.dynamic) {\n            i = addDynamicAttrTagStatements(\n              attrTags2,\n              i,\n              attrTagLookup,\n              statements,\n              templateExports\n            );\n          } else {\n            const translatedAttrTag = translateAttrs(\n              child,\n              templateExports?.[attrTagMeta.name]?.props,\n              statements\n            );\n            if (attrTagMeta.repeated) {\n              const prevProp = findObjectProperty(attrTagMeta.name, properties);\n              if (prevProp) {\n                prevProp.value = callRuntime(\n                  \"attrTags\",\n                  prevProp.value,\n                  propsToExpression(translatedAttrTag.properties)\n                );\n              } else {\n                properties.push(\n                  import_compiler28.types.objectProperty(\n                    toPropertyName(attrTagMeta.name),\n                    callRuntime(\n                      \"attrTag\",\n                      propsToExpression(translatedAttrTag.properties)\n                    )\n                  )\n                );\n              }\n            } else {\n              properties.push(\n                import_compiler28.types.objectProperty(\n                  toPropertyName(attrTagMeta.name),\n                  callRuntime(\n                    \"attrTag\",\n                    propsToExpression(translatedAttrTag.properties)\n                  )\n                )\n              );\n            }\n          }\n        } else {\n          i = addDynamicAttrTagStatements(\n            attrTags2,\n            i,\n            attrTagLookup,\n            statements,\n            templateExports\n          );\n        }\n      }\n    }\n  }\n  if (!seen.has(\"renderBody\") && usesExport(templateExports, \"renderBody\")) {\n    seen.add(\"renderBody\");\n    const renderBodyExpression = buildRenderBody(tag.get(\"body\"));\n    if (renderBodyExpression) {\n      const renderBodyProp = import_compiler28.types.objectProperty(\n        import_compiler28.types.identifier(\"renderBody\"),\n        renderBodyExpression\n      );\n      renderBodyProps.add(renderBodyProp);\n      properties.push(renderBodyProp);\n    }\n  }\n  const { attributes } = tag.node;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler28.types.isMarkoSpreadAttribute(attr2)) {\n      properties.push(import_compiler28.types.spreadElement(value));\n    } else if (!seen.has(attr2.name) && usesExport(templateExports, attr2.name)) {\n      seen.add(attr2.name);\n      properties.push(import_compiler28.types.objectProperty(toPropertyName(attr2.name), value));\n    }\n  }\n  properties.reverse();\n  return { properties, statements };\n}\nfunction getTranslatedRenderBodyProperty(props) {\n  for (const prop of props) {\n    if (renderBodyProps.has(prop)) {\n      return prop;\n    }\n  }\n}\nfunction addDynamicAttrTagStatements(attrTags2, index, attrTagLookup, statements, templateExports) {\n  const tag = attrTags2[index];\n  if (tag.isMarkoTag()) {\n    if ((0, import_babel_utils18.isAttributeTag)(tag)) {\n      const attrTagMeta = attrTagLookup[getTagName(tag)];\n      if (usesExport(templateExports, attrTagMeta.name) && attrTagMeta.dynamic) {\n        const translatedAttrTag = translateAttrs(\n          tag,\n          templateExports?.[attrTagMeta.name]?.props,\n          statements\n        );\n        if (attrTagMeta.repeated) {\n          statements.push(\n            import_compiler28.types.expressionStatement(\n              import_compiler28.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTags\",\n                  getAttrTagIdentifier(attrTagMeta),\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        } else {\n          statements.push(\n            import_compiler28.types.expressionStatement(\n              import_compiler28.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTag\",\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        }\n      }\n    } else {\n      switch (getTagName(tag)) {\n        case \"if\":\n          return translateIfAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports\n          );\n        case \"for\": {\n          return translateForAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports\n          );\n        }\n      }\n    }\n  }\n  return index;\n}\nfunction propsToExpression(props) {\n  return props.length === 1 && import_compiler28.types.isSpreadElement(props[0]) ? props[0].argument : import_compiler28.types.objectExpression(props);\n}\nfunction translateForAttrTag(attrTags2, index, attrTagLookup, statements, templateExports) {\n  const forTag = attrTags2[index];\n  const bodyStatements = [];\n  addAllAttrTagsAsDynamic(\n    forTag,\n    attrTagLookup,\n    bodyStatements,\n    templateExports\n  );\n  statements.push(\n    buildForRuntimeCall(\n      getForType(forTag.node),\n      getKnownAttrValues(forTag.node),\n      forTag.node.body.params,\n      bodyStatements\n    )\n  );\n  return index;\n}\nfunction translateIfAttrTag(attrTags2, index, attrTagLookup, statements, templateExports) {\n  const ifTag = attrTags2[index];\n  const consequentStatements = [];\n  let ifStatement = import_compiler28.types.ifStatement(\n    getConditionTestValue(ifTag),\n    import_compiler28.types.blockStatement(consequentStatements)\n  );\n  statements.push(ifStatement);\n  addAllAttrTagsAsDynamic(\n    ifTag,\n    attrTagLookup,\n    consequentStatements,\n    templateExports\n  );\n  let nextIndex = index + 1;\n  while (nextIndex < attrTags2.length) {\n    const nextTag = attrTags2[nextIndex];\n    if (nextTag.isMarkoTag()) {\n      switch (getTagName(nextTag)) {\n        case \"else-if\":\n        case \"else\": {\n          const testValue = getConditionTestValue(nextTag);\n          const alternateStatements = [];\n          addAllAttrTagsAsDynamic(\n            nextTag,\n            attrTagLookup,\n            alternateStatements,\n            templateExports\n          );\n          if (testValue) {\n            ifStatement.alternate = ifStatement = import_compiler28.types.ifStatement(\n              testValue,\n              import_compiler28.types.blockStatement(alternateStatements)\n            );\n            nextIndex++;\n            continue;\n          } else {\n            ifStatement.alternate = import_compiler28.types.blockStatement(alternateStatements);\n            break;\n          }\n        }\n      }\n    }\n    break;\n  }\n  return nextIndex - 1;\n}\nfunction addAllAttrTagsAsDynamic(tag, attrTagLookup, statements, templateExports) {\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  for (let i = 0; i < attrTags2.length; i++) {\n    i = addDynamicAttrTagStatements(\n      attrTags2,\n      i,\n      attrTagLookup,\n      statements,\n      templateExports\n    );\n  }\n}\nfunction usesExport(templateExports, name) {\n  return !templateExports || !!templateExports[name];\n}\nfunction findObjectProperty(name, props) {\n  for (const prop of props) {\n    if (prop.type === \"ObjectProperty\") {\n      switch (prop.key.type) {\n        case \"StringLiteral\":\n          if (prop.key.value === name) {\n            return prop;\n          }\n          break;\n        case \"Identifier\":\n          if (prop.key.name === name) {\n            return prop;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\nfunction getConditionTestValue({\n  node: { attributes }\n}) {\n  return attributes.length === 1 ? attributes[0].value : void 0;\n}\nfunction buildRenderBody(body) {\n  const bodySection = body.node.extra?.section;\n  if (bodySection) {\n    if (isOutputHTML()) {\n      return callRuntime(\n        \"register\",\n        callRuntime(\n          \"createRenderer\",\n          import_compiler28.types.arrowFunctionExpression(\n            body.node.params,\n            import_compiler28.types.blockStatement(body.node.body)\n          )\n        ),\n        import_compiler28.types.stringLiteral(getResumeRegisterId(bodySection, \"renderer\")),\n        getScopeIdIdentifier(\n          getSection(\n            getNonAttributeTagParent(body.parentPath)\n          )\n        )\n      );\n    } else {\n      return import_compiler28.types.callExpression(import_compiler28.types.identifier(bodySection.name), [\n        scopeIdentifier\n      ]);\n    }\n  }\n}\nfunction getNonAttributeTagParent(tag) {\n  let cur = tag;\n  while ((0, import_babel_utils18.isAttributeTag)(cur) || (0, import_babel_utils18.isTransparentTag)(cur)) {\n    cur = getParentTag(cur);\n  }\n  return cur;\n}\n\n// src/core/define.ts\nvar define_default = {\n  analyze(tag) {\n    (0, import_babel_utils19.assertNoArgs)(tag);\n    if (!tag.node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `define` tag requires a tag variable.\");\n    }\n    const tagBody = tag.get(\"body\");\n    startSection(tagBody);\n    trackVarReferences(tag, 4 /* derived */);\n    trackParamsReferences(tagBody, 3 /* param */);\n    mergeReferences(\n      getOrCreateSection(tag),\n      tag.node,\n      getAllTagReferenceNodes(tag.node)\n    );\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const translatedAttrs = translateAttrs(tag);\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        tag.insertBefore(translatedAttrs.statements);\n        translateVar(tag, propsToExpression(translatedAttrs.properties));\n      } else {\n        const section = getSection(tag);\n        const referencedBindings = node.extra?.referencedBindings;\n        const derivation = initValue(tag.get(\"var\").node.extra.binding);\n        if (translatedAttrs.statements.length) {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            translatedAttrs.statements\n          );\n        }\n        addValue(\n          section,\n          referencedBindings,\n          derivation,\n          propsToExpression(translatedAttrs.properties)\n        );\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a constant object binding that can be rendered.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#define\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/define.d.marko\"\n};\n\n// src/core/do.ts\nvar import_babel_utils20 = require(\"@marko/babel-utils\");\nvar import_compiler30 = require(\"@marko/compiler\");\nvar do_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils20.assertNoArgs)(tag);\n    (0, import_babel_utils20.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils20.assertNoVar)(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `do` tag requires a value.\");\n    }\n    if (tag.node.attributes.length > 1 || !import_compiler30.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `do` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      let statement = null;\n      if (import_compiler30.types.isFunctionExpression(value) || import_compiler30.types.isArrowFunctionExpression(value)) {\n        if (import_compiler30.types.isBlockStatement(value.body)) {\n          let hasDeclaration = false;\n          for (const child of value.body.body) {\n            if (import_compiler30.types.isDeclaration(child)) {\n              hasDeclaration = true;\n              break;\n            }\n          }\n          statement = hasDeclaration ? value.body : value.body.body;\n        } else {\n          statement = import_compiler30.types.expressionStatement(value.body);\n        }\n      }\n      if (isOutputHTML()) {\n        if (statement) {\n          tag.insertBefore(statement);\n        } else {\n          tag.insertBefore(import_compiler30.types.expressionStatement(import_compiler30.types.callExpression(value, [])));\n        }\n      } else {\n        addStatement(\n          \"render\",\n          section,\n          referencedBindings,\n          statement ?? import_compiler30.types.expressionStatement(import_compiler30.types.callExpression(value, [scopeIdentifier]))\n        );\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to run a function on render.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#do\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/do.d.marko\"\n};\n\n// src/core/effect.ts\nvar import_babel_utils21 = require(\"@marko/babel-utils\");\nvar import_compiler31 = require(\"@marko/compiler\");\nvar effect_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    (0, import_babel_utils21.assertNoArgs)(tag);\n    (0, import_babel_utils21.assertNoVar)(tag);\n    (0, import_babel_utils21.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `effect` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler31.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `effect` tag only supports the `value` attribute.\"\n      );\n    }\n    (valueAttr.value.extra ??= {}).isEffect = true;\n    (currentProgramPath.node.extra ??= {}).isInteractive = true;\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      const section = getSection(tag);\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      if (isOutputDOM()) {\n        const { value: value2 } = valueAttr;\n        let inlineBody = null;\n        if (import_compiler31.types.isFunctionExpression(value2) || import_compiler31.types.isArrowFunctionExpression(value2)) {\n          if (import_compiler31.types.isBlockStatement(value2.body)) {\n            let hasDeclaration = false;\n            for (const child of value2.body.body) {\n              if (import_compiler31.types.isDeclaration(child)) {\n                hasDeclaration = true;\n                break;\n              }\n            }\n            inlineBody = hasDeclaration ? value2.body : value2.body.body;\n          } else {\n            inlineBody = import_compiler31.types.expressionStatement(value2.body);\n          }\n        }\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          inlineBody || import_compiler31.types.expressionStatement(import_compiler31.types.callExpression(value2, [scopeIdentifier])),\n          value2,\n          !!inlineBody\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/effect.d.marko\"\n};\n\n// src/core/export.ts\nvar import_babel_utils22 = require(\"@marko/babel-utils\");\nvar export_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils22.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"export <value>\"\n    }\n  ]\n};\n\n// src/core/html-comment.ts\nvar import_babel_utils23 = require(\"@marko/babel-utils\");\nvar import_compiler32 = require(\"@marko/compiler\");\nvar kCommentTagBinding = Symbol(\"comment tag binding\");\nvar kGetterId2 = Symbol(\"node getter id\");\nvar html_comment_default = {\n  analyze(tag) {\n    (0, import_babel_utils23.assertNoArgs)(tag);\n    (0, import_babel_utils23.assertNoParams)(tag);\n    (0, import_babel_utils23.assertNoAttributes)(tag);\n    const tagVar = tag.node.var;\n    let needsBinding = false;\n    let needsGetter = false;\n    if (tagVar) {\n      if (!import_compiler32.types.isIdentifier(tagVar)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"The `html-comment` tag variable cannot be destructured.\"\n        );\n      }\n      needsBinding = true;\n      for (const ref of tag.scope.getBinding(tagVar.name).referencePaths) {\n        if (!ref.parentPath?.isCallExpression()) {\n          needsGetter = true;\n          break;\n        }\n      }\n    }\n    const referenceNodes = [];\n    for (const child of tag.get(\"body\").get(\"body\")) {\n      if (child.isMarkoPlaceholder()) {\n        referenceNodes.push(child.node.value);\n        needsBinding = true;\n      } else if (!child.isMarkoText()) {\n        throw child.buildCodeFrameError(\n          \"Invalid child. Only text is allowed inside an html comment.\"\n        );\n      }\n    }\n    if (needsBinding) {\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      if (needsGetter) {\n        tagExtra[kGetterId2] = getRegisterUID(section, \"comment\");\n      }\n      tagExtra[kCommentTagBinding] = createBinding(\n        \"#comment\",\n        0 /* dom */,\n        section\n      );\n      mergeReferences(section, tag.node, referenceNodes);\n    }\n    tag.skip();\n  },\n  translate(tag) {\n    const tagExtra = tag.node.extra;\n    const commentBinding = tagExtra[kCommentTagBinding];\n    const hasVar = !!tag.node.var;\n    if (hasVar) {\n      const getterId = tagExtra[kGetterId2];\n      if (isOutputHTML()) {\n        translateVar(\n          tag,\n          callRuntime(\n            \"nodeRef\",\n            getterId && getScopeIdIdentifier(getSection(tag)),\n            getterId && import_compiler32.types.stringLiteral(getterId)\n          )\n        );\n      } else {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        let getterFnIdentifier;\n        if (getterId) {\n          getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n            `get_${varName}`\n          );\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler32.types.variableDeclaration(\"const\", [\n              import_compiler32.types.variableDeclarator(\n                getterFnIdentifier,\n                callRuntime(\n                  \"nodeRef\",\n                  import_compiler32.types.stringLiteral(getterId),\n                  getScopeAccessorLiteral(commentBinding)\n                )\n              )\n            ])\n          );\n        }\n        for (const reference of references) {\n          const referenceSection = getSection(reference);\n          if (reference.parentPath?.isCallExpression()) {\n            reference.parentPath.replaceWith(\n              import_compiler32.types.expressionStatement(\n                createScopeReadExpression(referenceSection, commentBinding)\n              )\n            );\n          } else if (getterFnIdentifier) {\n            reference.replaceWith(\n              import_compiler32.types.callExpression(getterFnIdentifier, [\n                getScopeExpression(referenceSection, getSection(tag))\n              ])\n            );\n          }\n        }\n      }\n    }\n    if (tagExtra[kCommentTagBinding]) {\n      visit(tag, 32 /* Get */);\n    }\n    const write2 = writeTo(tag);\n    enter2(tag);\n    write2`<!--`;\n    if (isOutputHTML()) {\n      for (const child of tag.node.body.body) {\n        if (import_compiler32.types.isMarkoText(child)) {\n          write2`${child.value}`;\n        } else if (import_compiler32.types.isMarkoPlaceholder(child)) {\n          write2`${callRuntime(\"escapeXML\", child.value)}`;\n        }\n      }\n    } else {\n      const templateQuasis = [];\n      const templateExpressions = [];\n      let currentQuasi = \"\";\n      for (const child of tag.node.body.body) {\n        if (import_compiler32.types.isMarkoText(child)) {\n          currentQuasi += child.value;\n        } else if (import_compiler32.types.isMarkoPlaceholder(child)) {\n          templateQuasis.push(import_compiler32.types.templateElement({ raw: currentQuasi }));\n          templateExpressions.push(child.value);\n          currentQuasi = \"\";\n        }\n      }\n      if (templateExpressions.length === 0) {\n        write2`${currentQuasi}`;\n      } else {\n        templateQuasis.push(import_compiler32.types.templateElement({ raw: currentQuasi }));\n        addStatement(\n          \"render\",\n          getSection(tag),\n          tagExtra.referencedBindings,\n          import_compiler32.types.expressionStatement(\n            callRuntime(\n              \"data\",\n              import_compiler32.types.memberExpression(\n                scopeIdentifier,\n                getScopeAccessorLiteral(commentBinding),\n                true\n              ),\n              import_compiler32.types.templateLiteral(templateQuasis, templateExpressions)\n            )\n          )\n        );\n      }\n    }\n    exit2(tag);\n    write2`-->`;\n    if (commentBinding) {\n      markNode(tag, commentBinding);\n    }\n    tag.remove();\n  },\n  parseOptions: {\n    // TODO: fix the types for Tag or parseOptions or something\n    text: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an html comment that is not stripped from the output.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#html-comment\"\n    }\n  ]\n};\n\n// src/core/id.ts\nvar import_babel_utils24 = require(\"@marko/babel-utils\");\nvar import_compiler33 = require(\"@marko/compiler\");\nvar id_default = {\n  analyze(tag) {\n    (0, import_babel_utils24.assertNoArgs)(tag);\n    (0, import_babel_utils24.assertNoParams)(tag);\n    (0, import_babel_utils24.assertNoAttributes)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils24.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `id` tag requires a tag variable.\");\n    }\n    if (!import_compiler33.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `id` tag cannot be destructured\");\n    }\n    trackVarReferences(tag, 4 /* derived */);\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const id = isOutputHTML() ? callRuntime(\"nextTagId\") : callRuntime(\"nextTagId\", scopeIdentifier);\n      if (isOutputHTML()) {\n        tag.replaceWith(\n          import_compiler33.types.variableDeclaration(\"const\", [import_compiler33.types.variableDeclarator(node.var, id)])\n        );\n      } else {\n        const source = initValue(node.var.extra.binding);\n        addValue(getSection(tag), void 0, source, id);\n        tag.remove();\n      }\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"id/<name>\",\n      description: \"Use to create a unique identifier.\",\n      snippet: \"id/${1:name}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#id\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/id.d.marko\"\n};\n\n// src/core/if.ts\nvar import_babel_utils25 = require(\"@marko/babel-utils\");\nvar import_compiler35 = require(\"@marko/compiler\");\n\n// src/util/to-first-statement-or-block.ts\nvar import_compiler34 = require(\"@marko/compiler\");\nfunction toFirstStatementOrBlock(body) {\n  if (Array.isArray(body)) {\n    if (body.length === 1) {\n      return body[0];\n    }\n    return import_compiler34.types.blockStatement(body);\n  }\n  return body;\n}\n\n// src/core/if.ts\nvar kBinding = Symbol(\"if node binding\");\nvar BRANCHES_LOOKUP = /* @__PURE__ */ new WeakMap();\nvar IfTag = {\n  analyze(tag) {\n    assertValidCondition(tag);\n    if (tag.node.body.attributeTags) return;\n    const [isLast, branches] = getBranches(tag, startSection(tag.get(\"body\")));\n    if (isLast) {\n      const [rootTag] = branches[0];\n      const rootExtra = rootTag.node.extra ??= {};\n      const mergeReferenceNodes = [];\n      let singleNodeOptimization = true;\n      for (const [branchTag, branchBodySection] of branches) {\n        if (branchBodySection) {\n          branchBodySection.upstreamExpression = rootExtra;\n          if (!(branchBodySection.content === null || branchBodySection.content?.singleChild)) {\n            singleNodeOptimization = false;\n          }\n        }\n        if (branchTag.node.attributes.length) {\n          mergeReferenceNodes.push(branchTag.node.attributes[0].value);\n        }\n      }\n      const section = getOrCreateSection(tag);\n      rootExtra[kBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section,\n        void 0,\n        rootExtra\n      );\n      rootExtra.singleNodeOptimization = singleNodeOptimization;\n      mergeReferences(section, rootTag.node, mergeReferenceNodes);\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        const rootExtra = getRoot(tag).node.extra;\n        const isStateful = isStatefulReferences(rootExtra.referencedBindings);\n        const singleNodeOptimization = rootExtra.singleNodeOptimization;\n        if (isRoot(tag)) {\n          visit(tag, 37 /* Replace */);\n        }\n        enterShallow(tag);\n        flushBefore(tag);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n          if (isStateful && !singleNodeOptimization) {\n            writeTo(tagBody)`${callRuntime(\n              \"markResumeScopeStart\",\n              getScopeIdIdentifier(bodySection)\n            )}`;\n          }\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const [isLast, branches] = getBranches(tag, bodySection);\n        const rootExtra = branches[0][0].node.extra;\n        const nodeRef2 = rootExtra[kBinding];\n        const isStateful = isStatefulReferences(rootExtra.referencedBindings);\n        const singleNodeOptimization = rootExtra.singleNodeOptimization;\n        const hasStatefulClosures = bodySection && checkStatefulClosures(bodySection, true);\n        if (bodySection) {\n          if (isStateful || hasStatefulClosures) {\n            setForceResumeScope(bodySection);\n          }\n          flushInto(tag);\n          setSubscriberBuilder(tag, () => {\n          });\n          writeHTMLResumeStatements(tagBody);\n        }\n        if (isLast) {\n          const write2 = writeTo(tag);\n          const nextTag = tag.getNextSibling();\n          const ifScopeIdIdentifier = tag.scope.generateUidIdentifier(\"ifScopeId\");\n          const ifRendererIdentifier = tag.scope.generateUidIdentifier(\"ifRenderer\");\n          let statement;\n          for (let i = branches.length; i--; ) {\n            const [branchTag, branchBodySection] = branches[i];\n            const bodyStatements = branchTag.node.body.body;\n            if (branchBodySection) {\n              const branchHasStatefulClosures = checkStatefulClosures(\n                branchBodySection,\n                true\n              );\n              if (isStateful) {\n                bodyStatements.push(\n                  import_compiler35.types.expressionStatement(\n                    callRuntime(\n                      \"register\",\n                      import_compiler35.types.assignmentExpression(\n                        \"=\",\n                        ifRendererIdentifier,\n                        callRuntime(\n                          \"createRenderer\",\n                          import_compiler35.types.arrowFunctionExpression([], import_compiler35.types.blockStatement([]))\n                        )\n                      ),\n                      import_compiler35.types.stringLiteral(\n                        getResumeRegisterId(branchBodySection, \"renderer\")\n                      )\n                    )\n                  )\n                );\n              }\n              if (isStateful || branchHasStatefulClosures) {\n                bodyStatements.push(\n                  import_compiler35.types.expressionStatement(\n                    import_compiler35.types.assignmentExpression(\n                      \"=\",\n                      ifScopeIdIdentifier,\n                      getScopeIdIdentifier(branchBodySection)\n                    )\n                  )\n                );\n              }\n            }\n            const [testAttr] = branchTag.node.attributes;\n            const curStatement = toFirstStatementOrBlock(bodyStatements);\n            if (testAttr) {\n              statement = import_compiler35.types.ifStatement(\n                testAttr.value,\n                curStatement,\n                statement\n              );\n            } else {\n              statement = curStatement;\n            }\n            branchTag.remove();\n          }\n          if (!(isStateful || hasStatefulClosures)) {\n            nextTag.insertBefore(statement);\n          } else {\n            nextTag.insertBefore([\n              import_compiler35.types.variableDeclaration(\n                \"let\",\n                [\n                  import_compiler35.types.variableDeclarator(ifScopeIdIdentifier),\n                  isStateful && import_compiler35.types.variableDeclarator(ifRendererIdentifier)\n                ].filter(Boolean)\n              ),\n              statement\n            ]);\n            if (isStateful) {\n              if (singleNodeOptimization) {\n                write2`${callRuntime(\n                  \"markResumeControlSingleNodeEnd\",\n                  getScopeIdIdentifier(section),\n                  getScopeAccessorLiteral(nodeRef2),\n                  ifScopeIdIdentifier\n                )}`;\n              } else {\n                write2`${callRuntime(\n                  \"markResumeControlEnd\",\n                  getScopeIdIdentifier(section),\n                  getScopeAccessorLiteral(nodeRef2)\n                )}`;\n              }\n              getSerializedScopeProperties(section).set(\n                import_compiler35.types.stringLiteral(\n                  getScopeAccessorLiteral(nodeRef2).value + \"(\" /* ConditionalRenderer */\n                ),\n                ifRendererIdentifier\n              );\n            }\n            getSerializedScopeProperties(section).set(\n              import_compiler35.types.stringLiteral(\n                getScopeAccessorLiteral(nodeRef2).value + \"!\" /* ConditionalScope */\n              ),\n              callRuntime(\"getScopeById\", ifScopeIdIdentifier)\n            );\n          }\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n        }\n        if (isRoot(tag)) {\n          visit(tag, 37 /* Replace */);\n        }\n        enterShallow(tag);\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const [isLast, branches] = getBranches(\n          tag,\n          getSectionForBody(tag.get(\"body\"))\n        );\n        if (isLast) {\n          const section = getSection(tag);\n          const rootExtra = branches[0][0].node.extra;\n          const nodeRef2 = rootExtra[kBinding];\n          let expr = import_compiler35.types.nullLiteral();\n          for (let i = branches.length; i--; ) {\n            const [branchTag, branchBodySection] = branches[i];\n            const [testAttr] = branchTag.node.attributes;\n            const consequent = branchBodySection ? import_compiler35.types.identifier(branchBodySection.name) : import_compiler35.types.numericLiteral(0);\n            setSubscriberBuilder(branchTag, (subscriber) => {\n              return callRuntime(\n                \"inConditionalScope\",\n                subscriber,\n                getScopeAccessorLiteral(nodeRef2)\n                /*t.identifier(section.name)*/\n              );\n            });\n            branchTag.remove();\n            expr = testAttr ? import_compiler35.types.conditionalExpression(testAttr.value, consequent, expr) : consequent;\n          }\n          const signal = getSignal(section, nodeRef2, \"if\");\n          signal.build = () => {\n            return callRuntime(\n              \"conditional\",\n              getScopeAccessorLiteral(nodeRef2),\n              getSignalFn(signal, [scopeIdentifier])\n            );\n          };\n          signal.hasDownstreamIntersections = () => branches.some(([, bodySection]) => bodySection?.closures);\n          addValue(section, rootExtra.referencedBindings, signal, expr);\n        }\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  autocomplete: [\n    {\n      snippet: \"if=${1:condition}\",\n      description: \"Use to display content only if the condition is met.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseIfTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      snippet: \"else-if=${1:condition}\",\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nfunction assertValidCondition(tag) {\n  (0, import_babel_utils25.assertNoVar)(tag);\n  (0, import_babel_utils25.assertNoArgs)(tag);\n  (0, import_babel_utils25.assertNoParams)(tag);\n  assertHasBody(tag);\n  assertNoSpreadAttrs(tag);\n  switch (getTagName(tag)) {\n    case \"if\":\n      assertHasValueAttribute(tag);\n      break;\n    case \"else-if\":\n      assertHasValueAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n    case \"else\":\n      assertOptionalIfAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n  }\n}\nfunction assertHasPrecedingCondition(tag) {\n  let prev = tag.getPrevSibling();\n  while (prev.node && prev.isMarkoComment()) prev = prev.getPrevSibling();\n  if (!isConditionTag(prev) || getTagName(prev) !== \"else\" && !prev.node.attributes.length) {\n    throw tag.buildCodeFrameError(\n      `The \\`<${getTagName(tag)}>\\` must have a preceding \\`<if=cond>\\`, \\`<else-if=cond>\\`, or \\`<else if=cond>\\`.`\n    );\n  }\n}\nfunction assertHasBody(tag) {\n  if (!(tag.node.body.body.length || tag.node.attributeTags.length)) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${getTagName(tag)}\\` tag requires body content.`\n    );\n  }\n}\nfunction assertHasValueAttribute(tag) {\n  const { node } = tag;\n  const [valueAttr] = node.attributes;\n  if (!import_compiler35.types.isMarkoAttribute(valueAttr) || !valueAttr.default) {\n    throw tag.get(\"name\").buildCodeFrameError(`The \\`${getTagName(tag)}\\` tag requires a value.`);\n  }\n  if (node.attributes.length > 1) {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports the \\`value\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction assertOptionalIfAttribute(tag) {\n  const { node } = tag;\n  const [ifAttr] = node.attributes;\n  if (node.attributes.length > 1 || ifAttr && ifAttr.name !== \"if\") {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports an \\`if=\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction getBranches(tag, bodySection) {\n  const branches = BRANCHES_LOOKUP.get(tag) ?? [];\n  let nextTag = tag.getNextSibling();\n  while (nextTag.isMarkoComment()) nextTag = nextTag.getNextSibling();\n  const isLast = !(isCoreTagName(nextTag, \"else\") || isCoreTagName(nextTag, \"else-if\"));\n  branches.push([tag, bodySection]);\n  if (!isLast) {\n    BRANCHES_LOOKUP.set(nextTag, branches);\n  }\n  return [isLast, branches];\n}\nfunction getRoot(tag) {\n  return isRoot(tag) ? tag : BRANCHES_LOOKUP.get(tag)[0][0];\n}\nfunction isRoot(tag) {\n  return isCoreTagName(tag, \"if\");\n}\n\n// src/core/import.ts\nvar import_babel_utils26 = require(\"@marko/babel-utils\");\nvar import_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils26.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: 'import <scope> from \"<path>\"',\n      description: \"Use to import external modules, follows the same syntax as JavaScript imports.\",\n      snippet: 'import ${2} from \"${1:path}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#importing-external-files\"\n    }\n  ]\n};\n\n// src/core/let.ts\nvar import_babel_utils27 = require(\"@marko/babel-utils\");\nvar import_compiler36 = require(\"@marko/compiler\");\nvar let_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    const { optimize } = getMarkoOpts();\n    let valueAttr;\n    let valueChangeAttr;\n    for (const attr2 of node.attributes) {\n      if (import_compiler36.types.isMarkoAttribute(attr2)) {\n        if (attr2.name === \"value\") {\n          valueAttr = attr2;\n        } else if (attr2.name === \"valueChange\") {\n          valueChangeAttr = attr2;\n        } else {\n          const start = attr2.loc?.start;\n          const end = attr2.loc?.end;\n          const msg = \"The `let` tag only supports the `value` attribute and its change handler.\";\n          if (start == null || end == null) {\n            throw tag.get(\"name\").buildCodeFrameError(msg);\n          } else {\n            throw tag.hub.buildError(\n              { loc: { start, end } },\n              msg,\n              Error\n            );\n          }\n        }\n      }\n    }\n    (0, import_babel_utils27.assertNoArgs)(tag);\n    (0, import_babel_utils27.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    if (!tagVar) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `let` tag requires a tag variable.\");\n    }\n    if (!import_compiler36.types.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `let` tag variable cannot be destructured.\");\n    }\n    if (valueChangeAttr && (0, import_babel_utils27.computeNode)(valueChangeAttr.value)) {\n      throw tag.get(\"attributes\").find((attr2) => attr2.node === valueChangeAttr).get(\"value\").buildCodeFrameError(\n        \"The `let` tag `valueChange` attribute must be a function.\"\n      );\n    }\n    if (valueChangeAttr) {\n      const valueChangeReferences = (valueChangeAttr.value.extra ??= {})?.referencedBindings;\n      valueChangeAttr.value.extra.static = import_compiler36.types.isFunction(valueChangeAttr.value);\n      if (optimize && import_compiler36.types.isIdentifier(valueChangeAttr.value) && size(valueChangeReferences) === 1) {\n        valueChangeAttr.value.extra.binding = valueChangeReferences;\n      } else {\n        valueChangeAttr.value.extra.binding = createBinding(\n          tag.scope.generateUid(tagVar.name + \"_change\"),\n          1 /* let */,\n          getSection(tag),\n          void 0,\n          valueChangeAttr.value.extra\n        );\n      }\n    }\n    const upstreamExpressionExtra = valueAttr ? valueAttr.value.extra ??= {} : void 0;\n    trackVarReferences(\n      tag,\n      1 /* let */,\n      void 0,\n      upstreamExpressionExtra,\n      valueChangeAttr?.value.extra?.binding\n    );\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const tagVar = node.var;\n      const { optimize } = getMarkoOpts();\n      const valueAttr = node.attributes.find(\n        (attr2) => import_compiler36.types.isMarkoAttribute(attr2) && (attr2.default || attr2.name === \"value\")\n      ) ?? import_compiler36.types.markoAttribute(\"value\", import_compiler36.types.identifier(\"undefined\"));\n      const valueChangeAttr = node.attributes.find(\n        (attr2) => import_compiler36.types.isMarkoAttribute(attr2) && attr2.name === \"valueChange\"\n      );\n      const valueChangeBinding = valueChangeAttr?.value.extra?.binding;\n      if (isOutputDOM()) {\n        const section = getSection(tag);\n        const binding = tagVar.extra.binding;\n        const signal = initValue(binding, \"state\");\n        const referencedBindings = valueAttr.value.extra?.referencedBindings;\n        const isSetup = !referencedBindings;\n        if (valueChangeBinding && (!optimize || !import_compiler36.types.isIdentifier(valueChangeAttr.value))) {\n          addValue(\n            section,\n            valueChangeAttr.value.extra?.referencedBindings,\n            initValue(valueChangeBinding),\n            valueChangeAttr.value\n          );\n        }\n        addValue(section, referencedBindings, signal, valueAttr.value);\n        if (!isSetup) {\n          let extraArgsExpression;\n          Object.defineProperty(signal, \"extraArgs\", {\n            get() {\n              if (!extraArgsExpression) {\n                extraArgsExpression = valueChangeBinding ? valueChangeAttr?.value.extra?.static ? [import_compiler36.types.numericLiteral(1)] : [createScopeReadExpression(section, valueChangeBinding)] : [];\n              }\n              return extraArgsExpression;\n            }\n          });\n        }\n        signal.buildAssignment = (valueSection, value) => {\n          const changeBindingId = valueChangeBinding && import_compiler36.types.identifier(valueChangeBinding.name);\n          if (valueChangeBinding?.upstreamExpression?.static) {\n            return import_compiler36.types.callExpression(changeBindingId, [value]);\n          }\n          const scope = getScopeExpression(valueSection, signal.section);\n          return import_compiler36.types.callExpression(\n            signal.identifier,\n            changeBindingId ? [scope, value, changeBindingId] : [scope, value]\n          );\n        };\n      } else {\n        translateVar(tag, valueAttr.value);\n        if (valueChangeBinding) {\n          tag.insertBefore(\n            import_compiler36.types.variableDeclaration(\"const\", [\n              import_compiler36.types.variableDeclarator(\n                import_compiler36.types.identifier(valueChangeBinding.name),\n                valueChangeAttr.value\n              )\n            ])\n          );\n        }\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a mutable binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#let\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/let.d.marko\"\n};\n\n// src/core/lifecycle.ts\nvar import_babel_utils28 = require(\"@marko/babel-utils\");\nvar import_compiler37 = require(\"@marko/compiler\");\nvar kRef = Symbol(\"lifecycle attrs reference\");\nvar supportedAttrNames = /* @__PURE__ */ new Set([\"onMount\", \"onUpdate\", \"onDestroy\"]);\nvar lifecycle_default = {\n  analyze(tag) {\n    (0, import_babel_utils28.assertNoArgs)(tag);\n    (0, import_babel_utils28.assertNoVar)(tag);\n    (0, import_babel_utils28.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const tagExtra = node.extra ??= {};\n    const section = getOrCreateSection(tag);\n    tagExtra[kRef] = createBinding(\n      tag.scope.generateUid(\"lifecycle\"),\n      4 /* derived */,\n      section,\n      void 0,\n      tagExtra\n    );\n    if (node.attributes.length === 0) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `lifecycle` tag requires at least one attribute.\"\n      );\n    }\n    for (const attr2 of node.attributes) {\n      if (import_compiler37.types.isMarkoSpreadAttribute(attr2)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The `lifecycle` tag does not support `...spread` attributes.\"\n        );\n      } else if (!supportedAttrNames.has(attr2.name)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          `The \\`lifecycle\\` tag does not support the \\`${attr2.name}\\` attribute.`\n        );\n      }\n      (attr2.value.extra ??= {}).isEffect = true;\n    }\n    (currentProgramPath.node.extra ??= {}).isInteractive = true;\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const section = getSection(tag);\n      const tagExtra = node.extra;\n      const { referencedBindings } = tagExtra;\n      const lifecycleAttrsRef = tagExtra[kRef];\n      if (isOutputDOM()) {\n        const translatedAttrs = translateAttrs(tag);\n        translatedAttrs.statements.push(\n          import_compiler37.types.expressionStatement(\n            callRuntime(\n              \"lifecycle\",\n              scopeIdentifier,\n              getScopeAccessorLiteral(lifecycleAttrsRef),\n              propsToExpression(translatedAttrs.properties)\n            )\n          )\n        );\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          translatedAttrs.statements,\n          node.attributes.map((a) => a.value)\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/lifecycle.d.marko\"\n};\n\n// src/core/log.ts\nvar import_babel_utils29 = require(\"@marko/babel-utils\");\nvar import_compiler38 = require(\"@marko/compiler\");\nvar log_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils29.assertNoArgs)(tag);\n    (0, import_babel_utils29.assertNoVar)(tag);\n    (0, import_babel_utils29.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `log` tag requires a value.\");\n    }\n    if (tag.node.attributes.length > 1 || !import_compiler38.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `log` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      const statement = import_compiler38.types.expressionStatement(\n        import_compiler38.types.callExpression(\n          import_compiler38.types.memberExpression(import_compiler38.types.identifier(\"console\"), import_compiler38.types.identifier(\"log\")),\n          [value]\n        )\n      );\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to log a value to the console.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#log\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/log.d.marko\"\n};\n\n// src/core/noop.ts\nvar noop_default = {\n  migrate: [(tag) => tag.remove()]\n};\n\n// src/core/server.ts\nvar import_babel_utils30 = require(\"@marko/babel-utils\");\nvar import_compiler39 = require(\"@marko/compiler\");\nvar server_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^server\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils30.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler39.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler39.types.markoScriptlet(body, true, \"server\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"server <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the server.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#server-javascript\"\n    }\n  ]\n};\n\n// src/core/static.ts\nvar import_babel_utils31 = require(\"@marko/babel-utils\");\nvar import_compiler40 = require(\"@marko/compiler\");\nvar static_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^static\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils31.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler40.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler40.types.markoScriptlet(body, true));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"static <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#static-javascript\"\n    }\n  ]\n};\n\n// src/core/style.ts\nvar import_babel_utils32 = require(\"@marko/babel-utils\");\nvar import_compiler41 = require(\"@marko/compiler\");\n\n// ../../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs\nvar comma = \",\".charCodeAt(0);\nvar semicolon = \";\".charCodeAt(0);\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar intToChar = new Uint8Array(64);\nvar charToInt = new Uint8Array(128);\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\nfunction encodeInteger(builder, num, relative) {\n  let delta = num - relative;\n  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;\n  do {\n    let clamped = delta & 31;\n    delta >>>= 5;\n    if (delta > 0)\n      clamped |= 32;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n  return num;\n}\nvar bufLength = 1024 * 16;\nvar td = typeof TextDecoder !== \"undefined\" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== \"undefined\" ? {\n  decode(buf) {\n    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n    return out.toString();\n  }\n} : {\n  decode(buf) {\n    let out = \"\";\n    for (let i = 0; i < buf.length; i++) {\n      out += String.fromCharCode(buf[i]);\n    }\n    return out;\n  }\n};\nvar StringWriter = class {\n  constructor() {\n    this.pos = 0;\n    this.out = \"\";\n    this.buffer = new Uint8Array(bufLength);\n  }\n  write(v) {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n  flush() {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n};\nfunction encode(decoded) {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0)\n      writer.write(semicolon);\n    if (line.length === 0)\n      continue;\n    let genColumn = 0;\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0)\n        writer.write(comma);\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n      if (segment.length === 1)\n        continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n      if (segment.length === 4)\n        continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n  return writer.flush();\n}\n\n// ../../node_modules/magic-string/dist/magic-string.es.mjs\nvar BitSet = class _BitSet {\n  constructor(arg) {\n    this.bits = arg instanceof _BitSet ? arg.bits.slice() : [];\n  }\n  add(n2) {\n    this.bits[n2 >> 5] |= 1 << (n2 & 31);\n  }\n  has(n2) {\n    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));\n  }\n};\nvar Chunk2 = class _Chunk {\n  constructor(start, end, content) {\n    this.start = start;\n    this.end = end;\n    this.original = content;\n    this.intro = \"\";\n    this.outro = \"\";\n    this.content = content;\n    this.storeName = false;\n    this.edited = false;\n    {\n      this.previous = null;\n      this.next = null;\n    }\n  }\n  appendLeft(content) {\n    this.outro += content;\n  }\n  appendRight(content) {\n    this.intro = this.intro + content;\n  }\n  clone() {\n    const chunk = new _Chunk(this.start, this.end, this.original);\n    chunk.intro = this.intro;\n    chunk.outro = this.outro;\n    chunk.content = this.content;\n    chunk.storeName = this.storeName;\n    chunk.edited = this.edited;\n    return chunk;\n  }\n  contains(index) {\n    return this.start < index && index < this.end;\n  }\n  eachNext(fn) {\n    let chunk = this;\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.next;\n    }\n  }\n  eachPrevious(fn) {\n    let chunk = this;\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.previous;\n    }\n  }\n  edit(content, storeName, contentOnly) {\n    this.content = content;\n    if (!contentOnly) {\n      this.intro = \"\";\n      this.outro = \"\";\n    }\n    this.storeName = storeName;\n    this.edited = true;\n    return this;\n  }\n  prependLeft(content) {\n    this.outro = content + this.outro;\n  }\n  prependRight(content) {\n    this.intro = content + this.intro;\n  }\n  reset() {\n    this.intro = \"\";\n    this.outro = \"\";\n    if (this.edited) {\n      this.content = this.original;\n      this.storeName = false;\n      this.edited = false;\n    }\n  }\n  split(index) {\n    const sliceIndex = index - this.start;\n    const originalBefore = this.original.slice(0, sliceIndex);\n    const originalAfter = this.original.slice(sliceIndex);\n    this.original = originalBefore;\n    const newChunk = new _Chunk(index, this.end, originalAfter);\n    newChunk.outro = this.outro;\n    this.outro = \"\";\n    this.end = index;\n    if (this.edited) {\n      newChunk.edit(\"\", false);\n      this.content = \"\";\n    } else {\n      this.content = originalBefore;\n    }\n    newChunk.next = this.next;\n    if (newChunk.next) newChunk.next.previous = newChunk;\n    newChunk.previous = this;\n    this.next = newChunk;\n    return newChunk;\n  }\n  toString() {\n    return this.intro + this.content + this.outro;\n  }\n  trimEnd(rx) {\n    this.outro = this.outro.replace(rx, \"\");\n    if (this.outro.length) return true;\n    const trimmed = this.content.replace(rx, \"\");\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        this.split(this.start + trimmed.length).edit(\"\", void 0, true);\n        if (this.edited) {\n          this.edit(trimmed, this.storeName, true);\n        }\n      }\n      return true;\n    } else {\n      this.edit(\"\", void 0, true);\n      this.intro = this.intro.replace(rx, \"\");\n      if (this.intro.length) return true;\n    }\n  }\n  trimStart(rx) {\n    this.intro = this.intro.replace(rx, \"\");\n    if (this.intro.length) return true;\n    const trimmed = this.content.replace(rx, \"\");\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        const newChunk = this.split(this.end - trimmed.length);\n        if (this.edited) {\n          newChunk.edit(trimmed, this.storeName, true);\n        }\n        this.edit(\"\", void 0, true);\n      }\n      return true;\n    } else {\n      this.edit(\"\", void 0, true);\n      this.outro = this.outro.replace(rx, \"\");\n      if (this.outro.length) return true;\n    }\n  }\n};\nfunction getBtoa() {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));\n  } else if (typeof Buffer === \"function\") {\n    return (str) => Buffer.from(str, \"utf-8\").toString(\"base64\");\n  } else {\n    return () => {\n      throw new Error(\"Unsupported environment: `window.btoa` or `Buffer` should be supported.\");\n    };\n  }\n}\nvar btoa = /* @__PURE__ */ getBtoa();\nvar SourceMap = class {\n  constructor(properties) {\n    this.version = 3;\n    this.file = properties.file;\n    this.sources = properties.sources;\n    this.sourcesContent = properties.sourcesContent;\n    this.names = properties.names;\n    this.mappings = encode(properties.mappings);\n    if (typeof properties.x_google_ignoreList !== \"undefined\") {\n      this.x_google_ignoreList = properties.x_google_ignoreList;\n    }\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  toUrl() {\n    return \"data:application/json;charset=utf-8;base64,\" + btoa(this.toString());\n  }\n};\nfunction guessIndent(code) {\n  const lines = code.split(\"\\n\");\n  const tabbed = lines.filter((line) => /^\\t+/.test(line));\n  const spaced = lines.filter((line) => /^ {2,}/.test(line));\n  if (tabbed.length === 0 && spaced.length === 0) {\n    return null;\n  }\n  if (tabbed.length >= spaced.length) {\n    return \"\t\";\n  }\n  const min = spaced.reduce((previous, current) => {\n    const numSpaces = /^ +/.exec(current)[0].length;\n    return Math.min(numSpaces, previous);\n  }, Infinity);\n  return new Array(min + 1).join(\" \");\n}\nfunction getRelativePath(from, to) {\n  const fromParts = from.split(/[/\\\\]/);\n  const toParts = to.split(/[/\\\\]/);\n  fromParts.pop();\n  while (fromParts[0] === toParts[0]) {\n    fromParts.shift();\n    toParts.shift();\n  }\n  if (fromParts.length) {\n    let i = fromParts.length;\n    while (i--) fromParts[i] = \"..\";\n  }\n  return fromParts.concat(toParts).join(\"/\");\n}\nvar toString2 = Object.prototype.toString;\nfunction isObject(thing) {\n  return toString2.call(thing) === \"[object Object]\";\n}\nfunction getLocator(source) {\n  const originalLines = source.split(\"\\n\");\n  const lineOffsets = [];\n  for (let i = 0, pos = 0; i < originalLines.length; i++) {\n    lineOffsets.push(pos);\n    pos += originalLines[i].length + 1;\n  }\n  return function locate(index) {\n    let i = 0;\n    let j = lineOffsets.length;\n    while (i < j) {\n      const m = i + j >> 1;\n      if (index < lineOffsets[m]) {\n        j = m;\n      } else {\n        i = m + 1;\n      }\n    }\n    const line = i - 1;\n    const column = index - lineOffsets[line];\n    return { line, column };\n  };\n}\nvar wordRegex = /\\w/;\nvar Mappings = class {\n  constructor(hires) {\n    this.hires = hires;\n    this.generatedCodeLine = 0;\n    this.generatedCodeColumn = 0;\n    this.raw = [];\n    this.rawSegments = this.raw[this.generatedCodeLine] = [];\n    this.pending = null;\n  }\n  addEdit(sourceIndex, content, loc, nameIndex) {\n    if (content.length) {\n      const contentLengthMinusOne = content.length - 1;\n      let contentLineEnd = content.indexOf(\"\\n\", 0);\n      let previousContentLineEnd = -1;\n      while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {\n        const segment2 = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n        if (nameIndex >= 0) {\n          segment2.push(nameIndex);\n        }\n        this.rawSegments.push(segment2);\n        this.generatedCodeLine += 1;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n        this.generatedCodeColumn = 0;\n        previousContentLineEnd = contentLineEnd;\n        contentLineEnd = content.indexOf(\"\\n\", contentLineEnd + 1);\n      }\n      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n      if (nameIndex >= 0) {\n        segment.push(nameIndex);\n      }\n      this.rawSegments.push(segment);\n      this.advance(content.slice(previousContentLineEnd + 1));\n    } else if (this.pending) {\n      this.rawSegments.push(this.pending);\n      this.advance(content);\n    }\n    this.pending = null;\n  }\n  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n    let originalCharIndex = chunk.start;\n    let first = true;\n    let charInHiresBoundary = false;\n    while (originalCharIndex < chunk.end) {\n      if (original[originalCharIndex] === \"\\n\") {\n        loc.line += 1;\n        loc.column = 0;\n        this.generatedCodeLine += 1;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n        this.generatedCodeColumn = 0;\n        first = true;\n      } else {\n        if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n          const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n          if (this.hires === \"boundary\") {\n            if (wordRegex.test(original[originalCharIndex])) {\n              if (!charInHiresBoundary) {\n                this.rawSegments.push(segment);\n                charInHiresBoundary = true;\n              }\n            } else {\n              this.rawSegments.push(segment);\n              charInHiresBoundary = false;\n            }\n          } else {\n            this.rawSegments.push(segment);\n          }\n        }\n        loc.column += 1;\n        this.generatedCodeColumn += 1;\n        first = false;\n      }\n      originalCharIndex += 1;\n    }\n    this.pending = null;\n  }\n  advance(str) {\n    if (!str) return;\n    const lines = str.split(\"\\n\");\n    if (lines.length > 1) {\n      for (let i = 0; i < lines.length - 1; i++) {\n        this.generatedCodeLine++;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n      }\n      this.generatedCodeColumn = 0;\n    }\n    this.generatedCodeColumn += lines[lines.length - 1].length;\n  }\n};\nvar n = \"\\n\";\nvar warned = {\n  insertLeft: false,\n  insertRight: false,\n  storeName: false\n};\nvar MagicString = class _MagicString {\n  constructor(string, options = {}) {\n    const chunk = new Chunk2(0, string.length, string);\n    Object.defineProperties(this, {\n      original: { writable: true, value: string },\n      outro: { writable: true, value: \"\" },\n      intro: { writable: true, value: \"\" },\n      firstChunk: { writable: true, value: chunk },\n      lastChunk: { writable: true, value: chunk },\n      lastSearchedChunk: { writable: true, value: chunk },\n      byStart: { writable: true, value: {} },\n      byEnd: { writable: true, value: {} },\n      filename: { writable: true, value: options.filename },\n      indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n      sourcemapLocations: { writable: true, value: new BitSet() },\n      storedNames: { writable: true, value: {} },\n      indentStr: { writable: true, value: void 0 },\n      ignoreList: { writable: true, value: options.ignoreList }\n    });\n    this.byStart[0] = chunk;\n    this.byEnd[string.length] = chunk;\n  }\n  addSourcemapLocation(char) {\n    this.sourcemapLocations.add(char);\n  }\n  append(content) {\n    if (typeof content !== \"string\") throw new TypeError(\"outro content must be a string\");\n    this.outro += content;\n    return this;\n  }\n  appendLeft(index, content) {\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byEnd[index];\n    if (chunk) {\n      chunk.appendLeft(content);\n    } else {\n      this.intro += content;\n    }\n    return this;\n  }\n  appendRight(index, content) {\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byStart[index];\n    if (chunk) {\n      chunk.appendRight(content);\n    } else {\n      this.outro += content;\n    }\n    return this;\n  }\n  clone() {\n    const cloned = new _MagicString(this.original, { filename: this.filename });\n    let originalChunk = this.firstChunk;\n    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();\n    while (originalChunk) {\n      cloned.byStart[clonedChunk.start] = clonedChunk;\n      cloned.byEnd[clonedChunk.end] = clonedChunk;\n      const nextOriginalChunk = originalChunk.next;\n      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n      if (nextClonedChunk) {\n        clonedChunk.next = nextClonedChunk;\n        nextClonedChunk.previous = clonedChunk;\n        clonedChunk = nextClonedChunk;\n      }\n      originalChunk = nextOriginalChunk;\n    }\n    cloned.lastChunk = clonedChunk;\n    if (this.indentExclusionRanges) {\n      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n    }\n    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n    cloned.intro = this.intro;\n    cloned.outro = this.outro;\n    return cloned;\n  }\n  generateDecodedMap(options) {\n    options = options || {};\n    const sourceIndex = 0;\n    const names = Object.keys(this.storedNames);\n    const mappings = new Mappings(options.hires);\n    const locate = getLocator(this.original);\n    if (this.intro) {\n      mappings.advance(this.intro);\n    }\n    this.firstChunk.eachNext((chunk) => {\n      const loc = locate(chunk.start);\n      if (chunk.intro.length) mappings.advance(chunk.intro);\n      if (chunk.edited) {\n        mappings.addEdit(\n          sourceIndex,\n          chunk.content,\n          loc,\n          chunk.storeName ? names.indexOf(chunk.original) : -1\n        );\n      } else {\n        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n      }\n      if (chunk.outro.length) mappings.advance(chunk.outro);\n    });\n    return {\n      file: options.file ? options.file.split(/[/\\\\]/).pop() : void 0,\n      sources: [\n        options.source ? getRelativePath(options.file || \"\", options.source) : options.file || \"\"\n      ],\n      sourcesContent: options.includeContent ? [this.original] : void 0,\n      names,\n      mappings: mappings.raw,\n      x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0\n    };\n  }\n  generateMap(options) {\n    return new SourceMap(this.generateDecodedMap(options));\n  }\n  _ensureindentStr() {\n    if (this.indentStr === void 0) {\n      this.indentStr = guessIndent(this.original);\n    }\n  }\n  _getRawIndentString() {\n    this._ensureindentStr();\n    return this.indentStr;\n  }\n  getIndentString() {\n    this._ensureindentStr();\n    return this.indentStr === null ? \"\t\" : this.indentStr;\n  }\n  indent(indentStr, options) {\n    const pattern = /^[^\\r\\n]/gm;\n    if (isObject(indentStr)) {\n      options = indentStr;\n      indentStr = void 0;\n    }\n    if (indentStr === void 0) {\n      this._ensureindentStr();\n      indentStr = this.indentStr || \"\t\";\n    }\n    if (indentStr === \"\") return this;\n    options = options || {};\n    const isExcluded = {};\n    if (options.exclude) {\n      const exclusions = typeof options.exclude[0] === \"number\" ? [options.exclude] : options.exclude;\n      exclusions.forEach((exclusion) => {\n        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n          isExcluded[i] = true;\n        }\n      });\n    }\n    let shouldIndentNextCharacter = options.indentStart !== false;\n    const replacer = (match) => {\n      if (shouldIndentNextCharacter) return `${indentStr}${match}`;\n      shouldIndentNextCharacter = true;\n      return match;\n    };\n    this.intro = this.intro.replace(pattern, replacer);\n    let charIndex = 0;\n    let chunk = this.firstChunk;\n    while (chunk) {\n      const end = chunk.end;\n      if (chunk.edited) {\n        if (!isExcluded[charIndex]) {\n          chunk.content = chunk.content.replace(pattern, replacer);\n          if (chunk.content.length) {\n            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === \"\\n\";\n          }\n        }\n      } else {\n        charIndex = chunk.start;\n        while (charIndex < end) {\n          if (!isExcluded[charIndex]) {\n            const char = this.original[charIndex];\n            if (char === \"\\n\") {\n              shouldIndentNextCharacter = true;\n            } else if (char !== \"\\r\" && shouldIndentNextCharacter) {\n              shouldIndentNextCharacter = false;\n              if (charIndex === chunk.start) {\n                chunk.prependRight(indentStr);\n              } else {\n                this._splitChunk(chunk, charIndex);\n                chunk = chunk.next;\n                chunk.prependRight(indentStr);\n              }\n            }\n          }\n          charIndex += 1;\n        }\n      }\n      charIndex = chunk.end;\n      chunk = chunk.next;\n    }\n    this.outro = this.outro.replace(pattern, replacer);\n    return this;\n  }\n  insert() {\n    throw new Error(\n      \"magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)\"\n    );\n  }\n  insertLeft(index, content) {\n    if (!warned.insertLeft) {\n      console.warn(\n        \"magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead\"\n      );\n      warned.insertLeft = true;\n    }\n    return this.appendLeft(index, content);\n  }\n  insertRight(index, content) {\n    if (!warned.insertRight) {\n      console.warn(\n        \"magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead\"\n      );\n      warned.insertRight = true;\n    }\n    return this.prependRight(index, content);\n  }\n  move(start, end, index) {\n    if (index >= start && index <= end) throw new Error(\"Cannot move a selection inside itself\");\n    this._split(start);\n    this._split(end);\n    this._split(index);\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n    const oldLeft = first.previous;\n    const oldRight = last.next;\n    const newRight = this.byStart[index];\n    if (!newRight && last === this.lastChunk) return this;\n    const newLeft = newRight ? newRight.previous : this.lastChunk;\n    if (oldLeft) oldLeft.next = oldRight;\n    if (oldRight) oldRight.previous = oldLeft;\n    if (newLeft) newLeft.next = first;\n    if (newRight) newRight.previous = last;\n    if (!first.previous) this.firstChunk = last.next;\n    if (!last.next) {\n      this.lastChunk = first.previous;\n      this.lastChunk.next = null;\n    }\n    first.previous = newLeft;\n    last.next = newRight || null;\n    if (!newLeft) this.firstChunk = first;\n    if (!newRight) this.lastChunk = last;\n    return this;\n  }\n  overwrite(start, end, content, options) {\n    options = options || {};\n    return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n  }\n  update(start, end, content, options) {\n    if (typeof content !== \"string\") throw new TypeError(\"replacement content must be a string\");\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (end > this.original.length) throw new Error(\"end is out of bounds\");\n    if (start === end)\n      throw new Error(\n        \"Cannot overwrite a zero-length range \\u2013 use appendLeft or prependRight instead\"\n      );\n    this._split(start);\n    this._split(end);\n    if (options === true) {\n      if (!warned.storeName) {\n        console.warn(\n          \"The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string\"\n        );\n        warned.storeName = true;\n      }\n      options = { storeName: true };\n    }\n    const storeName = options !== void 0 ? options.storeName : false;\n    const overwrite = options !== void 0 ? options.overwrite : false;\n    if (storeName) {\n      const original = this.original.slice(start, end);\n      Object.defineProperty(this.storedNames, original, {\n        writable: true,\n        value: true,\n        enumerable: true\n      });\n    }\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n    if (first) {\n      let chunk = first;\n      while (chunk !== last) {\n        if (chunk.next !== this.byStart[chunk.end]) {\n          throw new Error(\"Cannot overwrite across a split point\");\n        }\n        chunk = chunk.next;\n        chunk.edit(\"\", false);\n      }\n      first.edit(content, storeName, !overwrite);\n    } else {\n      const newChunk = new Chunk2(start, end, \"\").edit(content, storeName);\n      last.next = newChunk;\n      newChunk.previous = last;\n    }\n    return this;\n  }\n  prepend(content) {\n    if (typeof content !== \"string\") throw new TypeError(\"outro content must be a string\");\n    this.intro = content + this.intro;\n    return this;\n  }\n  prependLeft(index, content) {\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byEnd[index];\n    if (chunk) {\n      chunk.prependLeft(content);\n    } else {\n      this.intro = content + this.intro;\n    }\n    return this;\n  }\n  prependRight(index, content) {\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byStart[index];\n    if (chunk) {\n      chunk.prependRight(content);\n    } else {\n      this.outro = content + this.outro;\n    }\n    return this;\n  }\n  remove(start, end) {\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (start === end) return this;\n    if (start < 0 || end > this.original.length) throw new Error(\"Character is out of bounds\");\n    if (start > end) throw new Error(\"end must be greater than start\");\n    this._split(start);\n    this._split(end);\n    let chunk = this.byStart[start];\n    while (chunk) {\n      chunk.intro = \"\";\n      chunk.outro = \"\";\n      chunk.edit(\"\");\n      chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n    }\n    return this;\n  }\n  reset(start, end) {\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (start === end) return this;\n    if (start < 0 || end > this.original.length) throw new Error(\"Character is out of bounds\");\n    if (start > end) throw new Error(\"end must be greater than start\");\n    this._split(start);\n    this._split(end);\n    let chunk = this.byStart[start];\n    while (chunk) {\n      chunk.reset();\n      chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n    }\n    return this;\n  }\n  lastChar() {\n    if (this.outro.length) return this.outro[this.outro.length - 1];\n    let chunk = this.lastChunk;\n    do {\n      if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n      if (chunk.content.length) return chunk.content[chunk.content.length - 1];\n      if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n    } while (chunk = chunk.previous);\n    if (this.intro.length) return this.intro[this.intro.length - 1];\n    return \"\";\n  }\n  lastLine() {\n    let lineIndex = this.outro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n    let lineStr = this.outro;\n    let chunk = this.lastChunk;\n    do {\n      if (chunk.outro.length > 0) {\n        lineIndex = chunk.outro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.outro + lineStr;\n      }\n      if (chunk.content.length > 0) {\n        lineIndex = chunk.content.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.content + lineStr;\n      }\n      if (chunk.intro.length > 0) {\n        lineIndex = chunk.intro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.intro + lineStr;\n      }\n    } while (chunk = chunk.previous);\n    lineIndex = this.intro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n    return this.intro + lineStr;\n  }\n  slice(start = 0, end = this.original.length) {\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    let result = \"\";\n    let chunk = this.firstChunk;\n    while (chunk && (chunk.start > start || chunk.end <= start)) {\n      if (chunk.start < end && chunk.end >= end) {\n        return result;\n      }\n      chunk = chunk.next;\n    }\n    if (chunk && chunk.edited && chunk.start !== start)\n      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n    const startChunk = chunk;\n    while (chunk) {\n      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n        result += chunk.intro;\n      }\n      const containsEnd = chunk.start < end && chunk.end >= end;\n      if (containsEnd && chunk.edited && chunk.end !== end)\n        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n      const sliceStart = startChunk === chunk ? start - chunk.start : 0;\n      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n      result += chunk.content.slice(sliceStart, sliceEnd);\n      if (chunk.outro && (!containsEnd || chunk.end === end)) {\n        result += chunk.outro;\n      }\n      if (containsEnd) {\n        break;\n      }\n      chunk = chunk.next;\n    }\n    return result;\n  }\n  // TODO deprecate this? not really very useful\n  snip(start, end) {\n    const clone = this.clone();\n    clone.remove(0, start);\n    clone.remove(end, clone.original.length);\n    return clone;\n  }\n  _split(index) {\n    if (this.byStart[index] || this.byEnd[index]) return;\n    let chunk = this.lastSearchedChunk;\n    const searchForward = index > chunk.end;\n    while (chunk) {\n      if (chunk.contains(index)) return this._splitChunk(chunk, index);\n      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n    }\n  }\n  _splitChunk(chunk, index) {\n    if (chunk.edited && chunk.content.length) {\n      const loc = getLocator(this.original)(index);\n      throw new Error(\n        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \\u2013 \"${chunk.original}\")`\n      );\n    }\n    const newChunk = chunk.split(index);\n    this.byEnd[index] = chunk;\n    this.byStart[index] = newChunk;\n    this.byEnd[newChunk.end] = newChunk;\n    if (chunk === this.lastChunk) this.lastChunk = newChunk;\n    this.lastSearchedChunk = chunk;\n    return true;\n  }\n  toString() {\n    let str = this.intro;\n    let chunk = this.firstChunk;\n    while (chunk) {\n      str += chunk.toString();\n      chunk = chunk.next;\n    }\n    return str + this.outro;\n  }\n  isEmpty() {\n    let chunk = this.firstChunk;\n    do {\n      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())\n        return false;\n    } while (chunk = chunk.next);\n    return true;\n  }\n  length() {\n    let chunk = this.firstChunk;\n    let length = 0;\n    do {\n      length += chunk.intro.length + chunk.content.length + chunk.outro.length;\n    } while (chunk = chunk.next);\n    return length;\n  }\n  trimLines() {\n    return this.trim(\"[\\\\r\\\\n]\");\n  }\n  trim(charType) {\n    return this.trimStart(charType).trimEnd(charType);\n  }\n  trimEndAborted(charType) {\n    const rx = new RegExp((charType || \"\\\\s\") + \"+$\");\n    this.outro = this.outro.replace(rx, \"\");\n    if (this.outro.length) return true;\n    let chunk = this.lastChunk;\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimEnd(rx);\n      if (chunk.end !== end) {\n        if (this.lastChunk === chunk) {\n          this.lastChunk = chunk.next;\n        }\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n      if (aborted) return true;\n      chunk = chunk.previous;\n    } while (chunk);\n    return false;\n  }\n  trimEnd(charType) {\n    this.trimEndAborted(charType);\n    return this;\n  }\n  trimStartAborted(charType) {\n    const rx = new RegExp(\"^\" + (charType || \"\\\\s\") + \"+\");\n    this.intro = this.intro.replace(rx, \"\");\n    if (this.intro.length) return true;\n    let chunk = this.firstChunk;\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimStart(rx);\n      if (chunk.end !== end) {\n        if (chunk === this.lastChunk) this.lastChunk = chunk.next;\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n      if (aborted) return true;\n      chunk = chunk.next;\n    } while (chunk);\n    return false;\n  }\n  trimStart(charType) {\n    this.trimStartAborted(charType);\n    return this;\n  }\n  hasChanged() {\n    return this.original !== this.toString();\n  }\n  _replaceRegexp(searchValue, replacement) {\n    function getReplacement(match, str) {\n      if (typeof replacement === \"string\") {\n        return replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n          if (i === \"$\") return \"$\";\n          if (i === \"&\") return match[0];\n          const num = +i;\n          if (num < match.length) return match[+i];\n          return `$${i}`;\n        });\n      } else {\n        return replacement(...match, match.index, str, match.groups);\n      }\n    }\n    function matchAll(re, str) {\n      let match;\n      const matches = [];\n      while (match = re.exec(str)) {\n        matches.push(match);\n      }\n      return matches;\n    }\n    if (searchValue.global) {\n      const matches = matchAll(searchValue, this.original);\n      matches.forEach((match) => {\n        if (match.index != null) {\n          const replacement2 = getReplacement(match, this.original);\n          if (replacement2 !== match[0]) {\n            this.overwrite(\n              match.index,\n              match.index + match[0].length,\n              replacement2\n            );\n          }\n        }\n      });\n    } else {\n      const match = this.original.match(searchValue);\n      if (match && match.index != null) {\n        const replacement2 = getReplacement(match, this.original);\n        if (replacement2 !== match[0]) {\n          this.overwrite(\n            match.index,\n            match.index + match[0].length,\n            replacement2\n          );\n        }\n      }\n    }\n    return this;\n  }\n  _replaceString(string, replacement) {\n    const { original } = this;\n    const index = original.indexOf(string);\n    if (index !== -1) {\n      this.overwrite(index, index + string.length, replacement);\n    }\n    return this;\n  }\n  replace(searchValue, replacement) {\n    if (typeof searchValue === \"string\") {\n      return this._replaceString(searchValue, replacement);\n    }\n    return this._replaceRegexp(searchValue, replacement);\n  }\n  _replaceAllString(string, replacement) {\n    const { original } = this;\n    const stringLength = string.length;\n    for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {\n      const previous = original.slice(index, index + stringLength);\n      if (previous !== replacement)\n        this.overwrite(index, index + stringLength, replacement);\n    }\n    return this;\n  }\n  replaceAll(searchValue, replacement) {\n    if (typeof searchValue === \"string\") {\n      return this._replaceAllString(searchValue, replacement);\n    }\n    if (!searchValue.global) {\n      throw new TypeError(\n        \"MagicString.prototype.replaceAll called with a non-global RegExp argument\"\n      );\n    }\n    return this._replaceRegexp(searchValue, replacement);\n  }\n};\n\n// src/core/style.ts\nvar import_path2 = __toESM(require(\"path\"));\nvar style_default = {\n  analyze(tag) {\n    (0, import_babel_utils32.assertNoArgs)(tag);\n    (0, import_babel_utils32.assertNoParams)(tag);\n    (0, import_babel_utils32.assertNoAttributeTags)(tag);\n  },\n  translate(tag) {\n    const {\n      hub: { file }\n    } = tag;\n    const { filename, sourceMaps } = file.opts;\n    (0, import_babel_utils32.assertNoParams)(tag);\n    assertNoSpreadAttrs(tag);\n    let type = \"text/css\";\n    const attrs2 = tag.get(\"attributes\");\n    const base = import_path2.default.basename(filename);\n    const typeAttr = attrs2.find(\n      (attr2) => attr2.isMarkoAttribute() && attr2.node.name === \"type\"\n    );\n    const classAttr2 = attrs2.find(\n      (attr2) => attr2.isMarkoAttribute() && attr2.node.name === \"class\"\n    );\n    if (typeAttr && classAttr2) {\n      throw classAttr2.buildCodeFrameError(\n        \"The `style` tag must only use `type` or `class` and not both.\"\n      );\n    } else if (typeAttr) {\n      const typeValue = typeAttr.get(\"value\");\n      if (typeValue.isStringLiteral()) {\n        type = typeValue.node.value;\n      } else {\n        throw typeValue.buildCodeFrameError(\n          \"The `style` tag `type` attribute can only be a string literal.\"\n        );\n      }\n    } else if (classAttr2) {\n      const classValue2 = classAttr2.get(\"value\");\n      if (classValue2.isStringLiteral()) {\n        type = classValue2.node.value;\n      } else {\n        throw classValue2.buildCodeFrameError(\n          \"The `style` tag `class` attribute can only be a string literal.\"\n        );\n      }\n    }\n    if (type === \"text/css\") {\n      type = \"css\";\n    }\n    if (tag.node.var && !type.startsWith(\"module\")) {\n      type = \"module.\" + type;\n    }\n    const body = tag.get(\"body\").get(\"body\");\n    const markoText = body[0];\n    if (body.length !== 1 || !markoText.isMarkoText()) {\n      throw (markoText.isMarkoText() ? body[1] : body[0]).buildCodeFrameError(\n        \"The `style` tag currently only supports static content.\"\n      );\n    }\n    const { resolveVirtualDependency } = getMarkoOpts();\n    const start = (0, import_babel_utils32.getStart)(file, markoText.node);\n    const end = (0, import_babel_utils32.getEnd)(file, markoText.node);\n    let code = markoText.node.value;\n    let map2;\n    if (resolveVirtualDependency && sourceMaps && start !== null && end !== null) {\n      const magicString = new MagicString(file.code, { filename });\n      magicString.remove(0, start);\n      magicString.remove(end, file.code.length);\n      map2 = magicString.generateMap({\n        source: filename,\n        includeContent: true\n      });\n      if (sourceMaps === \"inline\" || sourceMaps === \"both\") {\n        code += `\n/*# sourceMappingURL=${map2.toUrl()}*/`;\n        if (sourceMaps === \"inline\") {\n          map2 = void 0;\n        }\n      }\n    }\n    const importPath = resolveVirtualDependency?.(filename, {\n      virtualPath: `./${base}.${type}`,\n      code,\n      map: map2\n    });\n    if (importPath) {\n      if (!tag.node.var) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler41.types.importDeclaration([], import_compiler41.types.stringLiteral(importPath))\n        );\n      } else if (import_compiler41.types.isIdentifier(tag.node.var)) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler41.types.importDeclaration(\n            [import_compiler41.types.importDefaultSpecifier(tag.node.var)],\n            import_compiler41.types.stringLiteral(importPath)\n          )\n        );\n      } else {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler41.types.variableDeclaration(\"const\", [\n            import_compiler41.types.variableDeclarator(\n              tag.node.var,\n              (0, import_babel_utils32.importDefault)(file, importPath, \"style\")\n            )\n          ])\n        );\n      }\n    }\n    tag.remove();\n  },\n  attributes: {}\n};\n\n// src/core/index.ts\nvar core_default = {\n  taglibId,\n  \"<import>\": import_default,\n  \"<export>\": export_default,\n  \"<attrs>\": attrs_default,\n  \"<if>\": IfTag,\n  \"<else-if>\": ElseIfTag,\n  \"<else>\": ElseTag,\n  \"<for>\": for_default,\n  \"<let>\": let_default,\n  \"<const>\": const_default,\n  \"<define>\": define_default,\n  \"<effect>\": effect_default,\n  \"<do>\": do_default,\n  \"<log>\": log_default,\n  \"<debug>\": debug_default,\n  \"<lifecycle>\": lifecycle_default,\n  \"<id>\": id_default,\n  \"<html-comment>\": html_comment_default,\n  \"<return>\": return_default,\n  \"<style>\": style_default,\n  \"<await-reorderer>\": noop_default,\n  \"<init-widgets>\": noop_default,\n  \"<init-components>\": noop_default,\n  \"<static>\": static_default,\n  \"<server>\": server_default,\n  \"<client>\": client_default,\n  \"<__flush_here_and_after__>\": flush_here_and_after_default\n};\n\n// src/visitors/cdata.ts\nvar cdata_default = {\n  translate: {\n    enter(cdata) {\n      throw cdata.buildCodeFrameError(\n        \"CDATA sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/visitors/comment.ts\nvar comment_default = {\n  translate: {\n    exit(comment) {\n      comment.remove();\n    }\n  }\n};\n\n// src/visitors/declaration.ts\nvar declaration_default = {\n  translate: {\n    enter(decl) {\n      throw decl.buildCodeFrameError(\n        \"XML declarations sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/visitors/document-type.ts\nvar document_type_default = {\n  translate: {\n    exit(documentType) {\n      if (isOutputHTML()) {\n        writeTo(documentType)`<!${documentType.node.value}>`;\n      }\n      documentType.remove();\n    }\n  }\n};\n\n// src/visitors/import-declaration.ts\nvar import_babel_utils33 = require(\"@marko/babel-utils\");\nvar import_declaration_default = {\n  analyze(importDecl) {\n    const { node } = importDecl;\n    const { source } = node;\n    const { value } = source;\n    const tagImport = (0, import_babel_utils33.resolveTagImport)(importDecl, value);\n    if (tagImport) {\n      node.extra ??= {};\n      node.extra.tagImport = tagImport;\n      const tags = importDecl.hub.file.metadata.marko.tags;\n      if (!tags.includes(tagImport)) {\n        tags.push(tagImport);\n      }\n    }\n  },\n  translate: {\n    exit(importDecl) {\n      const { node } = importDecl;\n      const { extra } = node;\n      const tagImport = extra?.tagImport;\n      if (tagImport) {\n        node.source.value = tagImport;\n      }\n    }\n  }\n};\n\n// src/visitors/placeholder.ts\nvar import_babel_utils34 = require(\"@marko/babel-utils\");\nvar import_compiler42 = require(\"@marko/compiler\");\nvar kBinding2 = Symbol(\"placeholder node binding\");\nvar kSiblingText = Symbol(\"placeholder has sibling text\");\nvar ESCAPE_TYPES = {\n  script: \"escapeScript\",\n  style: \"escapeStyle\"\n};\nvar placeholder_default = {\n  analyze(placeholder) {\n    const { node } = placeholder;\n    const { confident, computed } = evaluate(placeholder);\n    if (!(confident && (node.escape || !computed))) {\n      (node.extra ??= {})[kBinding2] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        getOrCreateSection(placeholder),\n        void 0,\n        node.value.extra\n      );\n      analyzeSiblingText(placeholder);\n    }\n  },\n  translate: {\n    exit(placeholder) {\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(placeholder);\n      const { node } = placeholder;\n      const { value } = node;\n      const extra = node.extra;\n      const { confident, computed } = extra;\n      const nodeBinding = extra[kBinding2];\n      const canWriteHTML = isHTML || confident && (node.escape || !computed);\n      const method = canWriteHTML ? node.escape ? ESCAPE_TYPES[getParentTagName(placeholder)] || \"escapeXML\" : \"toString\" : node.escape ? \"data\" : \"html\";\n      const isStateful = isStatefulReferences(value.extra?.referencedBindings);\n      const siblingText = extra[kSiblingText];\n      if (confident && canWriteHTML) {\n        write2`${getHTMLRuntime()[method](computed)}`;\n      } else {\n        if (siblingText === 1 /* Before */) {\n          if (isHTML && isStateful) {\n            write2`<!>`;\n          }\n          visit(placeholder, 37 /* Replace */);\n        } else if (siblingText === 2 /* After */) {\n          visit(placeholder, 37 /* Replace */);\n        } else {\n          if (!isHTML) write2` `;\n          visit(placeholder, 32 /* Get */);\n        }\n        if (isHTML) {\n          write2`${callRuntime(method, value)}`;\n          if (isStateful) {\n            markNode(placeholder, nodeBinding);\n          }\n        } else {\n          addStatement(\n            \"render\",\n            getSection(placeholder),\n            value.extra?.referencedBindings,\n            import_compiler42.types.expressionStatement(\n              method === \"data\" ? callRuntime(\n                \"data\",\n                import_compiler42.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(nodeBinding),\n                  true\n                ),\n                value\n              ) : callRuntime(\n                \"html\",\n                scopeIdentifier,\n                value,\n                getScopeAccessorLiteral(nodeBinding)\n              )\n            )\n          );\n        }\n      }\n      enterShallow(placeholder);\n      placeholder.remove();\n    }\n  }\n};\nfunction getParentTagName({ parentPath }) {\n  return parentPath.isMarkoTag() && (0, import_babel_utils34.isNativeTag)(parentPath) && parentPath.node.name.value || \"\";\n}\nfunction analyzeSiblingText(placeholder) {\n  const placeholderExtra = placeholder.node.extra;\n  let prev = placeholder.getPrevSibling();\n  while (prev.node) {\n    const contentType = getNodeContentType(\n      prev,\n      \"endType\"\n    );\n    if (contentType === null) {\n      prev = prev.getPrevSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 1 /* Before */;\n    } else {\n      break;\n    }\n  }\n  if (!prev.node && import_compiler42.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 1 /* Before */;\n  }\n  let next = placeholder.getNextSibling();\n  while (next.node) {\n    const contentType = getNodeContentType(\n      next,\n      \"startType\"\n    );\n    if (contentType === null) {\n      next = next.getNextSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 2 /* After */;\n    } else {\n      break;\n    }\n  }\n  if (!next.node && import_compiler42.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 2 /* After */;\n  }\n  return placeholderExtra[kSiblingText] = 0 /* None */;\n}\n\n// src/visitors/referenced-identifier.ts\nvar import_compiler43 = require(\"@marko/compiler\");\nvar abortIdsByExpressionForSection = /* @__PURE__ */ new WeakMap();\nvar referenced_identifier_default = {\n  migrate(identifier) {\n    const { name } = identifier.node;\n    if (identifier.scope.hasBinding(name)) return;\n    switch (name) {\n      case \"out\":\n        if (import_compiler43.types.isMemberExpression(identifier.parent) && import_compiler43.types.isIdentifier(identifier.parent.property) && identifier.parent.property.name === \"global\") {\n          identifier.parentPath.replaceWith(import_compiler43.types.identifier(\"$global\"));\n        } else {\n          throw identifier.buildCodeFrameError(\n            \"Only `out.global` is supported for compatibility.\"\n          );\n        }\n        break;\n    }\n  },\n  translate(identifier) {\n    const { name } = identifier.node;\n    if (identifier.scope.hasBinding(name)) return;\n    switch (name) {\n      case \"$global\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler43.types.callExpression(importRuntime(\"$global\"), [])\n          );\n        } else {\n          identifier.replaceWith(\n            import_compiler43.types.memberExpression(scopeIdentifier, import_compiler43.types.identifier(\"$global\"))\n          );\n        }\n        break;\n      case \"$signal\":\n        if (isOutputHTML()) {\n          const section = getSection(identifier);\n          if (!section.hasCleanup) {\n            section.hasCleanup = true;\n            const exprRoot = getExprRoot(identifier);\n            const write2 = writeTo(exprRoot);\n            write2`${callRuntime(\"markResumeCleanup\", getScopeIdIdentifier(section))}`;\n          }\n          identifier.replaceWith(\n            import_compiler43.types.callExpression(\n              import_compiler43.types.arrowFunctionExpression(\n                [],\n                import_compiler43.types.blockStatement([\n                  import_compiler43.types.throwStatement(\n                    import_compiler43.types.newExpression(import_compiler43.types.identifier(\"Error\"), [\n                      import_compiler43.types.stringLiteral(\"Cannot use $signal in a server render.\")\n                    ])\n                  )\n                ])\n              ),\n              []\n            )\n          );\n        } else {\n          const section = getSection(identifier);\n          const exprRoot = getExprRoot(identifier);\n          let abortIdsByExpression = abortIdsByExpressionForSection.get(section);\n          let exprId;\n          if (abortIdsByExpression) {\n            exprId = abortIdsByExpression.get(exprRoot);\n          } else {\n            abortIdsByExpression = /* @__PURE__ */ new Map();\n            abortIdsByExpressionForSection.set(section, abortIdsByExpression);\n          }\n          if (!exprId) {\n            exprId = abortIdsByExpression.size;\n            abortIdsByExpression.set(exprRoot, exprId);\n            addStatement(\n              \"render\",\n              section,\n              exprRoot.node.extra?.referencedBindings,\n              import_compiler43.types.expressionStatement(\n                import_compiler43.types.callExpression(importRuntime(\"resetAbortSignal\"), [\n                  scopeIdentifier,\n                  import_compiler43.types.numericLiteral(exprId)\n                ])\n              )\n            );\n          }\n          identifier.replaceWith(\n            import_compiler43.types.callExpression(importRuntime(\"getAbortSignal\"), [\n              scopeIdentifier,\n              import_compiler43.types.numericLiteral(exprId)\n            ])\n          );\n        }\n    }\n  }\n};\n\n// src/visitors/scriptlet.ts\nvar scriptlet_default = {\n  analyze(scriptlet) {\n    mergeReferences(\n      getOrCreateSection(scriptlet),\n      scriptlet.node,\n      scriptlet.node.body\n    );\n  },\n  translate: {\n    exit(scriptlet) {\n      const { node } = scriptlet;\n      if (isOutputHTML()) {\n        if (node.static) return;\n        scriptlet.replaceWithMultiple(node.body);\n      } else {\n        if (node.target && node.target !== \"client\") {\n          scriptlet.remove();\n        } else if (node.static) {\n          scriptlet.replaceWithMultiple(node.body);\n        } else {\n          addStatement(\n            \"render\",\n            getSection(scriptlet),\n            node.extra?.referencedBindings,\n            node.body\n          );\n          scriptlet.remove();\n        }\n      }\n    }\n  }\n};\n\n// src/visitors/tag/index.ts\nvar import_babel_utils38 = require(\"@marko/babel-utils\");\nvar import_compiler47 = require(\"@marko/compiler\");\n\n// src/visitors/tag/attribute-tag.ts\nvar import_babel_utils35 = require(\"@marko/babel-utils\");\nvar import_compiler44 = require(\"@marko/compiler\");\nvar attribute_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils35.assertNoVar)(tag);\n      (0, import_babel_utils35.assertNoArgs)(tag);\n      const body = tag.get(\"body\");\n      startSection(body);\n      trackParamsReferences(body, 3 /* param */);\n      if (!(0, import_babel_utils35.findParentTag)(tag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags must be nested within another tag.\");\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n      }\n    }\n  }\n};\n\n// src/visitors/tag/custom-tag.ts\nvar import_babel_utils36 = require(\"@marko/babel-utils\");\nvar import_compiler45 = require(\"@marko/compiler\");\nvar import_path3 = __toESM(require(\"path\"));\nvar kChildScopeBinding = Symbol(\"custom tag child scope\");\nvar custom_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils36.assertAttributesOrSingleArg)(tag);\n      analyzeAttributeTags(tag);\n      const templateFile = (0, import_babel_utils36.getTagTemplate)(tag);\n      if (!templateFile) {\n        const tagName = getTagName(tag);\n        if (tagName && tag.scope.hasBinding(tagName)) {\n          throw tag.get(\"name\").buildCodeFrameError(\n            `Local variables must in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n          );\n        }\n        throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n      }\n      const section = getOrCreateSection(tag);\n      const tagBody = tag.get(\"body\");\n      const tagExtra = tag.node.extra ??= {};\n      startSection(tagBody);\n      trackVarReferences(tag, 4 /* derived */);\n      trackParamsReferences(tagBody, 3 /* param */);\n      tagExtra[kChildScopeBinding] = createBinding(\n        \"#childScope\",\n        0 /* dom */,\n        section,\n        void 0,\n        tagExtra\n      );\n      const childFile = (0, import_babel_utils36.loadFileForTag)(tag);\n      if (childFile.opts.filename === tag.hub.file.opts.filename) {\n        mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n      } else {\n        const childProgramExtra = childFile.ast.program.extra;\n        analyzeAttrs(\n          section,\n          tag,\n          childProgramExtra?.domExports.params?.props?.[0]\n        );\n        currentProgramPath.node.extra.hasInteractiveChild = childProgramExtra?.isInteractive || childProgramExtra?.hasInteractiveChild || false;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML(tag);\n      } else {\n        translateDOM(tag);\n      }\n    }\n  }\n};\nfunction translateHTML(tag) {\n  const tagBody = tag.get(\"body\");\n  const { node } = tag;\n  let tagIdentifier;\n  flushInto(tag);\n  writeHTMLResumeStatements(tagBody);\n  if (import_compiler45.types.isStringLiteral(node.name)) {\n    const relativePath = getTagRelativePath(tag);\n    tagIdentifier = isCircularRequest(tag.hub.file, relativePath) ? htmlRendererIdentifier : (0, import_babel_utils36.importDefault)(tag.hub.file, relativePath, getTagName(tag));\n  } else {\n    tagIdentifier = node.name;\n  }\n  const tagVar = node.var;\n  const section = getSection(tag);\n  const childScopeBinding = node.extra[kChildScopeBinding];\n  const peekScopeId = tag.scope.generateUidIdentifier(childScopeBinding?.name);\n  tag.insertBefore(\n    import_compiler45.types.variableDeclaration(\"const\", [\n      import_compiler45.types.variableDeclarator(peekScopeId, callRuntime(\"peekNextScope\"))\n    ])\n  );\n  getSerializedScopeProperties(section).set(\n    getScopeAccessorLiteral(childScopeBinding),\n    callRuntime(\"writeExistingScope\", peekScopeId)\n  );\n  const inputExport = (0, import_babel_utils36.loadFileForTag)(tag)?.ast.program.extra?.domExports?.params?.props?.[0];\n  const { properties, statements } = inputExport ? translateAttrs(tag, inputExport.props) : {\n    properties: [],\n    statements: []\n  };\n  if (node.extra.tagNameNullable) {\n    const renderBodyProp = getTranslatedRenderBodyProperty(properties);\n    let renderBodyId = void 0;\n    if (renderBodyProp) {\n      const renderBodyExpression = renderBodyProp.value;\n      renderBodyProp.value = renderBodyId = tag.scope.generateUidIdentifier(\"renderBody\");\n      const [renderBodyPath] = tag.insertBefore(\n        import_compiler45.types.variableDeclaration(\"const\", [\n          import_compiler45.types.variableDeclarator(\n            renderBodyId,\n            // TODO: only register if needed (child template analysis)\n            renderBodyExpression\n          )\n        ])\n      );\n      renderBodyPath.skip();\n    }\n    let renderTagExpr = callExpression(\n      tagIdentifier,\n      propsToExpression(properties)\n    );\n    if (tagVar) {\n      translateVar(tag, import_compiler45.types.unaryExpression(\"void\", import_compiler45.types.numericLiteral(0)), \"let\");\n      renderTagExpr = import_compiler45.types.assignmentExpression(\"=\", tagVar, renderTagExpr);\n    }\n    statements.push(\n      import_compiler45.types.ifStatement(\n        tagIdentifier,\n        import_compiler45.types.expressionStatement(renderTagExpr),\n        renderBodyId && callStatement(renderBodyId)\n      )\n    );\n  } else if (tagVar) {\n    translateVar(\n      tag,\n      callExpression(\n        tagIdentifier,\n        propsToExpression(properties),\n        callRuntime(\n          \"register\",\n          import_compiler45.types.arrowFunctionExpression([], import_compiler45.types.blockStatement([])),\n          import_compiler45.types.stringLiteral(\n            getResumeRegisterId(\n              section,\n              node.var.extra?.binding\n              // TODO: node.var is not always an identifier.\n            )\n          ),\n          getScopeIdIdentifier(section)\n        )\n      )\n    );\n    setForceResumeScope(section);\n  } else {\n    statements.push(\n      callStatement(tagIdentifier, propsToExpression(properties))\n    );\n  }\n  for (const replacement of tag.replaceWithMultiple(statements)) {\n    replacement.skip();\n  }\n}\nfunction translateDOM(tag) {\n  const tagSection = getSection(tag);\n  const { node } = tag;\n  const extra = node.extra;\n  const childScopeBinding = extra[kChildScopeBinding];\n  const write2 = writeTo(tag);\n  const { file } = tag.hub;\n  const tagName = import_compiler45.types.isIdentifier(node.name) ? node.name.name : import_compiler45.types.isStringLiteral(node.name) ? node.name.value : \"tag\";\n  const relativePath = getTagRelativePath(tag);\n  const childFile = (0, import_babel_utils36.loadFileForTag)(tag);\n  const childExports = childFile.ast.program.extra.domExports;\n  const tagIdentifier = importOrSelfReferenceName(\n    file,\n    relativePath,\n    childExports.setup,\n    tagName\n  );\n  const inputExport = childExports.params?.props?.[0];\n  if (inputExport) {\n    writeAttrsToExports(tag, inputExport, `${getTagName(tag) || \"tag\"}_input`, {\n      circular: childFile.opts.filename === file.opts.filename,\n      tagSection,\n      relativePath,\n      childScopeBinding\n    });\n  }\n  write2`${(0, import_babel_utils36.importNamed)(file, relativePath, childExports.template, `${tagName}_template`)}`;\n  injectWalks(\n    tag,\n    (0, import_babel_utils36.importNamed)(file, relativePath, childExports.walks, `${tagName}_walks`)\n  );\n  if (node.var) {\n    const source = initValue(\n      // TODO: support destructuring\n      node.var.extra.binding\n    );\n    source.register = true;\n    source.buildAssignment = (_valueSection, value) => {\n      return import_compiler45.types.callExpression(importRuntime(\"tagVarSignalChange\"), [\n        createScopeReadExpression(source.section, childScopeBinding),\n        value\n      ]);\n    };\n    addStatement(\n      \"render\",\n      tagSection,\n      void 0,\n      import_compiler45.types.expressionStatement(\n        callRuntime(\n          \"setTagVar\",\n          scopeIdentifier,\n          getScopeAccessorLiteral(childScopeBinding),\n          source.identifier\n        )\n      )\n    );\n  }\n  addStatement(\n    \"render\",\n    tagSection,\n    void 0,\n    import_compiler45.types.expressionStatement(\n      import_compiler45.types.callExpression(tagIdentifier, [\n        createScopeReadExpression(tagSection, childScopeBinding)\n      ])\n    )\n  );\n  tag.remove();\n}\nfunction getTagRelativePath(tag) {\n  const {\n    node,\n    hub: { file }\n  } = tag;\n  let relativePath;\n  if (import_compiler45.types.isStringLiteral(node.name)) {\n    const template = (0, import_babel_utils36.getTagTemplate)(tag);\n    relativePath = template && (0, import_babel_utils36.resolveRelativePath)(file, template);\n  } else if (node.extra?.tagNameImported) {\n    relativePath = node.extra.tagNameImported;\n  }\n  if (!relativePath) {\n    const tagName = getTagName(tag);\n    if (tagName && tag.scope.hasBinding(tagName)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        `Local variables must in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n      );\n    }\n    throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n  }\n  return relativePath;\n}\nfunction analyzeAttrs(section, tag, templateExport) {\n  if (!templateExport) {\n    dropReferences(getAllTagReferenceNodes(tag.node));\n    return;\n  }\n  if (!templateExport.props || tag.node.arguments?.length) {\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n    return;\n  }\n  const attrTagLookup = analyzeAttributeTags(tag);\n  const seen = /* @__PURE__ */ new Set();\n  if (attrTagLookup) {\n    const nodeReferencesByGroup = /* @__PURE__ */ new Map();\n    const analyzeDynamicChildGroup = (group, child) => {\n      const referenceNodes = getAllTagReferenceNodes(child.node);\n      const groupReferences = nodeReferencesByGroup.get(group);\n      if (groupReferences) {\n        groupReferences.referenceNodes = groupReferences.referenceNodes.concat(referenceNodes);\n      } else {\n        nodeReferencesByGroup.set(group, {\n          firstTag: child,\n          referenceNodes\n        });\n      }\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n    for (const child of attrTags2) {\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils36.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExports = templateExport.props[attrTagMeta.name];\n          if (childAttrExports) {\n            if (childAttrExports.props && !attrTagMeta.dynamic) {\n              analyzeAttrs(section, child, childAttrExports);\n            } else {\n              analyzeDynamicChildGroup(attrTagMeta.group, child);\n            }\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        } else {\n          const group = child.node.extra.attributeTagGroup;\n          let childUsesGroupProp = false;\n          for (const name of group) {\n            if (templateExport.props[attrTagLookup[name].name]) {\n              childUsesGroupProp = true;\n              break;\n            }\n          }\n          if (childUsesGroupProp) {\n            analyzeDynamicChildGroup(group, child);\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        }\n      }\n    }\n    for (const { firstTag, referenceNodes } of nodeReferencesByGroup.values()) {\n      mergeReferences(section, firstTag.node, referenceNodes);\n    }\n  }\n  const { attributes } = tag.node;\n  let spreadReferenceNodes;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler45.types.isMarkoAttribute(attr2)) {\n      if (seen.has(attr2.name) || !templateExport.props[attr2.name]) {\n        dropReferences(attr2.value);\n        continue;\n      }\n      seen.add(attr2.name);\n    }\n    if (spreadReferenceNodes) {\n      spreadReferenceNodes.push(attr2.value);\n    } else if (import_compiler45.types.isMarkoSpreadAttribute(attr2)) {\n      spreadReferenceNodes = [attr2.value];\n    }\n  }\n  if (spreadReferenceNodes) {\n    mergeReferences(section, tag.node, spreadReferenceNodes);\n  }\n}\nfunction writeAttrsToExports(tag, templateExport, importAlias, info) {\n  if (tag.node.arguments?.length) {\n    const [arg] = tag.node.arguments;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    addValue(\n      info.tagSection,\n      // technically this should be `arg.extra?.referencedBindings`\n      // but we should probably ensure all other references are dropped in this case before we do that.\n      tag.node.extra?.referencedBindings,\n      identifierToSignal(tagInputIdentifier),\n      import_compiler45.types.isSpreadElement(arg) ? import_compiler45.types.memberExpression(arg.argument, import_compiler45.types.numericLiteral(0)) : arg,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding),\n      callRuntime(\n        \"inChild\",\n        getScopeAccessorLiteral(info.childScopeBinding),\n        import_compiler45.types.identifier(tagInputIdentifier.name)\n      )\n    );\n    return;\n  }\n  if (!templateExport.props || info.circular) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    const translatedAttrs = translateAttrs(tag);\n    if (translatedAttrs.statements.length) {\n      addStatement(\n        \"render\",\n        info.tagSection,\n        referencedBindings,\n        translatedAttrs.statements\n      );\n    }\n    addValue(\n      info.tagSection,\n      referencedBindings,\n      identifierToSignal(tagInputIdentifier),\n      propsToExpression(translatedAttrs.properties),\n      createScopeReadExpression(info.tagSection, info.childScopeBinding),\n      callRuntime(\n        \"inChild\",\n        getScopeAccessorLiteral(info.childScopeBinding),\n        import_compiler45.types.identifier(tagInputIdentifier.name)\n      )\n    );\n    return;\n  }\n  const seen = /* @__PURE__ */ new Set();\n  const attrTagLookup = analyzeAttributeTags(tag);\n  if (attrTagLookup) {\n    const attrTags2 = tag.get(\"attributeTags\");\n    const statementsByGroup = /* @__PURE__ */ new Map();\n    const translateDynamicAttrTagChildInGroup = (group, index) => {\n      const child = attrTags2[index];\n      let statements = statementsByGroup.get(group)?.statements;\n      if (!statements) {\n        statements = [];\n        statementsByGroup.set(group, {\n          referencedBindings: child.node.extra?.referencedBindings,\n          statements\n        });\n      }\n      return addDynamicAttrTagStatements(\n        attrTags2,\n        index,\n        attrTagLookup,\n        statements,\n        templateExport.props\n      );\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils36.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExport = templateExport.props[attrTagMeta.name];\n          if (childAttrExport) {\n            if (attrTagMeta.dynamic) {\n              i = translateDynamicAttrTagChildInGroup(attrTagMeta.group, i);\n            } else {\n              writeAttrsToExports(\n                child,\n                childAttrExport,\n                `${importAlias}_${attrTagMeta.name}`,\n                info\n              );\n            }\n          }\n        } else if (child.node.extra?.attributeTagGroup) {\n          i = translateDynamicAttrTagChildInGroup(\n            child.node.extra.attributeTagGroup,\n            i\n          );\n        }\n      }\n    }\n    for (const [\n      group,\n      { referencedBindings, statements }\n    ] of statementsByGroup) {\n      const decls = [];\n      for (const name of group) {\n        const attrTagMeta = attrTagLookup[name];\n        const childAttrExports = templateExport.props[attrTagMeta.name];\n        if (!childAttrExports) continue;\n        const attrExportIdentifier = importOrSelfReferenceName(\n          tag.hub.file,\n          info.relativePath,\n          childAttrExports.id,\n          `${importAlias}_${attrTagMeta.name}`\n        );\n        decls.push(import_compiler45.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta)));\n        addValue(\n          info.tagSection,\n          referencedBindings,\n          identifierToSignal(attrExportIdentifier),\n          getAttrTagIdentifier(attrTagMeta),\n          createScopeReadExpression(info.tagSection, info.childScopeBinding),\n          callRuntime(\n            \"inChild\",\n            getScopeAccessorLiteral(info.childScopeBinding),\n            import_compiler45.types.identifier(attrExportIdentifier.name)\n          )\n        );\n      }\n      addStatement(\"render\", info.tagSection, referencedBindings, [\n        import_compiler45.types.variableDeclaration(\"let\", decls),\n        ...statements\n      ]);\n    }\n  }\n  const bodySection = tag.node.body.extra?.section;\n  if (bodySection && !seen.has(\"renderBody\")) {\n    seen.add(\"renderBody\");\n    if (templateExport.props.renderBody) {\n      const renderBodyExportIdentifier = (0, import_babel_utils36.importNamed)(\n        tag.hub.file,\n        info.relativePath,\n        templateExport.props.renderBody.id,\n        `${importAlias}_renderBody`\n      );\n      addValue(\n        info.tagSection,\n        void 0,\n        // TODO: pretty sure renderBody needs to have the reference group of it's param defaults.\n        identifierToSignal(renderBodyExportIdentifier),\n        import_compiler45.types.callExpression(import_compiler45.types.identifier(bodySection.name), [scopeIdentifier]),\n        createScopeReadExpression(info.tagSection, info.childScopeBinding),\n        callRuntime(\n          \"inChild\",\n          getScopeAccessorLiteral(info.childScopeBinding),\n          import_compiler45.types.identifier(renderBodyExportIdentifier.name)\n        )\n      );\n    }\n  }\n  const { attributes } = tag.node;\n  const staticAttrs = [];\n  let spreadProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler45.types.isMarkoAttribute(attr2)) {\n      const childAttrExports = templateExport.props[attr2.name];\n      if (!childAttrExports || seen.has(attr2.name)) continue;\n      seen.add(attr2.name);\n      if (spreadProps) {\n        spreadProps.push(\n          import_compiler45.types.objectProperty(toPropertyName(attr2.name), attr2.value)\n        );\n        continue;\n      }\n      staticAttrs.push(attr2);\n    } else if (spreadProps) {\n      spreadProps.push(import_compiler45.types.spreadElement(attr2.value));\n    } else {\n      spreadProps = [import_compiler45.types.spreadElement(attr2.value)];\n    }\n  }\n  for (const attr2 of staticAttrs.reverse()) {\n    const childAttrExports = templateExport.props[attr2.name];\n    const attrExportIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      childAttrExports.id,\n      `${importAlias}_${attr2.name}`\n    );\n    addValue(\n      info.tagSection,\n      attr2.value.extra?.referencedBindings,\n      identifierToSignal(attrExportIdentifier),\n      attr2.value,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding),\n      callRuntime(\n        \"inChild\",\n        getScopeAccessorLiteral(info.childScopeBinding),\n        import_compiler45.types.identifier(attrExportIdentifier.name)\n      )\n    );\n  }\n  const missing = new Set(Object.keys(templateExport.props));\n  for (const name of seen) missing.delete(name);\n  if (missing.size) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    let getMissingPropValue = buildUndefined2;\n    if (spreadProps) {\n      const spreadId = tag.scope.generateUidIdentifier(`${importAlias}_spread`);\n      spreadProps.reverse();\n      getMissingPropValue = (name) => import_compiler45.types.memberExpression(spreadId, toPropertyName(name));\n      addStatement(\"render\", info.tagSection, referencedBindings, [\n        import_compiler45.types.variableDeclaration(\"const\", [\n          import_compiler45.types.variableDeclarator(spreadId, propsToExpression(spreadProps))\n        ])\n      ]);\n    }\n    for (const name of missing) {\n      const childAttrExports = templateExport.props[name];\n      const attrExportIdentifier = importOrSelfReferenceName(\n        tag.hub.file,\n        info.relativePath,\n        childAttrExports.id,\n        `${importAlias}_${name}`\n      );\n      addValue(\n        info.tagSection,\n        referencedBindings,\n        identifierToSignal(attrExportIdentifier),\n        getMissingPropValue(name),\n        createScopeReadExpression(info.tagSection, info.childScopeBinding),\n        callRuntime(\n          \"inChild\",\n          getScopeAccessorLiteral(info.childScopeBinding),\n          import_compiler45.types.identifier(attrExportIdentifier.name)\n        )\n      );\n    }\n  }\n}\nfunction importOrSelfReferenceName(file, request, name, nameHint) {\n  if (isCircularRequest(file, request)) {\n    return import_compiler45.types.identifier(name);\n  }\n  return (0, import_babel_utils36.importNamed)(file, request, name, nameHint);\n}\nfunction isCircularRequest(file, request) {\n  const { filename } = file.opts;\n  return request === filename || request[0] === \".\" && import_path3.default.resolve(filename, \"..\", request) === filename;\n}\nfunction callStatement(id, ...args) {\n  return import_compiler45.types.expressionStatement(callExpression(id, ...args));\n}\nfunction callExpression(id, ...args) {\n  return import_compiler45.types.callExpression(id, args.filter(Boolean));\n}\nfunction identifierToSignal(identifier) {\n  return {\n    identifier,\n    hasDownstreamIntersections: always\n  };\n}\nfunction buildUndefined2() {\n  return import_compiler45.types.unaryExpression(\"void\", import_compiler45.types.numericLiteral(0));\n}\nfunction always() {\n  return true;\n}\n\n// src/visitors/tag/dynamic-tag.ts\nvar import_babel_utils37 = require(\"@marko/babel-utils\");\nvar import_compiler46 = require(\"@marko/compiler\");\nvar kDOMBinding = Symbol(\"dynamic tag dom binding\");\nvar dynamic_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils37.assertAttributesOrArgs)(tag);\n      analyzeAttributeTags(tag);\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      const tagBody = tag.get(\"body\");\n      const domBinding = tagExtra[kDOMBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section,\n        void 0,\n        tagExtra\n      );\n      startSection(tagBody);\n      trackVarReferences(tag, 4 /* derived */);\n      trackParamsReferences(tagBody, 3 /* param */);\n      mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n      addReferenceToExpression(tag, domBinding);\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag, 37 /* Replace */);\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const extra = node.extra;\n      const nodeRef2 = extra[kDOMBinding];\n      const section = getSection(tag);\n      let tagExpression = node.name;\n      if (import_compiler46.types.isStringLiteral(tagExpression)) {\n        tagExpression = (0, import_babel_utils37.importDefault)(\n          tag.hub.file,\n          getTagRelativePath(tag),\n          tagExpression.value\n        );\n      }\n      if (extra.featureType === \"class\") {\n        const compatRuntimeFile = getCompatRuntimeFile(tag.hub.file.markoOpts);\n        (0, import_babel_utils37.importDefault)(tag.hub.file, compatRuntimeFile);\n        if (isOutputHTML()) {\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler46.types.expressionStatement(\n              import_compiler46.types.callExpression(\n                (0, import_babel_utils37.importNamed)(tag.hub.file, compatRuntimeFile, \"s\"),\n                [\n                  import_compiler46.types.identifier(tagExpression.name),\n                  import_compiler46.types.stringLiteral((0, import_babel_utils37.loadFileForTag)(tag).metadata.marko.id)\n                ]\n              )\n            )\n          );\n        } else {\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler46.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                import_compiler46.types.stringLiteral((0, import_babel_utils37.loadFileForTag)(tag).metadata.marko.id),\n                import_compiler46.types.identifier(tagExpression.name)\n              )\n            )\n          );\n        }\n      }\n      const { properties, statements } = translateAttrs(tag);\n      const args = [];\n      let hasMultipleArgs = false;\n      if (node.arguments?.length) {\n        args.push(...node.arguments);\n        if (properties.length) {\n          hasMultipleArgs = true;\n          args.push(propsToExpression(properties));\n        } else {\n          hasMultipleArgs = node.arguments.length > 1 || import_compiler46.types.isSpreadElement(node.arguments[0]);\n        }\n      } else {\n        const renderBodyProp = getTranslatedRenderBodyProperty(properties);\n        if (renderBodyProp) {\n          properties.splice(properties.indexOf(renderBodyProp), 1);\n          args.push(propsToExpression(properties), renderBodyProp.value);\n        } else {\n          args.push(propsToExpression(properties));\n        }\n      }\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        const write2 = writeTo(tag);\n        if (node.var) {\n          if (!hasMultipleArgs && args.length === 1) {\n            args.push(import_compiler46.types.unaryExpression(\"void\", import_compiler46.types.numericLiteral(0)));\n          }\n          args.push(\n            callRuntime(\n              \"register\",\n              import_compiler46.types.arrowFunctionExpression([], import_compiler46.types.blockStatement([])),\n              import_compiler46.types.stringLiteral(\n                getResumeRegisterId(\n                  section,\n                  node.var.extra?.binding\n                  // TODO: node.var is not always an identifier.\n                )\n              ),\n              getScopeIdIdentifier(section)\n            )\n          );\n        }\n        const dynamicScopeIdentifier = currentProgramPath.scope.generateUidIdentifier(\"dynamicScope\");\n        const dynamicTagExpr = hasMultipleArgs ? callRuntime(\n          \"dynamicTagArgs\",\n          dynamicScopeIdentifier,\n          tagExpression,\n          import_compiler46.types.arrayExpression(args)\n        ) : callRuntime(\n          \"dynamicTagInput\",\n          dynamicScopeIdentifier,\n          tagExpression,\n          ...args\n        );\n        statements.push(\n          import_compiler46.types.variableDeclaration(\"const\", [\n            import_compiler46.types.variableDeclarator(\n              dynamicScopeIdentifier,\n              callRuntime(\"peekNextScope\")\n            )\n          ])\n        );\n        statements.push(\n          node.var ? import_compiler46.types.variableDeclaration(\"const\", [\n            import_compiler46.types.variableDeclarator(node.var, dynamicTagExpr)\n          ]) : import_compiler46.types.expressionStatement(dynamicTagExpr)\n        );\n        write2`${callRuntime(\n          \"markResumeControlEnd\",\n          getScopeIdIdentifier(section),\n          getScopeAccessorLiteral(nodeRef2)\n        )}`;\n        getSerializedScopeProperties(section).set(\n          import_compiler46.types.stringLiteral(\n            getScopeAccessorLiteral(nodeRef2).value + \"!\" /* ConditionalScope */\n          ),\n          callRuntime(\"writeExistingScope\", dynamicScopeIdentifier)\n        );\n        getSerializedScopeProperties(section).set(\n          import_compiler46.types.stringLiteral(\n            getScopeAccessorLiteral(nodeRef2).value + \"(\" /* ConditionalRenderer */\n          ),\n          callRuntime(\n            \"normalizeDynamicRenderer\",\n            import_compiler46.types.isIdentifier(tagExpression) ? import_compiler46.types.identifier(tagExpression.name) : tagExpression\n          )\n        );\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      } else {\n        const section2 = getSection(tag);\n        const bodySection = getSectionForBody(tag.get(\"body\"));\n        const signal = getSignal(section2, nodeRef2, \"dynamicTagName\");\n        signal.build = () => {\n          return callRuntime(\n            \"conditional\",\n            getScopeAccessorLiteral(nodeRef2),\n            getSignalFn(signal, [scopeIdentifier]),\n            buildSignalIntersections(signal)\n          );\n        };\n        signal.hasDownstreamIntersections = () => true;\n        addValue(\n          section2,\n          node.name.extra?.referencedBindings,\n          signal,\n          bodySection ? import_compiler46.types.logicalExpression(\n            \"||\",\n            tagExpression,\n            import_compiler46.types.callExpression(import_compiler46.types.identifier(bodySection.name), [\n              scopeIdentifier\n            ])\n          ) : tagExpression\n        );\n        if (tag.node.var) {\n          const childScopeLiteral = import_compiler46.types.stringLiteral(\n            getScopeAccessorLiteral(extra[kDOMBinding]).value + \"!\" /* ConditionalScope */\n          );\n          const source = initValue(\n            // TODO: support destructuring\n            tag.node.var.extra.binding\n          );\n          source.register = true;\n          source.buildAssignment = (valueSection, value) => {\n            return import_compiler46.types.callExpression(importRuntime(\"tagVarSignalChange\"), [\n              import_compiler46.types.memberExpression(\n                getScopeExpression(source.section, valueSection),\n                childScopeLiteral,\n                true\n              ),\n              value\n            ]);\n          };\n          addStatement(\n            \"render\",\n            section2,\n            nodeRef2,\n            import_compiler46.types.expressionStatement(\n              callRuntime(\n                \"setTagVar\",\n                scopeIdentifier,\n                childScopeLiteral,\n                source.identifier\n              )\n            )\n          );\n        }\n        if (args.length) {\n          const argsOrInput = hasMultipleArgs ? import_compiler46.types.arrayExpression(args) : args[0];\n          const attrsGetter = import_compiler46.types.arrowFunctionExpression(\n            [],\n            statements.length ? import_compiler46.types.blockStatement(\n              statements.concat(import_compiler46.types.returnStatement(argsOrInput))\n            ) : argsOrInput\n          );\n          const id = currentProgramPath.scope.generateUidIdentifier(\n            tag.get(\"name\").toString() + \"_input\"\n          );\n          let added = false;\n          addValue(\n            section2,\n            node.extra?.referencedBindings,\n            {\n              get identifier() {\n                if (!added) {\n                  currentProgramPath.pushContainer(\n                    \"body\",\n                    import_compiler46.types.variableDeclaration(\"const\", [\n                      import_compiler46.types.variableDeclarator(\n                        id,\n                        callRuntime(\n                          \"dynamicTagAttrs\",\n                          getScopeAccessorLiteral(nodeRef2),\n                          bodySection && import_compiler46.types.identifier(bodySection.name),\n                          hasMultipleArgs && import_compiler46.types.numericLiteral(1)\n                        )\n                      )\n                    ])\n                  );\n                  added = true;\n                }\n                return id;\n              },\n              hasDownstreamIntersections: () => true\n            },\n            attrsGetter\n          );\n        }\n        tag.remove();\n      }\n    }\n  }\n};\nfunction getCompatRuntimeFile(markoOpts) {\n  return `marko/src/runtime/helpers/tags-compat/${isOutputHTML() ? \"html\" : \"dom\"}${markoOpts.optimize ? \"\" : \"-debug\"}.${markoOpts.modules === \"esm\" ? \"mjs\" : \"js\"}`;\n}\n\n// src/visitors/tag/index.ts\nvar tag_default = {\n  transform: {\n    enter(tag) {\n      const attrs2 = tag.get(\"attributes\");\n      for (let i = 0; i < attrs2.length; i++) {\n        const attr2 = attrs2[i];\n        if (import_compiler47.types.isMarkoAttribute(attr2.node) && attr2.node.bound) {\n          attr2.node.bound = false;\n          const changeValue = getChangeHandler(tag, attr2);\n          if (changeValue === null) {\n            throw attr2.buildCodeFrameError(\n              \"Attributes may only be bound to identifiers or member expressions\"\n            );\n          }\n          tag.node.attributes.splice(\n            ++i,\n            0,\n            import_compiler47.types.markoAttribute(attr2.node.name + \"Change\", changeValue)\n          );\n          tag.scope.crawl();\n        }\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils38.getTagDef)(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        enter(hook, tag);\n        return;\n      }\n      if (type === 0 /* NativeTag */) {\n        native_tag_default.analyze.enter(tag);\n        return;\n      }\n      switch (type) {\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.analyze.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.analyze.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const hook = (0, import_babel_utils38.getTagDef)(tag)?.analyzer?.hook;\n      if (hook) {\n        exit(hook, tag);\n        return;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils38.getTagDef)(tag);\n      const extra = tag.node.extra;\n      if (tagDef?.translator) {\n        if (tagDef.translator.path) {\n          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);\n        }\n        enter(tagDef.translator.hook, tag);\n        return;\n      }\n      for (const attr2 of tag.get(\"attributes\")) {\n        if (attr2.isMarkoAttribute()) {\n          if (attr2.node.arguments) {\n            throw attr2.buildCodeFrameError(\n              `Unsupported arguments on the \\`${attr2.node.name}\\` attribute.`\n            );\n          }\n          if (attr2.node.modifier) {\n            if ((0, import_babel_utils38.isNativeTag)(attr2.parentPath)) {\n              attr2.node.name += `:${attr2.node.modifier}`;\n            } else {\n              throw attr2.buildCodeFrameError(\n                `Unsupported modifier \\`${attr2.node.modifier}\\`.`\n              );\n            }\n          }\n        }\n      }\n      if (extra.tagNameDynamic && extra.tagNameNullable && !tag.get(\"name\").isIdentifier() && isOutputHTML()) {\n        const tagNameId = tag.scope.generateUidIdentifier(\"tagName\");\n        const [tagNameVarPath] = tag.insertBefore(\n          import_compiler47.types.variableDeclaration(\"const\", [\n            import_compiler47.types.variableDeclarator(tagNameId, tag.node.name)\n          ])\n        );\n        tagNameVarPath.skip();\n        tag.set(\"name\", tagNameId);\n      }\n      switch (extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const translator = (0, import_babel_utils38.getTagDef)(tag)?.translator;\n      if (translator) {\n        exit(translator.hook, tag);\n        return;\n      }\n      switch (tag.node.extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.exit(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.exit(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.exit(tag);\n          break;\n      }\n    }\n  }\n};\nfunction getChangeHandler(tag, attr2) {\n  if (import_compiler47.types.isIdentifier(attr2.node.value)) {\n    const valueId = tag.scope.generateUidIdentifier(\n      \"new_\" + attr2.node.value.name\n    );\n    return import_compiler47.types.functionExpression(\n      null,\n      [valueId],\n      import_compiler47.types.blockStatement([\n        import_compiler47.types.expressionStatement(\n          import_compiler47.types.assignmentExpression(\"=\", attr2.node.value, valueId)\n        )\n      ])\n    );\n  } else if (import_compiler47.types.isMemberExpression(attr2.node.value)) {\n    const prop = attr2.node.value.property;\n    if (import_compiler47.types.isPrivateName(prop)) return null;\n    if (import_compiler47.types.isIdentifier(prop)) {\n      return import_compiler47.types.memberExpression(\n        import_compiler47.types.cloneNode(attr2.node.value.object),\n        import_compiler47.types.identifier(prop.name + \"Change\")\n      );\n    } else {\n      return import_compiler47.types.memberExpression(\n        import_compiler47.types.cloneNode(attr2.node.value.object),\n        import_compiler47.types.binaryExpression(\"+\", import_compiler47.types.cloneNode(prop), import_compiler47.types.stringLiteral(\"Change\")),\n        true\n      );\n    }\n  }\n  return null;\n}\n\n// src/visitors/text.ts\nvar import_compiler48 = require(\"@marko/compiler\");\nvar text_default = {\n  translate: {\n    exit(text) {\n      writeTo(text)`${text.node.value}`;\n      enterShallow(text);\n      text.remove();\n    }\n  }\n};\n\n// src/index.ts\nvar visitors = extractVisitors({\n  Program: program_default,\n  Function: function_default,\n  AssignmentExpression: assignment_expression_default,\n  UpdateExpression: update_expression_default,\n  ReferencedIdentifier: referenced_identifier_default,\n  ImportDeclaration: import_declaration_default,\n  MarkoDocumentType: document_type_default,\n  MarkoDeclaration: declaration_default,\n  MarkoCDATA: cdata_default,\n  MarkoText: text_default,\n  MarkoTag: tag_default,\n  MarkoPlaceholder: placeholder_default,\n  MarkoScriptlet: scriptlet_default,\n  MarkoComment: comment_default\n});\nvar { transform, analyze, translate } = visitors;\nvar taglibs = [\n  [\n    __dirname,\n    {\n      ...core_default,\n      migrate: visitors.migrate\n    }\n  ]\n];\nfunction getRuntimeEntryFiles(output, optimize) {\n  return [\n    `@marko/runtime-tags${optimize ? \"\" : \"/debug\"}/${output === \"html\" ? \"html\" : \"dom\"}`\n  ];\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  analyze,\n  getRuntimeEntryFiles,\n  internalEntryBuilder,\n  taglibs,\n  transform,\n  translate\n});\n"],"names":["mod","__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__copyProps","to","from","except","desc","key","call","get","enumerable","__toESM","isNodeMode","target","__esModule","value","src_exports","__export","all","name","analyze","getRuntimeEntryFiles","internalEntryBuilder","entry_builder_default","taglibs","transform","translate","module","exports","import_babel_utils","require","getTagName","tag","node","taglibId","isCoreTag","id","isMarkoTag","getTagDef","isCoreTagName","isConditionTag","import_babel_utils2","flush_here_and_after_default","renderer","replaceWithMultiple","body","import_compiler","attrs_default","migrate","tagVar","var","type","remove","constTag","types","markoTag","stringLiteral","markoAttribute","identifier","markoTagBody","replaceWith","attributes","autocomplete","displayText","description","snippet","import_babel_utils3","import_compiler2","client_default","parse","hub","file","rawValue","code","replace","trim","start","length","parseStatements","isBlockStatement","markoScriptlet","parseOptions","statement","rawOpenTag","descriptionMoreURL","import_babel_utils11","import_compiler19","assertNoSpreadAttrs","attr2","isMarkoSpreadAttribute","buildCodeFrameError","assertNoBodyContent","import_babel_utils10","import_compiler17","import_path","bindingHasDownstreamExpressions","binding","downstreamExpressions","size","alias","aliases","propertyAliases","values","import_babel_utils4","import_compiler3","kState","Symbol","build","entryFile","state","path","imports","map","it","importDeclaration","init","unshift","importSpecifier","markoOpts","optimize","push","expressionStatement","callExpression","visit","visitChild","analyzedTags","metadata","marko","resolveRelativePath","opts","filename","extra","hasInteractiveChild","isInteractive","import_compiler6","getMarkoRoot","path4","curPath","parentPath","isMarko","getExprRoot","destructRoot","getDestructureRoot","isFunctionExpression","parent","isStatefulReferences","referencedBindings","Array","isArray","isStatefulBinding","ref","upstreamExpression","data","item","forEach","cb","i","find","findSorted","compare","max","pos","mid","cur","compareResult","addSorted","len","result","next","joinRepeatable","a","b","import_babel_utils6","import_compiler5","createProgramState","map2","WeakMap","currentProgramPath","set","createSectionState","section","arrayOfSectionData","import_babel_utils5","import_compiler4","withPreviousLocation","newNode","originalNode","loc","end","MARKO_FILE_REG","TAG_NAME_IDENTIFIER_REG","analyzeTagNameType","tagNameType","isStringLiteral","isNativeTag","bindingName","bindingIdentifier","scope","getBinding","test","tagIdentifier","analyzeExpressionTagName","tagNameNullable","childFile","loadFileForTag","ast","program","featureType","pending","tagNameImported","nullable","pop","isConditionalExpression","alternate","isLogicalExpression","operator","isAssignmentExpression","isBinaryExpression","isTemplateLiteral","isNullLiteral","isIdentifier","kind","decl","source","specifiers","some","isImportDefaultSpecifier","resolvedImport","resolveTagImport","bindingTag","bindingTagName","tagNameDynamic","startSection","parentSection","getOrCreateSection","sectionNamePath","sectionName","isProgram","generateUid","toString","programExtra","sections","depth","params","closures","bindings","content","getContentInfo","hasCleanup","attributeTags","getSectionForBody","getSection","currentPath","getScopeIdIdentifier","generateUidIdentifier","getSectionParentIsOwner","setSectionParentIsOwner","_getScopeIdentifier","getScopeIdentifier","ignoreDefault","scopeId","forEachSection","fn","contentInfo","startType","endType","singleChild","endIndex","getNodeContentType","startIndex","extraMember","isMarkoText","isMarkoPlaceholder","isMarkoScriptlet","isMarkoComment","isAttributeTag","tagSection","isStatefulSection","checkStatefulClosures","immediateOnly","closure","getBindings","Set","getNextBindingId","setNextBindingId","createBinding","upstreamAlias","property","excludeProperties","serialize","Map","export","propBinding","add","trackVarReferences","changeBinding","canonicalUpstreamAlias","getCanonicalBinding","delete","createBindingsAndTrackReferences","trackParamsReferences","paramsBinding","assignBinding","prop","properties","element","elements","argument","lVal","babelBinding","referencePaths","constantViolations","referencePath","trackReference","left","isUpdateExpression","trackReferencesForBinding","patternBinding","Error","fnRoot","getFnRoot","exprRoot","reference","exprExtra","addReferenceToExpression","fnExtra","addReference","getMergedReferences","mergeReferences","nodes","compareIntersections","lenDelta","bindingUtil","isSuperset","subset","elem","has","getSourceBindings","derived","sources","crawl","binding2","curBinding","constructor","this","union","aLen","bLen","aIndex","bIndex","aValue","bValue","delta","unionSortedRepeatable","getIntersections","setIntersections","getDroppedReferences","dropReferences","droppedReferences","getAllTagReferenceNodes","referenceNodes","arguments","arg","child","findReferences","intersections","intersection","getScopeAccessorLiteral","getMarkoOpts","numericLiteral","pruneBinding","shouldPrune","import_compiler15","import_babel_utils7","import_compiler7","stringifyClassObject","NON_DIMENSIONAL","stringifyStyleObject","toDelimitedString","val","delimiter","stringify","curDelimiter","v","part","isEventHandler","getEventHandlerName","slice","toLowerCase","unsafeXMLReg","replaceUnsafeXML","c","escapeXML","str","unsafeScriptReg","escapeScript","unsafeStyleReg","escapeStyle","classAttr","stringAttr","styleAttr","attr","attrAssignment","RegExp","nonVoidAttr","escapeAttrValue","async","KNOWN_SYMBOLS2","symbol","AggregateError","of","ArrayBuffer","isView","Atomics","and","compareExchange","exchange","isLockFree","load","notify","or","store","sub","wait","BigInt","asIntN","asUintN","BigInt64Array","BigUint64Array","Boolean","console","assert","clear","count","countReset","debug","dir","dirxml","error","group","groupCollapsed","groupEnd","info","log","table","time","timeEnd","timeLog","timeStamp","trace","warn","DataView","Date","now","UTC","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","EvalError","Float32Array","Float64Array","Function","globalThis","atob","btoa","clearImmediate","clearInterval","clearTimeout","crypto","getRandomValues","randomUUID","fetch","performance","queueMicrotask","setImmediate","setInterval","setTimeout","structuredClone","URL","URLSearchParams","WritableStream","Int16Array","Int32Array","Int8Array","Intl","Collator","DateTimeFormat","DisplayNames","getCanonicalLocales","ListFormat","Locale","NumberFormat","PluralRules","RelativeTimeFormat","Segmenter","supportedValuesOf","isFinite","isNaN","JSON","groupBy","Math","abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","floor","fround","hypot","imul","log10","log1p","log2","min","pow","random","round","sign","sin","sinh","sqrt","tan","tanh","trunc","Number","isInteger","isSafeInteger","parseFloat","parseInt","assign","defineProperties","entries","freeze","fromEntries","getOwnPropertyDescriptors","getOwnPropertySymbols","is","isExtensible","isFrozen","isSealed","keys","preventExtensions","seal","setPrototypeOf","Promise","Proxy","RangeError","ReferenceError","Reflect","apply","construct","deleteProperty","ownKeys","String","fromCharCode","fromCodePoint","raw","for","SyntaxError","TypeError","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","URIError","WeakSet","unsafeAttrChars","lastIndex","pureFunctions","importRuntime","output","memberExpression","importStar","getRuntimePath","callRuntime","args","callExpression2","filteredArgs","unaryExpression","filterArguments","includes","leadingComments","getHTMLRuntime","import_babel_utils9","import_compiler14","import_babel_utils8","import_compiler12","getKnownAttrValues","attrs2","import_compiler8","enter","modulePlugin","plugin","isModulePlugin","default","isFunctionPlugin","exit","translateByTarget","html","dom","isOutputHTML","import_compiler11","import_compiler9","toTemplateOrStringLiteral","parts","strs","exprs","curStr","nextIndex","exprLen","expressions","shiftItems","quasis","j","templateLiteral","templateElement","appendLiteral","arr","list","offset","import_compiler10","getWalks","getWalkComment","getSteps","walkCodeToName","enter2","exit2","enterShallow","steps","walks","walkComment","walkString","walkCodes","step","lastIndexOf","current","walk","nCodeString","writeTo","number","toCharString","startCode","rangeSize","multiplier","getWalkString","prefix2","postfix","walkLiteral","join","getWrites","exprsLen","writes","consumeHTML","flushBefore","expr","insertBefore","skip","flushInto","pushContainer","getSectionMeta","writePrefix","writePostfix","setup","getSetup","markNode","returnId","_setReturnId","usedTag","return_default","assertNoArgs","assertNoVar","assertNoParams","assertAllowedAttributes","valueChange","getSerializedScopeProperties","returnId2","variableDeclaration","variableDeclarator","addValue","hasDownstreamIntersections","import_compiler13","createScopeReadPattern","rootDepth","rootPattern","objectPattern","nestedPatterns","propertyKey","propertyValue","isShorthand","pattern","relativeDepth","prev","nestedPattern","objectProperty","getScopeExpression","targetSection","scopeIdentifier","diff","createScopeReadExpression","getSignals","getSubscribeBuilder","_setSubscribeBuilder","setSubscriberBuilder","builder","forceResumeScope","_setForceResumeScope","setForceResumeScope","unimplementedBuild","getSignal","generateSignalName","signals","signal","exportName","domExports","render","effect","effectInlineReferences","subscribers","subscribe","getSignalFn","buildSignalIntersections","ownerScope","isImmediateOwner","object","isDynamicClosure","arrowFunctionExpression","initValue","runtimeHelper","valueAccessor","isParamBinding","scopeIdentifier2","valueIdentifier","aliasSignal","extraArgs","toMemberExpression","blockStatement","signal2","intersectionExpression","isMemberExpression","closureEntries","sort","closureSection","closureSignal","hasDynamicSubscribers","arrayExpression","provider","subscriber","p","providerSignal","finalizeSignalArgs","isArrowFunctionExpression","isExpressionStatement","expression","addStatement","originalNodes","isInlined","statements","isFunction","addEffectReferences","getResumeRegisterId","getTemplateId","usedRegisterIdsBySection","getRegisterUID","used","baseId","renameBindings","traverseFast","writeSignals","sortSignals","effectDeclarator","effectIdentifier","isCallExpression","register","signalDeclarator","signalDeclaration","functionDeclaration","isExpression","exportNamedDeclaration","roots","root","traverse","bindFunctionsVisitor","aReferencedBindings","getReferencedBindings","bReferencedBindings","reserve","getMappedId","addHTMLEffectCall","writeHTMLResumeStatements","tagVarIdentifier","allSignals","scopeIdIdentifier","currentSection","signalRefs","accessors","additionalProperties","serializedProperties","accessor","isLiteral","objectExpression","unshiftContainer","FunctionExpression","bindFunction","ArrowFunctionExpression","handleDestructure","assignment","ctx","getStatementParent","buildAssignment","valueId","insertAfter","fnId","returnStatement","keyLiteral","keyToNode","dom_default","templateIdentifier","template","walksIdentifier","setupIdentifier","closuresIdentifier","programParamsSignal","assignments","valueSection","replacement","binaryExpression","prefix","sequenceExpression","right","replaceAssignments","forEachSectionReverse","childSection","tagParamsSignal","walks2","writes2","setup2","closures2","getSectionClosuresExpr","exportDefaultDeclaration","reverse","htmlRendererIdentifier","import_compiler16","html_default","returnIdentifier","renderContent","isImportDeclaration","isExportDeclaration","static","previousProgramPath","program_default","mergedReferences","targetExtra","isEffect","additionalBindings","referencedBinding","name2","bindingReference","numReferences","binding1","sources1","sources2","sourceSection","bindings2","filter","finalizeReferences","buildTemplateExports","isOutputDOM","visitedFiles","resolved","loadFileForImport","req","resolveRelativeToEntry","templateExport","props","exports2","import_compiler18","translateVar","initialValue","const_default","valueAttr","isMarkoAttribute","varBinding","derivation","import_babel_utils12","import_compiler20","debug_default","debuggerStatement","import_babel_utils19","import_babel_utils18","import_compiler28","import_babel_utils16","import_compiler26","getParentTag","import_babel_utils15","import_compiler25","import_babel_utils13","evaluate","confident","computed","computeNode","import_compiler21","IDENTIFIER_REG","toPropertyName","assignment_expression_default","handleDestructure2","import_babel_utils14","import_compiler23","functionIdsBySection","registeredFunctions","function_default","markoRoot","toIdentifier","functionNameCounts","index","registerId","isStatic2","serializedScopeProperties","isFunctionDeclaration","update_expression_default","kNativeTagBinding","kSerializeMarker","kGetterId","htmlSelectArgs","getRelatedControllable","tagName","checked","checkedChange","special","helper","attrs","checkedValue","checkedValueChange","open","openChange","native_tag_default","escape","buildError","buildUndefined","assertNoAttributeTags","hasEventHandlers","hasDynamicAttributes","seen","relatedControllable","spreadReferenceNodes","propName","exclusiveGroups","assertExclusiveControllableGroups","every","tagName2","tagExtra","nodeRef2","isHTML","tagDef","write2","getterId","varName","references","getterFnIdentifier","referenceSection","visitAccessor","usedAttrs","maybeStaticAttrs","spreadExpression","skipExpression","spreadProps","skipProps","staticControllable","attr3","attrToObjectProperty","spreadElement","staticAttrs","propsToExpression","getUsedAttrs","writeAtStartOfBody","changeAttr","firstAttr","HoistVisitors","spreadIdentifier","valueReferences","openTagOnly","htmlType","ifStatement","selectArgs","UpdateExpression","AssignmentExpression","kForMarkerBinding","kForScopeStartIndex","kOnlyChildInParent","for_default","isAttrTag","allowAttrs","getForType","tagBody","bodySection","isOnlyChildInParent","parentTag","parentTagName","isStateful","updateExpression","forAttrs","forType","bodyStatements","hasStatefulClosures","keyExpression","singleNodeOptimization","defaultParamNames","in","defaultByParamIndex","requiredParamsIndex","by","existingParam","byIdentifier","forScopeIdsIdentifier","forScopesIdentifier","newExpression","conditionalExpression","buildForRuntimeCall","forTypeToDOMRuntime","param","referencedBindings2","loopArgs","getBaseArgsInForTag","controlFlow","forTypeToRuntime","import_babel_utils17","import_compiler27","attrTagToIdentifierLookup","getAttrTagIdentifier","meta","analyzeAttributeTags","attrTags2","lookup","attrTagNodesByName","sampleAttrTagsForControlFlow","createAttrTagMeta","isRepeated","isLoopTag","curGroup","crawlAttrTags","oldMeta","attrTagMeta","dynamic","repeated","controlFlowTag","sampleAttrName","attributeTagGroup","attrTagNodes","hasRepeatedDynamicAttrTags","attrTagNames","conditionRoot","seenBranches","attrTag2","curConditionRoot","getConditionRoot","getPrevSibling","renderBodyProps","translateAttrs","templateExports","attrTagLookup","usesExport","addDynamicAttrTagStatements","translatedAttrTag","prevProp","findObjectProperty","renderBodyExpression","isTransparentTag","getNonAttributeTagParent","buildRenderBody","renderBodyProp","getTranslatedRenderBodyProperty","assignmentExpression","ifTag","consequentStatements","getConditionTestValue","addAllAttrTagsAsDynamic","nextTag","testValue","alternateStatements","translateIfAttrTag","forTag","translateForAttrTag","isSpreadElement","define_default","translatedAttrs","import_babel_utils20","import_compiler30","do_default","hasDeclaration","isDeclaration","import_babel_utils21","import_compiler31","effect_default","value2","inlineBody","import_babel_utils22","export_default","import_babel_utils23","import_compiler32","kCommentTagBinding","kGetterId2","html_comment_default","assertNoAttributes","needsBinding","needsGetter","commentBinding","templateQuasis","templateExpressions","currentQuasi","text","import_babel_utils24","import_compiler33","id_default","import_babel_utils25","import_compiler35","import_compiler34","kBinding","BRANCHES_LOOKUP","IfTag","assertHasBody","assertHasValueAttribute","assertHasPrecedingCondition","ifAttr","msg","assertOptionalIfAttribute","assertValidCondition","isLast","branches","getBranches","rootTag","rootExtra","mergeReferenceNodes","branchTag","branchBodySection","isRoot","getRoot","getNextSibling","ifScopeIdIdentifier","ifRendererIdentifier","branchHasStatefulClosures","testAttr","curStatement","nullLiteral","consequent","ElseIfTag","ElseTag","import_babel_utils26","import_default","import_babel_utils27","import_compiler36","let_default","valueChangeAttr","valueChangeReferences","valueChangeBinding","isSetup","extraArgsExpression","changeBindingId","import_babel_utils28","import_compiler37","kRef","supportedAttrNames","lifecycle_default","lifecycleAttrsRef","import_babel_utils29","import_compiler38","log_default","noop_default","import_babel_utils30","import_compiler39","server_default","import_babel_utils31","import_compiler40","static_default","import_babel_utils32","import_compiler41","comma","charCodeAt","semicolon","intToChar","charToInt","chars","encodeInteger","num","relative","clamped","write","td","TextDecoder","Buffer","decode","buf","buffer","byteOffset","byteLength","out","StringWriter","flush","subarray","BitSet","_BitSet","bits","n2","Chunk2","_Chunk","original","intro","outro","storeName","edited","previous","appendLeft","appendRight","clone","chunk","contains","eachNext","eachPrevious","edit","contentOnly","prependLeft","prependRight","reset","split","sliceIndex","originalBefore","originalAfter","newChunk","trimEnd","rx","trimmed","trimStart","unescape","SourceMap","version","sourcesContent","names","mappings","decoded","writer","sourcesIndex","sourceLine","sourceColumn","namesIndex","line","genColumn","segment","encode","x_google_ignoreList","toUrl","getRelativePath","fromParts","toParts","shift","concat","toString2","getLocator","originalLines","lineOffsets","m","column","wordRegex","Mappings","hires","generatedCodeLine","generatedCodeColumn","rawSegments","addEdit","sourceIndex","nameIndex","contentLengthMinusOne","contentLineEnd","indexOf","previousContentLineEnd","segment2","advance","addUneditedChunk","sourcemapLocations","originalCharIndex","first","charInHiresBoundary","lines","n","warned","insertLeft","insertRight","MagicString","_MagicString","string","options","writable","firstChunk","lastChunk","lastSearchedChunk","byStart","byEnd","indentExclusionRanges","storedNames","indentStr","ignoreList","addSourcemapLocation","char","append","_split","cloned","originalChunk","clonedChunk","nextOriginalChunk","nextClonedChunk","generateDecodedMap","locate","includeContent","generateMap","_ensureindentStr","tabbed","spaced","reduce","numSpaces","exec","Infinity","guessIndent","_getRawIndentString","getIndentString","indent","thing","isExcluded","exclude","exclusion","shouldIndentNextCharacter","indentStart","replacer","match","charIndex","_splitChunk","insert","move","last","oldLeft","oldRight","newRight","newLeft","overwrite","update","prepend","lastChar","lastLine","lineIndex","substr","lineStr","startChunk","containsEnd","sliceStart","sliceEnd","snip","searchForward","isEmpty","trimLines","charType","trimEndAborted","aborted","trimStartAborted","hasChanged","_replaceRegexp","searchValue","getReplacement","_","groups","global","re","matches","matchAll","replacement2","_replaceString","_replaceAllString","stringLength","replaceAll","import_path2","core_default","sourceMaps","base","basename","typeAttr","classAttr2","typeValue","classValue2","startsWith","markoText","resolveVirtualDependency","getStart","getEnd","magicString","importPath","virtualPath","importDefaultSpecifier","importDefault","cdata_default","cdata","comment_default","comment","declaration_default","document_type_default","documentType","import_babel_utils33","import_declaration_default","importDecl","tagImport","tags","import_babel_utils34","import_compiler42","kBinding2","kSiblingText","ESCAPE_TYPES","script","style","placeholder_default","placeholder","placeholderExtra","contentType","analyzeSiblingText","nodeBinding","canWriteHTML","method","getParentTagName","siblingText","import_compiler43","abortIdsByExpressionForSection","referenced_identifier_default","hasBinding","throwStatement","exprId","abortIdsByExpression","scriptlet_default","scriptlet","import_babel_utils38","import_compiler47","import_babel_utils35","attribute_tag_default","findParentTag","import_babel_utils36","import_compiler45","import_path3","kChildScopeBinding","custom_tag_default","assertAttributesOrSingleArg","getTagTemplate","charAt","toUpperCase","childProgramExtra","analyzeAttrs","relativePath","getTagRelativePath","isCircularRequest","childScopeBinding","peekScopeId","inputExport","renderBodyId","renderBodyPath","renderTagExpr","callStatement","translateHTML","childExports","importOrSelfReferenceName","writeAttrsToExports","circular","importNamed","injectWalks","_valueSection","translateDOM","nodeReferencesByGroup","analyzeDynamicChildGroup","groupReferences","firstTag","attrTagName","childAttrExports","childUsesGroupProp","importAlias","tagInputIdentifier","identifierToSignal","statementsByGroup","translateDynamicAttrTagChildInGroup","childAttrExport","decls","attrExportIdentifier","renderBody","renderBodyExportIdentifier","missing","getMissingPropValue","buildUndefined2","spreadId","request","nameHint","resolve","always","import_babel_utils37","import_compiler46","kDOMBinding","dynamic_tag_default","assertAttributesOrArgs","domBinding","tagExpression","compatRuntimeFile","modules","hasMultipleArgs","splice","dynamicScopeIdentifier","dynamicTagExpr","section2","logicalExpression","childScopeLiteral","argsOrInput","attrsGetter","added","tag_default","bound","changeValue","getChangeHandler","hook","analyzer","translator","watchFiles","modifier","tagNameId","tagNameVarPath","functionExpression","isPrivateName","cloneNode","visitors","visitors2","_name","extractVisitors","Program","ReferencedIdentifier","ImportDeclaration","MarkoDocumentType","MarkoDeclaration","MarkoCDATA","MarkoText","MarkoTag","MarkoPlaceholder","MarkoScriptlet","MarkoComment"],"sourceRoot":""}