{"version":3,"file":"420.5350c725.js","mappings":"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","sources":["webpack:///../../node_modules/@marko/runtime-tags/dist/translator/index.js"],"sourcesContent":["\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name2 in all)\n    __defProp(target, name2, { get: all[name2], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/translator/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  analyze: () => analyze,\n  getRuntimeEntryFiles: () => getRuntimeEntryFiles,\n  internalEntryBuilder: () => entry_builder_default,\n  preferAPI: () => preferAPI,\n  tagDiscoveryDirs: () => tagDiscoveryDirs,\n  taglibs: () => taglibs,\n  transform: () => transform,\n  translate: () => translate\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// src/translator/util/runtime-info.ts\nvar import_package = require(\"../../package.json\");\nvar runtime_info_default = {\n  name: import_package.name,\n  taglibId: \"marko-core\"\n};\n\n// src/translator/core/attrs.ts\nvar import_compiler = require(\"@marko/compiler\");\nvar import_babel_utils = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/assert.ts\nfunction assertNoSpreadAttrs(tag) {\n  for (const attr2 of tag.get(\"attributes\")) {\n    if (attr2.isMarkoSpreadAttribute()) {\n      throw attr2.buildCodeFrameError(\n        `The \\`${tag.get(\"name\").node.value}\\` tag does not support \\`...spread\\` attributes.`\n      );\n    }\n  }\n}\nfunction assertNoBodyContent(tag) {\n  if (tag.node.body.body.length) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${tag.get(\"name\").node.value}\\` tag does not support body content.`\n    );\n  }\n}\n\n// src/translator/core/attrs.ts\nvar attrs_default = {\n  migrate: [\n    (tag) => {\n      (0, import_babel_utils.assertNoArgs)(tag);\n      (0, import_babel_utils.assertNoParams)(tag);\n      (0, import_babel_utils.assertNoAttributes)(tag);\n      assertNoBodyContent(tag);\n      (0, import_babel_utils.assertNoAttributeTags)(tag);\n      (0, import_babel_utils.diagnosticDeprecate)(tag, {\n        label: \"The `attrs` tag is deprecated, prefer destructuring `input` via the `const` tag.\",\n        fix() {\n          const tagVar = tag.node.var;\n          if (tagVar && !(tagVar.type === \"Identifier\" && tagVar.name === \"input\")) {\n            const constTag = import_compiler.types.markoTag(\n              import_compiler.types.stringLiteral(\"const\"),\n              [import_compiler.types.markoAttribute(\"value\", import_compiler.types.identifier(\"input\"))],\n              import_compiler.types.markoTagBody([])\n            );\n            constTag.var = tagVar;\n            tag.replaceWith(constTag);\n          } else {\n            tag.remove();\n          }\n        }\n      });\n    }\n  ],\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"attrs/{ ... }\",\n      description: \"Use to receive the attributes passed into this template.\",\n      snippet: \"attrs/{ $1 }$2\"\n    }\n  ]\n};\n\n// src/translator/core/await.ts\nvar import_compiler25 = require(\"@marko/compiler\");\nvar import_babel_utils18 = require(\"@marko/compiler/babel-utils\");\n\n// src/common/accessor.debug.ts\nvar AccessorPrefix = /* @__PURE__ */ ((AccessorPrefix4) => {\n  AccessorPrefix4[\"ClosureScopes\"] = \"ClosureScopes:\";\n  AccessorPrefix4[\"ClosureSignalIndex\"] = \"ClosureSignalIndex:\";\n  AccessorPrefix4[\"ConditionalRenderer\"] = \"ConditionalRenderer:\";\n  AccessorPrefix4[\"ConditionalScope\"] = \"ConditionalScope:\";\n  AccessorPrefix4[\"ControlledHandler\"] = \"ControlledHandler:\";\n  AccessorPrefix4[\"ControlledType\"] = \"ControlledType:\";\n  AccessorPrefix4[\"ControlledValue\"] = \"ControlledValue:\";\n  AccessorPrefix4[\"DynamicPlaceholderLastChild\"] = \"DynamicPlaceholderLastChild:\";\n  AccessorPrefix4[\"EventAttributes\"] = \"EventAttributes:\";\n  AccessorPrefix4[\"Getter\"] = \"Getter:\";\n  AccessorPrefix4[\"LifecycleAbortController\"] = \"LifecycleAbortController:\";\n  AccessorPrefix4[\"LoopScopeArray\"] = \"LoopScopeArray:\";\n  AccessorPrefix4[\"LoopScopeMap\"] = \"LoopScopeMap:\";\n  AccessorPrefix4[\"Promise\"] = \"Promise:\";\n  AccessorPrefix4[\"TagVariableChange\"] = \"TagVariableChange:\";\n  return AccessorPrefix4;\n})(AccessorPrefix || {});\nvar AccessorProp = /* @__PURE__ */ ((AccessorProp4) => {\n  AccessorProp4[\"Owner\"] = \"_\";\n  AccessorProp4[\"BranchAccessor\"] = \"#BranchAccessor\";\n  AccessorProp4[\"CatchContent\"] = \"#CatchContent\";\n  AccessorProp4[\"PlaceholderBranch\"] = \"#PlaceholderBranch\";\n  AccessorProp4[\"PlaceholderContent\"] = \"#PlaceholderContent\";\n  AccessorProp4[\"TagVariable\"] = \"#TagVariable\";\n  AccessorProp4[\"TagVariableChange\"] = \"#TagVariableChange\";\n  AccessorProp4[\"ClosestBranchId\"] = \"#ClosestBranchId\";\n  return AccessorProp4;\n})(AccessorProp || {});\n\n// src/translator/util/evaluate.ts\nvar import_babel_utils2 = require(\"@marko/compiler/babel-utils\");\nfunction evaluate(value) {\n  let { extra } = value;\n  if (!extra) {\n    extra = value.extra = {};\n  }\n  if (extra.confident === void 0) {\n    const computed = (0, import_babel_utils2.computeNode)(value);\n    if (computed) {\n      extra.computed = computed.value;\n      extra.confident = true;\n      extra.nullable = computed.value == null;\n    } else {\n      extra.computed = void 0;\n      extra.confident = false;\n      extra.nullable = isNullableExpr(value);\n    }\n  }\n  return extra;\n}\nfunction isNullableExpr(expr) {\n  switch (expr.type) {\n    case \"ArrayExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"BigIntLiteral\":\n    case \"BinaryExpression\":\n    case \"BooleanLiteral\":\n    case \"ClassExpression\":\n    case \"FunctionExpression\":\n    case \"NewExpression\":\n    case \"NumericLiteral\":\n    case \"ObjectExpression\":\n    case \"RegExpLiteral\":\n    case \"StringLiteral\":\n    case \"TemplateLiteral\":\n    case \"UpdateExpression\":\n      return false;\n    case \"AssignmentExpression\":\n      switch (expr.operator) {\n        case \"=\":\n          return isNullableExpr(expr.right);\n        case \"*=\":\n        case \"/=\":\n        case \"%=\":\n        case \"+=\":\n        case \"-=\":\n        case \"<<=\":\n        case \">>=\":\n        case \">>>=\":\n        case \"&=\":\n        case \"^=\":\n        case \"|=\":\n        case \"**=\":\n          return false;\n        case \"||=\":\n        case \"??=\":\n          return isNullableExpr(expr.right) || isNullableExpr(expr.left);\n        case \"&&=\":\n          return isNullableExpr(expr.left) && isNullableExpr(expr.right);\n        default:\n          return true;\n      }\n    case \"AwaitExpression\":\n      return isNullableExpr(expr.argument);\n    case \"ConditionalExpression\":\n      return isNullableExpr(expr.consequent) && isNullableExpr(expr.alternate);\n    case \"LogicalExpression\":\n      switch (expr.operator) {\n        case \"||\":\n        case \"??\":\n          return isNullableExpr(expr.right) || isNullableExpr(expr.left);\n        case \"&&\":\n          return isNullableExpr(expr.left) && isNullableExpr(expr.right);\n        default:\n          return true;\n      }\n    case \"ParenthesizedExpression\":\n      return isNullableExpr(expr.expression);\n    case \"SequenceExpression\":\n      return isNullableExpr(expr.expressions[expr.expressions.length - 1]);\n    case \"UnaryExpression\":\n      return expr.operator === \"void\";\n    default:\n      return true;\n  }\n}\n\n// src/translator/util/references.ts\nvar import_compiler24 = require(\"@marko/compiler\");\nvar import_babel_utils17 = require(\"@marko/compiler/babel-utils\");\n\n// src/html/serializer.ts\nvar kTouchedIterator = Symbol();\nvar { hasOwnProperty } = {};\nvar Generator = function* () {\n}().constructor;\nvar AsyncGenerator = async function* () {\n}().constructor;\npatchIteratorNext(Generator.prototype);\npatchIteratorNext(AsyncGenerator.prototype);\nvar KNOWN_SYMBOLS = (() => {\n  const KNOWN_SYMBOLS2 = /* @__PURE__ */ new Map();\n  for (const name2 of Object.getOwnPropertyNames(Symbol)) {\n    const symbol = Symbol[name2];\n    if (typeof symbol === \"symbol\") {\n      KNOWN_SYMBOLS2.set(symbol, \"Symbol.\" + name2);\n    }\n  }\n  return KNOWN_SYMBOLS2;\n})();\nvar KNOWN_FUNCTIONS = /* @__PURE__ */ new Map([\n  // This is by no means an exhaustive list,\n  // but it should cover most of the built-in functions.\n  [AggregateError, \"AggregateError\"],\n  [Array, \"Array\"],\n  [Array.from, \"Array.from\"],\n  [Array.isArray, \"Array.isArray\"],\n  [Array.of, \"Array.of\"],\n  [ArrayBuffer, \"ArrayBuffer\"],\n  [ArrayBuffer.isView, \"ArrayBuffer.isView\"],\n  [Atomics.add, \"Atomics.add\"],\n  [Atomics.and, \"Atomics.and\"],\n  [Atomics.compareExchange, \"Atomics.compareExchange\"],\n  [Atomics.exchange, \"Atomics.exchange\"],\n  [Atomics.isLockFree, \"Atomics.isLockFree\"],\n  [Atomics.load, \"Atomics.load\"],\n  [Atomics.notify, \"Atomics.notify\"],\n  [Atomics.or, \"Atomics.or\"],\n  [Atomics.store, \"Atomics.store\"],\n  [Atomics.sub, \"Atomics.sub\"],\n  [Atomics.wait, \"Atomics.wait\"],\n  [BigInt, \"BigInt\"],\n  [BigInt.asIntN, \"BigInt.asIntN\"],\n  [BigInt.asUintN, \"BigInt.asUintN\"],\n  [BigInt64Array, \"BigInt64Array\"],\n  [BigInt64Array.from, \"BigInt64Array.from\"],\n  [BigInt64Array.of, \"BigInt64Array.of\"],\n  [BigUint64Array, \"BigUint64Array\"],\n  [BigUint64Array.from, \"BigUint64Array.from\"],\n  [BigUint64Array.of, \"BigUint64Array.of\"],\n  [Boolean, \"Boolean\"],\n  [console.assert, \"console.assert\"],\n  [console.clear, \"console.clear\"],\n  [console.count, \"console.count\"],\n  [console.countReset, \"console.countReset\"],\n  [console.debug, \"console.debug\"],\n  [console.dir, \"console.dir\"],\n  [console.dirxml, \"console.dirxml\"],\n  [console.error, \"console.error\"],\n  [console.group, \"console.group\"],\n  [console.groupCollapsed, \"console.groupCollapsed\"],\n  [console.groupEnd, \"console.groupEnd\"],\n  [console.info, \"console.info\"],\n  [console.log, \"console.log\"],\n  [console.table, \"console.table\"],\n  [console.time, \"console.time\"],\n  [console.timeEnd, \"console.timeEnd\"],\n  [console.timeLog, \"console.timeLog\"],\n  [console.timeStamp, \"console.timeStamp\"],\n  [console.trace, \"console.trace\"],\n  [console.warn, \"console.warn\"],\n  [DataView, \"DataView\"],\n  [Date, \"Date\"],\n  [Date.now, \"Date.now\"],\n  [Date.parse, \"Date.parse\"],\n  [Date.UTC, \"Date.UTC\"],\n  [decodeURI, \"decodeURI\"],\n  [decodeURIComponent, \"decodeURIComponent\"],\n  [encodeURI, \"encodeURI\"],\n  [encodeURIComponent, \"encodeURIComponent\"],\n  [Error, \"Error\"],\n  [EvalError, \"EvalError\"],\n  [Float32Array, \"Float32Array\"],\n  [Float32Array.from, \"Float32Array.from\"],\n  [Float32Array.of, \"Float32Array.of\"],\n  [Float64Array, \"Float64Array\"],\n  [Float64Array.from, \"Float64Array.from\"],\n  [Float64Array.of, \"Float64Array.of\"],\n  [Function, \"Function\"],\n  [globalThis.atob, \"atob\"],\n  [globalThis.btoa, \"btoa\"],\n  [globalThis.clearImmediate, \"clearImmediate\"],\n  [globalThis.clearInterval, \"clearInterval\"],\n  [globalThis.clearTimeout, \"clearTimeout\"],\n  [globalThis.crypto?.getRandomValues, \"crypto.getRandomValues\"],\n  [globalThis.crypto?.randomUUID, \"crypto.randomUUID\"],\n  [globalThis.fetch, \"fetch\"],\n  [globalThis.performance?.now, \"performance.now\"],\n  [globalThis.queueMicrotask, \"queueMicrotask\"],\n  [globalThis.setImmediate, \"setImmediate\"],\n  [globalThis.setInterval, \"setInterval\"],\n  [globalThis.setTimeout, \"setTimeout\"],\n  [globalThis.structuredClone, \"structuredClone\"],\n  [globalThis.URL, \"URL\"],\n  [globalThis.URLSearchParams, \"URLSearchParams\"],\n  [globalThis.WritableStream, \"WritableStream\"],\n  [Int16Array, \"Int16Array\"],\n  [Int16Array.from, \"Int16Array.from\"],\n  [Int16Array.of, \"Int16Array.of\"],\n  [Int32Array, \"Int32Array\"],\n  [Int32Array.from, \"Int32Array.from\"],\n  [Int32Array.of, \"Int32Array.of\"],\n  [Int8Array, \"Int8Array\"],\n  [Int8Array.from, \"Int8Array.from\"],\n  [Int8Array.of, \"Int8Array.of\"],\n  [Intl.Collator, \"Intl.Collator\"],\n  [Intl.DateTimeFormat, \"Intl.DateTimeFormat\"],\n  [Intl.DisplayNames, \"Intl.DisplayNames\"],\n  [Intl.getCanonicalLocales, \"Intl.getCanonicalLocales\"],\n  [Intl.ListFormat, \"Intl.ListFormat\"],\n  [Intl.Locale, \"Intl.Locale\"],\n  [Intl.NumberFormat, \"Intl.NumberFormat\"],\n  [Intl.PluralRules, \"Intl.PluralRules\"],\n  [Intl.RelativeTimeFormat, \"Intl.RelativeTimeFormat\"],\n  [Intl.Segmenter, \"Intl.Segmenter\"],\n  [Intl.supportedValuesOf, \"Intl.supportedValuesOf\"],\n  [isFinite, \"isFinite\"],\n  [isNaN, \"isNaN\"],\n  [JSON.parse, \"JSON.parse\"],\n  [JSON.stringify, \"JSON.stringify\"],\n  [Map, \"Map\"],\n  [Map.groupBy, \"Map.groupBy\"],\n  [Math.abs, \"Math.abs\"],\n  [Math.acos, \"Math.acos\"],\n  [Math.acosh, \"Math.acosh\"],\n  [Math.asin, \"Math.asin\"],\n  [Math.asinh, \"Math.asinh\"],\n  [Math.atan, \"Math.atan\"],\n  [Math.atan2, \"Math.atan2\"],\n  [Math.atanh, \"Math.atanh\"],\n  [Math.cbrt, \"Math.cbrt\"],\n  [Math.ceil, \"Math.ceil\"],\n  [Math.clz32, \"Math.clz32\"],\n  [Math.cos, \"Math.cos\"],\n  [Math.cosh, \"Math.cosh\"],\n  [Math.exp, \"Math.exp\"],\n  [Math.expm1, \"Math.expm1\"],\n  [Math.floor, \"Math.floor\"],\n  [Math.fround, \"Math.fround\"],\n  [Math.hypot, \"Math.hypot\"],\n  [Math.imul, \"Math.imul\"],\n  [Math.log, \"Math.log\"],\n  [Math.log10, \"Math.log10\"],\n  [Math.log1p, \"Math.log1p\"],\n  [Math.log2, \"Math.log2\"],\n  [Math.max, \"Math.max\"],\n  [Math.min, \"Math.min\"],\n  [Math.pow, \"Math.pow\"],\n  [Math.random, \"Math.random\"],\n  [Math.round, \"Math.round\"],\n  [Math.sign, \"Math.sign\"],\n  [Math.sin, \"Math.sin\"],\n  [Math.sinh, \"Math.sinh\"],\n  [Math.sqrt, \"Math.sqrt\"],\n  [Math.tan, \"Math.tan\"],\n  [Math.tanh, \"Math.tanh\"],\n  [Math.trunc, \"Math.trunc\"],\n  [Number, \"Number\"],\n  [Number.isFinite, \"Number.isFinite\"],\n  [Number.isInteger, \"Number.isInteger\"],\n  [Number.isNaN, \"Number.isNaN\"],\n  [Number.isSafeInteger, \"Number.isSafeInteger\"],\n  [Number.parseFloat, \"Number.parseFloat\"],\n  [Number.parseInt, \"Number.parseInt\"],\n  [Object, \"Object\"],\n  [Object.assign, \"Object.assign\"],\n  [Object.create, \"Object.create\"],\n  [Object.defineProperties, \"Object.defineProperties\"],\n  [Object.defineProperty, \"Object.defineProperty\"],\n  [Object.entries, \"Object.entries\"],\n  [Object.freeze, \"Object.freeze\"],\n  [Object.fromEntries, \"Object.fromEntries\"],\n  [Object.getOwnPropertyDescriptor, \"Object.getOwnPropertyDescriptor\"],\n  [Object.getOwnPropertyDescriptors, \"Object.getOwnPropertyDescriptors\"],\n  [Object.getOwnPropertyNames, \"Object.getOwnPropertyNames\"],\n  [Object.getOwnPropertySymbols, \"Object.getOwnPropertySymbols\"],\n  [Object.getPrototypeOf, \"Object.getPrototypeOf\"],\n  [Object.is, \"Object.is\"],\n  [Object.isExtensible, \"Object.isExtensible\"],\n  [Object.isFrozen, \"Object.isFrozen\"],\n  [Object.isSealed, \"Object.isSealed\"],\n  [Object.keys, \"Object.keys\"],\n  [Object.preventExtensions, \"Object.preventExtensions\"],\n  [Object.seal, \"Object.seal\"],\n  [Object.setPrototypeOf, \"Object.setPrototypeOf\"],\n  [Object.values, \"Object.values\"],\n  [parseFloat, \"parseFloat\"],\n  [parseInt, \"parseInt\"],\n  [Promise, \"Promise\"],\n  [Proxy, \"Proxy\"],\n  [RangeError, \"RangeError\"],\n  [ReferenceError, \"ReferenceError\"],\n  [Reflect.apply, \"Reflect.apply\"],\n  [Reflect.construct, \"Reflect.construct\"],\n  [Reflect.defineProperty, \"Reflect.defineProperty\"],\n  [Reflect.deleteProperty, \"Reflect.deleteProperty\"],\n  [Reflect.get, \"Reflect.get\"],\n  [Reflect.getOwnPropertyDescriptor, \"Reflect.getOwnPropertyDescriptor\"],\n  [Reflect.getPrototypeOf, \"Reflect.getPrototypeOf\"],\n  [Reflect.has, \"Reflect.has\"],\n  [Reflect.isExtensible, \"Reflect.isExtensible\"],\n  [Reflect.ownKeys, \"Reflect.ownKeys\"],\n  [Reflect.preventExtensions, \"Reflect.preventExtensions\"],\n  [Reflect.set, \"Reflect.set\"],\n  [Reflect.setPrototypeOf, \"Reflect.setPrototypeOf\"],\n  [RegExp, \"RegExp\"],\n  [Set, \"Set\"],\n  [String, \"String\"],\n  [String.fromCharCode, \"String.fromCharCode\"],\n  [String.fromCodePoint, \"String.fromCodePoint\"],\n  [String.raw, \"String.raw\"],\n  [Symbol, \"Symbol\"],\n  [Symbol.for, \"Symbol.for\"],\n  [SyntaxError, \"SyntaxError\"],\n  [TypeError, \"TypeError\"],\n  [Uint16Array, \"Uint16Array\"],\n  [Uint16Array.from, \"Uint16Array.from\"],\n  [Uint16Array.of, \"Uint16Array.of\"],\n  [Uint32Array, \"Uint32Array\"],\n  [Uint32Array.from, \"Uint32Array.from\"],\n  [Uint32Array.of, \"Uint32Array.of\"],\n  [Uint8Array, \"Uint8Array\"],\n  [Uint8Array.from, \"Uint8Array.from\"],\n  [Uint8Array.of, \"Uint8Array.of\"],\n  [Uint8ClampedArray, \"Uint8ClampedArray\"],\n  [Uint8ClampedArray.from, \"Uint8ClampedArray.from\"],\n  [Uint8ClampedArray.of, \"Uint8ClampedArray.of\"],\n  [URIError, \"URIError\"],\n  [WeakMap, \"WeakMap\"],\n  [WeakSet, \"WeakSet\"]\n]);\nvar KNOWN_OBJECTS = /* @__PURE__ */ new Map([\n  [Atomics, \"Atomics\"],\n  [console, \"console\"],\n  [globalThis, \"globalThis\"],\n  [globalThis.crypto, \"crypto\"],\n  [Intl, \"Intl\"],\n  [JSON, \"JSON\"],\n  [Math, \"Math\"],\n  [Reflect, \"Reflect\"]\n]);\nfunction toAccess(accessor) {\n  const start = accessor[0];\n  return start === '\"' || start >= \"0\" && start <= \"9\" ? \"[\" + accessor + \"]\" : \".\" + accessor;\n}\nfunction patchIteratorNext(proto) {\n  const { next } = proto;\n  proto.next = function(value) {\n    this[kTouchedIterator] = 1;\n    return next.call(this, value);\n  };\n}\n\n// src/translator/util/for-each-identifier.ts\nfunction forEachIdentifier(node, cb) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        switch (prop.type) {\n          case \"ObjectProperty\":\n            if (prop.value.type === \"AssignmentPattern\") {\n              forEachIdentifier(prop.value.left, cb);\n            } else {\n              forEachIdentifier(prop.value, cb);\n            }\n            break;\n          case \"RestElement\":\n            forEachIdentifier(prop.argument, cb);\n            break;\n        }\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const el of node.elements) {\n        if (el != null) {\n          switch (el.type) {\n            case \"RestElement\":\n              forEachIdentifier(el.argument, cb);\n              break;\n            case \"AssignmentPattern\":\n              forEachIdentifier(el.left, cb);\n              break;\n            default:\n              forEachIdentifier(el, cb);\n              break;\n          }\n        }\n      }\n      break;\n    case \"Identifier\":\n      cb(node);\n      break;\n  }\n}\n\n// src/translator/util/generate-uid.ts\nvar import_compiler3 = require(\"@marko/compiler\");\nvar import_babel_utils4 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-compile-stage.ts\nvar import_babel_utils3 = require(\"@marko/compiler/babel-utils\");\nfunction getCompileStage() {\n  return (0, import_babel_utils3.getFile)().___compileStage;\n}\nfunction isTranslate() {\n  return getCompileStage() === \"translate\" /* translate */;\n}\n\n// src/translator/util/traverse.ts\nvar import_compiler2 = require(\"@marko/compiler\");\nvar skip = Symbol(\"skip\");\nfunction traverseReplace(container, key, enter3) {\n  const node = container[key];\n  if (node) {\n    if (Array.isArray(node)) {\n      for (let i = node.length; i--; ) {\n        traverseReplace(node, i, enter3);\n      }\n    } else {\n      const keys = import_compiler2.types.VISITOR_KEYS[node.type];\n      for (let i = keys.length; i--; ) {\n        traverseReplace(node, keys[i], enter3);\n      }\n      const replacement = enter3(node, container, key);\n      if (replacement) container[key] = replacement;\n    }\n  }\n}\nfunction traverseContains(node, check) {\n  if (node) {\n    if (Array.isArray(node)) {\n      for (const item of node) {\n        if (traverseContains(item, check)) {\n          return true;\n        }\n      }\n    } else {\n      switch (check(node)) {\n        case true:\n          return true;\n        case skip:\n          return false;\n      }\n      for (const key of import_compiler2.types.VISITOR_KEYS[node.type]) {\n        if (traverseContains(node[key], check)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction traverse(visit2, node, parent, grandParent) {\n  if (node) {\n    if (Array.isArray(node)) {\n      for (const item of node) {\n        traverse(visit2, item, parent, grandParent);\n      }\n    } else if (visit2(node, parent, grandParent) !== skip) {\n      for (const key of import_compiler2.types.VISITOR_KEYS[node.type]) {\n        traverse(visit2, node[key], node, parent);\n      }\n    }\n  }\n}\n\n// src/translator/util/generate-uid.ts\nvar countsForFile = /* @__PURE__ */ new WeakMap();\nfunction generateUid(name2 = \"\") {\n  const file = (0, import_babel_utils4.getFile)();\n  let counts = countsForFile.get(file);\n  if (!counts) {\n    const { cache } = file.markoOpts;\n    const { filename } = file.opts;\n    const cacheKey = `uid-counts:${filename}`;\n    counts = cache.get(cacheKey);\n    if (counts) {\n      if (isTranslate()) {\n        counts = new Map(counts);\n      }\n    } else {\n      counts = getInitialCounts(file);\n      if (!isTranslate()) {\n        cache.set(cacheKey, counts);\n      }\n    }\n    countsForFile.set(file, counts);\n  }\n  name2 = name2.replace(/^[^a-z$_]|[^a-z$_0-9]/gi, \"\") || \"temp\";\n  name2 = /^\\$?(.*?)\\d*$/.exec(name2)?.[1] || name2;\n  const i = (counts.get(name2) || 0) + 1;\n  const uniqueName = `$${i > 1 ? name2 + i : name2}`;\n  counts.set(name2, i);\n  return uniqueName;\n}\nfunction generateUidIdentifier(name2) {\n  return import_compiler3.types.identifier(generateUid(name2));\n}\nvar sharedUIDsForFile = /* @__PURE__ */ new WeakMap();\nfunction getSharedUid(name2) {\n  const file = (0, import_babel_utils4.getFile)();\n  let sharedUIDs = sharedUIDsForFile.get(file);\n  if (!sharedUIDs) {\n    const { cache } = file.markoOpts;\n    const { filename } = file.opts;\n    const cacheKey = `uid-shared:${filename}`;\n    sharedUIDs = cache.get(cacheKey);\n    if (sharedUIDs) {\n      if (isTranslate()) {\n        sharedUIDs = new Map(sharedUIDs);\n      }\n    } else {\n      sharedUIDs = /* @__PURE__ */ new Map();\n      if (!isTranslate()) {\n        cache.set(cacheKey, sharedUIDs);\n      }\n    }\n    sharedUIDsForFile.set(file, sharedUIDs);\n  }\n  let uniqueName = sharedUIDs.get(name2);\n  if (!uniqueName) {\n    uniqueName = generateUid(name2);\n    sharedUIDs.set(name2, uniqueName);\n  }\n  return uniqueName;\n}\nfunction usedSharedUid(name2) {\n  return !!sharedUIDsForFile.get((0, import_babel_utils4.getFile)())?.has(name2);\n}\nfunction getInitialCounts(file) {\n  const counts = /* @__PURE__ */ new Map();\n  const program = file.path;\n  const countName = (name2) => {\n    const match = /^$(.*?)([1-9]\\d*)?$/.exec(name2);\n    if (match) {\n      const name3 = match[1];\n      const count = match[2] ? +match[2] + 1 : 1;\n      counts.set(name3, Math.max(counts.get(name3) || 0, count));\n    }\n  };\n  for (const name2 in program.scope.globals) {\n    countName(name2);\n  }\n  traverse((node, parent, grandParent) => {\n    if (node.type === \"Identifier\" && import_compiler3.types.isBinding(node, parent, grandParent)) {\n      countName(node.name);\n    }\n  }, program.node);\n  return counts;\n}\n\n// src/common/accessor.ts\nvar AccessorPrefix2 = /* @__PURE__ */ ((AccessorPrefix4) => {\n  AccessorPrefix4[\"ClosureScopes\"] = \"a\";\n  AccessorPrefix4[\"ClosureSignalIndex\"] = \"b\";\n  AccessorPrefix4[\"ConditionalRenderer\"] = \"c\";\n  AccessorPrefix4[\"ConditionalScope\"] = \"d\";\n  AccessorPrefix4[\"ControlledHandler\"] = \"e\";\n  AccessorPrefix4[\"ControlledType\"] = \"f\";\n  AccessorPrefix4[\"ControlledValue\"] = \"g\";\n  AccessorPrefix4[\"DynamicPlaceholderLastChild\"] = \"h\";\n  AccessorPrefix4[\"EventAttributes\"] = \"i\";\n  AccessorPrefix4[\"Getter\"] = \"j\";\n  AccessorPrefix4[\"LifecycleAbortController\"] = \"k\";\n  AccessorPrefix4[\"LoopScopeArray\"] = \"l\";\n  AccessorPrefix4[\"LoopScopeMap\"] = \"m\";\n  AccessorPrefix4[\"Promise\"] = \"n\";\n  AccessorPrefix4[\"TagVariableChange\"] = \"o\";\n  return AccessorPrefix4;\n})(AccessorPrefix2 || {});\nvar AccessorProp2 = /* @__PURE__ */ ((AccessorProp4) => {\n  AccessorProp4[\"Owner\"] = \"_\";\n  AccessorProp4[\"BranchAccessor\"] = \"a\";\n  AccessorProp4[\"CatchContent\"] = \"b\";\n  AccessorProp4[\"PlaceholderBranch\"] = \"c\";\n  AccessorProp4[\"PlaceholderContent\"] = \"d\";\n  AccessorProp4[\"TagVariable\"] = \"e\";\n  AccessorProp4[\"TagVariableChange\"] = \"f\";\n  AccessorProp4[\"ClosestBranchId\"] = \"g\";\n  return AccessorProp4;\n})(AccessorProp2 || {});\n\n// src/translator/util/marko-config.ts\nvar import_babel_utils5 = require(\"@marko/compiler/babel-utils\");\nfunction isOutputHTML() {\n  return getMarkoOpts().output === \"html\";\n}\nfunction isOutputDOM() {\n  return !isOutputHTML();\n}\nfunction getMarkoOpts() {\n  return (0, import_babel_utils5.getFile)().markoOpts;\n}\nfunction isOptimize() {\n  return getMarkoOpts().optimize;\n}\n\n// src/translator/util/get-accessor-char.ts\nfunction getAccessorPrefix() {\n  return isOptimize() ? AccessorPrefix2 : AccessorPrefix;\n}\nfunction getAccessorProp() {\n  return isOptimize() ? AccessorProp2 : AccessorProp;\n}\n\n// src/translator/util/get-root.ts\nfunction getMarkoRoot(path5) {\n  let curPath = path5;\n  do\n    curPath = curPath.parentPath;\n  while (curPath && !isMarko(curPath));\n  return curPath;\n}\nfunction getExprRoot(path5) {\n  let curPath = path5;\n  while (!isMarko(curPath.parentPath)) {\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction getFnRoot(path5) {\n  let curPath = path5;\n  let fnPath;\n  if (curPath.isProgram()) return;\n  while (!isMarko(curPath)) {\n    if (isFunction(curPath)) {\n      fnPath = curPath;\n    } else {\n      switch (curPath.type) {\n        case \"CallExpression\":\n        case \"NewExpression\":\n          fnPath = void 0;\n          break;\n      }\n    }\n    curPath = curPath.parentPath;\n  }\n  return fnPath;\n}\nfunction isMarko(path5) {\n  switch (path5.type) {\n    case \"MarkoTag\":\n    case \"MarkoTagBody\":\n    case \"MarkoAttribute\":\n    case \"MarkoSpreadAttribute\":\n    case \"MarkoPlaceholder\":\n    case \"MarkoScriptlet\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isFunction(path5) {\n  switch (path5.type) {\n    case \"FunctionDeclaration\":\n      return !path5.node.declare;\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ObjectMethod\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// src/translator/util/is-invoked-function.ts\nvar import_compiler4 = require(\"@marko/compiler\");\nfunction isInvokedFunction(expr) {\n  let curPath = expr;\n  while (curPath) {\n    const { parent, node } = curPath;\n    switch (parent.type) {\n      case \"CallExpression\":\n        return parent.callee === node;\n      case \"TSNonNullExpression\":\n        curPath = curPath.parentPath;\n        break;\n      default:\n        return false;\n    }\n  }\n  return false;\n}\n\n// src/translator/util/optional.ts\nvar Sorted = class {\n  constructor(compare) {\n    this.compare = compare;\n  }\n  add(data, item) {\n    return data ? Array.isArray(data) ? addSorted(this.compare, data, item) : joinRepeatable(this.compare, data, item) : item;\n  }\n  union(a, b) {\n    if (a) {\n      if (Array.isArray(a)) {\n        if (b) {\n          if (Array.isArray(b)) {\n            return unionSortedRepeatable(this.compare, a, b);\n          } else {\n            return addSorted(this.compare, a, b);\n          }\n        }\n        return a;\n      }\n      if (b) {\n        if (Array.isArray(b)) {\n          return addSorted(this.compare, b, a);\n        }\n        return joinRepeatable(this.compare, b, a);\n      }\n      return a;\n    }\n    return b;\n  }\n  find(data, item) {\n    if (data) {\n      if (Array.isArray(data)) {\n        return findSorted(this.compare, data, item);\n      } else if (this.compare(data, item) === 0) {\n        return data;\n      }\n    }\n  }\n  findIndex(data, item) {\n    if (data) {\n      if (Array.isArray(data)) {\n        return findIndexSorted(this.compare, data, item);\n      } else if (this.compare(data, item) === 0) {\n        return 0;\n      }\n    }\n    return -1;\n  }\n  isSuperset(superset, subset) {\n    if (!subset) {\n      return true;\n    }\n    if (!Array.isArray(subset)) {\n      return this.findIndex(superset, subset) !== -1;\n    }\n    if (!Array.isArray(superset)) {\n      return false;\n    }\n    const subLen = subset.length;\n    const supLen = superset.length;\n    if (subLen > supLen) {\n      return false;\n    }\n    for (let i = subLen; i--; ) {\n      const supIndex = this.findIndex(superset, subset[i]);\n      if (supIndex === -1 || supLen - supIndex <= i) return false;\n    }\n    return true;\n  }\n};\nfunction push(data, item) {\n  if (data) {\n    if (Array.isArray(data)) {\n      data.push(item);\n      return data;\n    }\n    return [data, item];\n  }\n  return item;\n}\nfunction concat(a, b) {\n  if (a) {\n    if (b) {\n      if (Array.isArray(a)) {\n        return a.concat(b);\n      } else if (Array.isArray(b)) {\n        return [a, ...b];\n      } else {\n        return [a, b];\n      }\n    }\n    return a;\n  }\n  return b;\n}\nfunction filter(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      const len = data.length;\n      let result;\n      let i = 0;\n      while (i < len) {\n        let item = data[i++];\n        if (cb(item)) {\n          result = item;\n          while (i < len) {\n            item = data[i++];\n            if (cb(item)) {\n              result = [result, item];\n              while (i < len) {\n                item = data[i++];\n                if (cb(item)) {\n                  result.push(item);\n                }\n              }\n              return result;\n            }\n          }\n          return result;\n        }\n      }\n      return result;\n    }\n    if (cb(data)) {\n      return data;\n    }\n  }\n  return void 0;\n}\nfunction forEach(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      let i = 0;\n      for (const item of data) {\n        cb(item, i++);\n      }\n    } else {\n      cb(data, 0);\n    }\n  }\n}\nfunction fromIter(data) {\n  let one;\n  let many;\n  for (const item of data) {\n    if (many) {\n      many.push(item);\n    } else if (one) {\n      many = [one, item];\n    } else {\n      one = item;\n    }\n  }\n  return many || one;\n}\nfunction find(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      return data.find(cb);\n    }\n    if (cb(data, 0)) {\n      return data;\n    }\n  }\n}\nfunction toArray(data, cb) {\n  return data ? Array.isArray(data) ? data.map(cb) : [cb(data, 0)] : [];\n}\nfunction mapToString(data, sep, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      let str = \"\";\n      let curSep = \"\";\n      for (let i = 0; i < data.length; i++) {\n        str += curSep + cb(data[i], i);\n        curSep = sep;\n      }\n      return str;\n    }\n    return cb(data, 0);\n  }\n  return \"\";\n}\nfunction filterMap(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      const len = data.length;\n      let result;\n      let i = 0;\n      while (i < len) {\n        let item = cb(data[i++]);\n        if (item) {\n          result = item;\n          while (i < len) {\n            item = cb(data[i++]);\n            if (item) {\n              result = [result, item];\n              while (i < len) {\n                item = cb(data[i++]);\n                if (item) {\n                  result.push(item);\n                }\n              }\n              return result;\n            }\n          }\n          return result;\n        }\n      }\n      return result;\n    } else {\n      return cb(data);\n    }\n  }\n}\nfunction findSorted(compare, data, item) {\n  let max = data.length;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const cur = data[mid];\n    const compareResult = compare(cur, item);\n    if (compareResult === 0) return cur;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n}\nfunction findIndexSorted(compare, data, item) {\n  let max = data.length;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(data[mid], item);\n    if (compareResult === 0) return mid;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n  return -1;\n}\nfunction addSorted(compare, data, item) {\n  const len = data.length;\n  let max = len;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(data[mid], item);\n    if (compareResult === 0) return data;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n  const result = new Array(len + 1);\n  for (let i = 0; i < pos; i++) {\n    result[i] = data[i];\n  }\n  let cur = item;\n  while (pos < len) {\n    const next = cur;\n    cur = data[pos];\n    result[pos++] = next;\n  }\n  result[len] = cur;\n  return result;\n}\nfunction unionSortedRepeatable(compare, a, b) {\n  const aLen = a.length;\n  const bLen = b.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  const result = [];\n  while (aIndex < aLen && bIndex < bLen) {\n    const aValue = a[aIndex];\n    const bValue = b[bIndex];\n    const delta = compare(aValue, bValue);\n    if (delta === 0) {\n      aIndex++;\n      bIndex++;\n      result.push(aValue);\n    } else if (delta < 0) {\n      aIndex++;\n      result.push(aValue);\n    } else {\n      bIndex++;\n      result.push(bValue);\n    }\n  }\n  if (aLen === bLen && aIndex === aLen) {\n    return a;\n  }\n  while (aIndex < aLen) {\n    result.push(a[aIndex++]);\n  }\n  while (bIndex < bLen) {\n    result.push(b[bIndex++]);\n  }\n  return result;\n}\nfunction joinRepeatable(compare, a, b) {\n  const compareResult = compare(a, b);\n  return compareResult === 0 ? a : compareResult < 0 ? [a, b] : [b, a];\n}\n\n// src/translator/util/scope-read.ts\nvar import_compiler23 = require(\"@marko/compiler\");\n\n// src/translator/visitors/program/index.ts\nvar import_compiler22 = require(\"@marko/compiler\");\nvar import_babel_utils16 = require(\"@marko/compiler/babel-utils\");\nvar import_path2 = __toESM(require(\"path\"));\n\n// src/translator/util/binding-has-downstream-expressions.ts\nfunction bindingHasDownstreamExpressions(binding) {\n  if (binding.downstreamExpressions.size) return true;\n  for (const alias of binding.aliases) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  return false;\n}\n\n// src/translator/util/entry-builder.ts\nvar import_compiler5 = require(\"@marko/compiler\");\nvar import_babel_utils6 = require(\"@marko/compiler/babel-utils\");\nvar kState = Symbol();\nvar entry_builder_default = {\n  build(entryFile) {\n    const state = entryFile[kState];\n    if (!state) {\n      throw entryFile.path.buildCodeFrameError(\n        \"Unable to build hydrate code, no files were visited before finalizing the build\"\n      );\n    }\n    const body = state.imports.map(\n      (it) => import_compiler5.types.importDeclaration([], import_compiler5.types.stringLiteral(it))\n    );\n    if (state.init) {\n      body.unshift(\n        import_compiler5.types.importDeclaration(\n          [import_compiler5.types.importSpecifier(import_compiler5.types.identifier(\"init\"), import_compiler5.types.identifier(\"init\"))],\n          import_compiler5.types.stringLiteral(\n            `${runtime_info_default.name}/${entryFile.markoOpts.optimize ? \"\" : \"debug/\"}dom`\n          )\n        )\n      );\n      body.push(\n        import_compiler5.types.expressionStatement(import_compiler5.types.callExpression(import_compiler5.types.identifier(\"init\"), []))\n      );\n    }\n    return body;\n  },\n  visit(file, entryFile, visitChild) {\n    const state = entryFile[kState] ||= {\n      imports: [],\n      init: false\n    };\n    const { analyzedTags } = file.metadata.marko;\n    state.imports.push(\n      (0, import_babel_utils6.resolveRelativePath)(entryFile, file.opts.filename)\n    );\n    state.init ||= file.path.node.extra.hasInteractiveChild || file.path.node.extra.isInteractive || false;\n    for (const tag of analyzedTags || []) {\n      visitChild(tag);\n    }\n  }\n};\n\n// src/translator/util/get-known-attr-values.ts\nfunction getKnownAttrValues(tag) {\n  const attrs2 = {};\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      attrs2[attr2.name] = attr2.value;\n    }\n  }\n  return attrs2;\n}\n\n// src/translator/util/is-core-tag.ts\nvar import_babel_utils7 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-tag-name.ts\nfunction getTagName(tag) {\n  return tag.node.name.value;\n}\n\n// src/translator/util/is-core-tag.ts\nvar { taglibId } = runtime_info_default;\nvar htmlTaglibId = \"marko-html\";\nvar interopTaglibId = \"@marko/translator-interop-class-tags\";\nfunction isCoreTag(tag) {\n  if (tag.isMarkoTag()) {\n    const tagDef = (0, import_babel_utils7.getTagDef)(tag);\n    if (tagDef) {\n      switch (tagDef.taglibId) {\n        case taglibId:\n        case interopTaglibId:\n          return true;\n        case htmlTaglibId:\n          switch (tagDef.name) {\n            case \"script\":\n            case \"style\":\n              return true;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\nfunction isCoreTagName(tag, name2) {\n  return isCoreTag(tag) && getTagName(tag) === name2;\n}\nfunction isConditionTag(tag) {\n  if (isCoreTag(tag)) {\n    switch (getTagName(tag)) {\n      case \"if\":\n      case \"else-if\":\n      case \"else\":\n        return true;\n    }\n  }\n  return false;\n}\nfunction isControlFlowTag(tag) {\n  if (isCoreTag(tag)) {\n    switch (getTagName(tag)) {\n      case \"if\":\n      case \"else-if\":\n      case \"else\":\n      case \"for\":\n      case \"await\":\n      case \"try\":\n        return true;\n    }\n  }\n  return false;\n}\n\n// src/translator/util/runtime.ts\nvar import_compiler7 = require(\"@marko/compiler\");\nvar import_babel_utils8 = require(\"@marko/compiler/babel-utils\");\n\n// src/common/attr-tag.ts\nvar rest = false ? Symbol(\"Attribute Tag\") : Symbol();\n\n// src/common/helpers.ts\nfunction classValue(classValue2) {\n  return toDelimitedString(classValue2, \" \", stringifyClassObject);\n}\nfunction stringifyClassObject(name2, value) {\n  return value ? name2 : \"\";\n}\nfunction styleValue(styleValue2) {\n  return toDelimitedString(styleValue2, \";\", stringifyStyleObject);\n}\nfunction stringifyStyleObject(name2, value) {\n  return value || value === 0 ? name2 + \":\" + value : \"\";\n}\nfunction toDelimitedString(val, delimiter, stringify) {\n  let str = \"\";\n  let sep = \"\";\n  let part;\n  if (val) {\n    if (typeof val !== \"object\") {\n      str += val;\n    } else if (Array.isArray(val)) {\n      for (const v of val) {\n        part = toDelimitedString(v, delimiter, stringify);\n        if (part) {\n          str += sep + part;\n          sep = delimiter;\n        }\n      }\n    } else {\n      for (const name2 in val) {\n        part = stringify(name2, val[name2]);\n        if (part) {\n          str += sep + part;\n          sep = delimiter;\n        }\n      }\n    }\n  }\n  return str;\n}\nfunction isEventHandler(name2) {\n  return /^on[A-Z-]/.test(name2);\n}\nfunction getEventHandlerName(name2) {\n  return name2[2] === \"-\" ? name2.slice(3) : name2.slice(2).toLowerCase();\n}\nfunction isVoid(value) {\n  return value == null || value === false;\n}\n\n// src/html/content.ts\nfunction toString(val) {\n  return val ? val + \"\" : val === 0 ? \"0\" : \"\";\n}\nvar unsafeXMLReg = /[<&]/g;\nvar replaceUnsafeXML = (c) => c === \"&\" ? \"&amp;\" : \"&lt;\";\nvar escapeXMLStr = (str) => unsafeXMLReg.test(str) ? str.replace(unsafeXMLReg, replaceUnsafeXML) : str;\nfunction escapeXML(val) {\n  return val ? escapeXMLStr(val + \"\") : val === 0 ? \"0\" : \"&zwj;\";\n}\nvar unsafeScriptReg = /<\\/script/g;\nvar escapeScriptStr = (str) => unsafeScriptReg.test(str) ? str.replace(unsafeScriptReg, \"\\\\x3C/script\") : str;\nfunction escapeScript(val) {\n  return val ? escapeScriptStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\nvar unsafeStyleReg = /<\\/style/g;\nvar escapeStyleStr = (str) => unsafeStyleReg.test(str) ? str.replace(unsafeStyleReg, \"\\\\3C/style\") : str;\nfunction escapeStyle(val) {\n  return val ? escapeStyleStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\n\n// src/html/writer.ts\nvar K_SCOPE_ID = Symbol(\"Scope ID\");\nvar kPendingContexts = Symbol(\"Pending Contexts\");\nvar branchIdKey = Symbol();\nif (false) {\n  writeScope = /* @__PURE__ */ ((writeScope2) => (scopeId, partialScope, file, loc, vars) => {\n    const scope = writeScope2(scopeId, partialScope);\n    if (file && loc !== void 0) {\n      setDebugInfo(scope, file, loc, vars);\n    }\n    return scope;\n  })(writeScope);\n}\nvar tick = globalThis.setImmediate || globalThis.setTimeout || globalThis.queueMicrotask || ((cb) => Promise.resolve().then(cb));\n\n// src/html/attrs.ts\nfunction classAttr(value) {\n  return stringAttr(\"class\", classValue(value));\n}\nfunction styleAttr(value) {\n  return stringAttr(\"style\", styleValue(value));\n}\nvar kSelectedValue = Symbol(\"selectedValue\");\nfunction attr(name2, value) {\n  return isVoid(value) ? \"\" : nonVoidAttr(name2, value);\n}\nfunction stringAttr(name2, value) {\n  return value && \" \" + name2 + attrAssignment(value);\n}\nfunction nonVoidAttr(name2, value) {\n  switch (typeof value) {\n    case \"string\":\n      return \" \" + name2 + attrAssignment(value);\n    case \"boolean\":\n      return \" \" + name2;\n    case \"number\":\n      return \" \" + name2 + \"=\" + value;\n    case \"object\":\n      if (value instanceof RegExp) {\n        return \" \" + name2 + attrAssignment(value.source);\n      }\n      break;\n  }\n  return \" \" + name2 + attrAssignment(value + \"\");\n}\nvar singleQuoteAttrReplacements = /'|&(?=#?\\w+;)/g;\nvar doubleQuoteAttrReplacements = /\"|&(?=#?\\w+;)/g;\nvar needsQuotedAttr = /[\"'>\\s]|&#?\\w+;|\\/$/g;\nfunction attrAssignment(value) {\n  return value ? needsQuotedAttr.test(value) ? value[needsQuotedAttr.lastIndex - 1] === (needsQuotedAttr.lastIndex = 0, '\"') ? \"='\" + escapeSingleQuotedAttrValue(value) + \"'\" : '=\"' + escapeDoubleQuotedAttrValue(value) + '\"' : \"=\" + value : \"\";\n}\nfunction escapeSingleQuotedAttrValue(value) {\n  return singleQuoteAttrReplacements.test(value) ? value.replace(\n    singleQuoteAttrReplacements,\n    replaceUnsafeSingleQuoteAttrChar\n  ) : value;\n}\nfunction replaceUnsafeSingleQuoteAttrChar(match) {\n  return match === \"'\" ? \"&#39;\" : \"&amp;\";\n}\nfunction escapeDoubleQuotedAttrValue(value) {\n  return doubleQuoteAttrReplacements.test(value) ? value.replace(\n    doubleQuoteAttrReplacements,\n    replaceUnsafeDoubleQuoteAttrChar\n  ) : value;\n}\nfunction replaceUnsafeDoubleQuoteAttrChar(match) {\n  return match === '\"' ? \"&#34;\" : \"&amp;\";\n}\n\n// src/common/compat-meta.ts\nvar prefix = false ? \"$compat_\" : \"$C_\";\nvar RENDERER_REGISTER_ID = prefix + (false ? \"renderer\" : \"r\");\nvar SET_SCOPE_REGISTER_ID = prefix + (false ? \"setScope\" : \"s\");\nvar RENDER_BODY_ID = prefix + (false ? \"renderBody\" : \"b\");\n\n// src/html/compat.ts\nvar K_TAGS_API_STATE = Symbol();\n\n// src/translator/util/to-property-name.ts\nvar import_compiler6 = require(\"@marko/compiler\");\nfunction isValidPropertyIdentifier(name2) {\n  return /^[a-z_$][a-z0-9_$]*$/i.test(name2);\n}\nfunction toPropertyName(name2) {\n  if (isValidPropertyIdentifier(name2)) {\n    return import_compiler6.types.identifier(name2);\n  } else if (/^(?:0|[1-9][0-9]*)$/.test(name2)) {\n    return import_compiler6.types.numericLiteral(parseInt(name2, 10));\n  }\n  return import_compiler6.types.stringLiteral(name2);\n}\nfunction toObjectProperty(name2, value) {\n  return import_compiler6.types.objectProperty(toPropertyName(name2), value);\n}\nfunction toMemberExpression(object, key, optional) {\n  const prop = toPropertyName(key);\n  const computed = prop.type !== \"Identifier\";\n  return optional ? import_compiler6.types.optionalMemberExpression(object, prop, computed, true) : import_compiler6.types.memberExpression(object, prop, computed);\n}\n\n// src/translator/util/runtime.ts\nvar pureDOMFunctions = /* @__PURE__ */ new Set([\n  \"awaitTag\",\n  \"conditional\",\n  \"conditionalClosure\",\n  \"createTry\",\n  \"dynamicTag\",\n  \"createRenderer\",\n  \"createContent\",\n  \"createTemplate\",\n  \"dynamicClosure\",\n  \"dynamicClosureRead\",\n  \"intersection\",\n  \"loopClosure\",\n  \"loopIn\",\n  \"loopOf\",\n  \"loopTo\",\n  \"state\",\n  \"value\"\n]);\nfunction importRuntime(name2) {\n  const { output } = getMarkoOpts();\n  return toMemberExpression(\n    (0, import_babel_utils8.importStar)((0, import_babel_utils8.getFile)(), getRuntimePath(output), \"$\"),\n    name2\n  );\n}\nfunction callRuntime(name2, ...args) {\n  const callExpression2 = import_compiler7.types.callExpression(\n    importRuntime(name2),\n    filterArguments(args)\n  );\n  if (isOutputDOM() && pureDOMFunctions.has(name2)) {\n    callExpression2.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: ` @__PURE__ `\n      }\n    ];\n  }\n  return callExpression2;\n}\nfunction getHTMLRuntime() {\n  return {\n    escapeXML,\n    toString,\n    attr,\n    classAttr,\n    styleAttr,\n    escapeScript,\n    escapeStyle\n  };\n}\nfunction getRuntimePath(output) {\n  const { optimize } = getMarkoOpts();\n  return `${runtime_info_default.name}/${optimize ? \"\" : \"debug/\"}${output === \"html\" ? \"html\" : \"dom\"}`;\n}\nfunction filterArguments(args) {\n  const filteredArgs = [];\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (arg || filteredArgs.length) {\n      filteredArgs[i] = arg || import_compiler7.types.unaryExpression(\"void\", import_compiler7.types.numericLiteral(0));\n    }\n  }\n  return filteredArgs;\n}\nfunction getCompatRuntimeFile() {\n  const markoOpts = getMarkoOpts();\n  return `marko/src/runtime/helpers/tags-compat/${isOutputHTML() ? \"html\" : \"dom\"}${markoOpts.optimize ? \"\" : \"-debug\"}.${markoOpts.modules === \"esm\" ? \"mjs\" : \"js\"}`;\n}\n\n// src/translator/util/sections.ts\nvar import_compiler10 = require(\"@marko/compiler\");\nvar import_babel_utils11 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/serialize-reasons.ts\nvar import_compiler8 = require(\"@marko/compiler\");\nvar reasonExprs = /* @__PURE__ */ new WeakMap();\nvar keyedReasonExprs = /* @__PURE__ */ new WeakMap();\nvar serializeKeysByBinding = /* @__PURE__ */ new WeakMap();\nvar serializeKeyBySourceModifier = {};\nfunction forceOwnersSerialize(from, to, prop) {\n  let cur = from;\n  while (cur !== to && cur.parent) {\n    forceSectionSerialize(cur, prop);\n    cur = cur.parent;\n  }\n}\nfunction addOwnersSerializeReason(from, to, reason, prop) {\n  if (reason) {\n    let cur = from;\n    while (cur !== to && cur.parent) {\n      addSectionSerializeReason(cur, reason, prop);\n      cur = cur.parent;\n    }\n  }\n}\nfunction forceSectionSerialize(section, prop) {\n  if (prop) {\n    forceSerializeKey(section, getSectionPropSerializeReasonKey(section, prop));\n  } else if (section.serializeReason !== true) {\n    reasonExprs.delete(section);\n    setSectionSerializeReason(section, true);\n  }\n}\nfunction forceBindingSerialize(section, binding, prefix2) {\n  forceSerializeKey(section, getBindingSerializeReasonKey(binding, prefix2));\n}\nfunction forceSerializeKey(section, key) {\n  if (section.serializeReasons.get(key) !== true) {\n    setSectionKeyedSerializeReason(section, key, true);\n    keyedReasonExprs.get(section)?.delete(key);\n  }\n}\nfunction isBindingForceSerialized(section, binding, prefix2) {\n  return section.serializeReasons.get(\n    getBindingSerializeReasonKey(binding, prefix2)\n  ) === true;\n}\nfunction addSectionSerializeReasonExpr(section, expr, prop) {\n  if (expr) {\n    if (prop) {\n      addKeyedSerializeReasonExpr(\n        section,\n        getSectionPropSerializeReasonKey(section, prop),\n        expr\n      );\n    } else if (section.serializeReason !== true) {\n      if (expr === true) {\n        forceSectionSerialize(section);\n      } else {\n        const existingExpr = reasonExprs.get(section);\n        reasonExprs.set(\n          section,\n          existingExpr ? concat(existingExpr, expr) : expr\n        );\n      }\n    }\n  }\n}\nfunction addBindingSerializeReasonExpr(section, binding, expr, prefix2) {\n  const key = getBindingSerializeReasonKey(binding, prefix2);\n  if (expr && section.serializeReasons.get(key) !== true) {\n    addKeyedSerializeReasonExpr(section, key, expr);\n  }\n}\nfunction addKeyedSerializeReasonExpr(section, key, expr) {\n  if (expr === true) {\n    forceSerializeKey(section, key);\n  } else {\n    let existingExpr;\n    let keyedExprs = keyedReasonExprs.get(section);\n    if (keyedExprs) {\n      existingExpr = keyedExprs.get(key);\n    } else {\n      keyedExprs = /* @__PURE__ */ new Map();\n      keyedReasonExprs.set(section, keyedExprs);\n    }\n    keyedExprs.set(key, existingExpr ? concat(existingExpr, expr) : expr);\n  }\n}\nfunction addSectionSerializeReasonRef(section, ref, prop) {\n  if (ref) {\n    if (prop) {\n      addKeyedSerializeReasonRef(\n        section,\n        getSectionPropSerializeReasonKey(section, prop),\n        ref\n      );\n    } else {\n      const existingReason = section.serializeReason;\n      if (existingReason !== true) {\n        if (ref === true) {\n          forceSectionSerialize(section);\n        } else {\n          const reason = getSerializeSourcesForRef(ref);\n          if (reason) {\n            setSectionSerializeReason(\n              section,\n              mergeSerializeReasons(existingReason, reason)\n            );\n          }\n        }\n      }\n    }\n  }\n}\nfunction addKeyedSerializeReasonRef(section, key, ref) {\n  const existingReason = section.serializeReasons.get(key);\n  if (existingReason !== true) {\n    if (ref === true) {\n      forceSerializeKey(section, key);\n    } else {\n      const reason = getSerializeSourcesForRef(ref);\n      if (reason) {\n        setSectionKeyedSerializeReason(\n          section,\n          key,\n          mergeSerializeReasons(existingReason, reason)\n        );\n      }\n    }\n  }\n}\nfunction addSectionSerializeReason(section, reason, prop) {\n  if (reason) {\n    if (prop) {\n      addKeyedSerializeReason(\n        section,\n        getSectionPropSerializeReasonKey(section, prop),\n        reason\n      );\n    } else {\n      const existingReason = section.serializeReason;\n      if (existingReason !== true) {\n        if (reason === true) {\n          forceSectionSerialize(section);\n        } else {\n          setSectionSerializeReason(\n            section,\n            mergeSerializeReasons(existingReason, reason)\n          );\n        }\n      }\n    }\n  }\n}\nfunction addBindingSerializeReason(section, binding, reason, prefix2) {\n  if (reason) {\n    addKeyedSerializeReason(\n      section,\n      getBindingSerializeReasonKey(binding, prefix2),\n      reason\n    );\n  }\n}\nfunction addKeyedSerializeReason(section, key, reason) {\n  const existingReason = section.serializeReasons.get(key);\n  if (existingReason !== true) {\n    if (reason === true) {\n      forceSerializeKey(section, key);\n    } else {\n      setSectionKeyedSerializeReason(\n        section,\n        key,\n        mergeSerializeReasons(existingReason, reason)\n      );\n    }\n  }\n}\nfunction getSectionSerializeReason(section, prop) {\n  return prop ? section.serializeReasons.get(\n    getSectionPropSerializeReasonKey(section, prop)\n  ) : section.serializeReason;\n}\nfunction getBindingSerializeReason(section, binding, prefix2) {\n  return section.serializeReasons.get(\n    getBindingSerializeReasonKey(binding, prefix2)\n  );\n}\nfunction getSectionPropSerializeReasonKey(section, prop) {\n  const keys = serializeKeyBySourceModifier[prop] ||= /* @__PURE__ */ new WeakMap();\n  let key = keys.get(section);\n  if (!key) {\n    keys.set(\n      section,\n      key = Symbol(\n        typeof prop === \"symbol\" ? `Symbol(${prop.description})` : prop\n      )\n    );\n  }\n  return key;\n}\nfunction getBindingSerializeReasonKey(binding, prefix2) {\n  const keys = prefix2 ? serializeKeyBySourceModifier[prefix2] ||= /* @__PURE__ */ new WeakMap() : serializeKeysByBinding;\n  let key = keys.get(binding);\n  if (!key) {\n    keys.set(\n      binding,\n      key = Symbol(\n        (prefix2 ? typeof prefix2 === \"symbol\" ? `Symbol(${prefix2.description})` : prefix2 : \"\") + binding.name\n      )\n    );\n  }\n  return key;\n}\nfunction applySerializeReasonExprs(section) {\n  const keyedExprs = keyedReasonExprs.get(section);\n  if (keyedExprs) {\n    keyedReasonExprs.delete(section);\n    for (const [key, exprs] of keyedExprs) {\n      const reason2 = getSerializeSourcesForExprs(exprs);\n      if (reason2) {\n        setSectionKeyedSerializeReason(\n          section,\n          key,\n          mergeSerializeReasons(section.serializeReasons.get(key), reason2)\n        );\n      }\n    }\n  }\n  const reason = getSerializeSourcesForExprs(reasonExprs.get(section));\n  if (reason) {\n    setSectionSerializeReason(\n      section,\n      mergeSerializeReasons(section.serializeReason, reason)\n    );\n  }\n  reasonExprs.delete(section);\n}\nfunction finalizeSectionSerializeReasons(section) {\n  let reason = section.serializeReason;\n  if (reason !== true) {\n    for (const [, keyedReason] of section.serializeReasons) {\n      if (keyedReason === true) {\n        reason = true;\n        break;\n      }\n      reason = mergeSerializeReasons(reason, keyedReason);\n    }\n    if (reason) {\n      setSectionSerializeReason(section, reason);\n    }\n  }\n}\nfunction getSerializeSourcesForExpr(expr) {\n  if (isReferencedExtra(expr)) {\n    return getSerializeSourcesForRef(expr.referencedBindings);\n  }\n}\nfunction getSerializeSourcesForExprs(exprs) {\n  if (exprs) {\n    if (Array.isArray(exprs)) {\n      let allSources;\n      for (const expr of exprs) {\n        allSources = mergeSources(allSources, getSerializeSourcesForExpr(expr));\n      }\n      return allSources;\n    } else {\n      return getSerializeSourcesForExpr(exprs);\n    }\n  }\n}\nfunction getSerializeSourcesForRef(ref) {\n  if (ref) {\n    let allSources;\n    if (Array.isArray(ref)) {\n      for (const { sources } of ref) {\n        allSources = mergeSources(allSources, sources);\n      }\n      return allSources;\n    } else {\n      return ref.sources;\n    }\n  }\n}\nfunction mergeSerializeReasons(a, b) {\n  if (a === true || b === true) return true;\n  return mergeSources(a, b);\n}\nfunction setSectionSerializeReason(section, reason) {\n  section.serializeReason = reason;\n}\nfunction setSectionKeyedSerializeReason(section, key, reason) {\n  section.serializeReasons.set(key, reason);\n}\n\n// src/translator/util/state.ts\nvar import_babel_utils9 = require(\"@marko/compiler/babel-utils\");\nvar createProgramState = (init) => {\n  const map = /* @__PURE__ */ new WeakMap();\n  return [\n    () => {\n      let state = map.get((0, import_babel_utils9.getProgram)());\n      if (!state) {\n        map.set((0, import_babel_utils9.getProgram)(), state = init());\n      }\n      return state;\n    },\n    (value) => {\n      map.set((0, import_babel_utils9.getProgram)(), value);\n    }\n  ];\n};\nfunction createSectionState(key, init) {\n  return [\n    (section) => {\n      const arrayOfSectionData = (0, import_babel_utils9.getProgram)().state[key] ??= {};\n      const sectionData = arrayOfSectionData[section.id] ??= init && init(section);\n      return sectionData;\n    },\n    (section, value) => {\n      const arrayOfSectionData = (0, import_babel_utils9.getProgram)().state[key] ??= {};\n      arrayOfSectionData[section.id] = value;\n    }\n  ];\n}\n\n// src/translator/util/tag-name-type.ts\nvar import_compiler9 = require(\"@marko/compiler\");\nvar import_babel_utils10 = require(\"@marko/compiler/babel-utils\");\nvar MARKO_FILE_REG = /^<.*>$|\\.marko$/;\nfunction analyzeTagNameType(tag) {\n  const extra = tag.node.extra ??= {};\n  if (extra.tagNameType === void 0) {\n    const name2 = tag.get(\"name\");\n    if (name2.isStringLiteral()) {\n      extra.tagNameType = name2.node.value[0] === \"@\" ? 3 /* AttributeTag */ : (0, import_babel_utils10.isNativeTag)(tag) ? 0 /* NativeTag */ : 1 /* CustomTag */;\n      extra.tagNameNullable = extra.tagNameNullable = false;\n    } else if (name2.isIdentifier()) {\n      analyzeExpressionTagName(name2, extra);\n      if (extra.tagNameType === 0 /* NativeTag */) {\n        extra.tagNameType = 2 /* DynamicTag */;\n      }\n    } else if (name2.isTemplateLiteral() && !name2.node.expressions.length) {\n      extra.tagNameType = 0 /* NativeTag */;\n    } else {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n    if (extra.tagNameType === void 0) {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n    if (extra.tagNameType === 1 /* CustomTag */) {\n      const childFile = (0, import_babel_utils10.loadFileForTag)(tag);\n      if (!childFile) {\n        extra.tagNameType = 2 /* DynamicTag */;\n      } else if (childFile.ast.program.extra.featureType === \"class\") {\n        extra.tagNameType = 2 /* DynamicTag */;\n        extra.featureType = \"class\";\n        ((0, import_babel_utils10.getProgram)().node.extra ??= {}).needsCompat = true;\n      }\n    }\n  }\n  return extra.tagNameType;\n}\nfunction analyzeExpressionTagName(name2, extra) {\n  const pending = [name2];\n  let path5;\n  let type;\n  let nullable = false;\n  let tagNameImported;\n  while ((path5 = pending.pop()) && type !== 2 /* DynamicTag */) {\n    if (path5.isConditionalExpression()) {\n      pending.push(path5.get(\"consequent\"));\n      if (path5.node.alternate) {\n        pending.push(path5.get(\"alternate\"));\n      }\n    } else if (path5.isLogicalExpression()) {\n      if (path5.node.operator === \"||\") {\n        pending.push(path5.get(\"left\"));\n      } else {\n        nullable = true;\n      }\n      pending.push(path5.get(\"right\"));\n    } else if (path5.isAssignmentExpression()) {\n      pending.push(path5.get(\"right\"));\n    } else if (path5.isBinaryExpression()) {\n      type = path5.node.operator !== \"+\" || type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path5.isStringLiteral() || path5.isTemplateLiteral()) {\n      type = type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path5.isNullLiteral()) {\n      nullable = true;\n    } else if (path5.isIdentifier()) {\n      if (path5.node.name === \"undefined\") {\n        nullable = true;\n        continue;\n      }\n      const binding = path5.scope.getBinding(path5.node.name);\n      if (!binding) {\n        type = 2 /* DynamicTag */;\n        continue;\n      }\n      if (binding.kind === \"module\") {\n        const decl = binding.path.parent;\n        if (MARKO_FILE_REG.test(decl.source.value) && decl.specifiers.some((it) => import_compiler9.types.isImportDefaultSpecifier(it))) {\n          const resolvedImport = (0, import_babel_utils10.resolveTagImport)(name2, decl.source.value) || decl.source.value;\n          if (type === 0 /* NativeTag */ || tagNameImported && tagNameImported !== resolvedImport) {\n            type = 2 /* DynamicTag */;\n            tagNameImported = void 0;\n          } else {\n            type = 1 /* CustomTag */;\n            tagNameImported = resolvedImport;\n          }\n        } else {\n          type = 2 /* DynamicTag */;\n        }\n        continue;\n      }\n      const bindingTag = binding.path;\n      if (bindingTag.isMarkoTag() && binding.kind === \"local\") {\n        const bindingTagName = bindingTag.get(\"name\").node.value;\n        if (bindingTagName === \"const\") {\n          pending.push(\n            bindingTag.get(\"attributes\")[0].get(\"value\")\n          );\n          continue;\n        }\n        if (bindingTagName === \"let\") {\n          type = 2 /* DynamicTag */;\n          continue;\n        }\n        continue;\n      }\n      type = 2 /* DynamicTag */;\n    } else {\n      type = 2 /* DynamicTag */;\n    }\n  }\n  extra.tagNameType = type;\n  extra.tagNameNullable = nullable;\n  extra.tagNameDynamic = true;\n  if (type === 1 /* CustomTag */ && tagNameImported) {\n    extra.tagNameImported = tagNameImported;\n  }\n}\n\n// src/translator/util/sections.ts\nvar sectionUtil = new Sorted(function compareSections(a, b) {\n  return a.id - b.id;\n});\nfunction startSection(path5) {\n  const extra = path5.node.extra ??= {};\n  let section = extra.section;\n  if (!section && (path5.type === \"Program\" || path5.get(\"body\").length)) {\n    const parentSection = path5.parentPath ? getOrCreateSection(path5.parentPath) : void 0;\n    const sectionNamePath = path5.parentPath?.get(\n      \"name\"\n    );\n    const sectionName = path5.isProgram() ? \"\" : generateUid(sectionNamePath.toString() + \"_content\");\n    const programExtra = path5.hub.file.path.node.extra ??= {};\n    const sections = programExtra.sections ??= [];\n    section = extra.section = {\n      id: sections.length,\n      name: sectionName,\n      loc: sectionNamePath?.node.loc || void 0,\n      depth: parentSection ? parentSection.depth + 1 : 0,\n      parent: parentSection,\n      sectionAccessor: void 0,\n      params: void 0,\n      referencedClosures: void 0,\n      referencedHoists: void 0,\n      bindings: void 0,\n      hoisted: void 0,\n      isHoistThrough: void 0,\n      serializeReason: void 0,\n      serializeReasons: /* @__PURE__ */ new Map(),\n      content: getContentInfo(path5),\n      upstreamExpression: void 0,\n      downstreamBinding: void 0,\n      hasAbortSignal: false,\n      isBranch: false\n    };\n    sections.push(section);\n  }\n  return section;\n}\nfunction getOrCreateSection(path5) {\n  let cur = path5;\n  while (true) {\n    if (cur.type === \"Program\" || cur.type === \"MarkoTagBody\" && !cur.node.attributeTags && !isNativeNode(cur.parentPath)) {\n      return (path5.node.extra ??= {}).section = startSection(cur);\n    }\n    cur = cur.parentPath;\n  }\n}\nfunction getSectionForBody(body) {\n  return body.node.extra?.section;\n}\nfunction getSection(path5) {\n  let section;\n  let currentPath = path5;\n  while ((section = currentPath.node.extra?.section) === void 0) {\n    currentPath = currentPath.parentPath;\n  }\n  return section;\n}\nvar [getScopeIdIdentifier] = createSectionState(\n  \"scopeIdIdentifier\",\n  (section) => generateUidIdentifier(`scope${section.id}_id`)\n);\nvar [getSectionParentIsOwner, setSectionParentIsOwner] = createSectionState(\"parentIsOwner\", () => false);\nvar [_getScopeIdentifier] = createSectionState(\n  \"scopeIdentifier\",\n  () => import_compiler10.types.identifier(\"undefined\")\n);\nfunction forEachSection(fn) {\n  const { sections } = (0, import_babel_utils11.getProgram)().node.extra;\n  sections?.forEach(fn);\n}\nfunction forEachSectionReverse(fn) {\n  const { sections } = (0, import_babel_utils11.getProgram)().node.extra;\n  for (let i = sections.length; i--; ) {\n    fn(sections[i]);\n  }\n}\nfunction getContentInfo(path5) {\n  const body = path5.get(\"body\");\n  const contentInfo = {\n    startType: null,\n    endType: null,\n    singleChild: true\n  };\n  for (let endIndex = body.length; endIndex--; ) {\n    const endType = getNodeContentType(body[endIndex], \"endType\", contentInfo);\n    if (endType !== null) {\n      contentInfo.endType = endType;\n      if (endType === 1 /* Dynamic */) {\n        contentInfo.singleChild = false;\n      }\n      for (let startIndex = 0; startIndex < endIndex; startIndex++) {\n        const startType = getNodeContentType(body[startIndex], \"startType\");\n        if (startType !== null) {\n          contentInfo.startType = startType;\n          contentInfo.singleChild = false;\n          return contentInfo;\n        }\n      }\n      contentInfo.startType = getNodeContentType(body[endIndex], \"startType\");\n      return contentInfo;\n    }\n  }\n  return null;\n}\nfunction getNodeContentType(path5, extraMember, contentInfo) {\n  switch (path5.type) {\n    case \"MarkoText\":\n      return 4 /* Text */;\n    case \"MarkoPlaceholder\":\n      return 2 /* Placeholder */;\n    case \"MarkoScriptlet\":\n    case \"MarkoComment\":\n    case \"ImportDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportNamedDeclaration\":\n      return null;\n    case \"MarkoTag\": {\n      const tag = path5;\n      if (isCoreTag(tag)) {\n        switch (tag.node.name.value) {\n          case \"html-comment\":\n            return 0 /* Comment */;\n          case \"html-script\":\n          case \"html-style\":\n            return 3 /* Tag */;\n          case \"for\":\n          case \"if\":\n          case \"await\":\n          case \"try\":\n            return 1 /* Dynamic */;\n          default:\n            return null;\n        }\n      } else if ((0, import_babel_utils11.isNativeTag)(tag)) {\n        return 3 /* Tag */;\n      } else if ((0, import_babel_utils11.isAttributeTag)(tag)) {\n        return null;\n      } else if (import_compiler10.types.isStringLiteral(tag.node.name)) {\n        const tagSection = (0, import_babel_utils11.loadFileForTag)(tag)?.ast.program.extra.section;\n        if (tagSection) {\n          if (tagSection.content) {\n            if (contentInfo && !tagSection.content.singleChild) {\n              if (extraMember === \"endType\") {\n                contentInfo.startType = tagSection.content.startType;\n                contentInfo.singleChild = false;\n              }\n            }\n            return tagSection.content[extraMember];\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n  }\n  return 1 /* Dynamic */;\n}\nvar isSerializedSection = (section) => {\n  if (section.isBranch) return false;\n  const { downstreamBinding } = section;\n  if (downstreamBinding) {\n    return !!getBindingSerializeReason(\n      downstreamBinding.section,\n      downstreamBinding\n    );\n  }\n  return true;\n};\nfunction isImmediateOwner(section, binding) {\n  return section.parent?.id === binding.section.id;\n}\nfunction isDirectClosure(section, closure) {\n  return section.isBranch && isImmediateOwner(section, closure);\n}\nfunction isDynamicClosure(section, closure) {\n  return !isDirectClosure(section, closure);\n}\nfunction getDynamicClosureIndex(closure, closureSection) {\n  let index = 0;\n  find(closure.closureSections, (section) => {\n    if (section === closureSection) return true;\n    if (isDynamicClosure(section, closure)) {\n      index++;\n    }\n    return false;\n  });\n  return index;\n}\nfunction getDirectClosures(section) {\n  if (section.isBranch) {\n    return filter(\n      section.referencedClosures,\n      (closure) => isImmediateOwner(section, closure)\n    );\n  }\n}\nfunction isSameOrChildSection(section, other) {\n  do {\n    if (other === section) {\n      return true;\n    }\n  } while (other = other.parent);\n  return false;\n}\nfunction getCommonSection(section, other) {\n  let ancestor = section;\n  if (other.depth < section.depth) {\n    ancestor = other;\n    other = section;\n  }\n  while (ancestor) {\n    if (other === ancestor || !other.parent) {\n      return ancestor;\n    }\n    other = other.parent;\n    if (other.depth < ancestor.depth) {\n      ancestor = ancestor.parent;\n    }\n  }\n  throw new Error(\"No common section\");\n}\nfunction isNativeNode(tag) {\n  if (isCoreTag(tag)) {\n    switch (tag.node.name.value) {\n      case \"html-comment\":\n      case \"html-script\":\n      case \"html-style\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  return analyzeTagNameType(tag) === 0 /* NativeTag */;\n}\n\n// src/translator/visitors/program/dom.ts\nvar import_compiler21 = require(\"@marko/compiler\");\nvar import_babel_utils15 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-style-file.ts\nvar import_path = __toESM(require(\"path\"));\nfunction getStyleFile(file) {\n  const { filename } = file.opts;\n  const fs = file.markoOpts.fileSystem;\n  const base = getBase(filename);\n  const styleMatch = new RegExp(\n    `^(${escapeRegExp(base)}\\\\.${\"index\" === base ? \"|\" : \"\"})style\\\\.\\\\w+$`\n  );\n  for (const file2 of fs.readdirSync(import_path.default.dirname(filename)).sort()) {\n    if (styleMatch.test(file2)) {\n      return `./${file2}`;\n    }\n  }\n}\nfunction getBase(filename) {\n  const start = filename.lastIndexOf(import_path.default.sep) + 1;\n  const leftDot = filename.indexOf(\".\", start);\n  if (leftDot === -1) {\n    return filename.slice(start);\n  }\n  const rightDot = filename.lastIndexOf(\".\");\n  const closeBracket = leftDot - 1;\n  if (filename[closeBracket] === \"]\") {\n    const openBracket = filename.lastIndexOf(\"[\", closeBracket);\n    if (openBracket > start) {\n      return filename.slice(start, openBracket) + filename.slice(leftDot, rightDot);\n    }\n  }\n  return filename.slice(start, rightDot);\n}\nvar regexpCharsReg = /[\\\\^$.*+?()[\\]{}|]/g;\nfunction escapeRegExp(str) {\n  return str.replace(regexpCharsReg, \"\\\\$&\");\n}\n\n// src/translator/util/signals.ts\nvar import_compiler20 = require(\"@marko/compiler\");\nvar import_babel_utils14 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/core/return.ts\nvar import_compiler17 = require(\"@marko/compiler\");\nvar import_babel_utils13 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-parent-tag.ts\nfunction getParentTag(tag) {\n  const parent = tag.parent.type === \"MarkoTagBody\" ? tag.parentPath.parentPath : tag.parentPath;\n  if (parent.type === \"MarkoTag\") {\n    return parent;\n  }\n}\n\n// src/translator/util/plugin-hooks.ts\nvar import_compiler11 = require(\"@marko/compiler\");\nfunction enter(modulePlugin, path5) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path5;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (isFunctionPlugin(plugin)) {\n    plugin(path5, import_compiler11.types);\n  } else if (plugin.enter) {\n    plugin.enter(path5, import_compiler11.types);\n  }\n  return node !== path5.node;\n}\nfunction exit(modulePlugin, path5) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path5;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (!isFunctionPlugin(plugin) && plugin.exit) {\n    plugin.exit(path5, import_compiler11.types);\n  }\n  return node !== path5.node;\n}\nfunction isModulePlugin(plugin) {\n  return Boolean(plugin.default);\n}\nfunction isFunctionPlugin(plugin) {\n  return typeof plugin === \"function\";\n}\n\n// src/translator/util/visitors.ts\nfunction extractVisitors(visitors2) {\n  const result = {\n    migrate: {},\n    transform: {},\n    analyze: {},\n    translate: {}\n  };\n  for (const _name in visitors2) {\n    const name2 = _name;\n    const value = visitors2[name2];\n    if (value.migrate) result.migrate[name2] = value.migrate;\n    if (value.transform) result.transform[name2] = value.transform;\n    if (value.analyze) result.analyze[name2] = value.analyze;\n    if (value.translate) result.translate[name2] = value.translate;\n  }\n  return result;\n}\nfunction translateByTarget({\n  html,\n  dom\n}) {\n  return {\n    enter(path5) {\n      enter(isOutputHTML() ? html : dom, path5);\n    },\n    exit(path5) {\n      exit(isOutputHTML() ? html : dom, path5);\n    }\n  };\n}\n\n// src/translator/util/writer.ts\nvar import_compiler16 = require(\"@marko/compiler\");\n\n// src/translator/visitors/program/html.ts\nvar import_compiler13 = require(\"@marko/compiler\");\nvar import_babel_utils12 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/is-static.ts\nfunction isStatic(path5) {\n  return path5.isImportDeclaration() || path5.isExportDeclaration() || path5.isMarkoScriptlet({ static: true });\n}\n\n// src/translator/util/simplify-fn.ts\nvar import_compiler12 = require(\"@marko/compiler\");\nfunction simplifyFunction(fn) {\n  switch (fn.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return fn;\n    default:\n      return import_compiler12.types.functionExpression(\n        null,\n        fn.params,\n        fn.body,\n        fn.async,\n        fn.generator\n      );\n  }\n}\n\n// src/translator/util/with-comment.ts\nfunction withLeadingComment(node, value) {\n  const comment = {\n    type: \"CommentBlock\",\n    value: ` ${value} `\n  };\n  node.leadingComments = node.leadingComments ? [...node.leadingComments, comment] : [comment];\n  return node;\n}\n\n// src/translator/visitors/program/html.ts\nfunction getTemplateContentName() {\n  return getSharedUid(\"content\");\n}\nfunction getSerializeGuard(reason, optional) {\n  return !reason ? import_compiler13.types.numericLiteral(0) : reason === true || reason.state ? optional ? void 0 : reason === true ? import_compiler13.types.numericLiteral(1) : withLeadingComment(\n    import_compiler13.types.numericLiteral(1),\n    `state: ${mapToString(reason.state, \", \", getDebugName)}`\n  ) : getInputSerializeReasonGuard(reason.input);\n}\nfunction getSerializeGuardForAny(reasons, optional) {\n  if (!reasons || reasons === true) {\n    return getSerializeGuard(reasons, optional);\n  }\n  if (reasons.length === 1) {\n    return getSerializeGuard(reasons[0], optional);\n  }\n  let expr;\n  for (const reason of reasons) {\n    if (reason.state) {\n      return optional ? void 0 : withLeadingComment(\n        import_compiler13.types.numericLiteral(1),\n        `state: ${mapToString(reason.state, \", \", getDebugName)}`\n      );\n    }\n    const guard = getSerializeGuard(reason, false);\n    expr = expr ? import_compiler13.types.logicalExpression(\"||\", expr, guard) : guard;\n  }\n  return expr;\n}\nfunction getExprIfSerialized(reason, expr) {\n  return reason ? reason === true || reason.state ? expr : import_compiler13.types.logicalExpression(\n    \"&&\",\n    callRuntime(\n      \"serializeIf\",\n      import_compiler13.types.identifier(getSharedUid(\"serialize\")),\n      withLeadingComment(\n        import_compiler13.types.numericLiteral(\n          resolveSerializeReasonId(\n            (0, import_babel_utils12.getProgram)().node.extra.inputSerializeReasons,\n            reason.input\n          )\n        ),\n        mapToString(reason.input, \", \", getInputDebugName)\n      )\n    ),\n    expr\n  ) : void 0;\n}\nfunction getInputSerializeReasonGuard(reason) {\n  return callRuntime(\n    \"serializeGuard\",\n    import_compiler13.types.identifier(getSharedUid(\"serialize\")),\n    withLeadingComment(\n      import_compiler13.types.numericLiteral(\n        resolveSerializeReasonId(\n          (0, import_babel_utils12.getProgram)().node.extra.inputSerializeReasons,\n          reason\n        )\n      ),\n      mapToString(reason, \",\", getDebugName)\n    )\n  );\n}\nvar html_default = {\n  translate: {\n    exit(program) {\n      flushInto(program);\n      writeHTMLResumeStatements(program);\n      traverseReplace(program.node, \"body\", replaceNode);\n      const renderContent = [];\n      for (const child of program.get(\"body\")) {\n        if (!isStatic(child)) {\n          renderContent.push(child.node);\n          child.remove();\n        } else if (child.isMarkoScriptlet()) {\n          if (child.node.target && child.node.target !== \"server\") {\n            child.remove();\n          } else {\n            child.replaceWithMultiple(child.node.body);\n          }\n        }\n      }\n      const serializeId = usedSharedUid(\"serialize\") && getSharedUid(\"serialize\");\n      const contentId = usedSharedUid(\"content\") && getTemplateContentName();\n      const contentFn = import_compiler13.types.arrowFunctionExpression(\n        serializeId ? [import_compiler13.types.identifier(\"input\"), import_compiler13.types.identifier(serializeId)] : [import_compiler13.types.identifier(\"input\")],\n        import_compiler13.types.blockStatement(renderContent)\n      );\n      const exportDefault = import_compiler13.types.exportDefaultDeclaration(\n        callRuntime(\n          \"createTemplate\",\n          import_compiler13.types.stringLiteral(program.hub.file.metadata.marko.id),\n          contentId ? import_compiler13.types.identifier(contentId) : contentFn\n        )\n      );\n      if (contentId) {\n        program.node.body.push(\n          import_compiler13.types.variableDeclaration(\"const\", [\n            import_compiler13.types.variableDeclarator(import_compiler13.types.identifier(contentId), contentFn)\n          ]),\n          exportDefault\n        );\n      } else {\n        program.node.body.push(exportDefault);\n      }\n    }\n  }\n};\nfunction replaceNode(node, container) {\n  return replaceBindingReadNode(node) || replaceRegisteredFunctionNode(node, container);\n}\nfunction replaceBindingReadNode(node) {\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\": {\n      const { extra } = node;\n      if (extra && !(extra.read && !extra.read.binding.declared || extra.binding && !extra.binding.declared)) {\n        return getReadReplacement(node);\n      }\n    }\n  }\n}\nfunction replaceRegisteredFunctionNode(node, container) {\n  switch (node.type) {\n    case \"ClassMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler13.types.classProperty(node.key, replacement);\n    }\n    case \"ClassPrivateMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler13.types.classPrivateProperty(node.key, replacement);\n    }\n    case \"ObjectMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler13.types.objectProperty(node.key, replacement);\n    }\n    case \"FunctionDeclaration\": {\n      const { extra } = node;\n      if (isRegisteredFnExtra(extra)) {\n        let registeredFnDeclarations = registeredFnDeclarationsByBody.get(\n          container\n        );\n        if (!registeredFnDeclarations) {\n          registeredFnDeclarationsByBody.set(\n            container,\n            registeredFnDeclarations = []\n          );\n        }\n        registeredFnDeclarations.push({\n          id: node.id.name,\n          registerId: extra.registerId\n        });\n      }\n      break;\n    }\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\": {\n      return getRegisteredFnExpression(node);\n    }\n    case \"BlockStatement\":\n    case \"MarkoScriptlet\":\n      addRegisteredDeclarations(node.body);\n      break;\n  }\n}\nvar registeredFnDeclarationsByBody = /* @__PURE__ */ new WeakMap();\nfunction addRegisteredDeclarations(body) {\n  const registeredFnDeclarations = registeredFnDeclarationsByBody.get(body);\n  if (registeredFnDeclarations) {\n    for (const { id, registerId } of registeredFnDeclarations) {\n      body.push(\n        import_compiler13.types.expressionStatement(\n          callRuntime(\n            \"register\",\n            import_compiler13.types.identifier(id),\n            import_compiler13.types.stringLiteral(registerId)\n          )\n        )\n      );\n    }\n  }\n}\nfunction getRegisteredFnExpression(node) {\n  const { extra } = node;\n  if (isRegisteredFnExtra(extra)) {\n    return callRuntime(\n      \"register\",\n      simplifyFunction(node),\n      import_compiler13.types.stringLiteral(extra.registerId),\n      (extra.referencedBindingsInFunction || extra.referencesScope) && getScopeIdIdentifier(extra.section)\n    );\n  }\n}\n\n// src/translator/util/normalize-string-expression.ts\nvar import_compiler14 = require(\"@marko/compiler\");\nfunction normalizeStringExpression(parts) {\n  const strs = [];\n  const exprs = [];\n  let curStr = parts[0];\n  for (let i = 1; i < parts.length; i++) {\n    let content = parts[i];\n    if (typeof content === \"object\") {\n      if (import_compiler14.types.isStringLiteral(content)) {\n        content = content.value;\n      } else if (import_compiler14.types.isTemplateLiteral(content)) {\n        let nextIndex = i + 1;\n        const exprLen = content.expressions.length;\n        shiftItems(parts, nextIndex, content.quasis.length + exprLen);\n        for (let j = 0; j < exprLen; j++) {\n          parts[nextIndex++] = content.quasis[j].value.raw;\n          parts[nextIndex++] = content.expressions[j];\n        }\n        parts[nextIndex] = content.quasis[exprLen].value.raw;\n        continue;\n      } else {\n        exprs.push(content);\n        strs.push(curStr);\n        curStr = \"\";\n        continue;\n      }\n    }\n    curStr += content;\n  }\n  if (exprs.length) {\n    if (exprs.length === 1 && !curStr && !strs[0]) {\n      return exprs[0];\n    }\n    strs.push(curStr);\n    return import_compiler14.types.templateLiteral(\n      strs.map((raw) => import_compiler14.types.templateElement({ raw })),\n      exprs\n    );\n  } else if (curStr) {\n    return import_compiler14.types.stringLiteral(curStr);\n  }\n}\nfunction appendLiteral(arr, str) {\n  arr[arr.length - 1] += str;\n}\nfunction shiftItems(list, start, offset) {\n  for (let i = list.length - 1; i >= start; i--) {\n    list[i + offset] = list[i];\n  }\n}\n\n// src/translator/util/walks.ts\nvar import_compiler15 = require(\"@marko/compiler\");\nvar [getWalks] = createSectionState(\n  \"walks\",\n  () => [\"\"]\n);\nvar [getWalkComment] = createSectionState(\n  \"walkComment\",\n  () => []\n);\nvar [getSteps] = createSectionState(\"steps\", () => []);\nvar walkCodeToName = {\n  [32 /* Get */]: \"get\",\n  [36 /* Inside */]: \"inside\",\n  [37 /* Replace */]: \"replace\",\n  [38 /* EndChild */]: \"endChild\",\n  [47 /* BeginChild */]: \"beginChild\",\n  [48 /* BeginChildWithVar */]: \"beginChildWithVar\",\n  [49 /* DynamicTagWithVar */]: \"dynamicTagWithVar\",\n  [67 /* Next */]: \"next\",\n  [97 /* Over */]: \"over\",\n  [107 /* Out */]: \"out\",\n  [117 /* Multiplier */]: \"multiplier\",\n  [91 /* NextEnd */]: \"nextEnd\",\n  [106 /* OverEnd */]: \"overEnd\",\n  [116 /* OutEnd */]: \"outEnd\",\n  [126 /* MultiplierEnd */]: \"multiplierEnd\"\n};\nfunction enter2(path5) {\n  getSteps(getSection(path5)).push(0 /* Enter */);\n}\nfunction exit2(path5) {\n  getSteps(getSection(path5)).push(1 /* Exit */);\n}\nfunction enterShallow(path5) {\n  getSteps(getSection(path5)).push(0 /* Enter */, 1 /* Exit */);\n}\nfunction injectWalks(tag, expr) {\n  const walks = getWalks(getSection(tag));\n  const walkComment = getWalkComment(getSection(tag));\n  walkComment.push(\n    `${walkCodeToName[tag.node.var ? 48 /* BeginChildWithVar */ : 47 /* BeginChild */]}`,\n    expr.name,\n    walkCodeToName[38 /* EndChild */]\n  );\n  appendLiteral(\n    walks,\n    String.fromCharCode(\n      tag.node.var ? 48 /* BeginChildWithVar */ : 47 /* BeginChild */\n    )\n  );\n  walks.push(expr, String.fromCharCode(38 /* EndChild */));\n}\nfunction visit(path5, code) {\n  if (isOutputHTML()) {\n    return;\n  }\n  const section = getSection(path5);\n  const steps = getSteps(section);\n  const walks = getWalks(section);\n  const walkComment = getWalkComment(section);\n  let walkString = \"\";\n  if (steps.length) {\n    const walkCodes = [];\n    let depth = 0;\n    for (const step of steps) {\n      if (step === 0 /* Enter */) {\n        depth++;\n        walkCodes.push(67 /* Next */);\n      } else {\n        depth--;\n        if (depth >= 0) {\n          walkCodes.length = walkCodes.lastIndexOf(67 /* Next */);\n          walkCodes.push(97 /* Over */);\n        } else {\n          walkCodes.length = walkCodes.lastIndexOf(107 /* Out */) + 1;\n          walkCodes.push(107 /* Out */);\n          depth = 0;\n        }\n      }\n    }\n    let current = walkCodes[0];\n    let count = 0;\n    for (const walk of walkCodes) {\n      if (walk !== current) {\n        walkComment.push(`${walkCodeToName[current]}(${count})`);\n        walkString += nCodeString(current, count);\n        current = walk;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n    walkComment.push(`${walkCodeToName[current]}(${count})`);\n    walkString += nCodeString(current, count);\n    steps.length = 0;\n  }\n  if (code !== void 0) {\n    if (code !== 32 /* Get */) {\n      writeTo(path5)`<!>`;\n    }\n    walkComment.push(`${walkCodeToName[code]}`);\n    walkString += String.fromCharCode(code);\n  }\n  appendLiteral(walks, walkString);\n}\nfunction nCodeString(code, number) {\n  switch (code) {\n    case 67 /* Next */:\n      return toCharString(number, code, 20 /* Next */);\n    case 97 /* Over */:\n      return toCharString(number, code, 10 /* Over */);\n    case 107 /* Out */:\n      return toCharString(number, code, 10 /* Out */);\n    default:\n      throw new Error(`Unexpected walk code: ${code}`);\n  }\n}\nfunction toCharString(number, startCode, rangeSize) {\n  let result = \"\";\n  if (number >= rangeSize) {\n    const multiplier = Math.floor(number / rangeSize);\n    result += toCharString(\n      multiplier,\n      117 /* Multiplier */,\n      10 /* Multiplier */\n    );\n    number -= multiplier * rangeSize;\n  }\n  result += String.fromCharCode(startCode + number);\n  return result;\n}\nfunction getWalkString(section) {\n  const prefix2 = section.content?.startType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const postfix = section.content?.endType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const walks = getWalks(section);\n  const walkLiteral = normalizeStringExpression([prefix2, ...walks, postfix]);\n  if (walkLiteral && walkLiteral.value !== \"\") {\n    withLeadingComment(walkLiteral, getWalkComment(section).join(\", \"));\n  }\n  return walkLiteral;\n}\n\n// src/translator/util/writer.ts\nvar [getWrites] = createSectionState(\n  \"writes\",\n  () => [\"\"]\n);\nvar [getTrailerWrites] = createSectionState(\n  \"trailerWrites\",\n  () => [\"\"]\n);\nfunction writeTo(path5, trailer) {\n  const section = getSection(path5);\n  const get = trailer ? getTrailerWrites : getWrites;\n  return (strs, ...exprs) => {\n    const exprsLen = exprs.length;\n    const writes = get(section);\n    appendLiteral(writes, strs[0]);\n    for (let i = 0; i < exprsLen; i++) {\n      writes.push(exprs[i], strs[i + 1]);\n    }\n  };\n}\nfunction consumeHTML(path5) {\n  const section = getSection(path5);\n  const writes = getWrites(section);\n  const trailers = getTrailerWrites(section);\n  const writeResult = normalizeStringExpression(writes);\n  const trailerResult = normalizeStringExpression(trailers);\n  writes.length = 0;\n  writes[0] = \"\";\n  trailers.length = 0;\n  trailers[0] = \"\";\n  if (writeResult && trailerResult) {\n    return import_compiler16.types.expressionStatement(\n      import_compiler16.types.sequenceExpression([\n        callRuntime(\"write\", writeResult),\n        callRuntime(\"writeTrailers\", trailerResult)\n      ])\n    );\n  } else if (writeResult) {\n    return import_compiler16.types.expressionStatement(callRuntime(\"write\", writeResult));\n  } else if (trailerResult) {\n    return import_compiler16.types.expressionStatement(callRuntime(\"writeTrailers\", trailerResult));\n  }\n}\nfunction flushBefore(path5) {\n  const expr = consumeHTML(path5);\n  if (expr) {\n    path5.insertBefore(expr)[0].skip();\n  }\n}\nfunction flushInto(path5) {\n  const target = path5.isProgram() ? path5 : path5.get(\"body\");\n  const expr = consumeHTML(target);\n  if (expr) {\n    target.node.body.push(expr);\n  }\n}\nfunction getSectionMeta(section) {\n  const writePrefix = section.content?.startType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writePostfix = section.content?.endType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writes = getWrites(section);\n  return {\n    setup: getSetup(section),\n    walks: getWalkString(section),\n    writes: normalizeStringExpression([writePrefix, ...writes, writePostfix])\n  };\n}\nfunction markNode(path5, nodeBinding, reason) {\n  if (nodeBinding.type !== 0 /* dom */) {\n    throw path5.buildCodeFrameError(\n      \"Tried to mark a node that was not determined to need a mark during analyze.\"\n    );\n  }\n  if (isOutputHTML()) {\n    if (reason) {\n      const section = getSection(path5);\n      writeTo(path5)`${callRuntime(\n        \"markResumeNode\",\n        getScopeIdIdentifier(section),\n        getScopeAccessorLiteral(nodeBinding),\n        getSerializeGuard(reason, true)\n      )}`;\n    }\n  }\n}\n\n// src/translator/core/return.ts\nvar tagsWithReturn = /* @__PURE__ */ new WeakSet();\nvar [getSectionReturnValueIdentifier, setReturnValueIdentifier] = createSectionState(\"returnValue\");\nvar return_default = {\n  analyze(tag) {\n    (0, import_babel_utils13.assertNoArgs)(tag);\n    (0, import_babel_utils13.assertNoVar)(tag);\n    (0, import_babel_utils13.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils13.assertAllowedAttributes)(tag, [\"value\", \"valueChange\"]);\n    const parentTag = getParentTag(tag);\n    if (parentTag) {\n      if ((0, import_babel_utils13.isNativeTag)(parentTag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The `return` tag can not be used in a native tag.\"\n        );\n      } else if (isControlFlowTag(parentTag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          `The \\`return\\` tag can not be used under an \\`${parentTag.get(\"name\").toString()}\\` tag.`\n        );\n      }\n    }\n    if (tagsWithReturn.has(tag.parentPath)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        `Cannot have multiple \\`return\\` tags ${tag.parent.type === \"Program\" ? \"for the template\" : \"within a tag's body content\"}.`\n      );\n    } else {\n      tagsWithReturn.add(tag.parentPath);\n    }\n    const attrs2 = getKnownAttrValues(tag.node);\n    if (!attrs2.value) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `return` tag requires a value.\");\n    }\n    if (attrs2.valueChange) {\n      forceSectionSerialize(\n        getOrCreateSection(tag),\n        getAccessorProp().TagVariableChange\n      );\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      exit(tag) {\n        const section = getSection(tag);\n        const attrs2 = getKnownAttrValues(tag.node);\n        flushBefore(tag);\n        if (attrs2.valueChange) {\n          setSectionSerializedValue(\n            section,\n            getAccessorProp().TagVariableChange,\n            attrs2.valueChange\n          );\n        }\n        if (attrs2.value) {\n          const returnId = generateUidIdentifier(\"return\");\n          setReturnValueIdentifier(section, returnId);\n          tag.replaceWith(\n            import_compiler17.types.variableDeclaration(\"const\", [\n              import_compiler17.types.variableDeclarator(returnId, attrs2.value)\n            ])\n          )[0].skip();\n        }\n      }\n    },\n    dom: {\n      exit(tag) {\n        const section = getSection(tag);\n        const attrs2 = getKnownAttrValues(tag.node);\n        if (attrs2.value) {\n          addStatement(\n            \"render\",\n            section,\n            attrs2.value.extra?.referencedBindings,\n            import_compiler17.types.expressionStatement(\n              callRuntime(\"tagVarSignal\", scopeIdentifier, attrs2.value)\n            )\n          );\n        }\n        if (attrs2.valueChange) {\n          addStatement(\n            \"render\",\n            section,\n            attrs2.valueChange.extra?.referencedBindings,\n            import_compiler17.types.expressionStatement(\n              callRuntime(\n                \"setTagVarChange\",\n                scopeIdentifier,\n                attrs2.valueChange\n              )\n            )\n          );\n        }\n        tag.remove();\n      }\n    }\n  }),\n  parseOptions: {\n    openTagOnly: true\n  },\n  autocomplete: [\n    {\n      displayText: \"return=<value>\",\n      description: \"Provides a value for use in a parent template.\",\n      snippet: \"return=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#return\"\n    }\n  ]\n};\n\n// src/translator/util/get-defined-binding-expression.ts\nvar import_compiler18 = require(\"@marko/compiler\");\nfunction getDeclaredBindingExpression(binding) {\n  const canonicalBinding = getCanonicalBinding(binding);\n  if (canonicalBinding.declared || !canonicalBinding.upstreamAlias) {\n    return import_compiler18.types.identifier(canonicalBinding.name);\n  } else if (canonicalBinding.property !== void 0) {\n    return toMemberExpression(\n      getDeclaredBindingExpression(canonicalBinding.upstreamAlias),\n      canonicalBinding.property,\n      canonicalBinding.upstreamAlias.nullable\n    );\n  } else {\n    return getDeclaredBindingExpression(canonicalBinding.upstreamAlias);\n  }\n}\n\n// src/translator/util/to-first-expression-or-block.ts\nvar import_compiler19 = require(\"@marko/compiler\");\nfunction toFirstExpressionOrBlock(stmts) {\n  if (stmts.length === 1 && import_compiler19.types.isExpressionStatement(stmts[0])) {\n    const { expression } = stmts[0];\n    switch (expression.type) {\n      case \"ObjectExpression\":\n      case \"AssignmentExpression\":\n        return toParenthesizedExpressionIfNeeded(expression);\n      default:\n        return expression;\n    }\n  }\n  return import_compiler19.types.blockStatement(stmts);\n}\nfunction toParenthesizedExpressionIfNeeded(expr) {\n  switch (expr.type) {\n    case \"ObjectExpression\":\n    case \"AssignmentExpression\":\n      return import_compiler19.types.parenthesizedExpression(expr);\n    default:\n      return expr;\n  }\n}\n\n// src/translator/util/signals.ts\nvar [getSignals] = createSectionState(\n  \"signals\",\n  () => /* @__PURE__ */ new Map()\n);\nvar [getClosureSignalBuilder, _setClosureSignalBuilder] = createSectionState(\"queue\");\nfunction setClosureSignalBuilder(tag, builder) {\n  _setClosureSignalBuilder(getSectionForBody(tag.get(\"body\")), builder);\n}\nvar [getSerializedAccessors] = createSectionState(\"serializedScopeProperties\", () => /* @__PURE__ */ new Map());\nfunction setSectionSerializedValue(section, prop, expression) {\n  const reason = getSectionSerializeReason(section, prop);\n  if (reason) {\n    getSerializedAccessors(section).set(prop, { expression, reason });\n  }\n}\nfunction setBindingSerializedValue(section, binding, expression, prefix2) {\n  const reason = getBindingSerializeReason(section, binding, prefix2);\n  if (reason) {\n    getSerializedAccessors(section).set(\n      (prefix2 || \"\") + getScopeAccessor(binding),\n      { expression, reason }\n    );\n  }\n}\nvar nonAnalyzedForceSerializedSection = /* @__PURE__ */ new WeakSet();\nfunction setSerializedValue(section, key, expression) {\n  nonAnalyzedForceSerializedSection.add(section);\n  getSerializedAccessors(section).set(key, { expression, reason: true });\n}\nvar [getSectionWriteScopeBuilder, setSectionWriteScopeBuilder] = createSectionState(\n  \"sectionWriteScopeBuilder\"\n);\nfunction addWriteScopeBuilder(section, builder) {\n  const prev = getSectionWriteScopeBuilder(section);\n  setSectionWriteScopeBuilder(\n    section,\n    prev ? (expr) => builder(prev(expr)) : builder\n  );\n}\nvar htmlDynamicClosureInstancesIdentifier = /* @__PURE__ */ new WeakMap();\nvar [getHTMLSectionStatements] = createSectionState(\n  \"htmlScopeStatements\",\n  () => []\n);\nvar [getHoistFunctionsIdsMap] = createSectionState(\"hoistFunctionsIdsMap\", () => /* @__PURE__ */ new Map());\nfunction getHoistFunctionIdentifier(hoistedBinding) {\n  const idsMap = getHoistFunctionsIdsMap(hoistedBinding.section);\n  let identifier = idsMap.get(hoistedBinding);\n  if (!identifier) {\n    idsMap.set(\n      hoistedBinding,\n      identifier = generateUidIdentifier(`get${hoistedBinding.name}`)\n    );\n  }\n  return identifier;\n}\nvar unimplementedBuild = () => {\n  return import_compiler20.types.stringLiteral(\"SIGNAL NOT INITIALIZED\");\n};\nfunction getSignal(section, referencedBindings, name2 = generateSignalName(referencedBindings)) {\n  const signals = getSignals(section);\n  let signal = signals.get(referencedBindings);\n  if (!signal) {\n    const exportName = referencedBindings ? !Array.isArray(referencedBindings) && referencedBindings.section === section && referencedBindings.export : !section.parent && (0, import_babel_utils14.getProgram)().node.extra.domExports?.setup;\n    signals.set(\n      referencedBindings,\n      signal = {\n        identifier: exportName ? import_compiler20.types.identifier(exportName) : generateUidIdentifier(name2 + section.name.replace(\"_\", \"$\")),\n        referencedBindings,\n        section,\n        values: [],\n        intersection: void 0,\n        render: [],\n        renderReferencedBindings: void 0,\n        effect: [],\n        effectReferencedBindings: void 0,\n        subscribers: [],\n        build: unimplementedBuild,\n        export: !!exportName\n      }\n    );\n    if (isOutputHTML()) {\n      return signal;\n    } else if (!referencedBindings) {\n      signal.build = () => getSignalFn(signal);\n    } else if (Array.isArray(referencedBindings)) {\n      subscribe(referencedBindings, signal);\n      signal.build = () => {\n        const { id, scopeOffset } = intersectionMeta.get(referencedBindings);\n        return callRuntime(\n          \"intersection\",\n          import_compiler20.types.numericLiteral(id),\n          getSignalFn(signal),\n          scopeOffset || referencedBindings.length > 2 ? import_compiler20.types.numericLiteral(referencedBindings.length - 1) : void 0,\n          scopeOffset && getScopeAccessorLiteral(scopeOffset)\n        );\n      };\n    } else if (referencedBindings.section !== section && bindingUtil.find(section.referencedClosures, referencedBindings)) {\n      signal.build = () => {\n        const canonicalClosure = getCanonicalBinding(referencedBindings);\n        const render = getSignalFn(signal);\n        const closureSignalBuilder = getClosureSignalBuilder(section);\n        return !closureSignalBuilder || isDynamicClosure(section, canonicalClosure) ? callRuntime(\n          \"dynamicClosureRead\",\n          getScopeAccessorLiteral(canonicalClosure),\n          render,\n          isImmediateOwner(section, canonicalClosure) ? void 0 : import_compiler20.types.arrowFunctionExpression(\n            [scopeIdentifier],\n            getScopeExpression(section, canonicalClosure.section)\n          )\n        ) : getClosureSignalBuilder(section)(canonicalClosure, render);\n      };\n    }\n  }\n  return signal;\n}\nfunction initValue(binding, runtimeHelper = \"value\") {\n  const section = binding.section;\n  const signal = getSignal(section, binding);\n  signal.build = () => {\n    const fn = getSignalFn(signal);\n    const isParamBinding = !binding.upstreamAlias && (binding.type === 3 /* param */ || binding.type === 2 /* input */);\n    const isNakedAlias = binding.upstreamAlias && !binding.property;\n    const needsGuard = !isNakedAlias && (binding.closureSections || binding.downstreamExpressions.size || fn.type === \"ArrowFunctionExpression\" && fn.body.body.length > 0);\n    const needsCache = needsGuard || signal.intersection;\n    const needsMarks = isParamBinding || signal.intersection;\n    if (needsCache || needsMarks || binding.hoists.size) {\n      return callRuntime(\n        runtimeHelper,\n        getScopeAccessorLiteral(binding, runtimeHelper === \"state\"),\n        fn\n      );\n    } else {\n      return fn;\n    }\n  };\n  signal.valueAccessor = getScopeAccessorLiteral(binding);\n  for (const alias of binding.aliases) {\n    initValue(alias);\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    initValue(alias);\n  }\n  return signal;\n}\nfunction getSignalFn(signal) {\n  const section = signal.section;\n  const binding = signal.referencedBindings;\n  const params = [scopeIdentifier];\n  const isIntersection = Array.isArray(binding);\n  const isBinding = binding && !isIntersection;\n  const isValue = isBinding && binding.section === section;\n  if (isBinding && (signal.renderReferencedBindings || binding.aliases.size || binding.propertyAliases.size)) {\n    const valueParam = import_compiler20.types.identifier(binding.name);\n    if (binding.loc) {\n      valueParam.loc = binding.loc;\n      valueParam.start = binding.loc.start.index;\n      valueParam.end = binding.loc.end.index;\n    }\n    params.push(valueParam);\n  }\n  if (isValue) {\n    for (const alias of binding.aliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      if (aliasSignal.render.length || aliasSignal.values.length || aliasSignal.effect.length) {\n        signal.render.push(\n          import_compiler20.types.expressionStatement(\n            import_compiler20.types.callExpression(aliasSignal.identifier, [\n              scopeIdentifier,\n              import_compiler20.types.identifier(binding.name),\n              ...getTranslatedExtraArgs(aliasSignal)\n            ])\n          )\n        );\n      }\n    }\n    for (const [key, alias] of binding.propertyAliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler20.types.expressionStatement(\n          import_compiler20.types.callExpression(aliasSignal.identifier, [\n            scopeIdentifier,\n            toMemberExpression(\n              import_compiler20.types.identifier(binding.name),\n              key,\n              binding.nullable\n            ),\n            ...getTranslatedExtraArgs(aliasSignal)\n          ])\n        )\n      );\n    }\n  }\n  for (const value of signal.values) {\n    const valSignal = value.signal;\n    if (!valSignal.referencedBindings || Array.isArray(valSignal.referencedBindings) || !valSignal.referencedBindings.upstreamAlias || valSignal.referencedBindings.property || valSignal.effect.length || valSignal.render.length || valSignal.values.length) {\n      signal.render.push(\n        import_compiler20.types.expressionStatement(\n          import_compiler20.types.callExpression(value.signal.identifier, [\n            scopeIdentifier,\n            value.value,\n            ...getTranslatedExtraArgs(value.signal)\n          ])\n        )\n      );\n    } else {\n      signal.render.push(import_compiler20.types.expressionStatement(value.value));\n    }\n  }\n  forEach(signal.intersection, (intersection) => {\n    signal.render.push(\n      import_compiler20.types.expressionStatement(\n        import_compiler20.types.callExpression(intersection.identifier, [scopeIdentifier])\n      )\n    );\n  });\n  if (isValue && binding.sources) {\n    let dynamicClosureArgs;\n    let dynamicClosureSignalIdentifier;\n    if (binding.sources) {\n      forEach(binding.closureSections, (closureSection) => {\n        if (isDynamicClosure(closureSection, binding)) {\n          if (!dynamicClosureArgs) {\n            dynamicClosureArgs = [];\n            dynamicClosureSignalIdentifier = generateUidIdentifier(\n              signal.identifier.name + \"_closure\"\n            );\n            signal.render.push(\n              import_compiler20.types.expressionStatement(\n                import_compiler20.types.callExpression(dynamicClosureSignalIdentifier, [\n                  scopeIdentifier\n                ])\n              )\n            );\n          }\n          dynamicClosureArgs.push(\n            getSignal(closureSection, binding).identifier\n          );\n        } else {\n          signal.render.push(\n            import_compiler20.types.expressionStatement(\n              import_compiler20.types.callExpression(getSignal(closureSection, binding).identifier, [\n                scopeIdentifier\n              ])\n            )\n          );\n        }\n      });\n      if (dynamicClosureSignalIdentifier) {\n        (signal.prependStatements ||= []).push(\n          import_compiler20.types.variableDeclaration(\"const\", [\n            import_compiler20.types.variableDeclarator(\n              dynamicClosureSignalIdentifier,\n              callRuntime(\"dynamicClosure\", ...dynamicClosureArgs)\n            )\n          ])\n        );\n      }\n    }\n  }\n  if (signal.effect.length) {\n    const effectIdentifier = import_compiler20.types.identifier(`${signal.identifier.name}_effect`);\n    signal.render.push(\n      import_compiler20.types.expressionStatement(\n        import_compiler20.types.callExpression(effectIdentifier, [scopeIdentifier])\n      )\n    );\n  }\n  if (isIntersection && signal.renderReferencedBindings) {\n    signal.render.unshift(\n      import_compiler20.types.variableDeclaration(\"const\", [\n        import_compiler20.types.variableDeclarator(\n          createScopeReadPattern(section, signal.renderReferencedBindings),\n          scopeIdentifier\n        )\n      ])\n    );\n  }\n  if (signal.render.length === 1) {\n    const render = signal.render[0];\n    if (render.type === \"ExpressionStatement\") {\n      const { expression } = render;\n      if (expression.type === \"CallExpression\") {\n        const args = expression.arguments;\n        if (params.length >= args.length) {\n          let i = args.length;\n          for (; i--; ) {\n            const param = params[i];\n            const arg = args[i];\n            if (arg.type !== \"Identifier\" || param.name !== arg.name) {\n              break;\n            }\n          }\n          if (i === -1) {\n            return expression.callee;\n          }\n        }\n      }\n    }\n  }\n  return import_compiler20.types.arrowFunctionExpression(params, import_compiler20.types.blockStatement(signal.render));\n}\nvar hasTranslatedExtraArgs = /* @__PURE__ */ new WeakSet();\nvar emptyExtraArgs = [];\nfunction getTranslatedExtraArgs(signal) {\n  if (signal.extraArgs) {\n    if (!hasTranslatedExtraArgs.has(signal)) {\n      hasTranslatedExtraArgs.add(signal);\n      traverseReplace(signal, \"extraArgs\", replaceRenderNode);\n    }\n    return signal.extraArgs;\n  }\n  return emptyExtraArgs;\n}\nfunction subscribe(provider, subscriber) {\n  if (Array.isArray(provider)) {\n    provider.forEach((p) => subscribe(p, subscriber));\n    return;\n  }\n  const providerSignal = getSignal(subscriber.section, provider);\n  providerSignal.intersection = push(providerSignal.intersection, subscriber);\n}\nfunction generateSignalName(referencedBindings) {\n  let name2;\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      name2 = \"expr\";\n      for (const ref of referencedBindings) {\n        name2 += `_${ref.name}`;\n      }\n    } else {\n      name2 = referencedBindings.name;\n    }\n  } else {\n    name2 = \"setup\";\n  }\n  return name2;\n}\nfunction replaceNullishAndEmptyFunctionsWith0(args) {\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (!arg) {\n      args[i] = import_compiler20.types.numericLiteral(0);\n    } else if (import_compiler20.types.isArrowFunctionExpression(arg) && import_compiler20.types.isBlockStatement(arg.body)) {\n      const body = arg.body.body;\n      if (body.length === 0) {\n        args[i] = import_compiler20.types.numericLiteral(0);\n      } else if (body.length === 1 && import_compiler20.types.isExpressionStatement(body[0])) {\n        arg.body = toParenthesizedExpressionIfNeeded(body[0].expression);\n      }\n    } else if (import_compiler20.types.isNullLiteral(arg) || import_compiler20.types.isUnaryExpression(arg) && arg.operator === \"void\") {\n      args[i] = import_compiler20.types.numericLiteral(0);\n    }\n  }\n  for (let i = args.length - 1; import_compiler20.types.isNumericLiteral(args[i]) && args[i].value === 0; ) {\n    args.length = i--;\n  }\n  return args;\n}\nfunction addStatement(type, targetSection, referencedBindings, statement, usedReferences) {\n  const signal = getSignal(targetSection, referencedBindings);\n  const statements = signal[type] ??= [];\n  const add = type === \"effect\" ? addEffectReferences : addRenderReferences;\n  if (Array.isArray(statement)) {\n    statements.push(...statement);\n  } else {\n    statements.push(statement);\n  }\n  if (usedReferences !== false) {\n    if (usedReferences) {\n      for (const ref of usedReferences) {\n        add(signal, ref);\n      }\n    } else {\n      add(signal, referencedBindings);\n    }\n  }\n}\nfunction addEffectReferences(signal, referencedBindings) {\n  signal.effectReferencedBindings = bindingUtil.union(\n    signal.effectReferencedBindings,\n    referencedBindings\n  );\n}\nfunction addRenderReferences(signal, referencedBindings) {\n  signal.renderReferencedBindings = bindingUtil.union(\n    signal.renderReferencedBindings,\n    referencedBindings\n  );\n}\nfunction addValue(targetSection, referencedBindings, signal, value) {\n  const parentSignal = getSignal(targetSection, referencedBindings);\n  addRenderReferences(parentSignal, referencedBindings);\n  parentSignal.values.push({\n    signal,\n    value\n  });\n}\nfunction getResumeRegisterId(section, referencedBindings, type) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = (0, import_babel_utils14.getFile)();\n  let name2 = \"\";\n  if (referencedBindings) {\n    if (typeof referencedBindings === \"string\") {\n      name2 += `_${referencedBindings}`;\n    } else if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        name2 += `_${ref.name}`;\n      }\n    } else {\n      name2 += `_${referencedBindings.name}`;\n    }\n  }\n  return (0, import_babel_utils14.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}${name2}${type ? \"/\" + type : \"\"}`\n  );\n}\nvar usedRegisterIdsBySection = /* @__PURE__ */ new WeakMap();\nfunction getRegisterUID(section, name2) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = (0, import_babel_utils14.getFile)();\n  let used = usedRegisterIdsBySection.get(section);\n  if (!used) usedRegisterIdsBySection.set(section, used = /* @__PURE__ */ new Set());\n  const baseId = (0, import_babel_utils14.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}/${name2}`\n  );\n  let count = 0;\n  let id = baseId;\n  while (used.has(id)) {\n    id = baseId + \"_\" + ++count;\n  }\n  used.add(id);\n  return id;\n}\nfunction writeSignals(section) {\n  const seen = /* @__PURE__ */ new Set();\n  writeHoists(section);\n  for (const signal of getSignals(section).values()) {\n    writeSignal(signal);\n  }\n  function writeSignal(signal) {\n    if (seen.has(signal)) return;\n    seen.add(signal);\n    for (const value2 of signal.values) {\n      writeSignal(value2.signal);\n      traverseReplace(value2, \"value\", replaceRenderNode);\n    }\n    forEach(signal.intersection, writeSignal);\n    traverseReplace(signal, \"render\", replaceRenderNode);\n    let effectDeclarator;\n    if (signal.effect.length) {\n      traverseReplace(signal, \"effect\", replaceEffectNode);\n      const effectIdentifier = import_compiler20.types.identifier(`${signal.identifier.name}_effect`);\n      const referencedBindings = signal.effectReferencedBindings;\n      const referencesScope = traverseContains(\n        signal.effect,\n        isScopeIdentifier\n      );\n      effectDeclarator = import_compiler20.types.variableDeclarator(\n        effectIdentifier,\n        callRuntime(\n          \"effect\",\n          import_compiler20.types.stringLiteral(\n            getResumeRegisterId(section, signal.referencedBindings)\n          ),\n          import_compiler20.types.arrowFunctionExpression(\n            referencedBindings ? referencesScope ? [\n              scopeIdentifier,\n              createScopeReadPattern(section, referencedBindings)\n            ] : [createScopeReadPattern(section, referencedBindings)] : referencesScope ? [scopeIdentifier] : [],\n            toFirstExpressionOrBlock(signal.effect)\n          )\n        )\n      );\n    }\n    let value = signal.build();\n    if (\n      // It's possible for aliases to render nothing\n      // if they're only consumed in effects/closures.\n      // This ignores writing out those signals in that case.\n      signal.referencedBindings && !Array.isArray(signal.referencedBindings) && signal.referencedBindings.upstreamAlias && !signal.referencedBindings.property && import_compiler20.types.isFunction(value) && import_compiler20.types.isBlockStatement(value.body) && !value.body.body.length\n    ) {\n      return;\n    }\n    if (import_compiler20.types.isCallExpression(value)) {\n      replaceNullishAndEmptyFunctionsWith0(value.arguments);\n    }\n    if (signal.register) {\n      value = callRuntime(\n        \"registerBoundSignal\",\n        import_compiler20.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings, \"var\")\n        ),\n        value\n      );\n    }\n    const signalDeclarator = import_compiler20.types.variableDeclarator(signal.identifier, value);\n    let signalDeclaration = !section.parent && !signal.referencedBindings && (import_compiler20.types.isFunctionExpression(value) || import_compiler20.types.isArrowFunctionExpression(value)) ? import_compiler20.types.functionDeclaration(\n      signal.identifier,\n      value.params,\n      import_compiler20.types.isExpression(value.body) ? import_compiler20.types.blockStatement([import_compiler20.types.expressionStatement(value.body)]) : value.body\n    ) : import_compiler20.types.variableDeclaration(\"const\", [signalDeclarator]);\n    if (signal.export) {\n      signalDeclaration = import_compiler20.types.exportNamedDeclaration(signalDeclaration);\n    }\n    const signalStatements = signal.prependStatements || [];\n    if (effectDeclarator) {\n      signalStatements.push(import_compiler20.types.variableDeclaration(\"const\", [effectDeclarator]));\n    }\n    signalStatements.push(signalDeclaration);\n    (0, import_babel_utils14.getProgram)().node.body.push(...signalStatements);\n  }\n}\nfunction writeHoists(section) {\n  forEach(section.hoisted, (binding) => {\n    for (const hoistedBinding of binding.hoists.values()) {\n      const accessors = [\n        binding.type === 0 /* dom */ ? import_compiler20.types.stringLiteral(\n          getAccessorPrefix().Getter + getScopeAccessor(binding)\n        ) : getScopeAccessorLiteral(binding)\n      ];\n      let currentSection = section;\n      while (currentSection && currentSection !== hoistedBinding.section) {\n        const parentSection = currentSection.parent;\n        if (parentSection) {\n          accessors.push(getSectionInstancesAccessorLiteral(currentSection));\n        }\n        currentSection = parentSection;\n      }\n      const hoistIdentifier = getHoistFunctionIdentifier(hoistedBinding);\n      (0, import_babel_utils14.getProgram)().node.body.push(\n        import_compiler20.types.variableDeclaration(\"const\", [\n          import_compiler20.types.variableDeclarator(\n            hoistIdentifier,\n            hoistedBinding.downstreamExpressions.size ? callRuntime(\n              \"register\",\n              import_compiler20.types.stringLiteral(\n                getResumeRegisterId(\n                  hoistedBinding.section,\n                  hoistedBinding,\n                  \"hoist\"\n                )\n              ),\n              callRuntime(\"hoist\", ...accessors)\n            ) : callRuntime(\"hoist\", ...accessors)\n          )\n        ])\n      );\n      if (hoistedBinding.downstreamExpressions.size) {\n        addValue(\n          hoistedBinding.section,\n          void 0,\n          initValue(hoistedBinding),\n          import_compiler20.types.callExpression(hoistIdentifier, [scopeIdentifier])\n        );\n      }\n    }\n  });\n}\nfunction writeRegisteredFns() {\n  const registeredFns = registeredFnsForProgram.get((0, import_babel_utils14.getProgram)().node);\n  const statements = [];\n  if (registeredFns) {\n    for (const registeredFn of registeredFns) {\n      let fn;\n      const params = registeredFn.referencedBindings ? registeredFn.referencesScope ? [\n        scopeIdentifier,\n        import_compiler20.types.assignmentPattern(\n          createScopeReadPattern(\n            registeredFn.section,\n            registeredFn.referencedBindings\n          ),\n          scopeIdentifier\n        )\n      ] : [\n        createScopeReadPattern(\n          registeredFn.section,\n          registeredFn.referencedBindings\n        )\n      ] : registeredFn.referencesScope ? [scopeIdentifier] : void 0;\n      if (params) {\n        fn = import_compiler20.types.functionDeclaration(\n          import_compiler20.types.identifier(registeredFn.id),\n          params,\n          import_compiler20.types.blockStatement(toReturnedFunction(registeredFn.node))\n        );\n      } else if (registeredFn.node.type === \"FunctionDeclaration\" && registeredFn.node.id?.name === registeredFn.id) {\n        fn = registeredFn.node;\n      } else {\n        fn = import_compiler20.types.functionDeclaration(\n          import_compiler20.types.identifier(registeredFn.id),\n          registeredFn.node.params,\n          registeredFn.node.body.type === \"BlockStatement\" ? registeredFn.node.body : import_compiler20.types.blockStatement([import_compiler20.types.returnStatement(registeredFn.node.body)]),\n          registeredFn.node.generator,\n          registeredFn.node.async\n        );\n      }\n      statements.push(fn);\n    }\n    for (const registeredFn of registeredFns) {\n      statements.push(\n        import_compiler20.types.expressionStatement(\n          callRuntime(\n            \"register\",\n            import_compiler20.types.stringLiteral(registeredFn.registerId),\n            import_compiler20.types.identifier(registeredFn.id)\n          )\n        )\n      );\n    }\n    (0, import_babel_utils14.getProgram)().node.body.push(...statements);\n  }\n}\nfunction toReturnedFunction(rawFn) {\n  const fn = simplifyFunction(rawFn);\n  return fn.type === \"FunctionDeclaration\" ? [fn, import_compiler20.types.returnStatement(fn.id)] : [import_compiler20.types.returnStatement(fn)];\n}\nfunction addHTMLEffectCall(section, referencedBindings) {\n  addStatement(\"effect\", section, referencedBindings, void 0, false);\n}\nfunction writeHTMLResumeStatements(path5) {\n  const section = getSectionForBody(path5);\n  if (!section) return;\n  const body = path5.node.body;\n  const allSignals = Array.from(getSignals(section).values());\n  const scopeIdIdentifier = getScopeIdIdentifier(section);\n  forEach(section.referencedClosures, (closure) => {\n    if (closure.sources) {\n      if (isDynamicClosure(section, closure)) {\n        const closureSignal = getSignal(closure.section, closure);\n        let identifier = htmlDynamicClosureInstancesIdentifier.get(closureSignal);\n        if (!identifier) {\n          htmlDynamicClosureInstancesIdentifier.set(\n            closureSignal,\n            identifier = generateUidIdentifier(\n              closureSignal.identifier.name + \"_closures\"\n            )\n          );\n          getHTMLSectionStatements(closure.section).push(\n            import_compiler20.types.variableDeclaration(\"const\", [\n              import_compiler20.types.variableDeclarator(\n                identifier,\n                import_compiler20.types.newExpression(import_compiler20.types.identifier(\"Set\"), [])\n              )\n            ])\n          );\n          setBindingSerializedValue(\n            closure.section,\n            closure,\n            identifier,\n            getAccessorPrefix().ClosureScopes\n          );\n        }\n        setBindingSerializedValue(\n          section,\n          closure,\n          import_compiler20.types.numericLiteral(getDynamicClosureIndex(closure, section)),\n          getAccessorPrefix().ClosureSignalIndex\n        );\n        addWriteScopeBuilder(\n          section,\n          (expr) => callRuntime(\"writeSubscribe\", identifier, expr)\n        );\n      }\n    }\n  });\n  const sectionDynamicSubscribers = /* @__PURE__ */ new Set();\n  forEach(section.hoisted, (binding) => {\n    for (const hoistedBinding of binding.hoists.values()) {\n      if (hoistedBinding.downstreamExpressions.size) {\n        getHTMLSectionStatements(hoistedBinding.section).push(\n          import_compiler20.types.variableDeclaration(\"const\", [\n            import_compiler20.types.variableDeclarator(\n              import_compiler20.types.identifier(hoistedBinding.name),\n              callRuntime(\n                \"hoist\",\n                getScopeIdIdentifier(hoistedBinding.section),\n                import_compiler20.types.stringLiteral(\n                  getResumeRegisterId(\n                    hoistedBinding.section,\n                    hoistedBinding,\n                    \"hoist\"\n                  )\n                )\n              )\n            )\n          ])\n        );\n      }\n      let currentSection = section;\n      while (currentSection && currentSection !== hoistedBinding.section) {\n        const parentSection = currentSection.parent;\n        if (!currentSection.sectionAccessor && !sectionDynamicSubscribers.has(currentSection)) {\n          const subscribersIdentifier = generateUidIdentifier(\n            `${currentSection.name}_subscribers`\n          );\n          sectionDynamicSubscribers.add(currentSection);\n          getHTMLSectionStatements(parentSection).push(\n            import_compiler20.types.variableDeclaration(\"const\", [\n              import_compiler20.types.variableDeclarator(\n                subscribersIdentifier,\n                import_compiler20.types.newExpression(import_compiler20.types.identifier(\"Set\"), [])\n              )\n            ])\n          );\n          addWriteScopeBuilder(\n            currentSection,\n            (expr) => callRuntime(\"writeSubscribe\", subscribersIdentifier, expr)\n          );\n          setSerializedValue(\n            parentSection,\n            getSectionInstancesAccessor(currentSection),\n            subscribersIdentifier\n          );\n        }\n        currentSection = parentSection;\n      }\n    }\n    if (binding.hoists.size && binding.type !== 0 /* dom */) {\n      setBindingSerializedValue(\n        section,\n        binding,\n        getDeclaredBindingExpression(binding)\n      );\n    }\n  });\n  for (let i = allSignals.length; i--; ) {\n    if (allSignals[i].effect.length) {\n      const signalRefs = allSignals[i].referencedBindings;\n      body.push(\n        import_compiler20.types.expressionStatement(\n          callRuntime(\n            \"writeEffect\",\n            scopeIdIdentifier,\n            import_compiler20.types.stringLiteral(getResumeRegisterId(section, signalRefs))\n          )\n        )\n      );\n    }\n  }\n  const serializedLookup = getSerializedAccessors(section);\n  const serializedProperties = [];\n  const sectionSerializeReason = nonAnalyzedForceSerializedSection.has(section) ? true : section.serializeReason;\n  forEach(section.bindings, (binding) => {\n    if (binding.type === 0 /* dom */) return;\n    const reason = getBindingSerializeReason(section, binding);\n    if (!reason) return;\n    const accessor = getScopeAccessor(binding);\n    serializedLookup.delete(accessor);\n    serializedProperties.push(\n      toObjectProperty(\n        accessor,\n        sectionSerializeReason && (sectionSerializeReason === reason || sectionSerializeReason !== true && reason !== true && compareSources(sectionSerializeReason, reason) === 0) ? getDeclaredBindingExpression(binding) : getExprIfSerialized(reason, getDeclaredBindingExpression(binding))\n      )\n    );\n  });\n  if (section.parent) {\n    const ownerAccessor = getAccessorProp().Owner;\n    const ownerReason = getSectionSerializeReason(section, ownerAccessor);\n    if (ownerReason) {\n      const getOwnerExpr = callRuntime(\n        \"ensureScopeWithId\",\n        getScopeIdIdentifier(section.parent)\n      );\n      serializedLookup.delete(ownerAccessor);\n      serializedProperties.push(\n        toObjectProperty(\n          ownerAccessor,\n          sectionSerializeReason && (sectionSerializeReason === ownerReason || sectionSerializeReason !== true && ownerReason !== true && compareSources(sectionSerializeReason, ownerReason) === 0) ? getOwnerExpr : getExprIfSerialized(ownerReason, getOwnerExpr)\n        )\n      );\n    }\n  }\n  for (const [key, { expression, reason }] of serializedLookup) {\n    serializedProperties.push(\n      toObjectProperty(key, getExprIfSerialized(reason, expression))\n    );\n  }\n  const writeScopeBuilder = getSectionWriteScopeBuilder(section);\n  if (sectionSerializeReason) {\n    for (const prop of serializedProperties) {\n      if (prop.key.type === \"Identifier\" && prop.value.type === \"Identifier\" && prop.key.name === prop.value.name) {\n        prop.shorthand = true;\n      }\n    }\n    const writeScopeArgs = [\n      scopeIdIdentifier,\n      import_compiler20.types.objectExpression(serializedProperties)\n    ];\n    if (!isOptimize()) {\n      let debugVars;\n      forEach(section.bindings, (binding) => {\n        if (binding.type === 0 /* dom */) return;\n        const serializeReason = getBindingSerializeReason(section, binding);\n        if (!serializeReason) return;\n        const { root, access } = getDebugScopeAccess(binding);\n        const locExpr = root.loc && import_compiler20.types.stringLiteral(\n          `${root.loc.start.line}:${root.loc.start.column + 1}`\n        );\n        (debugVars ||= []).push(\n          toObjectProperty(\n            getScopeAccessor(binding),\n            root !== binding ? import_compiler20.types.arrayExpression(\n              locExpr ? [import_compiler20.types.stringLiteral(root.name + access), locExpr] : [import_compiler20.types.stringLiteral(root.name + access)]\n            ) : locExpr || import_compiler20.types.numericLiteral(0)\n          )\n        );\n      });\n      writeScopeArgs.push(\n        import_compiler20.types.stringLiteral(path5.hub.file.opts.filenameRelative),\n        section.loc && section.loc.start.line != null ? import_compiler20.types.stringLiteral(\n          `${section.loc.start.line}:${section.loc.start.column + 1}`\n        ) : import_compiler20.types.numericLiteral(0)\n      );\n      if (debugVars) {\n        writeScopeArgs.push(import_compiler20.types.objectExpression(debugVars));\n      }\n    }\n    let writeScopeCall = writeScopeBuilder ? writeScopeBuilder(callRuntime(\"writeScope\", ...writeScopeArgs)) : callRuntime(\"writeScope\", ...writeScopeArgs);\n    if (sectionSerializeReason !== true && !sectionSerializeReason.state) {\n      writeScopeCall = import_compiler20.types.logicalExpression(\n        \"&&\",\n        getSerializeGuard(sectionSerializeReason, false),\n        writeScopeCall\n      );\n    }\n    body.push(import_compiler20.types.expressionStatement(writeScopeCall));\n  }\n  const resumeClosestBranch2 = !section.isBranch && (section.hasAbortSignal || !!section.referencedClosures || !!find(section.bindings, (binding) => binding.type === 1 /* let */));\n  if (resumeClosestBranch2) {\n    body.push(\n      import_compiler20.types.expressionStatement(\n        callRuntime(\"resumeClosestBranch\", scopeIdIdentifier)\n      )\n    );\n  }\n  const additionalStatements = getHTMLSectionStatements(section);\n  if (body.length || additionalStatements.length) {\n    body.unshift(\n      import_compiler20.types.variableDeclaration(\"const\", [\n        import_compiler20.types.variableDeclarator(scopeIdIdentifier, callRuntime(\"nextScopeId\"))\n      ]),\n      ...additionalStatements\n    );\n  }\n  const returnIdentifier = getSectionReturnValueIdentifier(section);\n  if (returnIdentifier !== void 0) {\n    body.push(import_compiler20.types.returnStatement(returnIdentifier));\n  }\n}\nfunction getSetup(section) {\n  return getSignals(section).get(void 0)?.identifier;\n}\nfunction replaceRenderNode(node) {\n  return replaceAssignedNode(node) || replaceBindingReadNode2(node) || replaceRegisteredFunctionNode2(node);\n}\nfunction replaceEffectNode(node) {\n  return replaceAssignedNode(node) || replaceBindingReadNode2(node);\n}\nfunction replaceBindingReadNode2(node) {\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\": {\n      return getReadReplacement(node);\n    }\n  }\n}\nfunction replaceAssignedNode(node) {\n  switch (node.type) {\n    case \"UpdateExpression\": {\n      const { extra } = node.argument;\n      if (isAssignedBindingExtra(extra)) {\n        const { buildAssignment } = getSignal(\n          extra.assignment.section,\n          extra.assignment\n        );\n        if (buildAssignment) {\n          const replacement = buildAssignment(\n            extra.section,\n            import_compiler20.types.binaryExpression(\n              node.operator === \"++\" ? \"+\" : \"-\",\n              node.argument,\n              import_compiler20.types.numericLiteral(1)\n            )\n          );\n          if (!node.prefix) {\n            return import_compiler20.types.sequenceExpression([replacement, node.argument]);\n          }\n          return replacement;\n        }\n      }\n      break;\n    }\n    case \"AssignmentExpression\":\n      switch (node.left.type) {\n        case \"Identifier\": {\n          const { extra } = node.left;\n          if (isAssignedBindingExtra(extra)) {\n            const { buildAssignment } = getSignal(\n              extra.assignment.section,\n              extra.assignment\n            );\n            if (buildAssignment) {\n              return buildAssignment(\n                extra.section,\n                node.operator === \"=\" ? node.right : import_compiler20.types.binaryExpression(\n                  node.operator.slice(\n                    0,\n                    -1\n                  ),\n                  node.left,\n                  node.right\n                )\n              );\n            }\n          }\n          break;\n        }\n        case \"ArrayPattern\":\n        case \"ObjectPattern\": {\n          let params;\n          let assignments;\n          forEachIdentifier(node.left, (id) => {\n            const { extra } = id;\n            if (isAssignedBindingExtra(extra)) {\n              const signal = getSignal(\n                extra.assignment.section,\n                extra.assignment\n              );\n              if (signal?.buildAssignment) {\n                id.name = generateUid(id.name);\n                (params ||= []).push(import_compiler20.types.identifier(id.name));\n                (assignments ||= []).push(\n                  signal.buildAssignment(extra.section, import_compiler20.types.identifier(id.name))\n                );\n              }\n            }\n          });\n          if (params && assignments) {\n            const resultId = generateUid(\"result\");\n            return import_compiler20.types.callExpression(\n              import_compiler20.types.arrowFunctionExpression(\n                [import_compiler20.types.identifier(resultId), ...params],\n                import_compiler20.types.sequenceExpression([\n                  import_compiler20.types.assignmentExpression(\n                    \"=\",\n                    node.left,\n                    import_compiler20.types.identifier(resultId)\n                  ),\n                  ...assignments,\n                  import_compiler20.types.identifier(resultId)\n                ])\n              ),\n              [node.right]\n            );\n          }\n          break;\n        }\n      }\n      break;\n  }\n}\nvar registeredFnsForProgram = /* @__PURE__ */ new WeakMap();\nfunction replaceRegisteredFunctionNode2(node) {\n  switch (node.type) {\n    case \"ClassMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler20.types.classProperty(node.key, replacement);\n    }\n    case \"ClassPrivateMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler20.types.classPrivateProperty(node.key, replacement);\n    }\n    case \"ObjectMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler20.types.objectProperty(node.key, replacement);\n    }\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\": {\n      return getRegisteredFnExpression2(node);\n    }\n    case \"FunctionDeclaration\": {\n      const replacement = getRegisteredFnExpression2(node);\n      if (replacement) {\n        return import_compiler20.types.variableDeclaration(\"const\", [\n          import_compiler20.types.variableDeclarator(node.id, replacement)\n        ]);\n      }\n      break;\n    }\n  }\n}\nfunction getRegisteredFnExpression2(node) {\n  const { extra } = node;\n  if (isRegisteredFnExtra(extra)) {\n    const id = extra.name;\n    const referencesScope = extra.referencesScope;\n    const referencedBindings = extra.referencedBindingsInFunction;\n    let registedFns = registeredFnsForProgram.get((0, import_babel_utils14.getProgram)().node);\n    if (!registedFns) {\n      registeredFnsForProgram.set((0, import_babel_utils14.getProgram)().node, registedFns = []);\n    }\n    registedFns.push({\n      id,\n      node,\n      registerId: extra.registerId,\n      section: extra.section,\n      referencesScope,\n      referencedBindings\n    });\n    if (referencesScope || referencedBindings) {\n      return import_compiler20.types.callExpression(import_compiler20.types.identifier(id), [scopeIdentifier]);\n    } else {\n      return import_compiler20.types.identifier(id);\n    }\n  }\n}\n\n// src/translator/visitors/program/dom.ts\nvar dom_default = {\n  translate: {\n    exit(program) {\n      visit(program);\n      const section = getSectionForBody(program);\n      const { walks, writes, setup } = getSectionMeta(section);\n      const domExports = program.node.extra.domExports;\n      const templateIdentifier = import_compiler21.types.identifier(domExports.template);\n      const walksIdentifier = import_compiler21.types.identifier(domExports.walks);\n      const setupIdentifier = import_compiler21.types.identifier(domExports.setup);\n      const inputBinding = program.node.params[0].extra?.binding;\n      const programInputSignal = inputBinding && bindingHasDownstreamExpressions(inputBinding) ? initValue(inputBinding) : void 0;\n      const styleFile = getStyleFile(program.hub.file);\n      if (styleFile) {\n        (0, import_babel_utils15.importDefault)(program.hub.file, styleFile);\n      }\n      forEachSectionReverse((childSection) => {\n        if (childSection !== section) {\n          const tagParamsSignal = childSection.params && initValue(childSection.params);\n          const { walks: walks2, writes: writes2, setup: setup2 } = getSectionMeta(childSection);\n          const identifier = import_compiler21.types.identifier(childSection.name);\n          const referencedClosures = childSection.referencedClosures ? Array.isArray(childSection.referencedClosures) ? import_compiler21.types.arrowFunctionExpression(\n            [scopeIdentifier],\n            toFirstExpressionOrBlock(\n              toArray(childSection.referencedClosures, (closure) => {\n                const closureSignal = getSignal(childSection, closure);\n                return import_compiler21.types.expressionStatement(\n                  import_compiler21.types.callExpression(\n                    isDynamicClosure(childSection, closure) ? closureSignal.identifier : import_compiler21.types.memberExpression(\n                      closureSignal.identifier,\n                      import_compiler21.types.identifier(getAccessorProp().Owner)\n                    ),\n                    [scopeIdentifier]\n                  )\n                );\n              })\n            )\n          ) : getSignal(childSection, childSection.referencedClosures).identifier : void 0;\n          const renderer = getSectionParentIsOwner(childSection) ? callRuntime(\n            \"createRenderer\",\n            ...replaceNullishAndEmptyFunctionsWith0([\n              writes2,\n              walks2,\n              setup2,\n              tagParamsSignal?.identifier,\n              referencedClosures\n            ])\n          ) : callRuntime(\n            isSerializedSection(childSection) ? \"registerContent\" : \"createContent\",\n            import_compiler21.types.stringLiteral(getResumeRegisterId(childSection, \"renderer\")),\n            ...replaceNullishAndEmptyFunctionsWith0([\n              writes2,\n              walks2,\n              setup2,\n              tagParamsSignal?.identifier,\n              referencedClosures,\n              childSection.hoisted || childSection.isHoistThrough ? getSectionInstancesAccessorLiteral(childSection) : void 0\n            ])\n          );\n          writeSignals(childSection);\n          program.node.body.push(\n            import_compiler21.types.variableDeclaration(\"const\", [\n              import_compiler21.types.variableDeclarator(identifier, renderer)\n            ])\n          );\n        }\n      });\n      writeSignals(section);\n      writeRegisteredFns();\n      if (!setup) {\n        program.node.body.unshift(\n          import_compiler21.types.exportNamedDeclaration(\n            import_compiler21.types.variableDeclaration(\"const\", [\n              import_compiler21.types.variableDeclarator(\n                setupIdentifier,\n                import_compiler21.types.arrowFunctionExpression([], import_compiler21.types.blockStatement([]))\n              )\n            ])\n          )\n        );\n      }\n      program.node.body.unshift(\n        import_compiler21.types.exportNamedDeclaration(\n          import_compiler21.types.variableDeclaration(\"const\", [\n            import_compiler21.types.variableDeclarator(\n              templateIdentifier,\n              writes || import_compiler21.types.stringLiteral(\"\")\n            )\n          ])\n        ),\n        import_compiler21.types.exportNamedDeclaration(\n          import_compiler21.types.variableDeclaration(\"const\", [\n            import_compiler21.types.variableDeclarator(walksIdentifier, walks || import_compiler21.types.stringLiteral(\"\"))\n          ])\n        )\n      );\n      program.node.body.push(\n        import_compiler21.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            import_compiler21.types.stringLiteral(program.hub.file.metadata.marko.id),\n            templateIdentifier,\n            walksIdentifier,\n            setupIdentifier,\n            programInputSignal?.identifier\n          )\n        )\n      );\n    }\n  }\n};\n\n// src/translator/visitors/program/index.ts\nvar cleanIdentifier;\nvar scopeIdentifier;\nfunction isScopeIdentifier(node) {\n  return node === scopeIdentifier;\n}\nvar program_default = {\n  migrate: {\n    enter(program) {\n      program.node.params = [import_compiler22.types.identifier(\"input\")];\n    },\n    exit(program) {\n      program.scope.crawl();\n    }\n  },\n  analyze: {\n    enter(program) {\n      startSection(program);\n      trackParamsReferences(program, 2 /* input */);\n      const programExtra = program.node.extra ??= {};\n      const inputBinding = program.node.params[0].extra?.binding;\n      if (inputBinding) {\n        inputBinding.nullable = false;\n      }\n      programExtra.domExports = {\n        template: generateUid(\"template\"),\n        walks: generateUid(\"walks\"),\n        setup: generateUid(\"setup\"),\n        input: void 0\n        // TODO look into recursive components with fine grained params.\n      };\n      for (const child of program.get(\"body\")) {\n        if (isCoreTagName(child, \"return\")) {\n          const { value } = getKnownAttrValues(child.node);\n          if (value) {\n            programExtra.returnValueExpr = value.extra ??= {};\n          }\n          break;\n        }\n      }\n    },\n    exit(program) {\n      finalizeReferences();\n      const programExtra = program.node.extra;\n      const inputBinding = program.node.params[0].extra?.binding;\n      if (inputBinding && bindingHasDownstreamExpressions(inputBinding)) {\n        programExtra.domExports.input = buildTemplateExports(\n          inputBinding,\n          program\n        );\n      }\n    }\n  },\n  translate: {\n    enter(program) {\n      scopeIdentifier = isOutputDOM() ? generateUidIdentifier(\"scope\") : null;\n      cleanIdentifier = isOutputDOM() ? generateUidIdentifier(\"clean\") : null;\n      if (getMarkoOpts().output === \"hydrate\") {\n        const entryFile = program.hub.file;\n        const visitedFiles = /* @__PURE__ */ new Set([\n          (0, import_babel_utils16.resolveRelativePath)(entryFile, entryFile.opts.filename)\n        ]);\n        entry_builder_default.visit(entryFile, entryFile, function visitChild(resolved) {\n          if (!visitedFiles.has(resolved)) {\n            visitedFiles.add(resolved);\n            const file = (0, import_babel_utils16.loadFileForImport)(entryFile, resolved);\n            if (file) {\n              entry_builder_default.visit(\n                file,\n                entryFile,\n                (id) => visitChild(resolveRelativeToEntry(entryFile, file, id))\n              );\n            }\n          }\n        });\n        program.node.body = entry_builder_default.build(entryFile);\n        program.skip();\n        return;\n      }\n    },\n    exit(program) {\n      if (isOutputHTML()) {\n        html_default.translate.exit(program);\n      } else {\n        dom_default.translate.exit(program);\n      }\n      if (program.node.extra?.needsCompat) {\n        const compatFile = getCompatRuntimeFile();\n        const body = [void 0];\n        for (const child of program.node.body) {\n          if (child.type === \"ImportDeclaration\" && child.source.value === compatFile) {\n            body[0] = child;\n          } else {\n            body.push(child);\n          }\n        }\n        body[0] ??= import_compiler22.types.importDeclaration([], import_compiler22.types.stringLiteral(compatFile));\n        program.node.body = body;\n      }\n    }\n  }\n};\nfunction resolveSerializeReasonId(inputSerializeReasons, reason) {\n  const id = findIndexSorted(compareReferences, inputSerializeReasons, reason);\n  if (id === -1) {\n    throw new Error(\"Unable to resolve serialize reason against input\");\n  }\n  return id;\n}\nfunction resolveRelativeToEntry(entryFile, file, req) {\n  return file === entryFile ? (0, import_babel_utils16.resolveRelativePath)(file, req) : (0, import_babel_utils16.resolveRelativePath)(\n    entryFile,\n    req[0] === \".\" ? import_path2.default.join(file.opts.filename, \"..\", req) : req\n  );\n}\nfunction buildTemplateExports(binding, program) {\n  const templateExport = {\n    id: binding.export ??= generateUid(binding.name),\n    binding,\n    props: void 0\n  };\n  if (!(binding.aliases.size || binding.downstreamExpressions.size)) {\n    templateExport.props = {};\n    for (const [property, alias] of binding.propertyAliases) {\n      templateExport.props[property] = buildTemplateExports(alias, program);\n    }\n  }\n  return templateExport;\n}\n\n// src/translator/util/scope-read.ts\nfunction createScopeReadPattern(section, referencedBindings) {\n  const rootDepth = section.depth;\n  const rootPattern = import_compiler23.types.objectPattern([]);\n  let nestedPatterns;\n  forEach(referencedBindings, (ref) => {\n    const propertyValue = ref.name;\n    if (!isValidPropertyIdentifier(propertyValue)) return;\n    const propertyKey = getScopeAccessor(ref);\n    const isShorthand = propertyKey === propertyValue;\n    let pattern = rootPattern;\n    if (ref.section !== section) {\n      if (!nestedPatterns) nestedPatterns = [rootPattern];\n      const relativeDepth = rootDepth - ref.section.depth;\n      let i = nestedPatterns.length;\n      let prev = nestedPatterns[i - 1];\n      for (; i <= relativeDepth; i++) {\n        const nestedPattern = import_compiler23.types.objectPattern([]);\n        prev.properties.push(\n          import_compiler23.types.objectProperty(\n            import_compiler23.types.identifier(getAccessorProp().Owner),\n            nestedPattern\n          )\n        );\n        nestedPatterns.push(nestedPattern);\n        prev = nestedPattern;\n      }\n      pattern = nestedPatterns[relativeDepth];\n    }\n    pattern.properties.push(\n      import_compiler23.types.objectProperty(\n        toPropertyName(propertyKey),\n        import_compiler23.types.identifier(propertyValue),\n        false,\n        isShorthand\n      )\n    );\n  });\n  return rootPattern;\n}\nfunction getScopeExpression(section, targetSection) {\n  let scope = scopeIdentifier ?? import_compiler23.types.identifier(\"undefined\");\n  const diff = section.depth - targetSection.depth;\n  for (let i = 0; i < diff; i++) {\n    scope = import_compiler23.types.memberExpression(scope, import_compiler23.types.identifier(getAccessorProp().Owner));\n  }\n  if (diff < 0) {\n    throw new Error(\"Unable to find scope for reference.\");\n  }\n  return scope;\n}\nfunction createScopeReadExpression(section, reference) {\n  const propName = toPropertyName(getScopeAccessor(reference));\n  return import_compiler23.types.memberExpression(\n    getScopeExpression(section, reference.section),\n    propName,\n    propName.type !== \"Identifier\"\n  );\n}\n\n// src/translator/util/with-previous-location.ts\nfunction withPreviousLocation(newNode, originalNode) {\n  newNode.start = originalNode.start;\n  newNode.loc = originalNode.loc;\n  newNode.end = originalNode.end;\n  return newNode;\n}\n\n// src/translator/util/references.ts\nvar kIsInvoked = Symbol(\"hoist is invoked\");\nvar kBranchSerializeReason = Symbol(\"branch serialize reason\");\nvar [getBindings] = createProgramState(() => /* @__PURE__ */ new Set());\nvar [getNextBindingId, setNextBindingId] = createProgramState(() => 0);\nfunction createBinding(name2, type, section, upstreamAlias, property, loc = null, declared = false) {\n  const id = getNextBindingId();\n  const binding = {\n    id,\n    name: name2,\n    type,\n    loc,\n    section,\n    property,\n    declared,\n    closureSections: void 0,\n    assignmentSections: void 0,\n    excludeProperties: void 0,\n    sources: void 0,\n    aliases: /* @__PURE__ */ new Set(),\n    hoists: /* @__PURE__ */ new Map(),\n    propertyAliases: /* @__PURE__ */ new Map(),\n    upstreamAlias,\n    downstreamExpressions: /* @__PURE__ */ new Set(),\n    scopeOffset: void 0,\n    export: void 0,\n    nullable: true\n  };\n  if (property) {\n    if (declared) upstreamAlias.nullable = false;\n    const propBinding = upstreamAlias.propertyAliases.get(property);\n    if (propBinding) {\n      binding.property = void 0;\n      binding.upstreamAlias = propBinding;\n      propBinding.aliases.add(binding);\n    } else {\n      upstreamAlias.propertyAliases.set(property, binding);\n    }\n  } else if (upstreamAlias) {\n    upstreamAlias.aliases.add(binding);\n  }\n  setNextBindingId(id + 1);\n  getBindings().add(binding);\n  return binding;\n}\nfunction trackVarReferences(tag, type, upstreamAlias) {\n  const tagVar = tag.node.var;\n  if (tagVar) {\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    if (canonicalUpstreamAlias) {\n      createBindingsAndTrackReferences(\n        tagVar,\n        canonicalUpstreamAlias.type,\n        tag.scope,\n        canonicalUpstreamAlias.section,\n        canonicalUpstreamAlias,\n        void 0\n      );\n      return canonicalUpstreamAlias;\n    }\n    createBindingsAndTrackReferences(\n      tagVar,\n      type,\n      tag.scope,\n      getOrCreateSection(tag),\n      void 0,\n      void 0\n    );\n    return tagVar.extra?.binding;\n  }\n}\nfunction trackParamsReferences(body, type, upstreamAlias) {\n  const params = body.node.params;\n  if (body.node.body.length && params.length) {\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    let section;\n    if (canonicalUpstreamAlias) {\n      section = canonicalUpstreamAlias.section;\n      type = canonicalUpstreamAlias.type;\n    } else {\n      section = getOrCreateSection(body);\n    }\n    const paramsBinding = canonicalUpstreamAlias || ((body.node.extra ??= {}).binding = createBinding(\n      generateUid(\"params\"),\n      type,\n      section,\n      void 0,\n      void 0\n    ));\n    section.params = paramsBinding;\n    for (let i = 0; i < params.length; i++) {\n      createBindingsAndTrackReferences(\n        params[i],\n        type,\n        body.scope,\n        section,\n        paramsBinding,\n        i + \"\"\n      );\n    }\n    return paramsBinding;\n  }\n}\nfunction trackHoistedReference(referencePath, binding) {\n  const section = binding.section;\n  const referenceSection = getOrCreateSection(referencePath);\n  const hoistSection = getCommonSection(referenceSection, section);\n  const extra = referencePath.node.extra ??= {};\n  let hoistedBinding = binding.hoists.get(hoistSection);\n  if (!hoistedBinding) {\n    binding.hoists.set(\n      hoistSection,\n      hoistedBinding = createBinding(\n        generateUid(\"hoisted_\" + referencePath.node.name),\n        5 /* hoist */,\n        hoistSection,\n        void 0,\n        void 0,\n        binding.loc,\n        true\n      )\n    );\n    section.hoisted = bindingUtil.add(section.hoisted, binding);\n    let currentSection = section.parent;\n    while (currentSection && currentSection !== hoistSection) {\n      currentSection.isHoistThrough = true;\n      currentSection = currentSection.parent;\n    }\n  }\n  if (isInvokedFunction(referencePath)) {\n    extra.read = createRead(hoistedBinding, void 0);\n    extra.section = referenceSection;\n    extra[kIsInvoked] = true;\n  } else {\n    trackReference(referencePath, hoistedBinding);\n  }\n  referenceSection.referencedHoists = bindingUtil.add(\n    referenceSection.referencedHoists,\n    hoistedBinding\n  );\n}\nfunction trackReferencesForBinding(babelBinding, binding) {\n  const { referencePaths, constantViolations } = babelBinding;\n  for (const referencePath of referencePaths) {\n    const referenceSection = getOrCreateSection(referencePath);\n    if (isSameOrChildSection(binding.section, referenceSection)) {\n      trackReference(referencePath, binding);\n    } else {\n      trackHoistedReference(referencePath, binding);\n    }\n  }\n  for (const ref of constantViolations) {\n    if (ref.isUpdateExpression()) {\n      trackAssignment(ref.get(\"argument\"), binding);\n    } else if (ref.isAssignmentExpression()) {\n      trackAssignment(ref.get(\"left\"), binding);\n      if (ref.node.operator !== \"=\") {\n        const left = ref.get(\"left\");\n        if (left.isIdentifier()) {\n          trackReference(left, binding);\n        }\n      }\n    }\n  }\n}\nfunction trackAssignment(assignment, binding) {\n  const section = getOrCreateSection(assignment);\n  setReferencesScope(assignment);\n  forEachIdentifier(assignment.node, (id) => {\n    if (id.name === binding.name) {\n      const extra = id.extra ??= {};\n      binding.assignmentSections = sectionUtil.add(\n        binding.assignmentSections,\n        section\n      );\n      extra.assignment = binding;\n      extra.section = section;\n    }\n  });\n}\nfunction setReferencesScope(path5) {\n  const fnRoot = getFnRoot(path5);\n  if (fnRoot) {\n    (fnRoot.node.extra ??= {}).referencesScope = true;\n  }\n}\nfunction createBindingsAndTrackReferences(lVal, type, scope, section, upstreamAlias, property) {\n  switch (lVal.type) {\n    case \"Identifier\":\n      trackReferencesForBinding(\n        scope.getBinding(lVal.name),\n        (lVal.extra ??= {}).binding = createBinding(\n          lVal.name,\n          type,\n          section,\n          upstreamAlias,\n          property,\n          lVal.loc,\n          true\n        )\n      );\n      break;\n    case \"ObjectPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        generateUid(property || \"pattern\"),\n        type,\n        section,\n        upstreamAlias,\n        property,\n        lVal.loc\n      ));\n      for (const prop of lVal.properties) {\n        if (prop.type === \"RestElement\") {\n          createBindingsAndTrackReferences(\n            prop.argument,\n            type,\n            scope,\n            section,\n            patternBinding,\n            property\n          );\n        } else {\n          let key;\n          if (prop.key.type === \"Identifier\") {\n            key = prop.key.name;\n          } else if (prop.key.type === \"StringLiteral\") {\n            key = prop.key.value;\n          } else {\n            throw new Error(\"computed keys not supported in object pattern\");\n          }\n          createBindingsAndTrackReferences(\n            prop.value,\n            type,\n            scope,\n            section,\n            patternBinding,\n            key\n          );\n        }\n      }\n      break;\n    }\n    case \"ArrayPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        generateUid(property || \"pattern\"),\n        type,\n        section,\n        upstreamAlias,\n        property,\n        lVal.loc\n      ));\n      let i = -1;\n      for (const element of lVal.elements) {\n        i++;\n        if (element) {\n          if (element.type === \"RestElement\") {\n            createBindingsAndTrackReferences(\n              element.argument,\n              type,\n              scope,\n              section,\n              patternBinding,\n              property\n            );\n          } else {\n            createBindingsAndTrackReferences(\n              element,\n              type,\n              scope,\n              section,\n              patternBinding,\n              `${i}`\n            );\n          }\n        }\n      }\n      break;\n    }\n    case \"AssignmentPattern\":\n      createBindingsAndTrackReferences(\n        lVal.left,\n        type,\n        scope,\n        section,\n        upstreamAlias,\n        property\n      );\n      break;\n  }\n}\nfunction trackReference(referencePath, binding) {\n  let root = referencePath;\n  let reference = binding;\n  let propPath = binding.name;\n  while (true) {\n    const { parent } = root;\n    if (!import_compiler24.types.isMemberExpression(parent)) break;\n    const prop = getMemberExpressionPropString(parent);\n    if (prop === void 0) break;\n    if (reference.propertyAliases.has(prop)) {\n      root = root.parentPath;\n      reference = reference.propertyAliases.get(prop);\n      propPath = reference.name;\n      continue;\n    }\n    if (isInvokedFunction(root.parentPath) && !isEventOrChangeHandler(prop)) {\n      break;\n    }\n    root = root.parentPath;\n    reference = createBinding(\n      propPath += `_${prop.replace(/[^a-zA-Z0-9_$]/g, \"_\")}`,\n      reference.type,\n      reference.section,\n      reference,\n      prop\n    );\n  }\n  const fnRoot = getFnRoot(root);\n  const exprRoot = getExprRoot(fnRoot || root);\n  const { section } = addReadToExpression(exprRoot, reference, root.node);\n  if (fnRoot) {\n    const readsByFn = getReadsByFunction();\n    const fnExtra = fnRoot.node.extra ??= {};\n    fnExtra.section = section;\n    readsByFn.set(\n      fnExtra,\n      push(readsByFn.get(fnExtra), {\n        binding: reference,\n        node: root.node\n      })\n    );\n  }\n}\nvar [getMergedReferences] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction mergeReferences(section, target, nodes) {\n  const targetExtra = target.extra ??= {};\n  targetExtra.section = section;\n  getMergedReferences().set(target, nodes);\n  return targetExtra;\n}\nfunction compareReferences(a, b) {\n  return a === b ? 0 : a ? b ? Array.isArray(a) ? Array.isArray(b) ? compareIntersections(a, b) : -1 : Array.isArray(b) ? 1 : bindingUtil.compare(a, b) : 1 : b ? -1 : 0;\n}\nfunction compareIntersections(a, b) {\n  const len = a.length;\n  const lenDelta = len - b.length;\n  if (lenDelta !== 0) {\n    return lenDelta;\n  }\n  for (let i = 0; i < len; i++) {\n    const compareResult = bindingUtil.compare(a[i], b[i]);\n    if (compareResult !== 0) {\n      return compareResult;\n    }\n  }\n  return 0;\n}\nfunction finalizeReferences() {\n  const bindings = getBindings();\n  const readsByExpression = getReadsByExpression();\n  const readsByFn = getReadsByFunction();\n  const mergedReferences = getMergedReferences();\n  if (mergedReferences.size) {\n    for (const [target, nodes] of mergedReferences) {\n      const targetExtra = target.extra;\n      let reads = readsByExpression.get(targetExtra);\n      let { isEffect } = targetExtra;\n      for (const node of nodes) {\n        const extra = node?.extra;\n        if (isReferencedExtra(extra)) {\n          isEffect ||= extra.isEffect;\n          const additionalReads = readsByExpression.get(extra);\n          if (additionalReads) {\n            reads = concat(reads, additionalReads);\n            readsByExpression.delete(extra);\n          }\n        }\n      }\n      readsByExpression.set(targetExtra, reads);\n      targetExtra.isEffect = isEffect;\n    }\n  }\n  const intersectionsBySection = /* @__PURE__ */ new Map();\n  for (const [expr, reads] of readsByExpression) {\n    if (isReferencedExtra(expr)) {\n      expr.referencedBindings = resolveReferencedBindings(\n        expr,\n        reads,\n        intersectionsBySection\n      );\n      forEach(expr.referencedBindings, (binding) => {\n        binding.downstreamExpressions.add(expr);\n      });\n    }\n  }\n  for (const [fn, reads] of readsByFn) {\n    fn.referencedBindingsInFunction = resolveReferencedBindings(\n      fn,\n      reads,\n      intersectionsBySection\n    );\n    forEach(\n      fn.referencedBindingsInFunction,\n      (binding) => forceBindingSerialize(binding.section, binding)\n    );\n  }\n  for (const binding of bindings) {\n    if (binding.type !== 0 /* dom */ && !binding.upstreamAlias) {\n      pruneBinding(bindings, binding);\n    }\n  }\n  for (const binding of bindings) {\n    const { name: name2, section } = binding;\n    if (binding.type !== 0 /* dom */) {\n      resolveBindingSources(binding);\n      if (binding.hoists.size) {\n        forceBindingSerialize(binding.section, binding);\n      }\n      forEach(\n        binding.assignmentSections,\n        (assignedSection) => forceOwnersSerialize(assignedSection, section, getAccessorProp().Owner)\n      );\n      if (find(section.bindings, ({ name: name3 }) => name3 === binding.name)) {\n        binding.name = generateUid(name2);\n      }\n    }\n    section.bindings = bindingUtil.add(section.bindings, binding);\n    for (const {\n      referencedBindings,\n      isEffect,\n      section: section2\n    } of binding.downstreamExpressions) {\n      if (section2 !== binding.section) {\n        const canonicalUpstreamAlias = getCanonicalBinding(binding);\n        canonicalUpstreamAlias.closureSections = sectionUtil.add(\n          canonicalUpstreamAlias.closureSections,\n          section2\n        );\n        section2.referencedClosures = bindingUtil.add(\n          section2.referencedClosures,\n          binding\n        );\n        addOwnersSerializeReason(\n          section2,\n          canonicalUpstreamAlias.section,\n          !!isEffect || canonicalUpstreamAlias.sources,\n          getAccessorProp().Owner\n        );\n      }\n      if (isEffect) {\n        forEach(\n          referencedBindings,\n          (binding2) => forceBindingSerialize(binding2.section, binding2)\n        );\n      }\n    }\n  }\n  forEachSection((section) => {\n    if (section.isHoistThrough) {\n      forceSectionSerialize(section);\n    }\n    forEach(section.referencedHoists, (hoistedBinding) => {\n      forceOwnersSerialize(\n        section,\n        hoistedBinding.section,\n        getAccessorProp().Owner\n      );\n    });\n    if (section.parent && section.isBranch && section.sectionAccessor && section.upstreamExpression) {\n      addSectionSerializeReasonRef(\n        section,\n        !!(section.isHoistThrough || section.hoisted) || getDirectClosures(section),\n        kBranchSerializeReason\n      );\n      addSectionSerializeReasonExpr(\n        section,\n        section.upstreamExpression,\n        kBranchSerializeReason\n      );\n      addBindingSerializeReasonExpr(\n        section.parent,\n        section.sectionAccessor.binding,\n        section.upstreamExpression\n      );\n    }\n  });\n  forEachSection(applySerializeReasonExprs);\n  forEachSection((section) => {\n    const intersections = intersectionsBySection.get(section);\n    if (intersections) {\n      for (const intersection of intersections) {\n        const numReferences = intersection.length;\n        for (let i = 0; i < numReferences - 1; i++) {\n          for (let j = i + 1; j < numReferences; j++) {\n            const binding1 = intersection[i];\n            const binding2 = intersection[j];\n            if (!isBindingForceSerialized(section, binding1) && !isSupersetSources(binding1, binding2)) {\n              if (!isSameOrChildSection(section, binding1.section)) {\n                addOwnersSerializeReason(\n                  section,\n                  binding1.section,\n                  mergeSerializeReasons(\n                    // TODO should check for an actual intersection, not just stateful\n                    binding1.sources,\n                    binding2.sources\n                  ),\n                  getAccessorProp().Owner\n                );\n              }\n              addBindingSerializeReason(\n                binding1.section,\n                binding1,\n                binding2.sources\n                // TODO should check for an actual intersection, not just binding2.sources stateful\n              );\n            }\n            if (!isBindingForceSerialized(section, binding2) && !isSupersetSources(binding2, binding1)) {\n              if (!isSameOrChildSection(section, binding2.section)) {\n                addOwnersSerializeReason(\n                  section,\n                  binding2.section,\n                  mergeSerializeReasons(\n                    // TODO should check for an actual intersection, not just stateful\n                    binding1.sources,\n                    binding2.sources\n                  ),\n                  getAccessorProp().Owner\n                );\n              }\n              addBindingSerializeReason(\n                binding2.section,\n                binding2,\n                binding1.sources\n                // TODO should check for an actual intersection, not just binding1.sources stateful\n              );\n            }\n          }\n        }\n      }\n    }\n    forEach(section.referencedClosures, (closure) => {\n      if (!isBindingForceSerialized(closure.section, closure)) {\n        const sourceSection = closure.section;\n        let serializeReason;\n        let currentSection = section;\n        while (currentSection !== sourceSection) {\n          const upstreamReason = !currentSection.upstreamExpression || getSerializeSourcesForExpr(currentSection.upstreamExpression);\n          if (upstreamReason === true) {\n            serializeReason = true;\n            break;\n          }\n          serializeReason = mergeSerializeReasons(\n            serializeReason,\n            upstreamReason\n          );\n          currentSection = currentSection.parent;\n        }\n        addBindingSerializeReason(closure.section, closure, serializeReason);\n      }\n      if (closure.sources) {\n        addSectionSerializeReason(\n          closure.section,\n          getBindingSerializeReason(closure.section, closure)\n        );\n      }\n      if (closure.sources && isDynamicClosure(section, closure)) {\n        addBindingSerializeReason(\n          closure.section,\n          closure,\n          closure.sources,\n          getAccessorPrefix().ClosureScopes\n        );\n        addBindingSerializeReason(\n          section,\n          closure,\n          closure.sources,\n          getAccessorPrefix().ClosureSignalIndex\n        );\n      }\n    });\n  });\n  let inputSerializeReasons;\n  forEachSection((section) => {\n    finalizeSectionSerializeReasons(section);\n    if (section.serializeReason && section.serializeReason !== true && section.serializeReason.input) {\n      inputSerializeReasons = inputSerializeReasons ? addSorted(\n        compareReferences,\n        inputSerializeReasons,\n        section.serializeReason.input\n      ) : [section.serializeReason.input];\n    }\n    for (const [, reason] of section.serializeReasons) {\n      if (reason !== true && reason.input) {\n        inputSerializeReasons = inputSerializeReasons ? addSorted(compareReferences, inputSerializeReasons, reason.input) : [reason.input];\n      }\n    }\n  });\n  const programExtra = (0, import_babel_utils17.getProgram)().node.extra;\n  if (programExtra.returnValueExpr) {\n    const returnSources = getSerializeSourcesForExpr(\n      programExtra.returnValueExpr\n    );\n    if (returnSources) {\n      programExtra.returnSerializeReason = returnSources.state ? true : returnSources.input;\n    }\n  }\n  programExtra.inputSerializeReasons = inputSerializeReasons;\n  forEachSection((section) => {\n    let intersectionIndex = 0;\n    const intersections = intersectionsBySection.get(section) || [];\n    const { id, bindings: bindings2 } = section;\n    const isOwnedBinding = ({ section: section2 }) => section2.id === id;\n    let lastBindingIndex = 0;\n    let intersection;\n    forEach(filter(bindings2, isOwnedBinding), (binding, bindingIndex) => {\n      binding.id = (lastBindingIndex = bindingIndex) + intersectionIndex;\n      while (intersectionIndex < intersections.length && (intersection = intersections[intersectionIndex]).filter(isOwnedBinding).at(-1) === binding) {\n        intersectionMeta.set(intersection, {\n          id: bindingIndex + ++intersectionIndex,\n          scopeOffset: getMaxOwnSourceOffset(intersection, section)\n        });\n      }\n    });\n    while (intersectionIndex < intersections.length) {\n      intersection = intersections[intersectionIndex];\n      intersectionMeta.set(intersection, {\n        id: lastBindingIndex + ++intersectionIndex,\n        scopeOffset: getMaxOwnSourceOffset(intersection, section)\n      });\n    }\n  });\n  mergedReferences.clear();\n  readsByExpression.clear();\n  readsByFn.clear();\n}\nfunction getMaxOwnSourceOffset(intersection, section) {\n  let scopeOffset;\n  for (const binding of intersection) {\n    if (binding.section === section && binding.sources) {\n      const trackScopeOffset = (source) => {\n        if (source.scopeOffset && (!scopeOffset || scopeOffset.id < source.scopeOffset.id)) {\n          scopeOffset = source.scopeOffset;\n        }\n      };\n      forEach(binding.sources.state, trackScopeOffset);\n      forEach(binding.sources.input, trackScopeOffset);\n    }\n  }\n  return scopeOffset;\n}\nvar intersectionMeta = /* @__PURE__ */ new WeakMap();\nfunction setBindingValueExpr(binding, valueExpr) {\n  bindingValueExprs.set(binding, valueExpr || false);\n}\nvar resolvedSources = /* @__PURE__ */ new WeakSet();\nvar bindingValueExprs = /* @__PURE__ */ new WeakMap();\nfunction resolveBindingSources(binding) {\n  if (resolvedSources.has(binding)) return;\n  resolvedSources.add(binding);\n  switch (binding.type) {\n    case 1 /* let */:\n      binding.sources = createSources(binding, void 0);\n      return;\n    case 2 /* input */:\n      binding.sources = createSources(void 0, binding);\n      return;\n  }\n  if (binding.upstreamAlias) {\n    let alias;\n    let source = binding;\n    while (alias = source.upstreamAlias) {\n      source = alias;\n    }\n    if (!resolvedSources.has(source)) {\n      resolvedSources.add(source);\n      resolveDerivedSources(source);\n    }\n    binding.sources = source.sources;\n  } else {\n    resolveDerivedSources(binding);\n  }\n}\nfunction resolveDerivedSources(binding) {\n  const exprs = bindingValueExprs.get(binding);\n  bindingValueExprs.delete(binding);\n  if (exprs === void 0 || exprs === true) {\n    binding.sources = createSources(binding, void 0);\n  } else if (exprs) {\n    const seen = /* @__PURE__ */ new Set();\n    forEach(exprs, (expr) => {\n      if (isReferencedExtra(expr)) {\n        forEach(expr.referencedBindings, (ref) => {\n          if (!seen.has(ref)) {\n            seen.add(ref);\n            resolveBindingSources(ref);\n            binding.sources = mergeSources(binding.sources, ref.sources);\n          }\n        });\n      }\n    });\n  }\n}\nfunction createSources(state, input) {\n  if (!(state || input)) {\n    throw new Error(\n      \"Cannot create a serialize reason that does not reference state or input.\"\n    );\n  }\n  return { state, input };\n}\nfunction compareSources(a, b) {\n  let delta = 0;\n  if (a.input) {\n    if (!b.input) return 1;\n    if (delta = compareReferences(a.input, b.input)) return delta;\n  } else if (b.input) {\n    return -1;\n  }\n  if (a.state) {\n    if (!b.state) return 1;\n    if (delta = compareReferences(a.state, b.state)) return delta;\n  } else if (b.state) {\n    return -1;\n  }\n  return 0;\n}\nfunction mergeSources(a, b) {\n  if (!a) return b;\n  if (!b) return a;\n  if (a.state === b.state && a.input === b.input) return a;\n  return createSources(\n    bindingUtil.union(a.state, b.state),\n    bindingUtil.union(a.input, b.input)\n  );\n}\nvar bindingUtil = new Sorted(function compareBindings(a, b) {\n  return a === b ? 0 : a.section.id - b.section.id || a.type !== b.type && (a.type === 0 /* dom */ || b.type === 0 /* dom */) ? a.type - b.type || a.id - b.id : a.id - b.id;\n});\nvar [getReadsByExpression] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nvar [getReadsByFunction] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction addReadToExpression(path5, binding, node) {\n  const exprExtra = path5.node.extra ??= {};\n  const readsByExpression = getReadsByExpression();\n  exprExtra.section = getOrCreateSection(path5);\n  readsByExpression.set(\n    exprExtra,\n    push(readsByExpression.get(exprExtra), { binding, node })\n  );\n  return exprExtra;\n}\nfunction dropReferences(node) {\n  if (Array.isArray(node)) {\n    for (const item of node) {\n      (item.extra ??= {}).pruned = true;\n    }\n  } else {\n    (node.extra ??= {}).pruned = true;\n  }\n}\nfunction getCanonicalBinding(binding) {\n  return binding && (binding.property ? binding : binding.upstreamAlias || binding);\n}\nfunction getAllTagReferenceNodes(tag, referenceNodes = []) {\n  if (tag.arguments) {\n    for (const arg of tag.arguments) {\n      referenceNodes.push(arg);\n    }\n  }\n  for (const attr2 of tag.attributes) {\n    referenceNodes.push(attr2.value);\n  }\n  for (const child of tag.body.attributeTags ? tag.body.body : tag.attributeTags) {\n    switch (child.type) {\n      case \"MarkoTag\":\n        getAllTagReferenceNodes(child, referenceNodes);\n        break;\n      case \"MarkoScriptlet\":\n        for (const statement of child.body) {\n          referenceNodes.push(statement);\n        }\n        break;\n    }\n  }\n  return referenceNodes;\n}\nfunction getScopeAccessorLiteral(binding, includeId) {\n  const canonicalBinding = getCanonicalBinding(binding);\n  if (isOptimize()) {\n    return import_compiler24.types.numericLiteral(canonicalBinding.id);\n  }\n  return import_compiler24.types.stringLiteral(\n    canonicalBinding.name + (includeId || canonicalBinding.type === 0 /* dom */ ? `/${canonicalBinding.id}` : \"\")\n  );\n}\nfunction getScopeAccessor(binding, includeId) {\n  const canonicalBinding = getCanonicalBinding(binding);\n  if (isOptimize()) {\n    return canonicalBinding.id + \"\";\n  }\n  return canonicalBinding.name + (includeId || canonicalBinding.type === 0 /* dom */ ? `/${canonicalBinding.id}` : \"\");\n}\nfunction getDebugScopeAccess(binding) {\n  let root = binding;\n  let access = \"\";\n  while (!(root.loc || root.declared) && root.upstreamAlias) {\n    if (root.property !== void 0) {\n      access = toAccess(root.property) + access;\n    }\n    root = root.upstreamAlias;\n  }\n  return {\n    root,\n    access\n  };\n}\nfunction getDebugName(binding) {\n  const { root, access } = getDebugScopeAccess(binding);\n  return root.name + access;\n}\nfunction getInputDebugName(binding) {\n  let root = binding;\n  let access = \"\";\n  while (root.upstreamAlias !== root.section.params) {\n    if (root.property !== void 0) {\n      access = toAccess(root.property) + access;\n    }\n    root = root.upstreamAlias;\n  }\n  return root.name + access;\n}\nfunction getSectionInstancesAccessor(section) {\n  return section.sectionAccessor ? section.sectionAccessor.prefix + getScopeAccessor(section.sectionAccessor.binding) : getAccessorPrefix().ClosureScopes + section.id;\n}\nfunction getSectionInstancesAccessorLiteral(section) {\n  const accessor = getSectionInstancesAccessor(section);\n  return accessor ? typeof accessor === \"number\" ? import_compiler24.types.numericLiteral(accessor) : import_compiler24.types.stringLiteral(accessor) : void 0;\n}\nfunction getReadReplacement(node) {\n  const { extra } = node;\n  if (!extra) return;\n  let { binding, read } = extra;\n  let replacement;\n  if (read) {\n    if (read.props === void 0) {\n      binding = read.binding;\n      read = void 0;\n    } else {\n      binding = void 0;\n    }\n  }\n  if (binding) {\n    if (node.type === \"Identifier\") {\n      if (binding.type === 5 /* hoist */) {\n        replacement = node.extra?.[kIsInvoked] ? import_compiler24.types.callExpression(getHoistFunctionIdentifier(binding), [\n          getScopeExpression(node.extra.section, binding.section)\n        ]) : import_compiler24.types.identifier(getScopeAccessor(binding));\n      } else if (binding.name !== node.name) {\n        node.name = binding.name;\n      }\n    } else {\n      replacement = import_compiler24.types.identifier(binding.name);\n    }\n  } else if (read) {\n    replacement = toMemberExpression(\n      import_compiler24.types.identifier(read.binding.name),\n      Array.isArray(read.props) ? read.props[0] : read.props\n    );\n    if (Array.isArray(read.props)) {\n      for (let i = 1; i < read.props.length; i++) {\n        replacement = toMemberExpression(replacement, read.props[i]);\n      }\n    }\n  }\n  return replacement && withPreviousLocation(replacement, node);\n}\nfunction pruneBinding(bindings, binding) {\n  let shouldPrune = !binding.downstreamExpressions.size;\n  if (binding.hoists.size) {\n    shouldPrune = false;\n  }\n  for (const alias of binding.aliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.aliases.delete(alias);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  for (const [key, alias] of binding.propertyAliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.propertyAliases.delete(key);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  if (shouldPrune) {\n    bindings.delete(binding);\n  }\n  return shouldPrune;\n}\nfunction resolveReferencedBindings(expr, reads, intersectionsBySection) {\n  let referencedBindings;\n  if (Array.isArray(reads)) {\n    for (const read of reads) {\n      let { binding } = read;\n      if (read.node) {\n        const exprReference = (read.node.extra ??= {}).read ??= resolveExpressionReference(reads, binding, void 0);\n        ({ binding } = (read.node.extra ??= {}).read = exprReference);\n      }\n      referencedBindings = bindingUtil.add(referencedBindings, binding);\n    }\n  } else if (reads) {\n    if (reads.node) {\n      (reads.node.extra ??= {}).read = createRead(reads.binding, void 0);\n    }\n    referencedBindings = reads.binding;\n  }\n  if (Array.isArray(referencedBindings)) {\n    const intersections = intersectionsBySection.get(expr.section) || [];\n    const intersection = findSorted(\n      compareIntersections,\n      intersections,\n      referencedBindings\n    );\n    if (intersection) {\n      referencedBindings = intersection;\n    } else {\n      intersectionsBySection.set(\n        expr.section,\n        addSorted(compareIntersections, intersections, referencedBindings)\n      );\n    }\n  }\n  return referencedBindings;\n}\nfunction resolveExpressionReference(reads, readBinding, readProps) {\n  const { upstreamAlias } = readBinding;\n  if (upstreamAlias && Array.isArray(reads)) {\n    const prop = getCanonicalProperty(readBinding);\n    const aliasProps = prop === void 0 ? readProps : push(readProps, prop);\n    for (const { binding } of reads) {\n      if (binding !== readBinding) {\n        let alias = upstreamAlias;\n        while (alias) {\n          if (binding === alias) {\n            return resolveExpressionReference(reads, alias, aliasProps);\n          }\n          alias = alias.upstreamAlias;\n        }\n      }\n    }\n  }\n  return createRead(readBinding, readProps);\n}\nfunction isSupersetSources(a, b) {\n  if (!b.sources) return true;\n  if (!a.sources) return false;\n  return bindingUtil.isSuperset(a.sources.state, b.sources.state) && bindingUtil.isSuperset(a.sources.input, b.sources.input);\n}\nfunction getCanonicalProperty(binding) {\n  return binding.property ?? binding.upstreamAlias?.property;\n}\nfunction createRead(binding, props) {\n  return { binding, props };\n}\nfunction getMemberExpressionPropString(expr) {\n  switch (expr.property.type) {\n    case \"StringLiteral\":\n      return expr.property.value;\n    case \"NumericLiteral\":\n      return \"\" + expr.property.value;\n    case \"Identifier\":\n      if (expr.computed) return;\n      return expr.property.name;\n  }\n}\nfunction isEventOrChangeHandler(prop) {\n  return /^on[-A-Z][a-zA-Z0-9_$]|[a-zA-Z_$][a-zA-Z0-9_$]*Change$/.test(prop);\n}\nfunction isReferencedExtra(extra) {\n  return !!(extra && !extra.pruned && extra.section);\n}\nfunction isAssignedBindingExtra(extra) {\n  return isReferencedExtra(extra) && extra.assignment !== void 0;\n}\nfunction isRegisteredFnExtra(extra) {\n  return isReferencedExtra(extra) && extra.registerId !== void 0;\n}\n\n// src/translator/core/await.ts\nvar kDOMBinding = Symbol(\"await tag dom binding\");\nvar await_default = {\n  analyze(tag) {\n    (0, import_babel_utils18.assertNoVar)(tag);\n    (0, import_babel_utils18.assertNoArgs)(tag);\n    assertNoSpreadAttrs(tag);\n    (0, import_babel_utils18.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    const tagBody = tag.get(\"body\");\n    const section = getOrCreateSection(tag);\n    const [valueAttr] = node.attributes;\n    const tagExtra = tag.node.extra ??= {};\n    tagExtra[kDOMBinding] = createBinding(\"#text\", 0 /* dom */, section);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `await` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler25.types.isMarkoAttribute(valueAttr) || valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `await` tag only supports the `value` attribute.\"\n      );\n    }\n    if (!node.body.body.length) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `await` tag requires body content.\");\n    }\n    if (node.body.params.length && (node.body.params.length > 1 || import_compiler25.types.isSpreadElement(node.body.params[0]))) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `await` tag only supports a single parameter.\"\n      );\n    }\n    const bodySection = startSection(tagBody);\n    const valueExtra = evaluate(valueAttr.value);\n    getOrCreateSection(tag);\n    const paramsBinding = trackParamsReferences(tagBody, 3 /* param */);\n    if (paramsBinding) {\n      setBindingValueExpr(paramsBinding, valueExtra);\n    }\n    bodySection.upstreamExpression = valueAttr.value.extra;\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        flushBefore(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const [valueAttr] = node.attributes;\n        const tagExtra = node.extra;\n        const nodeRef2 = tagExtra[kDOMBinding];\n        const tagBody = tag.get(\"body\");\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        flushInto(tag);\n        writeHTMLResumeStatements(tagBody);\n        tag.replaceWith(\n          import_compiler25.types.expressionStatement(\n            callRuntime(\n              \"fork\",\n              getScopeIdIdentifier(section),\n              getScopeAccessorLiteral(nodeRef2),\n              valueAttr.value,\n              import_compiler25.types.arrowFunctionExpression(\n                node.body.params,\n                toFirstExpressionOrBlock(node.body.body)\n              ),\n              getSerializeGuard(\n                bodySection && getSectionSerializeReason(bodySection),\n                true\n              )\n            )\n          )\n        )[0].skip();\n      }\n    },\n    dom: {\n      enter(tag) {\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        visit(tag, 37 /* Replace */);\n        enterShallow(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const nodeRef2 = tagExtra[kDOMBinding];\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tag.get(\"body\"));\n        const signal = getSignal(section, nodeRef2, \"await\");\n        signal.build = () => {\n          return callRuntime(\n            \"awaitTag\",\n            getScopeAccessorLiteral(nodeRef2),\n            import_compiler25.types.identifier(bodySection.name)\n          );\n        };\n        addValue(\n          section,\n          bodySection.upstreamExpression?.referencedBindings,\n          signal,\n          tag.node.attributes[0].value\n        );\n        tag.remove();\n      }\n    }\n  }),\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to consume asynchronous an data.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#await\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/await.d.marko\"\n};\n\n// src/translator/core/client.ts\nvar import_compiler26 = require(\"@marko/compiler\");\nvar import_babel_utils19 = require(\"@marko/compiler/babel-utils\");\nvar client_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^client\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils19.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler26.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler26.types.markoScriptlet(body, true, \"client\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"client <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the client.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#client-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/const.ts\nvar import_compiler28 = require(\"@marko/compiler\");\nvar import_babel_utils20 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/translate-var.ts\nvar import_compiler27 = require(\"@marko/compiler\");\nfunction translateVar(tag, initialValue, kind = \"const\") {\n  const {\n    node: { var: tagVar }\n  } = tag;\n  if (!tagVar) {\n    return;\n  }\n  tag.insertBefore(\n    import_compiler27.types.variableDeclaration(kind, [import_compiler27.types.variableDeclarator(tagVar, initialValue)])\n  );\n}\n\n// src/translator/core/const.ts\nvar const_default = {\n  analyze(tag) {\n    (0, import_babel_utils20.assertNoArgs)(tag);\n    (0, import_babel_utils20.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a tag variable.\");\n    }\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler28.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `const` tag only supports the `value` attribute.\"\n      );\n    }\n    const valueExtra = evaluate(valueAttr.value);\n    const upstreamAlias = import_compiler28.types.isIdentifier(valueAttr.value) ? tag.scope.getBinding(valueAttr.value.name)?.identifier.extra?.binding : void 0;\n    if (upstreamAlias) {\n      valueExtra.pruned = true;\n    }\n    const binding = trackVarReferences(tag, 4 /* derived */, upstreamAlias);\n    if (binding) {\n      if (!valueExtra.nullable) binding.nullable = false;\n      setBindingValueExpr(binding, valueExtra);\n    }\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      const { value } = valueAttr;\n      if (isOutputDOM()) {\n        const section = getSection(tag);\n        const varBinding = node.var.extra?.binding;\n        if (varBinding && !varBinding.upstreamAlias) {\n          const derivation = initValue(varBinding);\n          addValue(section, value.extra?.referencedBindings, derivation, value);\n        }\n      } else {\n        translateVar(tag, value);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an constant binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#const\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/const.d.marko\"\n};\n\n// src/translator/core/debug.ts\nvar import_compiler29 = require(\"@marko/compiler\");\nvar import_babel_utils21 = require(\"@marko/compiler/babel-utils\");\nvar debug_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils21.assertNoVar)(tag);\n    (0, import_babel_utils21.assertNoArgs)(tag);\n    (0, import_babel_utils21.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (tag.node.attributes.length > 1 || tag.node.attributes.length === 1 && (!import_compiler29.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\")) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `debug` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const referencedBindings = valueAttr?.value.extra?.referencedBindings;\n      const statement = withPreviousLocation(import_compiler29.types.debuggerStatement(), tag.node);\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Debug on value change.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#debug\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/debug.d.marko\"\n};\n\n// src/translator/core/define.ts\nvar import_compiler35 = require(\"@marko/compiler\");\nvar import_babel_utils27 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/nested-attribute-tags.ts\nvar import_compiler30 = require(\"@marko/compiler\");\nvar import_babel_utils22 = require(\"@marko/compiler/babel-utils\");\nvar attrTagToIdentifierLookup = /* @__PURE__ */ new WeakMap();\nfunction getAttrTagIdentifier(meta) {\n  let name2 = attrTagToIdentifierLookup.get(meta);\n  if (!name2) {\n    name2 = generateUid(meta.name);\n    attrTagToIdentifierLookup.set(meta, name2);\n  }\n  return import_compiler30.types.identifier(name2);\n}\nfunction analyzeAttributeTags(tag) {\n  if (tag.node.extra?.attributeTags) return tag.node.extra.attributeTags;\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  if (!attrTags2.length) return;\n  const tagExtra = tag.node.extra ??= {};\n  const lookup = tagExtra.attributeTags = {};\n  const attrTagNodesByName = {};\n  const sampleAttrTagsForControlFlow = /* @__PURE__ */ new Map();\n  for (const child of attrTags2) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils22.isAttributeTag)(child)) {\n        const name2 = getTagName(child);\n        lookup[name2] ||= createAttrTagMeta(name2, [name2]);\n        (attrTagNodesByName[name2] ||= []).push(child);\n        analyzeAttributeTags(child);\n      } else {\n        const isRepeated = (0, import_babel_utils22.isLoopTag)(child);\n        let curGroup;\n        for (const name2 of crawlAttrTags(child, attrTagNodesByName)) {\n          const oldMeta = lookup[name2];\n          if (oldMeta) {\n            if (!curGroup) {\n              curGroup = oldMeta.group;\n            } else if (curGroup !== oldMeta.group) {\n              for (const name3 of oldMeta.group) {\n                lookup[name3].group = curGroup;\n                curGroup.push(name3);\n              }\n            }\n          }\n          let attrTagMeta = lookup[name2];\n          if (!attrTagMeta) {\n            attrTagMeta = lookup[name2] = createAttrTagMeta(name2, []);\n            curGroup = attrTagMeta.group;\n            curGroup.push(name2);\n          }\n          attrTagMeta.dynamic = true;\n          if (isRepeated) {\n            attrTagMeta.repeated = true;\n          }\n          sampleAttrTagsForControlFlow.set(child, name2);\n        }\n      }\n    }\n  }\n  for (const [controlFlowTag, sampleAttrName] of sampleAttrTagsForControlFlow) {\n    (controlFlowTag.node.extra ??= {}).attributeTagGroup = lookup[sampleAttrName].group;\n  }\n  for (const name2 in attrTagNodesByName) {\n    const attrTagMeta = lookup[name2];\n    if (!attrTagMeta.repeated) {\n      const attrTagNodes = attrTagNodesByName[name2];\n      if (attrTagNodes.length > 1) {\n        attrTagMeta.repeated = !attrTagMeta.dynamic || hasRepeatedDynamicAttrTags(attrTagNodes);\n      }\n    }\n  }\n  return lookup;\n}\nfunction createAttrTagMeta(name2, group) {\n  return {\n    name: name2.slice(1),\n    dynamic: false,\n    repeated: false,\n    group\n  };\n}\nfunction crawlAttrTags(tag, attrTagNodesByName, attrTagNames = /* @__PURE__ */ new Set()) {\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  for (const child of attrTags2) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils22.isAttributeTag)(child)) {\n        const tagName = getTagName(child);\n        attrTagNames.add(tagName);\n        (attrTagNodesByName[tagName] ||= []).push(child);\n        analyzeAttributeTags(child);\n      } else {\n        crawlAttrTags(child, attrTagNodesByName, attrTagNames);\n      }\n    }\n  }\n  return attrTagNames;\n}\nfunction hasRepeatedDynamicAttrTags(attrTags2) {\n  let conditionRoot;\n  const seenBranches = /* @__PURE__ */ new Set();\n  for (const attrTag2 of attrTags2) {\n    const parentTag = getParentTag(attrTag2);\n    if (seenBranches.has(parentTag) || !isConditionTag(parentTag)) {\n      return true;\n    }\n    const curConditionRoot = getConditionRoot(parentTag);\n    if (curConditionRoot && curConditionRoot !== (conditionRoot ||= curConditionRoot)) {\n      return true;\n    }\n    seenBranches.add(parentTag);\n  }\n  return false;\n}\nfunction getConditionRoot(tag) {\n  if (getTagName(tag) === \"if\") return tag;\n  let prev = tag.getPrevSibling();\n  while (prev.node) {\n    if (prev.isMarkoTag() && getTagName(prev) === \"if\") {\n      return prev;\n    }\n    prev = prev.getPrevSibling();\n  }\n}\n\n// src/translator/util/translate-attrs.ts\nvar import_compiler34 = require(\"@marko/compiler\");\nvar import_babel_utils26 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/core/for.ts\nvar import_compiler33 = require(\"@marko/compiler\");\nvar import_babel_utils25 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/is-only-child-in-parent.ts\nvar import_compiler32 = require(\"@marko/compiler\");\nvar import_babel_utils24 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/visitors/tag/native-tag.ts\nvar import_compiler31 = require(\"@marko/compiler\");\nvar import_babel_utils23 = require(\"@marko/compiler/babel-utils\");\nvar kNativeTagBinding = Symbol(\"native tag binding\");\nvar kSkipEndTag = Symbol(\"skip native tag mark\");\nvar kGetterId = Symbol(\"node getter id\");\nvar htmlSelectArgs = /* @__PURE__ */ new WeakMap();\nvar native_tag_default = {\n  transform: {\n    enter(tag) {\n      const tagName = getTagName(tag);\n      if (tagName === \"textarea\" && tag.node.body.body.length) {\n        const parts = [];\n        for (const child of tag.node.body.body) {\n          if (child.type === \"MarkoText\" || child.type === \"MarkoPlaceholder\" && child.escape) {\n            parts.push(child.value);\n          } else {\n            throw tag.hub.file.hub.buildError(\n              child,\n              \"Unexpected content in textarea, only text and placeholders are supported.\",\n              SyntaxError\n            );\n          }\n        }\n        tag.node.attributes.push(\n          import_compiler31.types.markoAttribute(\n            \"value\",\n            normalizeStringExpression(parts) || buildUndefined()\n          )\n        );\n        tag.node.body.body = [];\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils23.assertNoArgs)(tag);\n      (0, import_babel_utils23.assertNoParams)(tag);\n      (0, import_babel_utils23.assertNoAttributeTags)(tag);\n      const { node } = tag;\n      if (node.var && !import_compiler31.types.isIdentifier(node.var)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"Tag variables on native elements cannot be destructured.\"\n        );\n      }\n      const tagName = getTagName(tag);\n      const seen = {};\n      const { attributes } = tag.node;\n      let hasDynamicAttributes = false;\n      let hasEventHandlers = false;\n      let relatedControllable;\n      let spreadReferenceNodes;\n      let attrExprExtras;\n      for (let i = attributes.length; i--; ) {\n        const attr2 = attributes[i];\n        const valueExtra = attr2.value.extra ??= {};\n        if (import_compiler31.types.isMarkoAttribute(attr2)) {\n          if (seen[attr2.name]) {\n            dropReferences(attr2.value);\n            continue;\n          }\n          seen[attr2.name] = attr2;\n          if (isEventHandler(attr2.name) || isChangeHandler(attr2.name)) {\n            valueExtra.isEffect = true;\n            hasEventHandlers = true;\n          } else if (!evaluate(attr2.value).confident) {\n            hasDynamicAttributes = true;\n          }\n        } else if (import_compiler31.types.isMarkoSpreadAttribute(attr2)) {\n          valueExtra.isEffect = true;\n          hasEventHandlers = true;\n          hasDynamicAttributes = true;\n        }\n        if (spreadReferenceNodes) {\n          spreadReferenceNodes.push(attr2.value);\n        } else if (import_compiler31.types.isMarkoSpreadAttribute(attr2)) {\n          spreadReferenceNodes = [attr2.value];\n          relatedControllable = getRelatedControllable(tagName, seen);\n        } else {\n          attrExprExtras = push(attrExprExtras, valueExtra);\n        }\n      }\n      assertExclusiveControllableGroups(tag, seen);\n      if (node.var || hasEventHandlers || hasDynamicAttributes) {\n        const tagExtra = node.extra ??= {};\n        const tagSection = getOrCreateSection(tag);\n        const nodeBinding = tagExtra[kNativeTagBinding] = createBinding(\n          \"#\" + (node.name.type === \"StringLiteral\" ? node.name.value : import_compiler31.types.toIdentifier(tag.get(\"name\"))),\n          0 /* dom */,\n          tagSection\n        );\n        (0, import_babel_utils23.getProgram)().node.extra.isInteractive ||= hasEventHandlers;\n        if (spreadReferenceNodes) {\n          if (relatedControllable && !relatedControllable.attrs.every(Boolean)) {\n            for (const attr2 of relatedControllable.attrs) {\n              if (attr2) {\n                spreadReferenceNodes.push(attr2.value);\n              }\n            }\n            relatedControllable = void 0;\n          }\n          mergeReferences(tagSection, tag.node, spreadReferenceNodes);\n        } else {\n          relatedControllable = getRelatedControllable(tagName, seen);\n        }\n        if (relatedControllable) {\n          mergeReferences(\n            tagSection,\n            relatedControllable.attrs.find(Boolean).value,\n            relatedControllable.attrs.map((it) => it?.value)\n          );\n        }\n        if (hasEventHandlers || spreadReferenceNodes) {\n          forceBindingSerialize(tagSection, nodeBinding);\n        }\n        if (node.var) {\n          forceBindingSerialize(tagSection, nodeBinding);\n          for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n            const refSection = getOrCreateSection(ref);\n            setReferencesScope(ref);\n            if (isSameOrChildSection(tagSection, refSection)) {\n              forceOwnersSerialize(\n                refSection,\n                tagSection,\n                getAccessorProp().Owner\n              );\n              if (!tagExtra[kGetterId] && !isInvokedFunction(ref)) {\n                tagExtra[kGetterId] = getRegisterUID(\n                  tagSection,\n                  nodeBinding.name\n                );\n              }\n            } else {\n              trackHoistedReference(\n                ref,\n                nodeBinding\n              );\n            }\n          }\n        }\n        addBindingSerializeReasonExpr(\n          tagSection,\n          nodeBinding,\n          push(attrExprExtras, tagExtra)\n        );\n      }\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        const tagName = getTagName(tag);\n        const tagExtra = tag.node.extra;\n        const nodeBinding = tagExtra[kNativeTagBinding];\n        const tagDef = (0, import_babel_utils23.getTagDef)(tag);\n        const write2 = writeTo(tag);\n        const tagSection = getSection(tag);\n        if (tagExtra.tagNameNullable) {\n          flushBefore(tag);\n        }\n        if (tag.node.var) {\n          const getterId = tagExtra[kGetterId];\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(tagSection),\n              getterId && import_compiler31.types.stringLiteral(getterId)\n            )\n          );\n        }\n        const visitAccessor = nodeBinding && getScopeAccessorLiteral(nodeBinding);\n        write2`<${tag.node.name}`;\n        const usedAttrs = getUsedAttrs(tagName, tag.node);\n        const { staticAttrs, staticControllable, skipExpression } = usedAttrs;\n        let { spreadExpression } = usedAttrs;\n        if (staticControllable) {\n          const { helper, attrs: attrs2 } = staticControllable;\n          if (tagName !== \"select\" && tagName !== \"textarea\") {\n            const values = attrs2.map((attr2) => attr2?.value);\n            write2`${callRuntime(helper, getScopeIdIdentifier(tagSection), visitAccessor, ...values)}`;\n          }\n          addHTMLEffectCall(tagSection, void 0);\n        }\n        let writeAtStartOfBody;\n        if (tagName === \"select\") {\n          if (staticControllable) {\n            htmlSelectArgs.set(tag.node, {\n              value: staticControllable.attrs[0]?.value || buildUndefined(),\n              valueChange: staticControllable.attrs[1]?.value || buildUndefined()\n            });\n          } else if (spreadExpression) {\n            const spreadIdentifier = generateUidIdentifier(\"select_input\");\n            tag.insertBefore(\n              import_compiler31.types.variableDeclaration(\"const\", [\n                import_compiler31.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            htmlSelectArgs.set(tag.node, {\n              value: import_compiler31.types.memberExpression(\n                spreadIdentifier,\n                import_compiler31.types.identifier(\"value\")\n              ),\n              valueChange: import_compiler31.types.memberExpression(\n                spreadIdentifier,\n                import_compiler31.types.identifier(\"valueChange\")\n              )\n            });\n            spreadExpression = spreadIdentifier;\n          }\n        } else if (tagName === \"textarea\") {\n          let value;\n          let valueChange;\n          if (staticControllable) {\n            value = staticControllable.attrs[0]?.value;\n            valueChange = staticControllable.attrs[1]?.value;\n          } else if (spreadExpression) {\n            const spreadIdentifier = generateUidIdentifier(\"textarea_input\");\n            tag.insertBefore(\n              import_compiler31.types.variableDeclaration(\"const\", [\n                import_compiler31.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            value = import_compiler31.types.memberExpression(spreadIdentifier, import_compiler31.types.identifier(\"value\"));\n            valueChange = import_compiler31.types.memberExpression(\n              spreadIdentifier,\n              import_compiler31.types.identifier(\"valueChange\")\n            );\n            spreadExpression = spreadIdentifier;\n          }\n          if (value || valueChange) {\n            writeAtStartOfBody = callRuntime(\n              \"controllable_textarea_value\",\n              getScopeIdIdentifier(getSection(tag)),\n              getScopeAccessorLiteral(nodeBinding),\n              value,\n              valueChange\n            );\n          }\n        }\n        for (const attr2 of staticAttrs) {\n          const { name: name2, value } = attr2;\n          const { confident, computed } = value.extra || {};\n          const valueReferences = value.extra?.referencedBindings;\n          if (tagName === \"option\" && name2 === \"value\") {\n            write2`${callRuntime(\"optionValueAttr\", value)}`;\n            continue;\n          }\n          switch (name2) {\n            case \"class\":\n            case \"style\": {\n              const helper = `${name2}Attr`;\n              if (confident) {\n                write2`${getHTMLRuntime()[helper](computed)}`;\n              } else {\n                write2`${callRuntime(helper, value)}`;\n              }\n              break;\n            }\n            default:\n              if (confident) {\n                write2`${getHTMLRuntime().attr(name2, computed)}`;\n              } else if (isEventHandler(name2)) {\n                addHTMLEffectCall(tagSection, valueReferences);\n              } else {\n                write2`${callRuntime(\"attr\", import_compiler31.types.stringLiteral(name2), value)}`;\n              }\n              break;\n          }\n        }\n        if (spreadExpression) {\n          addHTMLEffectCall(tagSection, tagExtra.referencedBindings);\n          if (skipExpression) {\n            write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(tagSection), tag.node.name)}`;\n          } else {\n            write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(tagSection), tag.node.name)}`;\n          }\n        }\n        if (tagDef && tagDef.parseOptions?.openTagOnly) {\n          switch (tagDef.htmlType) {\n            case \"svg\":\n            case \"math\":\n              write2`/>`;\n              break;\n            default:\n              write2`>`;\n              break;\n          }\n        } else {\n          write2`>`;\n        }\n        if (tagExtra.tagNameNullable) {\n          tag.insertBefore(\n            import_compiler31.types.ifStatement(tag.node.name, consumeHTML(tag))\n          )[0].skip();\n        }\n        if (writeAtStartOfBody) {\n          write2`${writeAtStartOfBody}`;\n        }\n      },\n      exit(tag) {\n        const tagExtra = tag.node.extra;\n        const nodeBinding = tagExtra[kNativeTagBinding];\n        const openTagOnly = (0, import_babel_utils23.getTagDef)(tag)?.parseOptions?.openTagOnly;\n        const selectArgs = htmlSelectArgs.get(tag.node);\n        const tagName = getTagName(tag);\n        const tagSection = getSection(tag);\n        if (tagExtra.tagNameNullable) {\n          flushInto(tag);\n        }\n        if (selectArgs) {\n          if (!tagExtra[kSkipEndTag]) {\n            writeTo(tag)`</${tag.node.name}>`;\n          }\n          flushInto(tag);\n          tag.insertBefore(\n            import_compiler31.types.expressionStatement(\n              callRuntime(\n                \"controllable_select_value\",\n                getScopeIdIdentifier(getSection(tag)),\n                getScopeAccessorLiteral(nodeBinding),\n                selectArgs.value,\n                selectArgs.valueChange,\n                import_compiler31.types.arrowFunctionExpression(\n                  [],\n                  import_compiler31.types.blockStatement(tag.node.body.body)\n                )\n              )\n            )\n          );\n        } else {\n          tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n        }\n        const markerSerializeReason = !tagExtra[kSkipEndTag] && nodeBinding && getBindingSerializeReason(tagSection, nodeBinding);\n        if (!tagExtra[kSkipEndTag] && !openTagOnly && !selectArgs) {\n          writeTo(\n            tag,\n            !markerSerializeReason && (tagName === \"html\" || tagName === \"body\")\n          )`</${tag.node.name}>`;\n        }\n        if (tagExtra.tagNameNullable) {\n          tag.insertBefore(\n            import_compiler31.types.ifStatement(tag.node.name, consumeHTML(tag))\n          )[0].skip();\n        }\n        if (markerSerializeReason) {\n          markNode(tag, nodeBinding, markerSerializeReason);\n        }\n        tag.remove();\n      }\n    },\n    dom: {\n      enter(tag) {\n        const tagName = getTagName(tag);\n        const tagExtra = tag.node.extra;\n        const nodeBinding = tagExtra[kNativeTagBinding];\n        const tagDef = (0, import_babel_utils23.getTagDef)(tag);\n        const write2 = writeTo(tag);\n        const tagSection = getSection(tag);\n        if (tag.node.var) {\n          const varName = tag.node.var.name;\n          const varBinding = tag.scope.getBinding(varName);\n          const getterId = tagExtra[kGetterId];\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);\n            (0, import_babel_utils23.getProgram)().node.body.push(\n              import_compiler31.types.variableDeclaration(\"const\", [\n                import_compiler31.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler31.types.stringLiteral(getterId),\n                    import_compiler31.types.stringLiteral(\n                      getAccessorPrefix().Getter + getScopeAccessorLiteral(nodeBinding).value\n                    )\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of varBinding.referencePaths) {\n            const referenceSection = getSection(reference);\n            if (isSameOrChildSection(tagSection, referenceSection)) {\n              if (isInvokedFunction(reference)) {\n                reference.parentPath.replaceWith(\n                  import_compiler31.types.expressionStatement(\n                    createScopeReadExpression(referenceSection, nodeBinding)\n                  )\n                );\n              } else if (getterFnIdentifier) {\n                reference.replaceWith(\n                  import_compiler31.types.callExpression(getterFnIdentifier, [\n                    getScopeExpression(referenceSection, getSection(tag))\n                  ])\n                );\n              } else {\n                reference.replaceWith(\n                  import_compiler31.types.expressionStatement(\n                    import_compiler31.types.memberExpression(\n                      getScopeExpression(tagSection, referenceSection),\n                      import_compiler31.types.stringLiteral(\n                        getAccessorPrefix().Getter + getScopeAccessorLiteral(nodeBinding).value\n                      ),\n                      true\n                    )\n                  )\n                );\n              }\n            }\n          }\n        }\n        const visitAccessor = nodeBinding && getScopeAccessorLiteral(nodeBinding);\n        if (visitAccessor) {\n          visit(tag, 32 /* Get */);\n        }\n        write2`<${tag.node.name}`;\n        const usedAttrs = getUsedAttrs(tagName, tag.node);\n        const { staticAttrs, staticControllable, skipExpression } = usedAttrs;\n        const { spreadExpression } = usedAttrs;\n        if (staticControllable) {\n          const { helper, attrs: attrs2 } = staticControllable;\n          const firstAttr = attrs2.find(Boolean);\n          const referencedBindings = firstAttr.value.extra?.referencedBindings;\n          const values = attrs2.map((attr2) => attr2?.value);\n          addStatement(\n            \"render\",\n            tagSection,\n            referencedBindings,\n            import_compiler31.types.expressionStatement(\n              callRuntime(helper, scopeIdentifier, visitAccessor, ...values)\n            )\n          );\n          addStatement(\n            \"effect\",\n            tagSection,\n            void 0,\n            import_compiler31.types.expressionStatement(\n              callRuntime(`${helper}_effect`, scopeIdentifier, visitAccessor)\n            )\n          );\n        }\n        for (const attr2 of staticAttrs) {\n          const { name: name2, value } = attr2;\n          const { confident, computed } = value.extra || {};\n          const valueReferences = value.extra?.referencedBindings;\n          switch (name2) {\n            case \"class\":\n            case \"style\": {\n              const helper = `${name2}Attr`;\n              if (confident) {\n                write2`${getHTMLRuntime()[helper](computed)}`;\n              } else {\n                const nodeExpr = import_compiler31.types.memberExpression(\n                  scopeIdentifier,\n                  visitAccessor,\n                  true\n                );\n                const meta = {\n                  staticItems: void 0,\n                  dynamicItems: void 0,\n                  dynamicValues: void 0\n                };\n                let stmt;\n                trackDelimitedAttrValue(value, meta);\n                if (meta.dynamicItems) {\n                  stmt = import_compiler31.types.expressionStatement(\n                    callRuntime(helper, nodeExpr, value)\n                  );\n                } else {\n                  if (meta.staticItems) {\n                    write2`${getHTMLRuntime()[helper](meta.staticItems)}`;\n                  }\n                  if (meta.dynamicValues) {\n                    const keys = Object.keys(meta.dynamicValues);\n                    if (keys.length === 1) {\n                      const [key] = keys;\n                      const value2 = meta.dynamicValues[key];\n                      stmt = import_compiler31.types.expressionStatement(\n                        callRuntime(\n                          `${name2}Item`,\n                          nodeExpr,\n                          import_compiler31.types.stringLiteral(key),\n                          value2\n                        )\n                      );\n                    } else {\n                      const props = [];\n                      for (const key of keys) {\n                        const value2 = meta.dynamicValues[key];\n                        props.push(\n                          import_compiler31.types.objectProperty(toPropertyName(key), value2)\n                        );\n                      }\n                      stmt = import_compiler31.types.expressionStatement(\n                        callRuntime(\n                          `${name2}Items`,\n                          nodeExpr,\n                          import_compiler31.types.objectExpression(props)\n                        )\n                      );\n                    }\n                  }\n                }\n                if (stmt) {\n                  addStatement(\"render\", tagSection, valueReferences, stmt);\n                }\n              }\n              break;\n            }\n            default:\n              if (confident) {\n                write2`${getHTMLRuntime().attr(name2, computed)}`;\n              } else if (isEventHandler(name2)) {\n                addStatement(\n                  \"effect\",\n                  tagSection,\n                  valueReferences,\n                  import_compiler31.types.expressionStatement(\n                    callRuntime(\n                      \"on\",\n                      import_compiler31.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                      import_compiler31.types.stringLiteral(getEventHandlerName(name2)),\n                      value\n                    )\n                  )\n                );\n              } else {\n                addStatement(\n                  \"render\",\n                  tagSection,\n                  valueReferences,\n                  import_compiler31.types.expressionStatement(\n                    callRuntime(\n                      \"attr\",\n                      import_compiler31.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                      import_compiler31.types.stringLiteral(name2),\n                      value\n                    )\n                  )\n                );\n              }\n              break;\n          }\n        }\n        if (spreadExpression) {\n          if (skipExpression) {\n            addStatement(\n              \"render\",\n              tagSection,\n              tagExtra.referencedBindings,\n              import_compiler31.types.expressionStatement(\n                callRuntime(\n                  \"partialAttrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression,\n                  skipExpression\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              tagSection,\n              tagExtra.referencedBindings,\n              import_compiler31.types.expressionStatement(\n                callRuntime(\n                  \"attrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression\n                )\n              )\n            );\n          }\n          addStatement(\n            \"effect\",\n            tagSection,\n            tagExtra.referencedBindings,\n            import_compiler31.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            false\n          );\n        }\n        if (tagDef && tagDef.parseOptions?.openTagOnly) {\n          switch (tagDef.htmlType) {\n            case \"svg\":\n            case \"math\":\n              write2`/>`;\n              break;\n            default:\n              write2`>`;\n              break;\n          }\n        } else {\n          write2`>`;\n        }\n        enter2(tag);\n      },\n      exit(tag) {\n        const openTagOnly = (0, import_babel_utils23.getTagDef)(tag)?.parseOptions?.openTagOnly;\n        tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n        if (!openTagOnly) {\n          writeTo(tag)`</${tag.node.name}>`;\n        }\n        exit2(tag);\n        tag.remove();\n      }\n    }\n  })\n};\nfunction assertExclusiveControllableGroups(tag, attrs2) {\n  const exclusiveGroups = [\n    attrs2.open || attrs2.openChange,\n    attrs2.checked || attrs2.checkedChange,\n    attrs2.checkedValue || attrs2.checkedValueChange,\n    attrs2.valueChange\n  ].filter(Boolean);\n  if (exclusiveGroups.length > 1) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The attributes ${exclusiveGroups.map((attr2) => `\"${attr2.name}\"`).join(\", \")} are mutually exclusive.`\n    );\n  }\n}\nfunction getRelatedControllable(tagName, attrs2) {\n  switch (tagName) {\n    case \"input\":\n      if (attrs2.checked || attrs2.checkedChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_checked\",\n          attrs: [attrs2.checked, attrs2.checkedChange]\n        };\n      }\n      if (attrs2.checkedValue || attrs2.checkedValueChange) {\n        return {\n          special: true,\n          helper: \"controllable_input_checkedValue\",\n          attrs: [attrs2.checkedValue, attrs2.checkedValueChange, attrs2.value]\n        };\n      }\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"select\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_select_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"textarea\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_textarea_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"details\":\n    case \"dialog\":\n      if (attrs2.open || attrs2.openChange) {\n        return {\n          special: false,\n          helper: \"controllable_detailsOrDialog_open\",\n          attrs: [attrs2.open, attrs2.openChange]\n        };\n      }\n      break;\n  }\n}\nfunction getUsedAttrs(tagName, tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  let staticControllable;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler31.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n        staticControllable = getRelatedControllable(tagName, seen);\n        if (staticControllable && !staticControllable.attrs.every(Boolean)) {\n          for (const attr3 of staticControllable.attrs) {\n            if (attr3) {\n              spreadProps.push(toObjectProperty(attr3.name, attr3.value));\n              maybeStaticAttrs.delete(attr3);\n            }\n          }\n          staticControllable = void 0;\n        }\n      }\n      spreadProps.push(import_compiler31.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  if (!spreadProps) {\n    staticControllable = getRelatedControllable(tagName, seen);\n    if (staticControllable?.special === false && !staticControllable.attrs[1]) {\n      staticControllable = void 0;\n    }\n  }\n  if (staticControllable) {\n    for (const attr2 of staticControllable.attrs) {\n      if (attr2) {\n        maybeStaticAttrs.delete(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    if (staticControllable) {\n      for (const attr2 of staticControllable.attrs) {\n        if (attr2) {\n          (skipProps ||= []).push(\n            toObjectProperty(attr2.name, import_compiler31.types.numericLiteral(1))\n          );\n        }\n      }\n    }\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler31.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler31.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    staticControllable,\n    spreadExpression,\n    skipExpression\n  };\n}\nfunction trackDelimitedAttrValue(expr, meta) {\n  switch (expr.type) {\n    case \"ObjectExpression\":\n      trackDelimitedAttrObjectProperties(expr, meta);\n      break;\n    case \"ArrayExpression\":\n      trackDelimitedAttrArrayItems(expr, meta);\n      break;\n    default:\n      (meta.dynamicItems ||= []).push(expr);\n      break;\n  }\n}\nfunction trackDelimitedAttrArrayItems(arr, meta) {\n  for (const item of arr.elements) {\n    if (item) {\n      switch (item.type) {\n        case \"ArrayExpression\": {\n          trackDelimitedAttrArrayItems(item, meta);\n          break;\n        }\n        case \"ObjectExpression\": {\n          trackDelimitedAttrObjectProperties(item, meta);\n          break;\n        }\n        case \"SpreadElement\":\n          if (item.argument.type === \"ArrayExpression\") {\n            trackDelimitedAttrArrayItems(item.argument, meta);\n          } else {\n            (meta.dynamicItems ||= []).push(item);\n          }\n          break;\n        default: {\n          const evalItem = evaluate(item);\n          if (evalItem.confident) {\n            (meta.staticItems ||= []).push(evalItem.computed);\n          } else {\n            (meta.dynamicItems ||= []).push(item);\n          }\n          break;\n        }\n      }\n    }\n  }\n}\nfunction trackDelimitedAttrObjectProperties(obj, meta) {\n  let staticProps;\n  let dynamicProps;\n  for (const prop of obj.properties) {\n    if (prop.type !== \"ObjectProperty\" || prop.computed) {\n      (dynamicProps ||= []).push(prop);\n      continue;\n    }\n    let key;\n    if (prop.key.type === \"Identifier\") {\n      key = prop.key.name;\n    } else {\n      const keyEval = evaluate(prop.key);\n      if (keyEval.confident) {\n        key = keyEval.computed + \"\";\n      } else {\n        (dynamicProps ||= []).push(prop);\n        continue;\n      }\n    }\n    const value = prop.value;\n    const propEval = evaluate(value);\n    if (propEval.confident) {\n      (staticProps ||= {})[key] = propEval.computed;\n    } else {\n      (meta.dynamicValues ||= {})[key] = value;\n    }\n  }\n  if (staticProps) {\n    (meta.staticItems ||= []).push(staticProps);\n  }\n  if (dynamicProps) {\n    (meta.dynamicItems ||= []).push(import_compiler31.types.objectExpression(dynamicProps));\n  }\n}\nfunction isChangeHandler(propName) {\n  return /^(?:value|checked(?:Value)?|open)Change/.test(propName);\n}\nfunction buildUndefined() {\n  return import_compiler31.types.unaryExpression(\"void\", import_compiler31.types.numericLiteral(0));\n}\n\n// src/translator/util/is-only-child-in-parent.ts\nvar kOnlyChildInParent = Symbol(\"only child in parent\");\nvar kNodeRef = Symbol(\"potential only child node ref\");\nfunction getOnlyChildParentTagName(tag, branchSize = 1) {\n  const extra = tag.node.extra;\n  if (extra[kOnlyChildInParent] !== void 0) {\n    return extra[kOnlyChildInParent];\n  }\n  const parentTag = getParentTag(tag);\n  return extra[kOnlyChildInParent] = parentTag && (0, import_babel_utils24.getTagDef)(parentTag)?.html && parentTag.node.name.type === \"StringLiteral\" && tag.parent.body.length === branchSize ? parentTag.node.name.value : false;\n}\nfunction getOptimizedOnlyChildNodeBinding(tag, section, branchSize = 1) {\n  if (getOnlyChildParentTagName(tag, branchSize)) {\n    const parentTag = getParentTag(tag).node;\n    const parentTagName = parentTag.name?.value;\n    return (parentTag.extra ??= {})[kNativeTagBinding] ??= createBinding(\n      \"#\" + parentTagName,\n      0 /* dom */,\n      section\n    );\n  } else {\n    return (tag.node.extra ??= {})[kNodeRef] ??= createBinding(\n      \"#text\",\n      0 /* dom */,\n      section\n    );\n  }\n}\n\n// src/translator/core/for.ts\nvar for_default = {\n  analyze(tag) {\n    const isAttrTag = tag.node.body.attributeTags;\n    let allowAttrs;\n    (0, import_babel_utils25.assertNoVar)(tag);\n    (0, import_babel_utils25.assertNoArgs)(tag);\n    assertNoSpreadAttrs(tag);\n    switch (getForType(tag.node)) {\n      case \"of\":\n        allowAttrs = [\"of\"];\n        break;\n      case \"in\":\n        allowAttrs = [\"in\"];\n        break;\n      case \"to\":\n        allowAttrs = [\"to\", \"from\", \"step\"];\n        break;\n      default:\n        throw tag.buildCodeFrameError(\n          \"Invalid `for` tag, missing an `of=`, `in=`, `to=` attribute.\"\n        );\n    }\n    if (!isAttrTag) {\n      allowAttrs.push(\"by\");\n    }\n    (0, import_babel_utils25.assertAllowedAttributes)(tag, allowAttrs);\n    if (isAttrTag) return;\n    const tagBody = tag.get(\"body\");\n    const bodySection = startSection(tagBody);\n    if (!bodySection) {\n      dropReferences(getAllTagReferenceNodes(tag.node));\n      return;\n    }\n    const tagSection = getOrCreateSection(tag);\n    const nodeBinding = getOptimizedOnlyChildNodeBinding(tag, tagSection);\n    const paramsBinding = trackParamsReferences(tagBody, 3 /* param */);\n    const tagExtra = mergeReferences(\n      tagSection,\n      tag.node,\n      getAllTagReferenceNodes(tag.node)\n    );\n    if (paramsBinding) {\n      setBindingValueExpr(paramsBinding, tagExtra);\n    }\n    bodySection.sectionAccessor = {\n      binding: nodeBinding,\n      prefix: getAccessorPrefix().LoopScopeMap\n    };\n    bodySection.upstreamExpression = tagExtra;\n    bodySection.isBranch = true;\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        if (!getOnlyChildParentTagName(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n        flushBefore(tag);\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const onlyChildParentTagName = getOnlyChildParentTagName(tag);\n        const nodeBinding = getOptimizedOnlyChildNodeBinding(tag, tagSection);\n        const forAttrs = getKnownAttrValues(node);\n        const forType = getForType(node);\n        const params = node.body.params;\n        const statements = [];\n        const bodyStatements = node.body.body;\n        const singleNodeOptimization = bodySection.content === null || bodySection.content.singleChild && bodySection.content.startType !== 4 /* Text */;\n        const branchSerializeReason = getSectionSerializeReason(\n          bodySection,\n          kBranchSerializeReason\n        );\n        const markerSerializeReason = getBindingSerializeReason(\n          tagSection,\n          nodeBinding\n        );\n        flushInto(tag);\n        writeHTMLResumeStatements(tagBody);\n        const forTagArgs = getBaseArgsInForTag(forType, forAttrs);\n        const forTagHTMLRuntime = branchSerializeReason ? forTypeToHTMLResumeRuntime(forType) : forTypeToRuntime(forType);\n        forTagArgs.push(\n          import_compiler33.types.arrowFunctionExpression(params, import_compiler33.types.blockStatement(bodyStatements))\n        );\n        if (branchSerializeReason) {\n          const skipParentEnd = onlyChildParentTagName && markerSerializeReason;\n          const markerSerializeArg = getSerializeGuard(\n            markerSerializeReason,\n            !(skipParentEnd || singleNodeOptimization)\n          );\n          forTagArgs.push(\n            forAttrs.by || import_compiler33.types.numericLiteral(0),\n            getScopeIdIdentifier(tagSection),\n            getScopeAccessorLiteral(nodeBinding),\n            getSerializeGuard(branchSerializeReason, !markerSerializeArg),\n            markerSerializeArg\n          );\n          if (skipParentEnd) {\n            getParentTag(tag).node.extra[kSkipEndTag] = true;\n            forTagArgs.push(import_compiler33.types.stringLiteral(`</${onlyChildParentTagName}>`));\n          }\n          if (singleNodeOptimization) {\n            if (!skipParentEnd) {\n              forTagArgs.push(import_compiler33.types.numericLiteral(0));\n            }\n            forTagArgs.push(import_compiler33.types.numericLiteral(1));\n          }\n        }\n        statements.push(\n          import_compiler33.types.expressionStatement(callRuntime(forTagHTMLRuntime, ...forTagArgs))\n        );\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        if (!getOnlyChildParentTagName(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const { referencedBindings } = tagExtra;\n        const nodeRef2 = getOptimizedOnlyChildNodeBinding(tag, tagSection);\n        setClosureSignalBuilder(tag, (closure, render) => {\n          return callRuntime(\n            \"loopClosure\",\n            getScopeAccessorLiteral(closure),\n            getScopeAccessorLiteral(nodeRef2),\n            render\n          );\n        });\n        const forType = getForType(node);\n        const signal = getSignal(tagSection, nodeRef2, \"for\");\n        signal.build = () => {\n          return callRuntime(\n            forTypeToDOMRuntime(forType),\n            getScopeAccessorLiteral(nodeRef2),\n            import_compiler33.types.identifier(bodySection.name)\n          );\n        };\n        const forAttrs = getKnownAttrValues(node);\n        const loopArgs = getBaseArgsInForTag(forType, forAttrs);\n        if (forAttrs.by) {\n          loopArgs.push(forAttrs.by);\n        }\n        addValue(\n          tagSection,\n          referencedBindings,\n          signal,\n          import_compiler33.types.arrayExpression(loopArgs)\n        );\n        tag.remove();\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  attributes: {\n    of: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over a list of items.\"\n        }\n      ]\n    },\n    in: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over the keys and values of an object.\"\n        }\n      ]\n    },\n    to: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates up to the provided number (inclusive)\"\n        }\n      ]\n    },\n    from: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates starting from the provided number (inclusive)\"\n        }\n      ]\n    },\n    step: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"The amount to increment during each interation (with from/to)\"\n        }\n      ]\n    }\n  },\n  autocomplete: [\n    {\n      snippet: \"for|${1:value, index}| of=${3:array}\",\n      description: \"Use to iterate over lists, object properties, or between ranges.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-a-list\"\n    },\n    {\n      snippet: \"for|${1:name, value}| in=${3:object}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties\"\n    },\n    {\n      snippet: \"for|${1:index}| to=${2:number}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers\"\n    }\n  ]\n};\nfunction buildForRuntimeCall(type, attrs2, params, statements) {\n  return import_compiler33.types.expressionStatement(\n    callRuntime(\n      forTypeToRuntime(type),\n      ...getBaseArgsInForTag(type, attrs2),\n      import_compiler33.types.arrowFunctionExpression(params, import_compiler33.types.blockStatement(statements))\n    )\n  );\n}\nfunction getForType(tag) {\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      switch (attr2.name) {\n        case \"of\":\n        case \"in\":\n        case \"to\":\n          return attr2.name;\n      }\n    }\n  }\n}\nfunction forTypeToRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"forOf\";\n    case \"in\":\n      return \"forIn\";\n    case \"to\":\n      return \"forTo\";\n  }\n}\nfunction forTypeToHTMLResumeRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"resumeForOf\";\n    case \"in\":\n      return \"resumeForIn\";\n    case \"to\":\n      return \"resumeForTo\";\n  }\n}\nfunction forTypeToDOMRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"loopOf\";\n    case \"in\":\n      return \"loopIn\";\n    case \"to\":\n      return \"loopTo\";\n  }\n}\nfunction getBaseArgsInForTag(type, attrs2) {\n  switch (type) {\n    case \"in\":\n      return [attrs2.in];\n    case \"of\":\n      return [attrs2.of];\n    case \"to\":\n      return [\n        attrs2.to,\n        attrs2.from || import_compiler33.types.numericLiteral(0),\n        attrs2.step || import_compiler33.types.numericLiteral(1)\n      ];\n  }\n}\n\n// src/translator/util/translate-attrs.ts\nvar contentProps = /* @__PURE__ */ new WeakSet();\nfunction translateAttrs(tag, templateExports, statements = [], contentKey = \"content\") {\n  const seen = /* @__PURE__ */ new Set();\n  const properties = [];\n  const attrTagLookup = tag.node.extra?.attributeTags;\n  if (attrTagLookup) {\n    for (const name2 in attrTagLookup) {\n      const attrTagMeta = attrTagLookup[name2];\n      if (usesExport(templateExports, attrTagMeta.name)) {\n        seen.add(attrTagMeta.name);\n        if (attrTagMeta.dynamic) {\n          statements.push(\n            import_compiler34.types.variableDeclaration(\"let\", [\n              import_compiler34.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta))\n            ])\n          );\n          properties.push(\n            toObjectProperty(\n              attrTagMeta.name,\n              getAttrTagIdentifier(attrTagMeta)\n            )\n          );\n        }\n      }\n    }\n    const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils26.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          if (attrTagMeta.dynamic) {\n            i = addDynamicAttrTagStatements(\n              attrTags2,\n              i,\n              attrTagLookup,\n              statements,\n              templateExports,\n              contentKey\n            );\n          } else {\n            const translatedAttrTag = translateAttrs(\n              child,\n              templateExports?.[attrTagMeta.name]?.props,\n              statements,\n              contentKey\n            );\n            if (attrTagMeta.repeated) {\n              const prevProp = findObjectProperty(attrTagMeta.name, properties);\n              if (prevProp) {\n                prevProp.value = callRuntime(\n                  \"attrTags\",\n                  prevProp.value,\n                  propsToExpression(translatedAttrTag.properties)\n                );\n              } else {\n                properties.push(\n                  toObjectProperty(\n                    attrTagMeta.name,\n                    callRuntime(\n                      \"attrTag\",\n                      propsToExpression(translatedAttrTag.properties)\n                    )\n                  )\n                );\n              }\n            } else {\n              properties.push(\n                toObjectProperty(\n                  attrTagMeta.name,\n                  callRuntime(\n                    \"attrTag\",\n                    propsToExpression(translatedAttrTag.properties)\n                  )\n                )\n              );\n            }\n          }\n        } else {\n          i = addDynamicAttrTagStatements(\n            attrTags2,\n            i,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        }\n      }\n    }\n  }\n  if (!seen.has(contentKey) && usesExport(templateExports, contentKey)) {\n    seen.add(contentKey);\n    const contentExpression = buildContent(tag.get(\"body\"));\n    if (contentExpression) {\n      const contentProp = import_compiler34.types.objectProperty(\n        import_compiler34.types.identifier(contentKey),\n        contentExpression\n      );\n      contentProps.add(contentProp);\n      properties.push(contentProp);\n    }\n  }\n  const { attributes } = tag.node;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler34.types.isMarkoSpreadAttribute(attr2)) {\n      properties.push(import_compiler34.types.spreadElement(value));\n    } else if (!seen.has(attr2.name) && usesExport(templateExports, attr2.name)) {\n      seen.add(attr2.name);\n      properties.push(toObjectProperty(attr2.name, value));\n    }\n  }\n  properties.reverse();\n  return { properties, statements };\n}\nfunction getTranslatedBodyContentProperty(props) {\n  for (const prop of props) {\n    if (contentProps.has(prop)) {\n      return prop;\n    }\n  }\n}\nfunction addDynamicAttrTagStatements(attrTags2, index, attrTagLookup, statements, templateExports, contentKey = \"content\") {\n  const tag = attrTags2[index];\n  if (tag.isMarkoTag()) {\n    if ((0, import_babel_utils26.isAttributeTag)(tag)) {\n      const attrTagMeta = attrTagLookup[getTagName(tag)];\n      if (usesExport(templateExports, attrTagMeta.name) && attrTagMeta.dynamic) {\n        const translatedAttrTag = translateAttrs(\n          tag,\n          templateExports?.[attrTagMeta.name]?.props,\n          statements,\n          contentKey\n        );\n        if (attrTagMeta.repeated) {\n          statements.push(\n            import_compiler34.types.expressionStatement(\n              import_compiler34.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTags\",\n                  getAttrTagIdentifier(attrTagMeta),\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        } else {\n          statements.push(\n            import_compiler34.types.expressionStatement(\n              import_compiler34.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTag\",\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        }\n      }\n    } else {\n      switch (getTagName(tag)) {\n        case \"if\":\n          return translateIfAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        case \"for\": {\n          return translateForAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        }\n      }\n    }\n  }\n  return index;\n}\nfunction propsToExpression(props) {\n  return props.length === 1 && import_compiler34.types.isSpreadElement(props[0]) ? props[0].argument : import_compiler34.types.objectExpression(props);\n}\nfunction translateForAttrTag(attrTags2, index, attrTagLookup, statements, templateExports, contentKey) {\n  const forTag = attrTags2[index];\n  const bodyStatements = [];\n  addAllAttrTagsAsDynamic(\n    forTag,\n    attrTagLookup,\n    bodyStatements,\n    templateExports,\n    contentKey\n  );\n  statements.push(\n    buildForRuntimeCall(\n      getForType(forTag.node),\n      getKnownAttrValues(forTag.node),\n      forTag.node.body.params,\n      bodyStatements\n    )\n  );\n  return index;\n}\nfunction translateIfAttrTag(attrTags2, index, attrTagLookup, statements, templateExports, contentKey) {\n  const ifTag = attrTags2[index];\n  const consequentStatements = [];\n  let ifStatement = import_compiler34.types.ifStatement(\n    getConditionTestValue(ifTag),\n    import_compiler34.types.blockStatement(consequentStatements)\n  );\n  statements.push(ifStatement);\n  addAllAttrTagsAsDynamic(\n    ifTag,\n    attrTagLookup,\n    consequentStatements,\n    templateExports,\n    contentKey\n  );\n  let nextIndex = index + 1;\n  while (nextIndex < attrTags2.length) {\n    const nextTag = attrTags2[nextIndex];\n    if (nextTag.isMarkoTag()) {\n      switch (getTagName(nextTag)) {\n        case \"else-if\":\n        case \"else\": {\n          const testValue = getConditionTestValue(nextTag);\n          const alternateStatements = [];\n          addAllAttrTagsAsDynamic(\n            nextTag,\n            attrTagLookup,\n            alternateStatements,\n            templateExports,\n            contentKey\n          );\n          if (testValue) {\n            ifStatement.alternate = ifStatement = import_compiler34.types.ifStatement(\n              testValue,\n              import_compiler34.types.blockStatement(alternateStatements)\n            );\n            nextIndex++;\n            continue;\n          } else {\n            ifStatement.alternate = import_compiler34.types.blockStatement(alternateStatements);\n            break;\n          }\n        }\n      }\n    }\n    break;\n  }\n  return nextIndex - 1;\n}\nfunction addAllAttrTagsAsDynamic(tag, attrTagLookup, statements, templateExports, contentKey) {\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  for (let i = 0; i < attrTags2.length; i++) {\n    i = addDynamicAttrTagStatements(\n      attrTags2,\n      i,\n      attrTagLookup,\n      statements,\n      templateExports,\n      contentKey\n    );\n  }\n}\nfunction usesExport(templateExports, name2) {\n  return !templateExports || !!templateExports[name2];\n}\nfunction findObjectProperty(name2, props) {\n  for (const prop of props) {\n    if (prop.type === \"ObjectProperty\") {\n      switch (prop.key.type) {\n        case \"StringLiteral\":\n          if (prop.key.value === name2) {\n            return prop;\n          }\n          break;\n        case \"Identifier\":\n          if (prop.key.name === name2) {\n            return prop;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\nfunction getConditionTestValue({\n  node: { attributes }\n}) {\n  return attributes.length === 1 ? attributes[0].value : void 0;\n}\nfunction buildContent(body) {\n  const bodySection = body.node.extra?.section;\n  if (bodySection) {\n    if (isOutputHTML()) {\n      const serialized = isSerializedSection(bodySection);\n      return callRuntime(\n        serialized ? \"registerContent\" : \"createContent\",\n        import_compiler34.types.stringLiteral(getResumeRegisterId(bodySection, \"renderer\")),\n        import_compiler34.types.arrowFunctionExpression(\n          body.node.params,\n          import_compiler34.types.blockStatement(body.node.body)\n        ),\n        serialized ? getScopeIdIdentifier(\n          getSection(\n            getNonAttributeTagParent(\n              body.parentPath\n            )\n          )\n        ) : void 0\n      );\n    } else {\n      return import_compiler34.types.callExpression(import_compiler34.types.identifier(bodySection.name), [\n        scopeIdentifier\n      ]);\n    }\n  }\n}\nfunction getNonAttributeTagParent(tag) {\n  let cur = tag;\n  while ((0, import_babel_utils26.isAttributeTag)(cur) || (0, import_babel_utils26.isTransparentTag)(cur)) {\n    cur = getParentTag(cur);\n  }\n  return cur;\n}\n\n// src/translator/core/define.ts\nvar define_default = {\n  analyze(tag) {\n    (0, import_babel_utils27.assertNoArgs)(tag);\n    if (!tag.node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `define` tag requires a tag variable.\");\n    }\n    const tagBody = tag.get(\"body\");\n    const bodySection = startSection(tagBody);\n    const varBinding = trackVarReferences(tag, 4 /* derived */);\n    if (bodySection) {\n      if (varBinding) {\n        bodySection.downstreamBinding = varBinding.propertyAliases.get(\"content\") || varBinding;\n      }\n    }\n    trackParamsReferences(tagBody, 3 /* param */);\n    analyzeAttributeTags(tag);\n    const tagExtra = mergeReferences(\n      getOrCreateSection(tag),\n      tag.node,\n      getAllTagReferenceNodes(tag.node)\n    );\n    if (varBinding) {\n      setBindingValueExpr(varBinding, tagExtra);\n    }\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const translatedAttrs = translateAttrs(tag);\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        tag.insertBefore(translatedAttrs.statements);\n        translateVar(tag, propsToExpression(translatedAttrs.properties));\n      } else {\n        const section = getSection(tag);\n        const referencedBindings = node.extra?.referencedBindings;\n        const derivation = initValue(tag.get(\"var\").node.extra.binding);\n        if (translatedAttrs.statements.length) {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            translatedAttrs.statements\n          );\n        }\n        addValue(\n          section,\n          referencedBindings,\n          derivation,\n          propsToExpression(translatedAttrs.properties)\n        );\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a constant object binding that can be rendered.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#define\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/define.d.marko\"\n};\n\n// src/translator/core/effect.ts\nvar import_compiler36 = require(\"@marko/compiler\");\nvar import_babel_utils28 = require(\"@marko/compiler/babel-utils\");\nvar effect_default = {\n  migrate: [\n    (tag) => {\n      (0, import_babel_utils28.assertNoArgs)(tag);\n      (0, import_babel_utils28.assertNoParams)(tag);\n      assertNoBodyContent(tag);\n      (0, import_babel_utils28.assertNoAttributeTags)(tag);\n      assertNoSpreadAttrs(tag);\n      (0, import_babel_utils28.assertAllowedAttributes)(tag, [\"value\"]);\n      (0, import_babel_utils28.diagnosticDeprecate)(tag, {\n        label: \"The 'effect' tag has been replaced by the 'script' tag.\",\n        fix() {\n          const { node } = tag;\n          tag.replaceWith(\n            import_compiler36.types.markoTag(\n              withPreviousLocation(import_compiler36.types.stringLiteral(\"script\"), node.name),\n              node.attributes,\n              node.body,\n              node.arguments,\n              node.var,\n              node.attributeTags\n            )\n          );\n        }\n      });\n    }\n  ],\n  attributes: {},\n  types: runtime_info_default.name + \"/tag-types/effect.d.marko\"\n};\n\n// src/translator/core/export.ts\nvar import_babel_utils29 = require(\"@marko/compiler/babel-utils\");\nvar export_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils29.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"export <value>\"\n    }\n  ]\n};\n\n// src/translator/core/html-comment.ts\nvar import_compiler37 = require(\"@marko/compiler\");\nvar import_babel_utils30 = require(\"@marko/compiler/babel-utils\");\nvar kNodeBinding = Symbol(\"comment tag binding\");\nvar kGetterId2 = Symbol(\"node getter id\");\nvar html_comment_default = {\n  analyze(tag) {\n    (0, import_babel_utils30.assertNoArgs)(tag);\n    (0, import_babel_utils30.assertNoParams)(tag);\n    (0, import_babel_utils30.assertNoAttributes)(tag);\n    const tagVar = tag.node.var;\n    let needsBinding = false;\n    let needsGetter = false;\n    if (tagVar) {\n      if (!import_compiler37.types.isIdentifier(tagVar)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"The `html-comment` tag variable cannot be destructured.\"\n        );\n      }\n      needsBinding = true;\n      for (const ref of tag.scope.getBinding(tagVar.name).referencePaths) {\n        if (!isInvokedFunction(ref)) {\n          needsGetter = true;\n          break;\n        }\n      }\n    }\n    const referenceNodes = [];\n    for (const child of tag.get(\"body\").get(\"body\")) {\n      if (child.isMarkoPlaceholder()) {\n        referenceNodes.push(child.node.value);\n        needsBinding = true;\n      } else if (!child.isMarkoText()) {\n        throw child.buildCodeFrameError(\n          \"Invalid child. Only text is allowed inside an html comment.\"\n        );\n      }\n    }\n    if (needsBinding) {\n      const tagSection = getOrCreateSection(tag);\n      const tagExtra = mergeReferences(tagSection, tag.node, referenceNodes);\n      const nodeBinding = tagExtra[kNodeBinding] = createBinding(\n        \"#comment\",\n        0 /* dom */,\n        tagSection\n      );\n      if (needsGetter) {\n        tagExtra[kGetterId2] = getRegisterUID(tagSection, \"comment\");\n      }\n      if (tagVar) {\n        forceBindingSerialize(tagSection, nodeBinding);\n      } else {\n        addBindingSerializeReasonExpr(tagSection, nodeBinding, tagExtra);\n      }\n    }\n    tag.skip();\n  },\n  translate: {\n    enter(tag) {\n      const tagExtra = tag.node.extra;\n      const nodeBinding = tagExtra[kNodeBinding];\n      const hasVar = !!tag.node.var;\n      if (hasVar) {\n        const getterId = tagExtra[kGetterId2];\n        if (isOutputHTML()) {\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(getSection(tag)),\n              getterId && import_compiler37.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);\n            (0, import_babel_utils30.getProgram)().node.body.push(\n              import_compiler37.types.variableDeclaration(\"const\", [\n                import_compiler37.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler37.types.stringLiteral(getterId),\n                    getScopeAccessorLiteral(nodeBinding)\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (isInvokedFunction(reference)) {\n              reference.parentPath.replaceWith(\n                import_compiler37.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, nodeBinding)\n                )\n              );\n            } else if (getterFnIdentifier) {\n              reference.replaceWith(\n                import_compiler37.types.callExpression(getterFnIdentifier, [\n                  getScopeExpression(referenceSection, getSection(tag))\n                ])\n              );\n            }\n          }\n        }\n      }\n      if (nodeBinding) {\n        visit(tag, 32 /* Get */);\n      }\n      enter2(tag);\n      writeTo(tag)`<!--`;\n    },\n    exit(tag) {\n      const tagSection = getSection(tag);\n      const tagExtra = tag.node.extra;\n      const nodeBinding = tagExtra[kNodeBinding];\n      const write2 = writeTo(tag);\n      if (isOutputHTML()) {\n        for (const child of tag.node.body.body) {\n          if (import_compiler37.types.isMarkoText(child)) {\n            write2`${child.value}`;\n          } else if (import_compiler37.types.isMarkoPlaceholder(child)) {\n            write2`${callRuntime(\"escapeXML\", child.value)}`;\n          }\n        }\n      } else {\n        const templateQuasis = [];\n        const templateExpressions = [];\n        let currentQuasi = \"\";\n        for (const child of tag.node.body.body) {\n          if (import_compiler37.types.isMarkoText(child)) {\n            currentQuasi += child.value;\n          } else if (import_compiler37.types.isMarkoPlaceholder(child)) {\n            templateQuasis.push(import_compiler37.types.templateElement({ raw: currentQuasi }));\n            templateExpressions.push(child.value);\n            currentQuasi = \"\";\n          }\n        }\n        if (templateExpressions.length === 0) {\n          write2`${currentQuasi}`;\n        } else {\n          templateQuasis.push(import_compiler37.types.templateElement({ raw: currentQuasi }));\n          addStatement(\n            \"render\",\n            getSection(tag),\n            tagExtra.referencedBindings,\n            import_compiler37.types.expressionStatement(\n              callRuntime(\n                \"data\",\n                import_compiler37.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(nodeBinding),\n                  true\n                ),\n                import_compiler37.types.templateLiteral(templateQuasis, templateExpressions)\n              )\n            )\n          );\n        }\n      }\n      exit2(tag);\n      write2`-->`;\n      if (nodeBinding) {\n        markNode(\n          tag,\n          nodeBinding,\n          getBindingSerializeReason(tagSection, nodeBinding)\n        );\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    text: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an html comment that is not stripped from the output.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#html-comment\"\n    }\n  ]\n};\n\n// src/translator/core/html-script.ts\nvar import_compiler38 = require(\"@marko/compiler\");\nvar import_babel_utils31 = require(\"@marko/compiler/babel-utils\");\nvar kNodeBinding2 = Symbol(\"script tag node binding\");\nvar kGetterId3 = Symbol(\"node getter id\");\nvar html_script_default = {\n  analyze(tag) {\n    (0, import_babel_utils31.assertNoArgs)(tag);\n    (0, import_babel_utils31.assertNoParams)(tag);\n    const { node } = tag;\n    if (node.var && !import_compiler38.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\n        \"Tag variables on native elements cannot be destructured.\"\n      );\n    }\n    const seen = {};\n    const { attributes } = tag.node;\n    let spreadReferenceNodes;\n    let attrExprExtras;\n    let hasEventHandlers = false;\n    let hasDynamicAttributes = false;\n    for (let i = attributes.length; i--; ) {\n      const attr2 = attributes[i];\n      const valueExtra = attr2.value.extra ??= {};\n      if (import_compiler38.types.isMarkoAttribute(attr2)) {\n        if (seen[attr2.name]) {\n          dropReferences(attr2.value);\n          continue;\n        }\n        seen[attr2.name] = attr2;\n        if (isEventHandler(attr2.name)) {\n          valueExtra.isEffect = true;\n          hasEventHandlers = true;\n        } else if (!evaluate(attr2.value).confident) {\n          hasDynamicAttributes = true;\n        }\n      } else if (import_compiler38.types.isMarkoSpreadAttribute(attr2)) {\n        valueExtra.isEffect = true;\n        hasEventHandlers = true;\n        hasDynamicAttributes = true;\n      }\n      if (spreadReferenceNodes) {\n        spreadReferenceNodes.push(attr2.value);\n      } else if (import_compiler38.types.isMarkoSpreadAttribute(attr2)) {\n        spreadReferenceNodes = [attr2.value];\n      } else {\n        attrExprExtras = push(attrExprExtras, valueExtra);\n      }\n    }\n    const bodyPlaceholderNodes = [];\n    let hasBodyPlaceholders = false;\n    for (const child of tag.node.body.body) {\n      if (import_compiler38.types.isMarkoPlaceholder(child)) {\n        bodyPlaceholderNodes.push(child.value);\n        hasBodyPlaceholders = true;\n      } else if (!import_compiler38.types.isMarkoText(child)) {\n        throw tag.hub.buildError(\n          child,\n          \"Invalid child. Only text is allowed inside an html-script.\"\n        );\n      }\n    }\n    if (node.var || hasEventHandlers || hasDynamicAttributes || hasBodyPlaceholders) {\n      const tagExtra = node.extra ??= {};\n      const tagSection = getOrCreateSection(tag);\n      const nodeBinding = tagExtra[kNodeBinding2] = createBinding(\n        \"#script\",\n        0 /* dom */,\n        tagSection\n      );\n      (0, import_babel_utils31.getProgram)().node.extra.isInteractive ||= hasEventHandlers;\n      if (spreadReferenceNodes) {\n        mergeReferences(tagSection, tag.node, spreadReferenceNodes);\n      }\n      if (bodyPlaceholderNodes.length > 1) {\n        mergeReferences(\n          tagSection,\n          bodyPlaceholderNodes[0],\n          bodyPlaceholderNodes.slice(1)\n        );\n      }\n      if (hasEventHandlers || spreadReferenceNodes) {\n        forceBindingSerialize(tagSection, nodeBinding);\n      }\n      if (node.var) {\n        forceBindingSerialize(tagSection, nodeBinding);\n        for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n          const refSection = getOrCreateSection(ref);\n          setReferencesScope(ref);\n          if (isSameOrChildSection(tagSection, refSection)) {\n            forceOwnersSerialize(\n              refSection,\n              tagSection,\n              getAccessorProp().Owner\n            );\n            if (!tagExtra[kGetterId3] && !isInvokedFunction(ref)) {\n              tagExtra[kGetterId3] = getRegisterUID(tagSection, \"#script\");\n            }\n          } else {\n            trackHoistedReference(ref, nodeBinding);\n          }\n        }\n      }\n      addBindingSerializeReasonExpr(\n        tagSection,\n        nodeBinding,\n        push(attrExprExtras, tagExtra)\n      );\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagExtra = tag.node.extra;\n      const nodeBinding = tagExtra[kNodeBinding2];\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(tag);\n      const tagSection = getSection(tag);\n      const hasVar = !!tag.node.var;\n      if (hasVar) {\n        const getterId = tagExtra[kGetterId3];\n        if (isHTML) {\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(tagSection),\n              getterId && import_compiler38.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);\n            (0, import_babel_utils31.getProgram)().node.body.push(\n              import_compiler38.types.variableDeclaration(\"const\", [\n                import_compiler38.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler38.types.stringLiteral(getterId),\n                    getScopeAccessorLiteral(nodeBinding)\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (isInvokedFunction(reference)) {\n              reference.parentPath.replaceWith(\n                import_compiler38.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, nodeBinding)\n                )\n              );\n            } else if (getterFnIdentifier) {\n              reference.replaceWith(\n                import_compiler38.types.callExpression(getterFnIdentifier, [\n                  getScopeExpression(referenceSection, getSection(tag))\n                ])\n              );\n            }\n          }\n        }\n      }\n      const visitAccessor = nodeBinding && getScopeAccessorLiteral(nodeBinding);\n      if (visitAccessor) {\n        visit(tag, 32 /* Get */);\n      }\n      write2`<script`;\n      const usedAttrs = getUsedAttrs2(tag.node);\n      const { staticAttrs, skipExpression, spreadExpression } = usedAttrs;\n      for (const attr2 of staticAttrs) {\n        const { name: name2, value } = attr2;\n        const { confident, computed } = value.extra || {};\n        const valueReferences = value.extra?.referencedBindings;\n        switch (name2) {\n          case \"class\":\n          case \"style\": {\n            const helper = `${name2}Attr`;\n            if (confident) {\n              write2`${getHTMLRuntime()[helper](computed)}`;\n            } else if (isHTML) {\n              write2`${callRuntime(helper, value)}`;\n            } else {\n              addStatement(\n                \"render\",\n                tagSection,\n                valueReferences,\n                import_compiler38.types.expressionStatement(\n                  callRuntime(\n                    helper,\n                    import_compiler38.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n          }\n          default:\n            if (confident) {\n              write2`${getHTMLRuntime().attr(name2, computed)}`;\n            } else if (isHTML) {\n              if (isEventHandler(name2)) {\n                addHTMLEffectCall(tagSection, valueReferences);\n              } else {\n                write2`${callRuntime(\"attr\", import_compiler38.types.stringLiteral(name2), value)}`;\n              }\n            } else if (isEventHandler(name2)) {\n              addStatement(\n                \"effect\",\n                tagSection,\n                valueReferences,\n                import_compiler38.types.expressionStatement(\n                  callRuntime(\n                    \"on\",\n                    import_compiler38.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler38.types.stringLiteral(getEventHandlerName(name2)),\n                    value\n                  )\n                )\n              );\n            } else {\n              addStatement(\n                \"render\",\n                tagSection,\n                valueReferences,\n                import_compiler38.types.expressionStatement(\n                  callRuntime(\n                    \"attr\",\n                    import_compiler38.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler38.types.stringLiteral(name2),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n        }\n      }\n      if (spreadExpression) {\n        if (isHTML) {\n          addHTMLEffectCall(tagSection, tagExtra.referencedBindings);\n          if (skipExpression) {\n            write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(tagSection), import_compiler38.types.stringLiteral(\"script\"))}`;\n          } else {\n            write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(tagSection), import_compiler38.types.stringLiteral(\"script\"))}`;\n          }\n        } else {\n          if (skipExpression) {\n            addStatement(\n              \"render\",\n              tagSection,\n              tagExtra.referencedBindings,\n              import_compiler38.types.expressionStatement(\n                callRuntime(\n                  \"partialAttrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression,\n                  skipExpression\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              tagSection,\n              tagExtra.referencedBindings,\n              import_compiler38.types.expressionStatement(\n                callRuntime(\n                  \"attrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression\n                )\n              )\n            );\n          }\n          addStatement(\n            \"effect\",\n            tagSection,\n            tagExtra.referencedBindings,\n            import_compiler38.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            false\n          );\n        }\n      }\n      write2`>`;\n      enter2(tag);\n    },\n    exit(tag) {\n      const tagSection = getSection(tag);\n      const tagExtra = tag.node.extra;\n      const nodeBinding = tagExtra[kNodeBinding2];\n      const write2 = writeTo(tag);\n      if (isOutputHTML()) {\n        for (const child of tag.node.body.body) {\n          if (import_compiler38.types.isMarkoText(child)) {\n            write2`${child.value}`;\n          } else if (import_compiler38.types.isMarkoPlaceholder(child)) {\n            write2`${callRuntime(\"escapeScript\", child.value)}`;\n          }\n        }\n      } else {\n        const templateQuasis = [];\n        const templateExpressions = [];\n        let currentQuasi = \"\";\n        let referencePlaceholder;\n        for (const child of tag.node.body.body) {\n          if (import_compiler38.types.isMarkoText(child)) {\n            currentQuasi += child.value;\n          } else if (import_compiler38.types.isMarkoPlaceholder(child)) {\n            referencePlaceholder ||= child;\n            templateQuasis.push(import_compiler38.types.templateElement({ raw: currentQuasi }));\n            templateExpressions.push(child.value);\n            currentQuasi = \"\";\n          }\n        }\n        if (!referencePlaceholder) {\n          write2`${currentQuasi}`;\n        } else {\n          templateQuasis.push(import_compiler38.types.templateElement({ raw: currentQuasi }));\n          addStatement(\n            \"render\",\n            getSection(tag),\n            referencePlaceholder.value.extra?.referencedBindings,\n            import_compiler38.types.expressionStatement(\n              callRuntime(\n                \"textContent\",\n                import_compiler38.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(nodeBinding),\n                  true\n                ),\n                import_compiler38.types.templateLiteral(templateQuasis, templateExpressions)\n              )\n            )\n          );\n        }\n      }\n      write2`</script>`;\n      if (nodeBinding) {\n        markNode(\n          tag,\n          nodeBinding,\n          getBindingSerializeReason(tagSection, nodeBinding)\n        );\n      }\n      exit2(tag);\n      tag.remove();\n    }\n  },\n  \"@async\": \"#html-async\",\n  \"@crossorigin\": \"#html-crossorigin\",\n  \"@defer\": \"#html-defer\",\n  \"@integrity\": \"#html-integrity\",\n  \"@nomodule\": \"#html-nomodule\",\n  \"@nonce\": \"#html-nonce\",\n  \"@referrerpolicy\": \"#html-referrerpolicy\",\n  \"@src\": \"#html-src\",\n  \"@type\": \"#html-type\",\n  \"attribute-groups\": [\"html-attributes\"],\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  }\n};\nfunction getUsedAttrs2(tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler38.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n      }\n      spreadProps.push(import_compiler38.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler38.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler38.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    spreadExpression,\n    skipExpression\n  };\n}\n\n// src/translator/core/html-style.ts\nvar import_compiler39 = require(\"@marko/compiler\");\nvar import_babel_utils32 = require(\"@marko/compiler/babel-utils\");\nvar kNodeBinding3 = Symbol(\"style tag node binding\");\nvar kGetterId4 = Symbol(\"node getter id\");\nvar html_style_default = {\n  analyze(tag) {\n    (0, import_babel_utils32.assertNoArgs)(tag);\n    (0, import_babel_utils32.assertNoParams)(tag);\n    const { node } = tag;\n    if (node.var && !import_compiler39.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\n        \"Tag variables on native elements cannot be destructured.\"\n      );\n    }\n    const seen = {};\n    const { attributes } = tag.node;\n    let spreadReferenceNodes;\n    let attrExprExtras;\n    let hasEventHandlers = false;\n    let hasDynamicAttributes = false;\n    for (let i = attributes.length; i--; ) {\n      const attr2 = attributes[i];\n      const valueExtra = attr2.value.extra ??= {};\n      if (import_compiler39.types.isMarkoAttribute(attr2)) {\n        if (seen[attr2.name]) {\n          dropReferences(attr2.value);\n          continue;\n        }\n        seen[attr2.name] = attr2;\n        if (isEventHandler(attr2.name)) {\n          valueExtra.isEffect = true;\n          hasEventHandlers = true;\n        } else if (!evaluate(attr2.value).confident) {\n          hasDynamicAttributes = true;\n        }\n      } else if (import_compiler39.types.isMarkoSpreadAttribute(attr2)) {\n        valueExtra.isEffect = true;\n        hasEventHandlers = true;\n        hasDynamicAttributes = true;\n      }\n      if (spreadReferenceNodes) {\n        spreadReferenceNodes.push(attr2.value);\n      } else if (import_compiler39.types.isMarkoSpreadAttribute(attr2)) {\n        spreadReferenceNodes = [attr2.value];\n      } else {\n        attrExprExtras = push(attrExprExtras, valueExtra);\n      }\n    }\n    const bodyPlaceholderNodes = [];\n    let hasBodyPlaceholders = false;\n    for (const child of tag.node.body.body) {\n      if (import_compiler39.types.isMarkoPlaceholder(child)) {\n        bodyPlaceholderNodes.push(child.value);\n        hasBodyPlaceholders = true;\n      } else if (!import_compiler39.types.isMarkoText(child)) {\n        throw tag.hub.buildError(\n          child,\n          \"Invalid child. Only text is allowed inside an html-style.\"\n        );\n      }\n    }\n    if (node.var || hasEventHandlers || hasDynamicAttributes || hasBodyPlaceholders) {\n      const tagExtra = node.extra ??= {};\n      const tagSection = getOrCreateSection(tag);\n      const nodeBinding = tagExtra[kNodeBinding3] = createBinding(\n        \"#style\",\n        0 /* dom */,\n        tagSection\n      );\n      (0, import_babel_utils32.getProgram)().node.extra.isInteractive ||= hasEventHandlers;\n      if (spreadReferenceNodes) {\n        mergeReferences(tagSection, tag.node, spreadReferenceNodes);\n      }\n      if (bodyPlaceholderNodes.length > 1) {\n        mergeReferences(\n          tagSection,\n          bodyPlaceholderNodes[0],\n          bodyPlaceholderNodes.slice(1)\n        );\n      }\n      if (hasEventHandlers || spreadReferenceNodes) {\n        forceBindingSerialize(tagSection, nodeBinding);\n      }\n      if (node.var) {\n        forceBindingSerialize(tagSection, nodeBinding);\n        for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n          const refSection = getOrCreateSection(ref);\n          setReferencesScope(ref);\n          if (isSameOrChildSection(tagSection, refSection)) {\n            forceOwnersSerialize(\n              refSection,\n              tagSection,\n              getAccessorProp().Owner\n            );\n            if (!tagExtra[kGetterId4] && !isInvokedFunction(ref)) {\n              tagExtra[kGetterId4] = getRegisterUID(tagSection, \"#style\");\n            }\n          } else {\n            trackHoistedReference(ref, nodeBinding);\n          }\n        }\n      }\n      addBindingSerializeReasonExpr(\n        tagSection,\n        nodeBinding,\n        push(attrExprExtras, tagExtra)\n      );\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagExtra = tag.node.extra;\n      const nodeBinding = tagExtra[kNodeBinding3];\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(tag);\n      const tagSection = getSection(tag);\n      const hasVar = !!tag.node.var;\n      if (hasVar) {\n        const getterId = tagExtra[kGetterId4];\n        if (isHTML) {\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(tagSection),\n              getterId && import_compiler39.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);\n            (0, import_babel_utils32.getProgram)().node.body.push(\n              import_compiler39.types.variableDeclaration(\"const\", [\n                import_compiler39.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler39.types.stringLiteral(getterId),\n                    getScopeAccessorLiteral(nodeBinding)\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (isInvokedFunction(reference)) {\n              reference.parentPath.replaceWith(\n                import_compiler39.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, nodeBinding)\n                )\n              );\n            } else if (getterFnIdentifier) {\n              reference.replaceWith(\n                import_compiler39.types.callExpression(getterFnIdentifier, [\n                  getScopeExpression(referenceSection, getSection(tag))\n                ])\n              );\n            }\n          }\n        }\n      }\n      const visitAccessor = nodeBinding && getScopeAccessorLiteral(nodeBinding);\n      if (visitAccessor) {\n        visit(tag, 32 /* Get */);\n      }\n      write2`<style`;\n      const usedAttrs = getUsedAttrs3(tag.node);\n      const { staticAttrs, skipExpression, spreadExpression } = usedAttrs;\n      for (const attr2 of staticAttrs) {\n        const { name: name2, value } = attr2;\n        const { confident, computed } = value.extra || {};\n        const valueReferences = value.extra?.referencedBindings;\n        switch (name2) {\n          case \"class\":\n          case \"style\": {\n            const helper = `${name2}Attr`;\n            if (confident) {\n              write2`${getHTMLRuntime()[helper](computed)}`;\n            } else if (isHTML) {\n              write2`${callRuntime(helper, value)}`;\n            } else {\n              addStatement(\n                \"render\",\n                tagSection,\n                valueReferences,\n                import_compiler39.types.expressionStatement(\n                  callRuntime(\n                    helper,\n                    import_compiler39.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n          }\n          default:\n            if (confident) {\n              write2`${getHTMLRuntime().attr(name2, computed)}`;\n            } else if (isHTML) {\n              if (isEventHandler(name2)) {\n                addHTMLEffectCall(tagSection, valueReferences);\n              } else {\n                write2`${callRuntime(\"attr\", import_compiler39.types.stringLiteral(name2), value)}`;\n              }\n            } else if (isEventHandler(name2)) {\n              addStatement(\n                \"effect\",\n                tagSection,\n                valueReferences,\n                import_compiler39.types.expressionStatement(\n                  callRuntime(\n                    \"on\",\n                    import_compiler39.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler39.types.stringLiteral(getEventHandlerName(name2)),\n                    value\n                  )\n                )\n              );\n            } else {\n              addStatement(\n                \"render\",\n                tagSection,\n                valueReferences,\n                import_compiler39.types.expressionStatement(\n                  callRuntime(\n                    \"attr\",\n                    import_compiler39.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler39.types.stringLiteral(name2),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n        }\n      }\n      if (spreadExpression) {\n        if (isHTML) {\n          addHTMLEffectCall(tagSection, tagExtra.referencedBindings);\n          if (skipExpression) {\n            write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(tagSection), import_compiler39.types.stringLiteral(\"style\"))}`;\n          } else {\n            write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(tagSection), import_compiler39.types.stringLiteral(\"style\"))}`;\n          }\n        } else {\n          if (skipExpression) {\n            addStatement(\n              \"render\",\n              tagSection,\n              tagExtra.referencedBindings,\n              import_compiler39.types.expressionStatement(\n                callRuntime(\n                  \"partialAttrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression,\n                  skipExpression\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              tagSection,\n              tagExtra.referencedBindings,\n              import_compiler39.types.expressionStatement(\n                callRuntime(\n                  \"attrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression\n                )\n              )\n            );\n          }\n          addStatement(\n            \"effect\",\n            tagSection,\n            tagExtra.referencedBindings,\n            import_compiler39.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            false\n          );\n        }\n      }\n      write2`>`;\n      enter2(tag);\n    },\n    exit(tag) {\n      const tagSection = getSection(tag);\n      const tagExtra = tag.node.extra;\n      const nodeBinding = tagExtra[kNodeBinding3];\n      const write2 = writeTo(tag);\n      if (isOutputHTML()) {\n        for (const child of tag.node.body.body) {\n          if (import_compiler39.types.isMarkoText(child)) {\n            write2`${child.value}`;\n          } else if (import_compiler39.types.isMarkoPlaceholder(child)) {\n            write2`${callRuntime(\"escapeStyle\", child.value)}`;\n          }\n        }\n      } else {\n        const templateQuasis = [];\n        const templateExpressions = [];\n        let currentQuasi = \"\";\n        let referencePlaceholder;\n        for (const child of tag.node.body.body) {\n          if (import_compiler39.types.isMarkoText(child)) {\n            currentQuasi += child.value;\n          } else if (import_compiler39.types.isMarkoPlaceholder(child)) {\n            referencePlaceholder ||= child;\n            templateQuasis.push(import_compiler39.types.templateElement({ raw: currentQuasi }));\n            templateExpressions.push(child.value);\n            currentQuasi = \"\";\n          }\n        }\n        if (!referencePlaceholder) {\n          write2`${currentQuasi}`;\n        } else {\n          templateQuasis.push(import_compiler39.types.templateElement({ raw: currentQuasi }));\n          addStatement(\n            \"render\",\n            getSection(tag),\n            referencePlaceholder.value.extra?.referencedBindings,\n            import_compiler39.types.expressionStatement(\n              callRuntime(\n                \"textContent\",\n                import_compiler39.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(nodeBinding),\n                  true\n                ),\n                import_compiler39.types.templateLiteral(templateQuasis, templateExpressions)\n              )\n            )\n          );\n        }\n      }\n      write2`</style>`;\n      if (nodeBinding) {\n        markNode(\n          tag,\n          nodeBinding,\n          getBindingSerializeReason(tagSection, nodeBinding)\n        );\n      }\n      exit2(tag);\n      tag.remove();\n    }\n  },\n  \"@disabled\": \"#html-disabled\",\n  \"@media\": \"#html-media\",\n  \"@nonce\": \"#html-nonce\",\n  \"@type\": \"#html-type\",\n  \"attribute-groups\": [\"html-attributes\"],\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  }\n};\nfunction getUsedAttrs3(tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler39.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n      }\n      spreadProps.push(import_compiler39.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler39.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler39.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    spreadExpression,\n    skipExpression\n  };\n}\n\n// src/translator/core/id.ts\nvar import_compiler40 = require(\"@marko/compiler\");\nvar import_babel_utils33 = require(\"@marko/compiler/babel-utils\");\nvar id_default = {\n  analyze(tag) {\n    (0, import_babel_utils33.assertNoArgs)(tag);\n    (0, import_babel_utils33.assertNoParams)(tag);\n    (0, import_babel_utils33.assertNoAttributes)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils33.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `id` tag requires a tag variable.\");\n    }\n    if (!import_compiler40.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `id` tag cannot be destructured\");\n    }\n    const binding = trackVarReferences(tag, 4 /* derived */);\n    if (binding) {\n      setBindingValueExpr(binding, false);\n    }\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const id = isOutputHTML() ? callRuntime(\"nextTagId\") : callRuntime(\"nextTagId\", scopeIdentifier);\n      if (isOutputHTML()) {\n        tag.replaceWith(\n          import_compiler40.types.variableDeclaration(\"const\", [import_compiler40.types.variableDeclarator(node.var, id)])\n        );\n      } else {\n        const source = initValue(node.var.extra.binding);\n        addValue(getSection(tag), void 0, source, id);\n        tag.remove();\n      }\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"id/<name>\",\n      description: \"Use to create a unique identifier.\",\n      snippet: \"id/${1:name}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#id\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/id.d.marko\"\n};\n\n// src/translator/core/if.ts\nvar import_compiler42 = require(\"@marko/compiler\");\nvar import_babel_utils34 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/to-first-statement-or-block.ts\nvar import_compiler41 = require(\"@marko/compiler\");\nfunction toFirstStatementOrBlock(body) {\n  if (Array.isArray(body)) {\n    if (body.length === 1) {\n      return body[0];\n    }\n    return import_compiler41.types.blockStatement(body);\n  }\n  return body;\n}\n\n// src/translator/core/if.ts\nvar BRANCHES_LOOKUP = /* @__PURE__ */ new WeakMap();\nvar IfTag = {\n  analyze(tag) {\n    assertValidCondition(tag);\n    if (tag.node.body.attributeTags) return;\n    if (isLastBranch(tag)) {\n      const branches = getBranches(tag);\n      const [ifTag] = branches[0];\n      const ifTagSection = getOrCreateSection(ifTag);\n      const ifTagExtra = ifTag.node.extra ??= {};\n      const mergeReferenceNodes = [];\n      const nodeBinding = getOptimizedOnlyChildNodeBinding(\n        ifTag,\n        ifTagSection,\n        branches.length\n      );\n      const sectionAccessor = {\n        binding: nodeBinding,\n        prefix: getAccessorPrefix().ConditionalScope\n      };\n      let singleNodeOptimization = true;\n      for (const [branchTag, branchBodySection] of branches) {\n        if (branchBodySection) {\n          singleNodeOptimization &&= branchBodySection.content === null || branchBodySection.content?.singleChild && branchBodySection.content.startType !== 4 /* Text */;\n          branchBodySection.isBranch = true;\n          branchBodySection.upstreamExpression = ifTagExtra;\n          branchBodySection.sectionAccessor = sectionAccessor;\n        }\n        if (branchTag.node.attributes.length) {\n          mergeReferenceNodes.push(branchTag.node.attributes[0].value);\n        }\n      }\n      mergeReferences(ifTagSection, ifTag.node, mergeReferenceNodes);\n      ifTagExtra.singleNodeOptimization = singleNodeOptimization;\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (isRoot(tag) && !getOnlyChildParentTagName(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n        flushBefore(tag);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (bodySection) {\n          flushInto(tag);\n          writeHTMLResumeStatements(tagBody);\n        }\n        if (isLastBranch(tag)) {\n          const branches = getBranches(tag);\n          const [ifTag] = branches[0];\n          const ifTagSection = getSection(ifTag);\n          const ifTagExtra = ifTag.node.extra;\n          const singleNodeOptimization = ifTagExtra.singleNodeOptimization;\n          const nodeBinding = getOptimizedOnlyChildNodeBinding(\n            ifTag,\n            ifTagSection\n          );\n          const onlyChildParentTagName = getOnlyChildParentTagName(ifTag);\n          const markerSerializeReason = getBindingSerializeReason(\n            ifTagSection,\n            nodeBinding\n          );\n          const nextTag = tag.getNextSibling();\n          let branchSerializeReasons;\n          let statement;\n          for (let i = branches.length; i--; ) {\n            const [branchTag, branchBody] = branches[i];\n            const bodyStatements = branchTag.node.body.body;\n            if (branchBody) {\n              const branchSerializeReason = getSectionSerializeReason(\n                branchBody,\n                kBranchSerializeReason\n              );\n              if (branchSerializeReason) {\n                if (branchSerializeReasons !== true) {\n                  if (branchSerializeReason === true || branchSerializeReason.state) {\n                    branchSerializeReasons = true;\n                  } else if (branchSerializeReasons) {\n                    branchSerializeReasons = addSorted(\n                      compareSources,\n                      branchSerializeReasons,\n                      branchSerializeReason\n                    );\n                  } else {\n                    branchSerializeReasons = [branchSerializeReason];\n                  }\n                }\n                bodyStatements.push(\n                  import_compiler42.types.returnStatement(import_compiler42.types.numericLiteral(i))\n                );\n              }\n            }\n            const [testAttr] = branchTag.node.attributes;\n            const curStatement = toFirstStatementOrBlock(bodyStatements);\n            if (testAttr) {\n              statement = import_compiler42.types.ifStatement(\n                testAttr.value,\n                curStatement,\n                statement\n              );\n            } else {\n              statement = curStatement;\n            }\n            branchTag.remove();\n          }\n          if (branchSerializeReasons) {\n            const skipParentEnd = onlyChildParentTagName && markerSerializeReason;\n            if (skipParentEnd) {\n              getParentTag(ifTag).node.extra[kSkipEndTag] = true;\n            }\n            const markerSerializeArg = getSerializeGuard(\n              markerSerializeReason,\n              !(skipParentEnd || singleNodeOptimization)\n            );\n            const cbNode = import_compiler42.types.arrowFunctionExpression(\n              [],\n              import_compiler42.types.blockStatement([statement])\n            );\n            statement = import_compiler42.types.expressionStatement(\n              callRuntime(\n                \"resumeConditional\",\n                cbNode,\n                getScopeIdIdentifier(ifTagSection),\n                getScopeAccessorLiteral(nodeBinding),\n                getSerializeGuardForAny(\n                  branchSerializeReasons,\n                  !markerSerializeArg\n                ),\n                markerSerializeArg,\n                skipParentEnd ? import_compiler42.types.stringLiteral(`</${onlyChildParentTagName}>`) : singleNodeOptimization ? import_compiler42.types.numericLiteral(0) : void 0,\n                singleNodeOptimization ? import_compiler42.types.numericLiteral(1) : void 0\n              )\n            );\n          }\n          nextTag.insertBefore(statement);\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n        }\n        if (isRoot(tag) && !getOnlyChildParentTagName(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        if (isLastBranch(tag)) {\n          const branches = getBranches(tag);\n          const [ifTag] = branches[0];\n          const ifTagSection = getSection(ifTag);\n          const ifTagExtra = branches[0][0].node.extra;\n          const nodeRef2 = getOptimizedOnlyChildNodeBinding(ifTag, ifTagSection);\n          const rendererIdentifiers = [];\n          let expr = import_compiler42.types.numericLiteral(branches.length);\n          for (let i = branches.length; i--; ) {\n            const [branchTag, branchBodySection] = branches[i];\n            const [testAttr] = branchTag.node.attributes;\n            const consequent = import_compiler42.types.numericLiteral(branchBodySection ? i : -1);\n            if (branchBodySection) {\n              rendererIdentifiers.push(import_compiler42.types.identifier(branchBodySection.name));\n              setClosureSignalBuilder(branchTag, (closure, render) => {\n                return callRuntime(\n                  \"conditionalClosure\",\n                  getScopeAccessorLiteral(closure),\n                  getScopeAccessorLiteral(nodeRef2),\n                  import_compiler42.types.numericLiteral(i),\n                  render\n                );\n              });\n            }\n            branchTag.remove();\n            expr = testAttr ? import_compiler42.types.conditionalExpression(testAttr.value, consequent, expr) : consequent;\n          }\n          const signal = getSignal(ifTagSection, nodeRef2, \"if\");\n          signal.build = () => {\n            return callRuntime(\n              \"conditional\",\n              getScopeAccessorLiteral(nodeRef2),\n              ...rendererIdentifiers.reverse()\n            );\n          };\n          addValue(ifTagSection, ifTagExtra.referencedBindings, signal, expr);\n        }\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  autocomplete: [\n    {\n      snippet: \"if=${1:condition}\",\n      description: \"Use to display content only if the condition is met.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseIfTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      snippet: \"else-if=${1:condition}\",\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nfunction assertValidCondition(tag) {\n  (0, import_babel_utils34.assertNoVar)(tag);\n  (0, import_babel_utils34.assertNoArgs)(tag);\n  (0, import_babel_utils34.assertNoParams)(tag);\n  assertHasBody(tag);\n  assertNoSpreadAttrs(tag);\n  switch (getTagName(tag)) {\n    case \"if\":\n      assertHasValueAttribute(tag);\n      break;\n    case \"else-if\":\n      assertHasValueAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n    case \"else\":\n      assertOptionalIfAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n  }\n}\nfunction assertHasPrecedingCondition(tag) {\n  let prev = tag.getPrevSibling();\n  while (prev.node && prev.isMarkoComment()) prev = prev.getPrevSibling();\n  if (!isConditionTag(prev) || getTagName(prev) !== \"else\" && !prev.node.attributes.length) {\n    throw tag.buildCodeFrameError(\n      `The \\`<${getTagName(tag)}>\\` must have a preceding \\`<if=cond>\\`, \\`<else-if=cond>\\`, or \\`<else if=cond>\\`.`\n    );\n  }\n}\nfunction assertHasBody(tag) {\n  if (!(tag.node.body.body.length || tag.node.attributeTags.length)) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${getTagName(tag)}\\` tag requires body content.`\n    );\n  }\n}\nfunction assertHasValueAttribute(tag) {\n  const { node } = tag;\n  const [valueAttr] = node.attributes;\n  if (!import_compiler42.types.isMarkoAttribute(valueAttr) || !valueAttr.default) {\n    throw tag.get(\"name\").buildCodeFrameError(`The \\`${getTagName(tag)}\\` tag requires a value.`);\n  }\n  if (node.attributes.length > 1) {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports the \\`value\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction assertOptionalIfAttribute(tag) {\n  const { node } = tag;\n  const [ifAttr] = node.attributes;\n  if (node.attributes.length > 1 || ifAttr && ifAttr.name !== \"if\") {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports an \\`if=\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction getBranches(tag) {\n  let branches = BRANCHES_LOOKUP.get(tag);\n  if (!branches) {\n    let curTag = tag;\n    branches = [];\n    do {\n      BRANCHES_LOOKUP.set(curTag, branches);\n      branches.push([\n        curTag,\n        startSection(curTag.get(\"body\"))\n      ]);\n      while ((curTag = curTag.getNextSibling()).isMarkoComment()) ;\n    } while (isCoreTagName(curTag, \"else\") || isCoreTagName(curTag, \"else-if\"));\n  }\n  return branches;\n}\nfunction isLastBranch(tag) {\n  const branches = getBranches(tag);\n  return branches[branches.length - 1][0] === tag;\n}\nfunction isRoot(tag) {\n  return isCoreTagName(tag, \"if\");\n}\n\n// src/translator/core/import.ts\nvar import_babel_utils35 = require(\"@marko/compiler/babel-utils\");\nvar import_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils35.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: 'import <scope> from \"<path>\"',\n      description: \"Use to import external modules, follows the same syntax as JavaScript imports.\",\n      snippet: 'import ${2} from \"${1:path}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#importing-external-files\"\n    }\n  ]\n};\n\n// src/translator/core/let.ts\nvar import_compiler43 = require(\"@marko/compiler\");\nvar import_babel_utils36 = require(\"@marko/compiler/babel-utils\");\nvar let_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    let valueAttr;\n    let valueChangeAttr;\n    for (const attr2 of node.attributes) {\n      if (import_compiler43.types.isMarkoAttribute(attr2)) {\n        if (attr2.name === \"value\") {\n          valueAttr = attr2;\n        } else if (attr2.name === \"valueChange\") {\n          valueChangeAttr = attr2;\n        } else {\n          const start = attr2.loc?.start;\n          const end = attr2.loc?.end;\n          const msg = \"The `let` tag only supports the `value` attribute and its change handler.\";\n          if (start == null || end == null) {\n            throw tag.get(\"name\").buildCodeFrameError(msg);\n          } else {\n            throw tag.hub.buildError(\n              { loc: { start, end } },\n              msg,\n              Error\n            );\n          }\n        }\n      }\n    }\n    (0, import_babel_utils36.assertNoArgs)(tag);\n    (0, import_babel_utils36.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    if (!tagVar) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `let` tag requires a tag variable.\");\n    }\n    if (!import_compiler43.types.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `let` tag variable cannot be destructured.\");\n    }\n    if (valueChangeAttr && (0, import_babel_utils36.computeNode)(valueChangeAttr.value)) {\n      throw tag.get(\"attributes\").find((attr2) => attr2.node === valueChangeAttr).get(\"value\").buildCodeFrameError(\n        \"The `let` tag `valueChange` attribute must be a function.\"\n      );\n    }\n    const tagSection = getOrCreateSection(tag);\n    const binding = trackVarReferences(tag, 1 /* let */);\n    setBindingValueExpr(\n      binding,\n      mergeReferences(tagSection, tag.node, [\n        valueAttr?.value,\n        valueChangeAttr?.value\n      ])\n    );\n    if (valueChangeAttr) {\n      forceBindingSerialize(\n        tagSection,\n        binding,\n        getAccessorPrefix().TagVariableChange\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const tagVar = node.var;\n      const valueAttr = node.attributes.find(\n        (attr2) => import_compiler43.types.isMarkoAttribute(attr2) && (attr2.default || attr2.name === \"value\")\n      ) ?? import_compiler43.types.markoAttribute(\"value\", import_compiler43.types.identifier(\"undefined\"));\n      const valueChangeAttr = node.attributes.find(\n        (attr2) => import_compiler43.types.isMarkoAttribute(attr2) && attr2.name === \"valueChange\"\n      );\n      const section = getSection(tag);\n      const binding = tagVar.extra.binding;\n      if (isOutputDOM()) {\n        const signal = initValue(binding, \"state\");\n        const referencedBindings = tag.node.extra.referencedBindings;\n        addValue(section, referencedBindings, signal, valueAttr.value);\n        if (valueChangeAttr) {\n          signal.extraArgs = [valueChangeAttr.value];\n        }\n        signal.buildAssignment = (valueSection, value) => {\n          const scope = getScopeExpression(valueSection, signal.section);\n          return import_compiler43.types.callExpression(signal.identifier, [scope, value]);\n        };\n      } else {\n        translateVar(tag, valueAttr.value, \"let\");\n        if (valueChangeAttr) {\n          setBindingSerializedValue(\n            section,\n            binding,\n            valueChangeAttr.value,\n            getAccessorPrefix().TagVariableChange\n          );\n        }\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a mutable binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#let\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/let.d.marko\"\n};\n\n// src/translator/core/lifecycle.ts\nvar import_compiler44 = require(\"@marko/compiler\");\nvar import_babel_utils37 = require(\"@marko/compiler/babel-utils\");\nvar kRef = Symbol(\"lifecycle attrs reference\");\nvar lifecycle_default = {\n  analyze(tag) {\n    (0, import_babel_utils37.assertNoArgs)(tag);\n    (0, import_babel_utils37.assertNoVar)(tag);\n    (0, import_babel_utils37.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const section = getOrCreateSection(tag);\n    const tagExtra = mergeReferences(\n      section,\n      tag.node,\n      getAllTagReferenceNodes(tag.node)\n    );\n    tagExtra[kRef] = createBinding(\n      generateUid(\"lifecycle\"),\n      4 /* derived */,\n      section\n    );\n    if (node.attributes.length === 0) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `lifecycle` tag requires at least one attribute.\"\n      );\n    }\n    for (const attr2 of node.attributes) {\n      if (import_compiler44.types.isMarkoSpreadAttribute(attr2)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The `lifecycle` tag does not support `...spread` attributes.\"\n        );\n      }\n      (attr2.value.extra ??= {}).isEffect = true;\n    }\n    ((0, import_babel_utils37.getProgram)().node.extra ??= {}).isInteractive = true;\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const section = getSection(tag);\n      const tagExtra = node.extra;\n      const { referencedBindings } = tagExtra;\n      const lifecycleAttrsRef = tagExtra[kRef];\n      if (isOutputDOM()) {\n        const translatedAttrs = translateAttrs(tag);\n        translatedAttrs.statements.push(\n          import_compiler44.types.expressionStatement(\n            callRuntime(\n              \"lifecycle\",\n              scopeIdentifier,\n              getScopeAccessorLiteral(lifecycleAttrsRef),\n              propsToExpression(translatedAttrs.properties)\n            )\n          )\n        );\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          translatedAttrs.statements\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/lifecycle.d.marko\"\n};\n\n// src/translator/core/log.ts\nvar import_compiler45 = require(\"@marko/compiler\");\nvar import_babel_utils38 = require(\"@marko/compiler/babel-utils\");\nvar log_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils38.assertNoArgs)(tag);\n    (0, import_babel_utils38.assertNoVar)(tag);\n    (0, import_babel_utils38.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `log` tag requires a value.\");\n    }\n    if (tag.node.attributes.length > 1 || !import_compiler45.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `log` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      const statement = import_compiler45.types.expressionStatement(\n        import_compiler45.types.callExpression(\n          import_compiler45.types.memberExpression(import_compiler45.types.identifier(\"console\"), import_compiler45.types.identifier(\"log\")),\n          [value]\n        )\n      );\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to log a value to the console.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#log\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/log.d.marko\"\n};\n\n// src/translator/core/script.ts\nvar import_compiler46 = require(\"@marko/compiler\");\nvar import_babel_utils39 = require(\"@marko/compiler/babel-utils\");\nvar htmlScriptTagAlternateMsg = \" For a native html `script` tag use the `html-script` core tag instead.\";\nvar script_default = {\n  parse(tag) {\n    const { node } = tag;\n    const { body } = node.body;\n    if (body.length) {\n      let code = \"\";\n      for (const child of body) {\n        if (child.type !== \"MarkoText\") {\n          throw tag.hub.file.hub.buildError(\n            child,\n            \"Unexpected content in `script` tag. Only javascript and typescript is supported.\" + htmlScriptTagAlternateMsg,\n            SyntaxError\n          );\n        }\n        code += child.value;\n      }\n      const start = body[0]?.start;\n      const end = body[body.length - 1]?.end;\n      const bodyStatements = (0, import_babel_utils39.parseStatements)(tag.hub.file, code, start, end);\n      const valueFn = import_compiler46.types.arrowFunctionExpression(\n        [],\n        import_compiler46.types.blockStatement(bodyStatements),\n        traverseContains(bodyStatements, isAwaitExpression)\n      );\n      node.attributes.push(import_compiler46.types.markoAttribute(\"value\", valueFn));\n      node.body.body = [];\n    }\n  },\n  analyze(tag) {\n    const { node } = tag;\n    (0, import_babel_utils39.assertNoArgs)(tag);\n    (0, import_babel_utils39.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils39.assertNoAttributeTags)(tag);\n    if (node.var) {\n      throw tag.hub.buildError(\n        node.var,\n        \"The `script` tag does not support a tag variable reference.\" + htmlScriptTagAlternateMsg\n      );\n    }\n    let seenValueAttr = false;\n    for (const attr2 of node.attributes) {\n      if (attr2.type === \"MarkoAttribute\" && attr2.name === \"value\") {\n        if (seenValueAttr) {\n          throw tag.hub.buildError(attr2, \"Invalid duplicate value attribute.\");\n        }\n        seenValueAttr = true;\n        (attr2.value.extra ??= {}).isEffect = true;\n        ((0, import_babel_utils39.getProgram)().node.extra ??= {}).isInteractive = true;\n      } else {\n        throw tag.hub.buildError(\n          attr2,\n          \"The `script` tag does not support html attributes.\" + htmlScriptTagAlternateMsg\n        );\n      }\n    }\n    if (!seenValueAttr) {\n      dropReferences(getAllTagReferenceNodes(node));\n    }\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      if (!valueAttr) {\n        tag.remove();\n        return;\n      }\n      const section = getSection(tag);\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      if (isOutputDOM()) {\n        const { value: value2 } = valueAttr;\n        const isFunction2 = import_compiler46.types.isFunctionExpression(value2) || import_compiler46.types.isArrowFunctionExpression(value2);\n        let inlineBody = null;\n        if (isFunction2 && !(value2.async || value2.generator)) {\n          if (import_compiler46.types.isBlockStatement(value2.body)) {\n            let hasDeclaration = false;\n            for (const child of value2.body.body) {\n              if (import_compiler46.types.isDeclaration(child)) {\n                hasDeclaration = true;\n                break;\n              }\n            }\n            inlineBody = hasDeclaration ? value2.body : value2.body.body;\n          } else {\n            inlineBody = import_compiler46.types.expressionStatement(value2.body);\n          }\n        }\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          inlineBody || import_compiler46.types.expressionStatement(\n            import_compiler46.types.callExpression(value2, isFunction2 ? [] : [scopeIdentifier])\n          )\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  html: false,\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#script\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/script.d.marko\"\n};\nfunction isAwaitExpression(node) {\n  switch (node.type) {\n    case \"ForOfStatement\":\n      return node.await;\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ObjectMethod\":\n    case \"ClassPrivateMethod\":\n      return skip;\n    case \"AwaitExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// src/translator/core/server.ts\nvar import_compiler47 = require(\"@marko/compiler\");\nvar import_babel_utils40 = require(\"@marko/compiler/babel-utils\");\nvar server_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^server\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils40.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler47.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler47.types.markoScriptlet(body, true, \"server\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"server <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the server.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#server-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/static.ts\nvar import_compiler48 = require(\"@marko/compiler\");\nvar import_babel_utils41 = require(\"@marko/compiler/babel-utils\");\nvar static_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^static\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils41.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler48.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler48.types.markoScriptlet(body, true));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"static <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#static-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/style.ts\nvar import_compiler49 = require(\"@marko/compiler\");\nvar import_babel_utils42 = require(\"@marko/compiler/babel-utils\");\nvar import_magic_string = __toESM(require(\"magic-string\"));\nvar import_path3 = __toESM(require(\"path\"));\nvar STYLE_EXT_REG = /^style((?:\\.[a-zA-Z0-9$_-]+)+)?/;\nvar htmlStyleTagAlternateMsg = \" For a native html `style` tag use the `html-style` core tag instead.\";\nvar style_default = {\n  analyze(tag) {\n    (0, import_babel_utils42.assertNoArgs)(tag);\n    (0, import_babel_utils42.assertNoParams)(tag);\n    (0, import_babel_utils42.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    const ext = STYLE_EXT_REG.exec(node.rawValue || \"\")?.[1]?.slice(1);\n    for (const attr2 of node.attributes) {\n      if (attr2.start == null && attr2.type === \"MarkoAttribute\" && attr2.name === \"class\" && attr2.value.type === \"StringLiteral\" && attr2.value.value === ext) {\n        continue;\n      }\n      throw tag.hub.buildError(\n        attr2.value,\n        \"The `style` does not support html attributes.\" + htmlStyleTagAlternateMsg\n      );\n    }\n    for (const child of node.body.body) {\n      if (child.type !== \"MarkoText\") {\n        throw tag.hub.buildError(\n          child,\n          \"The `style` tag currently only supports static content.\" + htmlStyleTagAlternateMsg\n        );\n      }\n    }\n    if (node.body.body.length > 1) {\n      throw tag.hub.buildError(\n        node.name,\n        \"The `style` tag currently only supports static content.\" + htmlStyleTagAlternateMsg\n      );\n    }\n  },\n  translate(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const { filename, sourceMaps } = file.opts;\n    let ext = STYLE_EXT_REG.exec(node.rawValue || \"\")?.[1] || \".css\";\n    if (node.var && !/\\.module\\./.test(ext)) {\n      ext = \".module\" + ext;\n    }\n    const markoText = node.body.body[0];\n    const { resolveVirtualDependency } = getMarkoOpts();\n    const start = (0, import_babel_utils42.getStart)(file, markoText);\n    const end = (0, import_babel_utils42.getEnd)(file, markoText);\n    let code = markoText.value;\n    let map;\n    if (resolveVirtualDependency && sourceMaps && start !== null && end !== null) {\n      const magicString = new import_magic_string.default(file.code, { filename });\n      magicString.remove(0, start);\n      magicString.remove(end, file.code.length);\n      map = magicString.generateMap({\n        source: filename,\n        includeContent: true\n      });\n      if (sourceMaps === \"inline\" || sourceMaps === \"both\") {\n        code += `\n/*# sourceMappingURL=${map.toUrl()}*/`;\n        if (sourceMaps === \"inline\") {\n          map = void 0;\n        }\n      }\n    }\n    const importPath = resolveVirtualDependency?.(filename, {\n      virtualPath: `./${import_path3.default.basename(filename) + ext}`,\n      code,\n      map\n    });\n    if (importPath) {\n      if (!node.var) {\n        (0, import_babel_utils42.getProgram)().node.body.push(\n          import_compiler49.types.importDeclaration([], import_compiler49.types.stringLiteral(importPath))\n        );\n      } else if (import_compiler49.types.isIdentifier(node.var)) {\n        (0, import_babel_utils42.getProgram)().node.body.push(\n          import_compiler49.types.importDeclaration(\n            [import_compiler49.types.importDefaultSpecifier(node.var)],\n            import_compiler49.types.stringLiteral(importPath)\n          )\n        );\n      } else {\n        (0, import_babel_utils42.getProgram)().node.body.push(\n          import_compiler49.types.variableDeclaration(\"const\", [\n            import_compiler49.types.variableDeclarator(\n              node.var,\n              (0, import_babel_utils42.importDefault)(file, importPath, \"style\")\n            )\n          ])\n        );\n      }\n    }\n    tag.remove();\n  },\n  parseOptions: {\n    html: false,\n    text: true,\n    rawOpenTag: true,\n    preserveWhitespace: true\n  },\n  attributes: {}\n};\n\n// src/translator/core/try.ts\nvar import_compiler50 = require(\"@marko/compiler\");\nvar import_babel_utils43 = require(\"@marko/compiler/babel-utils\");\nvar kDOMBinding2 = Symbol(\"try tag dom binding\");\nvar try_default = {\n  analyze(tag) {\n    (0, import_babel_utils43.assertNoVar)(tag);\n    (0, import_babel_utils43.assertNoArgs)(tag);\n    (0, import_babel_utils43.assertNoParams)(tag);\n    (0, import_babel_utils43.assertNoAttributes)(tag);\n    assertNoSpreadAttrs(tag);\n    analyzeAttributeTags(tag);\n    const section = getOrCreateSection(tag);\n    const tagExtra = mergeReferences(\n      section,\n      tag.node,\n      getAllTagReferenceNodes(tag.node)\n    );\n    tagExtra[kDOMBinding2] = createBinding(\"#text\", 0 /* dom */, section);\n    if (!tag.node.body.body.length) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `try` tag requires body content.\");\n    }\n    startSection(tag.get(\"body\"));\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (!getSectionForBody(tag.get(\"body\"))) {\n          tag.remove();\n          return;\n        }\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        setSectionParentIsOwner(bodySection, true);\n        flushBefore(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const section = getSection(tag);\n        const tagExtra = node.extra;\n        const tagBody = tag.get(\"body\");\n        const translatedAttrs = translateAttrs(tag);\n        const nodeRef2 = tagExtra[kDOMBinding2];\n        const contentProp = getTranslatedBodyContentProperty(\n          translatedAttrs.properties\n        );\n        if (contentProp) {\n          translatedAttrs.properties.splice(\n            translatedAttrs.properties.indexOf(contentProp),\n            1\n          );\n        }\n        flushInto(tag);\n        writeHTMLResumeStatements(tagBody);\n        tag.insertBefore(translatedAttrs.statements);\n        tag.replaceWith(\n          import_compiler50.types.expressionStatement(\n            callRuntime(\n              \"tryContent\",\n              getScopeIdIdentifier(section),\n              getScopeAccessorLiteral(nodeRef2),\n              contentProp?.value,\n              propsToExpression(translatedAttrs.properties)\n            )\n          )\n        )[0].skip();\n      }\n    },\n    dom: {\n      enter(tag) {\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        setSectionParentIsOwner(bodySection, true);\n        visit(tag, 37 /* Replace */);\n        enterShallow(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const nodeRef2 = tagExtra[kDOMBinding2];\n        const referencedBindings = tagExtra.referencedBindings;\n        const translatedAttrs = translateAttrs(tag);\n        const contentProp = getTranslatedBodyContentProperty(\n          translatedAttrs.properties\n        );\n        if (contentProp) {\n          translatedAttrs.properties.splice(\n            translatedAttrs.properties.indexOf(contentProp),\n            1\n          );\n        }\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tag.get(\"body\"));\n        const signal = getSignal(section, nodeRef2, \"try\");\n        signal.build = () => {\n          return callRuntime(\n            \"createTry\",\n            getScopeAccessorLiteral(nodeRef2),\n            import_compiler50.types.identifier(bodySection.name)\n          );\n        };\n        if (translatedAttrs.statements.length) {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            translatedAttrs.statements\n          );\n        }\n        (0, import_babel_utils43.getProgram)().node.body.push(\n          import_compiler50.types.expressionStatement(callRuntime(\"enableCatch\"))\n        );\n        addValue(\n          section,\n          referencedBindings,\n          signal,\n          propsToExpression(translatedAttrs.properties)\n        );\n        tag.remove();\n      }\n    }\n  }),\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Used to capture errors and display placeholders for nested content.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#try\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/try.d.marko\"\n};\n\n// src/translator/core/index.ts\nvar core_default = {\n  taglibId: runtime_info_default.taglibId,\n  \"<attrs>\": attrs_default,\n  \"<await>\": await_default,\n  \"<client>\": client_default,\n  \"<const>\": const_default,\n  \"<debug>\": debug_default,\n  \"<define>\": define_default,\n  \"<effect>\": effect_default,\n  \"<else-if>\": ElseIfTag,\n  \"<else>\": ElseTag,\n  \"<export>\": export_default,\n  \"<for>\": for_default,\n  \"<html-comment>\": html_comment_default,\n  \"<html-script>\": html_script_default,\n  \"<html-style>\": html_style_default,\n  \"<id>\": id_default,\n  \"<if>\": IfTag,\n  \"<import>\": import_default,\n  \"<let>\": let_default,\n  \"<lifecycle>\": lifecycle_default,\n  \"<log>\": log_default,\n  \"<return>\": return_default,\n  \"<script>\": script_default,\n  \"<server>\": server_default,\n  \"<static>\": static_default,\n  \"<style>\": style_default,\n  \"<try>\": try_default\n};\n\n// src/translator/visitors/cdata.ts\nvar cdata_default = {\n  translate: {\n    enter(cdata) {\n      throw cdata.buildCodeFrameError(\n        \"CDATA sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/translator/visitors/comment.ts\nvar comment_default = {\n  translate: {\n    exit(comment) {\n      comment.remove();\n    }\n  }\n};\n\n// src/translator/visitors/declaration.ts\nvar declaration_default = {\n  translate: {\n    enter(decl) {\n      throw decl.buildCodeFrameError(\n        \"XML declarations sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/translator/visitors/document-type.ts\nvar document_type_default = {\n  translate: {\n    exit(documentType) {\n      if (isOutputHTML()) {\n        writeTo(documentType)`<!${documentType.node.value}>`;\n      }\n      documentType.remove();\n    }\n  }\n};\n\n// src/translator/visitors/function.ts\nvar import_compiler51 = require(\"@marko/compiler\");\nvar import_babel_utils44 = require(\"@marko/compiler/babel-utils\");\nvar function_default = {\n  analyze(fn) {\n    if (fn !== getFnRoot(fn)) {\n      return;\n    }\n    const markoRoot = getMarkoRoot(fn);\n    if (markoRoot && (markoRoot.isMarkoPlaceholder() || markoRoot.isMarkoScriptlet() && markoRoot.node.target === \"server\")) {\n      return;\n    }\n    if (isMarkoAttribute(markoRoot) && ((0, import_babel_utils44.isNativeTag)(markoRoot.parentPath) && /^on[A-Z-]/.test(markoRoot.node.name) || isCoreTagName(markoRoot.parentPath, \"script\") || isCoreTagName(markoRoot.parentPath, \"lifecycle\") || isCoreTagName(markoRoot.parentPath, \"for\"))) {\n      return;\n    }\n    const { node } = fn;\n    const section = getSection(fn);\n    const extra = node.extra ??= {};\n    const {\n      markoOpts,\n      opts: { filename }\n    } = (0, import_babel_utils44.getFile)();\n    const name2 = extra.name = generateUid(\n      fn.node.id?.name || (isMarkoAttribute(markoRoot) ? markoRoot.node.default ? import_compiler51.types.toIdentifier(\n        markoRoot.parentPath.has(\"var\") ? markoRoot.parentPath.get(\"var\") : markoRoot.parentPath.get(\"name\")\n      ) : markoRoot.node.name : import_compiler51.types.isVariableDeclarator(fn.parent) && import_compiler51.types.isIdentifier(fn.parent.id) ? fn.parent.id.name : import_compiler51.types.isObjectMethod(node) && import_compiler51.types.isIdentifier(node.key) ? node.key.name : \"anonymous\")\n    );\n    extra.section = section;\n    extra.registerId = (0, import_babel_utils44.getTemplateId)(\n      markoOpts,\n      filename,\n      `${section.id}/${name2.slice(1)}`\n    );\n  }\n};\nfunction isMarkoAttribute(path5) {\n  return path5 ? path5.isMarkoAttribute() : false;\n}\n\n// src/translator/visitors/import-declaration.ts\nvar import_babel_utils45 = require(\"@marko/compiler/babel-utils\");\nvar import_declaration_default = {\n  analyze(importDecl) {\n    const { node } = importDecl;\n    const { source } = node;\n    const { value } = source;\n    const tagImport = (0, import_babel_utils45.resolveTagImport)(importDecl, value);\n    if (tagImport) {\n      node.extra ??= {};\n      node.extra.tagImport = tagImport;\n      const tags = importDecl.hub.file.metadata.marko.tags;\n      if (!tags.includes(tagImport)) {\n        tags.push(tagImport);\n      }\n    }\n  },\n  translate: {\n    exit(importDecl) {\n      const { node } = importDecl;\n      const { extra } = node;\n      const tagImport = extra?.tagImport;\n      if (tagImport) {\n        node.source.value = tagImport;\n      }\n    }\n  }\n};\n\n// src/translator/visitors/placeholder.ts\nvar import_compiler53 = require(\"@marko/compiler\");\n\n// src/translator/util/is-non-html-text.ts\nvar import_compiler52 = require(\"@marko/compiler\");\nfunction isNonHTMLText(placeholder) {\n  const parentTag = placeholder.parentPath.isMarkoTagBody() && placeholder.parentPath.parentPath;\n  if (parentTag && isCoreTag(parentTag)) {\n    switch (parentTag.node.name.value) {\n      case \"html-comment\":\n      case \"html-script\":\n      case \"html-style\":\n        return true;\n    }\n  }\n  return false;\n}\n\n// src/translator/visitors/placeholder.ts\nvar kNodeBinding4 = Symbol(\"placeholder node binding\");\nvar kSiblingText = Symbol(\"placeholder has sibling text\");\nvar placeholder_default = {\n  analyze(placeholder) {\n    if (isNonHTMLText(placeholder)) return;\n    const { node } = placeholder;\n    const valueExtra = evaluate(node.value);\n    const { confident, computed } = valueExtra;\n    if (!(confident && (node.escape || isVoid2(computed)))) {\n      const section = getOrCreateSection(placeholder);\n      const nodeBinding = (node.extra ??= {})[kNodeBinding4] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section\n      );\n      analyzeSiblingText(placeholder);\n      addBindingSerializeReasonExpr(section, nodeBinding, valueExtra);\n    }\n  },\n  translate: {\n    exit(placeholder) {\n      if (isNonHTMLText(placeholder)) return;\n      const { node } = placeholder;\n      const { value } = node;\n      const valueExtra = evaluate(value);\n      const { confident, computed } = valueExtra;\n      if (confident && isVoid2(computed)) {\n        placeholder.remove();\n        return;\n      }\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(placeholder);\n      const extra = node.extra || {};\n      const nodeBinding = extra[kNodeBinding4];\n      const canWriteHTML = isHTML || confident && node.escape;\n      const method = canWriteHTML ? node.escape ? \"escapeXML\" : \"toString\" : node.escape ? \"data\" : \"html\";\n      const section = getSection(placeholder);\n      const markerSerializeReason = nodeBinding && getBindingSerializeReason(section, nodeBinding);\n      const siblingText = extra[kSiblingText];\n      if (confident && canWriteHTML) {\n        write2`${getHTMLRuntime()[method](computed)}`;\n      } else {\n        if (siblingText === 1 /* Before */) {\n          if (isHTML && markerSerializeReason) {\n            if (markerSerializeReason === true || markerSerializeReason.state) {\n              write2`<!>`;\n            } else {\n              write2`${callRuntime(\"commentSeparator\", getSerializeGuard(markerSerializeReason, true))}`;\n            }\n          }\n          visit(placeholder, 37 /* Replace */);\n        } else if (siblingText === 2 /* After */) {\n          visit(placeholder, 37 /* Replace */);\n        } else {\n          if (!isHTML) write2` `;\n          visit(placeholder, 32 /* Get */);\n        }\n        if (isHTML) {\n          write2`${callRuntime(method, value)}`;\n          if (nodeBinding) {\n            markNode(placeholder, nodeBinding, markerSerializeReason);\n          }\n        } else {\n          addStatement(\n            \"render\",\n            getSection(placeholder),\n            valueExtra.referencedBindings,\n            import_compiler53.types.expressionStatement(\n              method === \"data\" ? callRuntime(\n                \"data\",\n                import_compiler53.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(nodeBinding),\n                  true\n                ),\n                value\n              ) : callRuntime(\n                \"html\",\n                scopeIdentifier,\n                value,\n                getScopeAccessorLiteral(nodeBinding)\n              )\n            )\n          );\n        }\n      }\n      enterShallow(placeholder);\n      placeholder.remove();\n    }\n  }\n};\nfunction analyzeSiblingText(placeholder) {\n  const placeholderExtra = placeholder.node.extra;\n  let prev = placeholder.getPrevSibling();\n  while (prev.node) {\n    const contentType = getNodeContentType(\n      prev,\n      \"endType\"\n    );\n    if (contentType === null) {\n      prev = prev.getPrevSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 1 /* Before */;\n    } else {\n      break;\n    }\n  }\n  if (!prev.node && import_compiler53.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 1 /* Before */;\n  }\n  let next = placeholder.getNextSibling();\n  while (next.node) {\n    const contentType = getNodeContentType(\n      next,\n      \"startType\"\n    );\n    if (contentType === null) {\n      next = next.getNextSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 2 /* After */;\n    } else {\n      break;\n    }\n  }\n  if (!next.node && import_compiler53.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 2 /* After */;\n  }\n  return placeholderExtra[kSiblingText] = 0 /* None */;\n}\nfunction isVoid2(value) {\n  return value == null || value === false;\n}\n\n// src/translator/visitors/referenced-identifier.ts\nvar import_compiler54 = require(\"@marko/compiler\");\nvar abortIdsByExpressionForSection = /* @__PURE__ */ new WeakMap();\nvar referenced_identifier_default = {\n  migrate(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    switch (name2) {\n      case \"out\":\n        if (import_compiler54.types.isMemberExpression(identifier.parent) && import_compiler54.types.isIdentifier(identifier.parent.property) && identifier.parent.property.name === \"global\") {\n          identifier.parentPath.replaceWith(import_compiler54.types.identifier(\"$global\"));\n        } else {\n          throw identifier.buildCodeFrameError(\n            \"Only `out.global` is supported for compatibility.\"\n          );\n        }\n        break;\n    }\n  },\n  analyze(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    if (name2 === \"$global\") {\n      setReferencesScope(identifier);\n    } else if (name2 === \"$signal\") {\n      const section = getOrCreateSection(identifier);\n      section.hasAbortSignal = true;\n      setReferencesScope(identifier);\n    }\n  },\n  translate(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    switch (name2) {\n      case \"$global\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler54.types.callExpression(importRuntime(\"$global\"), [])\n          );\n        } else {\n          identifier.replaceWith(\n            import_compiler54.types.memberExpression(scopeIdentifier, import_compiler54.types.identifier(\"$global\"))\n          );\n        }\n        break;\n      case \"$signal\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler54.types.callExpression(\n              import_compiler54.types.arrowFunctionExpression(\n                [],\n                import_compiler54.types.blockStatement([\n                  import_compiler54.types.throwStatement(\n                    import_compiler54.types.newExpression(import_compiler54.types.identifier(\"Error\"), [\n                      import_compiler54.types.stringLiteral(\"Cannot use $signal in a server render.\")\n                    ])\n                  )\n                ])\n              ),\n              []\n            )\n          );\n        } else {\n          const section = getSection(identifier);\n          const exprRoot = getExprRoot(identifier);\n          let abortIdsByExpression = abortIdsByExpressionForSection.get(section);\n          let exprId;\n          if (abortIdsByExpression) {\n            exprId = abortIdsByExpression.get(exprRoot);\n          } else {\n            abortIdsByExpression = /* @__PURE__ */ new Map();\n            abortIdsByExpressionForSection.set(section, abortIdsByExpression);\n          }\n          if (!exprId) {\n            exprId = abortIdsByExpression.size;\n            abortIdsByExpression.set(exprRoot, exprId);\n            addStatement(\n              \"render\",\n              section,\n              exprRoot.node.extra?.referencedBindings,\n              import_compiler54.types.expressionStatement(\n                import_compiler54.types.callExpression(importRuntime(\"resetAbortSignal\"), [\n                  scopeIdentifier,\n                  import_compiler54.types.numericLiteral(exprId)\n                ])\n              ),\n              false\n            );\n          }\n          identifier.replaceWith(\n            import_compiler54.types.callExpression(importRuntime(\"getAbortSignal\"), [\n              scopeIdentifier,\n              import_compiler54.types.numericLiteral(exprId)\n            ])\n          );\n        }\n    }\n  }\n};\n\n// src/translator/visitors/scriptlet.ts\nvar scriptlet_default = {\n  analyze(scriptlet) {\n    if (!scriptlet.node.static) {\n      throw scriptlet.buildCodeFrameError(\n        \"Scriptlets are not supported when using the tags api.\"\n      );\n    }\n    mergeReferences(\n      getOrCreateSection(scriptlet),\n      scriptlet.node,\n      scriptlet.node.body\n    );\n  },\n  translate: {\n    exit(scriptlet) {\n      const { node } = scriptlet;\n      const isHTML = isOutputHTML();\n      if (node.target && node.target !== (isHTML ? \"server\" : \"client\")) {\n        scriptlet.remove();\n        return;\n      }\n      if (isHTML) {\n      } else {\n        traverseReplace(node, \"body\", replaceRegisteredFunctionNode2);\n        scriptlet.replaceWithMultiple(node.body);\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/index.ts\nvar import_compiler58 = require(\"@marko/compiler\");\nvar import_babel_utils49 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/visitors/tag/attribute-tag.ts\nvar import_compiler55 = require(\"@marko/compiler\");\nvar import_babel_utils46 = require(\"@marko/compiler/babel-utils\");\nvar attribute_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils46.assertNoVar)(tag);\n      (0, import_babel_utils46.assertNoArgs)(tag);\n      const body = tag.get(\"body\");\n      startSection(body);\n      trackParamsReferences(body, 3 /* param */);\n      if (!(0, import_babel_utils46.findParentTag)(tag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags must be nested within another tag.\");\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/custom-tag.ts\nvar import_compiler56 = require(\"@marko/compiler\");\nvar import_babel_utils47 = require(\"@marko/compiler/babel-utils\");\nvar import_path4 = __toESM(require(\"path\"));\nvar kChildScopeBinding = Symbol(\"custom tag child scope\");\nvar kChildOffsetScopeBinding = Symbol(\"custom tag scope offset\");\nvar kChildInputSerializePropIds = Symbol(\n  \"custom tag child serialize reasons\"\n);\nvar custom_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils47.assertAttributesOrSingleArg)(tag);\n      analyzeAttributeTags(tag);\n      const templateFile = (0, import_babel_utils47.getTagTemplate)(tag);\n      if (!templateFile) {\n        const tagName = getTagName(tag);\n        if (tagName && tag.scope.hasBinding(tagName)) {\n          throw tag.get(\"name\").buildCodeFrameError(\n            `Local variables must be in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n          );\n        }\n        throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n      }\n      const section = getOrCreateSection(tag);\n      const tagBody = tag.get(\"body\");\n      const tagExtra = tag.node.extra ??= {};\n      const childScopeBinding = tagExtra[kChildScopeBinding] = createBinding(\n        \"#childScope\",\n        0 /* dom */,\n        section\n      );\n      const attrExprs = /* @__PURE__ */ new Set([tagExtra]);\n      startSection(tagBody);\n      trackParamsReferences(tagBody, 3 /* param */);\n      const childFile = (0, import_babel_utils47.loadFileForTag)(tag);\n      if (!childFile) {\n        throw tag.get(\"name\").buildCodeFrameError(\"Unable to resolve file for tag.\");\n      }\n      const varBinding = trackVarReferences(tag, 4 /* derived */);\n      if (varBinding) {\n        varBinding.scopeOffset = tagExtra[kChildOffsetScopeBinding] = createBinding(\"#scopeOffset\", 0 /* dom */, section);\n      }\n      if (childFile.opts.filename === tag.hub.file.opts.filename) {\n        mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n        if (varBinding) {\n          const varSerializeReason = (0, import_babel_utils47.getProgram)().node.extra.returnValueExpr;\n          setBindingValueExpr(varBinding, varSerializeReason);\n          addBindingSerializeReasonExpr(\n            section,\n            childScopeBinding,\n            varSerializeReason\n          );\n        }\n      } else {\n        const childProgram = childFile.ast.program;\n        const childExtra = childProgram.extra;\n        const childInputBinding = childProgram.params[0].extra?.binding;\n        const inputExpr = {};\n        analyzeAttrs(\n          tagExtra,\n          section,\n          tag,\n          childExtra?.domExports.input,\n          attrExprs,\n          inputExpr\n        );\n        if (varBinding) {\n          const varSerializeReason = mapChildReasonToLocalReason(\n            childExtra.returnSerializeReason,\n            childInputBinding,\n            inputExpr\n          );\n          setBindingValueExpr(varBinding, varSerializeReason);\n          addBindingSerializeReasonExpr(\n            section,\n            childScopeBinding,\n            varSerializeReason\n          );\n        }\n        if (childExtra.inputSerializeReasons) {\n          const childInputSerializePropIds = tagExtra[kChildInputSerializePropIds] = [];\n          for (const reason of childExtra.inputSerializeReasons) {\n            const propId = Symbol();\n            childInputSerializePropIds.push(propId);\n            addBindingSerializeReasonExpr(\n              section,\n              childScopeBinding,\n              mapChildReasonToLocalReason(reason, childInputBinding, inputExpr),\n              propId\n            );\n          }\n        }\n        (0, import_babel_utils47.getProgram)().node.extra.hasInteractiveChild = childExtra?.isInteractive || childExtra?.hasInteractiveChild || false;\n      }\n      addBindingSerializeReasonExpr(\n        section,\n        childScopeBinding,\n        fromIter(attrExprs)\n      );\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML(tag);\n      } else {\n        translateDOM(tag);\n      }\n    }\n  }\n};\nfunction translateHTML(tag) {\n  const tagBody = tag.get(\"body\");\n  const { node } = tag;\n  const tagExtra = node.extra;\n  let tagIdentifier;\n  flushInto(tag);\n  writeHTMLResumeStatements(tagBody);\n  if (import_compiler56.types.isStringLiteral(node.name)) {\n    const relativePath = getTagRelativePath(tag);\n    tagIdentifier = isCircularRequest(tag.hub.file, relativePath) ? import_compiler56.types.identifier(getTemplateContentName()) : (0, import_babel_utils47.importDefault)(tag.hub.file, relativePath, getTagName(tag));\n  } else {\n    tagIdentifier = node.name;\n  }\n  const tagVar = node.var;\n  const section = getSection(tag);\n  const childProgram = (0, import_babel_utils47.loadFileForTag)(tag).ast.program;\n  const childExtra = childProgram.extra;\n  const inputExport = childExtra.domExports?.input;\n  const { properties, statements } = inputExport ? translateAttrs(tag, inputExport.props) : {\n    properties: [],\n    statements: []\n  };\n  const childScopeBinding = tagExtra[kChildScopeBinding];\n  const childScopeSerializeReason = getBindingSerializeReason(\n    section,\n    childScopeBinding\n  );\n  const childSerializeReasonIds = tagExtra[kChildInputSerializePropIds];\n  let childSerializeReasonExpr;\n  if (childSerializeReasonIds) {\n    if (childSerializeReasonIds.length === 1) {\n      const reason = getBindingSerializeReason(\n        section,\n        childScopeBinding,\n        childSerializeReasonIds[0]\n      );\n      childSerializeReasonExpr = !reason ? void 0 : reason == true || reason.state ? import_compiler56.types.numericLiteral(1) : getSerializeGuard(reason, true);\n    } else {\n      const props = [];\n      let hasDynamicReasons = false;\n      let hasSkippedReasons = false;\n      for (let i = 0; i < childSerializeReasonIds.length; i++) {\n        const reason = getBindingSerializeReason(\n          section,\n          childScopeBinding,\n          childSerializeReasonIds[i]\n        );\n        if (reason) {\n          hasDynamicReasons ||= reason !== true && !reason.state;\n          const childReason = childExtra.inputSerializeReasons[i];\n          props.push(\n            import_compiler56.types.objectProperty(\n              withLeadingComment(\n                import_compiler56.types.numericLiteral(i),\n                mapToString(childReason, \", \", getInputDebugName)\n              ),\n              reason === true || reason.state ? import_compiler56.types.numericLiteral(1) : getSerializeGuard(reason, false)\n            )\n          );\n        } else {\n          hasSkippedReasons = true;\n        }\n      }\n      if (props.length) {\n        childSerializeReasonExpr = hasDynamicReasons || hasSkippedReasons ? import_compiler56.types.objectExpression(props) : import_compiler56.types.numericLiteral(1);\n      }\n    }\n  }\n  if (childScopeSerializeReason) {\n    const peekScopeId = generateUidIdentifier(childScopeBinding?.name);\n    tag.insertBefore(\n      import_compiler56.types.variableDeclaration(\"const\", [\n        import_compiler56.types.variableDeclarator(peekScopeId, callRuntime(\"peekNextScopeId\"))\n      ])\n    );\n    setBindingSerializedValue(\n      section,\n      childScopeBinding,\n      callRuntime(\"writeExistingScope\", peekScopeId)\n    );\n    if (tagVar) {\n      statements.push(\n        import_compiler56.types.expressionStatement(\n          callRuntime(\n            \"setTagVar\",\n            getScopeIdIdentifier(section),\n            getScopeAccessorLiteral(tag.node.extra[kChildOffsetScopeBinding]),\n            peekScopeId,\n            import_compiler56.types.stringLiteral(\n              getResumeRegisterId(\n                section,\n                node.var.extra?.binding,\n                // TODO: node.var is not always an identifier.\n                \"var\"\n              )\n            )\n          )\n        )\n      );\n    }\n  }\n  if (node.extra.tagNameNullable) {\n    const contentProp = getTranslatedBodyContentProperty(properties);\n    let contentId = void 0;\n    if (contentProp) {\n      const contentExpression = contentProp.value;\n      contentProp.value = contentId = generateUidIdentifier(\"content\");\n      const [contentPath] = tag.insertBefore(\n        import_compiler56.types.variableDeclaration(\"const\", [\n          import_compiler56.types.variableDeclarator(\n            contentId,\n            // TODO: only register if needed (child template analysis)\n            contentExpression\n          )\n        ])\n      );\n      contentPath.skip();\n    }\n    let renderTagExpr = callExpression(\n      tagIdentifier,\n      propsToExpression(properties),\n      childSerializeReasonExpr\n    );\n    if (tagVar) {\n      translateVar(tag, import_compiler56.types.unaryExpression(\"void\", import_compiler56.types.numericLiteral(0)), \"let\");\n      renderTagExpr = import_compiler56.types.assignmentExpression(\"=\", tagVar, renderTagExpr);\n    }\n    statements.push(\n      import_compiler56.types.ifStatement(\n        tagIdentifier,\n        import_compiler56.types.expressionStatement(renderTagExpr),\n        contentId && callStatement(contentId)\n      )\n    );\n  } else if (tagVar) {\n    translateVar(\n      tag,\n      callExpression(\n        tagIdentifier,\n        propsToExpression(properties),\n        childSerializeReasonExpr\n      )\n    );\n  } else {\n    statements.push(\n      callStatement(\n        tagIdentifier,\n        propsToExpression(properties),\n        childSerializeReasonExpr\n      )\n    );\n  }\n  for (const replacement of tag.replaceWithMultiple(statements)) {\n    replacement.skip();\n  }\n}\nfunction translateDOM(tag) {\n  const tagSection = getSection(tag);\n  const { node } = tag;\n  const extra = node.extra;\n  const childScopeBinding = extra[kChildScopeBinding];\n  const write2 = writeTo(tag);\n  const { file } = tag.hub;\n  const tagName = import_compiler56.types.isIdentifier(node.name) ? node.name.name : import_compiler56.types.isStringLiteral(node.name) ? node.name.value : \"tag\";\n  const relativePath = getTagRelativePath(tag);\n  const childFile = (0, import_babel_utils47.loadFileForTag)(tag);\n  const childExports = childFile.ast.program.extra.domExports;\n  const tagIdentifier = importOrSelfReferenceName(\n    file,\n    relativePath,\n    childExports.setup,\n    tagName\n  );\n  const inputExport = childExports.input;\n  if (node.var) {\n    const source = initValue(\n      // TODO: support destructuring\n      node.var.extra.binding\n    );\n    source.register = true;\n    source.buildAssignment = (valueSection, value) => {\n      return import_compiler56.types.callExpression(importRuntime(\"tagVarSignalChange\"), [\n        createScopeReadExpression(valueSection, childScopeBinding),\n        value\n      ]);\n    };\n    addStatement(\n      \"render\",\n      tagSection,\n      void 0,\n      import_compiler56.types.expressionStatement(\n        callRuntime(\n          \"setTagVar\",\n          scopeIdentifier,\n          getScopeAccessorLiteral(childScopeBinding),\n          source.identifier\n        )\n      )\n    );\n  }\n  addStatement(\n    \"render\",\n    tagSection,\n    void 0,\n    import_compiler56.types.expressionStatement(\n      import_compiler56.types.callExpression(tagIdentifier, [\n        createScopeReadExpression(tagSection, childScopeBinding)\n      ])\n    )\n  );\n  if (inputExport) {\n    writeAttrsToExports(tag, inputExport, `${getTagName(tag) || \"tag\"}_input`, {\n      circular: childFile.opts.filename === file.opts.filename,\n      tagSection,\n      relativePath,\n      childScopeBinding,\n      attrTagCallsByTag: void 0\n    });\n  }\n  write2`${(0, import_babel_utils47.importNamed)(file, relativePath, childExports.template, `${tagName}_template`)}`;\n  injectWalks(\n    tag,\n    (0, import_babel_utils47.importNamed)(file, relativePath, childExports.walks, `${tagName}_walks`)\n  );\n  tag.remove();\n}\nfunction getTagRelativePath(tag) {\n  const {\n    node,\n    hub: { file }\n  } = tag;\n  let relativePath;\n  if (import_compiler56.types.isStringLiteral(node.name)) {\n    const template = (0, import_babel_utils47.getTagTemplate)(tag);\n    relativePath = template && (0, import_babel_utils47.resolveRelativePath)(file, template);\n  } else if (node.extra?.tagNameImported) {\n    relativePath = node.extra.tagNameImported;\n  }\n  if (!relativePath) {\n    const tagName = getTagName(tag);\n    if (tagName && tag.scope.hasBinding(tagName)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        `Local variables must be in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n      );\n    }\n    throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n  }\n  return relativePath;\n}\nfunction analyzeAttrs(rootTagExtra, section, tag, templateExport, rootAttrExprs, inputExpr) {\n  if (!templateExport) {\n    dropReferences(getAllTagReferenceNodes(tag.node));\n    return;\n  }\n  if (!templateExport.props || tag.node.arguments?.length) {\n    inputExpr.value = mergeReferences(\n      section,\n      tag.node,\n      getAllTagReferenceNodes(tag.node)\n    );\n    return;\n  }\n  const known = inputExpr.known = {};\n  const attrTagLookup = analyzeAttributeTags(tag);\n  const seen = /* @__PURE__ */ new Set();\n  if (attrTagLookup) {\n    const nodeReferencesByGroup = /* @__PURE__ */ new Map();\n    const analyzeDynamicChildGroup = (group, child) => {\n      const referenceNodes = getAllTagReferenceNodes(child.node);\n      const groupReferences = nodeReferencesByGroup.get(group);\n      if (groupReferences) {\n        groupReferences.referenceNodes = groupReferences.referenceNodes.concat(referenceNodes);\n      } else {\n        nodeReferencesByGroup.set(group, {\n          firstTag: child,\n          referenceNodes\n        });\n      }\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n    for (const child of attrTags2) {\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils47.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExports = templateExport.props[attrTagMeta.name];\n          if (childAttrExports) {\n            if (childAttrExports.props && !attrTagMeta.dynamic) {\n              analyzeAttrs(\n                rootTagExtra,\n                section,\n                child,\n                childAttrExports,\n                rootAttrExprs,\n                known[attrTagMeta.name] = {}\n              );\n            } else {\n              analyzeDynamicChildGroup(attrTagMeta.group, child);\n            }\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        } else {\n          const group = child.node.extra.attributeTagGroup;\n          let childUsesGroupProp = false;\n          for (const name2 of group) {\n            if (templateExport.props[attrTagLookup[name2].name]) {\n              childUsesGroupProp = true;\n              break;\n            }\n          }\n          if (childUsesGroupProp) {\n            analyzeDynamicChildGroup(group, child);\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        }\n      }\n    }\n    for (const [\n      group,\n      {\n        firstTag: { node },\n        referenceNodes\n      }\n    ] of nodeReferencesByGroup) {\n      const groupExtra = mergeReferences(section, node, referenceNodes);\n      const groupKnownValue = { value: groupExtra };\n      rootAttrExprs.add(groupExtra);\n      for (const name2 of group) {\n        known[attrTagLookup[name2].name] = groupKnownValue;\n      }\n    }\n  }\n  if (!seen.has(\"content\")) {\n    const bodySection = getSectionForBody(tag.get(\"body\"));\n    if (bodySection) {\n      seen.add(\"content\");\n      known.content = { value: void 0 };\n      bodySection.downstreamBinding = (templateExport.props.content || templateExport.props).binding;\n    }\n  }\n  const { attributes } = tag.node;\n  let spreadReferenceNodes;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler56.types.isMarkoAttribute(attr2)) {\n      if (seen.has(attr2.name) || !templateExport.props[attr2.name]) {\n        dropReferences(attr2.value);\n        continue;\n      }\n      seen.add(attr2.name);\n    }\n    if (spreadReferenceNodes) {\n      spreadReferenceNodes.push(attr2.value);\n    } else if (import_compiler56.types.isMarkoSpreadAttribute(attr2)) {\n      spreadReferenceNodes = [attr2.value];\n    } else {\n      const attrValueExtra = attr2.value.extra ??= {};\n      known[attr2.name] = { value: attrValueExtra };\n      rootAttrExprs.add(attrValueExtra);\n    }\n  }\n  if (spreadReferenceNodes) {\n    inputExpr.value = mergeReferences(section, tag.node, spreadReferenceNodes);\n  }\n}\nfunction writeAttrsToExports(tag, templateExport, importAlias, info) {\n  if (tag.node.arguments?.length) {\n    const [arg] = tag.node.arguments;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    addStatement(\n      \"render\",\n      info.tagSection,\n      // technically this should be `arg.extra?.referencedBindings`\n      // but we should probably ensure all other references are dropped in this case before we do that.\n      tag.node.extra?.referencedBindings,\n      import_compiler56.types.expressionStatement(\n        import_compiler56.types.callExpression(tagInputIdentifier, [\n          createScopeReadExpression(info.tagSection, info.childScopeBinding),\n          import_compiler56.types.isSpreadElement(arg) ? import_compiler56.types.memberExpression(arg.argument, import_compiler56.types.numericLiteral(0), true) : arg\n        ])\n      )\n    );\n    return;\n  }\n  if (!templateExport.props || info.circular) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    const translatedAttrs = translateAttrs(tag);\n    if (translatedAttrs.statements.length) {\n      addStatement(\n        \"render\",\n        info.tagSection,\n        referencedBindings,\n        translatedAttrs.statements\n      );\n    }\n    let translatedProps = propsToExpression(translatedAttrs.properties);\n    if ((0, import_babel_utils47.isAttributeTag)(tag)) {\n      const attrTagName = getTagName(tag);\n      const parentTag = tag.parentPath;\n      const repeated = analyzeAttributeTags(parentTag)?.[attrTagName]?.repeated;\n      if (repeated) {\n        let attrTagCallsForTag = (info.attrTagCallsByTag ||= /* @__PURE__ */ new Map()).get(\n          parentTag\n        );\n        if (!attrTagCallsForTag) {\n          info.attrTagCallsByTag.set(\n            parentTag,\n            attrTagCallsForTag = /* @__PURE__ */ new Map()\n          );\n        }\n        const attrTagCall = attrTagCallsForTag.get(attrTagName);\n        if (attrTagCall) {\n          attrTagCall.expression = callRuntime(\n            \"attrTags\",\n            attrTagCall.expression,\n            translatedProps\n          );\n          return;\n        } else {\n          attrTagCallsForTag.set(\n            attrTagName,\n            translatedProps = import_compiler56.types.parenthesizedExpression(\n              callRuntime(\"attrTag\", translatedProps)\n            )\n          );\n        }\n      } else {\n        translatedProps = callRuntime(\"attrTag\", translatedProps);\n      }\n    }\n    addStatement(\n      \"render\",\n      info.tagSection,\n      referencedBindings,\n      import_compiler56.types.expressionStatement(\n        import_compiler56.types.callExpression(tagInputIdentifier, [\n          createScopeReadExpression(info.tagSection, info.childScopeBinding),\n          translatedProps\n        ])\n      )\n    );\n    return;\n  }\n  const seen = /* @__PURE__ */ new Set();\n  const attrTagLookup = analyzeAttributeTags(tag);\n  if (attrTagLookup) {\n    const attrTags2 = tag.get(\"attributeTags\");\n    const statementsByGroup = /* @__PURE__ */ new Map();\n    const translateDynamicAttrTagChildInGroup = (group, index) => {\n      const child = attrTags2[index];\n      let statements = statementsByGroup.get(group)?.statements;\n      if (!statements) {\n        statements = [];\n        statementsByGroup.set(group, {\n          referencedBindings: child.node.extra?.referencedBindings,\n          statements\n        });\n      }\n      return addDynamicAttrTagStatements(\n        attrTags2,\n        index,\n        attrTagLookup,\n        statements,\n        templateExport.props\n      );\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils47.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExport = templateExport.props[attrTagMeta.name];\n          if (childAttrExport) {\n            if (attrTagMeta.dynamic) {\n              i = translateDynamicAttrTagChildInGroup(attrTagMeta.group, i);\n            } else {\n              writeAttrsToExports(\n                child,\n                childAttrExport,\n                `${importAlias}_${attrTagMeta.name}`,\n                info\n              );\n            }\n          }\n        } else if (child.node.extra?.attributeTagGroup) {\n          i = translateDynamicAttrTagChildInGroup(\n            child.node.extra.attributeTagGroup,\n            i\n          );\n        }\n      }\n    }\n    for (const [\n      group,\n      { referencedBindings, statements }\n    ] of statementsByGroup) {\n      const decls = [];\n      for (const name2 of group) {\n        const attrTagMeta = attrTagLookup[name2];\n        const childAttrExports = templateExport.props[attrTagMeta.name];\n        if (!childAttrExports) continue;\n        const attrExportIdentifier = importOrSelfReferenceName(\n          tag.hub.file,\n          info.relativePath,\n          childAttrExports.id,\n          `${importAlias}_${attrTagMeta.name}`\n        );\n        decls.push(import_compiler56.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta)));\n        addStatement(\"render\", info.tagSection, referencedBindings, [\n          import_compiler56.types.variableDeclaration(\"let\", decls),\n          ...statements\n        ]);\n        addStatement(\n          \"render\",\n          info.tagSection,\n          referencedBindings,\n          import_compiler56.types.expressionStatement(\n            import_compiler56.types.callExpression(attrExportIdentifier, [\n              createScopeReadExpression(\n                info.tagSection,\n                info.childScopeBinding\n              ),\n              getAttrTagIdentifier(attrTagMeta)\n            ])\n          )\n        );\n      }\n    }\n  }\n  const bodySection = tag.node.body.extra?.section;\n  if (bodySection && !seen.has(\"content\")) {\n    seen.add(\"content\");\n    if (templateExport.props.content) {\n      const contentExportIdentifier = (0, import_babel_utils47.importNamed)(\n        tag.hub.file,\n        info.relativePath,\n        templateExport.props.content.id,\n        `${importAlias}_content`\n      );\n      addStatement(\n        \"render\",\n        info.tagSection,\n        void 0,\n        // TODO: pretty sure content needs to have the reference group of it's param defaults.\n        import_compiler56.types.expressionStatement(\n          import_compiler56.types.callExpression(contentExportIdentifier, [\n            createScopeReadExpression(info.tagSection, info.childScopeBinding),\n            import_compiler56.types.callExpression(import_compiler56.types.identifier(bodySection.name), [scopeIdentifier])\n          ])\n        )\n      );\n    }\n  }\n  const { attributes } = tag.node;\n  const staticAttrs = [];\n  let spreadProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler56.types.isMarkoAttribute(attr2)) {\n      const childAttrExports = templateExport.props[attr2.name];\n      if (!childAttrExports || seen.has(attr2.name)) continue;\n      seen.add(attr2.name);\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n        continue;\n      }\n      staticAttrs.push(attr2);\n    } else if (spreadProps) {\n      spreadProps.push(import_compiler56.types.spreadElement(attr2.value));\n    } else {\n      spreadProps = [import_compiler56.types.spreadElement(attr2.value)];\n    }\n  }\n  for (const attr2 of staticAttrs.reverse()) {\n    const childAttrExports = templateExport.props[attr2.name];\n    const attrExportIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      childAttrExports.id,\n      `${importAlias}_${attr2.name}`\n    );\n    addStatement(\n      \"render\",\n      info.tagSection,\n      attr2.value.extra?.referencedBindings,\n      import_compiler56.types.expressionStatement(\n        import_compiler56.types.callExpression(attrExportIdentifier, [\n          createScopeReadExpression(info.tagSection, info.childScopeBinding),\n          attr2.value\n        ])\n      )\n    );\n  }\n  const missing = new Set(Object.keys(templateExport.props));\n  for (const name2 of seen) missing.delete(name2);\n  if (missing.size) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    let getMissingPropValue = buildUndefined2;\n    if (spreadProps) {\n      const spreadId = generateUidIdentifier(`${importAlias}_spread`);\n      spreadProps.reverse();\n      getMissingPropValue = (name2) => toMemberExpression(spreadId, name2);\n      addStatement(\"render\", info.tagSection, referencedBindings, [\n        import_compiler56.types.variableDeclaration(\"const\", [\n          import_compiler56.types.variableDeclarator(spreadId, propsToExpression(spreadProps))\n        ])\n      ]);\n    }\n    for (const name2 of missing) {\n      const childAttrExports = templateExport.props[name2];\n      const attrExportIdentifier = importOrSelfReferenceName(\n        tag.hub.file,\n        info.relativePath,\n        childAttrExports.id,\n        `${importAlias}_${name2}`\n      );\n      addStatement(\n        \"render\",\n        info.tagSection,\n        referencedBindings,\n        import_compiler56.types.expressionStatement(\n          import_compiler56.types.callExpression(attrExportIdentifier, [\n            createScopeReadExpression(info.tagSection, info.childScopeBinding),\n            getMissingPropValue(name2)\n          ])\n        )\n      );\n    }\n  }\n}\nfunction importOrSelfReferenceName(file, request, name2, nameHint) {\n  if (isCircularRequest(file, request)) {\n    return import_compiler56.types.identifier(name2);\n  }\n  return (0, import_babel_utils47.importNamed)(file, request, name2, nameHint);\n}\nfunction mapChildReasonToLocalReason(childReason, childInputBinding, inputExpr) {\n  if (childReason) {\n    if (childReason === true) return true;\n    return filterMap(\n      childReason,\n      (inputBinding) => resolveChildInputExpr(childInputBinding, inputBinding, inputExpr)\n    );\n  }\n}\nfunction resolveChildInputExpr(inputBinding, propBinding, expr) {\n  if (expr) {\n    let curExpr = expr;\n    if (inputBinding !== propBinding) {\n      const props = [propBinding.property];\n      let curBinding = propBinding;\n      while (inputBinding !== (curBinding = curBinding.upstreamAlias)) {\n        props.push(curBinding.property);\n      }\n      for (let i = props.length; i--; ) {\n        const nestedExpr = curExpr.known?.[props[i]];\n        if (nestedExpr) {\n          curExpr = nestedExpr;\n        } else {\n          break;\n        }\n      }\n    }\n    return curExpr.value;\n  }\n}\nfunction isCircularRequest(file, request) {\n  const { filename } = file.opts;\n  return request === filename || request[0] === \".\" && import_path4.default.resolve(filename, \"..\", request) === filename;\n}\nfunction callStatement(id, ...args) {\n  return import_compiler56.types.expressionStatement(callExpression(id, ...args));\n}\nfunction callExpression(id, ...args) {\n  return import_compiler56.types.callExpression(id, args.filter(Boolean));\n}\nfunction buildUndefined2() {\n  return import_compiler56.types.unaryExpression(\"void\", import_compiler56.types.numericLiteral(0));\n}\n\n// src/translator/visitors/tag/dynamic-tag.ts\nvar import_compiler57 = require(\"@marko/compiler\");\nvar import_babel_utils48 = require(\"@marko/compiler/babel-utils\");\nvar kDOMBinding3 = Symbol(\"dynamic tag dom binding\");\nvar kChildOffsetScopeBinding2 = Symbol(\"custom tag scope offset\");\nvar dynamic_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils48.assertAttributesOrArgs)(tag);\n      analyzeAttributeTags(tag);\n      const tagSection = getOrCreateSection(tag);\n      const tagExtra = mergeReferences(tagSection, tag.node, [\n        tag.node.name,\n        ...getAllTagReferenceNodes(tag.node)\n      ]);\n      const tagBody = tag.get(\"body\");\n      const isClassAPI = tagExtra.featureType === \"class\";\n      const hasVar = !!tag.node.var;\n      const nodeBinding = tagExtra[kDOMBinding3] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        tagSection\n      );\n      if (hasVar) {\n        trackVarReferences(tag, 4 /* derived */);\n        tag.node.var.extra.binding.scopeOffset = tagExtra[kChildOffsetScopeBinding2] = createBinding(\"#scopeOffset\", 0 /* dom */, tagSection);\n      }\n      startSection(tagBody);\n      trackParamsReferences(tagBody, 3 /* param */);\n      addBindingSerializeReasonExpr(\n        tagSection,\n        nodeBinding,\n        isClassAPI || hasVar || tagExtra\n      );\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(\n        tag,\n        tag.node.var ? 49 /* DynamicTagWithVar */ : 37 /* Replace */\n      );\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const tagExtra = node.extra;\n      const nodeBinding = tagExtra[kDOMBinding3];\n      const tagSection = getSection(tag);\n      const isClassAPI = tagExtra.featureType === \"class\";\n      let tagExpression = node.name;\n      if (import_compiler57.types.isStringLiteral(tagExpression)) {\n        tagExpression = (0, import_babel_utils48.importDefault)(\n          tag.hub.file,\n          getTagRelativePath(tag),\n          tagExpression.value\n        );\n      }\n      if (isClassAPI) {\n        if (isOutputHTML()) {\n          (0, import_babel_utils48.getProgram)().node.body.push(\n            import_compiler57.types.markoScriptlet(\n              [\n                import_compiler57.types.expressionStatement(\n                  import_compiler57.types.callExpression(\n                    (0, import_babel_utils48.importNamed)(tag.hub.file, getCompatRuntimeFile(), \"s\"),\n                    [\n                      import_compiler57.types.identifier(tagExpression.name),\n                      import_compiler57.types.stringLiteral((0, import_babel_utils48.loadFileForTag)(tag).metadata.marko.id)\n                    ]\n                  )\n                )\n              ],\n              true\n            )\n          );\n        } else {\n          (0, import_babel_utils48.getProgram)().node.body.push(\n            import_compiler57.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                import_compiler57.types.stringLiteral((0, import_babel_utils48.loadFileForTag)(tag).metadata.marko.id),\n                import_compiler57.types.identifier(tagExpression.name)\n              )\n            )\n          );\n        }\n      }\n      const { properties, statements } = translateAttrs(\n        tag,\n        void 0,\n        void 0,\n        isClassAPI ? \"renderBody\" : \"content\"\n      );\n      const args = [];\n      let hasTagArgs = false;\n      if (node.arguments) {\n        hasTagArgs = true;\n        args.push(...node.arguments);\n        if (properties.length) {\n          args.push(propsToExpression(properties));\n        }\n      } else {\n        const contentProp = getTranslatedBodyContentProperty(properties);\n        if (contentProp) {\n          properties.splice(properties.indexOf(contentProp), 1);\n          args.push(propsToExpression(properties), contentProp.value);\n        } else {\n          args.push(propsToExpression(properties));\n        }\n      }\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        const serializeArg = getSerializeGuard(\n          getBindingSerializeReason(tagSection, nodeBinding),\n          true\n        );\n        const dynamicTagExpr = hasTagArgs ? callRuntime(\n          \"dynamicTag\",\n          getScopeIdIdentifier(tagSection),\n          getScopeAccessorLiteral(nodeBinding),\n          tagExpression,\n          import_compiler57.types.arrayExpression(args),\n          import_compiler57.types.numericLiteral(0),\n          import_compiler57.types.numericLiteral(1),\n          serializeArg\n        ) : callRuntime(\n          \"dynamicTag\",\n          getScopeIdIdentifier(tagSection),\n          getScopeAccessorLiteral(nodeBinding),\n          tagExpression,\n          args[0],\n          args[1] || (serializeArg ? import_compiler57.types.numericLiteral(0) : void 0),\n          serializeArg ? import_compiler57.types.numericLiteral(0) : void 0,\n          serializeArg\n        );\n        if (node.var) {\n          const dynamicScopeIdentifier = generateUidIdentifier(\n            tag.get(\"name\").toString() + \"_scope\"\n          );\n          statements.push(\n            import_compiler57.types.variableDeclaration(\"const\", [\n              import_compiler57.types.variableDeclarator(\n                dynamicScopeIdentifier,\n                callRuntime(\"peekNextScopeId\")\n              )\n            ])\n          );\n          statements.push(\n            import_compiler57.types.variableDeclaration(\"const\", [\n              import_compiler57.types.variableDeclarator(node.var, dynamicTagExpr)\n            ]),\n            import_compiler57.types.expressionStatement(\n              callRuntime(\n                \"setTagVar\",\n                getScopeIdIdentifier(tagSection),\n                getScopeAccessorLiteral(\n                  tag.node.extra[kChildOffsetScopeBinding2]\n                ),\n                dynamicScopeIdentifier,\n                import_compiler57.types.stringLiteral(\n                  getResumeRegisterId(\n                    tagSection,\n                    node.var.extra?.binding,\n                    // TODO: node.var is not always an identifier.\n                    \"var\"\n                  )\n                )\n              )\n            )\n          );\n        } else {\n          statements.push(import_compiler57.types.expressionStatement(dynamicTagExpr));\n        }\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      } else {\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tag.get(\"body\"));\n        const signal = getSignal(section, nodeBinding, \"dynamicTag\");\n        let tagVarSignal;\n        if (tag.node.var) {\n          tagVarSignal = initValue(\n            // TODO: support destructuring\n            tag.node.var.extra.binding\n          );\n          tagVarSignal.register = true;\n          tagVarSignal.buildAssignment = (valueSection, value) => {\n            return import_compiler57.types.callExpression(importRuntime(\"tagVarSignalChange\"), [\n              import_compiler57.types.memberExpression(\n                getScopeExpression(tagVarSignal.section, valueSection),\n                import_compiler57.types.stringLiteral(\n                  getAccessorPrefix().ConditionalScope + getScopeAccessor(nodeBinding)\n                ),\n                true\n              ),\n              value\n            ]);\n          };\n        }\n        signal.build = () => {\n          return callRuntime(\n            \"dynamicTag\",\n            getScopeAccessorLiteral(nodeBinding),\n            bodySection && import_compiler57.types.identifier(bodySection.name),\n            tagVarSignal ? import_compiler57.types.arrowFunctionExpression([], tagVarSignal.identifier) : void 0,\n            hasTagArgs && import_compiler57.types.numericLiteral(1)\n          );\n        };\n        if (args.length) {\n          const argsOrInput = hasTagArgs ? import_compiler57.types.arrayExpression(args) : args[0];\n          if (!import_compiler57.types.isObjectExpression(argsOrInput) || argsOrInput.properties.length) {\n            signal.extraArgs = [\n              import_compiler57.types.arrowFunctionExpression(\n                [],\n                statements.length ? import_compiler57.types.blockStatement(\n                  statements.concat(import_compiler57.types.returnStatement(argsOrInput))\n                ) : argsOrInput\n              )\n            ];\n          }\n        }\n        addValue(section, tagExtra.referencedBindings, signal, tagExpression);\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/index.ts\nvar TAG_NAME_IDENTIFIER_REG = /^[A-Z][a-zA-Z0-9_$]*$/;\nvar BINDING_CHANGE_HANDLER = /* @__PURE__ */ new WeakMap();\nvar tag_default = {\n  transform: {\n    enter(tag) {\n      const { node } = tag;\n      const { name: name2, attributes } = tag.node;\n      let crawl = false;\n      if (import_compiler58.types.isStringLiteral(name2)) {\n        const tagName = name2.value;\n        if (tag.scope.getBinding(tagName) && TAG_NAME_IDENTIFIER_REG.test(tagName)) {\n          node.name = withPreviousLocation(import_compiler58.types.identifier(tagName), name2);\n          crawl = true;\n        }\n      }\n      for (let i = 0; i < attributes.length; i++) {\n        const attr2 = attributes[i];\n        if (import_compiler58.types.isMarkoAttribute(attr2) && attr2.bound) {\n          attr2.bound = false;\n          attributes.splice(++i, 0, getChangeHandler(tag, attr2));\n          crawl = true;\n        }\n      }\n      if (crawl) {\n        tag.scope.crawl();\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils49.getTagDef)(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        enter(hook, tag);\n        return;\n      }\n      if (type === 0 /* NativeTag */) {\n        native_tag_default.analyze.enter(tag);\n        return;\n      }\n      switch (type) {\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.analyze.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.analyze.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const hook = (0, import_babel_utils49.getTagDef)(tag)?.analyzer?.hook;\n      if (hook) {\n        exit(hook, tag);\n        return;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils49.getTagDef)(tag);\n      const extra = tag.node.extra;\n      if (tagDef?.translator) {\n        if (tagDef.translator.path) {\n          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);\n        }\n        enter(tagDef.translator.hook, tag);\n        return;\n      }\n      for (const attr2 of tag.get(\"attributes\")) {\n        if (attr2.isMarkoAttribute()) {\n          if (attr2.node.arguments) {\n            throw attr2.buildCodeFrameError(\n              `Unsupported arguments on the \\`${attr2.node.name}\\` attribute.`\n            );\n          }\n          if (attr2.node.modifier) {\n            if ((0, import_babel_utils49.isNativeTag)(attr2.parentPath)) {\n              attr2.node.name += `:${attr2.node.modifier}`;\n            } else {\n              throw attr2.buildCodeFrameError(\n                `Unsupported modifier \\`${attr2.node.modifier}\\`.`\n              );\n            }\n          }\n        }\n      }\n      if (extra.tagNameDynamic && extra.tagNameNullable && !tag.get(\"name\").isIdentifier() && isOutputHTML()) {\n        const tagNameId = generateUidIdentifier(\"tagName\");\n        const [tagNameVarPath] = tag.insertBefore(\n          import_compiler58.types.variableDeclaration(\"const\", [\n            import_compiler58.types.variableDeclarator(tagNameId, tag.node.name)\n          ])\n        );\n        tagNameVarPath.skip();\n        tag.set(\"name\", tagNameId);\n      }\n      switch (extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const translator = (0, import_babel_utils49.getTagDef)(tag)?.translator;\n      if (translator) {\n        exit(translator.hook, tag);\n        return;\n      }\n      switch (tag.node.extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.exit(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.exit(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.exit(tag);\n          break;\n      }\n    }\n  }\n};\nfunction getChangeHandler(tag, attr2) {\n  const attrName = attr2.name;\n  const changeAttrName = attrName + \"Change\";\n  if (import_compiler58.types.isIdentifier(attr2.value)) {\n    const binding = tag.scope.getBinding(attr2.value.name);\n    if (!binding)\n      return import_compiler58.types.markoAttribute(\n        changeAttrName,\n        buildChangeHandlerFunction(attr2.value)\n      );\n    const existingChangedAttr = BINDING_CHANGE_HANDLER.get(binding.identifier);\n    if (!existingChangedAttr) {\n      const changeHandlerAttr = import_compiler58.types.markoAttribute(\n        changeAttrName,\n        buildChangeHandlerFunction(attr2.value)\n      );\n      BINDING_CHANGE_HANDLER.set(binding.identifier, changeHandlerAttr);\n      return changeHandlerAttr;\n    }\n    if (existingChangedAttr.type === \"Identifier\") {\n      return import_compiler58.types.markoAttribute(\n        changeAttrName,\n        withPreviousLocation(\n          import_compiler58.types.identifier(existingChangedAttr.name),\n          attr2.value\n        )\n      );\n    }\n    const markoRoot = isMarko(binding.path) ? binding.path : getMarkoRoot(binding.path);\n    if (!(markoRoot?.isMarkoTag() || markoRoot?.isMarkoTagBody())) {\n      throw tag.hub.buildError(attr2.value, \"Unable to bind to value.\");\n    }\n    const changeHandlerId = generateUid(changeAttrName);\n    const changeHandlerConst = import_compiler58.types.markoTag(\n      import_compiler58.types.stringLiteral(\"const\"),\n      [import_compiler58.types.markoAttribute(\"value\", existingChangedAttr.value, null, null, true)],\n      import_compiler58.types.markoTagBody([]),\n      null,\n      import_compiler58.types.identifier(changeHandlerId)\n    );\n    BINDING_CHANGE_HANDLER.set(\n      binding.identifier,\n      existingChangedAttr.value = import_compiler58.types.identifier(changeHandlerId)\n    );\n    if (markoRoot.isMarkoTag()) {\n      markoRoot.insertAfter(changeHandlerConst);\n    } else {\n      markoRoot.unshiftContainer(\"body\", changeHandlerConst);\n    }\n    return import_compiler58.types.markoAttribute(\n      changeAttrName,\n      withPreviousLocation(import_compiler58.types.identifier(changeHandlerId), attr2.value)\n    );\n  } else if (import_compiler58.types.isMemberExpression(attr2.value)) {\n    const prop = attr2.value.property;\n    if (!import_compiler58.types.isPrivateName(attr2.value.property)) {\n      return import_compiler58.types.markoAttribute(\n        changeAttrName,\n        import_compiler58.types.memberExpression(\n          import_compiler58.types.cloneNode(attr2.value.object),\n          prop.type === \"Identifier\" ? withPreviousLocation(import_compiler58.types.identifier(prop.name + \"Change\"), prop) : import_compiler58.types.binaryExpression(\n            \"+\",\n            import_compiler58.types.cloneNode(prop),\n            import_compiler58.types.stringLiteral(\"Change\")\n          ),\n          prop.type !== \"Identifier\"\n        )\n      );\n    }\n  }\n  throw tag.hub.buildError(\n    attr2.value,\n    \"Attributes may only be bound to identifiers or member expressions\"\n  );\n}\nfunction buildChangeHandlerFunction(id) {\n  const newId = \"_new_\" + id.name;\n  return import_compiler58.types.arrowFunctionExpression(\n    [withPreviousLocation(import_compiler58.types.identifier(newId), id)],\n    import_compiler58.types.blockStatement([\n      import_compiler58.types.expressionStatement(\n        import_compiler58.types.assignmentExpression(\n          \"=\",\n          withPreviousLocation(import_compiler58.types.identifier(id.name), id),\n          withPreviousLocation(import_compiler58.types.identifier(newId), id)\n        )\n      )\n    ])\n  );\n}\n\n// src/translator/visitors/text.ts\nvar import_compiler59 = require(\"@marko/compiler\");\nvar text_default = {\n  translate: {\n    exit(text) {\n      if (isNonHTMLText(text)) return;\n      writeTo(text)`${text.node.value}`;\n      enterShallow(text);\n      text.remove();\n    }\n  }\n};\n\n// src/translator/index.ts\nvar visitors = extractVisitors({\n  Program: program_default,\n  Function: function_default,\n  ReferencedIdentifier: referenced_identifier_default,\n  ImportDeclaration: import_declaration_default,\n  MarkoDocumentType: document_type_default,\n  MarkoDeclaration: declaration_default,\n  MarkoCDATA: cdata_default,\n  MarkoText: text_default,\n  MarkoTag: tag_default,\n  MarkoPlaceholder: placeholder_default,\n  MarkoScriptlet: scriptlet_default,\n  MarkoComment: comment_default\n});\nvar tagDiscoveryDirs = [\"tags\"];\nvar preferAPI = \"tags\";\nvar { transform, analyze, translate } = visitors;\nvar taglibs = [\n  [\n    __dirname,\n    {\n      ...core_default,\n      migrate: visitors.migrate\n    }\n  ]\n];\nfunction getRuntimeEntryFiles(output, optimize) {\n  return [\n    `${runtime_info_default.name}${optimize ? \"\" : \"/debug\"}/${output === \"html\" ? \"html\" : \"dom\"}`\n  ];\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  analyze,\n  getRuntimeEntryFiles,\n  internalEntryBuilder,\n  preferAPI,\n  tagDiscoveryDirs,\n  taglibs,\n  transform,\n  translate\n});\n"],"names":["mod","__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__copyProps","to","from","except","desc","key","call","get","enumerable","__toESM","isNodeMode","target","__esModule","value","index_exports","__export","all","name2","analyze","getRuntimeEntryFiles","internalEntryBuilder","entry_builder_default","preferAPI","tagDiscoveryDirs","taglibs","transform","translate","module","exports","runtime_info_default","name","require","taglibId","import_compiler","import_babel_utils","assertNoSpreadAttrs","tag","attr2","isMarkoSpreadAttribute","buildCodeFrameError","node","assertNoBodyContent","body","length","AccessorPrefix4","AccessorProp4","attrs_default","migrate","assertNoArgs","assertNoParams","assertNoAttributes","assertNoAttributeTags","diagnosticDeprecate","label","fix","tagVar","var","type","remove","constTag","types","markoTag","stringLiteral","markoAttribute","identifier","markoTagBody","replaceWith","attributes","autocomplete","displayText","description","snippet","import_compiler25","import_babel_utils18","AccessorPrefix","AccessorProp","import_babel_utils2","evaluate","extra","confident","computed","computeNode","nullable","isNullableExpr","expr","operator","right","left","argument","consequent","alternate","expression","expressions","import_compiler24","import_babel_utils17","kTouchedIterator","Symbol","Generator","constructor","AsyncGenerator","async","toAccess","accessor","start","patchIteratorNext","proto","next","this","forEachIdentifier","cb","prop","properties","el","elements","KNOWN_SYMBOLS2","Map","symbol","set","AggregateError","Array","isArray","of","ArrayBuffer","isView","Atomics","add","and","compareExchange","exchange","isLockFree","load","notify","or","store","sub","wait","BigInt","asIntN","asUintN","BigInt64Array","BigUint64Array","Boolean","console","assert","clear","count","countReset","debug","dir","dirxml","error","group","groupCollapsed","groupEnd","info","log","table","time","timeEnd","timeLog","timeStamp","trace","warn","DataView","Date","now","parse","UTC","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","Error","EvalError","Float32Array","Float64Array","Function","globalThis","atob","btoa","clearImmediate","clearInterval","clearTimeout","crypto","getRandomValues","randomUUID","fetch","performance","queueMicrotask","setImmediate","setInterval","setTimeout","structuredClone","URL","URLSearchParams","WritableStream","Int16Array","Int32Array","Int8Array","Intl","Collator","DateTimeFormat","DisplayNames","getCanonicalLocales","ListFormat","Locale","NumberFormat","PluralRules","RelativeTimeFormat","Segmenter","supportedValuesOf","isFinite","isNaN","JSON","stringify","groupBy","Math","abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","floor","fround","hypot","imul","log10","log1p","log2","max","min","pow","random","round","sign","sin","sinh","sqrt","tan","tanh","trunc","Number","isInteger","isSafeInteger","parseFloat","parseInt","assign","defineProperties","entries","freeze","fromEntries","getOwnPropertyDescriptors","getOwnPropertySymbols","is","isExtensible","isFrozen","isSealed","keys","preventExtensions","seal","setPrototypeOf","values","Promise","Proxy","RangeError","ReferenceError","Reflect","apply","construct","deleteProperty","has","ownKeys","RegExp","Set","String","fromCharCode","fromCodePoint","raw","for","SyntaxError","TypeError","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","URIError","WeakMap","WeakSet","import_compiler3","import_babel_utils4","import_babel_utils3","isTranslate","getFile","___compileStage","import_compiler2","skip","traverseReplace","container","enter3","i","VISITOR_KEYS","replacement","traverseContains","check","item","traverse","visit2","parent","grandParent","countsForFile","generateUid","file","counts","cache","markoOpts","filename","opts","cacheKey","program","path","countName","match","exec","name3","scope","globals","isBinding","getInitialCounts","replace","uniqueName","generateUidIdentifier","sharedUIDsForFile","getSharedUid","sharedUIDs","usedSharedUid","AccessorPrefix2","AccessorProp2","import_babel_utils5","isOutputHTML","getMarkoOpts","output","isOutputDOM","isOptimize","optimize","getAccessorPrefix","getAccessorProp","getMarkoRoot","path5","curPath","parentPath","isMarko","getExprRoot","getFnRoot","fnPath","isProgram","isFunction","declare","isInvokedFunction","callee","Sorted","compare","data","addSorted","joinRepeatable","union","a","b","aLen","bLen","aIndex","bIndex","result","aValue","bValue","delta","push","unionSortedRepeatable","find","findSorted","findIndex","findIndexSorted","isSuperset","superset","subset","subLen","supLen","supIndex","concat","filter","len","forEach","mapToString","sep","str","curSep","pos","mid","cur","compareResult","import_compiler23","import_compiler22","import_babel_utils16","import_path2","bindingHasDownstreamExpressions","binding","downstreamExpressions","size","alias","aliases","propertyAliases","import_compiler5","import_babel_utils6","kState","build","entryFile","state","imports","map","it","importDeclaration","init","unshift","importSpecifier","expressionStatement","callExpression","visit","visitChild","analyzedTags","metadata","marko","resolveRelativePath","hasInteractiveChild","isInteractive","getKnownAttrValues","attrs2","import_babel_utils7","getTagName","isCoreTag","isMarkoTag","tagDef","getTagDef","isCoreTagName","isConditionTag","import_compiler7","import_babel_utils8","stringifyClassObject","stringifyStyleObject","toDelimitedString","val","delimiter","part","v","isEventHandler","test","getEventHandlerName","slice","toLowerCase","toString","unsafeXMLReg","replaceUnsafeXML","c","escapeXML","unsafeScriptReg","escapeScript","unsafeStyleReg","escapeStyle","classAttr","stringAttr","styleAttr","attr","isVoid","attrAssignment","source","nonVoidAttr","singleQuoteAttrReplacements","doubleQuoteAttrReplacements","needsQuotedAttr","lastIndex","replaceUnsafeSingleQuoteAttrChar","escapeSingleQuotedAttrValue","replaceUnsafeDoubleQuoteAttrChar","escapeDoubleQuotedAttrValue","import_compiler6","isValidPropertyIdentifier","toPropertyName","numericLiteral","toObjectProperty","objectProperty","toMemberExpression","object","optional","optionalMemberExpression","memberExpression","pureDOMFunctions","importRuntime","importStar","getRuntimePath","callRuntime","args","callExpression2","filteredArgs","arg","unaryExpression","filterArguments","leadingComments","getHTMLRuntime","getCompatRuntimeFile","modules","import_compiler10","import_babel_utils11","reasonExprs","keyedReasonExprs","serializeKeysByBinding","serializeKeyBySourceModifier","forceOwnersSerialize","forceSectionSerialize","addOwnersSerializeReason","reason","addSectionSerializeReason","section","forceSerializeKey","getSectionPropSerializeReasonKey","serializeReason","delete","setSectionSerializeReason","forceBindingSerialize","prefix2","getBindingSerializeReasonKey","serializeReasons","setSectionKeyedSerializeReason","isBindingForceSerialized","addBindingSerializeReasonExpr","addKeyedSerializeReasonExpr","existingExpr","keyedExprs","addKeyedSerializeReason","existingReason","mergeSerializeReasons","addBindingSerializeReason","getSectionSerializeReason","getBindingSerializeReason","applySerializeReasonExprs","exprs","reason2","getSerializeSourcesForExprs","getSerializeSourcesForExpr","isReferencedExtra","getSerializeSourcesForRef","referencedBindings","allSources","mergeSources","ref","sources","import_babel_utils9","createProgramState","getProgram","createSectionState","arrayOfSectionData","id","import_compiler9","import_babel_utils10","MARKO_FILE_REG","analyzeTagNameType","tagNameType","isStringLiteral","isNativeTag","tagNameNullable","isIdentifier","pending","tagNameImported","pop","isConditionalExpression","isLogicalExpression","isAssignmentExpression","isBinaryExpression","isTemplateLiteral","isNullLiteral","getBinding","kind","decl","specifiers","some","isImportDefaultSpecifier","resolvedImport","resolveTagImport","bindingTag","bindingTagName","tagNameDynamic","analyzeExpressionTagName","childFile","loadFileForTag","ast","featureType","needsCompat","sectionUtil","startSection","parentSection","getOrCreateSection","sectionNamePath","sectionName","programExtra","hub","sections","loc","depth","sectionAccessor","params","referencedClosures","referencedHoists","bindings","hoisted","isHoistThrough","content","getContentInfo","upstreamExpression","downstreamBinding","hasAbortSignal","isBranch","attributeTags","isNativeNode","getSectionForBody","getSection","currentPath","getScopeIdIdentifier","getSectionParentIsOwner","setSectionParentIsOwner","_getScopeIdentifier","forEachSection","fn","contentInfo","startType","endType","singleChild","endIndex","getNodeContentType","startIndex","extraMember","isAttributeTag","tagSection","isSerializedSection","isImmediateOwner","isDynamicClosure","closure","isDirectClosure","isSameOrChildSection","other","import_compiler21","import_babel_utils15","import_path","regexpCharsReg","import_compiler20","import_babel_utils14","import_compiler17","import_babel_utils13","getParentTag","import_compiler11","enter","modulePlugin","plugin","isModulePlugin","default","isFunctionPlugin","exit","translateByTarget","html","dom","import_compiler16","import_compiler13","import_babel_utils12","import_compiler12","simplifyFunction","functionExpression","generator","withLeadingComment","comment","getTemplateContentName","getSerializeGuard","getDebugName","resolveSerializeReasonId","inputSerializeReasons","getInputSerializeReasonGuard","input","getExprIfSerialized","logicalExpression","getInputDebugName","html_default","flushInto","writeHTMLResumeStatements","replaceNode","renderContent","child","isImportDeclaration","isExportDeclaration","isMarkoScriptlet","static","replaceWithMultiple","serializeId","contentId","contentFn","arrowFunctionExpression","blockStatement","exportDefault","exportDefaultDeclaration","variableDeclaration","variableDeclarator","read","declared","getReadReplacement","replaceBindingReadNode","getRegisteredFnExpression","classProperty","classPrivateProperty","isRegisteredFnExtra","registeredFnDeclarations","registeredFnDeclarationsByBody","registerId","addRegisteredDeclarations","replaceRegisteredFunctionNode","referencedBindingsInFunction","referencesScope","import_compiler14","normalizeStringExpression","parts","strs","curStr","nextIndex","exprLen","shiftItems","quasis","j","templateLiteral","templateElement","appendLiteral","arr","list","offset","getWalks","getWalkComment","getSteps","walkCodeToName","enter2","exit2","enterShallow","code","steps","walks","walkComment","walkString","walkCodes","step","lastIndexOf","current","walk","nCodeString","writeTo","number","toCharString","startCode","rangeSize","multiplier","getWalkString","postfix","walkLiteral","join","getWrites","getTrailerWrites","trailer","exprsLen","writes","consumeHTML","trailers","writeResult","trailerResult","sequenceExpression","flushBefore","insertBefore","getSectionMeta","writePrefix","writePostfix","setup","getSetup","markNode","nodeBinding","getScopeAccessorLiteral","tagsWithReturn","getSectionReturnValueIdentifier","setReturnValueIdentifier","return_default","assertNoVar","assertAllowedAttributes","parentTag","isControlFlowTag","valueChange","TagVariableChange","getSerializedAccessors","setSectionSerializedValue","returnId","addStatement","scopeIdentifier","parseOptions","openTagOnly","descriptionMoreURL","import_compiler18","getDeclaredBindingExpression","canonicalBinding","getCanonicalBinding","upstreamAlias","property","import_compiler19","toFirstExpressionOrBlock","stmts","isExpressionStatement","toParenthesizedExpressionIfNeeded","parenthesizedExpression","getSignals","getClosureSignalBuilder","_setClosureSignalBuilder","setClosureSignalBuilder","builder","setBindingSerializedValue","getScopeAccessor","nonAnalyzedForceSerializedSection","setSerializedValue","getSectionWriteScopeBuilder","setSectionWriteScopeBuilder","addWriteScopeBuilder","prev","htmlDynamicClosureInstancesIdentifier","getHTMLSectionStatements","getHoistFunctionsIdsMap","getHoistFunctionIdentifier","hoistedBinding","idsMap","unimplementedBuild","getSignal","generateSignalName","signals","signal","exportName","export","domExports","intersection","render","renderReferencedBindings","effect","effectReferencedBindings","subscribers","subscribe","scopeOffset","intersectionMeta","getSignalFn","bindingUtil","canonicalClosure","getScopeExpression","initValue","runtimeHelper","isParamBinding","needsCache","closureSections","needsMarks","hoists","valueAccessor","isIntersection","isValue","valueParam","index","end","aliasSignal","getTranslatedExtraArgs","valSignal","dynamicClosureArgs","dynamicClosureSignalIdentifier","closureSection","prependStatements","effectIdentifier","createScopeReadPattern","arguments","param","hasTranslatedExtraArgs","emptyExtraArgs","extraArgs","replaceRenderNode","provider","subscriber","p","providerSignal","replaceNullishAndEmptyFunctionsWith0","isArrowFunctionExpression","isBlockStatement","isUnaryExpression","isNumericLiteral","targetSection","statement","usedReferences","statements","addEffectReferences","addRenderReferences","addValue","parentSignal","getResumeRegisterId","getTemplateId","usedRegisterIdsBySection","getRegisterUID","used","baseId","writeSignals","seen","accessors","Getter","currentSection","getSectionInstancesAccessorLiteral","hoistIdentifier","writeHoists","writeSignal","value2","effectDeclarator","replaceEffectNode","isScopeIdentifier","isCallExpression","register","signalDeclarator","signalDeclaration","isFunctionExpression","functionDeclaration","isExpression","exportNamedDeclaration","signalStatements","toReturnedFunction","rawFn","returnStatement","addHTMLEffectCall","allSignals","scopeIdIdentifier","closureSignal","newExpression","ClosureScopes","getDynamicClosureIndex","ClosureSignalIndex","sectionDynamicSubscribers","subscribersIdentifier","getSectionInstancesAccessor","signalRefs","serializedLookup","serializedProperties","sectionSerializeReason","compareSources","ownerAccessor","Owner","ownerReason","getOwnerExpr","writeScopeBuilder","shorthand","writeScopeArgs","objectExpression","debugVars","root","access","getDebugScopeAccess","locExpr","line","column","arrayExpression","filenameRelative","writeScopeCall","additionalStatements","returnIdentifier","replaceAssignedNode","replaceBindingReadNode2","replaceRegisteredFunctionNode2","isAssignedBindingExtra","buildAssignment","assignment","binaryExpression","prefix","assignments","resultId","assignmentExpression","registeredFnsForProgram","getRegisteredFnExpression2","registedFns","dom_default","templateIdentifier","template","walksIdentifier","setupIdentifier","inputBinding","programInputSignal","styleFile","fs","fileSystem","base","leftDot","indexOf","rightDot","closeBracket","openBracket","getBase","styleMatch","file2","readdirSync","dirname","sort","getStyleFile","importDefault","forEachSectionReverse","childSection","tagParamsSignal","walks2","writes2","setup2","renderer","registeredFns","registeredFn","assignmentPattern","writeRegisteredFns","program_default","crawl","trackParamsReferences","returnValueExpr","getBindings","readsByExpression","getReadsByExpression","readsByFn","getReadsByFunction","mergedReferences","getMergedReferences","nodes","targetExtra","reads","isEffect","additionalReads","intersectionsBySection","resolveReferencedBindings","pruneBinding","resolveBindingSources","assignmentSections","assignedSection","section2","canonicalUpstreamAlias","binding2","addKeyedSerializeReasonRef","addSectionSerializeReasonRef","getDirectClosures","kBranchSerializeReason","addSectionSerializeReasonExpr","intersections","numReferences","binding1","isSupersetSources","sourceSection","upstreamReason","keyedReason","finalizeSectionSerializeReasons","compareReferences","returnSources","returnSerializeReason","intersectionIndex","bindings2","isOwnedBinding","lastBindingIndex","bindingIndex","at","getMaxOwnSourceOffset","finalizeReferences","buildTemplateExports","visitedFiles","resolved","loadFileForImport","req","resolveRelativeToEntry","compatFile","templateExport","props","rootDepth","rootPattern","objectPattern","nestedPatterns","propertyValue","propertyKey","isShorthand","pattern","relativeDepth","nestedPattern","diff","createScopeReadExpression","reference","propName","withPreviousLocation","newNode","originalNode","kIsInvoked","getNextBindingId","setNextBindingId","createBinding","excludeProperties","propBinding","trackVarReferences","createBindingsAndTrackReferences","paramsBinding","trackHoistedReference","referencePath","referenceSection","hoistSection","ancestor","getCommonSection","createRead","trackReference","trackAssignment","setReferencesScope","fnRoot","lVal","babelBinding","referencePaths","constantViolations","isUpdateExpression","trackReferencesForBinding","patternBinding","element","propPath","isMemberExpression","getMemberExpressionPropString","isEventOrChangeHandler","exprRoot","exprExtra","addReadToExpression","fnExtra","mergeReferences","compareIntersections","lenDelta","trackScopeOffset","setBindingValueExpr","valueExpr","bindingValueExprs","resolvedSources","createSources","resolveDerivedSources","dropReferences","pruned","getAllTagReferenceNodes","referenceNodes","includeId","shouldPrune","exprReference","resolveExpressionReference","readBinding","readProps","aliasProps","kDOMBinding","await_default","tagBody","valueAttr","isMarkoAttribute","isSpreadElement","bodySection","valueExtra","nodeRef2","import_compiler26","import_babel_utils19","client_default","rawValue","trim","parseStatements","markoScriptlet","rawOpenTag","import_compiler28","import_babel_utils20","import_compiler27","translateVar","initialValue","const_default","varBinding","derivation","import_compiler29","import_babel_utils21","debug_default","debuggerStatement","import_babel_utils27","import_compiler30","import_babel_utils22","attrTagToIdentifierLookup","getAttrTagIdentifier","meta","analyzeAttributeTags","attrTags2","lookup","attrTagNodesByName","sampleAttrTagsForControlFlow","createAttrTagMeta","isRepeated","isLoopTag","curGroup","crawlAttrTags","oldMeta","attrTagMeta","dynamic","repeated","controlFlowTag","sampleAttrName","attributeTagGroup","attrTagNodes","hasRepeatedDynamicAttrTags","attrTagNames","tagName","conditionRoot","seenBranches","attrTag2","curConditionRoot","getConditionRoot","getPrevSibling","import_compiler34","import_babel_utils26","import_compiler33","import_babel_utils25","import_babel_utils24","import_compiler31","import_babel_utils23","kNativeTagBinding","kSkipEndTag","kGetterId","htmlSelectArgs","native_tag_default","escape","buildError","buildUndefined","relatedControllable","spreadReferenceNodes","attrExprExtras","hasDynamicAttributes","hasEventHandlers","getRelatedControllable","exclusiveGroups","open","openChange","checked","checkedChange","checkedValue","checkedValueChange","assertExclusiveControllableGroups","tagExtra","toIdentifier","attrs","every","refSection","write2","getterId","visitAccessor","usedAttrs","getUsedAttrs","staticAttrs","staticControllable","skipExpression","writeAtStartOfBody","spreadExpression","helper","spreadIdentifier","valueReferences","htmlType","ifStatement","selectArgs","markerSerializeReason","varName","getterFnIdentifier","firstAttr","nodeExpr","staticItems","dynamicItems","dynamicValues","stmt","trackDelimitedAttrValue","special","maybeStaticAttrs","spreadProps","skipProps","attr3","spreadElement","reverse","propsToExpression","trackDelimitedAttrObjectProperties","trackDelimitedAttrArrayItems","evalItem","obj","staticProps","dynamicProps","keyEval","propEval","kOnlyChildInParent","kNodeRef","getOnlyChildParentTagName","branchSize","getOptimizedOnlyChildNodeBinding","parentTagName","for_default","isAttrTag","allowAttrs","getForType","LoopScopeMap","onlyChildParentTagName","forAttrs","forType","bodyStatements","singleNodeOptimization","branchSerializeReason","forTagArgs","getBaseArgsInForTag","forTagHTMLRuntime","forTypeToHTMLResumeRuntime","forTypeToRuntime","skipParentEnd","markerSerializeArg","by","forTypeToDOMRuntime","loopArgs","controlFlow","in","contentProps","translateAttrs","templateExports","contentKey","attrTagLookup","usesExport","addDynamicAttrTagStatements","translatedAttrTag","prevProp","findObjectProperty","contentExpression","serialized","isTransparentTag","getNonAttributeTagParent","buildContent","contentProp","getTranslatedBodyContentProperty","ifTag","consequentStatements","getConditionTestValue","addAllAttrTagsAsDynamic","nextTag","testValue","alternateStatements","translateIfAttrTag","forTag","buildForRuntimeCall","translateForAttrTag","define_default","translatedAttrs","import_compiler36","import_babel_utils28","effect_default","import_babel_utils29","export_default","import_compiler37","import_babel_utils30","kNodeBinding","kGetterId2","html_comment_default","needsBinding","needsGetter","isMarkoPlaceholder","isMarkoText","references","templateQuasis","templateExpressions","currentQuasi","text","import_compiler38","import_babel_utils31","kNodeBinding2","kGetterId3","html_script_default","bodyPlaceholderNodes","hasBodyPlaceholders","isHTML","getUsedAttrs2","referencePlaceholder","preserveWhitespace","import_compiler39","import_babel_utils32","kNodeBinding3","kGetterId4","html_style_default","getUsedAttrs3","import_compiler40","import_babel_utils33","id_default","import_compiler42","import_babel_utils34","import_compiler41","BRANCHES_LOOKUP","IfTag","assertHasBody","assertHasValueAttribute","assertHasPrecedingCondition","ifAttr","msg","assertOptionalIfAttribute","assertValidCondition","isLastBranch","branches","getBranches","ifTagSection","ifTagExtra","mergeReferenceNodes","ConditionalScope","branchTag","branchBodySection","isRoot","getNextSibling","branchSerializeReasons","branchBody","testAttr","curStatement","cbNode","reasons","guard","getSerializeGuardForAny","rendererIdentifiers","conditionalExpression","ElseIfTag","ElseTag","isMarkoComment","curTag","import_babel_utils35","import_default","import_compiler43","import_babel_utils36","let_default","valueChangeAttr","valueSection","import_compiler44","import_babel_utils37","kRef","lifecycle_default","lifecycleAttrsRef","import_compiler45","import_babel_utils38","log_default","import_compiler46","import_babel_utils39","htmlScriptTagAlternateMsg","script_default","valueFn","isAwaitExpression","seenValueAttr","isFunction2","inlineBody","hasDeclaration","isDeclaration","await","import_compiler47","import_babel_utils40","server_default","import_compiler48","import_babel_utils41","static_default","import_compiler49","import_babel_utils42","import_magic_string","import_path3","STYLE_EXT_REG","htmlStyleTagAlternateMsg","style_default","ext","sourceMaps","markoText","resolveVirtualDependency","getStart","getEnd","magicString","generateMap","includeContent","toUrl","importPath","virtualPath","basename","importDefaultSpecifier","import_compiler50","import_babel_utils43","kDOMBinding2","try_default","splice","core_default","cdata_default","cdata","comment_default","declaration_default","document_type_default","documentType","import_compiler51","import_babel_utils44","function_default","markoRoot","isVariableDeclarator","isObjectMethod","import_babel_utils45","import_declaration_default","importDecl","tagImport","tags","includes","import_compiler53","isNonHTMLText","placeholder","isMarkoTagBody","kNodeBinding4","kSiblingText","placeholder_default","isVoid2","placeholderExtra","contentType","analyzeSiblingText","canWriteHTML","method","siblingText","import_compiler54","abortIdsByExpressionForSection","referenced_identifier_default","hasBinding","throwStatement","exprId","abortIdsByExpression","scriptlet_default","scriptlet","import_compiler58","import_babel_utils49","import_babel_utils46","attribute_tag_default","findParentTag","import_compiler56","import_babel_utils47","import_path4","kChildScopeBinding","kChildOffsetScopeBinding","kChildInputSerializePropIds","custom_tag_default","assertAttributesOrSingleArg","getTagTemplate","charAt","toUpperCase","childScopeBinding","attrExprs","varSerializeReason","childProgram","childExtra","childInputBinding","inputExpr","analyzeAttrs","mapChildReasonToLocalReason","childInputSerializePropIds","propId","one","many","fromIter","tagIdentifier","relativePath","getTagRelativePath","isCircularRequest","inputExport","childScopeSerializeReason","childSerializeReasonIds","childSerializeReasonExpr","hasDynamicReasons","hasSkippedReasons","childReason","peekScopeId","contentPath","renderTagExpr","callStatement","translateHTML","childExports","importOrSelfReferenceName","writeAttrsToExports","circular","attrTagCallsByTag","importNamed","injectWalks","translateDOM","rootTagExtra","rootAttrExprs","known","nodeReferencesByGroup","analyzeDynamicChildGroup","groupReferences","firstTag","attrTagName","childAttrExports","childUsesGroupProp","groupExtra","groupKnownValue","attrValueExtra","importAlias","tagInputIdentifier","translatedProps","attrTagCallsForTag","attrTagCall","statementsByGroup","translateDynamicAttrTagChildInGroup","childAttrExport","decls","attrExportIdentifier","contentExportIdentifier","missing","getMissingPropValue","buildUndefined2","spreadId","request","nameHint","filterMap","curExpr","curBinding","nestedExpr","resolveChildInputExpr","resolve","import_compiler57","import_babel_utils48","kDOMBinding3","kChildOffsetScopeBinding2","dynamic_tag_default","assertAttributesOrArgs","isClassAPI","hasVar","tagExpression","hasTagArgs","serializeArg","dynamicTagExpr","dynamicScopeIdentifier","tagVarSignal","argsOrInput","isObjectExpression","TAG_NAME_IDENTIFIER_REG","BINDING_CHANGE_HANDLER","tag_default","bound","getChangeHandler","hook","analyzer","translator","watchFiles","modifier","tagNameId","tagNameVarPath","changeAttrName","buildChangeHandlerFunction","existingChangedAttr","changeHandlerAttr","changeHandlerId","changeHandlerConst","insertAfter","unshiftContainer","isPrivateName","cloneNode","newId","visitors","visitors2","_name","extractVisitors","Program","ReferencedIdentifier","ImportDeclaration","MarkoDocumentType","MarkoDeclaration","MarkoCDATA","MarkoText","MarkoTag","MarkoPlaceholder","MarkoScriptlet","MarkoComment"],"sourceRoot":""}