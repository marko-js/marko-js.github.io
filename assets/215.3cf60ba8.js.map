{"version":3,"file":"215.3cf60ba8.js","mappings":"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","sources":["webpack:///../../node_modules/@marko/translator-tags/dist/index.js"],"sourcesContent":["\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  analyze: () => analyze2,\n  getRuntimeEntryFiles: () => getRuntimeEntryFiles,\n  internalEntryBuilder: () => entry_builder_default,\n  taglibs: () => taglibs,\n  translate: () => translate2\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/util/is-core-tag.ts\nvar import_babel_utils = require(\"@marko/babel-utils\");\nvar taglibId = \"marko-core\";\nvar interopTaglibId = \"@marko/translator-interop-class-tags\";\nfunction isCoreTag(tag) {\n  const id = tag.isMarkoTag() && (0, import_babel_utils.getTagDef)(tag)?.taglibId;\n  return id === taglibId || id === interopTaglibId;\n}\nfunction isCoreTagName(tag, name) {\n  return isCoreTag(tag) && tag.node.name.value === name;\n}\n\n// src/core/__flush_here_and_after__.ts\nvar import_babel_utils2 = require(\"@marko/babel-utils\");\nvar flush_here_and_after_default = {\n  transform: [\n    (tag) => {\n      if ((0, import_babel_utils2.getTagDef)(tag)?.renderer) {\n        return;\n      }\n      tag.replaceWithMultiple(tag.node.body.body);\n    }\n  ]\n};\n\n// src/core/attrs.ts\nvar import_compiler = require(\"@marko/compiler\");\nvar attrs_default = {\n  migrate: [\n    (tag) => {\n      const tagVar = tag.node.var;\n      if (tagVar && !(tagVar.type === \"Identifier\" && tagVar.name === \"input\")) {\n        const constTag = import_compiler.types.markoTag(\n          import_compiler.types.stringLiteral(\"const\"),\n          [import_compiler.types.markoAttribute(\"value\", import_compiler.types.identifier(\"input\"))],\n          import_compiler.types.markoTagBody([])\n        );\n        constTag.var = tagVar;\n        tag.replaceWith(constTag);\n      } else {\n        tag.remove();\n      }\n    }\n  ],\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"attrs/{ ... }\",\n      description: \"Use to receive the attributes passed into this template.\",\n      snippet: \"attrs/{ $1 }$2\"\n    }\n  ]\n};\n\n// src/core/client.ts\nvar import_babel_utils3 = require(\"@marko/babel-utils\");\nvar import_compiler2 = require(\"@marko/compiler\");\nvar client_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^client\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils3.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler2.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler2.types.markoScriptlet(body, true, \"client\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"client <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the client.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#client-javascript\"\n    }\n  ]\n};\n\n// src/core/condition/else.ts\nvar import_babel_utils14 = require(\"@marko/babel-utils\");\n\n// src/core/condition/if.ts\nvar import_babel_utils13 = require(\"@marko/babel-utils\");\nvar import_compiler18 = require(\"@marko/compiler\");\n\n// src/util/references.ts\nvar import_compiler16 = require(\"@marko/compiler\");\n\n// src/util/get-root.ts\nfunction getMarkoRoot(path3) {\n  let curPath = path3;\n  do\n    curPath = curPath.parentPath;\n  while (!isMarko(curPath));\n  return curPath;\n}\nfunction getExprRoot(path3) {\n  let curPath = path3;\n  while (!isMarko(curPath.parentPath)) {\n    curPath = curPath.parentPath;\n    if (curPath.type === \"AssignmentExpression\") {\n      const destructRoot = getDestructureRoot(curPath);\n      if (isMarko(destructRoot.parentPath)) {\n        curPath = curPath.get(\"right\");\n        break;\n      }\n      curPath = destructRoot.parentPath;\n    }\n  }\n  return curPath;\n}\nfunction getFnRoot(path3) {\n  let curPath = path3;\n  if (curPath.isProgram())\n    return;\n  while (!isFunctionExpression(curPath)) {\n    if (isMarko(curPath))\n      return;\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction isMarko(path3) {\n  switch (path3.type) {\n    case \"MarkoTag\":\n    case \"MarkoTagBody\":\n    case \"MarkoAttribute\":\n    case \"MarkoSpreadAttribute\":\n    case \"MarkoPlaceholder\":\n    case \"MarkoScriptlet\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isFunctionExpression(path3) {\n  switch (path3.type) {\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction getDestructureRoot(path3) {\n  switch (path3.parent.type) {\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"ObjectProperty\":\n      return getDestructureRoot(path3.parentPath);\n    default:\n      return path3;\n  }\n}\n\n// src/visitors/program/index.ts\nvar import_path = __toESM(require(\"path\"));\nvar import_babel_utils12 = require(\"@marko/babel-utils\");\nvar import_compiler15 = require(\"@marko/compiler\");\n\n// src/util/binding-has-downstream-expressions.ts\nfunction bindingHasDownstreamExpressions(binding) {\n  if (binding.downstreamExpressions.size)\n    return true;\n  for (const alias of binding.aliases) {\n    if (bindingHasDownstreamExpressions(alias))\n      return true;\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    if (bindingHasDownstreamExpressions(alias))\n      return true;\n  }\n  return false;\n}\n\n// src/util/entry-builder.ts\nvar import_babel_utils4 = require(\"@marko/babel-utils\");\nvar import_compiler3 = require(\"@marko/compiler\");\nvar kState = Symbol();\nvar entry_builder_default = {\n  build(entryFile) {\n    const state = entryFile[kState];\n    if (!state) {\n      throw entryFile.path.buildCodeFrameError(\n        \"Unable to build hydrate code, no files were visited before finalizing the build\"\n      );\n    }\n    const body = state.imports.map(\n      (it) => import_compiler3.types.importDeclaration([], import_compiler3.types.stringLiteral(it))\n    );\n    if (state.init) {\n      body.unshift(\n        import_compiler3.types.importDeclaration(\n          [import_compiler3.types.importSpecifier(import_compiler3.types.identifier(\"init\"), import_compiler3.types.identifier(\"init\"))],\n          import_compiler3.types.stringLiteral(\n            `@marko/runtime-tags/${entryFile.markoOpts.optimize ? \"\" : \"debug/\"}dom`\n          )\n        )\n      );\n      body.push(\n        import_compiler3.types.expressionStatement(import_compiler3.types.callExpression(import_compiler3.types.identifier(\"init\"), []))\n      );\n    }\n    return body;\n  },\n  visit(file, entryFile, visitChild) {\n    const state = entryFile[kState] ||= {\n      imports: [],\n      init: false\n    };\n    const { analyzedTags } = file.metadata.marko;\n    state.imports.push(\n      (0, import_babel_utils4.resolveRelativePath)(entryFile, file.opts.filename)\n    );\n    state.init ||= file.path.node.extra.hasInteractiveChild || file.path.node.extra.isInteractive || false;\n    for (const tag of analyzedTags || []) {\n      visitChild(tag);\n    }\n  }\n};\n\n// src/util/sections.ts\nvar import_babel_utils6 = require(\"@marko/babel-utils\");\nvar import_compiler5 = require(\"@marko/compiler\");\n\n// src/util/state.ts\nvar createProgramState = (init) => {\n  const map = /* @__PURE__ */ new WeakMap();\n  return [\n    () => {\n      let state = map.get(currentProgramPath);\n      if (!state) {\n        map.set(currentProgramPath, state = init());\n      }\n      return state;\n    },\n    (value) => {\n      map.set(currentProgramPath, value);\n    }\n  ];\n};\nfunction createSectionState(key, init) {\n  return [\n    (section) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      const sectionData = arrayOfSectionData[section.id] ??= init && init(section);\n      return sectionData;\n    },\n    (section, value) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      arrayOfSectionData[section.id] = value;\n    }\n  ];\n}\n\n// src/util/tag-name-type.ts\nvar import_babel_utils5 = require(\"@marko/babel-utils\");\nvar import_compiler4 = require(\"@marko/compiler\");\n\n// src/util/with-previous-location.ts\nfunction withPreviousLocation(newNode, originalNode) {\n  newNode.start = originalNode.start;\n  newNode.loc = originalNode.loc;\n  newNode.end = originalNode.end;\n  return newNode;\n}\n\n// src/util/tag-name-type.ts\nvar MARKO_FILE_REG = /^<.*>$|\\.marko$/;\nfunction analyzeTagNameType(tag) {\n  const extra = tag.node.extra ??= {};\n  if (extra.tagNameType === void 0) {\n    const name = tag.get(\"name\");\n    if (name.isStringLiteral()) {\n      extra.tagNameType = name.node.value[0] === \"@\" ? 3 /* AttributeTag */ : (0, import_babel_utils5.isNativeTag)(tag) ? 0 /* NativeTag */ : 1 /* CustomTag */;\n      if (extra.tagNameType === 1 /* CustomTag */) {\n        const bindingName = name.node.value;\n        const bindingIdentifier = tag.scope.getBinding(bindingName)?.identifier;\n        if (bindingIdentifier) {\n          const tagIdentifier = withPreviousLocation(\n            import_compiler4.types.identifier(bindingName),\n            name.node\n          );\n          tagIdentifier.extra = {\n            referencedBindings: bindingIdentifier.extra?.binding\n          };\n          analyzeExpressionTagName(name.replaceWith(tagIdentifier)[0], extra);\n        } else {\n          const childFile = (0, import_babel_utils5.loadFileForTag)(tag);\n          const childProgram = childFile?.ast.program;\n          if (childProgram?.extra.featureType === \"class\") {\n            extra.tagNameType = 2 /* DynamicTag */;\n            extra.featureType = \"class\";\n          }\n        }\n      }\n      extra.tagNameNullable = extra.tagNameNullable = false;\n    } else {\n      analyzeExpressionTagName(name, extra);\n    }\n    if (extra.tagNameType === void 0) {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n  }\n  return extra.tagNameType;\n}\nfunction analyzeExpressionTagName(name, extra) {\n  const pending = [name];\n  let path3;\n  let type;\n  let nullable = false;\n  let tagNameImported;\n  while ((path3 = pending.pop()) && type !== 2 /* DynamicTag */) {\n    if (path3.isConditionalExpression()) {\n      pending.push(path3.get(\"consequent\"));\n      if (path3.node.alternate) {\n        pending.push(path3.get(\"alternate\"));\n      }\n    } else if (path3.isLogicalExpression()) {\n      if (path3.node.operator === \"||\") {\n        pending.push(path3.get(\"left\"));\n      } else {\n        nullable = true;\n      }\n      pending.push(path3.get(\"right\"));\n    } else if (path3.isAssignmentExpression()) {\n      pending.push(path3.get(\"right\"));\n    } else if (path3.isBinaryExpression()) {\n      type = path3.node.operator !== \"+\" || type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path3.isStringLiteral() || path3.isTemplateLiteral()) {\n      type = type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path3.isNullLiteral()) {\n      nullable = true;\n    } else if (path3.isIdentifier()) {\n      if (path3.node.name === \"undefined\") {\n        nullable = true;\n        continue;\n      }\n      const binding = path3.scope.getBinding(path3.node.name);\n      if (!binding) {\n        type = 2 /* DynamicTag */;\n        continue;\n      }\n      if (binding.kind === \"module\") {\n        const decl = binding.path.parent;\n        if (MARKO_FILE_REG.test(decl.source.value) && decl.specifiers.some((it) => import_compiler4.types.isImportDefaultSpecifier(it))) {\n          const resolvedImport = (0, import_babel_utils5.resolveTagImport)(name, decl.source.value) || decl.source.value;\n          if (type === 0 /* NativeTag */ || tagNameImported && tagNameImported !== resolvedImport) {\n            type = 2 /* DynamicTag */;\n            tagNameImported = void 0;\n          } else {\n            type = 1 /* CustomTag */;\n            tagNameImported = resolvedImport;\n          }\n        } else {\n          type = 2 /* DynamicTag */;\n        }\n        continue;\n      }\n      const bindingTag = binding.path;\n      if (bindingTag.isMarkoTag() && binding.kind === \"local\") {\n        const bindingTagName = bindingTag.get(\"name\").node.value;\n        if (bindingTagName === \"const\") {\n          pending.push(\n            bindingTag.get(\"attributes\")[0].get(\"value\")\n          );\n          continue;\n        }\n        if (bindingTagName === \"let\") {\n          type = 2 /* DynamicTag */;\n          continue;\n        }\n        continue;\n      }\n      type = 2 /* DynamicTag */;\n    } else {\n      type = 2 /* DynamicTag */;\n    }\n  }\n  extra.tagNameType = type;\n  extra.tagNameNullable = nullable;\n  extra.tagNameDynamic = true;\n  if (type === 1 /* CustomTag */ && tagNameImported) {\n    extra.tagNameImported = tagNameImported;\n  }\n}\n\n// src/util/sections.ts\nfunction startSection(path3) {\n  const extra = path3.node.extra ??= {};\n  let section = extra.section;\n  if (!section && (path3.type === \"Program\" || path3.get(\"body\").length)) {\n    const parentSection = path3.parentPath ? getOrCreateSection(path3.parentPath) : void 0;\n    const sectionNamePath = path3.parentPath?.get(\n      \"name\"\n    );\n    const sectionName = path3.isProgram() ? \"\" : currentProgramPath.scope.generateUid(\n      sectionNamePath.toString() + \"Body\"\n    );\n    const programExtra = path3.hub.file.path.node.extra ??= {};\n    const sections = programExtra.sections ??= [];\n    section = extra.section = {\n      id: sections.length,\n      name: sectionName,\n      depth: parentSection ? parentSection.depth + 1 : 0,\n      parent: parentSection,\n      closures: /* @__PURE__ */ new Set(),\n      bindings: /* @__PURE__ */ new Set(),\n      startNodeContentType: getStartNodeContentType(path3),\n      endNodeContentType: getEndNodeContentType(path3),\n      upstreamExpression: void 0\n    };\n    sections.push(section);\n  }\n  return section;\n}\nfunction getOrCreateSection(path3) {\n  let cur = path3;\n  while (true) {\n    if (cur.type === \"Program\" || cur.type === \"MarkoTagBody\" && analyzeTagNameType(cur.parentPath) !== 0 /* NativeTag */ && cur.parent.name.value !== \"html-comment\") {\n      return startSection(cur);\n    }\n    cur = cur.parentPath;\n  }\n}\nfunction hasSection(path3) {\n  return path3.node.extra?.section !== void 0;\n}\nfunction getSection(path3) {\n  let section;\n  let currentPath = path3;\n  while ((section = currentPath.node.extra?.section) === void 0) {\n    currentPath = currentPath.parentPath;\n  }\n  _setSectionPath(\n    section,\n    currentPath\n  );\n  return section;\n}\nvar [getScopeIdIdentifier] = createSectionState(\n  \"scopeIdIdentifier\",\n  (section) => currentProgramPath.scope.generateUidIdentifier(`scope${section.id}_id`)\n);\nvar [getSectionPath, _setSectionPath] = createSectionState(\"sectionPath\");\nvar [_getScopeIdentifier] = createSectionState(\n  \"scopeIdentifier\",\n  () => import_compiler5.types.identifier(\"undefined\")\n);\nvar getScopeIdentifier = (section, ignoreDefault) => {\n  const scopeId = _getScopeIdentifier(section);\n  if (!ignoreDefault && scopeId.name === \"undefined\") {\n    scopeId.name = currentProgramPath.scope.generateUid(`scope${section.id}_`);\n  }\n  return scopeId;\n};\nfunction forEachSection(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  sections?.forEach(fn);\n}\nfunction forEachSectionReverse(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  for (let i = sections.length; i--; ) {\n    fn(sections[i]);\n  }\n}\nfunction getStartNodeContentType(path3) {\n  for (const child of path3.get(\"body\")) {\n    const contentType = getNodeContentType(child, \"startNodeContentType\");\n    if (contentType !== 2 /* Empty */) {\n      return contentType;\n    }\n  }\n  return 2 /* Empty */;\n}\nfunction getEndNodeContentType(path3) {\n  const body = path3.get(\"body\");\n  for (let i = body.length; i--; ) {\n    const contentType = getNodeContentType(body[i], \"endNodeContentType\");\n    if (contentType !== 2 /* Empty */) {\n      return contentType;\n    }\n  }\n  return 2 /* Empty */;\n}\nfunction getNodeContentType(path3, extraMember) {\n  if (import_compiler5.types.isMarkoText(path3)) {\n    return 5 /* Text */;\n  }\n  if (import_compiler5.types.isMarkoPlaceholder(path3)) {\n    return 3 /* Placeholder */;\n  }\n  if (import_compiler5.types.isMarkoScriptlet(path3) || import_compiler5.types.isMarkoComment(path3)) {\n    return 2 /* Empty */;\n  }\n  if (import_compiler5.types.isMarkoTag(path3.node)) {\n    const tag = path3;\n    if ((0, import_babel_utils6.isNativeTag)(tag)) {\n      return 4 /* Tag */;\n    }\n    if ((0, import_babel_utils6.isAttributeTag)(tag)) {\n      return 2 /* Empty */;\n    }\n    if (import_compiler5.types.isStringLiteral(path3.node.name)) {\n      switch (path3.node.name.value) {\n        case \"html-comment\":\n          return 0 /* Comment */;\n        case \"let\":\n        case \"const\":\n        case \"attrs\":\n        case \"effect\":\n        case \"lifecycle\":\n        case \"return\":\n        case \"id\":\n        case \"define\":\n          return 2 /* Empty */;\n      }\n      const tagSection = (0, import_babel_utils6.loadFileForTag)(tag)?.ast.program.extra.section;\n      if (tagSection) {\n        return tagSection[extraMember] ?? 2 /* Empty */;\n      }\n    }\n  }\n  return 1 /* Dynamic */;\n}\nvar isStatefulSection = (section) => {\n  const upstreamExpression = section.upstreamExpression;\n  return !upstreamExpression || isStatefulReferences(upstreamExpression.referencedBindings);\n};\nvar checkStatefulClosures = (section, immediateOnly) => {\n  for (const binding of section.closures) {\n    if ((!immediateOnly || section.parent === binding.section) && isStatefulReferences(binding)) {\n      return true;\n    }\n  }\n};\n\n// src/visitors/program/dom.ts\nvar import_babel_utils10 = require(\"@marko/babel-utils\");\nvar import_compiler13 = require(\"@marko/compiler\");\n\n// src/util/runtime.ts\nvar import_babel_utils7 = require(\"@marko/babel-utils\");\nvar import_compiler7 = require(\"@marko/compiler\");\n\n// ../runtime-tags/src/html/content.ts\nfunction toString(val) {\n  return val ? val + \"\" : val === 0 ? \"0\" : \"\";\n}\nvar unsafeXMLReg = /[<&]/g;\nvar replaceUnsafeXML = (c) => c === \"&\" ? \"&amp;\" : \"&lt;\";\nvar escapeXMLStr = (str) => unsafeXMLReg.test(str) ? str.replace(unsafeXMLReg, replaceUnsafeXML) : str;\nfunction escapeXML(val) {\n  return val ? escapeXMLStr(val + \"\") : val === 0 ? \"0\" : \"&zwj;\";\n}\nvar unsafeScriptReg = /<\\/script/g;\nvar escapeScriptStr = (str) => unsafeScriptReg.test(str) ? str.replace(unsafeScriptReg, \"\\\\x3C/script\") : str;\nfunction escapeScript(val) {\n  return val ? escapeScriptStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\nvar unsafeStyleReg = /<\\/style/g;\nvar escapeStyleStr = (str) => unsafeStyleReg.test(str) ? str.replace(unsafeStyleReg, \"\\\\3C/style\") : str;\nfunction escapeStyle(val) {\n  return val ? escapeStyleStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\n\n// ../runtime-tags/src/common/helpers.ts\nfunction classValue(value) {\n  return toDelimitedString(value, \" \", stringifyClassObject);\n}\nfunction stringifyClassObject(name, value) {\n  return value ? name : \"\";\n}\nfunction styleValue(value) {\n  return toDelimitedString(value, \";\", stringifyStyleObject);\n}\nvar NON_DIMENSIONAL = /^(--|ta|or|li|z)|n-c|i(do|nk|m|t)|w$|we/;\nfunction stringifyStyleObject(name, value) {\n  return value || value === 0 ? `${name}:${typeof value === \"number\" && value && !NON_DIMENSIONAL.test(name) ? value + \"px\" : value}` : \"\";\n}\nfunction toDelimitedString(val, delimiter, stringify) {\n  switch (typeof val) {\n    case \"string\":\n      return val;\n    case \"object\":\n      if (val !== null) {\n        let result = \"\";\n        let curDelimiter = \"\";\n        if (Array.isArray(val)) {\n          for (const v of val) {\n            const part = toDelimitedString(v, delimiter, stringify);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        } else {\n          for (const name in val) {\n            const v = val[name];\n            const part = stringify(name, v);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        }\n        return result;\n      }\n  }\n  return \"\";\n}\nfunction isVoid(value) {\n  return value == null || value === false;\n}\n\n// ../runtime-tags/src/html/reorder-runtime.ts\nfunction reorder_runtime_default(id, doc, walker, node, replacementNode, targetParent, targetNode, refNode, nextNode, runtimePrefix) {\n  runtimePrefix = \"RUNTIME_ID$\";\n  id = runtimePrefix + id;\n  doc = document;\n  walker = doc[runtimePrefix + \"w\"] || (doc[runtimePrefix + \"w\"] = doc.createTreeWalker(\n    doc,\n    128\n  ));\n  while (node = walker.nextNode()) {\n    if (node.data.indexOf(runtimePrefix) === 0) {\n      walker[node.data] = node;\n    }\n  }\n  replacementNode = doc.getElementById(id);\n  targetNode = walker[id];\n  targetParent = targetNode.parentNode;\n  while (refNode = replacementNode.firstChild) {\n    targetParent.insertBefore(refNode, targetNode);\n  }\n  nextNode = replacementNode.parentNode;\n  nextNode.removeChild(replacementNode.nextSibling);\n  nextNode.removeChild(replacementNode);\n  refNode = walker[id + \"/\"];\n  while (targetNode && (nextNode = targetNode.nextSibling, targetParent.removeChild(targetNode) !== refNode)) {\n    targetNode = nextNode;\n  }\n}\n\n// ../runtime-tags/src/html/serializer.ts\nvar { hasOwnProperty } = {};\nvar Generator = function* () {\n}().constructor;\nvar AsyncGenerator = async function* () {\n}().constructor;\nvar REF_START_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$\";\nvar REF_START_CHARS_LEN = REF_START_CHARS.length;\nvar REF_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_\";\nvar REF_CHARS_LEN = REF_CHARS.length;\nvar KNOWN_SYMBOLS = (() => {\n  const KNOWN_SYMBOLS2 = /* @__PURE__ */ new Map();\n  for (const name of Object.getOwnPropertyNames(Symbol)) {\n    const symbol = Symbol[name];\n    if (typeof symbol === \"symbol\") {\n      KNOWN_SYMBOLS2.set(symbol, \"Symbol.\" + name);\n    }\n  }\n  return KNOWN_SYMBOLS2;\n})();\nvar KNOWN_FUNCTIONS = /* @__PURE__ */ new Map([\n  // This is by no means an exhaustive list,\n  // but it should cover most of the built-in functions.\n  [AggregateError, \"AggregateError\"],\n  [Array, \"Array\"],\n  [Array.from, \"Array.from\"],\n  [Array.isArray, \"Array.isArray\"],\n  [Array.of, \"Array.of\"],\n  [ArrayBuffer, \"ArrayBuffer\"],\n  [ArrayBuffer.isView, \"ArrayBuffer.isView\"],\n  [Atomics.add, \"Atomics.add\"],\n  [Atomics.and, \"Atomics.and\"],\n  [Atomics.compareExchange, \"Atomics.compareExchange\"],\n  [Atomics.exchange, \"Atomics.exchange\"],\n  [Atomics.isLockFree, \"Atomics.isLockFree\"],\n  [Atomics.load, \"Atomics.load\"],\n  [Atomics.notify, \"Atomics.notify\"],\n  [Atomics.or, \"Atomics.or\"],\n  [Atomics.store, \"Atomics.store\"],\n  [Atomics.sub, \"Atomics.sub\"],\n  [Atomics.wait, \"Atomics.wait\"],\n  [BigInt, \"BigInt\"],\n  [BigInt.asIntN, \"BigInt.asIntN\"],\n  [BigInt.asUintN, \"BigInt.asUintN\"],\n  [BigInt64Array, \"BigInt64Array\"],\n  [BigInt64Array.from, \"BigInt64Array.from\"],\n  [BigInt64Array.of, \"BigInt64Array.of\"],\n  [BigUint64Array, \"BigUint64Array\"],\n  [BigUint64Array.from, \"BigUint64Array.from\"],\n  [BigUint64Array.of, \"BigUint64Array.of\"],\n  [Boolean, \"Boolean\"],\n  [console.assert, \"console.assert\"],\n  [console.clear, \"console.clear\"],\n  [console.count, \"console.count\"],\n  [console.countReset, \"console.countReset\"],\n  [console.debug, \"console.debug\"],\n  [console.dir, \"console.dir\"],\n  [console.dirxml, \"console.dirxml\"],\n  [console.error, \"console.error\"],\n  [console.group, \"console.group\"],\n  [console.groupCollapsed, \"console.groupCollapsed\"],\n  [console.groupEnd, \"console.groupEnd\"],\n  [console.info, \"console.info\"],\n  [console.log, \"console.log\"],\n  [console.table, \"console.table\"],\n  [console.time, \"console.time\"],\n  [console.timeEnd, \"console.timeEnd\"],\n  [console.timeLog, \"console.timeLog\"],\n  [console.timeStamp, \"console.timeStamp\"],\n  [console.trace, \"console.trace\"],\n  [console.warn, \"console.warn\"],\n  [DataView, \"DataView\"],\n  [Date, \"Date\"],\n  [Date.now, \"Date.now\"],\n  [Date.parse, \"Date.parse\"],\n  [Date.UTC, \"Date.UTC\"],\n  [decodeURI, \"decodeURI\"],\n  [decodeURIComponent, \"decodeURIComponent\"],\n  [encodeURI, \"encodeURI\"],\n  [encodeURIComponent, \"encodeURIComponent\"],\n  [Error, \"Error\"],\n  [EvalError, \"EvalError\"],\n  [Float32Array, \"Float32Array\"],\n  [Float32Array.from, \"Float32Array.from\"],\n  [Float32Array.of, \"Float32Array.of\"],\n  [Float64Array, \"Float64Array\"],\n  [Float64Array.from, \"Float64Array.from\"],\n  [Float64Array.of, \"Float64Array.of\"],\n  [Function, \"Function\"],\n  [globalThis.atob, \"atob\"],\n  [globalThis.btoa, \"btoa\"],\n  [globalThis.clearImmediate, \"clearImmediate\"],\n  [globalThis.clearInterval, \"clearInterval\"],\n  [globalThis.clearTimeout, \"clearTimeout\"],\n  [globalThis.crypto?.getRandomValues, \"crypto.getRandomValues\"],\n  [globalThis.crypto?.randomUUID, \"crypto.randomUUID\"],\n  [globalThis.fetch, \"fetch\"],\n  [globalThis.performance?.now, \"performance.now\"],\n  [globalThis.queueMicrotask, \"queueMicrotask\"],\n  [globalThis.setImmediate, \"setImmediate\"],\n  [globalThis.setInterval, \"setInterval\"],\n  [globalThis.setTimeout, \"setTimeout\"],\n  [globalThis.structuredClone, \"structuredClone\"],\n  [globalThis.URL, \"URL\"],\n  [globalThis.URLSearchParams, \"URLSearchParams\"],\n  [globalThis.WritableStream, \"WritableStream\"],\n  [Int16Array, \"Int16Array\"],\n  [Int16Array.from, \"Int16Array.from\"],\n  [Int16Array.of, \"Int16Array.of\"],\n  [Int32Array, \"Int32Array\"],\n  [Int32Array.from, \"Int32Array.from\"],\n  [Int32Array.of, \"Int32Array.of\"],\n  [Int8Array, \"Int8Array\"],\n  [Int8Array.from, \"Int8Array.from\"],\n  [Int8Array.of, \"Int8Array.of\"],\n  [Intl.Collator, \"Intl.Collator\"],\n  [Intl.DateTimeFormat, \"Intl.DateTimeFormat\"],\n  [Intl.DisplayNames, \"Intl.DisplayNames\"],\n  [Intl.getCanonicalLocales, \"Intl.getCanonicalLocales\"],\n  [Intl.ListFormat, \"Intl.ListFormat\"],\n  [Intl.Locale, \"Intl.Locale\"],\n  [Intl.NumberFormat, \"Intl.NumberFormat\"],\n  [Intl.PluralRules, \"Intl.PluralRules\"],\n  [Intl.RelativeTimeFormat, \"Intl.RelativeTimeFormat\"],\n  [Intl.Segmenter, \"Intl.Segmenter\"],\n  [Intl.supportedValuesOf, \"Intl.supportedValuesOf\"],\n  [isFinite, \"isFinite\"],\n  [isNaN, \"isNaN\"],\n  [JSON.parse, \"JSON.parse\"],\n  [JSON.stringify, \"JSON.stringify\"],\n  [Map, \"Map\"],\n  [Map.groupBy, \"Map.groupBy\"],\n  [Math.abs, \"Math.abs\"],\n  [Math.acos, \"Math.acos\"],\n  [Math.acosh, \"Math.acosh\"],\n  [Math.asin, \"Math.asin\"],\n  [Math.asinh, \"Math.asinh\"],\n  [Math.atan, \"Math.atan\"],\n  [Math.atan2, \"Math.atan2\"],\n  [Math.atanh, \"Math.atanh\"],\n  [Math.cbrt, \"Math.cbrt\"],\n  [Math.ceil, \"Math.ceil\"],\n  [Math.clz32, \"Math.clz32\"],\n  [Math.cos, \"Math.cos\"],\n  [Math.cosh, \"Math.cosh\"],\n  [Math.exp, \"Math.exp\"],\n  [Math.expm1, \"Math.expm1\"],\n  [Math.floor, \"Math.floor\"],\n  [Math.fround, \"Math.fround\"],\n  [Math.hypot, \"Math.hypot\"],\n  [Math.imul, \"Math.imul\"],\n  [Math.log, \"Math.log\"],\n  [Math.log10, \"Math.log10\"],\n  [Math.log1p, \"Math.log1p\"],\n  [Math.log2, \"Math.log2\"],\n  [Math.max, \"Math.max\"],\n  [Math.min, \"Math.min\"],\n  [Math.pow, \"Math.pow\"],\n  [Math.random, \"Math.random\"],\n  [Math.round, \"Math.round\"],\n  [Math.sign, \"Math.sign\"],\n  [Math.sin, \"Math.sin\"],\n  [Math.sinh, \"Math.sinh\"],\n  [Math.sqrt, \"Math.sqrt\"],\n  [Math.tan, \"Math.tan\"],\n  [Math.tanh, \"Math.tanh\"],\n  [Math.trunc, \"Math.trunc\"],\n  [Number, \"Number\"],\n  [Number.isFinite, \"Number.isFinite\"],\n  [Number.isInteger, \"Number.isInteger\"],\n  [Number.isNaN, \"Number.isNaN\"],\n  [Number.isSafeInteger, \"Number.isSafeInteger\"],\n  [Number.parseFloat, \"Number.parseFloat\"],\n  [Number.parseInt, \"Number.parseInt\"],\n  [Object, \"Object\"],\n  [Object.assign, \"Object.assign\"],\n  [Object.create, \"Object.create\"],\n  [Object.defineProperties, \"Object.defineProperties\"],\n  [Object.defineProperty, \"Object.defineProperty\"],\n  [Object.entries, \"Object.entries\"],\n  [Object.freeze, \"Object.freeze\"],\n  [Object.fromEntries, \"Object.fromEntries\"],\n  [Object.getOwnPropertyDescriptor, \"Object.getOwnPropertyDescriptor\"],\n  [Object.getOwnPropertyDescriptors, \"Object.getOwnPropertyDescriptors\"],\n  [Object.getOwnPropertyNames, \"Object.getOwnPropertyNames\"],\n  [Object.getOwnPropertySymbols, \"Object.getOwnPropertySymbols\"],\n  [Object.getPrototypeOf, \"Object.getPrototypeOf\"],\n  [Object.is, \"Object.is\"],\n  [Object.isExtensible, \"Object.isExtensible\"],\n  [Object.isFrozen, \"Object.isFrozen\"],\n  [Object.isSealed, \"Object.isSealed\"],\n  [Object.keys, \"Object.keys\"],\n  [Object.preventExtensions, \"Object.preventExtensions\"],\n  [Object.seal, \"Object.seal\"],\n  [Object.setPrototypeOf, \"Object.setPrototypeOf\"],\n  [Object.values, \"Object.values\"],\n  [parseFloat, \"parseFloat\"],\n  [parseInt, \"parseInt\"],\n  [Promise, \"Promise\"],\n  [Proxy, \"Proxy\"],\n  [RangeError, \"RangeError\"],\n  [ReferenceError, \"ReferenceError\"],\n  [Reflect.apply, \"Reflect.apply\"],\n  [Reflect.construct, \"Reflect.construct\"],\n  [Reflect.defineProperty, \"Reflect.defineProperty\"],\n  [Reflect.deleteProperty, \"Reflect.deleteProperty\"],\n  [Reflect.get, \"Reflect.get\"],\n  [Reflect.getOwnPropertyDescriptor, \"Reflect.getOwnPropertyDescriptor\"],\n  [Reflect.getPrototypeOf, \"Reflect.getPrototypeOf\"],\n  [Reflect.has, \"Reflect.has\"],\n  [Reflect.isExtensible, \"Reflect.isExtensible\"],\n  [Reflect.ownKeys, \"Reflect.ownKeys\"],\n  [Reflect.preventExtensions, \"Reflect.preventExtensions\"],\n  [Reflect.set, \"Reflect.set\"],\n  [Reflect.setPrototypeOf, \"Reflect.setPrototypeOf\"],\n  [RegExp, \"RegExp\"],\n  [Set, \"Set\"],\n  [String, \"String\"],\n  [String.fromCharCode, \"String.fromCharCode\"],\n  [String.fromCodePoint, \"String.fromCodePoint\"],\n  [String.raw, \"String.raw\"],\n  [Symbol, \"Symbol\"],\n  [Symbol.for, \"Symbol.for\"],\n  [SyntaxError, \"SyntaxError\"],\n  [TypeError, \"TypeError\"],\n  [Uint16Array, \"Uint16Array\"],\n  [Uint16Array.from, \"Uint16Array.from\"],\n  [Uint16Array.of, \"Uint16Array.of\"],\n  [Uint32Array, \"Uint32Array\"],\n  [Uint32Array.from, \"Uint32Array.from\"],\n  [Uint32Array.of, \"Uint32Array.of\"],\n  [Uint8Array, \"Uint8Array\"],\n  [Uint8Array.from, \"Uint8Array.from\"],\n  [Uint8Array.of, \"Uint8Array.of\"],\n  [Uint8ClampedArray, \"Uint8ClampedArray\"],\n  [Uint8ClampedArray.from, \"Uint8ClampedArray.from\"],\n  [Uint8ClampedArray.of, \"Uint8ClampedArray.of\"],\n  [URIError, \"URIError\"],\n  [WeakMap, \"WeakMap\"],\n  [WeakSet, \"WeakSet\"]\n]);\nvar KNOWN_OBJECTS = /* @__PURE__ */ new Map([\n  [Atomics, \"Atomics\"],\n  [console, \"console\"],\n  [globalThis, \"globalThis\"],\n  [globalThis.crypto, \"crypto\"],\n  [Intl, \"Intl\"],\n  [JSON, \"JSON\"],\n  [Math, \"Math\"],\n  [Reflect, \"Reflect\"]\n]);\n\n// ../runtime-tags/src/html/writer.ts\nvar kScopeId = Symbol(\"scopeId\");\nvar runtimeId = \"M\" /* DefaultRuntimeId */;\nvar reorderRuntimeString = String(reorder_runtime_default).replace(\n  \"RUNTIME_ID\",\n  runtimeId\n);\n\n// ../runtime-tags/src/html/attrs.ts\nfunction classAttr(val) {\n  return stringAttr(\"class\", classValue(val));\n}\nfunction styleAttr(val) {\n  return stringAttr(\"style\", styleValue(val));\n}\nfunction attr(name, val) {\n  return isVoid(val) ? \"\" : nonVoidAttr(name, val);\n}\nfunction stringAttr(name, val) {\n  return val && ` ${name}=${escapeAttrValue(val)}`;\n}\nfunction nonVoidAttr(name, val) {\n  switch (typeof val) {\n    case \"string\":\n      return ` ${name + attrAssignment(val)}`;\n    case \"boolean\":\n      return ` ${name}`;\n    case \"number\":\n      return ` ${name}=${val}`;\n    case \"object\":\n      if (val instanceof RegExp) {\n        return ` ${name + attrAssignment(val.source)}`;\n      }\n      break;\n  }\n  return ` ${name + attrAssignment(val + \"\")}`;\n}\nfunction attrAssignment(val) {\n  return val ? `=${escapeAttrValue(val)}` : \"\";\n}\nvar unsafeAttrChars = /[\"'>\\s]/g;\nfunction escapeAttrValue(str) {\n  if (unsafeAttrChars.test(str)) {\n    const c = str[unsafeAttrChars.lastIndex - 1];\n    unsafeAttrChars.lastIndex = 0;\n    return c === '\"' ? `'${str.replace(/'/g, \"&#39;\")}'` : `\"${str.replace(/\"/g, \"&#34;\")}\"`;\n  }\n  return str;\n}\n\n// src/util/scope-read.ts\nvar import_compiler6 = require(\"@marko/compiler\");\n\n// src/util/optional.ts\nvar Sorted = class {\n  constructor(compare) {\n    this.compare = compare;\n  }\n  add(data, item) {\n    return data ? Array.isArray(data) ? addSorted(this.compare, data, item) : joinRepeatable(this.compare, data, item) : item;\n  }\n  union(a, b) {\n    if (a) {\n      if (Array.isArray(a)) {\n        if (b) {\n          if (Array.isArray(b)) {\n            return unionSortedRepeatable(this.compare, a, b);\n          } else {\n            return addSorted(this.compare, a, b);\n          }\n        }\n        return a;\n      }\n      if (b) {\n        if (Array.isArray(b)) {\n          return addSorted(this.compare, b, a);\n        }\n        return joinRepeatable(this.compare, b, a);\n      }\n      return a;\n    }\n    return b;\n  }\n  find(data, item) {\n    if (data) {\n      if (Array.isArray(data)) {\n        return findSorted(this.compare, data, item);\n      } else if (this.compare(data, item) === 0) {\n        return data;\n      }\n    }\n  }\n};\nfunction push(data, item) {\n  if (data) {\n    if (Array.isArray(data)) {\n      data.push(item);\n      return data;\n    }\n    return [data, item];\n  }\n  return item;\n}\nfunction forEach(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      for (const item of data) {\n        cb(item);\n      }\n    } else {\n      cb(data);\n    }\n  }\n}\nfunction findSorted(compare, data, item) {\n  let max = data.length;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const cur = data[mid];\n    const compareResult = compare(cur, item);\n    if (compareResult === 0)\n      return cur;\n    if (compareResult > 0)\n      max = mid;\n    else\n      pos = mid + 1;\n  }\n}\nfunction addSorted(compare, data, item) {\n  const len = data.length;\n  let max = len;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(data[mid], item);\n    if (compareResult === 0)\n      return data;\n    if (compareResult > 0)\n      max = mid;\n    else\n      pos = mid + 1;\n  }\n  const result = new Array(len + 1);\n  for (let i = 0; i < pos; i++) {\n    result[i] = data[i];\n  }\n  let cur = item;\n  while (pos < len) {\n    const next = cur;\n    cur = data[pos];\n    result[pos++] = next;\n  }\n  result[len] = cur;\n  return result;\n}\nfunction unionSortedRepeatable(compare, a, b) {\n  const aLen = a.length;\n  const bLen = b.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  const result = [\n    compare(a[aIndex], b[bIndex]) <= 0 ? a[aIndex++] : b[bIndex++],\n    compare(a[aIndex], b[bIndex]) <= 0 ? a[aIndex++] : b[bIndex++]\n  ];\n  while (aIndex < aLen && bIndex < bLen) {\n    result.push(compare(a[aIndex], b[bIndex]) <= 0 ? a[aIndex++] : b[bIndex++]);\n  }\n  if (aLen === bLen && aIndex === aLen) {\n    return a;\n  }\n  while (aIndex < aLen) {\n    result.push(a[aIndex++]);\n  }\n  while (bIndex < bLen) {\n    result.push(b[bIndex++]);\n  }\n  return result;\n}\nfunction joinRepeatable(compare, a, b) {\n  const compareResult = compare(a, b);\n  return compareResult === 0 ? a : compareResult < 0 ? [a, b] : [b, a];\n}\n\n// src/util/scope-read.ts\nfunction createScopeReadPattern(section, referencedBindings) {\n  const rootDepth = section.depth;\n  const rootPattern = import_compiler6.types.objectPattern([]);\n  let nestedPatterns;\n  forEach(referencedBindings, (ref) => {\n    if (ref.name.includes(\"#\"))\n      return;\n    const propertyKey = getScopeAccessorLiteral(ref);\n    const propertyValue = import_compiler6.types.identifier(ref.name);\n    const isShorthand = propertyKey.value === propertyValue.name;\n    let pattern = rootPattern;\n    if (ref.section !== section) {\n      if (!nestedPatterns)\n        nestedPatterns = [rootPattern];\n      const relativeDepth = rootDepth - ref.section.depth;\n      let i = nestedPatterns.length;\n      let prev = nestedPatterns[i - 1];\n      for (; i <= relativeDepth; i++) {\n        const nestedPattern = import_compiler6.types.objectPattern([]);\n        prev.properties.push(\n          import_compiler6.types.objectProperty(import_compiler6.types.identifier(\"_\"), nestedPattern)\n        );\n        nestedPatterns.push(nestedPattern);\n        prev = nestedPattern;\n      }\n      pattern = nestedPatterns[relativeDepth];\n    }\n    pattern.properties.push(\n      import_compiler6.types.objectProperty(\n        isShorthand ? propertyValue : propertyKey,\n        propertyValue,\n        false,\n        isShorthand\n      )\n    );\n  });\n  return rootPattern;\n}\nfunction getScopeExpression(section, targetSection) {\n  let scope = scopeIdentifier ?? import_compiler6.types.identifier(\"undefined\");\n  const diff = section.depth - targetSection.depth;\n  for (let i = 0; i < diff; i++) {\n    scope = import_compiler6.types.memberExpression(scope, import_compiler6.types.identifier(\"_\"));\n  }\n  if (diff < 0) {\n    throw new Error(\"Unable to find scope for reference.\");\n  }\n  return scope;\n}\nfunction createScopeReadExpression(section, reference) {\n  return import_compiler6.types.memberExpression(\n    getScopeExpression(section, reference.section),\n    getScopeAccessorLiteral(reference),\n    true\n  );\n}\n\n// src/util/runtime.ts\nvar pureFunctions = [\n  \"createTemplate\",\n  \"createRenderer\",\n  \"value\",\n  \"intersection\",\n  \"closure\",\n  \"dynamicClosure\",\n  \"loopOf\",\n  \"loopIn\",\n  \"loopTo\",\n  \"conditional\",\n  \"bindFunction\",\n  \"bindRenderer\"\n];\nfunction importRuntime(name) {\n  const { output } = getMarkoOpts();\n  return (0, import_babel_utils7.importNamed)(currentProgramPath.hub.file, getRuntimePath(output), name);\n}\nfunction callRuntime(name, ...args) {\n  const callExpression2 = import_compiler7.types.callExpression(\n    importRuntime(name),\n    filterArguments(args)\n  );\n  if (pureFunctions.includes(\n    name\n  )) {\n    callExpression2.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: ` @__PURE__ `\n      }\n    ];\n  }\n  return callExpression2;\n}\nfunction getHTMLRuntime() {\n  return {\n    escapeXML,\n    toString,\n    attr,\n    classAttr,\n    styleAttr,\n    escapeScript,\n    escapeStyle\n  };\n}\nfunction getRuntimePath(output) {\n  const { optimize } = getMarkoOpts();\n  return `@marko/runtime-tags/${optimize ? \"\" : \"debug/\"}${output === \"html\" ? \"html\" : \"dom\"}`;\n}\nfunction filterArguments(args) {\n  const filteredArgs = [];\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (arg || filteredArgs.length) {\n      filteredArgs[i] = arg || import_compiler7.types.unaryExpression(\"void\", import_compiler7.types.numericLiteral(0));\n    }\n  }\n  return filteredArgs;\n}\n\n// src/util/signals.ts\nvar import_babel_utils9 = require(\"@marko/babel-utils\");\nvar import_compiler12 = require(\"@marko/compiler\");\n\n// src/core/return.ts\nvar import_babel_utils8 = require(\"@marko/babel-utils\");\nvar import_compiler11 = require(\"@marko/compiler\");\n\n// src/util/assert.ts\nfunction assertNoSpreadAttrs(tag) {\n  for (const attr2 of tag.get(\"attributes\")) {\n    if (attr2.isMarkoSpreadAttribute()) {\n      throw attr2.buildCodeFrameError(\n        `The <${tag.get(\"name\")}> tag does not support ...spread attributes.`\n      );\n    }\n  }\n}\nfunction assertNoBodyContent(tag) {\n  if (tag.node.body.body.length) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The <${tag.get(\"name\")}> tag does not support body content.`\n    );\n  }\n}\n\n// src/util/writer.ts\nvar import_compiler10 = require(\"@marko/compiler\");\n\n// src/util/to-template-string-or-literal.ts\nvar import_compiler8 = require(\"@marko/compiler\");\nfunction toTemplateOrStringLiteral(parts) {\n  const strs = [];\n  const exprs = [];\n  let curStr = parts[0];\n  for (let i = 1; i < parts.length; i++) {\n    let content = parts[i];\n    if (typeof content === \"object\") {\n      if (import_compiler8.types.isStringLiteral(content)) {\n        content = content.value;\n      } else if (import_compiler8.types.isTemplateLiteral(content)) {\n        let nextIndex = i + 1;\n        const exprLen = content.expressions.length;\n        shiftItems(parts, nextIndex, content.quasis.length + exprLen);\n        for (let j = 0; j < exprLen; j++) {\n          parts[nextIndex++] = content.quasis[j].value.raw;\n          parts[nextIndex++] = content.expressions[j];\n        }\n        parts[nextIndex] = content.quasis[exprLen].value.raw;\n        continue;\n      } else {\n        exprs.push(content);\n        strs.push(curStr);\n        curStr = \"\";\n        continue;\n      }\n    }\n    curStr += content;\n  }\n  if (exprs.length) {\n    strs.push(curStr);\n    return import_compiler8.types.templateLiteral(\n      strs.map((raw) => import_compiler8.types.templateElement({ raw })),\n      exprs\n    );\n  } else if (curStr) {\n    return import_compiler8.types.stringLiteral(curStr);\n  }\n}\nfunction appendLiteral(arr, str) {\n  arr[arr.length - 1] += str;\n}\nfunction shiftItems(list, start, offset) {\n  for (let i = list.length - 1; i >= start; i--) {\n    list[i + offset] = list[i];\n  }\n}\n\n// src/util/walks.ts\nvar import_compiler9 = require(\"@marko/compiler\");\nvar [getWalks] = createSectionState(\n  \"walks\",\n  () => [\"\"]\n);\nvar [getWalkComment] = createSectionState(\n  \"walkComment\",\n  () => []\n);\nvar [getSteps] = createSectionState(\"steps\", () => []);\nvar walkCodeToName = {\n  [32 /* Get */]: \"get\",\n  [33 /* Before */]: \"before\",\n  [35 /* After */]: \"after\",\n  [36 /* Inside */]: \"inside\",\n  [37 /* Replace */]: \"replace\",\n  [38 /* EndChild */]: \"endChild\",\n  [47 /* BeginChild */]: \"beginChild\",\n  [67 /* Next */]: \"next\",\n  [97 /* Over */]: \"over\",\n  [107 /* Out */]: \"out\",\n  [117 /* Multiplier */]: \"multiplier\",\n  [91 /* NextEnd */]: \"nextEnd\",\n  [106 /* OverEnd */]: \"overEnd\",\n  [116 /* OutEnd */]: \"outEnd\",\n  [126 /* MultiplierEnd */]: \"multiplierEnd\"\n};\nfunction enter(path3) {\n  getSteps(getSection(path3)).push(0 /* Enter */);\n}\nfunction exit(path3) {\n  getSteps(getSection(path3)).push(1 /* Exit */);\n}\nfunction enterShallow(path3) {\n  getSteps(getSection(path3)).push(0 /* Enter */, 1 /* Exit */);\n}\nfunction injectWalks(path3, expr) {\n  const walks = getWalks(getSection(path3));\n  const walkComment = getWalkComment(getSection(path3));\n  walkComment.push(\n    `${walkCodeToName[47 /* BeginChild */]}`,\n    expr.name,\n    walkCodeToName[38 /* EndChild */]\n  );\n  appendLiteral(walks, String.fromCharCode(47 /* BeginChild */));\n  walks.push(expr, String.fromCharCode(38 /* EndChild */));\n}\nfunction visit(path3, code) {\n  if (isOutputHTML()) {\n    return;\n  }\n  const section = getSection(path3);\n  const steps = getSteps(section);\n  const walks = getWalks(section);\n  const walkComment = getWalkComment(section);\n  let walkString = \"\";\n  if (steps.length) {\n    const walks2 = [];\n    let depth = 0;\n    for (const step of steps) {\n      if (step === 0 /* Enter */) {\n        depth++;\n        walks2.push(67 /* Next */);\n      } else {\n        depth--;\n        if (depth >= 0) {\n          walks2.length = walks2.lastIndexOf(67 /* Next */);\n          walks2.push(97 /* Over */);\n        } else {\n          walks2.length = walks2.lastIndexOf(107 /* Out */) + 1;\n          walks2.push(107 /* Out */);\n          depth = 0;\n        }\n      }\n    }\n    let current = walks2[0];\n    let count = 0;\n    for (const walk of walks2) {\n      if (walk !== current) {\n        walkComment.push(`${walkCodeToName[current]}(${count})`);\n        walkString += nCodeString(current, count);\n        current = walk;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n    walkComment.push(`${walkCodeToName[current]}(${count})`);\n    walkString += nCodeString(current, count);\n    steps.length = 0;\n  }\n  if (code !== void 0) {\n    if (code !== 32 /* Get */) {\n      writeTo(path3)`<!>`;\n    }\n    walkComment.push(`${walkCodeToName[code]}`);\n    walkString += String.fromCharCode(code);\n  }\n  appendLiteral(walks, walkString);\n}\nfunction nCodeString(code, number) {\n  switch (code) {\n    case 67 /* Next */:\n      return toCharString(number, code, 20 /* Next */);\n    case 97 /* Over */:\n      return toCharString(number, code, 10 /* Over */);\n    case 107 /* Out */:\n      return toCharString(number, code, 10 /* Out */);\n    default:\n      throw new Error(`Unexpected walk code: ${code}`);\n  }\n}\nfunction toCharString(number, startCode, rangeSize) {\n  let result = \"\";\n  if (number >= rangeSize) {\n    const multiplier = Math.floor(number / rangeSize);\n    result += toCharString(\n      multiplier,\n      117 /* Multiplier */,\n      10 /* Multiplier */\n    );\n    number -= multiplier * rangeSize;\n  }\n  result += String.fromCharCode(startCode + number);\n  return result;\n}\nfunction getWalkString(section) {\n  const prefix = section.startNodeContentType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const postfix = section.endNodeContentType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const walks = getWalks(section);\n  const walkLiteral = toTemplateOrStringLiteral([prefix, ...walks, postfix]) || import_compiler9.types.stringLiteral(\"\");\n  if (walkLiteral.value !== \"\") {\n    walkLiteral.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: \" \" + getWalkComment(section).join(\", \") + \" \"\n      }\n    ];\n  }\n  return walkLiteral;\n}\n\n// src/util/writer.ts\nvar [getWrites] = createSectionState(\n  \"writes\",\n  () => [\"\"]\n);\nfunction writeTo(path3) {\n  const section = getSection(path3);\n  return (strs, ...exprs) => {\n    const exprsLen = exprs.length;\n    const writes = getWrites(section);\n    appendLiteral(writes, strs[0]);\n    for (let i = 0; i < exprsLen; i++) {\n      writes.push(exprs[i], strs[i + 1]);\n    }\n  };\n}\nfunction consumeHTML(path3) {\n  const writes = getWrites(getSection(path3));\n  const result = toTemplateOrStringLiteral(writes);\n  writes.length = 0;\n  writes[0] = \"\";\n  if (result) {\n    return import_compiler10.types.expressionStatement(callRuntime(\"write\", result));\n  }\n}\nfunction hasPendingHTML(path3) {\n  const writes = getWrites(getSection(path3));\n  return Boolean(writes.length > 1 || writes[0]);\n}\nfunction flushBefore(path3) {\n  const expr = consumeHTML(path3);\n  if (expr) {\n    path3.insertBefore(expr)[0].skip();\n  }\n}\nfunction flushInto(path3) {\n  const target = path3.isProgram() ? path3 : path3.get(\"body\");\n  const expr = consumeHTML(target);\n  if (expr) {\n    target.pushContainer(\"body\", expr)[0].skip();\n  }\n}\nfunction getSectionMeta(section) {\n  const writePrefix = section.startNodeContentType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writePostfix = section.endNodeContentType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writes = getWrites(section);\n  return {\n    setup: getSetup(section),\n    walks: getWalkString(section),\n    writes: toTemplateOrStringLiteral([writePrefix, ...writes, writePostfix]) || import_compiler10.types.stringLiteral(\"\")\n  };\n}\nfunction markNode(path3, binding) {\n  const section = getSection(path3);\n  if (binding.type !== 0 /* dom */) {\n    throw path3.buildCodeFrameError(\n      \"Tried to mark a node that was not determined to need a mark during analyze.\"\n    );\n  }\n  if (isOutputHTML()) {\n    writeTo(path3)`${callRuntime(\n      \"markResumeNode\",\n      getScopeIdIdentifier(section),\n      getScopeAccessorLiteral(binding)\n    )}`;\n  }\n}\n\n// src/core/return.ts\nvar [returnId, _setReturnId] = createSectionState(\n  \"returnId\"\n);\nvar return_default = {\n  translate(tag) {\n    (0, import_babel_utils8.assertNoVar)(tag);\n    (0, import_babel_utils8.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    const section = getSection(tag);\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const [valueAttr] = node.attributes;\n    if (!import_compiler11.types.isMarkoAttribute(valueAttr) || !valueAttr.default) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        `The '<return>' tag requires default attribute like '<return=VALUE>'.`\n      );\n    }\n    if (node.attributes.length > 1) {\n      const start = node.attributes[1].loc?.start;\n      const end = node.attributes[node.attributes.length - 1].loc?.end;\n      const msg = `The '<return>' tag only supports a default attribute.`;\n      if (start == null || end == null) {\n        throw tag.get(\"name\").buildCodeFrameError(msg);\n      } else {\n        throw tag.hub.buildError(\n          { loc: { start, end } },\n          msg,\n          Error\n        );\n      }\n    }\n    const { value } = valueAttr;\n    if (isOutputHTML()) {\n      flushBefore(tag);\n      const returnId2 = file.path.scope.generateUidIdentifier(\"return\");\n      _setReturnId(section, returnId2);\n      tag.replaceWith(\n        import_compiler11.types.variableDeclaration(\"const\", [\n          import_compiler11.types.variableDeclarator(returnId2, value)\n        ])\n      )[0].skip();\n    } else {\n      addValue(\n        section,\n        value.extra?.referencedBindings,\n        {\n          identifier: importRuntime(\"tagVarSignal\"),\n          hasDownstreamIntersections: () => true\n        },\n        value\n      );\n      tag.remove();\n    }\n  },\n  autocomplete: [\n    {\n      displayText: \"return=<value>\",\n      description: \"Provides a value for use in a parent template.\",\n      snippet: \"return=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#return\"\n    }\n  ]\n};\n\n// src/util/signals.ts\nvar [getSignals] = createSectionState(\n  \"signals\",\n  () => /* @__PURE__ */ new Map()\n);\nvar [getSubscribeBuilder, _setSubscribeBuilder] = createSectionState(\"queue\");\nfunction setSubscriberBuilder(tag, builder) {\n  _setSubscribeBuilder(getSection(tag.get(\"body\")), builder);\n}\nvar [getClosures] = createSectionState(\n  \"closures\",\n  () => []\n);\nvar addClosure = (fromSection, toSection, closure) => {\n  let currentSection = fromSection;\n  while (currentSection !== void 0 && currentSection !== toSection) {\n    getClosures(currentSection).push(closure);\n    currentSection = currentSection.parent;\n  }\n};\nvar [forceResumeScope, _setForceResumeScope] = createSectionState(\"forceResumeScope\");\nfunction setForceResumeScope(section) {\n  _setForceResumeScope(section, true);\n}\nvar [getSerializedScopeProperties] = createSectionState(\"serializedScopeProperties\", () => /* @__PURE__ */ new Map());\nvar unimplementedBuild = () => {\n  return import_compiler12.types.stringLiteral(\"SIGNAL NOT INITIALIZED\");\n};\nfunction getSignal(section, referencedBindings, name = generateSignalName(referencedBindings)) {\n  const signals = getSignals(section);\n  let signal = signals.get(referencedBindings);\n  if (!signal) {\n    const exportName = referencedBindings && !Array.isArray(referencedBindings) && referencedBindings.section === section && referencedBindings.export;\n    signals.set(\n      referencedBindings,\n      signal = {\n        identifier: exportName ? import_compiler12.types.identifier(exportName) : currentProgramPath.scope.generateUidIdentifier(\n          name + section.name.replace(\"_\", \"$\")\n        ),\n        referencedBindings,\n        section,\n        values: [],\n        intersection: void 0,\n        render: [],\n        effect: [],\n        effectInlineReferences: void 0,\n        subscribers: [],\n        closures: /* @__PURE__ */ new Map(),\n        hasDownstreamIntersections: () => {\n          let hasDownstreamIntersections = !!(signal.intersection || signal.closures.size);\n          if (!hasDownstreamIntersections) {\n            for (const value of signal.values) {\n              if (value.signal.hasDownstreamIntersections()) {\n                hasDownstreamIntersections = true;\n                break;\n              }\n            }\n          }\n          if (!hasDownstreamIntersections) {\n            if (!Array.isArray(referencedBindings) && referencedBindings) {\n              for (const alias of referencedBindings.aliases) {\n                if (getSignal(section, alias).hasDownstreamIntersections()) {\n                  hasDownstreamIntersections = true;\n                  break;\n                }\n              }\n              if (!hasDownstreamIntersections) {\n                for (const [, alias] of referencedBindings.propertyAliases) {\n                  if (getSignal(section, alias).hasDownstreamIntersections()) {\n                    hasDownstreamIntersections = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          signal.hasDownstreamIntersections = () => hasDownstreamIntersections;\n          return hasDownstreamIntersections;\n        },\n        build: unimplementedBuild,\n        export: !!exportName\n      }\n    );\n    if (isOutputHTML()) {\n      return signal;\n    } else if (!referencedBindings) {\n      signal.build = () => getSignalFn(signal, [scopeIdentifier]);\n    } else if (Array.isArray(referencedBindings)) {\n      subscribe(referencedBindings, signal);\n      signal.build = () => {\n        return callRuntime(\n          \"intersection\",\n          import_compiler12.types.numericLiteral(referencedBindings.length),\n          getSignalFn(signal, [scopeIdentifier], referencedBindings)\n        );\n      };\n    } else if (referencedBindings.section !== section) {\n      const provider = getSignal(\n        referencedBindings.section,\n        referencedBindings\n      );\n      addClosure(\n        section,\n        section.parent,\n        signal.identifier\n      );\n      provider.closures.set(section, signal);\n      signal.build = () => {\n        const builder = getSubscribeBuilder(section);\n        const ownerScope = getScopeExpression(\n          section,\n          referencedBindings.section\n        );\n        const isImmediateOwner = ownerScope.object === scopeIdentifier;\n        const isDynamicClosure = signal.isDynamicClosure = !(isImmediateOwner && builder);\n        return callRuntime(\n          isDynamicClosure ? \"dynamicClosure\" : \"closure\",\n          getScopeAccessorLiteral(referencedBindings),\n          getSignalFn(signal, [\n            scopeIdentifier,\n            import_compiler12.types.identifier(referencedBindings.name)\n          ]),\n          isImmediateOwner ? null : import_compiler12.types.arrowFunctionExpression([scopeIdentifier], ownerScope),\n          buildSignalIntersections(signal)\n        );\n      };\n    }\n  }\n  return signal;\n}\nfunction initValue(binding) {\n  const valueAccessor = getScopeAccessorLiteral(binding);\n  const section = binding.section;\n  const signal = getSignal(section, binding);\n  signal.build = () => {\n    const fn = getSignalFn(signal, [\n      scopeIdentifier,\n      import_compiler12.types.identifier(binding.name)\n    ]);\n    const intersections = buildSignalIntersections(signal);\n    const isParamBinding = !binding.upstreamAlias && (binding.type === 3 /* param */ || binding.type === 2 /* input */);\n    const isNakedAlias = binding.upstreamAlias && !binding.property;\n    const needsGuard = !isNakedAlias && (binding.downstreamExpressions.size || fn.body.body.length > 0);\n    const needsCache = needsGuard || intersections;\n    const needsMarks = isParamBinding || intersections;\n    if (needsCache || needsMarks) {\n      return callRuntime(\"value\", valueAccessor, fn, intersections);\n    } else {\n      return fn;\n    }\n  };\n  signal.valueAccessor = valueAccessor;\n  for (const alias of binding.aliases) {\n    initValue(alias);\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    initValue(alias);\n  }\n  return signal;\n}\nfunction getSignalFn(signal, params, referencedBindings) {\n  const section = signal.section;\n  const binding = signal.referencedBindings;\n  if (binding && !Array.isArray(binding) && binding.section === section) {\n    const [scopeIdentifier2, valueIdentifier] = params;\n    for (const alias of binding.aliases) {\n      signal.render.push(\n        import_compiler12.types.expressionStatement(\n          import_compiler12.types.callExpression(getSignal(alias.section, alias).identifier, [\n            scopeIdentifier2,\n            valueIdentifier\n          ])\n        )\n      );\n    }\n    for (const [key, alias] of binding.propertyAliases) {\n      signal.render.push(\n        import_compiler12.types.expressionStatement(\n          import_compiler12.types.callExpression(getSignal(alias.section, alias).identifier, [\n            scopeIdentifier2,\n            toMemberExpression(valueIdentifier, key)\n          ])\n        )\n      );\n    }\n  }\n  for (const value of signal.values) {\n    signal.render.push(\n      import_compiler12.types.expressionStatement(\n        import_compiler12.types.callExpression(value.signal.identifier, [value.scope, value.value])\n      )\n    );\n  }\n  if (referencedBindings) {\n    signal.render.unshift(\n      import_compiler12.types.variableDeclaration(\"const\", [\n        import_compiler12.types.variableDeclarator(\n          createScopeReadPattern(section, referencedBindings),\n          scopeIdentifier\n        )\n      ])\n    );\n  }\n  return import_compiler12.types.arrowFunctionExpression(params, import_compiler12.types.blockStatement(signal.render));\n}\nfunction buildSignalIntersections(signal) {\n  const section = signal.section;\n  let intersections = signal.intersection;\n  const binding = signal.referencedBindings;\n  if (binding && !Array.isArray(binding) && binding.section === signal.section) {\n    for (const alias of binding.aliases) {\n      const signal2 = getSignal(alias.section, alias);\n      if (signal2.hasDownstreamIntersections()) {\n        intersections = push(\n          intersections,\n          import_compiler12.types.identifier(signal2.identifier.name)\n        );\n      }\n    }\n    for (const [, alias] of binding.propertyAliases) {\n      const signal2 = getSignal(alias.section, alias);\n      if (signal2.hasDownstreamIntersections()) {\n        intersections = push(\n          intersections,\n          import_compiler12.types.identifier(signal2.identifier.name)\n        );\n      }\n    }\n  }\n  for (const value of signal.values) {\n    if (value.signal.hasDownstreamIntersections()) {\n      intersections = push(\n        intersections,\n        value.intersectionExpression ?? import_compiler12.types.identifier(value.signal.identifier.name)\n      );\n    }\n  }\n  const closureEntries = Array.from(signal.closures.entries()).sort(\n    ([a], [b]) => a.id - b.id\n  );\n  for (const [closureSection, closureSignal] of closureEntries) {\n    const builder = getSubscribeBuilder(closureSection);\n    const isImmediateOwner = closureSection.parent === section;\n    if (builder && isImmediateOwner) {\n      intersections = push(intersections, builder(closureSignal.identifier));\n    } else if (!signal.hasDynamicSubscribers) {\n      signal.hasDynamicSubscribers = true;\n    }\n  }\n  if (signal.hasDynamicSubscribers) {\n    signal.hasDynamicSubscribers = true;\n    intersections = push(\n      intersections,\n      callRuntime(\"dynamicSubscribers\", signal.valueAccessor)\n    );\n  }\n  return Array.isArray(intersections) ? callRuntime(\"intersections\", import_compiler12.types.arrayExpression(intersections)) : intersections;\n}\nfunction subscribe(provider, subscriber) {\n  if (Array.isArray(provider)) {\n    provider.forEach((p) => subscribe(p, subscriber));\n    return;\n  }\n  const providerSignal = getSignal(subscriber.section, provider);\n  providerSignal.intersection = push(\n    providerSignal.intersection,\n    subscriber.identifier\n  );\n}\nfunction generateSignalName(referencedBindings) {\n  let name;\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      name = \"expr\";\n      for (const ref of referencedBindings) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name = referencedBindings.name;\n    }\n  } else {\n    name = \"setup\";\n  }\n  return name;\n}\nfunction queueSource(source, value, targetSection) {\n  return callRuntime(\n    \"queueSource\",\n    getScopeExpression(targetSection, source.section),\n    source.identifier,\n    value\n  );\n}\nfunction finalizeSignalArgs(args) {\n  for (let i = args.length - 1; i >= 0; i--) {\n    const arg = args[i];\n    if (import_compiler12.types.isArrowFunctionExpression(arg)) {\n      const body = arg.body.body;\n      if (body) {\n        if (body.length === 0) {\n          args[i] = import_compiler12.types.nullLiteral();\n        } else if (body.length === 1 && import_compiler12.types.isExpressionStatement(body[0])) {\n          arg.body = body[0].expression;\n        }\n      }\n    }\n  }\n  for (let i = args.length - 1; import_compiler12.types.isNullLiteral(args[i]); ) {\n    args.length = i--;\n  }\n}\nfunction addStatement(type, targetSection, referencedBindings, statement, originalNodes, isInlined) {\n  const signal = getSignal(targetSection, referencedBindings);\n  const statements = signal[type] ??= [];\n  if (Array.isArray(statement)) {\n    statements.push(...statement);\n  } else {\n    statements.push(statement);\n  }\n  if (type === \"effect\") {\n    if (Array.isArray(originalNodes)) {\n      for (const node of originalNodes) {\n        if (isInlined || !import_compiler12.types.isFunction(node)) {\n          addEffectReferences(signal, node);\n        }\n      }\n    } else {\n      if (isInlined || !import_compiler12.types.isFunction(originalNodes)) {\n        addEffectReferences(signal, originalNodes);\n      }\n    }\n  }\n}\nfunction addValue(targetSection, referencedBindings, signal, value, scope = scopeIdentifier, intersectionExpression) {\n  getSignal(targetSection, referencedBindings).values.push({\n    signal,\n    value,\n    scope,\n    intersectionExpression\n  });\n}\nfunction addEffectReferences(signal, expression) {\n  signal.effectInlineReferences = bindingUtil.union(\n    signal.effectInlineReferences,\n    expression.extra?.referencedBindings\n  );\n}\nfunction getResumeRegisterId(section, referencedBindings, type) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let name = \"\";\n  if (referencedBindings) {\n    if (typeof referencedBindings === \"string\") {\n      name += `_${referencedBindings}`;\n    } else if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name += `_${referencedBindings.name}`;\n    }\n  }\n  return (0, import_babel_utils9.getTemplateId)(\n    markoOpts,\n    `${filename}_${section.id}${name}${type ? \"/\" + type : \"\"}`\n  );\n}\nfunction writeSignals(section) {\n  const signals = [...getSignals(section).values()].sort(sortSignals);\n  for (const signal of signals) {\n    let effectDeclarator;\n    if (signal.effect.length) {\n      const effectIdentifier = import_compiler12.types.identifier(`${signal.identifier.name}_effect`);\n      if (signal.effectInlineReferences) {\n        signal.effect.unshift(\n          import_compiler12.types.variableDeclaration(\"const\", [\n            import_compiler12.types.variableDeclarator(\n              createScopeReadPattern(section, signal.effectInlineReferences),\n              scopeIdentifier\n            )\n          ])\n        );\n      }\n      effectDeclarator = import_compiler12.types.variableDeclarator(\n        effectIdentifier,\n        callRuntime(\n          \"register\",\n          import_compiler12.types.stringLiteral(\n            getResumeRegisterId(section, signal.referencedBindings)\n          ),\n          import_compiler12.types.arrowFunctionExpression(\n            [scopeIdentifier],\n            signal.effect.length === 1 && import_compiler12.types.isExpressionStatement(signal.effect[0]) ? signal.effect[0].expression : import_compiler12.types.blockStatement(signal.effect)\n          )\n        )\n      );\n      signal.render.push(\n        import_compiler12.types.expressionStatement(\n          callRuntime(\"queueEffect\", scopeIdentifier, effectIdentifier)\n        )\n      );\n    }\n    let value = signal.build();\n    if (import_compiler12.types.isCallExpression(value)) {\n      finalizeSignalArgs(value.arguments);\n    }\n    if (signal.register) {\n      value = callRuntime(\n        \"registerBoundSignal\",\n        import_compiler12.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings)\n        ),\n        value\n      );\n    }\n    if (signal.isDynamicClosure && isStatefulReferences(signal.referencedBindings)) {\n      value = callRuntime(\n        \"registerSubscriber\",\n        import_compiler12.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings, \"subscriber\")\n        ),\n        value\n      );\n    }\n    const signalDeclarator = import_compiler12.types.variableDeclarator(signal.identifier, value);\n    let signalDeclaration = import_compiler12.types.variableDeclaration(\"const\", [\n      signalDeclarator\n    ]);\n    if (signal.export) {\n      signalDeclaration = import_compiler12.types.exportNamedDeclaration(signalDeclaration);\n    }\n    const roots = currentProgramPath.pushContainer(\n      \"body\",\n      effectDeclarator ? [\n        import_compiler12.types.variableDeclaration(\"const\", [effectDeclarator]),\n        signalDeclaration\n      ] : signalDeclaration\n    );\n    for (const root of roots) {\n      root.traverse(bindFunctionsVisitor, { root, section });\n    }\n  }\n}\nfunction sortSignals(a, b) {\n  const aReferencedBindings = getReferencedBindings(a);\n  const bReferencedBindings = getReferencedBindings(b);\n  for (let i = Math.max(aReferencedBindings.length, bReferencedBindings.length) - 1; i >= 0; i--) {\n    const diff = (bReferencedBindings[i] ?? -1) - (aReferencedBindings[i] ?? -1);\n    if (diff !== 0)\n      return diff;\n  }\n  return 0;\n}\nfunction getReferencedBindings({ referencedBindings: reserve }) {\n  if (!reserve) {\n    return [];\n  } else if (Array.isArray(reserve)) {\n    return reserve.map(getMappedId).sort();\n  } else {\n    return [getMappedId(reserve)];\n  }\n}\nfunction getMappedId(reference) {\n  return (reference.type === 0 /* dom */ ? 1 : 0) * 1e4 + reference.id;\n}\nfunction addHTMLEffectCall(section, referencedBindings) {\n  addStatement(\"effect\", section, referencedBindings, void 0, []);\n}\nfunction writeHTMLResumeStatements(path3, tagVarIdentifier) {\n  if (!hasSection(path3))\n    return;\n  const section = getSection(path3);\n  const allSignals = Array.from(getSignals(section).values());\n  const scopeIdIdentifier = getScopeIdIdentifier(section);\n  for (const closure of section.closures) {\n    if (isStatefulReferences(closure)) {\n      let currentSection = section;\n      while (currentSection !== closure.section) {\n        getSerializedScopeProperties(currentSection).set(\n          import_compiler12.types.stringLiteral(\"_\"),\n          callRuntime(\n            \"ensureScopeWithId\",\n            getScopeIdIdentifier(currentSection = currentSection.parent)\n          )\n        );\n      }\n      setForceResumeScope(closure.section);\n      const isImmediateOwner = section.parent?.id === closure.section.id;\n      const isDynamicClosure = !getSubscribeBuilder(section) || !isImmediateOwner;\n      if (isDynamicClosure) {\n        path3.pushContainer(\n          \"body\",\n          import_compiler12.types.expressionStatement(\n            callRuntime(\n              \"writeEffect\",\n              scopeIdIdentifier,\n              import_compiler12.types.stringLiteral(\n                getResumeRegisterId(section, closure, \"subscriber\")\n              )\n            )\n          )\n        );\n      }\n    }\n  }\n  for (let i = allSignals.length; i--; ) {\n    if (allSignals[i].effect.length) {\n      const signalRefs = allSignals[i].referencedBindings;\n      path3.pushContainer(\n        \"body\",\n        import_compiler12.types.expressionStatement(\n          callRuntime(\n            \"writeEffect\",\n            scopeIdIdentifier,\n            import_compiler12.types.stringLiteral(getResumeRegisterId(section, signalRefs))\n          )\n        )\n      );\n    }\n  }\n  const accessors = /* @__PURE__ */ new Set();\n  const additionalProperties = getSerializedScopeProperties(section);\n  const serializedProperties = [];\n  section.bindings.forEach((binding) => {\n    if (binding.serialize && binding.type !== 0 /* dom */) {\n      const accessor = getScopeAccessorLiteral(binding);\n      serializedProperties.push(\n        import_compiler12.types.objectProperty(accessor, import_compiler12.types.identifier(binding.name))\n      );\n      accessors.add(accessor.value);\n    }\n  });\n  if (tagVarIdentifier && returnId(section) !== void 0) {\n    serializedProperties.push(\n      import_compiler12.types.objectProperty(\n        import_compiler12.types.stringLiteral(\"/\" /* TagVariable */),\n        tagVarIdentifier\n      )\n    );\n  }\n  for (const [key, value] of additionalProperties) {\n    if (!accessors.has(key.value)) {\n      serializedProperties.push(\n        import_compiler12.types.objectProperty(key, value, !import_compiler12.types.isLiteral(key))\n      );\n      accessors.add(key.value);\n    }\n  }\n  if (serializedProperties.length || forceResumeScope(section)) {\n    path3.pushContainer(\n      \"body\",\n      import_compiler12.types.expressionStatement(\n        callRuntime(\n          \"writeScope\",\n          scopeIdIdentifier,\n          import_compiler12.types.objectExpression(serializedProperties)\n        )\n      )\n    );\n  }\n  if (path3.get(\"body\").length) {\n    path3.unshiftContainer(\n      \"body\",\n      import_compiler12.types.variableDeclaration(\"const\", [\n        import_compiler12.types.variableDeclarator(scopeIdIdentifier, callRuntime(\"nextScopeId\"))\n      ])\n    );\n  }\n}\nvar bindFunctionsVisitor = {\n  FunctionExpression: { exit: bindFunction },\n  ArrowFunctionExpression: { exit: bindFunction }\n};\nfunction bindFunction(fn, { root, section }) {\n  const { node } = fn;\n  const { extra } = node;\n  if (!extra)\n    return;\n  const { name, referencedBindings } = extra;\n  const fnId = fn.hub.file.path.scope.generateUidIdentifier(name);\n  root.insertBefore(\n    import_compiler12.types.variableDeclaration(\"const\", [\n      import_compiler12.types.variableDeclarator(\n        fnId,\n        import_compiler12.types.arrowFunctionExpression(\n          [scopeIdentifier],\n          referencedBindings ? import_compiler12.types.blockStatement([\n            import_compiler12.types.variableDeclaration(\"const\", [\n              import_compiler12.types.variableDeclarator(\n                createScopeReadPattern(section, referencedBindings),\n                scopeIdentifier\n              )\n            ]),\n            import_compiler12.types.returnStatement(node)\n          ]) : node\n        )\n      )\n    ])\n  )[0].skip();\n  fn.replaceWith(import_compiler12.types.callExpression(fnId, [scopeIdentifier]))[0].skip();\n}\nfunction getSetup(section) {\n  return getSignals(section).get(void 0)?.identifier;\n}\nfunction toMemberExpression(value, key) {\n  const keyLiteral = keyToNode(key);\n  return import_compiler12.types.memberExpression(\n    value,\n    keyLiteral,\n    keyLiteral.type !== \"Identifier\"\n  );\n}\nfunction keyToNode(key) {\n  if (/^[a-z_$][a-z0-9_$]*$/i.test(key)) {\n    return import_compiler12.types.identifier(key);\n  } else if (/^(?:0|[1-9][0-9]*)$/.test(key)) {\n    return import_compiler12.types.numericLiteral(parseInt(key, 10));\n  }\n  return import_compiler12.types.stringLiteral(key);\n}\n\n// src/visitors/program/dom.ts\nvar dom_default = {\n  translate: {\n    exit(program) {\n      visit(program);\n      const section = getSection(program);\n      const { walks, writes, setup } = getSectionMeta(section);\n      const domExports = program.node.extra.domExports;\n      const templateIdentifier = import_compiler13.types.identifier(domExports.template);\n      const walksIdentifier = import_compiler13.types.identifier(domExports.walks);\n      const setupIdentifier = import_compiler13.types.identifier(domExports.setup);\n      const closuresIdentifier = import_compiler13.types.identifier(domExports.closures);\n      const paramsBinding = program.node.extra.binding;\n      const programParamsSignal = paramsBinding && bindingHasDownstreamExpressions(paramsBinding) ? initValue(paramsBinding) : void 0;\n      forEachSectionReverse((childSection) => {\n        if (childSection !== section) {\n          const sectionPath = getSectionPath(childSection);\n          const sectionParamsBinding = sectionPath.node.extra?.binding;\n          const tagParamsSignal = sectionParamsBinding && initValue(sectionParamsBinding);\n          const { walks: walks2, writes: writes2, setup: setup2 } = getSectionMeta(childSection);\n          const closures2 = getClosures(childSection);\n          const identifier = import_compiler13.types.identifier(childSection.name);\n          const renderer = callRuntime(\n            \"createRenderer\",\n            writes2,\n            walks2,\n            setup2,\n            closures2.length && import_compiler13.types.arrayExpression(closures2),\n            void 0,\n            tagParamsSignal?.identifier\n          );\n          writeSignals(childSection);\n          program.node.body.push(\n            import_compiler13.types.variableDeclaration(\"const\", [\n              import_compiler13.types.variableDeclarator(\n                identifier,\n                isStatefulSection(childSection) ? callRuntime(\n                  childSection.closures.size ? \"registerRenderer\" : \"register\",\n                  import_compiler13.types.stringLiteral(\n                    getResumeRegisterId(childSection, \"renderer\")\n                  ),\n                  renderer\n                ) : renderer\n              )\n            ])\n          );\n        }\n      });\n      const closures = getClosures(section);\n      writeSignals(section);\n      program.node.body.push(\n        import_compiler13.types.exportNamedDeclaration(\n          import_compiler13.types.variableDeclaration(\"const\", [\n            import_compiler13.types.variableDeclarator(\n              import_compiler13.types.identifier(domExports.template),\n              writes || import_compiler13.types.stringLiteral(\"\")\n            )\n          ])\n        ),\n        import_compiler13.types.exportNamedDeclaration(\n          import_compiler13.types.variableDeclaration(\"const\", [\n            import_compiler13.types.variableDeclarator(walksIdentifier, walks || import_compiler13.types.stringLiteral(\"\"))\n          ])\n        ),\n        import_compiler13.types.exportNamedDeclaration(\n          import_compiler13.types.variableDeclaration(\"const\", [\n            import_compiler13.types.variableDeclarator(\n              setupIdentifier,\n              import_compiler13.types.isNullLiteral(setup) || !setup ? import_compiler13.types.functionExpression(null, [], import_compiler13.types.blockStatement([])) : setup\n            )\n          ])\n        )\n      );\n      if (closures.length) {\n        program.node.body.push(\n          import_compiler13.types.exportNamedDeclaration(\n            import_compiler13.types.variableDeclaration(\"const\", [\n              import_compiler13.types.variableDeclarator(\n                closuresIdentifier,\n                import_compiler13.types.arrayExpression(closures)\n              )\n            ])\n          )\n        );\n      }\n      const {\n        markoOpts,\n        opts: { filename }\n      } = program.hub.file;\n      program.node.body.push(\n        import_compiler13.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            callRuntime(\n              \"createRenderer\",\n              templateIdentifier,\n              walksIdentifier,\n              setupIdentifier,\n              closures.length && closuresIdentifier,\n              void 0,\n              programParamsSignal?.identifier\n            ),\n            import_compiler13.types.stringLiteral((0, import_babel_utils10.getTemplateId)(markoOpts, `${filename}`))\n          )\n        )\n      );\n    }\n  }\n};\n\n// src/visitors/program/html.ts\nvar import_babel_utils11 = require(\"@marko/babel-utils\");\nvar import_compiler14 = require(\"@marko/compiler\");\n\n// src/util/is-static.ts\nfunction isStatic(path3) {\n  return path3.isImportDeclaration() || path3.isExportDeclaration() || path3.isMarkoScriptlet({ static: true });\n}\n\n// src/visitors/program/html.ts\nvar html_default = {\n  translate: {\n    exit(program) {\n      const section = getSection(program);\n      const tagVarIdentifier = program.scope.generateUidIdentifier(\"tagVar\");\n      flushInto(program);\n      writeHTMLResumeStatements(program, tagVarIdentifier);\n      const returnIdentifier = returnId(section);\n      if (returnIdentifier !== void 0) {\n        program.pushContainer(\"body\", import_compiler14.types.returnStatement(returnIdentifier));\n      }\n      const renderContent = [];\n      for (const child of program.get(\"body\")) {\n        if (!isStatic(child)) {\n          renderContent.push(child.node);\n          child.remove();\n        } else if (child.isMarkoScriptlet()) {\n          if (child.node.target && child.node.target !== \"server\") {\n            child.remove();\n          } else {\n            child.replaceWithMultiple(child.node.body);\n          }\n        }\n      }\n      const rendererId = program.scope.generateUidIdentifier(\"renderer\");\n      const {\n        markoOpts,\n        opts: { filename }\n      } = program.hub.file;\n      program.pushContainer(\"body\", [\n        import_compiler14.types.variableDeclaration(\"const\", [\n          import_compiler14.types.variableDeclarator(\n            rendererId,\n            callRuntime(\n              \"createRenderer\",\n              import_compiler14.types.arrowFunctionExpression(\n                [import_compiler14.types.identifier(\"input\"), tagVarIdentifier],\n                import_compiler14.types.blockStatement(renderContent)\n              )\n            )\n          )\n        ]),\n        import_compiler14.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            rendererId,\n            import_compiler14.types.stringLiteral((0, import_babel_utils11.getTemplateId)(markoOpts, `${filename}`))\n          )\n        )\n      ]);\n    }\n  }\n};\n\n// src/visitors/program/index.ts\nvar currentProgramPath;\nvar scopeIdentifier;\nvar cleanIdentifier;\nvar previousProgramPath = /* @__PURE__ */ new WeakMap();\nvar program_default = {\n  migrate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      program.node.params = [import_compiler15.types.identifier(\"input\")];\n      currentProgramPath = program;\n    },\n    exit() {\n      currentProgramPath.scope.crawl();\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  analyze: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      startSection(program);\n      trackParamsReferences(program, 2 /* input */);\n      const { scope } = program;\n      (program.node.extra ??= {}).domExports = {\n        template: scope.generateUid(\"template_\"),\n        walks: scope.generateUid(\"walks_\"),\n        setup: scope.generateUid(\"setup_\"),\n        params: void 0,\n        // TODO look into recursive components with fine grained params.\n        closures: scope.generateUid(\"closures_\")\n      };\n    },\n    exit(program) {\n      finalizeReferences();\n      const {\n        scope,\n        node: { extra }\n      } = program;\n      if (extra.binding && bindingHasDownstreamExpressions(extra.binding)) {\n        extra.domExports.params = recurseAndBuildExportTree(\n          extra.binding,\n          scope\n        );\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  translate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      scopeIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"scope\") : null;\n      cleanIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"clean\") : null;\n      if (getMarkoOpts().output === \"hydrate\") {\n        const entryFile = program.hub.file;\n        const visitedFiles = /* @__PURE__ */ new Set([\n          (0, import_babel_utils12.resolveRelativePath)(entryFile, entryFile.opts.filename)\n        ]);\n        entry_builder_default.visit(entryFile, entryFile, function visitChild(resolved) {\n          if (!visitedFiles.has(resolved)) {\n            visitedFiles.add(resolved);\n            const file = (0, import_babel_utils12.loadFileForImport)(entryFile, resolved);\n            if (file) {\n              entry_builder_default.visit(\n                file,\n                entryFile,\n                (id) => visitChild(resolveRelativeToEntry(entryFile, file, id))\n              );\n            }\n          }\n        });\n        program.node.body = entry_builder_default.build(entryFile);\n        program.skip();\n        return;\n      }\n    },\n    exit(program) {\n      if (isOutputHTML()) {\n        html_default.translate.exit(program);\n      } else {\n        dom_default.translate.exit(program);\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  }\n};\nfunction resolveRelativeToEntry(entryFile, file, req) {\n  return file === entryFile ? (0, import_babel_utils12.resolveRelativePath)(file, req) : (0, import_babel_utils12.resolveRelativePath)(\n    entryFile,\n    req[0] === \".\" ? import_path.default.join(file.opts.filename, \"..\", req) : req\n  );\n}\nfunction recurseAndBuildExportTree(binding, scope) {\n  const exportTree = {\n    id: binding.export ??= scope.generateUid(binding.name + \"_\"),\n    props: void 0\n  };\n  const { aliases, propertyAliases, downstreamExpressions } = binding;\n  if (!downstreamExpressions.size) {\n    exportTree.props = {};\n    for (const [property, alias] of propertyAliases) {\n      exportTree.props[property] = recurseAndBuildExportTree(alias, scope);\n    }\n    for (const alias of aliases) {\n      const exports2 = recurseAndBuildExportTree(alias, scope);\n      if (exports2.props) {\n        exportTree.props = { ...exportTree.props, ...exports2.props };\n      } else {\n        exportTree.props = void 0;\n        return exportTree;\n      }\n    }\n  }\n  return exportTree;\n}\n\n// src/util/marko-config.ts\nfunction isOutputHTML() {\n  return getMarkoOpts().output === \"html\";\n}\nfunction isOutputDOM() {\n  return !isOutputHTML();\n}\nfunction getMarkoOpts() {\n  return currentProgramPath.hub.file.markoOpts;\n}\nfunction isOptimize() {\n  return getMarkoOpts().optimize;\n}\n\n// src/util/references.ts\nvar [getBindings] = createProgramState(() => /* @__PURE__ */ new Set());\nvar [getNextBindingId, setNextBindingId] = createProgramState(() => 0);\nfunction createBinding(name, type, section, upstreamAlias, upstreamExpression, property) {\n  const id = getNextBindingId();\n  const binding = {\n    id,\n    name,\n    type,\n    section,\n    property,\n    excludeProperties: void 0,\n    serialize: false,\n    aliases: /* @__PURE__ */ new Set(),\n    propertyAliases: /* @__PURE__ */ new Map(),\n    upstreamAlias,\n    upstreamExpression,\n    downstreamExpressions: /* @__PURE__ */ new Set(),\n    export: void 0\n  };\n  if (property) {\n    const propBinding = upstreamAlias.propertyAliases.get(property);\n    if (propBinding) {\n      binding.property = void 0;\n      binding.upstreamAlias = propBinding;\n      propBinding.aliases.add(binding);\n    } else {\n      upstreamAlias.propertyAliases.set(property, binding);\n    }\n  } else if (upstreamAlias) {\n    upstreamAlias.aliases.add(binding);\n  }\n  setNextBindingId(id + 1);\n  getBindings().add(binding);\n  return binding;\n}\nfunction trackVarReferences(tag, type, upstreamAlias, upstreamExpression) {\n  const tagVar = tag.node.var;\n  if (tagVar) {\n    const section = getOrCreateSection(tag);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    upstreamAlias?.downstreamExpressions.delete(upstreamExpression);\n    createBindingsAndTrackReferences(\n      tagVar,\n      type,\n      tag.scope,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0\n    );\n  }\n}\nfunction trackParamsReferences(body, type, upstreamAlias, upstreamExpression) {\n  const params = body.node.params;\n  if (body.get(\"body\").length && params.length) {\n    upstreamAlias?.downstreamExpressions.delete(upstreamExpression);\n    const section = getOrCreateSection(body);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    const paramsBinding = canonicalUpstreamAlias || ((body.node.extra ??= {}).binding = createBinding(\n      body.scope.generateUid(\"params_\"),\n      type,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0\n    ));\n    for (let i = 0; i < params.length; i++) {\n      createBindingsAndTrackReferences(\n        params[i],\n        type,\n        body.scope,\n        section,\n        paramsBinding,\n        void 0,\n        i + \"\"\n      );\n    }\n  }\n}\nfunction trackReferencesForBinding(babelBinding) {\n  const { identifier, referencePaths, constantViolations } = babelBinding;\n  const binding = identifier.extra.binding;\n  for (const referencePath of referencePaths) {\n    trackReference(referencePath, binding);\n  }\n  for (const referencePath of constantViolations) {\n    const node = referencePath.node;\n    if (import_compiler16.types.isAssignmentExpression(node) && import_compiler16.types.isIdentifier(node.left) && node.operator !== \"=\") {\n      trackReference(\n        referencePath.get(\n          \"left\"\n        ),\n        binding\n      );\n    }\n  }\n}\nfunction createBindingsAndTrackReferences(lVal, type, scope, section, upstreamAlias, upstreamExpression, property) {\n  switch (lVal.type) {\n    case \"Identifier\":\n      (lVal.extra ??= {}).binding = createBinding(\n        lVal.name,\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      );\n      trackReferencesForBinding(scope.getBinding(lVal.name));\n      break;\n    case \"ObjectPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        scope.generateUid(\"pattern_\"),\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      ));\n      for (const prop of lVal.properties) {\n        if (prop.type === \"RestElement\") {\n          createBindingsAndTrackReferences(\n            prop.argument,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            property\n          );\n        } else {\n          let key;\n          if (prop.key.type === \"Identifier\") {\n            key = prop.key.name;\n          } else if (prop.key.type === \"StringLiteral\") {\n            key = prop.key.value;\n          } else {\n            throw new Error(\"computed keys not supported in object pattern\");\n          }\n          createBindingsAndTrackReferences(\n            prop.value,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            key\n          );\n        }\n      }\n      break;\n    }\n    case \"ArrayPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        scope.generateUid(\"pattern_\"),\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      ));\n      let i = -1;\n      for (const element of lVal.elements) {\n        i++;\n        if (element) {\n          if (element.type === \"RestElement\") {\n            createBindingsAndTrackReferences(\n              element.argument,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              property\n            );\n          } else {\n            createBindingsAndTrackReferences(\n              element,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              `${i}`\n            );\n          }\n        }\n      }\n      break;\n    }\n    case \"AssignmentPattern\":\n      createBindingsAndTrackReferences(\n        lVal.left,\n        type,\n        scope,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      );\n      break;\n  }\n}\nfunction trackReference(referencePath, binding) {\n  const fnRoot = getFnRoot(referencePath.scope.path);\n  const exprRoot = getExprRoot(fnRoot || referencePath);\n  const markoRoot = getMarkoRoot(exprRoot);\n  const section = getOrCreateSection(exprRoot);\n  const reference = binding;\n  const exprExtra = exprRoot.node.extra ??= {};\n  addReferenceToExpression(exprRoot, binding);\n  if (fnRoot) {\n    let name = fnRoot.node.id?.name;\n    let fnExtra = exprExtra;\n    if (fnRoot !== exprRoot) {\n      fnExtra = fnRoot.node.extra ??= {};\n      fnExtra.referencedBindings = addReference(\n        section,\n        fnExtra.referencedBindings,\n        reference\n      );\n    }\n    if (!name) {\n      if (markoRoot.isMarkoAttribute()) {\n        name = markoRoot.node.default ? import_compiler16.types.toIdentifier(\n          markoRoot.parentPath.parentPath.get(\n            \"name\"\n          )\n        ) : markoRoot.node.name;\n      } else {\n        name = \"anonymous\";\n      }\n    }\n    fnExtra.name = name;\n  }\n}\nvar [getMergedReferences] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction mergeReferences(target, nodes) {\n  getMergedReferences().set(target, nodes);\n}\nfunction compareIntersections(a, b) {\n  const len = a.length;\n  const lenDelta = len - b.length;\n  if (lenDelta !== 0) {\n    return lenDelta;\n  }\n  for (let i = 0; i < len; i++) {\n    const compareResult = bindingUtil.compare(a[i], b[i]);\n    if (compareResult !== 0) {\n      return compareResult;\n    }\n  }\n  return 0;\n}\nfunction finalizeReferences() {\n  const mergedReferences = getMergedReferences();\n  if (mergedReferences.size) {\n    for (const [target, nodes] of mergedReferences) {\n      const targetExtra = target.node.extra ??= {};\n      let { referencedBindings, isEffect } = targetExtra;\n      for (const node of nodes) {\n        const extra = node?.extra;\n        if (extra) {\n          const additionalBindings = extra.referencedBindings;\n          isEffect ||= extra.isEffect;\n          if (additionalBindings) {\n            referencedBindings = bindingUtil.union(\n              referencedBindings,\n              additionalBindings\n            );\n            forEach(additionalBindings, ({ downstreamExpressions }) => {\n              downstreamExpressions.delete(extra);\n              downstreamExpressions.add(targetExtra);\n            });\n          }\n        }\n      }\n      referencedBindings = findReferences(\n        getOrCreateSection(target),\n        referencedBindings\n      );\n      targetExtra.referencedBindings = referencedBindings;\n      targetExtra.isEffect = isEffect;\n    }\n    mergedReferences.clear();\n  }\n  const bindings = getBindings();\n  for (const binding of bindings) {\n    if (binding.type !== 0 /* dom */ && !binding.upstreamAlias) {\n      if (pruneBinding(bindings, binding)) {\n        const { upstreamExpression } = binding;\n        if (upstreamExpression) {\n          forEach(\n            upstreamExpression.referencedBindings,\n            (referencedBinding) => {\n              referencedBinding.downstreamExpressions.delete(\n                upstreamExpression\n              );\n              pruneBinding(bindings, referencedBinding);\n            }\n          );\n        }\n      }\n    }\n  }\n  const intersections = /* @__PURE__ */ new Set();\n  for (const binding of bindings) {\n    const { section } = binding;\n    section.bindings.add(binding);\n    for (const {\n      referencedBindings,\n      isEffect\n    } of binding.downstreamExpressions) {\n      if (Array.isArray(referencedBindings)) {\n        intersections.add(referencedBindings);\n      }\n      forEach(referencedBindings, (bindingReference) => {\n        if (isEffect) {\n          bindingReference.serialize = true;\n        }\n      });\n    }\n  }\n  for (const intersection of intersections) {\n    const numReferences = intersection.length;\n    for (let i = 0; i < numReferences - 1; i++) {\n      for (let j = i + 1; j < numReferences; j++) {\n        const binding1 = intersection[i];\n        const binding2 = intersection[j];\n        const sources1 = getSourceBindings(binding1);\n        const sources2 = getSourceBindings(binding2);\n        if (!binding1.serialize && !isSuperset(sources1, sources2)) {\n          binding1.serialize = true;\n        }\n        if (!binding2.serialize && !isSuperset(sources2, sources1)) {\n          binding2.serialize = true;\n        }\n      }\n    }\n  }\n  forEachSection((section) => {\n    for (const binding of section.closures) {\n      if (!binding.serialize) {\n        let serialize = false;\n        const sourceSection = binding.section;\n        let currentSection = section;\n        while (currentSection !== sourceSection && !(serialize = !currentSection.upstreamExpression || isStatefulReferences(\n          currentSection.upstreamExpression.referencedBindings\n        ))) {\n          currentSection = currentSection.parent;\n        }\n        binding.serialize = serialize;\n      }\n    }\n  });\n  forEachSection(({ id, bindings: bindings2 }) => {\n    const sortedBindings = [...bindings2].filter((b) => b.section.id === id).sort(bindingUtil.compare);\n    for (let i = sortedBindings.length; i--; ) {\n      const binding = sortedBindings[i];\n      binding.id = i;\n    }\n  });\n}\nfunction isSuperset(set, subset) {\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getSourceBindings(binding) {\n  const derived = /* @__PURE__ */ new Set();\n  const sources = /* @__PURE__ */ new Set();\n  crawl(binding);\n  return sources;\n  function crawl(binding2) {\n    if (binding2.type === 4 /* derived */ || binding2.type === 3 /* param */) {\n      let alias;\n      let curBinding = binding2;\n      while (alias = curBinding.upstreamAlias) {\n        curBinding = alias;\n      }\n      if (curBinding.upstreamExpression) {\n        if (derived.has(curBinding))\n          return;\n        derived.add(curBinding);\n        forEach(curBinding.upstreamExpression.referencedBindings, crawl);\n      } else {\n        sources.add(curBinding);\n      }\n    } else {\n      sources.add(binding2);\n    }\n  }\n}\nvar bindingUtil = new Sorted(function compareBindings(a, b) {\n  return a.section.id - b.section.id || a.type !== b.type && (a.type === 0 /* dom */ || b.type === 0 /* dom */) ? a.type - b.type : a.id - b.id;\n});\nvar [getIntersections, setIntersections] = createSectionState(\n  \"intersections\",\n  () => []\n);\nfunction addReferenceToExpression(path3, binding) {\n  const exprExtra = path3.node.extra ??= {};\n  const section = getOrCreateSection(path3);\n  exprExtra.referencedBindings = addReference(\n    section,\n    exprExtra.referencedBindings,\n    binding\n  );\n  binding.downstreamExpressions.add(exprExtra);\n}\nfunction getCanonicalBinding(binding) {\n  return binding && (binding.property ? binding : binding.upstreamAlias || binding);\n}\nfunction addReference(section, referencedBindings, binding) {\n  if (section !== binding.section) {\n    section.closures.add(binding);\n  }\n  const newIntersection = bindingUtil.add(referencedBindings, binding);\n  return findReferences(section, newIntersection);\n}\nfunction findReferences(section, referencedBindings) {\n  if (!referencedBindings || !Array.isArray(referencedBindings)) {\n    return referencedBindings;\n  }\n  const intersections = getIntersections(section);\n  let intersection = findSorted(\n    compareIntersections,\n    intersections,\n    referencedBindings\n  );\n  if (!intersection) {\n    setIntersections(\n      section,\n      addSorted(compareIntersections, intersections, referencedBindings)\n    );\n    intersection = referencedBindings;\n  }\n  return intersection;\n}\nfunction getScopeAccessorLiteral(binding) {\n  if (isOptimize()) {\n    return import_compiler16.types.numericLiteral(binding.id);\n  }\n  return import_compiler16.types.stringLiteral(\n    binding.name + (binding.type === 0 /* dom */ ? `/${binding.id}` : \"\")\n  );\n}\nfunction pruneBinding(bindings, binding) {\n  let shouldPrune = !binding.downstreamExpressions.size;\n  for (const alias of binding.aliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.aliases.delete(alias);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  for (const [key, alias] of binding.propertyAliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.propertyAliases.delete(key);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  if (shouldPrune) {\n    bindings.delete(binding);\n  }\n  return shouldPrune;\n}\n\n// src/util/is-stateful.ts\nfunction isStatefulReferences(referencedBindings) {\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        if (isStatefulBinding(ref)) {\n          return true;\n        }\n      }\n    } else {\n      return isStatefulBinding(referencedBindings);\n    }\n  }\n  return false;\n}\nfunction isStatefulBinding(binding) {\n  switch (binding.type) {\n    case 1 /* let */:\n    case 2 /* input */:\n      return true;\n    default:\n      return !binding.upstreamExpression || isStatefulReferences(binding.upstreamExpression.referencedBindings);\n  }\n}\n\n// src/util/to-first-statement-or-block.ts\nvar import_compiler17 = require(\"@marko/compiler\");\nfunction toFirstStatementOrBlock(body) {\n  const nodes = body.body;\n  if (nodes.length === 1) {\n    return nodes[0];\n  }\n  if (import_compiler17.types.isBlockStatement(body)) {\n    return body;\n  }\n  return import_compiler17.types.blockStatement(nodes);\n}\n\n// src/core/condition/if.ts\nvar kBinding = Symbol(\"if node binding\");\nvar if_default = {\n  analyze(tag) {\n    const tagBody = tag.get(\"body\");\n    const section = getOrCreateSection(tag);\n    const tagExtra = tag.node.extra ??= {};\n    startSection(tagBody);\n    tagExtra[kBinding] = createBinding(\n      \"#text\",\n      0 /* dom */,\n      section,\n      void 0,\n      tagExtra\n    );\n    analyze(tag);\n  },\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [testAttr] = node.attributes;\n      (0, import_babel_utils13.assertNoVar)(tag);\n      (0, import_babel_utils13.assertNoParams)(tag);\n      if (!import_compiler18.types.isMarkoAttribute(testAttr) || !testAttr.default) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          `The '<if>' tag requires a default attribute like '<if=condition>'.`\n        );\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<if>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError(\n            { loc: { start, end } },\n            msg,\n            Error\n          );\n        }\n      }\n      visit(tag, 37 /* Replace */);\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n      translate.enter(tag);\n    },\n    exit(tag) {\n      translate.exit(tag);\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      snippet: \"if=${1:condition}\",\n      description: \"Use to display content only if the condition is met.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar BRANCHES_LOOKUP = /* @__PURE__ */ new WeakMap();\nfunction getBranches(tag, bodySection) {\n  const branches = BRANCHES_LOOKUP.get(tag) ?? [];\n  const nextTag = tag.getNextSibling();\n  const isLast = !(isCoreTagName(nextTag, \"else\") || isCoreTagName(nextTag, \"else-if\"));\n  branches.push({\n    tag,\n    section: bodySection\n  });\n  if (!isLast) {\n    BRANCHES_LOOKUP.set(nextTag, branches);\n  }\n  return [isLast, branches];\n}\nfunction getRoot(tag) {\n  if (isCoreTagName(tag, \"if\")) {\n    return tag;\n  }\n  return BRANCHES_LOOKUP.get(tag)[0].tag;\n}\nfunction analyze(tag) {\n  const tagBody = tag.get(\"body\");\n  const bodySection = getOrCreateSection(tagBody);\n  const [isLast, branches] = getBranches(tag, bodySection);\n  if (isLast) {\n    const rootTag = branches[0].tag;\n    const rootExtra = rootTag.node.extra;\n    mergeReferences(\n      rootTag,\n      branches.map(({ tag: tag2 }) => tag2.node.attributes[0]?.value)\n    );\n    rootExtra.singleNodeOptimization = branches.every(({ tag: tag2 }) => {\n      return tag2.node.body.body.length === 1;\n    });\n    branches.forEach(({ section }) => {\n      section.upstreamExpression = rootExtra;\n    });\n  }\n}\nvar translate = {\n  enter(tag) {\n    const tagBody = tag.get(\"body\");\n    const bodySection = getSection(tagBody);\n    const rootExtra = getRoot(tag).node.extra;\n    const isStateful = isStatefulReferences(rootExtra.referencedBindings);\n    const singleNodeOptimization = rootExtra.singleNodeOptimization;\n    if (isOutputHTML() && isStateful && !singleNodeOptimization) {\n      writeTo(tagBody)`${callRuntime(\n        \"markResumeScopeStart\",\n        getScopeIdIdentifier(bodySection)\n      )}`;\n    }\n  },\n  exit(tag) {\n    const tagBody = tag.get(\"body\");\n    const section = getSection(tag);\n    const bodySection = getSection(tagBody);\n    const [isLast, branches] = getBranches(tag, bodySection);\n    const rootExtra = branches[0].tag.node.extra;\n    const nodeRef = rootExtra[kBinding];\n    const isStateful = isStatefulReferences(rootExtra.referencedBindings);\n    const singleNodeOptimization = rootExtra.singleNodeOptimization;\n    const hasStatefulClosures = checkStatefulClosures(bodySection, true);\n    if (isOutputHTML()) {\n      if (isStateful || hasStatefulClosures) {\n        setForceResumeScope(bodySection);\n      }\n      flushInto(tag);\n      setSubscriberBuilder(tag, () => {\n      });\n      writeHTMLResumeStatements(tagBody);\n    }\n    if (isLast) {\n      const extra = branches[0].tag.node.extra;\n      if (isOutputDOM()) {\n        let expr = import_compiler18.types.nullLiteral();\n        for (let i = branches.length; i--; ) {\n          const { tag: tag2, section: section2 } = branches[i];\n          const [testAttr] = tag2.node.attributes;\n          const id = import_compiler18.types.identifier(section2.name);\n          setSubscriberBuilder(tag2, (subscriber) => {\n            return callRuntime(\n              \"inConditionalScope\",\n              subscriber,\n              getScopeAccessorLiteral(nodeRef)\n              /*t.identifier(section.name)*/\n            );\n          });\n          tag2.remove();\n          if (testAttr) {\n            expr = import_compiler18.types.conditionalExpression(testAttr.value, id, expr);\n          } else {\n            expr = id;\n          }\n        }\n        const signal = getSignal(section, nodeRef, \"if\");\n        signal.build = () => {\n          return callRuntime(\n            \"conditional\",\n            getScopeAccessorLiteral(nodeRef),\n            getSignalFn(signal, [scopeIdentifier])\n          );\n        };\n        signal.hasDownstreamIntersections = () => branches.some((b) => getClosures(b.section).length > 0);\n        addValue(section, extra.referencedBindings, signal, expr);\n      } else {\n        const write2 = writeTo(tag);\n        const nextTag = tag.getNextSibling();\n        const ifScopeIdIdentifier = tag.scope.generateUidIdentifier(\"ifScopeId\");\n        const ifRendererIdentifier = tag.scope.generateUidIdentifier(\"ifRenderer\");\n        let statement;\n        for (let i = branches.length; i--; ) {\n          const { tag: tag2, section: section2 } = branches[i];\n          const branchHasStatefulClosures = checkStatefulClosures(\n            section2,\n            true\n          );\n          if (isStateful) {\n            tag2.node.body.body.push(\n              import_compiler18.types.expressionStatement(\n                callRuntime(\n                  \"register\",\n                  import_compiler18.types.assignmentExpression(\n                    \"=\",\n                    ifRendererIdentifier,\n                    callRuntime(\n                      \"createRenderer\",\n                      import_compiler18.types.arrowFunctionExpression([], import_compiler18.types.blockStatement([]))\n                    )\n                  ),\n                  import_compiler18.types.stringLiteral(getResumeRegisterId(section2, \"renderer\")),\n                  section2.closures.size && getScopeIdIdentifier(section2.parent)\n                )\n              )\n            );\n          }\n          if (isStateful || branchHasStatefulClosures) {\n            tag2.node.body.body.push(\n              import_compiler18.types.expressionStatement(\n                import_compiler18.types.assignmentExpression(\n                  \"=\",\n                  ifScopeIdIdentifier,\n                  getScopeIdIdentifier(section2)\n                )\n              )\n            );\n          }\n          const [testAttr] = tag2.node.attributes;\n          const curStatement = toFirstStatementOrBlock(tag2.node.body);\n          if (testAttr) {\n            statement = import_compiler18.types.ifStatement(testAttr.value, curStatement, statement);\n          } else {\n            statement = curStatement;\n          }\n          tag2.remove();\n        }\n        if (!isStateful && !hasStatefulClosures) {\n          nextTag.insertBefore(statement);\n        } else {\n          nextTag.insertBefore([\n            import_compiler18.types.variableDeclaration(\n              \"let\",\n              [\n                import_compiler18.types.variableDeclarator(ifScopeIdIdentifier),\n                isStateful && import_compiler18.types.variableDeclarator(ifRendererIdentifier)\n              ].filter(Boolean)\n            ),\n            statement\n          ]);\n          if (isStateful) {\n            if (singleNodeOptimization) {\n              write2`${callRuntime(\n                \"markResumeControlSingleNodeEnd\",\n                getScopeIdIdentifier(section),\n                getScopeAccessorLiteral(nodeRef),\n                ifScopeIdIdentifier\n              )}`;\n            } else {\n              write2`${callRuntime(\n                \"markResumeControlEnd\",\n                getScopeIdIdentifier(section),\n                getScopeAccessorLiteral(nodeRef)\n              )}`;\n            }\n            getSerializedScopeProperties(section).set(\n              import_compiler18.types.stringLiteral(\n                getScopeAccessorLiteral(nodeRef).value + \"(\" /* ConditionalRenderer */\n              ),\n              ifRendererIdentifier\n            );\n          }\n          getSerializedScopeProperties(section).set(\n            import_compiler18.types.stringLiteral(\n              getScopeAccessorLiteral(nodeRef).value + \"!\" /* ConditionalScope */\n            ),\n            callRuntime(\"getScopeById\", ifScopeIdIdentifier)\n          );\n        }\n      }\n    }\n  }\n};\n\n// src/core/condition/else.ts\nvar else_default = {\n  analyze,\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [testAttr] = node.attributes;\n      (0, import_babel_utils14.assertNoVar)(tag);\n      (0, import_babel_utils14.assertNoParams)(tag);\n      if (node.attributes.length > 1 || testAttr && testAttr.name !== \"if\") {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<else>' tag only supports an if attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError(\n            { loc: { start, end } },\n            msg,\n            Error\n          );\n        }\n      }\n      translate.enter(tag);\n    },\n    exit(tag) {\n      translate.exit(tag);\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\n\n// src/core/condition/else-if.ts\nvar import_babel_utils15 = require(\"@marko/babel-utils\");\nvar import_compiler19 = require(\"@marko/compiler\");\nvar else_if_default = {\n  analyze,\n  translate: {\n    enter(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      (0, import_babel_utils15.assertNoVar)(tag);\n      (0, import_babel_utils15.assertNoParams)(tag);\n      if (!import_compiler19.types.isMarkoAttribute(valueAttr) || !valueAttr.default) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          `The '<else-if>' tag requires a default attribute like '<else-if=condition>'.`\n        );\n      }\n      if (node.attributes.length > 1) {\n        const start = node.attributes[1].loc?.start;\n        const end = node.attributes[node.attributes.length - 1].loc?.end;\n        const msg = `The '<else-if>' tag only supports a default attribute.`;\n        if (start == null || end == null) {\n          throw tag.get(\"name\").buildCodeFrameError(msg);\n        } else {\n          throw tag.hub.buildError(\n            { loc: { start, end } },\n            msg,\n            Error\n          );\n        }\n      }\n      translate.enter(tag);\n    },\n    exit(tag) {\n      translate.exit(tag);\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      snippet: \"else-if=${1:condition}\",\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\n\n// src/core/const.ts\nvar import_babel_utils16 = require(\"@marko/babel-utils\");\nvar import_compiler21 = require(\"@marko/compiler\");\n\n// src/util/translate-var.ts\nvar import_compiler20 = require(\"@marko/compiler\");\nfunction translateVar(tag, initialValue, kind = \"const\") {\n  const {\n    node: { var: tagVar }\n  } = tag;\n  if (!tagVar) {\n    return;\n  }\n  tag.insertBefore(\n    import_compiler20.types.variableDeclaration(kind, [\n      import_compiler20.types.variableDeclarator(import_compiler20.types.cloneDeep(tagVar), initialValue)\n    ])\n  );\n}\n\n// src/core/const.ts\nvar const_default = {\n  analyze(tag) {\n    (0, import_babel_utils16.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'const' tag requires a tag variable.\");\n    }\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'const' tag requires a default attribute.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler21.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The 'const' tag only supports the 'default' attribute.\"\n      );\n    }\n    const upstreamAlias = import_compiler21.types.isIdentifier(valueAttr.value) ? tag.scope.getBinding(valueAttr.value.name)?.identifier.extra?.binding : void 0;\n    trackVarReferences(\n      tag,\n      4 /* derived */,\n      upstreamAlias,\n      valueAttr.value.extra ??= {}\n    );\n  },\n  translate(tag) {\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    const { value } = valueAttr;\n    if (isOutputDOM()) {\n      const section = getSection(tag);\n      const varBinding = node.var.extra?.binding;\n      if (varBinding && !varBinding.upstreamAlias) {\n        const derivation = initValue(varBinding);\n        addValue(section, value.extra?.referencedBindings, derivation, value);\n      }\n    } else {\n      translateVar(tag, value);\n    }\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an constant binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#const\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/const.d.marko\"\n};\n\n// src/core/debug.ts\nvar import_babel_utils17 = require(\"@marko/babel-utils\");\nvar import_compiler22 = require(\"@marko/compiler\");\nvar debug_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils17.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (tag.node.attributes.length > 1 || tag.node.attributes.length === 1 && (!import_compiler22.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\")) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The 'debug' tag only supports the 'value' attribute.\"\n      );\n    }\n  },\n  translate(tag) {\n    const section = getSection(tag);\n    const [valueAttr] = tag.node.attributes;\n    const referencedBindings = valueAttr?.value.extra?.referencedBindings;\n    const statement = import_compiler22.types.debuggerStatement();\n    if (isOutputHTML()) {\n      tag.insertBefore(statement);\n    } else {\n      addStatement(\"render\", section, referencedBindings, statement);\n    }\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Debug on value change.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#debug\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/debug.d.marko\"\n};\n\n// src/core/define.ts\nvar import_babel_utils18 = require(\"@marko/babel-utils\");\nvar import_compiler25 = require(\"@marko/compiler\");\n\n// src/util/attrs-to-object.ts\nvar import_compiler24 = require(\"@marko/compiler\");\n\n// src/util/to-property-name.ts\nvar import_compiler23 = require(\"@marko/compiler\");\nvar IDENTIFIER_REG = /^[0-9A-Z_$]+$/i;\nfunction toPropertyName(name) {\n  return IDENTIFIER_REG.test(name) ? import_compiler23.types.identifier(name) : import_compiler23.types.stringLiteral(name);\n}\n\n// src/util/attrs-to-object.ts\nvar renderBodyProps = /* @__PURE__ */ new WeakMap();\nvar htmlHoistFunctionVisitor = {\n  FunctionExpression: { exit: htmlFunctionVisit },\n  ArrowFunctionExpression: { exit: htmlFunctionVisit }\n};\nvar domHoistFunctionVisitor = {\n  FunctionExpression: { exit: domFunctionVisit },\n  ArrowFunctionExpression: { exit: domFunctionVisit }\n};\nfunction htmlFunctionVisit(fn, state) {\n  const extra = fn.node.extra;\n  if (!extra)\n    return;\n  const serializedScopeProperties = getSerializedScopeProperties(state.section);\n  forEach(extra.referencedBindings, (ref) => {\n    serializedScopeProperties.set(\n      getScopeAccessorLiteral(ref),\n      import_compiler24.types.identifier(ref.name)\n    );\n  });\n  fn.replaceWith(\n    callRuntime(\n      \"register\",\n      fn.node,\n      import_compiler24.types.stringLiteral(extra.registerId),\n      getScopeIdIdentifier(state.section)\n    )\n  )[0].skip();\n}\nfunction domFunctionVisit(fn, state) {\n  const { node } = fn;\n  const extra = node.extra;\n  if (!extra)\n    return;\n  const { referencedBindings } = extra;\n  const fnId = currentProgramPath.scope.generateUidIdentifier(extra.name);\n  currentProgramPath.pushContainer(\n    \"body\",\n    import_compiler24.types.variableDeclaration(\"const\", [\n      import_compiler24.types.variableDeclarator(\n        fnId,\n        callRuntime(\n          \"register\",\n          import_compiler24.types.stringLiteral(extra.registerId),\n          import_compiler24.types.arrowFunctionExpression(\n            [scopeIdentifier],\n            referencedBindings ? import_compiler24.types.blockStatement([\n              import_compiler24.types.variableDeclaration(\"const\", [\n                import_compiler24.types.variableDeclarator(\n                  createScopeReadPattern(\n                    state.section,\n                    referencedBindings\n                  ),\n                  scopeIdentifier\n                )\n              ]),\n              import_compiler24.types.returnStatement(node)\n            ]) : node\n          )\n        )\n      )\n    ])\n  )[0].skip();\n  fn.replaceWith(import_compiler24.types.callExpression(fnId, [scopeIdentifier]))[0].skip();\n}\nfunction attrsToObject(tag, withRenderBody = false) {\n  const { node } = tag;\n  let result = import_compiler24.types.objectExpression([]);\n  const resultExtra = result.extra = {};\n  const section = getSection(tag);\n  const hoistVisitor = isOutputHTML() ? htmlHoistFunctionVisitor : domHoistFunctionVisitor;\n  for (const attr2 of tag.get(\"attributes\")) {\n    attr2.traverse(hoistVisitor, { section });\n    const value = attr2.node.value;\n    if (attr2.isMarkoSpreadAttribute()) {\n      result.properties.push(import_compiler24.types.spreadElement(value));\n    } else {\n      result.properties.push(\n        import_compiler24.types.objectProperty(\n          toPropertyName(attr2.node.name),\n          value\n        )\n      );\n    }\n  }\n  if (withRenderBody) {\n    const { body, params } = node.body;\n    let hoistedControlFlows = node.extra.hoistedControlFlows;\n    if (hoistedControlFlows) {\n      for (const child of tag.get(\"body\").get(\"body\")) {\n        tag.insertBefore(child.node);\n        child.remove();\n        if (child.isConditional() || child.isLoop()) {\n          if (!--hoistedControlFlows) {\n            break;\n          }\n        }\n      }\n    }\n    if (body.length) {\n      const renderBodySection = getSection(tag.get(\"body\"));\n      const renderBodyExpression = import_compiler24.types.arrowFunctionExpression(\n        params,\n        import_compiler24.types.blockStatement(body)\n      );\n      renderBodyProps.set(result, renderBodyExpression);\n      if (isOutputHTML()) {\n        result.properties.push(\n          import_compiler24.types.objectProperty(\n            import_compiler24.types.identifier(\"renderBody\"),\n            callRuntime(\n              \"register\",\n              callRuntime(\"createRenderer\", renderBodyExpression),\n              import_compiler24.types.stringLiteral(\n                getResumeRegisterId(renderBodySection, \"renderer\")\n              ),\n              renderBodySection.closures.size && getScopeIdIdentifier(renderBodySection.parent)\n            )\n          )\n        );\n      } else {\n        result.properties.push(\n          import_compiler24.types.objectProperty(import_compiler24.types.identifier(\"renderBody\"), renderBodyExpression)\n        );\n      }\n    }\n  }\n  if (result.properties.length) {\n    if (result.properties.length === 1) {\n      const [prop] = result.properties;\n      if (import_compiler24.types.isSpreadElement(prop)) {\n        result = prop.argument;\n        result.extra = resultExtra;\n      }\n    }\n  }\n  if (node.arguments?.length) {\n    if (result.properties.length) {\n      result = import_compiler24.types.arrayExpression([...node.arguments, result]);\n    } else if (node.arguments.length == 1) {\n      const arg = node.arguments[0];\n      result = import_compiler24.types.isSpreadElement(arg) ? arg.argument : arg;\n    } else {\n      result = import_compiler24.types.arrayExpression(node.arguments);\n    }\n  }\n  return result;\n}\nfunction getRenderBodyProp(attrsObject) {\n  if (import_compiler24.types.isObjectExpression(attrsObject)) {\n    const lastProp = attrsObject.properties[attrsObject.properties.length - 1];\n    if (import_compiler24.types.isObjectProperty(lastProp) && lastProp.key.name === \"renderBody\") {\n      return renderBodyProps.get(attrsObject);\n    }\n  }\n}\n\n// src/core/define.ts\nvar define_default = {\n  analyze(tag) {\n    const tagBody = tag.get(\"body\");\n    startSection(tagBody);\n    trackVarReferences(tag, 4 /* derived */);\n    trackParamsReferences(tagBody, 3 /* param */);\n    mergeReferences(\n      tag,\n      tag.node.attributes.map((attr2) => attr2.value)\n    );\n  },\n  translate: {\n    enter(tag) {\n      if (!tag.node.var) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"<define> requires a variable to be specified, eg <define/NAME>.\"\n        );\n      }\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        const attrs2 = attrsToObject(tag, true);\n        translateVar(tag, attrs2);\n      } else {\n        const section = getSection(tag);\n        const tagBody = tag.get(\"body\");\n        const tagBodySection = getSection(tagBody);\n        const referencedBindings = node.extra?.referencedBindings;\n        const derivation = initValue(tag.get(\"var\").node.extra.binding);\n        let attrsObject = attrsToObject(tag);\n        if (tagBodySection !== section) {\n          attrsObject ??= import_compiler25.types.objectExpression([]);\n          attrsObject.properties.push(\n            import_compiler25.types.objectProperty(\n              import_compiler25.types.identifier(\"renderBody\"),\n              callRuntime(\n                \"bindRenderer\",\n                scopeIdentifier,\n                import_compiler25.types.identifier(tagBodySection.name)\n              )\n            )\n          );\n        }\n        addValue(section, referencedBindings, derivation, attrsObject);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a constant object binding that can be rendered.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#define\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/define.d.marko\"\n};\n\n// src/core/do.ts\nvar import_babel_utils19 = require(\"@marko/babel-utils\");\nvar import_compiler26 = require(\"@marko/compiler\");\nvar do_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils19.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'do' tag requires a 'value' attribute.\");\n    }\n    if (tag.node.attributes.length > 1 || !import_compiler26.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The 'do' tag only supports the 'value' attribute.\"\n      );\n    }\n  },\n  translate(tag) {\n    const section = getSection(tag);\n    const [valueAttr] = tag.node.attributes;\n    const { value } = valueAttr;\n    const referencedBindings = value.extra?.referencedBindings;\n    let statement = null;\n    if (import_compiler26.types.isFunctionExpression(value) || import_compiler26.types.isArrowFunctionExpression(value)) {\n      if (import_compiler26.types.isBlockStatement(value.body)) {\n        let hasDeclaration = false;\n        for (const child of value.body.body) {\n          if (import_compiler26.types.isDeclaration(child)) {\n            hasDeclaration = true;\n            break;\n          }\n        }\n        statement = hasDeclaration ? value.body : value.body.body;\n      } else {\n        statement = import_compiler26.types.expressionStatement(value.body);\n      }\n    }\n    if (isOutputHTML()) {\n      if (statement) {\n        tag.insertBefore(statement);\n      } else {\n        tag.insertBefore(import_compiler26.types.expressionStatement(import_compiler26.types.callExpression(value, [])));\n      }\n    } else {\n      addStatement(\n        \"render\",\n        section,\n        referencedBindings,\n        statement ?? import_compiler26.types.expressionStatement(import_compiler26.types.callExpression(value, [scopeIdentifier]))\n      );\n    }\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to run a function on render.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#do\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/do.d.marko\"\n};\n\n// src/core/effect.ts\nvar import_babel_utils20 = require(\"@marko/babel-utils\");\nvar import_compiler27 = require(\"@marko/compiler\");\nvar effect_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    (0, import_babel_utils20.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (node.attributes.length > 1 || !import_compiler27.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The 'effect' tag only supports the 'value' attribute.\"\n      );\n    }\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'effect' tag requires a 'value' attribute.\");\n    }\n    (valueAttr.value.extra ??= {}).isEffect = true;\n    (currentProgramPath.node.extra ??= {}).isInteractive = true;\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      const section = getSection(tag);\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      if (isOutputDOM()) {\n        const { value: value2 } = valueAttr;\n        let inlineBody = null;\n        if (import_compiler27.types.isFunctionExpression(value2) || import_compiler27.types.isArrowFunctionExpression(value2)) {\n          if (import_compiler27.types.isBlockStatement(value2.body)) {\n            let hasDeclaration = false;\n            for (const child of value2.body.body) {\n              if (import_compiler27.types.isDeclaration(child)) {\n                hasDeclaration = true;\n                break;\n              }\n            }\n            inlineBody = hasDeclaration ? value2.body : value2.body.body;\n          } else {\n            inlineBody = import_compiler27.types.expressionStatement(value2.body);\n          }\n        }\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          inlineBody || import_compiler27.types.expressionStatement(import_compiler27.types.callExpression(value2, [scopeIdentifier])),\n          value2,\n          !!inlineBody\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/effect.d.marko\"\n};\n\n// src/core/export.ts\nvar import_babel_utils21 = require(\"@marko/babel-utils\");\nvar export_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils21.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"export <value>\"\n    }\n  ]\n};\n\n// src/core/for.ts\nvar import_babel_utils25 = require(\"@marko/babel-utils\");\nvar import_compiler29 = require(\"@marko/compiler\");\n\n// src/util/nested-attribute-tags.ts\nvar import_babel_utils22 = require(\"@marko/babel-utils\");\nfunction analyzeAttributeTags(tag) {\n  const extra = tag.node.extra ??= {};\n  extra.nestedAttributeTags = {};\n  extra.hoistedControlFlows = 0;\n  analyzeChildren(extra, false, false, tag);\n}\nfunction analyzeChildren(rootExtra, repeated, dynamic, tag) {\n  let hasAttributeTags = false;\n  for (const child of tag.get(\"body\").get(\"body\")) {\n    if (child.isMarkoTag()) {\n      if (analyzeChild(rootExtra, repeated, dynamic, child)) {\n        hasAttributeTags = true;\n      }\n    }\n  }\n  return hasAttributeTags;\n}\nfunction analyzeChild(rootExtra, repeated, dynamic, tag) {\n  if ((0, import_babel_utils22.isTransparentTag)(tag)) {\n    if (analyzeChildren(rootExtra, repeated || (0, import_babel_utils22.isLoopTag)(tag), true, tag)) {\n      if (!(0, import_babel_utils22.isTransparentTag)(tag.parentPath.parentPath)) {\n        rootExtra.hoistedControlFlows++;\n      }\n      return true;\n    }\n  } else if ((0, import_babel_utils22.isAttributeTag)(tag)) {\n    const attrName = tag.node.name.value.slice(1);\n    const lookup = rootExtra.nestedAttributeTags;\n    const existing = lookup[attrName];\n    const info = existing || (lookup[attrName] = {\n      dynamic: false,\n      repeated: false\n    });\n    info.dynamic ||= dynamic;\n    info.repeated ||= repeated || existing !== void 0;\n    return true;\n  }\n  return false;\n}\n\n// src/visitors/tag/native-tag.ts\nvar import_babel_utils24 = require(\"@marko/babel-utils\");\nvar import_compiler28 = require(\"@marko/compiler\");\n\n// src/util/evaluate.ts\nvar import_babel_utils23 = require(\"@marko/babel-utils\");\nfunction evaluate(path3) {\n  let { extra } = path3.node;\n  if (!extra) {\n    extra = path3.node.extra = {};\n  }\n  if (extra.confident === void 0) {\n    const computed = (0, import_babel_utils23.computeNode)(path3.node.value);\n    if (computed) {\n      extra.computed = computed.value;\n      extra.confident = true;\n    } else {\n      extra.computed = void 0;\n      extra.confident = false;\n    }\n  }\n  return extra;\n}\n\n// src/visitors/tag/native-tag.ts\nvar kNativeTagBinding = Symbol(\"native tag binding\");\nvar kSerializeMarker = Symbol(\"serialize marker\");\nvar native_tag_default = {\n  analyze: {\n    enter(tag) {\n      const { node } = tag;\n      const attrs2 = tag.get(\"attributes\");\n      let hasEventHandlers = false;\n      let hasDynamicAttributes = false;\n      for (const attr2 of attrs2) {\n        if (isSpreadAttr(attr2)) {\n          (attr2.node.value.extra ??= {}).isEffect = true;\n          hasEventHandlers = true;\n          hasDynamicAttributes = true;\n          mergeReferences(\n            tag,\n            attrs2.map((attr3) => attr3.node.value)\n          );\n        } else if (isEventHandler(attr2.node.name)) {\n          (attr2.node.value.extra ??= {}).isEffect = true;\n          hasEventHandlers = true;\n        } else if (!evaluate(attr2).confident) {\n          hasDynamicAttributes = true;\n        }\n      }\n      if (tag.has(\"var\") || hasEventHandlers || hasDynamicAttributes) {\n        currentProgramPath.node.extra.isInteractive ||= hasEventHandlers;\n        const section = getOrCreateSection(tag);\n        const tagName = node.name.type === \"StringLiteral\" ? node.name.value : import_compiler28.types.toIdentifier(tag.get(\"name\"));\n        const tagExtra = node.extra ??= {};\n        tagExtra[kSerializeMarker] = tag.has(\"var\") || hasEventHandlers;\n        tagExtra[kNativeTagBinding] = createBinding(\n          \"#\" + tagName,\n          0 /* dom */,\n          section\n        );\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      (0, import_babel_utils24.assertNoArgs)(tag);\n      const extra = tag.node.extra;\n      const nodeRef = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const name = tag.get(\"name\");\n      const attrs2 = tag.get(\"attributes\");\n      const tagDef = (0, import_babel_utils24.getTagDef)(tag);\n      const hasSpread = attrs2.some((attr2) => attr2.isMarkoSpreadAttribute());\n      const write2 = writeTo(tag);\n      const section = getSection(tag);\n      if (isHTML && extra.tagNameNullable) {\n        flushBefore(tag);\n      }\n      if (tag.has(\"var\")) {\n        if (isHTML) {\n          translateVar(\n            tag,\n            import_compiler28.types.arrowFunctionExpression(\n              [],\n              import_compiler28.types.blockStatement([\n                import_compiler28.types.throwStatement(\n                  import_compiler28.types.newExpression(import_compiler28.types.identifier(\"Error\"), [\n                    import_compiler28.types.stringLiteral(\"Cannot reference DOM node from server\")\n                  ])\n                )\n              ])\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let createElFunction = void 0;\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (reference.parentPath?.isCallExpression()) {\n              reference.parentPath.replaceWith(\n                import_compiler28.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, nodeRef)\n                )\n              );\n            } else {\n              createElFunction ??= import_compiler28.types.identifier(varName + \"_getter\");\n              reference.replaceWith(\n                callRuntime(\n                  \"bindFunction\",\n                  getScopeExpression(referenceSection, section),\n                  createElFunction\n                )\n              );\n            }\n          }\n          if (createElFunction) {\n            currentProgramPath.pushContainer(\n              \"body\",\n              import_compiler28.types.variableDeclaration(\"const\", [\n                import_compiler28.types.variableDeclarator(\n                  createElFunction,\n                  import_compiler28.types.arrowFunctionExpression(\n                    [scopeIdentifier],\n                    import_compiler28.types.memberExpression(\n                      scopeIdentifier,\n                      getScopeAccessorLiteral(nodeRef),\n                      true\n                    )\n                  )\n                )\n              ])\n            );\n          }\n        }\n      }\n      let visitAccessor;\n      if (nodeRef) {\n        visitAccessor = getScopeAccessorLiteral(nodeRef);\n        visit(tag, 32 /* Get */);\n      }\n      write2`<${name.node}`;\n      if (hasSpread) {\n        const attrsObj = attrsToObject(tag);\n        if (isHTML) {\n          addHTMLEffectCall(section, extra.referencedBindings);\n          write2`${callRuntime(\"attrs\", attrsObj, visitAccessor, getScopeIdIdentifier(section))}`;\n        } else {\n          addStatement(\n            \"render\",\n            section,\n            extra.referencedBindings,\n            import_compiler28.types.expressionStatement(\n              callRuntime(\"attrs\", scopeIdentifier, visitAccessor, attrsObj)\n            )\n          );\n          addStatement(\n            \"effect\",\n            section,\n            extra.referencedBindings,\n            import_compiler28.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            attrsObj\n          );\n        }\n      } else {\n        for (const attr2 of attrs2) {\n          const name2 = attr2.node.name;\n          const value = attr2.get(\"value\");\n          const { confident, computed } = attr2.node.extra ?? {};\n          const valueReferences = value.node.extra?.referencedBindings;\n          switch (name2) {\n            case \"class\":\n            case \"style\": {\n              const helper = `${name2}Attr`;\n              if (confident) {\n                write2`${getHTMLRuntime()[helper](computed)}`;\n              } else if (isHTML) {\n                write2`${callRuntime(helper, value.node)}`;\n              } else {\n                addStatement(\n                  \"render\",\n                  section,\n                  valueReferences,\n                  import_compiler28.types.expressionStatement(\n                    callRuntime(\n                      helper,\n                      import_compiler28.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                      value.node\n                    )\n                  )\n                );\n              }\n              break;\n            }\n            default:\n              if (confident) {\n                write2`${getHTMLRuntime().attr(name2, computed)}`;\n              } else if (isHTML) {\n                if (isEventHandler(name2)) {\n                  addHTMLEffectCall(section, valueReferences);\n                } else {\n                  write2`${callRuntime(\n                    \"attr\",\n                    import_compiler28.types.stringLiteral(name2),\n                    value.node\n                  )}`;\n                }\n              } else if (isEventHandler(name2)) {\n                addStatement(\n                  \"effect\",\n                  section,\n                  valueReferences,\n                  import_compiler28.types.expressionStatement(\n                    callRuntime(\n                      \"on\",\n                      import_compiler28.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                      import_compiler28.types.stringLiteral(getEventHandlerName(name2)),\n                      value.node\n                    )\n                  ),\n                  value.node\n                );\n              } else {\n                addStatement(\n                  \"render\",\n                  section,\n                  valueReferences,\n                  import_compiler28.types.expressionStatement(\n                    callRuntime(\n                      \"attr\",\n                      import_compiler28.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                      import_compiler28.types.stringLiteral(name2),\n                      value.node\n                    )\n                  )\n                );\n              }\n              break;\n          }\n        }\n      }\n      if (tagDef && tagDef.parseOptions?.openTagOnly) {\n        switch (tagDef.htmlType) {\n          case \"svg\":\n          case \"math\":\n            write2`/>`;\n            break;\n          default:\n            write2`>`;\n            break;\n        }\n      } else {\n        write2`>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(import_compiler28.types.ifStatement(name.node, consumeHTML(tag)))[0].skip();\n      }\n      enter(tag);\n    },\n    exit(tag) {\n      const extra = tag.node.extra;\n      const nodeRef = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const openTagOnly = (0, import_babel_utils24.getTagDef)(tag)?.parseOptions?.openTagOnly;\n      if (isHTML && extra.tagNameNullable) {\n        flushInto(tag);\n      }\n      tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n      if (!openTagOnly) {\n        writeTo(tag)`</${tag.node.name}>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(\n          import_compiler28.types.ifStatement(tag.node.name, consumeHTML(tag))\n        )[0].skip();\n      }\n      if (nodeRef && (extra[kSerializeMarker] || tag.node.attributes.some(\n        (attr2) => isStatefulReferences(attr2.value.extra?.referencedBindings)\n      ))) {\n        markNode(tag, nodeRef);\n      }\n      exit(tag);\n      tag.remove();\n    }\n  }\n};\nfunction isSpreadAttr(attr2) {\n  return attr2.type === \"MarkoSpreadAttribute\";\n}\nfunction isEventHandler(propName) {\n  return /^on[A-Z-]/.test(propName);\n}\nfunction getEventHandlerName(propName) {\n  return propName.charAt(2) === \"-\" ? propName.slice(3) : propName.charAt(2).toLowerCase() + propName.slice(3);\n}\n\n// src/core/for.ts\nvar kForMarkerBinding = Symbol(\"for marker binding\");\nvar for_default = {\n  analyze(tag) {\n    const isOnlyChild = checkOnlyChild(tag);\n    const tagExtra = tag.node.extra ??= {};\n    const tagBody = tag.get(\"body\");\n    const section = getOrCreateSection(tag);\n    const bodySection = startSection(tagBody);\n    if (isOnlyChild) {\n      const parentTag = tag.parentPath.parent;\n      const parentTagName = parentTag.name?.value;\n      (parentTag.extra ??= {})[kNativeTagBinding] ??= createBinding(\n        \"#\" + parentTagName,\n        0 /* dom */,\n        section\n      );\n    } else {\n      tagExtra[kForMarkerBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section\n      );\n    }\n    trackParamsReferences(tagBody, 3 /* param */, void 0, tagExtra);\n    analyzeAttributeTags(tag);\n    mergeReferences(\n      tag,\n      tag.node.attributes.map((attr2) => attr2.value)\n    );\n    bodySection.upstreamExpression = tagExtra;\n    tagExtra.singleNodeOptimization = tag.node.body.body.length === 1;\n  },\n  translate: {\n    enter(tag) {\n      validateFor(tag);\n      const tagBody = tag.get(\"body\");\n      const bodySection = getSection(tagBody);\n      const tagExtra = tag.node.extra;\n      const { singleNodeOptimization, isOnlyChild } = tagExtra;\n      const isStateful = isStatefulReferences(tagExtra.referencedBindings);\n      const hasNestedAttributeTags = tagExtra.nestedAttributeTags && Object.keys(tagExtra.nestedAttributeTags).length > 0;\n      if (!isOnlyChild) {\n        visit(tag, 37 /* Replace */);\n        enterShallow(tag);\n      }\n      if (isOutputHTML()) {\n        flushBefore(tag);\n        if (isStateful && !singleNodeOptimization && !hasNestedAttributeTags) {\n          writeTo(tagBody)`${callRuntime(\n            \"markResumeScopeStart\",\n            getScopeIdIdentifier(bodySection)\n          )}`;\n        }\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML.exit(tag);\n      } else {\n        translateDOM.exit(tag);\n      }\n    }\n  },\n  attributes: {\n    of: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over a list of items.\"\n        }\n      ]\n    },\n    in: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over the keys and values of an object.\"\n        }\n      ]\n    },\n    to: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates up to the provided number (inclusive)\"\n        }\n      ]\n    },\n    from: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates starting from the provided number (inclusive)\"\n        }\n      ]\n    },\n    step: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"The amount to increment during each interation (with from/to)\"\n        }\n      ]\n    }\n  },\n  autocomplete: [\n    {\n      snippet: \"for|${1:value, index}| of=${3:array}\",\n      description: \"Use to iterate over lists, object properties, or between ranges.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-a-list\"\n    },\n    {\n      snippet: \"for|${1:name, value}| in=${3:object}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties\"\n    },\n    {\n      snippet: \"for|${1:index}| from=${2:number} to=${3:number} step=${4:number}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers\"\n    }\n  ]\n};\nvar translateDOM = {\n  exit(tag) {\n    const tagBody = tag.get(\"body\");\n    const tagSection = getSection(tag);\n    const bodySection = getSection(tagBody);\n    const { node } = tag;\n    const { attributes } = node;\n    const { isOnlyChild, referencedBindings } = node.extra;\n    const nodeRef = isOnlyChild ? tag.parentPath.parent.extra[kNativeTagBinding] : tag.node.extra[kForMarkerBinding];\n    setSubscriberBuilder(tag, (signal2) => {\n      return callRuntime(\n        \"inLoopScope\",\n        signal2,\n        getScopeAccessorLiteral(nodeRef)\n      );\n    });\n    tag.remove();\n    const rendererId = import_compiler29.types.identifier(bodySection.name);\n    const ofAttr = findName(attributes, \"of\");\n    const toAttr = findName(attributes, \"to\");\n    const inAttr = findName(attributes, \"in\");\n    const loopArgs = [];\n    let loopKind;\n    if (ofAttr) {\n      loopKind = \"loopOf\";\n      loopArgs.push(ofAttr.value);\n    } else if (inAttr) {\n      loopKind = \"loopIn\";\n      loopArgs.push(inAttr.value);\n    } else if (toAttr) {\n      const fromAttr = findName(attributes, \"from\");\n      const stepAttr = findName(attributes, \"step\");\n      loopKind = \"loopTo\";\n      loopArgs.push(\n        toAttr.value,\n        fromAttr ? fromAttr.value : import_compiler29.types.numericLiteral(0),\n        stepAttr ? stepAttr.value : import_compiler29.types.numericLiteral(1)\n      );\n    } else {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"Invalid <for> tag. Expected either an 'of', 'to', or 'in' attribute.\"\n      );\n    }\n    const byAttr = findName(attributes, \"by\");\n    if (byAttr) {\n      loopArgs.push(byAttr.value);\n    }\n    const signal = getSignal(tagSection, nodeRef, \"for\");\n    signal.build = () => {\n      return callRuntime(\n        loopKind,\n        getScopeAccessorLiteral(nodeRef),\n        rendererId\n      );\n    };\n    const paramIdentifiers = Object.values(\n      tagBody.getBindingIdentifiers()\n    );\n    signal.hasDownstreamIntersections = () => {\n      if (getClosures(bodySection).length > 0) {\n        return true;\n      }\n      if (paramIdentifiers.length) {\n        const binding = paramIdentifiers[0].extra.binding;\n        for (const { referencedBindings: referencedBindings2 } of binding.downstreamExpressions) {\n          if (getSignal(\n            bodySection,\n            referencedBindings2\n          ).hasDownstreamIntersections()) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    addValue(\n      tagSection,\n      referencedBindings,\n      signal,\n      import_compiler29.types.arrayExpression(loopArgs)\n    );\n  }\n};\nvar translateHTML = {\n  exit(tag) {\n    const tagBody = tag.get(\"body\");\n    const tagSection = getSection(tag);\n    const bodySection = getSection(tagBody);\n    const { node } = tag;\n    const {\n      attributes,\n      body: { body, params }\n    } = node;\n    const tagExtra = node.extra;\n    const { singleNodeOptimization, isOnlyChild } = tagExtra;\n    const isStateful = isStatefulReferences(tagExtra.referencedBindings);\n    const hasNestedAttributeTags = tagExtra.nestedAttributeTags && Object.keys(tagExtra.nestedAttributeTags).length > 0;\n    const nodeRef = isOnlyChild ? tag.parentPath.parent.extra[kNativeTagBinding] : tag.node.extra[kForMarkerBinding];\n    const namePath = tag.get(\"name\");\n    const ofAttr = findName(attributes, \"of\");\n    const inAttr = findName(attributes, \"in\");\n    const toAttr = findName(attributes, \"to\");\n    const byAttr = findName(attributes, \"by\");\n    const block = import_compiler29.types.blockStatement(body);\n    const write2 = writeTo(tag);\n    const replacement = [];\n    const hasStatefulClosures = checkStatefulClosures(bodySection, true);\n    let byParams;\n    let keyExpression = import_compiler29.types.identifier(\"NOO\");\n    if (isStateful && isOnlyChild) {\n      tag.parentPath.parent.extra[kSerializeMarker] = true;\n    }\n    if (isStateful || hasStatefulClosures) {\n      setForceResumeScope(bodySection);\n    }\n    if (byAttr && isStateful) {\n      const byIdentifier = currentProgramPath.scope.generateUidIdentifier(\"by\");\n      replacement.push(\n        import_compiler29.types.variableDeclaration(\"const\", [\n          import_compiler29.types.variableDeclarator(byIdentifier, byAttr.value)\n        ])\n      );\n      byParams = [];\n      keyExpression = import_compiler29.types.callExpression(byIdentifier, byParams);\n    }\n    if (inAttr) {\n      const [keyParam, valParam] = params;\n      keyExpression = keyParam;\n      if (valParam) {\n        block.body.unshift(\n          import_compiler29.types.variableDeclaration(\"const\", [\n            import_compiler29.types.variableDeclarator(\n              valParam,\n              import_compiler29.types.memberExpression(inAttr.value, keyParam, true)\n            )\n          ])\n        );\n      }\n      replacement.push(\n        import_compiler29.types.forInStatement(\n          import_compiler29.types.variableDeclaration(\"const\", [import_compiler29.types.variableDeclarator(keyParam)]),\n          inAttr.value,\n          block\n        )\n      );\n    } else if (ofAttr) {\n      let ofAttrValue = ofAttr.value;\n      let [valParam, indexParam, loopParam] = params;\n      if (!valParam) {\n        throw namePath.buildCodeFrameError(\n          \"Invalid 'for of' tag, missing |value, index| params.\"\n        );\n      }\n      if (!import_compiler29.types.isIdentifier(valParam) && byParams) {\n        const tempValParam = currentProgramPath.scope.generateUidIdentifier(\"v\");\n        block.body.unshift(\n          import_compiler29.types.variableDeclaration(\"const\", [\n            import_compiler29.types.variableDeclarator(valParam, tempValParam)\n          ])\n        );\n        valParam = tempValParam;\n      }\n      if (indexParam || isStateful || hasStatefulClosures) {\n        indexParam ??= currentProgramPath.scope.generateUidIdentifier(\"i\");\n        const indexName = tag.scope.generateUidIdentifierBasedOnNode(\n          indexParam,\n          \"i\"\n        );\n        replacement.push(\n          import_compiler29.types.variableDeclaration(\"let\", [\n            import_compiler29.types.variableDeclarator(indexName, import_compiler29.types.numericLiteral(0))\n          ])\n        );\n        block.body.unshift(\n          import_compiler29.types.variableDeclaration(\"let\", [\n            import_compiler29.types.variableDeclarator(\n              indexParam,\n              import_compiler29.types.updateExpression(\"++\", indexName)\n            )\n          ])\n        );\n      }\n      if (loopParam) {\n        if (import_compiler29.types.isIdentifier(loopParam)) {\n          ofAttrValue = loopParam;\n        }\n        replacement.push(\n          import_compiler29.types.variableDeclaration(\"const\", [\n            import_compiler29.types.variableDeclarator(loopParam, ofAttr.value)\n          ])\n        );\n      }\n      if (byParams) {\n        byParams.push(valParam, indexParam);\n      } else {\n        keyExpression = indexParam;\n      }\n      replacement.push(\n        import_compiler29.types.forOfStatement(\n          import_compiler29.types.variableDeclaration(\"const\", [import_compiler29.types.variableDeclarator(valParam)]),\n          ofAttrValue,\n          block\n        )\n      );\n    } else if (toAttr) {\n      const stepValue = findName(attributes, \"step\")?.value ?? import_compiler29.types.numericLiteral(1);\n      const fromValue = findName(attributes, \"from\")?.value ?? import_compiler29.types.numericLiteral(0);\n      let [indexParam] = params;\n      const stepsName = tag.scope.generateUidIdentifier(\"steps\");\n      const indexName = tag.scope.generateUidIdentifier(\"i\");\n      const stepName = tag.scope.generateUidIdentifier(\"step\");\n      const fromName = tag.scope.generateUidIdentifier(\"from\");\n      if (indexParam || isStateful || hasStatefulClosures) {\n        indexParam ??= currentProgramPath.scope.generateUidIdentifier(\"i\");\n        keyExpression = indexParam;\n        block.body.unshift(\n          import_compiler29.types.variableDeclaration(\"const\", [\n            import_compiler29.types.variableDeclarator(\n              indexParam,\n              import_compiler29.types.binaryExpression(\n                \"+\",\n                fromName,\n                import_compiler29.types.binaryExpression(\"*\", indexName, stepName)\n              )\n            )\n          ])\n        );\n      }\n      replacement.push(\n        import_compiler29.types.forStatement(\n          import_compiler29.types.variableDeclaration(\"let\", [\n            import_compiler29.types.variableDeclarator(\n              fromName,\n              import_compiler29.types.logicalExpression(\"??\", fromValue, import_compiler29.types.numericLiteral(0))\n            ),\n            import_compiler29.types.variableDeclarator(\n              stepName,\n              import_compiler29.types.logicalExpression(\"??\", stepValue, import_compiler29.types.numericLiteral(1))\n            ),\n            import_compiler29.types.variableDeclarator(\n              stepsName,\n              import_compiler29.types.binaryExpression(\n                \"/\",\n                import_compiler29.types.binaryExpression(\"-\", toAttr.value, fromName),\n                stepName\n              )\n            ),\n            import_compiler29.types.variableDeclarator(indexName, import_compiler29.types.numericLiteral(0))\n          ]),\n          import_compiler29.types.binaryExpression(\"<=\", indexName, stepsName),\n          import_compiler29.types.updateExpression(\"++\", indexName),\n          block\n        )\n      );\n    }\n    if ((isStateful || hasStatefulClosures) && !hasNestedAttributeTags) {\n      const forScopeIdsIdentifier = tag.scope.generateUidIdentifier(\"forScopeIds\");\n      const forScopesIdentifier = getScopeIdentifier(bodySection);\n      replacement.unshift(\n        import_compiler29.types.variableDeclaration(\n          \"const\",\n          [\n            isStateful && singleNodeOptimization && import_compiler29.types.variableDeclarator(\n              forScopeIdsIdentifier,\n              import_compiler29.types.arrayExpression([])\n            ),\n            import_compiler29.types.variableDeclarator(\n              forScopesIdentifier,\n              import_compiler29.types.newExpression(import_compiler29.types.identifier(\"Map\"), [])\n            )\n          ].filter(Boolean)\n        )\n      );\n      if (isStateful) {\n        if (singleNodeOptimization) {\n          block.body.push(\n            import_compiler29.types.expressionStatement(\n              import_compiler29.types.callExpression(\n                import_compiler29.types.memberExpression(forScopeIdsIdentifier, import_compiler29.types.identifier(\"push\")),\n                [getScopeIdIdentifier(bodySection)]\n              )\n            )\n          );\n          write2`${callRuntime(\n            \"markResumeControlSingleNodeEnd\",\n            getScopeIdIdentifier(tagSection),\n            getScopeAccessorLiteral(nodeRef),\n            forScopeIdsIdentifier\n          )}`;\n        } else {\n          write2`${callRuntime(\n            \"markResumeControlEnd\",\n            getScopeIdIdentifier(tagSection),\n            getScopeAccessorLiteral(nodeRef)\n          )}`;\n        }\n      }\n      getSerializedScopeProperties(tagSection).set(\n        import_compiler29.types.stringLiteral(\n          getScopeAccessorLiteral(nodeRef).value + \"(\" /* LoopScopeMap */\n        ),\n        import_compiler29.types.conditionalExpression(\n          import_compiler29.types.memberExpression(forScopesIdentifier, import_compiler29.types.identifier(\"size\")),\n          forScopesIdentifier,\n          import_compiler29.types.identifier(\"undefined\")\n        )\n      );\n    }\n    flushInto(tag);\n    setSubscriberBuilder(tag, () => {\n    });\n    writeHTMLResumeStatements(tagBody);\n    if (isStateful || hasStatefulClosures) {\n      tag.node.body.body.push(\n        import_compiler29.types.expressionStatement(\n          import_compiler29.types.callExpression(\n            import_compiler29.types.memberExpression(\n              getScopeIdentifier(bodySection),\n              import_compiler29.types.identifier(\"set\")\n            ),\n            [\n              keyExpression,\n              callRuntime(\"getScopeById\", getScopeIdIdentifier(bodySection))\n            ]\n          )\n        )\n      );\n    }\n    block.body.push(import_compiler29.types.expressionStatement(callRuntime(\"maybeFlush\")));\n    tag.replaceWithMultiple(replacement);\n  }\n};\nfunction findName(arr, value) {\n  return arr.find((obj) => import_compiler29.types.isMarkoAttribute(obj) && obj.name === value);\n}\nfunction validateFor(tag) {\n  const attrs2 = tag.node.attributes;\n  const hasParams = tag.node.body.params.length > 0;\n  (0, import_babel_utils25.assertNoVar)(tag);\n  if (findName(attrs2, \"of\")) {\n    (0, import_babel_utils25.assertAllowedAttributes)(tag, [\"of\", \"by\"]);\n    if (!hasParams) {\n      throw tag.buildCodeFrameError(\n        `Invalid 'for of' tag, missing |value, index| params.`\n      );\n    }\n  } else if (findName(attrs2, \"in\")) {\n    (0, import_babel_utils25.assertAllowedAttributes)(tag, [\"in\", \"by\"]);\n    if (!hasParams) {\n      throw tag.buildCodeFrameError(\n        `Invalid 'for in' tag, missing |key, value| params.`\n      );\n    }\n  } else if (findName(attrs2, \"to\")) {\n    (0, import_babel_utils25.assertAllowedAttributes)(tag, [\"from\", \"to\", \"step\", \"by\"]);\n  } else {\n    throw tag.buildCodeFrameError(\n      \"Invalid 'for' tag, missing an 'of', 'in' or 'to' attribute.\"\n    );\n  }\n}\nfunction checkOnlyChild(tag) {\n  const extra = tag.node.extra;\n  if (import_compiler29.types.isMarkoTag(tag.parentPath?.parent) && (0, import_babel_utils25.getTagDef)(tag.parentPath.parentPath)?.html) {\n    return extra.isOnlyChild = tag.parent.body.length === 1;\n  }\n  return extra.isOnlyChild = false;\n}\n\n// src/core/html-comment.ts\nvar import_babel_utils26 = require(\"@marko/babel-utils\");\nvar import_compiler30 = require(\"@marko/compiler\");\nvar kCommentTagBinding = Symbol(\"comment tag binding\");\nvar html_comment_default = {\n  analyze(tag) {\n    (0, import_babel_utils26.assertNoParams)(tag);\n    (0, import_babel_utils26.assertNoAttributes)(tag);\n    (0, import_babel_utils26.assertNoAttributeTags)(tag);\n    let needsBinding = false;\n    if (tag.has(\"var\")) {\n      if (!import_compiler30.types.isIdentifier(tag.node.var)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"The `<html-comment>` tag's return value cannot be destructured.\"\n        );\n      }\n      needsBinding = true;\n    }\n    const referenceNodes = [];\n    for (const child of tag.get(\"body\").get(\"body\")) {\n      if (child.isMarkoPlaceholder()) {\n        referenceNodes.push(child.node.value);\n        needsBinding = true;\n      } else if (!child.isMarkoText()) {\n        throw child.buildCodeFrameError(\n          \"Invalid child. Only text is allowed inside an html comment.\"\n        );\n      }\n    }\n    if (needsBinding) {\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      tagExtra[kCommentTagBinding] = createBinding(\n        \"#comment\",\n        0 /* dom */,\n        section\n      );\n      mergeReferences(tag, referenceNodes);\n    }\n    tag.skip();\n  },\n  translate: {\n    enter(tag) {\n      const tagExtra = tag.node.extra;\n      const commentBinding = tagExtra[kCommentTagBinding];\n      if (tag.has(\"var\")) {\n        if (isOutputHTML()) {\n          translateVar(\n            tag,\n            import_compiler30.types.arrowFunctionExpression(\n              [],\n              import_compiler30.types.blockStatement([\n                import_compiler30.types.throwStatement(\n                  import_compiler30.types.newExpression(import_compiler30.types.identifier(\"Error\"), [\n                    import_compiler30.types.stringLiteral(\n                      \"Cannot reference a DOM node from the server\"\n                    )\n                  ])\n                )\n              ])\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let createElFunction = void 0;\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (reference.parentPath?.isCallExpression()) {\n              reference.parentPath.replaceWith(\n                import_compiler30.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, commentBinding)\n                )\n              );\n            } else {\n              createElFunction ??= import_compiler30.types.identifier(varName + \"_getter\");\n              reference.replaceWith(\n                callRuntime(\n                  \"bindFunction\",\n                  getScopeExpression(referenceSection, getSection(tag)),\n                  createElFunction\n                )\n              );\n            }\n          }\n          if (createElFunction) {\n            currentProgramPath.pushContainer(\n              \"body\",\n              import_compiler30.types.variableDeclaration(\"const\", [\n                import_compiler30.types.variableDeclarator(\n                  createElFunction,\n                  import_compiler30.types.arrowFunctionExpression(\n                    [scopeIdentifier],\n                    import_compiler30.types.memberExpression(\n                      scopeIdentifier,\n                      getScopeAccessorLiteral(commentBinding),\n                      true\n                    )\n                  )\n                )\n              ])\n            );\n          }\n        }\n      }\n      if (tagExtra[kCommentTagBinding]) {\n        visit(tag, 32 /* Get */);\n      }\n      const write2 = writeTo(tag);\n      enter(tag);\n      write2`<!--`;\n      if (isOutputHTML()) {\n        for (const child of tag.node.body.body) {\n          if (import_compiler30.types.isMarkoText(child)) {\n            write2`${child.value}`;\n          } else if (import_compiler30.types.isMarkoPlaceholder(child)) {\n            write2`${callRuntime(\"escapeXML\", child.value)}`;\n          }\n        }\n      } else {\n        const templateQuasis = [];\n        const templateExpressions = [];\n        let currentQuasi = \"\";\n        for (const child of tag.node.body.body) {\n          if (import_compiler30.types.isMarkoText(child)) {\n            currentQuasi += child.value;\n          } else if (import_compiler30.types.isMarkoPlaceholder(child)) {\n            templateQuasis.push(import_compiler30.types.templateElement({ raw: currentQuasi }));\n            templateExpressions.push(child.value);\n            currentQuasi = \"\";\n          }\n        }\n        if (templateExpressions.length === 0) {\n          write2`${currentQuasi}`;\n        } else {\n          templateQuasis.push(import_compiler30.types.templateElement({ raw: currentQuasi }));\n          addStatement(\n            \"render\",\n            getSection(tag),\n            tagExtra.referencedBindings,\n            import_compiler30.types.expressionStatement(\n              callRuntime(\n                \"data\",\n                import_compiler30.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(commentBinding),\n                  true\n                ),\n                import_compiler30.types.templateLiteral(templateQuasis, templateExpressions)\n              )\n            )\n          );\n        }\n      }\n      exit(tag);\n      write2`-->`;\n      if (commentBinding) {\n        markNode(tag, commentBinding);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    // TODO: fix the types for Tag or parseOptions or something\n    text: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an html comment that is not stripped from the output.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#html-comment\"\n    }\n  ]\n};\n\n// src/core/id.ts\nvar import_babel_utils27 = require(\"@marko/babel-utils\");\nvar import_compiler31 = require(\"@marko/compiler\");\nvar id_default = {\n  translate(tag) {\n    const { node } = tag;\n    const { var: tagVar } = node;\n    const id = callRuntime(\"nextTagId\");\n    (0, import_babel_utils27.assertNoArgs)(tag);\n    (0, import_babel_utils27.assertNoAttributes)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils27.assertNoParams)(tag);\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'id' tag requires a tag variable.\");\n    }\n    if (!import_compiler31.types.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The 'id' tag cannot be destructured\");\n    }\n    if (isOutputHTML()) {\n      tag.replaceWith(\n        import_compiler31.types.variableDeclaration(\"const\", [import_compiler31.types.variableDeclarator(node.var, id)])\n      );\n    } else {\n      const source = initValue(tagVar.extra.binding);\n      addValue(getSection(tag), void 0, source, id);\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"id/<name>\",\n      description: \"Use to create a unique identifier.\",\n      snippet: \"id/${1:name}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#id\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/id.d.marko\"\n};\n\n// src/core/import.ts\nvar import_babel_utils28 = require(\"@marko/babel-utils\");\nvar import_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils28.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: 'import <scope> from \"<path>\"',\n      description: \"Use to import external modules, follows the same syntax as JavaScript imports.\",\n      snippet: 'import ${2} from \"${1:path}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#importing-external-files\"\n    }\n  ]\n};\n\n// src/core/let.ts\nvar import_babel_utils29 = require(\"@marko/babel-utils\");\nvar import_compiler32 = require(\"@marko/compiler\");\n\n// src/util/replace-assignments.ts\nvar assignmentGeneratorMaps = /* @__PURE__ */ new WeakMap();\nfunction getAssignmentGenerator(assignment, identifier) {\n  return assignmentGeneratorMaps.get(assignment.node)?.[identifier];\n}\nfunction registerAssignmentGenerator(binding, map) {\n  for (const assignment of binding.constantViolations) {\n    let generatorMap = assignmentGeneratorMaps.get(assignment.node);\n    if (!generatorMap) {\n      generatorMap = {};\n      assignmentGeneratorMaps.set(assignment.node, generatorMap);\n    }\n    generatorMap[binding.identifier.name] = map;\n  }\n}\n\n// src/core/let.ts\nvar let_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    const valueAttr = node.attributes.find(\n      (attr2) => import_compiler32.types.isMarkoAttribute(attr2) && attr2.name === \"value\"\n    );\n    (0, import_babel_utils29.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!tagVar) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'let' tag requires a tag variable.\");\n    }\n    if (!import_compiler32.types.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The 'let' cannot be destructured.\");\n    }\n    const upstreamExpressionExtra = valueAttr ? valueAttr.value.extra ??= {} : void 0;\n    trackVarReferences(\n      tag,\n      1 /* let */,\n      void 0,\n      upstreamExpressionExtra\n    );\n  },\n  translate(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    const valueAttr = node.attributes.find(\n      (attr2) => import_compiler32.types.isMarkoAttribute(attr2) && (attr2.default || attr2.name === \"value\")\n    ) ?? import_compiler32.types.markoAttribute(\"value\", import_compiler32.types.identifier(\"undefined\"));\n    if (isOutputDOM()) {\n      const section = getSection(tag);\n      const binding = tagVar.extra.binding;\n      const signal = initValue(binding);\n      const referencedBindings = valueAttr.value.extra?.referencedBindings;\n      const isSetup = !referencedBindings;\n      if (!isSetup) {\n        let initValueId;\n        addValue(\n          section,\n          referencedBindings,\n          {\n            get identifier() {\n              if (!initValueId) {\n                initValueId = tag.scope.generateUidIdentifier(\n                  signal.identifier.name + \"_init\"\n                );\n                currentProgramPath.pushContainer(\n                  \"body\",\n                  import_compiler32.types.variableDeclaration(\"const\", [\n                    import_compiler32.types.variableDeclarator(\n                      initValueId,\n                      callRuntime(\n                        \"initValue\",\n                        getScopeAccessorLiteral(binding),\n                        signal.identifier\n                      )\n                    )\n                  ])\n                );\n              }\n              return initValueId;\n            },\n            hasDownstreamIntersections() {\n              return signal.hasDownstreamIntersections();\n            }\n          },\n          valueAttr.value\n        );\n      } else {\n        addValue(section, referencedBindings, signal, valueAttr.value);\n      }\n      registerAssignmentGenerator(\n        tag.scope.getBinding(binding.name),\n        (assignment, value) => queueSource(signal, value, getSection(assignment))\n      );\n    } else {\n      translateVar(tag, valueAttr.value);\n    }\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a mutable binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#let\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/let.d.marko\"\n};\n\n// src/core/lifecycle.ts\nvar import_babel_utils30 = require(\"@marko/babel-utils\");\nvar import_compiler33 = require(\"@marko/compiler\");\nvar kRef = Symbol(\"lifecycle attrs reference\");\nvar lifecycle_default = {\n  analyze(tag) {\n    (0, import_babel_utils30.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const tagExtra = node.extra ??= {};\n    tagExtra[kRef] = createBinding(\n      tag.scope.generateUid(\"lifecycle\"),\n      4 /* derived */,\n      getOrCreateSection(tag),\n      void 0,\n      tagExtra\n    );\n    for (const attr2 of node.attributes) {\n      (attr2.value.extra ??= {}).isEffect = true;\n    }\n    (currentProgramPath.node.extra ??= {}).isInteractive = true;\n    mergeReferences(\n      tag,\n      tag.node.attributes.map((attr2) => attr2.value)\n    );\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const section = getSection(tag);\n      const tagExtra = node.extra;\n      const { referencedBindings } = tagExtra;\n      const lifecycleAttrsRef = tagExtra[kRef];\n      if (isOutputDOM()) {\n        const attrsObject = attrsToObject(tag);\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          import_compiler33.types.expressionStatement(\n            callRuntime(\n              \"lifecycle\",\n              scopeIdentifier,\n              getScopeAccessorLiteral(lifecycleAttrsRef),\n              attrsObject\n            )\n          ),\n          node.attributes.map((a) => a.value)\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/lifecycle.d.marko\"\n};\n\n// src/core/log.ts\nvar import_babel_utils31 = require(\"@marko/babel-utils\");\nvar import_compiler34 = require(\"@marko/compiler\");\nvar log_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils31.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The 'log' tag requires a 'value' attribute.\");\n    }\n    if (tag.node.attributes.length > 1 || !import_compiler34.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The 'log' tag only supports the 'value' attribute.\"\n      );\n    }\n  },\n  translate(tag) {\n    const section = getSection(tag);\n    const [valueAttr] = tag.node.attributes;\n    const { value } = valueAttr;\n    const referencedBindings = value.extra?.referencedBindings;\n    const statement = import_compiler34.types.expressionStatement(\n      import_compiler34.types.callExpression(\n        import_compiler34.types.memberExpression(import_compiler34.types.identifier(\"console\"), import_compiler34.types.identifier(\"log\")),\n        [value]\n      )\n    );\n    if (isOutputHTML()) {\n      tag.insertBefore(statement);\n    } else {\n      addStatement(\"render\", section, referencedBindings, statement);\n    }\n    tag.remove();\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to log a value to the console.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#log\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/log.d.marko\"\n};\n\n// src/core/noop.ts\nvar noop_default = {\n  migrate: [(tag) => tag.remove()]\n};\n\n// src/core/server.ts\nvar import_babel_utils32 = require(\"@marko/babel-utils\");\nvar import_compiler35 = require(\"@marko/compiler\");\nvar server_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^server\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils32.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler35.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler35.types.markoScriptlet(body, true, \"server\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"server <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the server.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#server-javascript\"\n    }\n  ]\n};\n\n// src/core/static.ts\nvar import_babel_utils33 = require(\"@marko/babel-utils\");\nvar import_compiler36 = require(\"@marko/compiler\");\nvar static_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^static\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils33.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler36.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler36.types.markoScriptlet(body, true));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"static <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#static-javascript\"\n    }\n  ]\n};\n\n// src/core/style.ts\nvar import_path2 = __toESM(require(\"path\"));\nvar import_babel_utils34 = require(\"@marko/babel-utils\");\nvar import_compiler37 = require(\"@marko/compiler\");\nvar style_default = {\n  translate(tag) {\n    const {\n      hub: { file }\n    } = tag;\n    (0, import_babel_utils34.assertNoParams)(tag);\n    assertNoSpreadAttrs(tag);\n    let type = \"text/css\";\n    const attrs2 = tag.get(\"attributes\");\n    const base = import_path2.default.basename(file.opts.sourceFileName);\n    const typeAttr = attrs2.find(\n      (attr2) => attr2.isMarkoAttribute() && attr2.node.name === \"type\"\n    );\n    const classAttr2 = attrs2.find(\n      (attr2) => attr2.isMarkoAttribute() && attr2.node.name === \"class\"\n    );\n    if (typeAttr && classAttr2) {\n      throw classAttr2.buildCodeFrameError(\n        `<style> must only use \"type\" or \"class\" and not both.`\n      );\n    } else if (typeAttr) {\n      const typeValue = typeAttr.get(\"value\");\n      if (typeValue.isStringLiteral()) {\n        type = typeValue.node.value;\n      } else {\n        throw typeValue.buildCodeFrameError(\n          `<style> \"type\" attribute can only be a string literal.`\n        );\n      }\n    } else if (classAttr2) {\n      const classValue2 = classAttr2.get(\"value\");\n      if (classValue2.isStringLiteral()) {\n        type = classValue2.node.value;\n      } else {\n        throw classValue2.buildCodeFrameError(\n          `<style> \"class\" attribute can only be a string literal.`\n        );\n      }\n    }\n    if (type === \"text/css\") {\n      type = \"css\";\n    }\n    if (tag.node.var && !type.startsWith(\"module\")) {\n      type = \"module.\" + type;\n    }\n    const body = tag.get(\"body\").get(\"body\");\n    const markoText = body[0];\n    if (body.length !== 1 || !markoText.isMarkoText()) {\n      throw (markoText.isMarkoText() ? body[1] : body[0]).buildCodeFrameError(\n        \"The '<style>' tag currently only supports static content.\"\n      );\n    }\n    const { resolveVirtualDependency } = getMarkoOpts();\n    if (resolveVirtualDependency) {\n      const importPath = resolveVirtualDependency(\n        file.opts.filename,\n        {\n          type,\n          code: markoText.node.value,\n          startPos: markoText.node.start,\n          endPos: markoText.node.end,\n          path: `./${base}`,\n          virtualPath: `./${base}.${type}`\n        }\n      );\n      if (!tag.node.var) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler37.types.importDeclaration([], import_compiler37.types.stringLiteral(importPath))\n        );\n      } else if (import_compiler37.types.isIdentifier(tag.node.var)) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler37.types.importDeclaration(\n            [import_compiler37.types.importDefaultSpecifier(tag.node.var)],\n            import_compiler37.types.stringLiteral(importPath)\n          )\n        );\n      } else {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler37.types.variableDeclaration(\"const\", [\n            import_compiler37.types.variableDeclarator(\n              tag.node.var,\n              (0, import_babel_utils34.importDefault)(file, importPath, \"style\")\n            )\n          ])\n        );\n      }\n    }\n    tag.remove();\n  },\n  attributes: {\n    type: { enum: [\"css\", \"less\", \"scss\", \"text/css\"] }\n  }\n};\n\n// src/core/index.ts\nvar core_default = {\n  taglibId,\n  \"<import>\": import_default,\n  \"<export>\": export_default,\n  \"<attrs>\": attrs_default,\n  \"<if>\": if_default,\n  \"<else-if>\": else_if_default,\n  \"<else>\": else_default,\n  \"<for>\": for_default,\n  \"<let>\": let_default,\n  \"<const>\": const_default,\n  \"<define>\": define_default,\n  \"<effect>\": effect_default,\n  \"<do>\": do_default,\n  \"<log>\": log_default,\n  \"<debug>\": debug_default,\n  \"<lifecycle>\": lifecycle_default,\n  \"<id>\": id_default,\n  \"<html-comment>\": html_comment_default,\n  \"<return>\": return_default,\n  \"<style>\": style_default,\n  \"<await-reorderer>\": noop_default,\n  \"<init-widgets>\": noop_default,\n  \"<init-components>\": noop_default,\n  \"<static>\": static_default,\n  \"<server>\": server_default,\n  \"<client>\": client_default,\n  \"<__flush_here_and_after__>\": flush_here_and_after_default\n};\n\n// src/visitors/assignment-expression.ts\nvar import_compiler38 = require(\"@marko/compiler\");\nvar assignment_expression_default = {\n  translate: {\n    exit(assignment) {\n      if (isOutputDOM()) {\n        if (assignment.node.left.type === \"ObjectPattern\" || assignment.node.left.type === \"ArrayPattern\") {\n          handleDestructure(assignment, assignment.node.left);\n        } else {\n          const generator = getAssignmentGenerator(\n            assignment,\n            assignment.node.left.name\n          );\n          if (generator) {\n            assignment.replaceWith(\n              generator(\n                assignment,\n                assignment.node.operator === \"=\" ? assignment.node.right : import_compiler38.types.binaryExpression(\n                  assignment.node.operator.slice(\n                    0,\n                    -1\n                  ),\n                  assignment.node.left,\n                  assignment.node.right\n                )\n              )\n            );\n          }\n        }\n      }\n    }\n  }\n};\nfunction handleDestructure(assignment, node, ctx, replace) {\n  if (!ctx) {\n    ctx = {\n      statement: assignment.getStatementParent(),\n      end: assignment.getStatementParent()\n    };\n  }\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        handleDestructure(assignment, prop, ctx);\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const i in node.elements) {\n        if (node.elements[i] === null)\n          continue;\n        handleDestructure(\n          assignment,\n          node.elements[i],\n          ctx,\n          (id) => node.elements[i] = id\n        );\n      }\n      break;\n    case \"RestElement\":\n      handleDestructure(\n        assignment,\n        node.argument,\n        ctx,\n        (id) => node.argument = id\n      );\n      break;\n    case \"ObjectProperty\":\n      handleDestructure(assignment, node.value, ctx, (id) => node.value = id);\n      break;\n    case \"Identifier\":\n      {\n        const generator = getAssignmentGenerator(assignment, node.name);\n        if (generator) {\n          const valueId = ctx.statement.scope.generateUidIdentifier(node.name);\n          ctx.statement.insertBefore(\n            import_compiler38.types.variableDeclaration(\"let\", [import_compiler38.types.variableDeclarator(valueId)])\n          );\n          replace?.(valueId);\n          [ctx.end] = ctx.end.insertAfter(\n            import_compiler38.types.expressionStatement(generator(ctx.statement, valueId))\n          );\n        }\n      }\n      break;\n  }\n}\n\n// src/visitors/cdata.ts\nvar cdata_default = {\n  translate: {\n    exit(cdata) {\n      if (isOutputHTML()) {\n        writeTo(cdata)`<![CDATA[${cdata.node.value}]]>`;\n      }\n      cdata.remove();\n    }\n  }\n};\n\n// src/visitors/comment.ts\nvar comment_default = {\n  translate: {\n    exit(comment) {\n      comment.remove();\n    }\n  }\n};\n\n// src/visitors/declaration.ts\nvar declaration_default = {\n  translate: {\n    exit(declaration) {\n      if (isOutputHTML()) {\n        writeTo(declaration)`<?${declaration.node.value}?>`;\n      }\n      declaration.remove();\n    }\n  }\n};\n\n// src/visitors/document-type.ts\nvar document_type_default = {\n  translate: {\n    exit(documentType) {\n      if (isOutputHTML()) {\n        writeTo(documentType)`<!${documentType.node.value}>`;\n      }\n      documentType.remove();\n    }\n  }\n};\n\n// src/visitors/function.ts\nvar import_babel_utils35 = require(\"@marko/babel-utils\");\nvar import_compiler39 = require(\"@marko/compiler\");\nvar functionIdsBySection = /* @__PURE__ */ new WeakMap();\nvar function_default = {\n  analyze(fn) {\n    const { node } = fn;\n    const extra = node.extra ??= {};\n    const {\n      markoOpts,\n      opts: { filename }\n    } = currentProgramPath.hub.file;\n    const section = getSection(fn);\n    let functionNameCounts = functionIdsBySection.get(section);\n    if (!functionNameCounts) {\n      functionNameCounts = /* @__PURE__ */ new Map();\n      functionIdsBySection.set(section, functionNameCounts);\n    }\n    let name = extra.name;\n    if (name === void 0) {\n      const markoRoot = fn.parentPath;\n      if (markoRoot.isMarkoAttribute()) {\n        name = markoRoot.node.default ? import_compiler39.types.toIdentifier(\n          markoRoot.parentPath.parentPath.get(\n            \"name\"\n          )\n        ) : markoRoot.node.name;\n      } else {\n        name = \"anonymous\";\n      }\n      extra.name = name;\n    }\n    const index = functionNameCounts.get(name);\n    let id = \"\";\n    if (index === void 0) {\n      functionNameCounts.set(name, 0);\n    } else {\n      id = `_${index}`;\n    }\n    extra.registerId = (0, import_babel_utils35.getTemplateId)(\n      markoOpts,\n      `${filename}_${section.id}/${name + id}`\n    );\n  }\n};\n\n// src/visitors/import-declaration.ts\nvar import_babel_utils36 = require(\"@marko/babel-utils\");\nvar import_declaration_default = {\n  analyze(importDecl) {\n    const { node } = importDecl;\n    const { source } = node;\n    const { value } = source;\n    const tagImport = (0, import_babel_utils36.resolveTagImport)(importDecl, value);\n    if (tagImport) {\n      node.extra ??= {};\n      node.extra.tagImport = tagImport;\n      const tags = importDecl.hub.file.metadata.marko.tags;\n      if (!tags.includes(tagImport)) {\n        tags.push(tagImport);\n      }\n    }\n  },\n  translate: {\n    exit(importDecl) {\n      const { node } = importDecl;\n      const { extra } = node;\n      const tagImport = extra?.tagImport;\n      if (tagImport) {\n        node.source.value = tagImport;\n      }\n    }\n  }\n};\n\n// src/visitors/placeholder.ts\nvar import_babel_utils37 = require(\"@marko/babel-utils\");\nvar import_compiler40 = require(\"@marko/compiler\");\nvar kBinding2 = Symbol(\"placeholder node binding\");\nvar kSiblingText = Symbol(\"placeholder has sibling text\");\nvar ESCAPE_TYPES = {\n  script: \"escapeScript\",\n  style: \"escapeStyle\"\n};\nvar placeholder_default = {\n  analyze(placeholder) {\n    const { node } = placeholder;\n    const { confident, computed } = evaluate(placeholder);\n    if (!(confident && (node.escape || !computed))) {\n      (node.extra ??= {})[kBinding2] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        getOrCreateSection(placeholder),\n        void 0,\n        node.value.extra\n      );\n      analyzeSiblingText(placeholder);\n    }\n  },\n  translate: {\n    exit(placeholder) {\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(placeholder);\n      const { node } = placeholder;\n      const { value } = node;\n      const extra = node.extra;\n      const { confident, computed } = extra;\n      const nodeBinding = extra[kBinding2];\n      const canWriteHTML = isHTML || confident && (node.escape || !computed);\n      const method = canWriteHTML ? node.escape ? ESCAPE_TYPES[getParentTagName(placeholder)] || \"escapeXML\" : \"toString\" : node.escape ? \"data\" : \"html\";\n      const isStateful = isStatefulReferences(value.extra?.referencedBindings);\n      const siblingText = extra[kSiblingText];\n      if (confident && canWriteHTML) {\n        write2`${getHTMLRuntime()[method](computed)}`;\n      } else {\n        if (siblingText === 1 /* Before */) {\n          if (isHTML && isStateful) {\n            write2`<!>`;\n          }\n          visit(placeholder, 37 /* Replace */);\n        } else if (siblingText === 2 /* After */) {\n          visit(placeholder, 37 /* Replace */);\n        } else {\n          if (!isHTML)\n            write2` `;\n          visit(placeholder, 32 /* Get */);\n        }\n        if (isHTML) {\n          write2`${callRuntime(method, value)}`;\n          if (isStateful) {\n            markNode(placeholder, nodeBinding);\n          }\n        } else {\n          addStatement(\n            \"render\",\n            getSection(placeholder),\n            value.extra?.referencedBindings,\n            import_compiler40.types.expressionStatement(\n              method === \"data\" ? callRuntime(\n                \"data\",\n                import_compiler40.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(nodeBinding),\n                  true\n                ),\n                value\n              ) : callRuntime(\n                \"html\",\n                scopeIdentifier,\n                value,\n                getScopeAccessorLiteral(nodeBinding)\n              )\n            )\n          );\n        }\n      }\n      enterShallow(placeholder);\n      placeholder.remove();\n    }\n  }\n};\nfunction getParentTagName({ parentPath }) {\n  return parentPath.isMarkoTag() && (0, import_babel_utils37.isNativeTag)(parentPath) && parentPath.node.name.value || \"\";\n}\nfunction analyzeSiblingText(placeholder) {\n  const placeholderExtra = placeholder.node.extra;\n  let prev = placeholder.getPrevSibling();\n  while (prev.node) {\n    const contentType = getNodeContentType(\n      prev,\n      \"endNodeContentType\"\n    );\n    if (contentType === 2 /* Empty */) {\n      prev = prev.getPrevSibling();\n    } else if (contentType === 5 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 3 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 1 /* Before */;\n    } else {\n      break;\n    }\n  }\n  if (!prev.node && import_compiler40.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 1 /* Before */;\n  }\n  let next = placeholder.getNextSibling();\n  while (next.node) {\n    const contentType = getNodeContentType(\n      next,\n      \"startNodeContentType\"\n    );\n    if (contentType === 2 /* Empty */) {\n      next = next.getNextSibling();\n    } else if (contentType === 5 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 3 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 2 /* After */;\n    } else {\n      break;\n    }\n  }\n  if (!next.node && import_compiler40.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 2 /* After */;\n  }\n  return placeholderExtra[kSiblingText] = 0 /* None */;\n}\n\n// src/visitors/referenced-identifier.ts\nvar import_compiler41 = require(\"@marko/compiler\");\nvar abortIdsByExpressionForSection = /* @__PURE__ */ new WeakMap();\nvar referenced_identifier_default = {\n  migrate(identifier) {\n    const { name } = identifier.node;\n    if (identifier.scope.hasBinding(name))\n      return;\n    switch (name) {\n      case \"out\":\n        if (import_compiler41.types.isMemberExpression(identifier.parent) && import_compiler41.types.isIdentifier(identifier.parent.property) && identifier.parent.property.name === \"global\") {\n          identifier.parentPath.replaceWith(import_compiler41.types.identifier(\"$global\"));\n        } else {\n          throw identifier.buildCodeFrameError(\n            \"Only out.global is supported for compatibility.\"\n          );\n        }\n        break;\n    }\n  },\n  translate(identifier) {\n    const { name } = identifier.node;\n    if (identifier.scope.hasBinding(name))\n      return;\n    switch (name) {\n      case \"$global\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler41.types.memberExpression(\n              import_compiler41.types.callExpression(importRuntime(\"getStreamData\"), []),\n              import_compiler41.types.identifier(\"global\")\n            )\n          );\n        } else {\n          identifier.replaceWith(\n            import_compiler41.types.memberExpression(scopeIdentifier, import_compiler41.types.identifier(\"$global\"))\n          );\n        }\n        break;\n      case \"$signal\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler41.types.callExpression(\n              import_compiler41.types.arrowFunctionExpression(\n                [],\n                import_compiler41.types.blockStatement([\n                  import_compiler41.types.throwStatement(\n                    import_compiler41.types.newExpression(import_compiler41.types.identifier(\"Error\"), [\n                      import_compiler41.types.stringLiteral(\"Cannot use $signal in a server render.\")\n                    ])\n                  )\n                ])\n              ),\n              []\n            )\n          );\n        } else {\n          const section = getSection(identifier);\n          const exprRoot = getExprRoot(identifier);\n          let abortIdsByExpression = abortIdsByExpressionForSection.get(section);\n          let exprId;\n          if (abortIdsByExpression) {\n            exprId = abortIdsByExpression.get(exprRoot);\n          } else {\n            abortIdsByExpression = /* @__PURE__ */ new Map();\n            abortIdsByExpressionForSection.set(section, abortIdsByExpression);\n          }\n          if (!exprId) {\n            exprId = abortIdsByExpression.size;\n            abortIdsByExpression.set(exprRoot, exprId);\n            addStatement(\n              \"render\",\n              section,\n              exprRoot.node.extra?.referencedBindings,\n              import_compiler41.types.expressionStatement(\n                import_compiler41.types.callExpression(importRuntime(\"resetAbortSignal\"), [\n                  scopeIdentifier,\n                  import_compiler41.types.numericLiteral(exprId)\n                ])\n              )\n            );\n          }\n          identifier.replaceWith(\n            import_compiler41.types.callExpression(importRuntime(\"getAbortSignal\"), [\n              scopeIdentifier,\n              import_compiler41.types.numericLiteral(exprId)\n            ])\n          );\n        }\n    }\n  }\n};\n\n// src/visitors/scriptlet.ts\nvar scriptlet_default = {\n  analyze(scriptlet) {\n    mergeReferences(scriptlet, scriptlet.node.body);\n  },\n  translate: {\n    exit(scriptlet) {\n      const { node } = scriptlet;\n      if (isOutputHTML()) {\n        if (node.static)\n          return;\n        scriptlet.replaceWithMultiple(node.body);\n      } else {\n        if (node.target && node.target !== \"client\") {\n          scriptlet.remove();\n        } else if (node.static) {\n          scriptlet.replaceWithMultiple(node.body);\n        } else {\n          addStatement(\n            \"render\",\n            getSection(scriptlet),\n            node.extra?.referencedBindings,\n            node.body\n          );\n          scriptlet.remove();\n        }\n      }\n    }\n  }\n};\n\n// src/visitors/tag/index.ts\nvar import_babel_utils41 = require(\"@marko/babel-utils\");\nvar import_compiler47 = require(\"@marko/compiler\");\n\n// src/util/plugin-hooks.ts\nvar import_compiler42 = require(\"@marko/compiler\");\nfunction enter2(modulePlugin, path3) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path3;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (isFunctionPlugin(plugin)) {\n    plugin(path3, import_compiler42.types);\n  } else if (plugin.enter) {\n    plugin.enter(path3, import_compiler42.types);\n  }\n  return node !== path3.node;\n}\nfunction exit2(modulePlugin, path3) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path3;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (!isFunctionPlugin(plugin) && plugin.exit) {\n    plugin.exit(path3, import_compiler42.types);\n  }\n  return node !== path3.node;\n}\nfunction isModulePlugin(plugin) {\n  return Boolean(plugin.default);\n}\nfunction isFunctionPlugin(plugin) {\n  return typeof plugin === \"function\";\n}\n\n// src/visitors/tag/attribute-tag.ts\nvar import_babel_utils38 = require(\"@marko/babel-utils\");\nvar import_compiler43 = require(\"@marko/compiler\");\nvar attribute_tag_default = {\n  analyze: {\n    enter(tag) {\n      startSection(tag.get(\"body\"));\n    }\n  },\n  translate: {\n    enter(tag) {\n      (0, import_babel_utils38.assertNoArgs)(tag);\n      getSection(tag.get(\"body\"));\n      if (hasPendingHTML(tag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"Dynamic @tags cannot be mixed with body content.\"\n        );\n      }\n    },\n    exit(tag) {\n      (0, import_babel_utils38.assertNoVar)(tag);\n      flushInto(tag);\n      const parentTag = (0, import_babel_utils38.findParentTag)(tag);\n      if (!parentTag) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags must be nested within another tag.\");\n      }\n      const parentExtra = parentTag.node.extra;\n      if (parentExtra.tagNameType === 0 /* NativeTag */) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags cannot be nested under native tags.\");\n      }\n      const attrName = tag.node.name.value.slice(1);\n      const info = parentExtra.nestedAttributeTags[attrName];\n      const attrsObject = attrsToObject(tag, true);\n      if (info.dynamic) {\n        if (!info.identifier) {\n          info.identifier = parentTag.scope.generateUidIdentifier(attrName);\n          parentTag.insertBefore(\n            info.repeated ? import_compiler43.types.variableDeclaration(\"const\", [\n              import_compiler43.types.variableDeclarator(info.identifier, import_compiler43.types.arrayExpression([]))\n            ]) : import_compiler43.types.variableDeclaration(\"let\", [\n              import_compiler43.types.variableDeclarator(info.identifier)\n            ])\n          );\n          parentTag.pushContainer(\n            \"attributes\",\n            import_compiler43.types.markoAttribute(attrName, info.identifier)\n          );\n        }\n        tag.replaceWith(\n          import_compiler43.types.expressionStatement(\n            info.repeated ? import_compiler43.types.callExpression(\n              import_compiler43.types.memberExpression(info.identifier, import_compiler43.types.identifier(\"push\")),\n              [attrsObject]\n            ) : import_compiler43.types.assignmentExpression(\"=\", info.identifier, attrsObject)\n          )\n        );\n      } else if (info.repeated) {\n        const existingAttr = parentTag.get(\"attributes\").find((attr2) => attr2.node.name === attrName);\n        if (existingAttr) {\n          existingAttr.get(\"value\").pushContainer(\"elements\", attrsObject);\n        } else {\n          parentTag.pushContainer(\n            \"attributes\",\n            import_compiler43.types.markoAttribute(attrName, import_compiler43.types.arrayExpression([attrsObject]))\n          );\n        }\n        tag.remove();\n      } else {\n        parentTag.pushContainer(\n          \"attributes\",\n          import_compiler43.types.markoAttribute(attrName, attrsObject)\n        );\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/visitors/tag/custom-tag.ts\nvar import_babel_utils39 = require(\"@marko/babel-utils\");\nvar import_compiler44 = require(\"@marko/compiler\");\nvar kChildScopeBinding = Symbol(\"custom tag child scope\");\nvar custom_tag_default = {\n  analyze: {\n    enter(tag) {\n      const section = getOrCreateSection(tag);\n      const tagBody = tag.get(\"body\");\n      startSection(tagBody);\n      trackVarReferences(tag, 4 /* derived */);\n      trackParamsReferences(tagBody, 3 /* param */);\n      if ((0, import_babel_utils39.getTagTemplate)(tag)) {\n        const tagExtra = tag.node.extra ??= {};\n        tagExtra[kChildScopeBinding] = createBinding(\n          \"#childScope\",\n          0 /* dom */,\n          section,\n          void 0,\n          tagExtra\n        );\n      }\n      const childFile = (0, import_babel_utils39.loadFileForTag)(tag);\n      const childProgramExtra = childFile?.ast.program.extra;\n      const hasInteractiveChild = childProgramExtra?.isInteractive || childProgramExtra?.hasInteractiveChild;\n      const inputExport = childProgramExtra?.domExports?.params?.props?.[0];\n      if (!inputExport?.props || tag.node.attributes.find((attr2) => import_compiler44.types.isMarkoSpreadAttribute(attr2))) {\n        mergeReferences(\n          tag,\n          tag.node.attributes.map((attr2) => attr2.value)\n        );\n      }\n      if (hasInteractiveChild) {\n        (currentProgramPath.node.extra ?? {}).hasInteractiveChild = true;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      (0, import_babel_utils39.assertAttributesOrSingleArg)(tag);\n      visit(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML2(tag);\n      } else {\n        translateDOM2(tag);\n      }\n    }\n  }\n};\nfunction translateHTML2(tag) {\n  const tagBody = tag.get(\"body\");\n  const { node } = tag;\n  let tagIdentifier;\n  flushInto(tag);\n  writeHTMLResumeStatements(tagBody);\n  if (import_compiler44.types.isStringLiteral(node.name)) {\n    const { file } = tag.hub;\n    const tagName = node.name.value;\n    const relativePath = getTagRelativePath(tag);\n    tagIdentifier = import_compiler44.types.memberExpression(\n      (0, import_babel_utils39.importDefault)(file, relativePath, tagName),\n      import_compiler44.types.identifier(\"_\")\n    );\n  } else {\n    tagIdentifier = import_compiler44.types.memberExpression(node.name, import_compiler44.types.identifier(\"_\"));\n  }\n  const tagVar = node.var;\n  const attrsObject = attrsToObject(tag, true);\n  const renderBodyProp = getRenderBodyProp(attrsObject);\n  const section = getSection(tag);\n  const childScopeBinding = node.extra[kChildScopeBinding];\n  const peekScopeId = tag.scope.generateUidIdentifier(childScopeBinding?.name);\n  tag.insertBefore(\n    import_compiler44.types.variableDeclaration(\"const\", [\n      import_compiler44.types.variableDeclarator(peekScopeId, callRuntime(\"peekNextScope\"))\n    ])\n  );\n  getSerializedScopeProperties(section).set(\n    getScopeAccessorLiteral(childScopeBinding),\n    peekScopeId\n  );\n  if (node.extra.tagNameNullable) {\n    let renderBodyId = void 0;\n    let renderTagExpr = callExpression(\n      tagIdentifier,\n      attrsToObject(tag)\n    );\n    if (renderBodyProp) {\n      renderBodyId = tag.scope.generateUidIdentifier(\"renderBody\");\n      const renderBodySection = getSection(tag.get(\"body\"));\n      const [renderBodyPath] = tag.insertBefore(\n        import_compiler44.types.variableDeclaration(\"const\", [\n          import_compiler44.types.variableDeclarator(\n            renderBodyId,\n            // TODO: only register if needed (child template analysis)\n            callRuntime(\n              \"register\",\n              callRuntime(\n                \"createRenderer\",\n                import_compiler44.types.arrowFunctionExpression(\n                  renderBodyProp.params,\n                  renderBodyProp.body\n                )\n              ),\n              import_compiler44.types.stringLiteral(\n                getResumeRegisterId(renderBodySection, \"renderer\")\n              ),\n              renderBodySection.closures.size && getScopeIdIdentifier(renderBodySection.parent)\n            )\n          )\n        ])\n      );\n      renderBodyPath.skip();\n      attrsObject.properties[attrsObject.properties.length - 1] = import_compiler44.types.objectProperty(import_compiler44.types.identifier(\"renderBody\"), renderBodyId);\n    }\n    if (tagVar) {\n      translateVar(tag, import_compiler44.types.unaryExpression(\"void\", import_compiler44.types.numericLiteral(0)), \"let\");\n      renderTagExpr = import_compiler44.types.assignmentExpression(\"=\", tagVar, renderTagExpr);\n    }\n    tag.replaceWith(\n      import_compiler44.types.ifStatement(\n        tagIdentifier,\n        import_compiler44.types.expressionStatement(renderTagExpr),\n        renderBodyId && callStatement(renderBodyId)\n      )\n    )[0].skip();\n  } else if (tagVar) {\n    translateVar(\n      tag,\n      callExpression(\n        tagIdentifier,\n        attrsObject,\n        callRuntime(\n          \"register\",\n          callRuntime(\n            \"createRenderer\",\n            import_compiler44.types.arrowFunctionExpression([], import_compiler44.types.blockStatement([]))\n          ),\n          import_compiler44.types.stringLiteral(\n            getResumeRegisterId(\n              section,\n              node.var.extra?.binding\n              // TODO: node.var is not always an identifier.\n            )\n          ),\n          getScopeIdIdentifier(section)\n        )\n      )\n    );\n    setForceResumeScope(section);\n    tag.remove();\n  } else {\n    tag.replaceWith(callStatement(tagIdentifier, attrsObject))[0].skip();\n  }\n}\nfunction translateDOM2(tag) {\n  const tagSection = getSection(tag);\n  const tagBody = tag.get(\"body\");\n  const tagBodySection = getSection(tagBody);\n  const { node } = tag;\n  const extra = node.extra;\n  const childScopeBinding = extra[kChildScopeBinding];\n  const write2 = writeTo(tag);\n  const { file } = tag.hub;\n  const tagName = import_compiler44.types.isIdentifier(node.name) ? node.name.name : import_compiler44.types.isStringLiteral(node.name) ? node.name.value : \"tag\";\n  const relativePath = getTagRelativePath(tag);\n  const childFile = (0, import_babel_utils39.loadFileForTag)(tag);\n  const childProgram = childFile.ast.program;\n  const tagIdentifier = (0, import_babel_utils39.importNamed)(\n    file,\n    relativePath,\n    childProgram.extra.domExports.setup,\n    tagName\n  );\n  const inputExport = childProgram.extra.domExports.params?.props?.[0];\n  if (inputExport) {\n    if (!inputExport.props || tag.node.attributes.some((attr2) => import_compiler44.types.isMarkoSpreadAttribute(attr2))) {\n      let attrsObject = attrsToObject(tag);\n      if (tagBodySection !== tagSection) {\n        attrsObject ??= import_compiler44.types.objectExpression([]);\n        attrsObject.properties.push(\n          import_compiler44.types.objectProperty(\n            import_compiler44.types.identifier(\"renderBody\"),\n            callRuntime(\n              \"bindRenderer\",\n              scopeIdentifier,\n              import_compiler44.types.identifier(tagBodySection.name)\n            )\n          )\n        );\n      }\n      const tagAttrsIdentifier = (0, import_babel_utils39.importNamed)(\n        file,\n        relativePath,\n        inputExport.id,\n        `${tagName}_input`\n      );\n      addValue(\n        tagSection,\n        extra.referencedBindings,\n        {\n          identifier: tagAttrsIdentifier,\n          hasDownstreamIntersections: () => true\n        },\n        attrsObject,\n        createScopeReadExpression(tagSection, childScopeBinding),\n        callRuntime(\n          \"inChild\",\n          getScopeAccessorLiteral(childScopeBinding),\n          import_compiler44.types.identifier(tagAttrsIdentifier.name)\n        )\n      );\n    } else {\n      for (const attrPath of tag.get(\n        \"attributes\"\n      )) {\n        const attr2 = attrPath.node;\n        const attrExport = inputExport.props[attr2.name];\n        if (attrExport) {\n          const attrExportIdentifier = (0, import_babel_utils39.importNamed)(\n            file,\n            relativePath,\n            attrExport.id,\n            `${tagName}_${attrExport.id}`\n          );\n          const attrReferences = attr2.value.extra?.referencedBindings;\n          attrPath.traverse(domHoistFunctionVisitor, { section: tagSection });\n          addValue(\n            tagSection,\n            attrReferences,\n            {\n              identifier: attrExportIdentifier,\n              hasDownstreamIntersections: () => true\n            },\n            attr2.value,\n            createScopeReadExpression(tagSection, childScopeBinding),\n            callRuntime(\n              \"inChild\",\n              getScopeAccessorLiteral(childScopeBinding),\n              import_compiler44.types.identifier(attrExportIdentifier.name)\n            )\n          );\n        }\n      }\n      if (inputExport.props.renderBody && tagBodySection !== tagSection) {\n        const renderBodyExportIdentifier = (0, import_babel_utils39.importNamed)(\n          file,\n          relativePath,\n          inputExport.props.renderBody.id,\n          `${tagName}_renderBody`\n        );\n        addValue(\n          tagSection,\n          void 0,\n          {\n            identifier: renderBodyExportIdentifier,\n            hasDownstreamIntersections: () => true\n          },\n          callRuntime(\n            \"bindRenderer\",\n            scopeIdentifier,\n            import_compiler44.types.identifier(tagBodySection.name)\n          ),\n          createScopeReadExpression(tagSection, childScopeBinding),\n          callRuntime(\n            \"inChild\",\n            getScopeAccessorLiteral(childScopeBinding),\n            import_compiler44.types.identifier(renderBodyExportIdentifier.name)\n          )\n        );\n      }\n    }\n  }\n  write2`${(0, import_babel_utils39.importNamed)(file, relativePath, childProgram.extra.domExports.template, `${tagName}_template`)}`;\n  injectWalks(\n    tag,\n    (0, import_babel_utils39.importNamed)(\n      file,\n      relativePath,\n      childProgram.extra.domExports.walks,\n      `${tagName}_walks`\n    )\n  );\n  if (node.var) {\n    const source = initValue(\n      // TODO: support destructuring\n      node.var.extra.binding\n    );\n    source.register = true;\n    addStatement(\n      \"render\",\n      tagSection,\n      void 0,\n      import_compiler44.types.expressionStatement(\n        callRuntime(\n          \"setTagVar\",\n          scopeIdentifier,\n          getScopeAccessorLiteral(childScopeBinding),\n          source.identifier\n        )\n      )\n    );\n  }\n  addStatement(\n    \"render\",\n    tagSection,\n    void 0,\n    import_compiler44.types.expressionStatement(\n      import_compiler44.types.callExpression(tagIdentifier, [\n        createScopeReadExpression(tagSection, childScopeBinding)\n      ])\n    )\n  );\n  tag.remove();\n}\nfunction getTagRelativePath(tag) {\n  const {\n    node,\n    hub: { file }\n  } = tag;\n  const nameIsString = import_compiler44.types.isStringLiteral(node.name);\n  let relativePath;\n  if (nameIsString) {\n    const template = (0, import_babel_utils39.getTagTemplate)(tag);\n    relativePath = template && (0, import_babel_utils39.resolveRelativePath)(file, template);\n  } else if (node.extra?.tagNameImported) {\n    relativePath = node.extra.tagNameImported;\n  }\n  if (!relativePath) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `Unable to find entry point for custom tag <${nameIsString ? node.name.value : node.name}>.`\n    );\n  }\n  const tags = file.metadata.marko.tags;\n  if (!tags.includes(relativePath)) {\n    tags.push(relativePath);\n  }\n  return relativePath;\n}\nfunction callStatement(id, ...args) {\n  return import_compiler44.types.expressionStatement(callExpression(id, ...args));\n}\nfunction callExpression(id, ...args) {\n  return import_compiler44.types.callExpression(id, args.filter(Boolean));\n}\n\n// src/visitors/tag/dynamic-tag.ts\nvar import_babel_utils40 = require(\"@marko/babel-utils\");\nvar import_compiler46 = require(\"@marko/compiler\");\n\n// src/util/to-first-expression-or-block.ts\nvar import_compiler45 = require(\"@marko/compiler\");\nfunction toFirstExpressionOrBlock(body) {\n  const nodes = body.body;\n  if (nodes.length === 1 && import_compiler45.types.isExpressionStatement(nodes[0])) {\n    return nodes[0].expression;\n  }\n  if (import_compiler45.types.isBlockStatement(body)) {\n    return body;\n  }\n  return import_compiler45.types.blockStatement(nodes);\n}\n\n// src/visitors/tag/dynamic-tag.ts\nvar kDOMBinding = Symbol(\"dynamic tag dom binding\");\nvar dynamic_tag_default = {\n  analyze: {\n    enter(tag) {\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      const tagBody = tag.get(\"body\");\n      const domBinding = tagExtra[kDOMBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section,\n        void 0,\n        tagExtra\n      );\n      startSection(tagBody);\n      trackVarReferences(tag, 4 /* derived */);\n      trackParamsReferences(tagBody, 3 /* param */);\n      const referenceNodes = [];\n      if (tag.node.arguments) {\n        for (const arg of tag.node.arguments) {\n          referenceNodes.push(arg);\n        }\n      }\n      for (const attr2 of tag.node.attributes) {\n        referenceNodes.push(attr2.value);\n      }\n      mergeReferences(tag, referenceNodes);\n      addReferenceToExpression(tag, domBinding);\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag, 37 /* Replace */);\n      (0, import_babel_utils40.assertAttributesOrArgs)(tag);\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const extra = node.extra;\n      const nodeRef = extra[kDOMBinding];\n      let tagExpression = node.name;\n      if (import_compiler46.types.isStringLiteral(tagExpression)) {\n        const { file } = tag.hub;\n        const relativePath = getTagRelativePath(tag);\n        tagExpression = (0, import_babel_utils40.importDefault)(file, relativePath, tagExpression.value);\n      }\n      if (extra.featureType === \"class\") {\n        const { markoOpts } = tag.hub.file;\n        const compatRuntimeFile = `marko/src/runtime/helpers/tags-compat/${isOutputHTML() ? \"html\" : \"dom\"}${markoOpts.optimize ? \"\" : \"-debug\"}.${markoOpts.modules === \"esm\" ? \"mjs\" : \"js\"}`;\n        (0, import_babel_utils40.importDefault)(tag.hub.file, compatRuntimeFile);\n        if (isOutputHTML()) {\n          const serialized5to6 = (0, import_babel_utils40.importNamed)(\n            tag.hub.file,\n            compatRuntimeFile,\n            \"s\"\n          );\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler46.types.expressionStatement(\n              import_compiler46.types.callExpression(serialized5to6, [\n                import_compiler46.types.identifier(tagExpression.name),\n                import_compiler46.types.stringLiteral(\n                  (0, import_babel_utils40.getTemplateId)(\n                    markoOpts,\n                    (0, import_babel_utils40.loadFileForTag)(tag).metadata.marko.id\n                  )\n                )\n              ])\n            )\n          );\n        } else {\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler46.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                import_compiler46.types.stringLiteral(\n                  (0, import_babel_utils40.getTemplateId)(\n                    markoOpts,\n                    (0, import_babel_utils40.loadFileForTag)(tag).metadata.marko.id\n                  )\n                ),\n                import_compiler46.types.identifier(tagExpression.name)\n              )\n            )\n          );\n        }\n      }\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        const attrsObject = attrsToObject(tag, true);\n        const renderBodyProp = getRenderBodyProp(attrsObject);\n        const args = [\n          tagExpression,\n          attrsObject\n        ];\n        if (import_compiler46.types.isObjectExpression(attrsObject) && renderBodyProp) {\n          const renderBodySection = getSection(tag.get(\"body\"));\n          attrsObject.properties.pop();\n          args.push(\n            // TODO: omit register if dynamic tag is string only\n            callRuntime(\n              \"register\",\n              callRuntime(\n                \"createRenderer\",\n                import_compiler46.types.arrowFunctionExpression(\n                  renderBodyProp.params,\n                  toFirstExpressionOrBlock(renderBodyProp.body)\n                )\n              ),\n              import_compiler46.types.stringLiteral(\n                getResumeRegisterId(renderBodySection, \"renderer\")\n              ),\n              renderBodySection.closures.size && getScopeIdIdentifier(renderBodySection.parent)\n            )\n          );\n        }\n        const dynamicScopeIdentifier = currentProgramPath.scope.generateUidIdentifier(\"dynamicScope\");\n        const dynamicTagExpr = import_compiler46.types.isArrayExpression(attrsObject) ? callRuntime(\"dynamicTagArgs\", ...args) : callRuntime(\"dynamicTagInput\", ...args);\n        if (node.var) {\n          translateVar(tag, dynamicTagExpr);\n          tag.remove();\n        } else {\n          tag.replaceWith(\n            import_compiler46.types.variableDeclaration(\"const\", [\n              import_compiler46.types.variableDeclarator(dynamicScopeIdentifier, dynamicTagExpr)\n            ])\n          )[0].skip();\n        }\n        const section = getSection(tag);\n        writeTo(tag)`${callRuntime(\n          \"markResumeControlEnd\",\n          getScopeIdIdentifier(section),\n          getScopeAccessorLiteral(nodeRef)\n        )}`;\n        getSerializedScopeProperties(section).set(\n          import_compiler46.types.stringLiteral(getScopeAccessorLiteral(nodeRef).value + \"!\"),\n          dynamicScopeIdentifier\n        );\n        getSerializedScopeProperties(section).set(\n          import_compiler46.types.stringLiteral(getScopeAccessorLiteral(nodeRef).value + \"(\"),\n          import_compiler46.types.isIdentifier(tagExpression) ? import_compiler46.types.identifier(tagExpression.name) : tagExpression\n        );\n      } else {\n        const section = getSection(tag);\n        const bodySection = getSection(tag.get(\"body\"));\n        const hasBody = section !== bodySection;\n        const renderBodyIdentifier = hasBody && import_compiler46.types.identifier(bodySection.name);\n        const signal = getSignal(section, nodeRef, \"dynamicTagName\");\n        signal.build = () => {\n          return callRuntime(\n            \"conditional\",\n            getScopeAccessorLiteral(nodeRef),\n            getSignalFn(signal, [scopeIdentifier]),\n            buildSignalIntersections(signal)\n          );\n        };\n        signal.hasDownstreamIntersections = () => true;\n        addValue(\n          section,\n          node.name.extra?.referencedBindings,\n          signal,\n          renderBodyIdentifier ? import_compiler46.types.logicalExpression(\"||\", tagExpression, renderBodyIdentifier) : tagExpression\n        );\n        const attrsObject = attrsToObject(tag, true);\n        const emptyAttrs = import_compiler46.types.isObjectExpression(attrsObject) && !attrsObject.properties.length;\n        if (!emptyAttrs || renderBodyIdentifier) {\n          const attrsGetter = import_compiler46.types.arrowFunctionExpression([], attrsObject);\n          const id = currentProgramPath.scope.generateUidIdentifier(\n            tag.get(\"name\").toString() + \"_input\"\n          );\n          let added = false;\n          addValue(\n            section,\n            node.extra?.referencedBindings,\n            {\n              get identifier() {\n                if (!added) {\n                  currentProgramPath.pushContainer(\n                    \"body\",\n                    import_compiler46.types.variableDeclaration(\"const\", [\n                      import_compiler46.types.variableDeclarator(\n                        id,\n                        callRuntime(\n                          \"dynamicTagAttrs\",\n                          getScopeAccessorLiteral(nodeRef),\n                          renderBodyIdentifier,\n                          import_compiler46.types.isArrayExpression(attrsObject) ? import_compiler46.types.booleanLiteral(true) : false\n                        )\n                      )\n                    ])\n                  );\n                  added = true;\n                }\n                return id;\n              },\n              hasDownstreamIntersections: () => true\n            },\n            attrsGetter\n          );\n        }\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/visitors/tag/index.ts\nvar tag_default = {\n  analyze: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils41.getTagDef)(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        enter2(hook, tag);\n        return;\n      }\n      if (type === 0 /* NativeTag */) {\n        native_tag_default.analyze.enter(tag);\n        return;\n      }\n      analyzeAttributeTags(tag);\n      switch (type) {\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.analyze.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.analyze.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const hook = (0, import_babel_utils41.getTagDef)(tag)?.analyzer?.hook;\n      if (hook) {\n        exit2(hook, tag);\n        return;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils41.getTagDef)(tag);\n      const extra = tag.node.extra;\n      if (tagDef?.translator) {\n        if (tagDef.translator.path) {\n          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);\n        }\n        enter2(tagDef.translator.hook, tag);\n        return;\n      }\n      for (const attr2 of tag.get(\"attributes\")) {\n        if (attr2.isMarkoAttribute()) {\n          if (attr2.node.arguments) {\n            throw attr2.buildCodeFrameError(\n              `Unsupported arguments on the \"${attr2.node.name}\" attribute.`\n            );\n          }\n          if (attr2.node.modifier) {\n            if ((0, import_babel_utils41.isNativeTag)(attr2.parentPath)) {\n              attr2.node.name += `:${attr2.node.modifier}`;\n            } else {\n              throw attr2.buildCodeFrameError(\n                `Unsupported modifier \"${attr2.node.modifier}\".`\n              );\n            }\n          }\n        }\n      }\n      if (extra.tagNameDynamic && extra.tagNameNullable && !tag.get(\"name\").isIdentifier() && isOutputHTML()) {\n        const tagNameId = tag.scope.generateUidIdentifier(\"tagName\");\n        const [tagNameVarPath] = tag.insertBefore(\n          import_compiler47.types.variableDeclaration(\"const\", [\n            import_compiler47.types.variableDeclarator(tagNameId, tag.node.name)\n          ])\n        );\n        tagNameVarPath.skip();\n        tag.set(\"name\", tagNameId);\n      }\n      switch (extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const translator = (0, import_babel_utils41.getTagDef)(tag)?.translator;\n      if (translator) {\n        exit2(translator.hook, tag);\n        return;\n      }\n      switch (tag.node.extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.exit(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.exit(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.exit(tag);\n          break;\n      }\n    }\n  }\n};\n\n// src/visitors/text.ts\nvar import_compiler48 = require(\"@marko/compiler\");\nvar text_default = {\n  translate: {\n    exit(text) {\n      writeTo(text)`${text.node.value}`;\n      enterShallow(text);\n      text.remove();\n    }\n  }\n};\n\n// src/visitors/update-expression.ts\nvar import_compiler49 = require(\"@marko/compiler\");\nvar update_expression_default = {\n  translate: {\n    exit(assignment) {\n      if (isOutputDOM()) {\n        const generator = getAssignmentGenerator(\n          assignment,\n          assignment.node.argument.name\n        );\n        if (generator) {\n          const replacement = generator(\n            assignment,\n            import_compiler49.types.binaryExpression(\n              assignment.node.operator === \"++\" ? \"+\" : \"-\",\n              assignment.node.argument,\n              import_compiler49.types.numericLiteral(1)\n            )\n          );\n          assignment.replaceWith(\n            assignment.node.prefix || assignment.parentPath.isExpressionStatement() ? replacement : import_compiler49.types.sequenceExpression([replacement, assignment.node.argument])\n          );\n        }\n      }\n    }\n  }\n};\n\n// src/index.ts\nvar visitors = {\n  Program: program_default,\n  Function: function_default,\n  AssignmentExpression: assignment_expression_default,\n  UpdateExpression: update_expression_default,\n  ReferencedIdentifier: referenced_identifier_default,\n  ImportDeclaration: import_declaration_default,\n  MarkoDocumentType: document_type_default,\n  MarkoDeclaration: declaration_default,\n  MarkoCDATA: cdata_default,\n  MarkoText: text_default,\n  MarkoTag: tag_default,\n  MarkoPlaceholder: placeholder_default,\n  MarkoScriptlet: scriptlet_default,\n  MarkoComment: comment_default\n};\nvar getVisitorOfType = (typename) => Object.entries(visitors).reduce((visitor, [name, value]) => {\n  if (typename in value) {\n    visitor[name] = value[typename];\n  }\n  return visitor;\n}, {});\nvar analyze2 = getVisitorOfType(\"analyze\");\nvar translate2 = getVisitorOfType(\"translate\");\nvar taglibs = [\n  [\n    __dirname,\n    {\n      ...core_default,\n      migrate: getVisitorOfType(\"migrate\")\n    }\n  ]\n];\nfunction getRuntimeEntryFiles(output, optimize) {\n  return [\n    `@marko/runtime-tags${optimize ? \"\" : \"/debug\"}/${output === \"html\" ? \"html\" : \"dom\"}`\n  ];\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  analyze,\n  getRuntimeEntryFiles,\n  internalEntryBuilder,\n  taglibs,\n  translate\n});\n"],"names":["mod","__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__copyProps","to","from","except","desc","key","call","get","enumerable","__toESM","isNodeMode","target","__esModule","value","src_exports","__export","all","name","analyze","analyze2","getRuntimeEntryFiles","internalEntryBuilder","entry_builder_default","taglibs","translate","translate2","module","exports","import_babel_utils","require","taglibId","interopTaglibId","isCoreTagName","tag","id","isMarkoTag","getTagDef","isCoreTag","node","import_babel_utils2","flush_here_and_after_default","transform","renderer","replaceWithMultiple","body","import_compiler","attrs_default","migrate","tagVar","var","type","remove","constTag","types","markoTag","stringLiteral","markoAttribute","identifier","markoTagBody","replaceWith","attributes","autocomplete","displayText","description","snippet","import_babel_utils3","import_compiler2","client_default","parse","hub","file","rawValue","code","replace","trim","start","length","parseStatements","isBlockStatement","markoScriptlet","parseOptions","statement","rawOpenTag","descriptionMoreURL","import_babel_utils14","import_babel_utils13","import_compiler18","import_compiler16","getExprRoot","path3","curPath","isMarko","parentPath","destructRoot","getDestructureRoot","isFunctionExpression","parent","import_path","import_babel_utils12","import_compiler15","bindingHasDownstreamExpressions","binding","downstreamExpressions","size","alias","aliases","propertyAliases","values","import_babel_utils4","import_compiler3","kState","Symbol","build","entryFile","state","path","buildCodeFrameError","imports","map","it","importDeclaration","init","unshift","importSpecifier","markoOpts","optimize","push","expressionStatement","callExpression","visit","visitChild","analyzedTags","metadata","marko","resolveRelativePath","opts","filename","extra","hasInteractiveChild","isInteractive","import_babel_utils6","import_compiler5","createProgramState","WeakMap","currentProgramPath","set","createSectionState","section","arrayOfSectionData","import_babel_utils5","import_compiler4","MARKO_FILE_REG","analyzeTagNameType","tagNameType","isStringLiteral","isNativeTag","bindingName","bindingIdentifier","scope","getBinding","tagIdentifier","newNode","originalNode","loc","end","referencedBindings","analyzeExpressionTagName","childFile","loadFileForTag","childProgram","ast","program","featureType","tagNameNullable","pending","tagNameImported","nullable","pop","isConditionalExpression","alternate","isLogicalExpression","operator","isAssignmentExpression","isBinaryExpression","isTemplateLiteral","isNullLiteral","isIdentifier","kind","decl","test","source","specifiers","some","isImportDefaultSpecifier","resolvedImport","resolveTagImport","bindingTag","bindingTagName","tagNameDynamic","startSection","parentSection","getOrCreateSection","sectionNamePath","sectionName","isProgram","generateUid","toString","programExtra","sections","depth","closures","Set","bindings","startNodeContentType","getStartNodeContentType","endNodeContentType","getEndNodeContentType","upstreamExpression","cur","getSection","currentPath","_setSectionPath","getScopeIdIdentifier","generateUidIdentifier","getSectionPath","_getScopeIdentifier","getScopeIdentifier","ignoreDefault","scopeId","forEachSection","fn","forEach","child","contentType","getNodeContentType","i","extraMember","isMarkoText","isMarkoPlaceholder","isMarkoScriptlet","isMarkoComment","isAttributeTag","tagSection","isStatefulSection","isStatefulReferences","checkStatefulClosures","immediateOnly","import_babel_utils10","import_compiler13","import_babel_utils7","import_compiler7","val","unsafeXMLReg","replaceUnsafeXML","c","escapeXMLStr","str","escapeXML","unsafeScriptReg","escapeScriptStr","escapeScript","unsafeStyleReg","escapeStyleStr","escapeStyle","stringifyClassObject","NON_DIMENSIONAL","stringifyStyleObject","toDelimitedString","delimiter","stringify","result","curDelimiter","Array","isArray","v","part","classAttr","stringAttr","styleAttr","attr","attrAssignment","RegExp","nonVoidAttr","escapeAttrValue","constructor","async","KNOWN_SYMBOLS2","Map","symbol","AggregateError","of","ArrayBuffer","isView","Atomics","add","and","compareExchange","exchange","isLockFree","load","notify","or","store","sub","wait","BigInt","asIntN","asUintN","BigInt64Array","BigUint64Array","Boolean","console","assert","clear","count","countReset","debug","dir","dirxml","error","group","groupCollapsed","groupEnd","info","log","table","time","timeEnd","timeLog","timeStamp","trace","warn","DataView","Date","now","UTC","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","Error","EvalError","Float32Array","Float64Array","Function","globalThis","atob","btoa","clearImmediate","clearInterval","clearTimeout","crypto","getRandomValues","randomUUID","fetch","performance","queueMicrotask","setImmediate","setInterval","setTimeout","structuredClone","URL","URLSearchParams","WritableStream","Int16Array","Int32Array","Int8Array","Intl","Collator","DateTimeFormat","DisplayNames","getCanonicalLocales","ListFormat","Locale","NumberFormat","PluralRules","RelativeTimeFormat","Segmenter","supportedValuesOf","isFinite","isNaN","JSON","groupBy","Math","abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","floor","fround","hypot","imul","log10","log1p","log2","max","min","pow","random","round","sign","sin","sinh","sqrt","tan","tanh","trunc","Number","isInteger","isSafeInteger","parseFloat","parseInt","assign","defineProperties","entries","freeze","fromEntries","getOwnPropertyDescriptors","getOwnPropertySymbols","is","isExtensible","isFrozen","isSealed","keys","preventExtensions","seal","setPrototypeOf","Promise","Proxy","RangeError","ReferenceError","Reflect","apply","construct","deleteProperty","has","ownKeys","String","fromCharCode","fromCodePoint","raw","for","SyntaxError","TypeError","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","URIError","WeakSet","doc","walker","replacementNode","targetParent","targetNode","refNode","nextNode","runtimePrefix","document","createTreeWalker","data","indexOf","getElementById","parentNode","firstChild","insertBefore","removeChild","nextSibling","unsafeAttrChars","lastIndex","import_compiler6","item","cb","findSorted","compare","pos","mid","compareResult","addSorted","len","next","joinRepeatable","a","b","createScopeReadPattern","rootDepth","rootPattern","objectPattern","nestedPatterns","ref","includes","propertyKey","getScopeAccessorLiteral","propertyValue","isShorthand","pattern","relativeDepth","prev","nestedPattern","properties","objectProperty","getScopeExpression","targetSection","scopeIdentifier","diff","memberExpression","createScopeReadExpression","reference","pureFunctions","importRuntime","output","getMarkoOpts","importNamed","getRuntimePath","callRuntime","args","callExpression2","filteredArgs","arg","unaryExpression","numericLiteral","filterArguments","leadingComments","getHTMLRuntime","import_babel_utils9","import_compiler12","import_babel_utils8","import_compiler11","assertNoSpreadAttrs","attr2","isMarkoSpreadAttribute","assertNoBodyContent","import_compiler10","import_compiler8","toTemplateOrStringLiteral","parts","strs","exprs","curStr","content","nextIndex","exprLen","expressions","shiftItems","quasis","j","templateLiteral","templateElement","appendLiteral","arr","list","offset","import_compiler9","getWalks","getWalkComment","getSteps","walkCodeToName","enter","exit","enterShallow","isOutputHTML","steps","walks","walkComment","walkString","walks2","step","lastIndexOf","current","walk","nCodeString","writeTo","number","toCharString","startCode","rangeSize","multiplier","getWalkString","prefix","postfix","walkLiteral","join","getWrites","exprsLen","writes","consumeHTML","flushBefore","expr","skip","flushInto","pushContainer","getSectionMeta","writePrefix","writePostfix","setup","getSetup","markNode","returnId","_setReturnId","return_default","assertNoVar","assertNoParams","valueAttr","isMarkoAttribute","default","msg","buildError","returnId2","variableDeclaration","variableDeclarator","addValue","hasDownstreamIntersections","getSignals","getSubscribeBuilder","_setSubscribeBuilder","setSubscriberBuilder","builder","getClosures","addClosure","fromSection","toSection","closure","currentSection","forceResumeScope","_setForceResumeScope","setForceResumeScope","getSerializedScopeProperties","unimplementedBuild","getSignal","generateSignalName","signals","signal","exportName","export","intersection","render","effect","effectInlineReferences","subscribers","subscribe","getSignalFn","provider","ownerScope","isImmediateOwner","object","isDynamicClosure","arrowFunctionExpression","buildSignalIntersections","initValue","valueAccessor","intersections","isParamBinding","upstreamAlias","property","params","scopeIdentifier2","valueIdentifier","toMemberExpression","blockStatement","signal2","intersectionExpression","closureEntries","sort","closureSection","closureSignal","hasDynamicSubscribers","arrayExpression","subscriber","p","providerSignal","finalizeSignalArgs","isArrowFunctionExpression","nullLiteral","isExpressionStatement","expression","addStatement","originalNodes","isInlined","statements","isFunction","addEffectReferences","bindingUtil","union","getResumeRegisterId","getTemplateId","writeSignals","sortSignals","effectDeclarator","effectIdentifier","isCallExpression","arguments","register","signalDeclarator","signalDeclaration","exportNamedDeclaration","roots","root","traverse","bindFunctionsVisitor","aReferencedBindings","getReferencedBindings","bReferencedBindings","reserve","getMappedId","addHTMLEffectCall","writeHTMLResumeStatements","tagVarIdentifier","hasSection","allSignals","scopeIdIdentifier","signalRefs","accessors","additionalProperties","serializedProperties","serialize","accessor","isLiteral","objectExpression","unshiftContainer","FunctionExpression","bindFunction","ArrowFunctionExpression","fnId","returnStatement","keyLiteral","keyToNode","dom_default","domExports","templateIdentifier","template","walksIdentifier","setupIdentifier","closuresIdentifier","paramsBinding","programParamsSignal","forEachSectionReverse","childSection","sectionPath","sectionParamsBinding","tagParamsSignal","writes2","setup2","closures2","functionExpression","exportDefaultDeclaration","import_babel_utils11","import_compiler14","html_default","returnIdentifier","renderContent","isImportDeclaration","isExportDeclaration","static","rendererId","previousProgramPath","program_default","crawl","trackParamsReferences","mergedReferences","getMergedReferences","nodes","targetExtra","isEffect","additionalBindings","delete","findReferences","getBindings","pruneBinding","referencedBinding","bindingReference","numReferences","binding1","binding2","sources1","getSourceBindings","sources2","isSuperset","sourceSection","bindings2","sortedBindings","filter","finalizeReferences","recurseAndBuildExportTree","isOutputDOM","visitedFiles","resolved","loadFileForImport","req","resolveRelativeToEntry","exportTree","props","exports2","getNextBindingId","setNextBindingId","createBinding","excludeProperties","propBinding","trackVarReferences","canonicalUpstreamAlias","getCanonicalBinding","createBindingsAndTrackReferences","lVal","babelBinding","referencePaths","constantViolations","referencePath","trackReference","left","trackReferencesForBinding","patternBinding","prop","argument","element","elements","fnRoot","getFnRoot","exprRoot","markoRoot","getMarkoRoot","exprExtra","addReferenceToExpression","fnExtra","addReference","toIdentifier","mergeReferences","compareIntersections","lenDelta","subset","elem","derived","sources","curBinding","this","aLen","bLen","aIndex","bIndex","unionSortedRepeatable","find","getIntersections","setIntersections","shouldPrune","isStatefulBinding","import_compiler17","toFirstStatementOrBlock","kBinding","if_default","tagBody","tagExtra","testAttr","BRANCHES_LOOKUP","getBranches","bodySection","branches","nextTag","getNextSibling","isLast","rootTag","rootExtra","tag2","singleNodeOptimization","every","getRoot","isStateful","nodeRef","hasStatefulClosures","section2","conditionalExpression","write2","ifScopeIdIdentifier","ifRendererIdentifier","branchHasStatefulClosures","assignmentExpression","curStatement","ifStatement","else_default","import_babel_utils15","import_compiler19","else_if_default","import_babel_utils16","import_compiler21","import_compiler20","translateVar","initialValue","cloneDeep","const_default","varBinding","derivation","import_babel_utils17","import_compiler22","debug_default","debuggerStatement","import_compiler25","import_compiler24","import_compiler23","IDENTIFIER_REG","renderBodyProps","htmlHoistFunctionVisitor","htmlFunctionVisit","domHoistFunctionVisitor","domFunctionVisit","serializedScopeProperties","registerId","attrsToObject","withRenderBody","resultExtra","hoistVisitor","spreadElement","hoistedControlFlows","isConditional","isLoop","renderBodySection","renderBodyExpression","isSpreadElement","getRenderBodyProp","attrsObject","isObjectExpression","lastProp","isObjectProperty","define_default","tagBodySection","import_babel_utils19","import_compiler26","do_default","hasDeclaration","isDeclaration","import_babel_utils20","import_compiler27","effect_default","value2","inlineBody","import_babel_utils21","export_default","import_babel_utils25","import_compiler29","import_babel_utils22","analyzeAttributeTags","nestedAttributeTags","analyzeChildren","repeated","dynamic","hasAttributeTags","analyzeChild","isTransparentTag","isLoopTag","attrName","slice","lookup","existing","import_babel_utils24","import_compiler28","import_babel_utils23","evaluate","confident","computed","computeNode","kNativeTagBinding","kSerializeMarker","native_tag_default","attrs2","hasEventHandlers","hasDynamicAttributes","isSpreadAttr","attr3","isEventHandler","tagName","assertNoArgs","isHTML","tagDef","hasSpread","throwStatement","newExpression","varName","references","createElFunction","referenceSection","visitAccessor","attrsObj","name2","valueReferences","helper","propName","charAt","toLowerCase","openTagOnly","htmlType","kForMarkerBinding","for_default","isOnlyChild","html","checkOnlyChild","parentTag","parentTagName","hasParams","findName","assertAllowedAttributes","validateFor","hasNestedAttributeTags","translateHTML","translateDOM","in","ofAttr","toAttr","inAttr","loopArgs","loopKind","fromAttr","stepAttr","byAttr","paramIdentifiers","getBindingIdentifiers","referencedBindings2","namePath","block","replacement","byParams","keyExpression","byIdentifier","keyParam","valParam","forInStatement","ofAttrValue","indexParam","loopParam","tempValParam","indexName","generateUidIdentifierBasedOnNode","updateExpression","forOfStatement","stepValue","fromValue","stepsName","stepName","fromName","binaryExpression","forStatement","logicalExpression","forScopeIdsIdentifier","forScopesIdentifier","obj","import_babel_utils26","import_compiler30","kCommentTagBinding","html_comment_default","assertNoAttributes","assertNoAttributeTags","needsBinding","referenceNodes","commentBinding","templateQuasis","templateExpressions","currentQuasi","text","import_babel_utils27","import_compiler31","id_default","import_babel_utils28","import_default","import_babel_utils29","import_compiler32","assignmentGeneratorMaps","getAssignmentGenerator","assignment","let_default","initValueId","generatorMap","registerAssignmentGenerator","queueSource","import_babel_utils30","import_compiler33","kRef","lifecycle_default","lifecycleAttrsRef","import_babel_utils31","import_compiler34","log_default","noop_default","import_babel_utils32","import_compiler35","server_default","import_babel_utils33","import_compiler36","static_default","import_path2","import_babel_utils34","import_compiler37","core_default","base","basename","sourceFileName","typeAttr","classAttr2","typeValue","classValue2","startsWith","markoText","resolveVirtualDependency","importPath","startPos","endPos","virtualPath","importDefaultSpecifier","importDefault","enum","import_compiler38","assignment_expression_default","handleDestructure","generator","right","ctx","getStatementParent","valueId","insertAfter","cdata_default","cdata","comment_default","comment","declaration_default","declaration","document_type_default","documentType","import_babel_utils35","import_compiler39","functionIdsBySection","function_default","functionNameCounts","index","import_babel_utils36","import_declaration_default","importDecl","tagImport","tags","import_babel_utils37","import_compiler40","kBinding2","kSiblingText","ESCAPE_TYPES","script","style","placeholder_default","placeholder","escape","placeholderExtra","getPrevSibling","analyzeSiblingText","nodeBinding","canWriteHTML","method","getParentTagName","siblingText","import_compiler41","abortIdsByExpressionForSection","referenced_identifier_default","hasBinding","isMemberExpression","exprId","abortIdsByExpression","scriptlet_default","scriptlet","import_babel_utils41","import_compiler47","import_compiler42","enter2","modulePlugin","plugin","isModulePlugin","isFunctionPlugin","exit2","import_babel_utils38","import_compiler43","attribute_tag_default","hasPendingHTML","findParentTag","parentExtra","existingAttr","import_babel_utils39","import_compiler44","kChildScopeBinding","custom_tag_default","getTagTemplate","childProgramExtra","inputExport","assertAttributesOrSingleArg","relativePath","getTagRelativePath","renderBodyProp","childScopeBinding","peekScopeId","renderBodyId","renderTagExpr","renderBodyPath","callStatement","translateHTML2","tagAttrsIdentifier","attrPath","attrExport","attrExportIdentifier","attrReferences","renderBody","renderBodyExportIdentifier","injectWalks","translateDOM2","nameIsString","import_babel_utils40","import_compiler46","import_compiler45","kDOMBinding","dynamic_tag_default","domBinding","assertAttributesOrArgs","tagExpression","compatRuntimeFile","modules","serialized5to6","toFirstExpressionOrBlock","dynamicScopeIdentifier","dynamicTagExpr","isArrayExpression","renderBodyIdentifier","attrsGetter","added","booleanLiteral","tag_default","hook","analyzer","translator","watchFiles","modifier","tagNameId","tagNameVarPath","text_default","import_compiler49","visitors","Program","AssignmentExpression","UpdateExpression","sequenceExpression","ReferencedIdentifier","ImportDeclaration","MarkoDocumentType","MarkoDeclaration","MarkoCDATA","MarkoText","MarkoTag","MarkoPlaceholder","MarkoScriptlet","MarkoComment","getVisitorOfType","typename","reduce","visitor"],"sourceRoot":""}