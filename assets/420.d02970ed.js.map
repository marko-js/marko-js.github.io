{"version":3,"file":"420.d02970ed.js","mappings":"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","sources":["webpack:///../../node_modules/@marko/runtime-tags/dist/translator/index.js"],"sourcesContent":["\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name2 in all)\n    __defProp(target, name2, { get: all[name2], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/translator/index.ts\nvar translator_exports = {};\n__export(translator_exports, {\n  analyze: () => analyze,\n  getRuntimeEntryFiles: () => getRuntimeEntryFiles,\n  internalEntryBuilder: () => entry_builder_default,\n  preferAPI: () => preferAPI,\n  tagDiscoveryDirs: () => tagDiscoveryDirs,\n  taglibs: () => taglibs,\n  transform: () => transform,\n  translate: () => translate\n});\nmodule.exports = __toCommonJS(translator_exports);\n\n// src/translator/util/runtime-info.ts\nvar import_package = require(\"../../package.json\");\nvar runtime_info_default = {\n  name: import_package.name,\n  taglibId: \"marko-core\"\n};\n\n// src/translator/core/attrs.ts\nvar import_compiler = require(\"@marko/compiler\");\nvar import_babel_utils = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/assert.ts\nfunction assertNoSpreadAttrs(tag) {\n  for (const attr2 of tag.get(\"attributes\")) {\n    if (attr2.isMarkoSpreadAttribute()) {\n      throw attr2.buildCodeFrameError(\n        `The \\`${tag.get(\"name\").node.value}\\` tag does not support \\`...spread\\` attributes.`\n      );\n    }\n  }\n}\nfunction assertNoBodyContent(tag) {\n  if (tag.node.body.body.length) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${tag.get(\"name\").node.value}\\` tag does not support body content.`\n    );\n  }\n}\n\n// src/translator/core/attrs.ts\nvar attrs_default = {\n  migrate: [\n    (tag) => {\n      (0, import_babel_utils.assertNoArgs)(tag);\n      (0, import_babel_utils.assertNoParams)(tag);\n      (0, import_babel_utils.assertNoAttributes)(tag);\n      assertNoBodyContent(tag);\n      (0, import_babel_utils.assertNoAttributeTags)(tag);\n      (0, import_babel_utils.diagnosticDeprecate)(tag, {\n        label: \"The `attrs` tag is deprecated, prefer destructuring `input` via the `const` tag.\",\n        fix() {\n          const tagVar = tag.node.var;\n          if (tagVar && !(tagVar.type === \"Identifier\" && tagVar.name === \"input\")) {\n            const constTag = import_compiler.types.markoTag(\n              import_compiler.types.stringLiteral(\"const\"),\n              [import_compiler.types.markoAttribute(\"value\", import_compiler.types.identifier(\"input\"))],\n              import_compiler.types.markoTagBody([])\n            );\n            constTag.var = tagVar;\n            tag.replaceWith(constTag);\n          } else {\n            tag.remove();\n          }\n        }\n      });\n    }\n  ],\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"attrs/{ ... }\",\n      description: \"Use to receive the attributes passed into this template.\",\n      snippet: \"attrs/{ $1 }$2\"\n    }\n  ]\n};\n\n// src/translator/core/await.ts\nvar import_compiler23 = require(\"@marko/compiler\");\nvar import_babel_utils12 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/evaluate.ts\nvar import_babel_utils2 = require(\"@marko/compiler/babel-utils\");\nfunction evaluate(value) {\n  let { extra } = value;\n  if (!extra) {\n    extra = value.extra = {};\n  }\n  if (extra.confident === void 0) {\n    const computed = (0, import_babel_utils2.computeNode)(value);\n    if (computed) {\n      extra.computed = computed.value;\n      extra.confident = true;\n    } else {\n      extra.computed = void 0;\n      extra.confident = false;\n    }\n  }\n  return extra;\n}\n\n// src/translator/util/references.ts\nvar import_compiler22 = require(\"@marko/compiler\");\n\n// src/translator/visitors/program/index.ts\nvar import_compiler20 = require(\"@marko/compiler\");\nvar import_babel_utils11 = require(\"@marko/compiler/babel-utils\");\nvar import_path2 = __toESM(require(\"path\"));\n\n// src/translator/util/binding-has-downstream-expressions.ts\nfunction bindingHasDownstreamExpressions(binding) {\n  if (binding.downstreamExpressions.size) return true;\n  for (const alias of binding.aliases) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  return false;\n}\n\n// src/translator/util/entry-builder.ts\nvar import_compiler2 = require(\"@marko/compiler\");\nvar import_babel_utils3 = require(\"@marko/compiler/babel-utils\");\nvar kState = Symbol();\nvar entry_builder_default = {\n  build(entryFile) {\n    const state = entryFile[kState];\n    if (!state) {\n      throw entryFile.path.buildCodeFrameError(\n        \"Unable to build hydrate code, no files were visited before finalizing the build\"\n      );\n    }\n    const body = state.imports.map(\n      (it) => import_compiler2.types.importDeclaration([], import_compiler2.types.stringLiteral(it))\n    );\n    if (state.init) {\n      body.unshift(\n        import_compiler2.types.importDeclaration(\n          [import_compiler2.types.importSpecifier(import_compiler2.types.identifier(\"init\"), import_compiler2.types.identifier(\"init\"))],\n          import_compiler2.types.stringLiteral(\n            `${runtime_info_default.name}/${entryFile.markoOpts.optimize ? \"\" : \"debug/\"}dom`\n          )\n        )\n      );\n      body.push(\n        import_compiler2.types.expressionStatement(import_compiler2.types.callExpression(import_compiler2.types.identifier(\"init\"), []))\n      );\n    }\n    return body;\n  },\n  visit(file, entryFile, visitChild) {\n    const state = entryFile[kState] ||= {\n      imports: [],\n      init: false\n    };\n    const { analyzedTags } = file.metadata.marko;\n    state.imports.push(\n      (0, import_babel_utils3.resolveRelativePath)(entryFile, file.opts.filename)\n    );\n    state.init ||= file.path.node.extra.hasInteractiveChild || file.path.node.extra.isInteractive || false;\n    for (const tag of analyzedTags || []) {\n      visitChild(tag);\n    }\n  }\n};\n\n// src/translator/util/marko-config.ts\nfunction isOutputHTML() {\n  return getMarkoOpts().output === \"html\";\n}\nfunction isOutputDOM() {\n  return !isOutputHTML();\n}\nfunction getMarkoOpts() {\n  return currentProgramPath.hub.file.markoOpts;\n}\nfunction isOptimize() {\n  return getMarkoOpts().optimize;\n}\n\n// src/translator/util/runtime.ts\nvar import_compiler4 = require(\"@marko/compiler\");\nvar import_babel_utils4 = require(\"@marko/compiler/babel-utils\");\n\n// src/common/attr-tag.ts\nvar rest = false ? Symbol(\"Attribute Tag\") : Symbol();\n\n// src/common/helpers.ts\nfunction classValue(value) {\n  return toDelimitedString(value, \" \", stringifyClassObject);\n}\nfunction stringifyClassObject(name2, value) {\n  return value ? name2 : \"\";\n}\nfunction styleValue(value) {\n  return toDelimitedString(value, \";\", stringifyStyleObject);\n}\nfunction stringifyStyleObject(name2, value) {\n  return value || value === 0 ? `${name2}:${typeof value === \"number\" && value && !/^(--|ta|or|li|z)|cou|nk|it|ag|we|do|w$/.test(name2) ? value + \"px\" : value}` : \"\";\n}\nfunction toDelimitedString(val, delimiter, stringify) {\n  switch (typeof val) {\n    case \"string\":\n      return val;\n    case \"object\":\n      if (val !== null) {\n        let result = \"\";\n        let curDelimiter = \"\";\n        if (Array.isArray(val)) {\n          for (const v of val) {\n            const part = toDelimitedString(v, delimiter, stringify);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        } else {\n          for (const name2 in val) {\n            const v = val[name2];\n            const part = stringify(name2, v);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        }\n        return result;\n      }\n  }\n  return \"\";\n}\nfunction isEventHandler(name2) {\n  return /^on[A-Z-]/.test(name2);\n}\nfunction getEventHandlerName(name2) {\n  return name2[2] === \"-\" ? name2.slice(3) : name2.slice(2).toLowerCase();\n}\nfunction isVoid(value) {\n  return value == null || value === false;\n}\n\n// src/html/content.ts\nfunction toString(val) {\n  return val ? val + \"\" : val === 0 ? \"0\" : \"\";\n}\nvar unsafeXMLReg = /[<&]/g;\nvar replaceUnsafeXML = (c) => c === \"&\" ? \"&amp;\" : \"&lt;\";\nvar escapeXMLStr = (str) => unsafeXMLReg.test(str) ? str.replace(unsafeXMLReg, replaceUnsafeXML) : str;\nfunction escapeXML(val) {\n  return val ? escapeXMLStr(val + \"\") : val === 0 ? \"0\" : \"&zwj;\";\n}\nvar unsafeScriptReg = /<\\/script/g;\nvar escapeScriptStr = (str) => unsafeScriptReg.test(str) ? str.replace(unsafeScriptReg, \"\\\\x3C/script\") : str;\nfunction escapeScript(val) {\n  return val ? escapeScriptStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\nvar unsafeStyleReg = /<\\/style/g;\nvar escapeStyleStr = (str) => unsafeStyleReg.test(str) ? str.replace(unsafeStyleReg, \"\\\\3C/style\") : str;\nfunction escapeStyle(val) {\n  return val ? escapeStyleStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\n\n// src/html/serializer.ts\nvar { hasOwnProperty } = {};\nvar Generator = function* () {\n}().constructor;\nvar AsyncGenerator = async function* () {\n}().constructor;\nvar KNOWN_SYMBOLS = (() => {\n  const KNOWN_SYMBOLS2 = /* @__PURE__ */ new Map();\n  for (const name2 of Object.getOwnPropertyNames(Symbol)) {\n    const symbol = Symbol[name2];\n    if (typeof symbol === \"symbol\") {\n      KNOWN_SYMBOLS2.set(symbol, \"Symbol.\" + name2);\n    }\n  }\n  return KNOWN_SYMBOLS2;\n})();\nvar KNOWN_FUNCTIONS = /* @__PURE__ */ new Map([\n  // This is by no means an exhaustive list,\n  // but it should cover most of the built-in functions.\n  [AggregateError, \"AggregateError\"],\n  [Array, \"Array\"],\n  [Array.from, \"Array.from\"],\n  [Array.isArray, \"Array.isArray\"],\n  [Array.of, \"Array.of\"],\n  [ArrayBuffer, \"ArrayBuffer\"],\n  [ArrayBuffer.isView, \"ArrayBuffer.isView\"],\n  [Atomics.add, \"Atomics.add\"],\n  [Atomics.and, \"Atomics.and\"],\n  [Atomics.compareExchange, \"Atomics.compareExchange\"],\n  [Atomics.exchange, \"Atomics.exchange\"],\n  [Atomics.isLockFree, \"Atomics.isLockFree\"],\n  [Atomics.load, \"Atomics.load\"],\n  [Atomics.notify, \"Atomics.notify\"],\n  [Atomics.or, \"Atomics.or\"],\n  [Atomics.store, \"Atomics.store\"],\n  [Atomics.sub, \"Atomics.sub\"],\n  [Atomics.wait, \"Atomics.wait\"],\n  [BigInt, \"BigInt\"],\n  [BigInt.asIntN, \"BigInt.asIntN\"],\n  [BigInt.asUintN, \"BigInt.asUintN\"],\n  [BigInt64Array, \"BigInt64Array\"],\n  [BigInt64Array.from, \"BigInt64Array.from\"],\n  [BigInt64Array.of, \"BigInt64Array.of\"],\n  [BigUint64Array, \"BigUint64Array\"],\n  [BigUint64Array.from, \"BigUint64Array.from\"],\n  [BigUint64Array.of, \"BigUint64Array.of\"],\n  [Boolean, \"Boolean\"],\n  [console.assert, \"console.assert\"],\n  [console.clear, \"console.clear\"],\n  [console.count, \"console.count\"],\n  [console.countReset, \"console.countReset\"],\n  [console.debug, \"console.debug\"],\n  [console.dir, \"console.dir\"],\n  [console.dirxml, \"console.dirxml\"],\n  [console.error, \"console.error\"],\n  [console.group, \"console.group\"],\n  [console.groupCollapsed, \"console.groupCollapsed\"],\n  [console.groupEnd, \"console.groupEnd\"],\n  [console.info, \"console.info\"],\n  [console.log, \"console.log\"],\n  [console.table, \"console.table\"],\n  [console.time, \"console.time\"],\n  [console.timeEnd, \"console.timeEnd\"],\n  [console.timeLog, \"console.timeLog\"],\n  [console.timeStamp, \"console.timeStamp\"],\n  [console.trace, \"console.trace\"],\n  [console.warn, \"console.warn\"],\n  [DataView, \"DataView\"],\n  [Date, \"Date\"],\n  [Date.now, \"Date.now\"],\n  [Date.parse, \"Date.parse\"],\n  [Date.UTC, \"Date.UTC\"],\n  [decodeURI, \"decodeURI\"],\n  [decodeURIComponent, \"decodeURIComponent\"],\n  [encodeURI, \"encodeURI\"],\n  [encodeURIComponent, \"encodeURIComponent\"],\n  [Error, \"Error\"],\n  [EvalError, \"EvalError\"],\n  [Float32Array, \"Float32Array\"],\n  [Float32Array.from, \"Float32Array.from\"],\n  [Float32Array.of, \"Float32Array.of\"],\n  [Float64Array, \"Float64Array\"],\n  [Float64Array.from, \"Float64Array.from\"],\n  [Float64Array.of, \"Float64Array.of\"],\n  [Function, \"Function\"],\n  [globalThis.atob, \"atob\"],\n  [globalThis.btoa, \"btoa\"],\n  [globalThis.clearImmediate, \"clearImmediate\"],\n  [globalThis.clearInterval, \"clearInterval\"],\n  [globalThis.clearTimeout, \"clearTimeout\"],\n  [globalThis.crypto?.getRandomValues, \"crypto.getRandomValues\"],\n  [globalThis.crypto?.randomUUID, \"crypto.randomUUID\"],\n  [globalThis.fetch, \"fetch\"],\n  [globalThis.performance?.now, \"performance.now\"],\n  [globalThis.queueMicrotask, \"queueMicrotask\"],\n  [globalThis.setImmediate, \"setImmediate\"],\n  [globalThis.setInterval, \"setInterval\"],\n  [globalThis.setTimeout, \"setTimeout\"],\n  [globalThis.structuredClone, \"structuredClone\"],\n  [globalThis.URL, \"URL\"],\n  [globalThis.URLSearchParams, \"URLSearchParams\"],\n  [globalThis.WritableStream, \"WritableStream\"],\n  [Int16Array, \"Int16Array\"],\n  [Int16Array.from, \"Int16Array.from\"],\n  [Int16Array.of, \"Int16Array.of\"],\n  [Int32Array, \"Int32Array\"],\n  [Int32Array.from, \"Int32Array.from\"],\n  [Int32Array.of, \"Int32Array.of\"],\n  [Int8Array, \"Int8Array\"],\n  [Int8Array.from, \"Int8Array.from\"],\n  [Int8Array.of, \"Int8Array.of\"],\n  [Intl.Collator, \"Intl.Collator\"],\n  [Intl.DateTimeFormat, \"Intl.DateTimeFormat\"],\n  [Intl.DisplayNames, \"Intl.DisplayNames\"],\n  [Intl.getCanonicalLocales, \"Intl.getCanonicalLocales\"],\n  [Intl.ListFormat, \"Intl.ListFormat\"],\n  [Intl.Locale, \"Intl.Locale\"],\n  [Intl.NumberFormat, \"Intl.NumberFormat\"],\n  [Intl.PluralRules, \"Intl.PluralRules\"],\n  [Intl.RelativeTimeFormat, \"Intl.RelativeTimeFormat\"],\n  [Intl.Segmenter, \"Intl.Segmenter\"],\n  [Intl.supportedValuesOf, \"Intl.supportedValuesOf\"],\n  [isFinite, \"isFinite\"],\n  [isNaN, \"isNaN\"],\n  [JSON.parse, \"JSON.parse\"],\n  [JSON.stringify, \"JSON.stringify\"],\n  [Map, \"Map\"],\n  [Map.groupBy, \"Map.groupBy\"],\n  [Math.abs, \"Math.abs\"],\n  [Math.acos, \"Math.acos\"],\n  [Math.acosh, \"Math.acosh\"],\n  [Math.asin, \"Math.asin\"],\n  [Math.asinh, \"Math.asinh\"],\n  [Math.atan, \"Math.atan\"],\n  [Math.atan2, \"Math.atan2\"],\n  [Math.atanh, \"Math.atanh\"],\n  [Math.cbrt, \"Math.cbrt\"],\n  [Math.ceil, \"Math.ceil\"],\n  [Math.clz32, \"Math.clz32\"],\n  [Math.cos, \"Math.cos\"],\n  [Math.cosh, \"Math.cosh\"],\n  [Math.exp, \"Math.exp\"],\n  [Math.expm1, \"Math.expm1\"],\n  [Math.floor, \"Math.floor\"],\n  [Math.fround, \"Math.fround\"],\n  [Math.hypot, \"Math.hypot\"],\n  [Math.imul, \"Math.imul\"],\n  [Math.log, \"Math.log\"],\n  [Math.log10, \"Math.log10\"],\n  [Math.log1p, \"Math.log1p\"],\n  [Math.log2, \"Math.log2\"],\n  [Math.max, \"Math.max\"],\n  [Math.min, \"Math.min\"],\n  [Math.pow, \"Math.pow\"],\n  [Math.random, \"Math.random\"],\n  [Math.round, \"Math.round\"],\n  [Math.sign, \"Math.sign\"],\n  [Math.sin, \"Math.sin\"],\n  [Math.sinh, \"Math.sinh\"],\n  [Math.sqrt, \"Math.sqrt\"],\n  [Math.tan, \"Math.tan\"],\n  [Math.tanh, \"Math.tanh\"],\n  [Math.trunc, \"Math.trunc\"],\n  [Number, \"Number\"],\n  [Number.isFinite, \"Number.isFinite\"],\n  [Number.isInteger, \"Number.isInteger\"],\n  [Number.isNaN, \"Number.isNaN\"],\n  [Number.isSafeInteger, \"Number.isSafeInteger\"],\n  [Number.parseFloat, \"Number.parseFloat\"],\n  [Number.parseInt, \"Number.parseInt\"],\n  [Object, \"Object\"],\n  [Object.assign, \"Object.assign\"],\n  [Object.create, \"Object.create\"],\n  [Object.defineProperties, \"Object.defineProperties\"],\n  [Object.defineProperty, \"Object.defineProperty\"],\n  [Object.entries, \"Object.entries\"],\n  [Object.freeze, \"Object.freeze\"],\n  [Object.fromEntries, \"Object.fromEntries\"],\n  [Object.getOwnPropertyDescriptor, \"Object.getOwnPropertyDescriptor\"],\n  [Object.getOwnPropertyDescriptors, \"Object.getOwnPropertyDescriptors\"],\n  [Object.getOwnPropertyNames, \"Object.getOwnPropertyNames\"],\n  [Object.getOwnPropertySymbols, \"Object.getOwnPropertySymbols\"],\n  [Object.getPrototypeOf, \"Object.getPrototypeOf\"],\n  [Object.is, \"Object.is\"],\n  [Object.isExtensible, \"Object.isExtensible\"],\n  [Object.isFrozen, \"Object.isFrozen\"],\n  [Object.isSealed, \"Object.isSealed\"],\n  [Object.keys, \"Object.keys\"],\n  [Object.preventExtensions, \"Object.preventExtensions\"],\n  [Object.seal, \"Object.seal\"],\n  [Object.setPrototypeOf, \"Object.setPrototypeOf\"],\n  [Object.values, \"Object.values\"],\n  [parseFloat, \"parseFloat\"],\n  [parseInt, \"parseInt\"],\n  [Promise, \"Promise\"],\n  [Proxy, \"Proxy\"],\n  [RangeError, \"RangeError\"],\n  [ReferenceError, \"ReferenceError\"],\n  [Reflect.apply, \"Reflect.apply\"],\n  [Reflect.construct, \"Reflect.construct\"],\n  [Reflect.defineProperty, \"Reflect.defineProperty\"],\n  [Reflect.deleteProperty, \"Reflect.deleteProperty\"],\n  [Reflect.get, \"Reflect.get\"],\n  [Reflect.getOwnPropertyDescriptor, \"Reflect.getOwnPropertyDescriptor\"],\n  [Reflect.getPrototypeOf, \"Reflect.getPrototypeOf\"],\n  [Reflect.has, \"Reflect.has\"],\n  [Reflect.isExtensible, \"Reflect.isExtensible\"],\n  [Reflect.ownKeys, \"Reflect.ownKeys\"],\n  [Reflect.preventExtensions, \"Reflect.preventExtensions\"],\n  [Reflect.set, \"Reflect.set\"],\n  [Reflect.setPrototypeOf, \"Reflect.setPrototypeOf\"],\n  [RegExp, \"RegExp\"],\n  [Set, \"Set\"],\n  [String, \"String\"],\n  [String.fromCharCode, \"String.fromCharCode\"],\n  [String.fromCodePoint, \"String.fromCodePoint\"],\n  [String.raw, \"String.raw\"],\n  [Symbol, \"Symbol\"],\n  [Symbol.for, \"Symbol.for\"],\n  [SyntaxError, \"SyntaxError\"],\n  [TypeError, \"TypeError\"],\n  [Uint16Array, \"Uint16Array\"],\n  [Uint16Array.from, \"Uint16Array.from\"],\n  [Uint16Array.of, \"Uint16Array.of\"],\n  [Uint32Array, \"Uint32Array\"],\n  [Uint32Array.from, \"Uint32Array.from\"],\n  [Uint32Array.of, \"Uint32Array.of\"],\n  [Uint8Array, \"Uint8Array\"],\n  [Uint8Array.from, \"Uint8Array.from\"],\n  [Uint8Array.of, \"Uint8Array.of\"],\n  [Uint8ClampedArray, \"Uint8ClampedArray\"],\n  [Uint8ClampedArray.from, \"Uint8ClampedArray.from\"],\n  [Uint8ClampedArray.of, \"Uint8ClampedArray.of\"],\n  [URIError, \"URIError\"],\n  [WeakMap, \"WeakMap\"],\n  [WeakSet, \"WeakSet\"]\n]);\nvar KNOWN_OBJECTS = /* @__PURE__ */ new Map([\n  [Atomics, \"Atomics\"],\n  [console, \"console\"],\n  [globalThis, \"globalThis\"],\n  [globalThis.crypto, \"crypto\"],\n  [Intl, \"Intl\"],\n  [JSON, \"JSON\"],\n  [Math, \"Math\"],\n  [Reflect, \"Reflect\"]\n]);\nfunction toAccess(accessor) {\n  const start = accessor[0];\n  return start === '\"' || start >= \"0\" && start <= \"9\" ? \"[\" + accessor + \"]\" : \".\" + accessor;\n}\n\n// src/html/writer.ts\nvar K_SCOPE_ID = Symbol(\"Scope ID\");\nvar kPendingContexts = Symbol(\"Pending Contexts\");\nvar branchIdKey = Symbol();\nif (false) {\n  writeScope = /* @__PURE__ */ ((writeScope2) => (scopeId, partialScope, file, loc, vars) => {\n    const scope = writeScope2(scopeId, partialScope);\n    if (file && loc !== void 0) {\n      setDebugInfo(scope, file, loc, vars);\n    }\n    return scope;\n  })(writeScope);\n}\nvar tick = globalThis.setImmediate || globalThis.setTimeout || globalThis.queueMicrotask || ((cb) => Promise.resolve().then(cb));\n\n// src/html/attrs.ts\nfunction classAttr(value) {\n  return stringAttr(\"class\", classValue(value));\n}\nfunction styleAttr(value) {\n  return stringAttr(\"style\", styleValue(value));\n}\nvar kSelectedValue = Symbol(\"selectedValue\");\nfunction attr(name2, value) {\n  return isVoid(value) ? \"\" : nonVoidAttr(name2, value);\n}\nfunction stringAttr(name2, value) {\n  return value && \" \" + name2 + attrAssignment(value);\n}\nfunction nonVoidAttr(name2, value) {\n  switch (typeof value) {\n    case \"string\":\n      return \" \" + name2 + attrAssignment(value);\n    case \"boolean\":\n      return \" \" + name2;\n    case \"number\":\n      return \" \" + name2 + \"=\" + value;\n    case \"object\":\n      if (value instanceof RegExp) {\n        return \" \" + name2 + attrAssignment(value.source);\n      }\n      break;\n  }\n  return \" \" + name2 + attrAssignment(value + \"\");\n}\nvar singleQuoteAttrReplacements = /'|&(?=#?\\w+;)/g;\nvar doubleQuoteAttrReplacements = /\"|&(?=#?\\w+;)/g;\nvar needsQuotedAttr = /[\"'>\\s]|&#?\\w+;|\\/$/g;\nfunction attrAssignment(value) {\n  return value ? needsQuotedAttr.test(value) ? value[needsQuotedAttr.lastIndex - 1] === (needsQuotedAttr.lastIndex = 0, '\"') ? \"='\" + escapeSingleQuotedAttrValue(value) + \"'\" : '=\"' + escapeDoubleQuotedAttrValue(value) + '\"' : \"=\" + value : \"\";\n}\nfunction escapeSingleQuotedAttrValue(value) {\n  return singleQuoteAttrReplacements.test(value) ? value.replace(\n    singleQuoteAttrReplacements,\n    replaceUnsafeSingleQuoteAttrChar\n  ) : value;\n}\nfunction replaceUnsafeSingleQuoteAttrChar(match) {\n  return match === \"'\" ? \"&#39;\" : \"&amp;\";\n}\nfunction escapeDoubleQuotedAttrValue(value) {\n  return doubleQuoteAttrReplacements.test(value) ? value.replace(\n    doubleQuoteAttrReplacements,\n    replaceUnsafeDoubleQuoteAttrChar\n  ) : value;\n}\nfunction replaceUnsafeDoubleQuoteAttrChar(match) {\n  return match === '\"' ? \"&#34;\" : \"&amp;\";\n}\n\n// src/common/compat-meta.ts\nvar prefix = false ? \"$compat_\" : \"$C_\";\nvar RENDERER_REGISTER_ID = prefix + (false ? \"renderer\" : \"r\");\nvar SET_SCOPE_REGISTER_ID = prefix + (false ? \"setScope\" : \"s\");\nvar RENDER_BODY_ID = prefix + (false ? \"renderBody\" : \"b\");\n\n// src/html/compat.ts\nvar K_TAGS_API_STATE = Symbol();\n\n// src/translator/util/to-property-name.ts\nvar import_compiler3 = require(\"@marko/compiler\");\nfunction isValidPropertyIdentifier(name2) {\n  return /^[a-z_$][a-z0-9_$]*$/i.test(name2);\n}\nfunction toPropertyName(name2) {\n  if (isValidPropertyIdentifier(name2)) {\n    return import_compiler3.types.identifier(name2);\n  } else if (/^(?:0|[1-9][0-9]*)$/.test(name2)) {\n    return import_compiler3.types.numericLiteral(parseInt(name2, 10));\n  }\n  return import_compiler3.types.stringLiteral(name2);\n}\nfunction toObjectProperty(name2, value) {\n  return import_compiler3.types.objectProperty(toPropertyName(name2), value);\n}\nfunction toMemberExpression(object, key, optional) {\n  const prop = toPropertyName(key);\n  const computed = prop.type !== \"Identifier\";\n  return optional ? import_compiler3.types.optionalMemberExpression(object, prop, computed, true) : import_compiler3.types.memberExpression(object, prop, computed);\n}\n\n// src/translator/util/runtime.ts\nvar pureFunctions = [\n  \"conditional\",\n  \"conditionalClosure\",\n  \"dynamicTag\",\n  \"createRenderer\",\n  \"createContent\",\n  \"createTemplate\",\n  \"dynamicClosure\",\n  \"dynamicClosureRead\",\n  \"intersection\",\n  \"loopClosure\",\n  \"loopIn\",\n  \"loopOf\",\n  \"loopTo\",\n  \"state\",\n  \"value\"\n];\nfunction importRuntime(name2) {\n  const { output } = getMarkoOpts();\n  return toMemberExpression(\n    (0, import_babel_utils4.importStar)(currentProgramPath.hub.file, getRuntimePath(output), \"$\"),\n    name2\n  );\n}\nfunction callRuntime(name2, ...args) {\n  const callExpression2 = import_compiler4.types.callExpression(\n    importRuntime(name2),\n    filterArguments(args)\n  );\n  if (pureFunctions.includes(name2)) {\n    callExpression2.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: ` @__PURE__ `\n      }\n    ];\n  }\n  return callExpression2;\n}\nfunction getHTMLRuntime() {\n  return {\n    escapeXML,\n    toString,\n    attr,\n    classAttr,\n    styleAttr,\n    escapeScript,\n    escapeStyle\n  };\n}\nfunction getRuntimePath(output) {\n  const { optimize } = getMarkoOpts();\n  return `${runtime_info_default.name}/${optimize ? \"\" : \"debug/\"}${output === \"html\" ? \"html\" : \"dom\"}`;\n}\nfunction filterArguments(args) {\n  const filteredArgs = [];\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (arg || filteredArgs.length) {\n      filteredArgs[i] = arg || import_compiler4.types.unaryExpression(\"void\", import_compiler4.types.numericLiteral(0));\n    }\n  }\n  return filteredArgs;\n}\nfunction getCompatRuntimeFile() {\n  const markoOpts = getMarkoOpts();\n  return `marko/src/runtime/helpers/tags-compat/${isOutputHTML() ? \"html\" : \"dom\"}${markoOpts.optimize ? \"\" : \"-debug\"}.${markoOpts.modules === \"esm\" ? \"mjs\" : \"js\"}`;\n}\n\n// src/translator/util/sections.ts\nvar import_compiler6 = require(\"@marko/compiler\");\nvar import_babel_utils7 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/is-core-tag.ts\nvar import_babel_utils5 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-tag-name.ts\nfunction getTagName(tag) {\n  return tag.node.name.value;\n}\n\n// src/translator/util/is-core-tag.ts\nvar { taglibId } = runtime_info_default;\nvar htmlTaglibId = \"marko-html\";\nvar interopTaglibId = \"@marko/translator-interop-class-tags\";\nfunction isCoreTag(tag) {\n  if (tag.isMarkoTag()) {\n    const tagDef = (0, import_babel_utils5.getTagDef)(tag);\n    if (tagDef) {\n      switch (tagDef.taglibId) {\n        case taglibId:\n        case interopTaglibId:\n          return true;\n        case htmlTaglibId:\n          switch (tagDef.name) {\n            case \"script\":\n            case \"style\":\n              return true;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\nfunction isCoreTagName(tag, name2) {\n  return isCoreTag(tag) && getTagName(tag) === name2;\n}\nfunction isConditionTag(tag) {\n  if (isCoreTag(tag)) {\n    switch (getTagName(tag)) {\n      case \"if\":\n      case \"else-if\":\n      case \"else\":\n        return true;\n    }\n  }\n  return false;\n}\nfunction isControlFlowTag(tag) {\n  if (isCoreTag(tag)) {\n    switch (getTagName(tag)) {\n      case \"if\":\n      case \"else-if\":\n      case \"else\":\n      case \"for\":\n      case \"await\":\n      case \"try\":\n        return true;\n    }\n  }\n  return false;\n}\n\n// src/translator/util/optional.ts\nvar Sorted = class {\n  constructor(compare) {\n    this.compare = compare;\n  }\n  add(data, item) {\n    return data ? Array.isArray(data) ? addSorted(this.compare, data, item) : joinRepeatable(this.compare, data, item) : item;\n  }\n  union(a, b) {\n    if (a) {\n      if (Array.isArray(a)) {\n        if (b) {\n          if (Array.isArray(b)) {\n            return unionSortedRepeatable(this.compare, a, b);\n          } else {\n            return addSorted(this.compare, a, b);\n          }\n        }\n        return a;\n      }\n      if (b) {\n        if (Array.isArray(b)) {\n          return addSorted(this.compare, [...b], a);\n        }\n        return joinRepeatable(this.compare, b, a);\n      }\n      return a;\n    }\n    return b;\n  }\n  find(data, item) {\n    if (data) {\n      if (Array.isArray(data)) {\n        return findSorted(this.compare, data, item);\n      } else if (this.compare(data, item) === 0) {\n        return data;\n      }\n    }\n  }\n};\nfunction push(data, item) {\n  if (data) {\n    if (Array.isArray(data)) {\n      data.push(item);\n      return data;\n    }\n    return [data, item];\n  }\n  return item;\n}\nfunction concat(a, b) {\n  if (a) {\n    if (b) {\n      if (Array.isArray(a)) {\n        return a.concat(b);\n      } else if (Array.isArray(b)) {\n        return [a, ...b];\n      } else {\n        return [a, b];\n      }\n    }\n    return a;\n  }\n  return b;\n}\nfunction filter(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      const len = data.length;\n      let result;\n      let i = 0;\n      while (i < len) {\n        let item = data[i++];\n        if (cb(item)) {\n          result = item;\n          while (i < len) {\n            item = data[i++];\n            if (cb(item)) {\n              result = [result, item];\n              while (i < len) {\n                item = data[i++];\n                if (cb(item)) {\n                  result.push(item);\n                }\n              }\n              return result;\n            }\n          }\n          return result;\n        }\n      }\n      return result;\n    }\n    if (cb(data)) {\n      return data;\n    }\n  }\n  return void 0;\n}\nfunction forEach(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      let i = 0;\n      for (const item of data) {\n        cb(item, i++);\n      }\n    } else {\n      cb(data, 0);\n    }\n  }\n}\nfunction find(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      return data.find(cb);\n    }\n    if (cb(data, 0)) {\n      return data;\n    }\n  }\n}\nfunction map(data, cb) {\n  return data ? Array.isArray(data) ? data.map(cb) : [cb(data, 0)] : [];\n}\nfunction findSorted(compare, data, item) {\n  let max = data.length;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const cur = data[mid];\n    const compareResult = compare(cur, item);\n    if (compareResult === 0) return cur;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n}\nfunction addSorted(compare, data, item) {\n  const len = data.length;\n  let max = len;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(data[mid], item);\n    if (compareResult === 0) return data;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n  const result = new Array(len + 1);\n  for (let i = 0; i < pos; i++) {\n    result[i] = data[i];\n  }\n  let cur = item;\n  while (pos < len) {\n    const next = cur;\n    cur = data[pos];\n    result[pos++] = next;\n  }\n  result[len] = cur;\n  return result;\n}\nfunction unionSortedRepeatable(compare, a, b) {\n  const aLen = a.length;\n  const bLen = b.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  const result = [];\n  while (aIndex < aLen && bIndex < bLen) {\n    const aValue = a[aIndex];\n    const bValue = b[bIndex];\n    const delta = compare(aValue, bValue);\n    if (delta === 0) {\n      aIndex++;\n      bIndex++;\n      result.push(aValue);\n    } else if (delta < 0) {\n      aIndex++;\n      result.push(aValue);\n    } else {\n      bIndex++;\n      result.push(bValue);\n    }\n  }\n  if (aLen === bLen && aIndex === aLen) {\n    return a;\n  }\n  while (aIndex < aLen) {\n    result.push(a[aIndex++]);\n  }\n  while (bIndex < bLen) {\n    result.push(b[bIndex++]);\n  }\n  return result;\n}\nfunction joinRepeatable(compare, a, b) {\n  const compareResult = compare(a, b);\n  return compareResult === 0 ? a : compareResult < 0 ? [a, b] : [b, a];\n}\n\n// src/translator/util/state.ts\nvar createProgramState = (init) => {\n  const map2 = /* @__PURE__ */ new WeakMap();\n  return [\n    () => {\n      let state = map2.get(currentProgramPath);\n      if (!state) {\n        map2.set(currentProgramPath, state = init());\n      }\n      return state;\n    },\n    (value) => {\n      map2.set(currentProgramPath, value);\n    }\n  ];\n};\nfunction createSectionState(key, init) {\n  return [\n    (section) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      const sectionData = arrayOfSectionData[section.id] ??= init && init(section);\n      return sectionData;\n    },\n    (section, value) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      arrayOfSectionData[section.id] = value;\n    }\n  ];\n}\n\n// src/translator/util/tag-name-type.ts\nvar import_compiler5 = require(\"@marko/compiler\");\nvar import_babel_utils6 = require(\"@marko/compiler/babel-utils\");\nvar MARKO_FILE_REG = /^<.*>$|\\.marko$/;\nfunction analyzeTagNameType(tag) {\n  const extra = tag.node.extra ??= {};\n  if (extra.tagNameType === void 0) {\n    const name2 = tag.get(\"name\");\n    if (name2.isStringLiteral()) {\n      extra.tagNameType = name2.node.value[0] === \"@\" ? 3 /* AttributeTag */ : (0, import_babel_utils6.isNativeTag)(tag) ? 0 /* NativeTag */ : 1 /* CustomTag */;\n      extra.tagNameNullable = extra.tagNameNullable = false;\n    } else if (name2.isIdentifier()) {\n      analyzeExpressionTagName(name2, extra);\n      if (extra.tagNameType === 0 /* NativeTag */) {\n        extra.tagNameType = 2 /* DynamicTag */;\n      }\n    } else if (name2.isTemplateLiteral() && !name2.node.expressions.length) {\n      extra.tagNameType = 0 /* NativeTag */;\n    } else {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n    if (extra.tagNameType === void 0) {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n    if (extra.tagNameType === 1 /* CustomTag */) {\n      const childFile = (0, import_babel_utils6.loadFileForTag)(tag);\n      if (!childFile) {\n        extra.tagNameType = 2 /* DynamicTag */;\n      } else if (childFile.ast.program.extra.featureType === \"class\") {\n        extra.tagNameType = 2 /* DynamicTag */;\n        extra.featureType = \"class\";\n        (currentProgramPath.node.extra ??= {}).needsCompat = true;\n      }\n    }\n  }\n  return extra.tagNameType;\n}\nfunction analyzeExpressionTagName(name2, extra) {\n  const pending = [name2];\n  let path5;\n  let type;\n  let nullable = false;\n  let tagNameImported;\n  while ((path5 = pending.pop()) && type !== 2 /* DynamicTag */) {\n    if (path5.isConditionalExpression()) {\n      pending.push(path5.get(\"consequent\"));\n      if (path5.node.alternate) {\n        pending.push(path5.get(\"alternate\"));\n      }\n    } else if (path5.isLogicalExpression()) {\n      if (path5.node.operator === \"||\") {\n        pending.push(path5.get(\"left\"));\n      } else {\n        nullable = true;\n      }\n      pending.push(path5.get(\"right\"));\n    } else if (path5.isAssignmentExpression()) {\n      pending.push(path5.get(\"right\"));\n    } else if (path5.isBinaryExpression()) {\n      type = path5.node.operator !== \"+\" || type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path5.isStringLiteral() || path5.isTemplateLiteral()) {\n      type = type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path5.isNullLiteral()) {\n      nullable = true;\n    } else if (path5.isIdentifier()) {\n      if (path5.node.name === \"undefined\") {\n        nullable = true;\n        continue;\n      }\n      const binding = path5.scope.getBinding(path5.node.name);\n      if (!binding) {\n        type = 2 /* DynamicTag */;\n        continue;\n      }\n      if (binding.kind === \"module\") {\n        const decl = binding.path.parent;\n        if (MARKO_FILE_REG.test(decl.source.value) && decl.specifiers.some((it) => import_compiler5.types.isImportDefaultSpecifier(it))) {\n          const resolvedImport = (0, import_babel_utils6.resolveTagImport)(name2, decl.source.value) || decl.source.value;\n          if (type === 0 /* NativeTag */ || tagNameImported && tagNameImported !== resolvedImport) {\n            type = 2 /* DynamicTag */;\n            tagNameImported = void 0;\n          } else {\n            type = 1 /* CustomTag */;\n            tagNameImported = resolvedImport;\n          }\n        } else {\n          type = 2 /* DynamicTag */;\n        }\n        continue;\n      }\n      const bindingTag = binding.path;\n      if (bindingTag.isMarkoTag() && binding.kind === \"local\") {\n        const bindingTagName = bindingTag.get(\"name\").node.value;\n        if (bindingTagName === \"const\") {\n          pending.push(\n            bindingTag.get(\"attributes\")[0].get(\"value\")\n          );\n          continue;\n        }\n        if (bindingTagName === \"let\") {\n          type = 2 /* DynamicTag */;\n          continue;\n        }\n        continue;\n      }\n      type = 2 /* DynamicTag */;\n    } else {\n      type = 2 /* DynamicTag */;\n    }\n  }\n  extra.tagNameType = type;\n  extra.tagNameNullable = nullable;\n  extra.tagNameDynamic = true;\n  if (type === 1 /* CustomTag */ && tagNameImported) {\n    extra.tagNameImported = tagNameImported;\n  }\n}\n\n// src/translator/util/sections.ts\nvar sectionUtil = new Sorted(function compareSections(a, b) {\n  return a.id - b.id;\n});\nfunction startSection(path5) {\n  const extra = path5.node.extra ??= {};\n  let section = extra.section;\n  if (!section && (path5.type === \"Program\" || path5.get(\"body\").length)) {\n    const parentSection = path5.parentPath ? getOrCreateSection(path5.parentPath) : void 0;\n    const sectionNamePath = path5.parentPath?.get(\n      \"name\"\n    );\n    const sectionName = path5.isProgram() ? \"\" : currentProgramPath.scope.generateUid(\n      sectionNamePath.toString() + \"_content\"\n    );\n    const programExtra = path5.hub.file.path.node.extra ??= {};\n    const sections = programExtra.sections ??= [];\n    section = extra.section = {\n      id: sections.length,\n      name: sectionName,\n      loc: sectionNamePath?.node.loc || void 0,\n      depth: parentSection ? parentSection.depth + 1 : 0,\n      parent: parentSection,\n      sectionAccessor: void 0,\n      params: void 0,\n      referencedClosures: void 0,\n      referencedHoists: void 0,\n      bindings: void 0,\n      hoisted: void 0,\n      isHoistThrough: void 0,\n      assignments: void 0,\n      content: getContentInfo(path5),\n      upstreamExpression: void 0,\n      downstreamBinding: void 0,\n      hasAbortSignal: false,\n      isBranch: false\n    };\n    sections.push(section);\n  }\n  return section;\n}\nfunction getOrCreateSection(path5) {\n  let cur = path5;\n  while (true) {\n    if (cur.type === \"Program\" || cur.type === \"MarkoTagBody\" && !cur.node.attributeTags && !isNativeNode(cur.parentPath)) {\n      return startSection(cur);\n    }\n    cur = cur.parentPath;\n  }\n}\nfunction getSectionForBody(body) {\n  return body.node.extra?.section;\n}\nfunction getSection(path5) {\n  let section;\n  let currentPath = path5;\n  while ((section = currentPath.node.extra?.section) === void 0) {\n    currentPath = currentPath.parentPath;\n  }\n  return section;\n}\nvar [getScopeIdIdentifier] = createSectionState(\n  \"scopeIdIdentifier\",\n  (section) => currentProgramPath.scope.generateUidIdentifier(`scope${section.id}_id`)\n);\nvar [getSectionParentIsOwner, setSectionParentIsOwner] = createSectionState(\"parentIsOwner\", () => false);\nvar [_getScopeIdentifier] = createSectionState(\n  \"scopeIdentifier\",\n  () => import_compiler6.types.identifier(\"undefined\")\n);\nvar getScopeIdentifier = (section, ignoreDefault) => {\n  const scopeId = _getScopeIdentifier(section);\n  if (!ignoreDefault && scopeId.name === \"undefined\") {\n    scopeId.name = currentProgramPath.scope.generateUid(`scope${section.id}_`);\n  }\n  return scopeId;\n};\nfunction forEachSection(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  sections?.forEach(fn);\n}\nfunction forEachSectionReverse(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  for (let i = sections.length; i--; ) {\n    fn(sections[i]);\n  }\n}\nfunction getContentInfo(path5) {\n  const body = path5.get(\"body\");\n  const contentInfo = {\n    startType: null,\n    endType: null,\n    singleChild: true\n  };\n  for (let endIndex = body.length; endIndex--; ) {\n    const endType = getNodeContentType(body[endIndex], \"endType\", contentInfo);\n    if (endType !== null) {\n      contentInfo.endType = endType;\n      for (let startIndex = 0; startIndex < endIndex; startIndex++) {\n        const startType = getNodeContentType(body[startIndex], \"startType\");\n        if (startType !== null) {\n          contentInfo.startType = startType;\n          contentInfo.singleChild = false;\n          return contentInfo;\n        }\n      }\n      contentInfo.startType = getNodeContentType(body[endIndex], \"startType\");\n      return contentInfo;\n    }\n  }\n  return null;\n}\nfunction getNodeContentType(path5, extraMember, contentInfo) {\n  switch (path5.type) {\n    case \"MarkoText\":\n      return 4 /* Text */;\n    case \"MarkoPlaceholder\":\n      return 2 /* Placeholder */;\n    case \"MarkoScriptlet\":\n    case \"MarkoComment\":\n    case \"ImportDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportNamedDeclaration\":\n      return null;\n    case \"MarkoTag\": {\n      const tag = path5;\n      if (isCoreTag(tag)) {\n        switch (tag.node.name.value) {\n          case \"html-comment\":\n            return 0 /* Comment */;\n          case \"html-script\":\n          case \"html-style\":\n            return 3 /* Tag */;\n          case \"for\":\n          case \"if\":\n            return 1 /* Dynamic */;\n          default:\n            return null;\n        }\n      } else if ((0, import_babel_utils7.isNativeTag)(tag)) {\n        return 3 /* Tag */;\n      } else if ((0, import_babel_utils7.isAttributeTag)(tag)) {\n        return null;\n      } else if (import_compiler6.types.isStringLiteral(tag.node.name)) {\n        const tagSection = (0, import_babel_utils7.loadFileForTag)(tag)?.ast.program.extra.section;\n        if (tagSection) {\n          if (tagSection.content) {\n            if (contentInfo && !tagSection.content.singleChild) {\n              if (extraMember === \"endType\") {\n                contentInfo.startType = tagSection.content.startType;\n                contentInfo.singleChild = false;\n              }\n            }\n            return tagSection.content[extraMember];\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n  }\n  return 1 /* Dynamic */;\n}\nvar isSerializedSection = (section) => {\n  return !(section.isBranch || section.downstreamBinding?.serialize === false);\n};\nvar checkStatefulClosures = (section, immediateOnly) => {\n  return !!find(\n    section.referencedClosures,\n    (closure) => (!immediateOnly || section.parent === closure.section) && isStatefulReferences(closure)\n  );\n};\nfunction isImmediateOwner(section, binding) {\n  return section.parent?.id === binding.section.id;\n}\nfunction isDynamicClosure(section, closure) {\n  return !section.isBranch || !isImmediateOwner(section, closure);\n}\nfunction isSameOrChildSection(section, other) {\n  do {\n    if (other === section) {\n      return true;\n    }\n  } while (other = other.parent);\n  return false;\n}\nfunction getCommonSection(section, other) {\n  let ancestor = section;\n  if (other.depth < section.depth) {\n    ancestor = other;\n    other = section;\n  }\n  while (ancestor) {\n    if (other === ancestor || !other.parent) {\n      return ancestor;\n    }\n    other = other.parent;\n    if (other.depth < ancestor.depth) {\n      ancestor = ancestor.parent;\n    }\n  }\n  throw new Error(\"No common section\");\n}\nfunction isNativeNode(tag) {\n  if (isCoreTag(tag)) {\n    switch (tag.node.name.value) {\n      case \"html-comment\":\n      case \"html-script\":\n      case \"html-style\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  return analyzeTagNameType(tag) === 0 /* NativeTag */;\n}\n\n// src/translator/visitors/program/dom.ts\nvar import_compiler18 = require(\"@marko/compiler\");\nvar import_babel_utils10 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-style-file.ts\nvar import_path = __toESM(require(\"path\"));\nfunction getStyleFile(file) {\n  const { filename } = file.opts;\n  const fs = file.markoOpts.fileSystem;\n  const base = getBase(filename);\n  const styleMatch = new RegExp(\n    `^(${escapeRegExp(base)}\\\\.${\"index\" === base ? \"|\" : \"\"})style\\\\.\\\\w+$`\n  );\n  for (const file2 of fs.readdirSync(import_path.default.dirname(filename)).sort()) {\n    if (styleMatch.test(file2)) {\n      return `./${file2}`;\n    }\n  }\n}\nfunction getBase(filename) {\n  const start = filename.lastIndexOf(import_path.default.sep) + 1;\n  const leftDot = filename.indexOf(\".\", start);\n  if (leftDot === -1) {\n    return filename.slice(start);\n  }\n  const rightDot = filename.lastIndexOf(\".\");\n  const closeBracket = leftDot - 1;\n  if (filename[closeBracket] === \"]\") {\n    const openBracket = filename.lastIndexOf(\"[\", closeBracket);\n    if (openBracket > start) {\n      return filename.slice(start, openBracket) + filename.slice(leftDot, rightDot);\n    }\n  }\n  return filename.slice(start, rightDot);\n}\nvar regexpCharsReg = /[\\\\^$.*+?()[\\]{}|]/g;\nfunction escapeRegExp(str) {\n  return str.replace(regexpCharsReg, \"\\\\$&\");\n}\n\n// src/translator/util/signals.ts\nvar import_compiler17 = require(\"@marko/compiler\");\nvar import_babel_utils9 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/core/return.ts\nvar import_compiler11 = require(\"@marko/compiler\");\nvar import_babel_utils8 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-known-attr-values.ts\nfunction getKnownAttrValues(tag) {\n  const attrs2 = {};\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      attrs2[attr2.name] = attr2.value;\n    }\n  }\n  return attrs2;\n}\n\n// src/translator/util/get-parent-tag.ts\nfunction getParentTag(tag) {\n  const parent = tag.parent.type === \"MarkoTagBody\" ? tag.parentPath.parentPath : tag.parentPath;\n  if (parent.type === \"MarkoTag\") {\n    return parent;\n  }\n}\n\n// src/translator/util/plugin-hooks.ts\nvar import_compiler7 = require(\"@marko/compiler\");\nfunction enter(modulePlugin, path5) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path5;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (isFunctionPlugin(plugin)) {\n    plugin(path5, import_compiler7.types);\n  } else if (plugin.enter) {\n    plugin.enter(path5, import_compiler7.types);\n  }\n  return node !== path5.node;\n}\nfunction exit(modulePlugin, path5) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path5;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (!isFunctionPlugin(plugin) && plugin.exit) {\n    plugin.exit(path5, import_compiler7.types);\n  }\n  return node !== path5.node;\n}\nfunction isModulePlugin(plugin) {\n  return Boolean(plugin.default);\n}\nfunction isFunctionPlugin(plugin) {\n  return typeof plugin === \"function\";\n}\n\n// src/translator/util/visitors.ts\nfunction extractVisitors(visitors2) {\n  const result = {\n    migrate: {},\n    transform: {},\n    analyze: {},\n    translate: {}\n  };\n  for (const _name in visitors2) {\n    const name2 = _name;\n    const value = visitors2[name2];\n    if (value.migrate) result.migrate[name2] = value.migrate;\n    if (value.transform) result.transform[name2] = value.transform;\n    if (value.analyze) result.analyze[name2] = value.analyze;\n    if (value.translate) result.translate[name2] = value.translate;\n  }\n  return result;\n}\nfunction translateByTarget({\n  html,\n  dom\n}) {\n  return {\n    enter(path5) {\n      enter(isOutputHTML() ? html : dom, path5);\n    },\n    exit(path5) {\n      exit(isOutputHTML() ? html : dom, path5);\n    }\n  };\n}\n\n// src/translator/util/writer.ts\nvar import_compiler10 = require(\"@marko/compiler\");\n\n// src/translator/util/normalize-string-expression.ts\nvar import_compiler8 = require(\"@marko/compiler\");\nfunction normalizeStringExpression(parts) {\n  const strs = [];\n  const exprs = [];\n  let curStr = parts[0];\n  for (let i = 1; i < parts.length; i++) {\n    let content = parts[i];\n    if (typeof content === \"object\") {\n      if (import_compiler8.types.isStringLiteral(content)) {\n        content = content.value;\n      } else if (import_compiler8.types.isTemplateLiteral(content)) {\n        let nextIndex = i + 1;\n        const exprLen = content.expressions.length;\n        shiftItems(parts, nextIndex, content.quasis.length + exprLen);\n        for (let j = 0; j < exprLen; j++) {\n          parts[nextIndex++] = content.quasis[j].value.raw;\n          parts[nextIndex++] = content.expressions[j];\n        }\n        parts[nextIndex] = content.quasis[exprLen].value.raw;\n        continue;\n      } else {\n        exprs.push(content);\n        strs.push(curStr);\n        curStr = \"\";\n        continue;\n      }\n    }\n    curStr += content;\n  }\n  if (exprs.length) {\n    if (exprs.length === 1 && !curStr && !strs[0]) {\n      return exprs[0];\n    }\n    strs.push(curStr);\n    return import_compiler8.types.templateLiteral(\n      strs.map((raw) => import_compiler8.types.templateElement({ raw })),\n      exprs\n    );\n  } else if (curStr) {\n    return import_compiler8.types.stringLiteral(curStr);\n  }\n}\nfunction appendLiteral(arr, str) {\n  arr[arr.length - 1] += str;\n}\nfunction shiftItems(list, start, offset) {\n  for (let i = list.length - 1; i >= start; i--) {\n    list[i + offset] = list[i];\n  }\n}\n\n// src/translator/util/walks.ts\nvar import_compiler9 = require(\"@marko/compiler\");\nvar [getWalks] = createSectionState(\n  \"walks\",\n  () => [\"\"]\n);\nvar [getWalkComment] = createSectionState(\n  \"walkComment\",\n  () => []\n);\nvar [getSteps] = createSectionState(\"steps\", () => []);\nvar walkCodeToName = {\n  [32 /* Get */]: \"get\",\n  [36 /* Inside */]: \"inside\",\n  [37 /* Replace */]: \"replace\",\n  [38 /* EndChild */]: \"endChild\",\n  [47 /* BeginChild */]: \"beginChild\",\n  [48 /* BeginChildWithVar */]: \"beginChildWithVar\",\n  [49 /* DynamicTagWithVar */]: \"dynamicTagWithVar\",\n  [67 /* Next */]: \"next\",\n  [97 /* Over */]: \"over\",\n  [107 /* Out */]: \"out\",\n  [117 /* Multiplier */]: \"multiplier\",\n  [91 /* NextEnd */]: \"nextEnd\",\n  [106 /* OverEnd */]: \"overEnd\",\n  [116 /* OutEnd */]: \"outEnd\",\n  [126 /* MultiplierEnd */]: \"multiplierEnd\"\n};\nfunction enter2(path5) {\n  getSteps(getSection(path5)).push(0 /* Enter */);\n}\nfunction exit2(path5) {\n  getSteps(getSection(path5)).push(1 /* Exit */);\n}\nfunction enterShallow(path5) {\n  getSteps(getSection(path5)).push(0 /* Enter */, 1 /* Exit */);\n}\nfunction injectWalks(tag, expr) {\n  const walks = getWalks(getSection(tag));\n  const walkComment = getWalkComment(getSection(tag));\n  walkComment.push(\n    `${walkCodeToName[tag.node.var ? 48 /* BeginChildWithVar */ : 47 /* BeginChild */]}`,\n    expr.name,\n    walkCodeToName[38 /* EndChild */]\n  );\n  appendLiteral(\n    walks,\n    String.fromCharCode(\n      tag.node.var ? 48 /* BeginChildWithVar */ : 47 /* BeginChild */\n    )\n  );\n  walks.push(expr, String.fromCharCode(38 /* EndChild */));\n}\nfunction visit(path5, code) {\n  if (isOutputHTML()) {\n    return;\n  }\n  const section = getSection(path5);\n  const steps = getSteps(section);\n  const walks = getWalks(section);\n  const walkComment = getWalkComment(section);\n  let walkString = \"\";\n  if (steps.length) {\n    const walkCodes = [];\n    let depth = 0;\n    for (const step of steps) {\n      if (step === 0 /* Enter */) {\n        depth++;\n        walkCodes.push(67 /* Next */);\n      } else {\n        depth--;\n        if (depth >= 0) {\n          walkCodes.length = walkCodes.lastIndexOf(67 /* Next */);\n          walkCodes.push(97 /* Over */);\n        } else {\n          walkCodes.length = walkCodes.lastIndexOf(107 /* Out */) + 1;\n          walkCodes.push(107 /* Out */);\n          depth = 0;\n        }\n      }\n    }\n    let current = walkCodes[0];\n    let count = 0;\n    for (const walk of walkCodes) {\n      if (walk !== current) {\n        walkComment.push(`${walkCodeToName[current]}(${count})`);\n        walkString += nCodeString(current, count);\n        current = walk;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n    walkComment.push(`${walkCodeToName[current]}(${count})`);\n    walkString += nCodeString(current, count);\n    steps.length = 0;\n  }\n  if (code !== void 0) {\n    if (code !== 32 /* Get */) {\n      writeTo(path5)`<!>`;\n    }\n    walkComment.push(`${walkCodeToName[code]}`);\n    walkString += String.fromCharCode(code);\n  }\n  appendLiteral(walks, walkString);\n}\nfunction nCodeString(code, number) {\n  switch (code) {\n    case 67 /* Next */:\n      return toCharString(number, code, 20 /* Next */);\n    case 97 /* Over */:\n      return toCharString(number, code, 10 /* Over */);\n    case 107 /* Out */:\n      return toCharString(number, code, 10 /* Out */);\n    default:\n      throw new Error(`Unexpected walk code: ${code}`);\n  }\n}\nfunction toCharString(number, startCode, rangeSize) {\n  let result = \"\";\n  if (number >= rangeSize) {\n    const multiplier = Math.floor(number / rangeSize);\n    result += toCharString(\n      multiplier,\n      117 /* Multiplier */,\n      10 /* Multiplier */\n    );\n    number -= multiplier * rangeSize;\n  }\n  result += String.fromCharCode(startCode + number);\n  return result;\n}\nfunction getWalkString(section) {\n  const prefix2 = section.content?.startType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const postfix = section.content?.endType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const walks = getWalks(section);\n  const walkLiteral = normalizeStringExpression([prefix2, ...walks, postfix]);\n  if (walkLiteral && walkLiteral.value !== \"\") {\n    walkLiteral.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: \" \" + getWalkComment(section).join(\", \") + \" \"\n      }\n    ];\n  }\n  return walkLiteral;\n}\n\n// src/translator/util/writer.ts\nvar [getWrites] = createSectionState(\n  \"writes\",\n  () => [\"\"]\n);\nvar [getTrailerWrites] = createSectionState(\n  \"trailerWrites\",\n  () => [\"\"]\n);\nfunction writeTo(path5, trailer) {\n  const section = getSection(path5);\n  const get = trailer ? getTrailerWrites : getWrites;\n  return (strs, ...exprs) => {\n    const exprsLen = exprs.length;\n    const writes = get(section);\n    appendLiteral(writes, strs[0]);\n    for (let i = 0; i < exprsLen; i++) {\n      writes.push(exprs[i], strs[i + 1]);\n    }\n  };\n}\nfunction consumeHTML(path5) {\n  const section = getSection(path5);\n  const writes = getWrites(section);\n  const trailers = getTrailerWrites(section);\n  const writeResult = normalizeStringExpression(writes);\n  const trailerResult = normalizeStringExpression(trailers);\n  writes.length = 0;\n  writes[0] = \"\";\n  trailers.length = 0;\n  trailers[0] = \"\";\n  if (writeResult && trailerResult) {\n    return import_compiler10.types.expressionStatement(\n      import_compiler10.types.sequenceExpression([\n        callRuntime(\"write\", writeResult),\n        callRuntime(\"writeTrailers\", trailerResult)\n      ])\n    );\n  } else if (writeResult) {\n    return import_compiler10.types.expressionStatement(callRuntime(\"write\", writeResult));\n  } else if (trailerResult) {\n    return import_compiler10.types.expressionStatement(callRuntime(\"writeTrailers\", trailerResult));\n  }\n}\nfunction flushBefore(path5) {\n  const expr = consumeHTML(path5);\n  if (expr) {\n    path5.insertBefore(expr)[0].skip();\n  }\n}\nfunction flushInto(path5) {\n  const target = path5.isProgram() ? path5 : path5.get(\"body\");\n  const expr = consumeHTML(target);\n  if (expr) {\n    target.pushContainer(\"body\", expr)[0].skip();\n  }\n}\nfunction getSectionMeta(section) {\n  const writePrefix = section.content?.startType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writePostfix = section.content?.endType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writes = getWrites(section);\n  return {\n    setup: getSetup(section),\n    walks: getWalkString(section),\n    writes: normalizeStringExpression([writePrefix, ...writes, writePostfix])\n  };\n}\nfunction markNode(path5, binding) {\n  const section = getSection(path5);\n  if (binding.type !== 0 /* dom */) {\n    throw path5.buildCodeFrameError(\n      \"Tried to mark a node that was not determined to need a mark during analyze.\"\n    );\n  }\n  if (isOutputHTML()) {\n    writeTo(path5)`${callRuntime(\n      \"markResumeNode\",\n      getScopeIdIdentifier(section),\n      getScopeAccessorLiteral(binding)\n    )}`;\n  }\n}\n\n// src/translator/core/return.ts\nvar tagsWithReturn = /* @__PURE__ */ new WeakSet();\nvar [getSectionReturnValueIdentifier, setReturnValueIdentifier] = createSectionState(\"returnValue\");\nvar return_default = {\n  analyze(tag) {\n    (0, import_babel_utils8.assertNoArgs)(tag);\n    (0, import_babel_utils8.assertNoVar)(tag);\n    (0, import_babel_utils8.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils8.assertAllowedAttributes)(tag, [\"value\", \"valueChange\"]);\n    const parentTag = getParentTag(tag);\n    if (parentTag) {\n      if ((0, import_babel_utils8.isNativeTag)(parentTag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The `return` tag can not be used in a native tag.\"\n        );\n      } else if (isControlFlowTag(parentTag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          `The \\`return\\` tag can not be used under an \\`${parentTag.get(\"name\").toString()}\\` tag.`\n        );\n      }\n    }\n    if (tagsWithReturn.has(tag.parentPath)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        `Cannot have multiple \\`return\\` tags ${tag.parent.type === \"Program\" ? \"for the template\" : \"within a tag's body content\"}.`\n      );\n    } else {\n      tagsWithReturn.add(tag.parentPath);\n    }\n    if (!getKnownAttrValues(tag.node).value) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `return` tag requires a value.\");\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      exit(tag) {\n        const section = getSection(tag);\n        const attrs2 = getKnownAttrValues(tag.node);\n        flushBefore(tag);\n        if (attrs2.valueChange) {\n          setSerializedProperty(\n            section,\n            \"@\" /* TagVariableChange */,\n            attrs2.valueChange\n          );\n        }\n        if (attrs2.value) {\n          const returnId = tag.scope.generateUidIdentifier(\"return\");\n          setReturnValueIdentifier(section, returnId);\n          tag.replaceWith(\n            import_compiler11.types.variableDeclaration(\"const\", [\n              import_compiler11.types.variableDeclarator(returnId, attrs2.value)\n            ])\n          )[0].skip();\n        }\n      }\n    },\n    dom: {\n      exit(tag) {\n        const section = getSection(tag);\n        const attrs2 = getKnownAttrValues(tag.node);\n        if (attrs2.value) {\n          addValue(\n            section,\n            attrs2.value.extra?.referencedBindings,\n            {\n              identifier: importRuntime(\"tagVarSignal\"),\n              hasDownstreamIntersections: () => true\n            },\n            attrs2.value\n          );\n        }\n        if (attrs2.valueChange) {\n          addValue(\n            section,\n            attrs2.valueChange.extra?.referencedBindings,\n            {\n              identifier: importRuntime(\"setTagVarChange\"),\n              hasDownstreamIntersections: () => false\n            },\n            attrs2.valueChange\n          );\n        }\n        tag.remove();\n      }\n    }\n  }),\n  parseOptions: {\n    openTagOnly: true\n  },\n  autocomplete: [\n    {\n      displayText: \"return=<value>\",\n      description: \"Provides a value for use in a parent template.\",\n      snippet: \"return=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#return\"\n    }\n  ]\n};\n\n// src/translator/util/for-each-identifier.ts\nfunction forEachIdentifier(node, cb) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        switch (prop.type) {\n          case \"ObjectProperty\":\n            if (prop.value.type === \"AssignmentPattern\") {\n              forEachIdentifier(prop.value.left, cb);\n            } else {\n              forEachIdentifier(prop.value, cb);\n            }\n            break;\n          case \"RestElement\":\n            forEachIdentifier(prop.argument, cb);\n            break;\n        }\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const el of node.elements) {\n        if (el != null) {\n          switch (el.type) {\n            case \"RestElement\":\n              forEachIdentifier(el.argument, cb);\n              break;\n            case \"AssignmentPattern\":\n              forEachIdentifier(el.left, cb);\n              break;\n            default:\n              forEachIdentifier(el, cb);\n              break;\n          }\n        }\n      }\n      break;\n    case \"Identifier\":\n      cb(node);\n      break;\n  }\n}\n\n// src/translator/util/get-defined-binding-expression.ts\nvar import_compiler12 = require(\"@marko/compiler\");\nfunction getDeclaredBindingExpression(binding) {\n  if (binding.declared || !binding.upstreamAlias) {\n    return import_compiler12.types.identifier(binding.name);\n  } else if (binding.property !== void 0) {\n    return toMemberExpression(\n      getDeclaredBindingExpression(binding.upstreamAlias),\n      binding.property,\n      binding.upstreamAlias.nullable\n    );\n  } else {\n    return getDeclaredBindingExpression(binding.upstreamAlias);\n  }\n}\n\n// src/translator/util/scope-read.ts\nvar import_compiler13 = require(\"@marko/compiler\");\nfunction createScopeReadPattern(section, referencedBindings) {\n  const rootDepth = section.depth;\n  const rootPattern = import_compiler13.types.objectPattern([]);\n  let nestedPatterns;\n  forEach(referencedBindings, (ref) => {\n    const propertyValue = ref.name;\n    if (!isValidPropertyIdentifier(propertyValue)) return;\n    const propertyKey = getScopeAccessor(ref);\n    const isShorthand = propertyKey === propertyValue;\n    let pattern = rootPattern;\n    if (ref.section !== section) {\n      if (!nestedPatterns) nestedPatterns = [rootPattern];\n      const relativeDepth = rootDepth - ref.section.depth;\n      let i = nestedPatterns.length;\n      let prev = nestedPatterns[i - 1];\n      for (; i <= relativeDepth; i++) {\n        const nestedPattern = import_compiler13.types.objectPattern([]);\n        prev.properties.push(\n          import_compiler13.types.objectProperty(import_compiler13.types.identifier(\"_\"), nestedPattern)\n        );\n        nestedPatterns.push(nestedPattern);\n        prev = nestedPattern;\n      }\n      pattern = nestedPatterns[relativeDepth];\n    }\n    pattern.properties.push(\n      import_compiler13.types.objectProperty(\n        toPropertyName(propertyKey),\n        import_compiler13.types.identifier(propertyValue),\n        false,\n        isShorthand\n      )\n    );\n  });\n  return rootPattern;\n}\nfunction getScopeExpression(section, targetSection) {\n  let scope = scopeIdentifier ?? import_compiler13.types.identifier(\"undefined\");\n  const diff = section.depth - targetSection.depth;\n  for (let i = 0; i < diff; i++) {\n    scope = import_compiler13.types.memberExpression(scope, import_compiler13.types.identifier(\"_\"));\n  }\n  if (diff < 0) {\n    throw new Error(\"Unable to find scope for reference.\");\n  }\n  return scope;\n}\nfunction createScopeReadExpression(section, reference) {\n  const propName = toPropertyName(getScopeAccessor(reference));\n  return import_compiler13.types.memberExpression(\n    getScopeExpression(section, reference.section),\n    propName,\n    propName.type !== \"Identifier\"\n  );\n}\n\n// src/translator/util/simplify-fn.ts\nvar import_compiler14 = require(\"@marko/compiler\");\nfunction simplifyFunction(fn) {\n  switch (fn.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return fn;\n    default:\n      return import_compiler14.types.functionExpression(\n        null,\n        fn.params,\n        fn.body,\n        fn.async,\n        fn.generator\n      );\n  }\n}\n\n// src/translator/util/to-first-expression-or-block.ts\nvar import_compiler15 = require(\"@marko/compiler\");\nfunction toFirstExpressionOrBlock(stmts) {\n  if (stmts.length === 1 && import_compiler15.types.isExpressionStatement(stmts[0])) {\n    const { expression } = stmts[0];\n    switch (expression.type) {\n      case \"ObjectExpression\":\n      case \"AssignmentExpression\":\n        return toParenthesizedExpressionIfNeeded(expression);\n      default:\n        return expression;\n    }\n  }\n  return import_compiler15.types.blockStatement(stmts);\n}\nfunction toParenthesizedExpressionIfNeeded(expr) {\n  switch (expr.type) {\n    case \"ObjectExpression\":\n    case \"AssignmentExpression\":\n      return import_compiler15.types.parenthesizedExpression(expr);\n    default:\n      return expr;\n  }\n}\n\n// src/translator/util/traverse.ts\nvar import_compiler16 = require(\"@marko/compiler\");\nvar skip = Symbol(\"skip\");\nfunction traverseReplace(container, key, enter3) {\n  const node = container[key];\n  if (node) {\n    if (Array.isArray(node)) {\n      for (let i = node.length; i--; ) {\n        traverseReplace(node, i, enter3);\n      }\n    } else {\n      const keys = import_compiler16.types.VISITOR_KEYS[node.type];\n      for (let i = keys.length; i--; ) {\n        traverseReplace(node, keys[i], enter3);\n      }\n      const replacement = enter3(node, container, key);\n      if (replacement) container[key] = replacement;\n    }\n  }\n}\nfunction traverseContains(node, check) {\n  if (node) {\n    if (Array.isArray(node)) {\n      for (const item of node) {\n        if (traverseContains(item, check)) {\n          return true;\n        }\n      }\n    } else {\n      switch (check(node)) {\n        case true:\n          return true;\n        case skip:\n          return false;\n      }\n      for (const key of import_compiler16.types.VISITOR_KEYS[node.type]) {\n        if (traverseContains(node[key], check)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n// src/translator/util/signals.ts\nvar [getSignals] = createSectionState(\n  \"signals\",\n  () => /* @__PURE__ */ new Map()\n);\nvar [getClosureSignalBuilder, _setClosureSignalBuilder] = createSectionState(\"queue\");\nfunction setClosureSignalBuilder(tag, builder) {\n  _setClosureSignalBuilder(getSectionForBody(tag.get(\"body\")), builder);\n}\nvar [forceResumeScope, _setForceResumeScope] = createSectionState(\"forceResumeScope\");\nfunction setForceResumeScope(section) {\n  _setForceResumeScope(section, true);\n}\nvar [getSerializedScopeProperties] = createSectionState(\"serializedScopeProperties\", () => /* @__PURE__ */ new Map());\nfunction setSerializedProperty(section, key, value) {\n  getSerializedScopeProperties(section).set(key, value);\n}\nvar [getSectionWriteScopeBuilder, setSectionWriteScopeBuilder] = createSectionState(\n  \"sectionWriteScopeBuilder\"\n);\nfunction addWriteScopeBuilder(section, builder) {\n  const prev = getSectionWriteScopeBuilder(section);\n  setSectionWriteScopeBuilder(\n    section,\n    prev ? (expr) => builder(prev(expr)) : builder\n  );\n}\nvar htmlDynamicClosureInstancesIdentifier = /* @__PURE__ */ new WeakMap();\nvar [getHTMLSectionStatements] = createSectionState(\n  \"htmlScopeStatements\",\n  () => []\n);\nvar [getHoistFunctionsIdsMap] = createSectionState(\"hoistFunctionsIdsMap\", () => /* @__PURE__ */ new Map());\nfunction getHoistFunctionIdentifier(hoistedBinding) {\n  const idsMap = getHoistFunctionsIdsMap(hoistedBinding.section);\n  let identifier = idsMap.get(hoistedBinding);\n  if (!identifier) {\n    idsMap.set(\n      hoistedBinding,\n      identifier = currentProgramPath.scope.generateUidIdentifier(\n        `get${hoistedBinding.name}`\n      )\n    );\n  }\n  return identifier;\n}\nvar unimplementedBuild = () => {\n  return import_compiler17.types.stringLiteral(\"SIGNAL NOT INITIALIZED\");\n};\nfunction getSignal(section, referencedBindings, name2 = generateSignalName(referencedBindings)) {\n  const signals = getSignals(section);\n  let signal = signals.get(referencedBindings);\n  if (!signal) {\n    const exportName = referencedBindings ? !Array.isArray(referencedBindings) && referencedBindings.section === section && referencedBindings.export : !section.parent && currentProgramPath.node.extra.domExports?.setup;\n    signals.set(\n      referencedBindings,\n      signal = {\n        identifier: exportName ? import_compiler17.types.identifier(exportName) : currentProgramPath.scope.generateUidIdentifier(\n          name2 + section.name.replace(\"_\", \"$\")\n        ),\n        referencedBindings,\n        section,\n        values: [],\n        intersection: void 0,\n        render: [],\n        renderReferencedBindings: void 0,\n        effect: [],\n        effectReferencedBindings: void 0,\n        subscribers: [],\n        hasDownstreamIntersections: () => {\n          let hasDownstreamIntersections = !!signal.intersection;\n          if (!hasDownstreamIntersections) {\n            for (const value of signal.values) {\n              if (value.signal.hasDownstreamIntersections()) {\n                hasDownstreamIntersections = true;\n                break;\n              }\n            }\n          }\n          if (!hasDownstreamIntersections) {\n            if (!Array.isArray(referencedBindings) && referencedBindings) {\n              for (const alias of referencedBindings.aliases) {\n                if (getSignal(section, alias).hasDownstreamIntersections()) {\n                  hasDownstreamIntersections = true;\n                  break;\n                }\n              }\n              if (!hasDownstreamIntersections) {\n                for (const [, alias] of referencedBindings.propertyAliases) {\n                  if (getSignal(section, alias).hasDownstreamIntersections()) {\n                    hasDownstreamIntersections = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          signal.hasDownstreamIntersections = () => hasDownstreamIntersections;\n          return hasDownstreamIntersections;\n        },\n        build: unimplementedBuild,\n        export: !!exportName\n      }\n    );\n    if (isOutputHTML()) {\n      return signal;\n    } else if (!referencedBindings) {\n      signal.build = () => getSignalFn(signal, [scopeIdentifier]);\n    } else if (Array.isArray(referencedBindings)) {\n      subscribe(referencedBindings, signal);\n      signal.build = () => {\n        const { id, scopeOffset } = intersectionMeta.get(referencedBindings);\n        return callRuntime(\n          \"intersection\",\n          import_compiler17.types.numericLiteral(id),\n          getSignalFn(signal, [scopeIdentifier], referencedBindings),\n          scopeOffset || referencedBindings.length > 2 ? import_compiler17.types.numericLiteral(referencedBindings.length - 1) : void 0,\n          scopeOffset && getScopeAccessorLiteral(scopeOffset)\n        );\n      };\n    } else if (referencedBindings.section !== section && bindingUtil.find(section.referencedClosures, referencedBindings)) {\n      signal.build = () => {\n        const render = getSignalFn(signal, [\n          scopeIdentifier,\n          import_compiler17.types.identifier(referencedBindings.name)\n        ]);\n        return isDynamicClosure(section, referencedBindings) ? callRuntime(\n          \"dynamicClosureRead\",\n          getScopeAccessorLiteral(referencedBindings),\n          render,\n          isImmediateOwner(section, referencedBindings) ? void 0 : import_compiler17.types.arrowFunctionExpression(\n            [scopeIdentifier],\n            getScopeExpression(section, referencedBindings.section)\n          )\n        ) : getClosureSignalBuilder(section)(referencedBindings, render);\n      };\n    }\n  }\n  return signal;\n}\nfunction initValue(binding, runtimeHelper = \"value\") {\n  const section = binding.section;\n  const signal = getSignal(section, binding);\n  signal.build = () => {\n    const fn = getSignalFn(signal, [\n      scopeIdentifier,\n      import_compiler17.types.identifier(binding.name)\n    ]);\n    const isParamBinding = !binding.upstreamAlias && (binding.type === 3 /* param */ || binding.type === 2 /* input */);\n    const isNakedAlias = binding.upstreamAlias && !binding.property;\n    const needsGuard = !isNakedAlias && (binding.downstreamExpressions.size || fn.body.body.length > 0);\n    const needsCache = needsGuard || signal.intersection;\n    const needsMarks = isParamBinding || signal.intersection;\n    if (needsCache || needsMarks || binding.hoists.size) {\n      return callRuntime(\n        runtimeHelper,\n        getScopeAccessorLiteral(binding, runtimeHelper === \"state\"),\n        fn\n      );\n    } else {\n      return fn;\n    }\n  };\n  signal.valueAccessor = getScopeAccessorLiteral(binding);\n  for (const alias of binding.aliases) {\n    initValue(alias);\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    initValue(alias);\n  }\n  return signal;\n}\nfunction getSignalFn(signal, params, referencedBindings) {\n  const section = signal.section;\n  const binding = signal.referencedBindings;\n  const [scopeIdentifier2, valueIdentifier] = params;\n  const isValueSignal = binding && !Array.isArray(binding) && binding.section === section;\n  if (isValueSignal) {\n    for (const alias of binding.aliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler17.types.expressionStatement(\n          import_compiler17.types.callExpression(aliasSignal.identifier, [\n            scopeIdentifier2,\n            valueIdentifier,\n            ...getTranslatedExtraArgs(aliasSignal)\n          ])\n        )\n      );\n    }\n    for (const [key, alias] of binding.propertyAliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler17.types.expressionStatement(\n          import_compiler17.types.callExpression(aliasSignal.identifier, [\n            scopeIdentifier2,\n            toMemberExpression(valueIdentifier, key, binding.nullable),\n            ...getTranslatedExtraArgs(aliasSignal)\n          ])\n        )\n      );\n    }\n  }\n  for (const value of signal.values) {\n    signal.render.push(\n      import_compiler17.types.expressionStatement(\n        import_compiler17.types.callExpression(value.signal.identifier, [\n          value.scope,\n          value.value,\n          ...getTranslatedExtraArgs(value.signal)\n        ])\n      )\n    );\n  }\n  forEach(signal.intersection, (intersection) => {\n    signal.render.push(\n      import_compiler17.types.expressionStatement(import_compiler17.types.callExpression(intersection, [scopeIdentifier2]))\n    );\n  });\n  if (isValueSignal) {\n    let dynamicClosureArgs;\n    let dynamicClosureSignalIdentifier;\n    forEach(binding.closureSections, (closureSection) => {\n      if (isStatefulReferences(binding)) {\n        if (isDynamicClosure(closureSection, binding)) {\n          if (!dynamicClosureArgs) {\n            dynamicClosureArgs = [];\n            dynamicClosureSignalIdentifier = currentProgramPath.scope.generateUidIdentifier(\n              signal.identifier.name + \"_closure\"\n            );\n            signal.render.push(\n              import_compiler17.types.expressionStatement(\n                import_compiler17.types.callExpression(dynamicClosureSignalIdentifier, [\n                  scopeIdentifier2\n                ])\n              )\n            );\n          }\n          dynamicClosureArgs.push(\n            getSignal(closureSection, binding).identifier\n          );\n        } else {\n          signal.render.push(\n            import_compiler17.types.expressionStatement(\n              import_compiler17.types.callExpression(getSignal(closureSection, binding).identifier, [\n                scopeIdentifier2\n              ])\n            )\n          );\n        }\n      }\n    });\n    if (dynamicClosureSignalIdentifier) {\n      (signal.prependStatements ||= []).push(\n        import_compiler17.types.variableDeclaration(\"const\", [\n          import_compiler17.types.variableDeclarator(\n            dynamicClosureSignalIdentifier,\n            callRuntime(\"dynamicClosure\", ...dynamicClosureArgs)\n          )\n        ])\n      );\n    }\n  }\n  if (signal.effect.length) {\n    const effectIdentifier = import_compiler17.types.identifier(`${signal.identifier.name}_effect`);\n    signal.render.push(\n      import_compiler17.types.expressionStatement(\n        import_compiler17.types.callExpression(effectIdentifier, [scopeIdentifier2])\n      )\n    );\n  }\n  if (referencedBindings) {\n    signal.render.unshift(\n      import_compiler17.types.variableDeclaration(\"const\", [\n        import_compiler17.types.variableDeclarator(\n          createScopeReadPattern(section, referencedBindings),\n          scopeIdentifier2\n        )\n      ])\n    );\n  }\n  return import_compiler17.types.arrowFunctionExpression(params, import_compiler17.types.blockStatement(signal.render));\n}\nvar hasTranslatedExtraArgs = /* @__PURE__ */ new WeakSet();\nvar emptyExtraArgs = [];\nfunction getTranslatedExtraArgs(signal) {\n  if (signal.extraArgs) {\n    if (!hasTranslatedExtraArgs.has(signal)) {\n      hasTranslatedExtraArgs.add(signal);\n      traverseReplace(signal, \"extraArgs\", replaceRenderNode);\n    }\n    return signal.extraArgs;\n  }\n  return emptyExtraArgs;\n}\nfunction subscribe(provider, subscriber) {\n  if (Array.isArray(provider)) {\n    provider.forEach((p) => subscribe(p, subscriber));\n    return;\n  }\n  const providerSignal = getSignal(subscriber.section, provider);\n  providerSignal.intersection = push(\n    providerSignal.intersection,\n    subscriber.identifier\n  );\n}\nfunction generateSignalName(referencedBindings) {\n  let name2;\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      name2 = \"expr\";\n      for (const ref of referencedBindings) {\n        name2 += `_${ref.name}`;\n      }\n    } else {\n      name2 = referencedBindings.name;\n    }\n  } else {\n    name2 = \"setup\";\n  }\n  return name2;\n}\nfunction replaceNullishAndEmptyFunctionsWith0(args) {\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (!arg) {\n      args[i] = import_compiler17.types.numericLiteral(0);\n    } else if (import_compiler17.types.isArrowFunctionExpression(arg) && import_compiler17.types.isBlockStatement(arg.body)) {\n      const body = arg.body.body;\n      if (body.length === 0) {\n        args[i] = import_compiler17.types.numericLiteral(0);\n      } else if (body.length === 1 && import_compiler17.types.isExpressionStatement(body[0])) {\n        arg.body = toParenthesizedExpressionIfNeeded(body[0].expression);\n      }\n    } else if (import_compiler17.types.isNullLiteral(arg) || import_compiler17.types.isUnaryExpression(arg) && arg.operator === \"void\") {\n      args[i] = import_compiler17.types.numericLiteral(0);\n    }\n  }\n  for (let i = args.length - 1; import_compiler17.types.isNumericLiteral(args[i]) && args[i].value === 0; ) {\n    args.length = i--;\n  }\n  return args;\n}\nfunction addStatement(type, targetSection, referencedBindings, statement, usedReferences) {\n  const signal = getSignal(targetSection, referencedBindings);\n  const statements = signal[type] ??= [];\n  const add = type === \"effect\" ? addEffectReferences : addRenderReferences;\n  if (Array.isArray(statement)) {\n    statements.push(...statement);\n  } else {\n    statements.push(statement);\n  }\n  if (usedReferences !== false) {\n    if (usedReferences) {\n      for (const ref of usedReferences) {\n        add(signal, ref);\n      }\n    } else {\n      add(signal, referencedBindings);\n    }\n  }\n}\nfunction addEffectReferences(signal, referencedBindings) {\n  signal.effectReferencedBindings = bindingUtil.union(\n    signal.effectReferencedBindings,\n    referencedBindings\n  );\n}\nfunction addRenderReferences(signal, referencedBindings) {\n  signal.renderReferencedBindings = bindingUtil.union(\n    signal.renderReferencedBindings,\n    referencedBindings\n  );\n}\nfunction addValue(targetSection, referencedBindings, signal, value, scope = scopeIdentifier) {\n  getSignal(targetSection, referencedBindings).values.push({\n    signal,\n    value,\n    scope\n  });\n}\nfunction getResumeRegisterId(section, referencedBindings, type) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let name2 = \"\";\n  if (referencedBindings) {\n    if (typeof referencedBindings === \"string\") {\n      name2 += `_${referencedBindings}`;\n    } else if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        name2 += `_${ref.name}`;\n      }\n    } else {\n      name2 += `_${referencedBindings.name}`;\n    }\n  }\n  return (0, import_babel_utils9.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}${name2}${type ? \"/\" + type : \"\"}`\n  );\n}\nvar usedRegisterIdsBySection = /* @__PURE__ */ new WeakMap();\nfunction getRegisterUID(section, name2) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let used = usedRegisterIdsBySection.get(section);\n  if (!used) usedRegisterIdsBySection.set(section, used = /* @__PURE__ */ new Set());\n  const baseId = (0, import_babel_utils9.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}/${name2}`\n  );\n  let count = 0;\n  let id = baseId;\n  while (used.has(id)) {\n    id = baseId + \"_\" + ++count;\n  }\n  used.add(id);\n  return id;\n}\nfunction writeSignals(section) {\n  forEach(section.hoisted, (binding) => {\n    for (const hoistedBinding of binding.hoists.values()) {\n      const accessors = [\n        binding.type === 0 /* dom */ ? import_compiler17.types.stringLiteral(getScopeAccessor(binding) + \">\" /* Getter */) : getScopeAccessorLiteral(binding)\n      ];\n      let currentSection = section;\n      while (currentSection && currentSection !== hoistedBinding.section) {\n        const parentSection = currentSection.parent;\n        if (parentSection) {\n          accessors.push(getSectionInstancesAccessorLiteral(currentSection));\n        }\n        currentSection = parentSection;\n      }\n      const hoistIdentifier = getHoistFunctionIdentifier(hoistedBinding);\n      currentProgramPath.pushContainer(\n        \"body\",\n        import_compiler17.types.variableDeclaration(\"const\", [\n          import_compiler17.types.variableDeclarator(\n            hoistIdentifier,\n            hoistedBinding.downstreamExpressions.size ? callRuntime(\n              \"register\",\n              import_compiler17.types.stringLiteral(\n                getResumeRegisterId(\n                  hoistedBinding.section,\n                  hoistedBinding,\n                  \"hoist\"\n                )\n              ),\n              callRuntime(\"hoist\", ...accessors)\n            ) : callRuntime(\"hoist\", ...accessors)\n          )\n        ])\n      );\n      if (hoistedBinding.downstreamExpressions.size) {\n        addValue(\n          hoistedBinding.section,\n          void 0,\n          initValue(hoistedBinding),\n          import_compiler17.types.callExpression(hoistIdentifier, [scopeIdentifier])\n        );\n      }\n    }\n  });\n  const signals = [...getSignals(section).values()].sort(sortSignals);\n  for (const signal of signals) {\n    traverseReplace(signal, \"render\", replaceRenderNode);\n    for (const value2 of signal.values) {\n      traverseReplace(value2, \"value\", replaceRenderNode);\n    }\n    let effectDeclarator;\n    if (signal.effect.length) {\n      traverseReplace(signal, \"effect\", replaceEffectNode);\n      const effectIdentifier = import_compiler17.types.identifier(`${signal.identifier.name}_effect`);\n      const referencedBindings = signal.effectReferencedBindings;\n      const referencesScope = traverseContains(\n        signal.effect,\n        isScopeIdentifier\n      );\n      effectDeclarator = import_compiler17.types.variableDeclarator(\n        effectIdentifier,\n        callRuntime(\n          \"effect\",\n          import_compiler17.types.stringLiteral(\n            getResumeRegisterId(section, signal.referencedBindings)\n          ),\n          import_compiler17.types.arrowFunctionExpression(\n            referencedBindings ? referencesScope ? [\n              scopeIdentifier,\n              createScopeReadPattern(section, referencedBindings)\n            ] : [createScopeReadPattern(section, referencedBindings)] : referencesScope ? [scopeIdentifier] : [],\n            toFirstExpressionOrBlock(signal.effect)\n          )\n        )\n      );\n    }\n    let value = signal.build();\n    if (import_compiler17.types.isCallExpression(value)) {\n      replaceNullishAndEmptyFunctionsWith0(value.arguments);\n    }\n    if (signal.register) {\n      value = callRuntime(\n        \"registerBoundSignal\",\n        import_compiler17.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings, \"var\")\n        ),\n        value\n      );\n    }\n    const signalDeclarator = import_compiler17.types.variableDeclarator(signal.identifier, value);\n    let signalDeclaration = !section.parent && !signal.referencedBindings && (import_compiler17.types.isFunctionExpression(value) || import_compiler17.types.isArrowFunctionExpression(value)) ? import_compiler17.types.functionDeclaration(\n      signal.identifier,\n      value.params,\n      import_compiler17.types.isExpression(value.body) ? import_compiler17.types.blockStatement([import_compiler17.types.expressionStatement(value.body)]) : value.body\n    ) : import_compiler17.types.variableDeclaration(\"const\", [signalDeclarator]);\n    if (signal.export) {\n      signalDeclaration = import_compiler17.types.exportNamedDeclaration(signalDeclaration);\n    }\n    const signalStatements = signal.prependStatements || [];\n    if (effectDeclarator) {\n      signalStatements.push(import_compiler17.types.variableDeclaration(\"const\", [effectDeclarator]));\n    }\n    signalStatements.push(signalDeclaration);\n    currentProgramPath.pushContainer(\"body\", signalStatements);\n  }\n}\nfunction writeRegisteredFns() {\n  const registeredFns = registeredFnsForProgram.get(currentProgramPath.node);\n  const statements = [];\n  if (registeredFns) {\n    for (const registeredFn of registeredFns) {\n      let fn;\n      const params = registeredFn.referencedBindings ? registeredFn.referencesScope ? [\n        scopeIdentifier,\n        import_compiler17.types.assignmentPattern(\n          createScopeReadPattern(\n            registeredFn.section,\n            registeredFn.referencedBindings\n          ),\n          scopeIdentifier\n        )\n      ] : [\n        createScopeReadPattern(\n          registeredFn.section,\n          registeredFn.referencedBindings\n        )\n      ] : registeredFn.referencesScope ? [scopeIdentifier] : void 0;\n      if (params) {\n        fn = import_compiler17.types.functionDeclaration(\n          import_compiler17.types.identifier(registeredFn.id),\n          params,\n          import_compiler17.types.blockStatement(toReturnedFunction(registeredFn.node))\n        );\n      } else if (registeredFn.node.type === \"FunctionDeclaration\" && registeredFn.node.id?.name === registeredFn.id) {\n        fn = registeredFn.node;\n      } else {\n        fn = import_compiler17.types.functionDeclaration(\n          import_compiler17.types.identifier(registeredFn.id),\n          registeredFn.node.params,\n          registeredFn.node.body.type === \"BlockStatement\" ? registeredFn.node.body : import_compiler17.types.blockStatement([import_compiler17.types.returnStatement(registeredFn.node.body)]),\n          registeredFn.node.generator,\n          registeredFn.node.async\n        );\n      }\n      statements.push(fn);\n    }\n    for (const registeredFn of registeredFns) {\n      statements.push(\n        import_compiler17.types.expressionStatement(\n          callRuntime(\n            \"register\",\n            import_compiler17.types.stringLiteral(registeredFn.registerId),\n            import_compiler17.types.identifier(registeredFn.id)\n          )\n        )\n      );\n    }\n    for (const stmt of currentProgramPath.pushContainer(\"body\", statements)) {\n      stmt.skip();\n    }\n  }\n}\nfunction toReturnedFunction(rawFn) {\n  const fn = simplifyFunction(rawFn);\n  return fn.type === \"FunctionDeclaration\" ? [fn, import_compiler17.types.returnStatement(fn.id)] : [import_compiler17.types.returnStatement(fn)];\n}\nfunction sortSignals(a, b) {\n  const aReferencedBindings = getReferencedBindings(a);\n  const bReferencedBindings = getReferencedBindings(b);\n  for (let i = Math.max(aReferencedBindings.length, bReferencedBindings.length) - 1; i >= 0; i--) {\n    const diff = (bReferencedBindings[i] ?? -1) - (aReferencedBindings[i] ?? -1);\n    if (diff !== 0) return diff;\n  }\n  return 0;\n}\nfunction getReferencedBindings({ referencedBindings: reserve }) {\n  if (!reserve) {\n    return [];\n  } else if (Array.isArray(reserve)) {\n    return reserve.map(getMappedId).sort();\n  } else {\n    return [getMappedId(reserve)];\n  }\n}\nfunction getMappedId(reference) {\n  return (reference.type === 0 /* dom */ ? 1 : 0) * 1e4 + reference.id;\n}\nfunction addHTMLEffectCall(section, referencedBindings) {\n  addStatement(\"effect\", section, referencedBindings, void 0, false);\n}\nfunction writeHTMLResumeStatements(path5) {\n  const section = getSectionForBody(path5);\n  if (!section) return;\n  const allSignals = Array.from(getSignals(section).values());\n  const scopeIdIdentifier = getScopeIdIdentifier(section);\n  const serializeOwnersUntilBindingSection = (binding) => {\n    let currentSection = section;\n    while (currentSection !== binding.section) {\n      const currentSerialized = getSerializedScopeProperties(currentSection);\n      currentSection = currentSection.parent;\n      if (!currentSerialized.has(\"_\")) {\n        currentSerialized.set(\n          \"_\",\n          callRuntime(\n            \"ensureScopeWithId\",\n            getScopeIdIdentifier(currentSection)\n          )\n        );\n      }\n    }\n  };\n  forEach(section.assignments, serializeOwnersUntilBindingSection);\n  forEach(section.referencedHoists, serializeOwnersUntilBindingSection);\n  forEach(section.referencedClosures, (closure) => {\n    if (isStatefulReferences(closure)) {\n      serializeOwnersUntilBindingSection(closure);\n      setForceResumeScope(closure.section);\n      if (isDynamicClosure(section, closure)) {\n        const closureSignal = getSignal(closure.section, closure);\n        let identifier = htmlDynamicClosureInstancesIdentifier.get(closureSignal);\n        if (!identifier) {\n          htmlDynamicClosureInstancesIdentifier.set(\n            closureSignal,\n            identifier = currentProgramPath.scope.generateUidIdentifier(\n              closureSignal.identifier.name + \"_closures\"\n            )\n          );\n          getHTMLSectionStatements(closure.section).push(\n            import_compiler17.types.variableDeclaration(\"const\", [\n              import_compiler17.types.variableDeclarator(\n                identifier,\n                import_compiler17.types.newExpression(import_compiler17.types.identifier(\"Set\"), [])\n              )\n            ])\n          );\n          setSerializedProperty(\n            closure.section,\n            getScopeAccessor(closure) + \"!\" /* ClosureScopes */,\n            identifier\n          );\n        }\n        setSerializedProperty(\n          section,\n          getScopeAccessor(closure) + \"(\" /* ClosureSignalIndex */,\n          import_compiler17.types.numericLiteral(getDynamicClosureIndex(closure, section))\n        );\n        addWriteScopeBuilder(\n          section,\n          (expr) => callRuntime(\"writeSubscribe\", identifier, expr)\n        );\n      }\n    }\n  });\n  const sectionDynamicSubscribers = /* @__PURE__ */ new Set();\n  forEach(section.hoisted, (binding) => {\n    for (const hoistedBinding of binding.hoists.values()) {\n      if (hoistedBinding.downstreamExpressions.size) {\n        getHTMLSectionStatements(hoistedBinding.section).push(\n          import_compiler17.types.variableDeclaration(\"const\", [\n            import_compiler17.types.variableDeclarator(\n              import_compiler17.types.identifier(hoistedBinding.name),\n              callRuntime(\n                \"hoist\",\n                getScopeIdIdentifier(hoistedBinding.section),\n                import_compiler17.types.stringLiteral(\n                  getResumeRegisterId(\n                    hoistedBinding.section,\n                    hoistedBinding,\n                    \"hoist\"\n                  )\n                )\n              )\n            )\n          ])\n        );\n      }\n      let currentSection = section;\n      while (currentSection && currentSection !== hoistedBinding.section) {\n        const parentSection = currentSection.parent;\n        if (!currentSection.sectionAccessor && !sectionDynamicSubscribers.has(currentSection)) {\n          const subscribersIdentifier = currentProgramPath.scope.generateUidIdentifier(\n            `${currentSection.name}_subscribers`\n          );\n          sectionDynamicSubscribers.add(currentSection);\n          getHTMLSectionStatements(parentSection).push(\n            import_compiler17.types.variableDeclaration(\"const\", [\n              import_compiler17.types.variableDeclarator(\n                subscribersIdentifier,\n                import_compiler17.types.newExpression(import_compiler17.types.identifier(\"Set\"), [])\n              )\n            ])\n          );\n          addWriteScopeBuilder(\n            currentSection,\n            (expr) => callRuntime(\"writeSubscribe\", subscribersIdentifier, expr)\n          );\n          setSerializedProperty(\n            parentSection,\n            getSectionInstancesAccessor(currentSection),\n            subscribersIdentifier\n          );\n        }\n        currentSection = parentSection;\n      }\n    }\n    if (binding.hoists.size && binding.type !== 0 /* dom */) {\n      setSerializedProperty(\n        section,\n        getScopeAccessor(binding),\n        getDeclaredBindingExpression(binding)\n      );\n    }\n  });\n  for (let i = allSignals.length; i--; ) {\n    if (allSignals[i].effect.length) {\n      const signalRefs = allSignals[i].referencedBindings;\n      path5.pushContainer(\n        \"body\",\n        import_compiler17.types.expressionStatement(\n          callRuntime(\n            \"writeEffect\",\n            scopeIdIdentifier,\n            import_compiler17.types.stringLiteral(getResumeRegisterId(section, signalRefs))\n          )\n        )\n      );\n    }\n  }\n  const serializedLookup = getSerializedScopeProperties(section);\n  const serializedProperties = [];\n  forEach(section.bindings, (binding) => {\n    if (binding.serialize && binding.type !== 0 /* dom */) {\n      const accessor = getScopeAccessor(binding);\n      serializedLookup.delete(accessor);\n      serializedProperties.push(\n        toObjectProperty(accessor, getDeclaredBindingExpression(binding))\n      );\n    }\n  });\n  for (const [key, value] of serializedLookup) {\n    serializedProperties.push(toObjectProperty(key, value));\n  }\n  const writeScopeBuilder = getSectionWriteScopeBuilder(section);\n  if (writeScopeBuilder || serializedProperties.length || forceResumeScope(section)) {\n    for (const prop of serializedProperties) {\n      if (prop.key.type === \"Identifier\" && prop.value.type === \"Identifier\" && prop.key.name === prop.value.name) {\n        prop.shorthand = true;\n      }\n    }\n    const writeScopeArgs = [\n      scopeIdIdentifier,\n      import_compiler17.types.objectExpression(serializedProperties)\n    ];\n    if (!isOptimize()) {\n      let debugVars;\n      forEach(section.bindings, (binding) => {\n        if (!binding.serialize || binding.type === 0 /* dom */) return;\n        let root = binding;\n        let access = \"\";\n        while (!(root.loc || root.declared) && root.upstreamAlias) {\n          if (root.property !== void 0) {\n            access = toAccess(root.property) + access;\n          }\n          root = root.upstreamAlias;\n        }\n        const locExpr = root.loc && import_compiler17.types.stringLiteral(\n          `${root.loc.start.line}:${root.loc.start.column + 1}`\n        );\n        (debugVars ||= []).push(\n          toObjectProperty(\n            getScopeAccessor(binding),\n            root !== binding ? import_compiler17.types.arrayExpression(\n              locExpr ? [import_compiler17.types.stringLiteral(root.name + access), locExpr] : [import_compiler17.types.stringLiteral(root.name + access)]\n            ) : locExpr || import_compiler17.types.numericLiteral(0)\n          )\n        );\n      });\n      writeScopeArgs.push(\n        import_compiler17.types.stringLiteral(path5.hub.file.opts.filenameRelative),\n        section.loc && section.loc.start.line != null ? import_compiler17.types.stringLiteral(\n          `${section.loc.start.line}:${section.loc.start.column + 1}`\n        ) : import_compiler17.types.numericLiteral(0)\n      );\n      if (debugVars) {\n        writeScopeArgs.push(import_compiler17.types.objectExpression(debugVars));\n      }\n    }\n    path5.pushContainer(\n      \"body\",\n      import_compiler17.types.expressionStatement(\n        writeScopeBuilder ? writeScopeBuilder(callRuntime(\"writeScope\", ...writeScopeArgs)) : callRuntime(\"writeScope\", ...writeScopeArgs)\n      )\n    );\n  }\n  const resumeClosestBranch2 = !section.isBranch && (section.hasAbortSignal || !!section.referencedClosures || !!find(section.bindings, (binding) => binding.type === 1 /* let */));\n  if (resumeClosestBranch2) {\n    path5.pushContainer(\n      \"body\",\n      import_compiler17.types.expressionStatement(\n        callRuntime(\"resumeClosestBranch\", scopeIdIdentifier)\n      )\n    );\n  }\n  const additionalStatements = getHTMLSectionStatements(section);\n  if (path5.get(\"body\").length || additionalStatements.length) {\n    path5.unshiftContainer(\"body\", [\n      import_compiler17.types.variableDeclaration(\"const\", [\n        import_compiler17.types.variableDeclarator(scopeIdIdentifier, callRuntime(\"nextScopeId\"))\n      ]),\n      ...additionalStatements\n    ]);\n  }\n  const returnIdentifier = getSectionReturnValueIdentifier(section);\n  if (returnIdentifier !== void 0) {\n    path5.pushContainer(\"body\", import_compiler17.types.returnStatement(returnIdentifier));\n  }\n}\nfunction getSetup(section) {\n  return getSignals(section).get(void 0)?.identifier;\n}\nfunction replaceRenderNode(node) {\n  return replaceAssignedNode(node) || replaceBindingReadNode(node) || replaceRegisteredFunctionNode(node);\n}\nfunction replaceEffectNode(node) {\n  return replaceAssignedNode(node) || replaceBindingReadNode(node);\n}\nfunction replaceBindingReadNode(node) {\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\": {\n      return getReadReplacement(node);\n    }\n  }\n}\nfunction replaceAssignedNode(node) {\n  switch (node.type) {\n    case \"UpdateExpression\": {\n      const { extra } = node.argument;\n      if (isAssignedBindingExtra(extra)) {\n        const { buildAssignment } = getSignal(\n          extra.assignment.section,\n          extra.assignment\n        );\n        if (buildAssignment) {\n          const replacement = buildAssignment(\n            extra.section,\n            import_compiler17.types.binaryExpression(\n              node.operator === \"++\" ? \"+\" : \"-\",\n              node.argument,\n              import_compiler17.types.numericLiteral(1)\n            )\n          );\n          if (!node.prefix) {\n            return import_compiler17.types.sequenceExpression([replacement, node.argument]);\n          }\n          return replacement;\n        }\n      }\n      break;\n    }\n    case \"AssignmentExpression\":\n      switch (node.left.type) {\n        case \"Identifier\": {\n          const { extra } = node.left;\n          if (isAssignedBindingExtra(extra)) {\n            const { buildAssignment } = getSignal(\n              extra.assignment.section,\n              extra.assignment\n            );\n            if (buildAssignment) {\n              return buildAssignment(\n                extra.section,\n                node.operator === \"=\" ? node.right : import_compiler17.types.binaryExpression(\n                  node.operator.slice(\n                    0,\n                    -1\n                  ),\n                  node.left,\n                  node.right\n                )\n              );\n            }\n          }\n          break;\n        }\n        case \"ArrayPattern\":\n        case \"ObjectPattern\": {\n          let params;\n          let assignments;\n          forEachIdentifier(node.left, (id) => {\n            const { extra } = id;\n            if (isAssignedBindingExtra(extra)) {\n              const signal = getSignal(\n                extra.assignment.section,\n                extra.assignment\n              );\n              if (signal?.buildAssignment) {\n                id.name = currentProgramPath.scope.generateUid(id.name);\n                (params ||= []).push(import_compiler17.types.identifier(id.name));\n                (assignments ||= []).push(\n                  signal.buildAssignment(extra.section, import_compiler17.types.identifier(id.name))\n                );\n              }\n            }\n          });\n          if (params && assignments) {\n            const resultId = currentProgramPath.scope.generateUid(\"result\");\n            return import_compiler17.types.callExpression(\n              import_compiler17.types.arrowFunctionExpression(\n                [import_compiler17.types.identifier(resultId), ...params],\n                import_compiler17.types.sequenceExpression([\n                  import_compiler17.types.assignmentExpression(\n                    \"=\",\n                    node.left,\n                    import_compiler17.types.identifier(resultId)\n                  ),\n                  ...assignments,\n                  import_compiler17.types.identifier(resultId)\n                ])\n              ),\n              [node.right]\n            );\n          }\n          break;\n        }\n      }\n      break;\n  }\n}\nvar registeredFnsForProgram = /* @__PURE__ */ new WeakMap();\nfunction replaceRegisteredFunctionNode(node) {\n  switch (node.type) {\n    case \"ClassMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler17.types.classProperty(node.key, replacement);\n    }\n    case \"ClassPrivateMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler17.types.classPrivateProperty(node.key, replacement);\n    }\n    case \"ObjectMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler17.types.objectProperty(node.key, replacement);\n    }\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\": {\n      return getRegisteredFnExpression(node);\n    }\n    case \"FunctionDeclaration\": {\n      const replacement = getRegisteredFnExpression(node);\n      if (replacement) {\n        return import_compiler17.types.variableDeclaration(\"const\", [\n          import_compiler17.types.variableDeclarator(node.id, replacement)\n        ]);\n      }\n      break;\n    }\n  }\n}\nfunction getRegisteredFnExpression(node) {\n  const { extra } = node;\n  if (isRegisteredFnExtra(extra)) {\n    const id = currentProgramPath.scope.generateUid(extra.name);\n    const referencesScope = extra.referencesScope;\n    const referencedBindings = extra.referencedBindingsInFunction;\n    let registedFns = registeredFnsForProgram.get(currentProgramPath.node);\n    if (!registedFns) {\n      registeredFnsForProgram.set(currentProgramPath.node, registedFns = []);\n    }\n    registedFns.push({\n      id,\n      node,\n      registerId: extra.registerId,\n      section: extra.section,\n      referencesScope,\n      referencedBindings\n    });\n    if (referencesScope || referencedBindings) {\n      return import_compiler17.types.callExpression(import_compiler17.types.identifier(id), [scopeIdentifier]);\n    } else {\n      return import_compiler17.types.identifier(id);\n    }\n  }\n}\nfunction getDynamicClosureIndex(closure, closureSection) {\n  let index = 0;\n  find(closure.closureSections, (section) => {\n    if (section === closureSection) return true;\n    if (isDynamicClosure(section, closure)) {\n      index++;\n    }\n    return false;\n  });\n  return index;\n}\n\n// src/translator/visitors/program/dom.ts\nvar dom_default = {\n  translate: {\n    exit(program) {\n      visit(program);\n      const section = getSectionForBody(program);\n      const { walks, writes, setup } = getSectionMeta(section);\n      const domExports = program.node.extra.domExports;\n      const templateIdentifier = import_compiler18.types.identifier(domExports.template);\n      const walksIdentifier = import_compiler18.types.identifier(domExports.walks);\n      const setupIdentifier = import_compiler18.types.identifier(domExports.setup);\n      const inputBinding = program.node.params[0].extra?.binding;\n      const programInputSignal = inputBinding && bindingHasDownstreamExpressions(inputBinding) ? initValue(inputBinding) : void 0;\n      const styleFile = getStyleFile(program.hub.file);\n      if (styleFile) {\n        (0, import_babel_utils10.importDefault)(program.hub.file, styleFile);\n      }\n      forEachSectionReverse((childSection) => {\n        if (childSection !== section) {\n          const tagParamsSignal = childSection.params && initValue(childSection.params);\n          const { walks: walks2, writes: writes2, setup: setup2 } = getSectionMeta(childSection);\n          const identifier = import_compiler18.types.identifier(childSection.name);\n          const referencedClosures = childSection.referencedClosures ? import_compiler18.types.arrowFunctionExpression(\n            [scopeIdentifier],\n            toFirstExpressionOrBlock(\n              map(childSection.referencedClosures, (closure) => {\n                const closureSignal = getSignal(childSection, closure);\n                return import_compiler18.types.expressionStatement(\n                  import_compiler18.types.callExpression(\n                    isDynamicClosure(childSection, closure) ? closureSignal.identifier : import_compiler18.types.memberExpression(\n                      closureSignal.identifier,\n                      import_compiler18.types.identifier(\"_\")\n                    ),\n                    [scopeIdentifier]\n                  )\n                );\n              })\n            )\n          ) : void 0;\n          const renderer = getSectionParentIsOwner(childSection) ? callRuntime(\n            \"createRenderer\",\n            ...replaceNullishAndEmptyFunctionsWith0([\n              writes2,\n              walks2,\n              setup2,\n              tagParamsSignal?.identifier,\n              referencedClosures\n            ])\n          ) : callRuntime(\n            isSerializedSection(childSection) ? \"registerContent\" : \"createContent\",\n            import_compiler18.types.stringLiteral(getResumeRegisterId(childSection, \"renderer\")),\n            ...replaceNullishAndEmptyFunctionsWith0([\n              writes2,\n              walks2,\n              setup2,\n              tagParamsSignal?.identifier,\n              referencedClosures,\n              childSection.hoisted || childSection.isHoistThrough ? getSectionInstancesAccessorLiteral(childSection) : void 0\n            ])\n          );\n          writeSignals(childSection);\n          program.node.body.push(\n            import_compiler18.types.variableDeclaration(\"const\", [\n              import_compiler18.types.variableDeclarator(identifier, renderer)\n            ])\n          );\n        }\n      });\n      writeSignals(section);\n      writeRegisteredFns();\n      if (!setup) {\n        program.node.body.unshift(\n          import_compiler18.types.exportNamedDeclaration(\n            import_compiler18.types.variableDeclaration(\"const\", [\n              import_compiler18.types.variableDeclarator(\n                setupIdentifier,\n                import_compiler18.types.arrowFunctionExpression([], import_compiler18.types.blockStatement([]))\n              )\n            ])\n          )\n        );\n      }\n      program.node.body.unshift(\n        import_compiler18.types.exportNamedDeclaration(\n          import_compiler18.types.variableDeclaration(\"const\", [\n            import_compiler18.types.variableDeclarator(\n              templateIdentifier,\n              writes || import_compiler18.types.stringLiteral(\"\")\n            )\n          ])\n        ),\n        import_compiler18.types.exportNamedDeclaration(\n          import_compiler18.types.variableDeclaration(\"const\", [\n            import_compiler18.types.variableDeclarator(walksIdentifier, walks || import_compiler18.types.stringLiteral(\"\"))\n          ])\n        )\n      );\n      program.node.body.push(\n        import_compiler18.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            import_compiler18.types.stringLiteral(program.hub.file.metadata.marko.id),\n            templateIdentifier,\n            walksIdentifier,\n            setupIdentifier,\n            programInputSignal?.identifier\n          )\n        )\n      );\n    }\n  }\n};\n\n// src/translator/visitors/program/html.ts\nvar import_compiler19 = require(\"@marko/compiler\");\n\n// src/translator/util/is-static.ts\nfunction isStatic(path5) {\n  return path5.isImportDeclaration() || path5.isExportDeclaration() || path5.isMarkoScriptlet({ static: true });\n}\n\n// src/translator/visitors/program/html.ts\nvar templateContentIdentifierForProgram = /* @__PURE__ */ new WeakMap();\nfunction getTemplateContentName() {\n  let name2 = templateContentIdentifierForProgram.get(currentProgramPath);\n  if (!name2) {\n    templateContentIdentifierForProgram.set(\n      currentProgramPath,\n      name2 = currentProgramPath.scope.generateUid(\"content\")\n    );\n  }\n  return name2;\n}\nvar html_default = {\n  translate: {\n    exit(program) {\n      flushInto(program);\n      writeHTMLResumeStatements(program);\n      traverseReplace(program.node, \"body\", replaceNode);\n      const renderContent = [];\n      for (const child of program.get(\"body\")) {\n        if (!isStatic(child)) {\n          renderContent.push(child.node);\n          child.remove();\n        } else if (child.isMarkoScriptlet()) {\n          if (child.node.target && child.node.target !== \"server\") {\n            child.remove();\n          } else {\n            child.replaceWithMultiple(child.node.body);\n          }\n        }\n      }\n      const contentId = templateContentIdentifierForProgram.get(program);\n      const contentFn = import_compiler19.types.arrowFunctionExpression(\n        [import_compiler19.types.identifier(\"input\")],\n        import_compiler19.types.blockStatement(renderContent)\n      );\n      const exportDefault = import_compiler19.types.exportDefaultDeclaration(\n        callRuntime(\n          \"createTemplate\",\n          import_compiler19.types.stringLiteral(program.hub.file.metadata.marko.id),\n          contentId ? import_compiler19.types.identifier(contentId) : contentFn\n        )\n      );\n      program.pushContainer(\n        \"body\",\n        contentId ? [\n          import_compiler19.types.variableDeclaration(\"const\", [\n            import_compiler19.types.variableDeclarator(import_compiler19.types.identifier(contentId), contentFn)\n          ]),\n          exportDefault\n        ] : exportDefault\n      );\n    }\n  }\n};\nfunction replaceNode(node, container) {\n  return replaceBindingReadNode2(node) || replaceRegisteredFunctionNode2(node, container);\n}\nfunction replaceBindingReadNode2(node) {\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\": {\n      const { extra } = node;\n      if (extra && !(extra.read && !extra.read.binding.declared || extra.binding && !extra.binding.declared)) {\n        return getReadReplacement(node);\n      }\n    }\n  }\n}\nfunction replaceRegisteredFunctionNode2(node, container) {\n  switch (node.type) {\n    case \"ClassMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler19.types.classProperty(node.key, replacement);\n    }\n    case \"ClassPrivateMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler19.types.classPrivateProperty(node.key, replacement);\n    }\n    case \"ObjectMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler19.types.objectProperty(node.key, replacement);\n    }\n    case \"FunctionDeclaration\": {\n      const { extra } = node;\n      if (isRegisteredFnExtra(extra)) {\n        let registeredFnDeclarations = registeredFnDeclarationsByBody.get(\n          container\n        );\n        if (!registeredFnDeclarations) {\n          registeredFnDeclarationsByBody.set(\n            container,\n            registeredFnDeclarations = []\n          );\n        }\n        registeredFnDeclarations.push({\n          id: node.id.name,\n          registerId: extra.registerId\n        });\n      }\n      break;\n    }\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\": {\n      return getRegisteredFnExpression2(node);\n    }\n    case \"BlockStatement\":\n    case \"MarkoScriptlet\":\n      addRegisteredDeclarations(node.body);\n      break;\n  }\n}\nvar registeredFnDeclarationsByBody = /* @__PURE__ */ new WeakMap();\nfunction addRegisteredDeclarations(body) {\n  const registeredFnDeclarations = registeredFnDeclarationsByBody.get(body);\n  if (registeredFnDeclarations) {\n    for (const { id, registerId } of registeredFnDeclarations) {\n      body.push(\n        import_compiler19.types.expressionStatement(\n          callRuntime(\n            \"register\",\n            import_compiler19.types.identifier(id),\n            import_compiler19.types.stringLiteral(registerId)\n          )\n        )\n      );\n    }\n  }\n}\nfunction getRegisteredFnExpression2(node) {\n  const { extra } = node;\n  if (isRegisteredFnExtra(extra)) {\n    return callRuntime(\n      \"register\",\n      simplifyFunction(node),\n      import_compiler19.types.stringLiteral(extra.registerId),\n      (extra.referencedBindingsInFunction || extra.referencesScope) && getScopeIdIdentifier(extra.section)\n    );\n  }\n}\n\n// src/translator/visitors/program/index.ts\nvar currentProgramPath;\nvar cleanIdentifier;\nvar scopeIdentifier;\nfunction isScopeIdentifier(node) {\n  return node === scopeIdentifier;\n}\nvar previousProgramPath = /* @__PURE__ */ new WeakMap();\nvar program_default = {\n  migrate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      program.node.params = [import_compiler20.types.identifier(\"input\")];\n      currentProgramPath = program;\n    },\n    exit() {\n      currentProgramPath.scope.crawl();\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  analyze: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      startSection(program);\n      trackParamsReferences(program, 2 /* input */);\n      const inputBinding = program.node.params[0].extra?.binding;\n      if (inputBinding) {\n        inputBinding.nullable = false;\n      }\n      const { scope } = program;\n      (program.node.extra ??= {}).domExports = {\n        template: scope.generateUid(\"template_\"),\n        walks: scope.generateUid(\"walks_\"),\n        setup: scope.generateUid(\"setup_\"),\n        input: void 0,\n        // TODO look into recursive components with fine grained params.\n        closures: scope.generateUid(\"closures_\")\n      };\n    },\n    exit(program) {\n      finalizeReferences();\n      const programExtra = program.node.extra;\n      const inputBinding = program.node.params[0].extra?.binding;\n      if (inputBinding && bindingHasDownstreamExpressions(inputBinding)) {\n        programExtra.domExports.input = buildTemplateExports(inputBinding);\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  translate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      scopeIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"scope\") : null;\n      cleanIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"clean\") : null;\n      if (getMarkoOpts().output === \"hydrate\") {\n        const entryFile = program.hub.file;\n        const visitedFiles = /* @__PURE__ */ new Set([\n          (0, import_babel_utils11.resolveRelativePath)(entryFile, entryFile.opts.filename)\n        ]);\n        entry_builder_default.visit(entryFile, entryFile, function visitChild(resolved) {\n          if (!visitedFiles.has(resolved)) {\n            visitedFiles.add(resolved);\n            const file = (0, import_babel_utils11.loadFileForImport)(entryFile, resolved);\n            if (file) {\n              entry_builder_default.visit(\n                file,\n                entryFile,\n                (id) => visitChild(resolveRelativeToEntry(entryFile, file, id))\n              );\n            }\n          }\n        });\n        program.node.body = entry_builder_default.build(entryFile);\n        program.skip();\n        return;\n      }\n    },\n    exit(program) {\n      if (isOutputHTML()) {\n        html_default.translate.exit(program);\n      } else {\n        dom_default.translate.exit(program);\n      }\n      if (program.node.extra?.needsCompat) {\n        const compatFile = getCompatRuntimeFile();\n        const body = [void 0];\n        for (const child of program.node.body) {\n          if (child.type === \"ImportDeclaration\" && child.source.value === compatFile) {\n            body[0] = child;\n          } else {\n            body.push(child);\n          }\n        }\n        body[0] ??= import_compiler20.types.importDeclaration([], import_compiler20.types.stringLiteral(compatFile));\n        program.node.body = body;\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  }\n};\nfunction resolveRelativeToEntry(entryFile, file, req) {\n  return file === entryFile ? (0, import_babel_utils11.resolveRelativePath)(file, req) : (0, import_babel_utils11.resolveRelativePath)(\n    entryFile,\n    req[0] === \".\" ? import_path2.default.join(file.opts.filename, \"..\", req) : req\n  );\n}\nfunction buildTemplateExports(binding) {\n  const templateExport = {\n    id: binding.export ??= currentProgramPath.scope.generateUid(\n      binding.name + \"_\"\n    ),\n    binding,\n    props: void 0\n  };\n  if (!(binding.aliases.size || binding.downstreamExpressions.size)) {\n    templateExport.props = {};\n    for (const [property, alias] of binding.propertyAliases) {\n      templateExport.props[property] = buildTemplateExports(alias);\n    }\n  }\n  return templateExport;\n}\n\n// src/translator/util/get-root.ts\nfunction getMarkoRoot(path5) {\n  let curPath = path5;\n  do\n    curPath = curPath.parentPath;\n  while (curPath && !isMarko(curPath));\n  return curPath;\n}\nfunction getExprRoot(path5) {\n  let curPath = path5;\n  while (!isMarko(curPath.parentPath)) {\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction getFnRoot(path5) {\n  let curPath = path5;\n  let fnPath;\n  if (curPath.isProgram()) return;\n  while (!isMarko(curPath)) {\n    if (isFunction(curPath)) {\n      fnPath = curPath;\n    } else {\n      switch (curPath.type) {\n        case \"CallExpression\":\n        case \"NewExpression\":\n          fnPath = void 0;\n          break;\n      }\n    }\n    curPath = curPath.parentPath;\n  }\n  return fnPath;\n}\nfunction isMarko(path5) {\n  switch (path5.type) {\n    case \"MarkoTag\":\n    case \"MarkoTagBody\":\n    case \"MarkoAttribute\":\n    case \"MarkoSpreadAttribute\":\n    case \"MarkoPlaceholder\":\n    case \"MarkoScriptlet\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isFunction(path5) {\n  switch (path5.type) {\n    case \"FunctionDeclaration\":\n      return !path5.node.declare;\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ObjectMethod\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// src/translator/util/is-invoked-function.ts\nvar import_compiler21 = require(\"@marko/compiler\");\nfunction isInvokedFunction(expr) {\n  let curPath = expr;\n  while (curPath) {\n    const { parent, node } = curPath;\n    switch (parent.type) {\n      case \"CallExpression\":\n        return parent.callee === node;\n      case \"TSNonNullExpression\":\n        curPath = curPath.parentPath;\n        break;\n      default:\n        return false;\n    }\n  }\n  return false;\n}\n\n// src/translator/util/with-previous-location.ts\nfunction withPreviousLocation(newNode, originalNode) {\n  newNode.start = originalNode.start;\n  newNode.loc = originalNode.loc;\n  newNode.end = originalNode.end;\n  return newNode;\n}\n\n// src/translator/util/references.ts\nvar kIsInvoked = Symbol(\"hoist is invoked\");\nvar [getBindings] = createProgramState(() => /* @__PURE__ */ new Set());\nvar [getNextBindingId, setNextBindingId] = createProgramState(() => 0);\nfunction createBinding(name2, type, section, upstreamAlias, upstreamExpression, property, loc = null, declared = false) {\n  const id = getNextBindingId();\n  const binding = {\n    id,\n    name: name2,\n    type,\n    loc,\n    section,\n    property,\n    declared,\n    closureSections: void 0,\n    excludeProperties: void 0,\n    serialize: false,\n    sources: /* @__PURE__ */ new Set(),\n    aliases: /* @__PURE__ */ new Set(),\n    hoists: /* @__PURE__ */ new Map(),\n    propertyAliases: /* @__PURE__ */ new Map(),\n    upstreamAlias,\n    upstreamExpression,\n    downstreamExpressions: /* @__PURE__ */ new Set(),\n    scopeOffset: void 0,\n    export: void 0,\n    nullable: !upstreamExpression?.confident || upstreamExpression.computed == null\n  };\n  if (property) {\n    if (declared) upstreamAlias.nullable = false;\n    const propBinding = upstreamAlias.propertyAliases.get(property);\n    if (propBinding) {\n      binding.property = void 0;\n      binding.upstreamAlias = propBinding;\n      propBinding.aliases.add(binding);\n    } else {\n      upstreamAlias.propertyAliases.set(property, binding);\n    }\n  } else if (upstreamAlias) {\n    upstreamAlias.aliases.add(binding);\n  }\n  setNextBindingId(id + 1);\n  getBindings().add(binding);\n  return binding;\n}\nfunction trackVarReferences(tag, type, upstreamAlias, upstreamExpression) {\n  const tagVar = tag.node.var;\n  if (tagVar) {\n    const section = getOrCreateSection(tag);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    if (upstreamAlias && upstreamExpression) upstreamExpression.pruned = true;\n    createBindingsAndTrackReferences(\n      tagVar,\n      type,\n      tag.scope,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0\n    );\n  }\n}\nfunction trackParamsReferences(body, type, upstreamAlias, upstreamExpression) {\n  const params = body.node.params;\n  if (body.node.body.length && params.length) {\n    if (upstreamAlias && upstreamExpression) upstreamExpression.pruned = true;\n    const section = getOrCreateSection(body);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    const paramsBinding = canonicalUpstreamAlias || ((body.node.extra ??= {}).binding = createBinding(\n      currentProgramPath.scope.generateUid(\"params_\"),\n      type,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0\n    ));\n    section.params = paramsBinding;\n    for (let i = 0; i < params.length; i++) {\n      createBindingsAndTrackReferences(\n        params[i],\n        type,\n        body.scope,\n        section,\n        paramsBinding,\n        upstreamExpression,\n        i + \"\"\n      );\n    }\n  }\n}\nfunction trackHoistedReference(referencePath, binding) {\n  const section = binding.section;\n  const referenceSection = getOrCreateSection(referencePath);\n  const hoistSection = getCommonSection(referenceSection, section);\n  const extra = referencePath.node.extra ??= {};\n  let hoistedBinding = binding.hoists.get(hoistSection);\n  if (!hoistedBinding) {\n    binding.hoists.set(\n      hoistSection,\n      hoistedBinding = createBinding(\n        currentProgramPath.scope.generateUid(\n          \"hoisted_\" + referencePath.node.name\n        ),\n        5 /* hoist */,\n        hoistSection,\n        void 0,\n        void 0,\n        void 0,\n        binding.loc,\n        true\n      )\n    );\n    section.hoisted = bindingUtil.add(section.hoisted, binding);\n    let currentSection = section.parent;\n    while (currentSection && currentSection !== hoistSection) {\n      currentSection.isHoistThrough = true;\n      currentSection = currentSection.parent;\n    }\n  }\n  extra.hoistedBinding = hoistedBinding;\n  if (isInvokedFunction(referencePath)) {\n    extra.read = createRead(hoistedBinding, void 0);\n    extra.section = referenceSection;\n    extra[kIsInvoked] = true;\n  } else {\n    trackReference(referencePath, hoistedBinding);\n  }\n  referenceSection.referencedHoists = bindingUtil.add(\n    referenceSection.referencedHoists,\n    hoistedBinding\n  );\n}\nfunction trackReferencesForBinding(babelBinding) {\n  const { identifier, referencePaths, constantViolations } = babelBinding;\n  const binding = identifier.extra.binding;\n  for (const referencePath of referencePaths) {\n    const referenceSection = getOrCreateSection(referencePath);\n    if (isSameOrChildSection(binding.section, referenceSection)) {\n      trackReference(referencePath, binding);\n    } else {\n      trackHoistedReference(referencePath, binding);\n    }\n  }\n  for (const ref of constantViolations) {\n    if (ref.isUpdateExpression()) {\n      trackAssignment(ref.get(\"argument\"), binding);\n    } else if (ref.isAssignmentExpression()) {\n      trackAssignment(ref.get(\"left\"), binding);\n      if (ref.node.operator !== \"=\") {\n        const left = ref.get(\"left\");\n        if (left.isIdentifier()) {\n          trackReference(left, binding);\n        }\n      }\n    }\n  }\n}\nfunction trackAssignment(assignment, binding) {\n  const section = getOrCreateSection(assignment);\n  setReferencesScope(assignment);\n  forEachIdentifier(assignment.node, (id) => {\n    if (id.name === binding.name) {\n      const extra = id.extra ??= {};\n      section.assignments = bindingUtil.add(section.assignments, binding);\n      extra.assignment = binding;\n      extra.section = section;\n    }\n  });\n}\nfunction setReferencesScope(path5) {\n  const fnRoot = getFnRoot(path5);\n  if (fnRoot) {\n    (fnRoot.node.extra ??= {}).referencesScope = true;\n  }\n}\nfunction createBindingsAndTrackReferences(lVal, type, scope, section, upstreamAlias, upstreamExpression, property) {\n  switch (lVal.type) {\n    case \"Identifier\":\n      (lVal.extra ??= {}).binding = createBinding(\n        lVal.name,\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property,\n        lVal.loc,\n        true\n      );\n      trackReferencesForBinding(scope.getBinding(lVal.name));\n      break;\n    case \"ObjectPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        currentProgramPath.scope.generateUid(\"pattern_\"),\n        type,\n        section,\n        upstreamAlias,\n        void 0,\n        property,\n        lVal.loc\n      ));\n      for (const prop of lVal.properties) {\n        if (prop.type === \"RestElement\") {\n          createBindingsAndTrackReferences(\n            prop.argument,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            property\n          );\n        } else {\n          let key;\n          if (prop.key.type === \"Identifier\") {\n            key = prop.key.name;\n          } else if (prop.key.type === \"StringLiteral\") {\n            key = prop.key.value;\n          } else {\n            throw new Error(\"computed keys not supported in object pattern\");\n          }\n          createBindingsAndTrackReferences(\n            prop.value,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            key\n          );\n        }\n      }\n      break;\n    }\n    case \"ArrayPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        currentProgramPath.scope.generateUid(\"pattern_\"),\n        type,\n        section,\n        upstreamAlias,\n        void 0,\n        property,\n        lVal.loc\n      ));\n      let i = -1;\n      for (const element of lVal.elements) {\n        i++;\n        if (element) {\n          if (element.type === \"RestElement\") {\n            createBindingsAndTrackReferences(\n              element.argument,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              property\n            );\n          } else {\n            createBindingsAndTrackReferences(\n              element,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              `${i}`\n            );\n          }\n        }\n      }\n      break;\n    }\n    case \"AssignmentPattern\":\n      createBindingsAndTrackReferences(\n        lVal.left,\n        type,\n        scope,\n        section,\n        upstreamAlias,\n        void 0,\n        property\n      );\n      break;\n  }\n}\nfunction trackReference(referencePath, binding) {\n  let root = referencePath;\n  let reference = binding;\n  let propPath = binding.name;\n  while (true) {\n    const { parent } = root;\n    if (!import_compiler22.types.isMemberExpression(parent)) break;\n    const prop = getMemberExpressionPropString(parent);\n    if (prop === void 0) break;\n    if (reference.propertyAliases.has(prop)) {\n      root = root.parentPath;\n      reference = reference.propertyAliases.get(prop);\n      propPath = reference.name;\n      continue;\n    }\n    if (root.parentPath.parentPath.isCallExpression() && !isEventOrChangeHandler(prop)) {\n      break;\n    }\n    root = root.parentPath;\n    reference = createBinding(\n      propPath += `_${prop.replace(/[^a-zA-Z0-9_$]/g, \"_\")}`,\n      reference.type,\n      reference.section,\n      reference,\n      void 0,\n      prop\n    );\n  }\n  const fnRoot = getFnRoot(root);\n  const exprRoot = getExprRoot(fnRoot || root);\n  const { section } = addReadToExpression(exprRoot, reference, root.node);\n  if (fnRoot) {\n    const readsByFn = getReadsByFunction();\n    const fnExtra = fnRoot.node.extra ??= {};\n    fnExtra.section = section;\n    readsByFn.set(\n      fnExtra,\n      push(readsByFn.get(fnExtra), {\n        binding: reference,\n        node: root.node\n      })\n    );\n  }\n}\nvar [getMergedReferences] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction mergeReferences(section, target, nodes) {\n  (target.extra ??= {}).section = section;\n  getMergedReferences().set(target, nodes);\n}\nfunction compareIntersections(a, b) {\n  const len = a.length;\n  const lenDelta = len - b.length;\n  if (lenDelta !== 0) {\n    return lenDelta;\n  }\n  for (let i = 0; i < len; i++) {\n    const compareResult = bindingUtil.compare(a[i], b[i]);\n    if (compareResult !== 0) {\n      return compareResult;\n    }\n  }\n  return 0;\n}\nfunction finalizeReferences() {\n  const bindings = getBindings();\n  const readsByExpression = getReadsByExpression();\n  const readsByFn = getReadsByFunction();\n  const mergedReferences = getMergedReferences();\n  if (mergedReferences.size) {\n    for (const [target, nodes] of mergedReferences) {\n      const targetExtra = target.extra;\n      let reads = readsByExpression.get(targetExtra);\n      let { isEffect } = targetExtra;\n      for (const node of nodes) {\n        const extra = node?.extra;\n        if (isReferencedExtra(extra)) {\n          isEffect ||= extra.isEffect;\n          const additionalReads = readsByExpression.get(extra);\n          if (additionalReads) {\n            reads = concat(reads, additionalReads);\n            readsByExpression.delete(extra);\n          }\n        }\n      }\n      readsByExpression.set(targetExtra, reads);\n      targetExtra.isEffect = isEffect;\n    }\n  }\n  const intersectionsBySection = /* @__PURE__ */ new Map();\n  for (const [expr, reads] of readsByExpression) {\n    if (isReferencedExtra(expr)) {\n      expr.referencedBindings = resolveReferencedBindings(\n        expr,\n        reads,\n        intersectionsBySection\n      );\n      forEach(expr.referencedBindings, (binding) => {\n        binding.downstreamExpressions.add(expr);\n      });\n    }\n  }\n  for (const [fn, reads] of readsByFn) {\n    fn.referencedBindingsInFunction = resolveReferencedBindings(\n      fn,\n      reads,\n      intersectionsBySection\n    );\n    forEach(fn.referencedBindingsInFunction, (binding) => {\n      binding.serialize = true;\n    });\n  }\n  for (const binding of bindings) {\n    if (binding.type !== 0 /* dom */ && !binding.upstreamAlias) {\n      pruneBinding(bindings, binding);\n    }\n  }\n  for (const binding of bindings) {\n    const { name: name2, section } = binding;\n    if (binding.type !== 0 /* dom */) {\n      resolveBindingSources(binding);\n      if (find(section.bindings, ({ name: name3 }) => name3 === binding.name)) {\n        binding.name = currentProgramPath.scope.generateUid(name2);\n      }\n    }\n    section.bindings = bindingUtil.add(section.bindings, binding);\n    for (const {\n      referencedBindings,\n      isEffect,\n      section: section2\n    } of binding.downstreamExpressions) {\n      if (section2 !== binding.section) {\n        binding.closureSections = sectionUtil.add(\n          binding.closureSections,\n          section2\n        );\n        section2.referencedClosures = bindingUtil.add(\n          section2.referencedClosures,\n          binding\n        );\n      }\n      if (isEffect) {\n        forEach(referencedBindings, (bindingReference) => {\n          bindingReference.serialize = true;\n        });\n      }\n    }\n  }\n  forEachSection((section) => {\n    const intersections = intersectionsBySection.get(section);\n    if (intersections) {\n      for (const intersection of intersections) {\n        const numReferences = intersection.length;\n        for (let i = 0; i < numReferences - 1; i++) {\n          for (let j = i + 1; j < numReferences; j++) {\n            const binding1 = intersection[i];\n            const binding2 = intersection[j];\n            if (!binding1.serialize && !isSuperset(binding1.sources, binding2.sources)) {\n              binding1.serialize = true;\n            }\n            if (!binding2.serialize && !isSuperset(binding2.sources, binding1.sources)) {\n              binding2.serialize = true;\n            }\n          }\n        }\n      }\n    }\n    forEach(section.referencedClosures, (binding) => {\n      if (!binding.serialize) {\n        let serialize = false;\n        const sourceSection = binding.section;\n        let currentSection = section;\n        while (currentSection !== sourceSection && !(serialize = !currentSection.upstreamExpression || isStatefulReferences(\n          currentSection.upstreamExpression.referencedBindings\n        ))) {\n          currentSection = currentSection.parent;\n        }\n        binding.serialize = serialize;\n      }\n    });\n  });\n  forEachSection((section) => {\n    let intersectionIndex = 0;\n    const intersections = intersectionsBySection.get(section) || [];\n    const { id, bindings: bindings2 } = section;\n    const isOwnedBinding = ({ section: section2 }) => section2.id === id;\n    let lastBindingIndex = 0;\n    let intersection;\n    forEach(filter(bindings2, isOwnedBinding), (binding, bindingIndex) => {\n      binding.id = (lastBindingIndex = bindingIndex) + intersectionIndex;\n      while (intersectionIndex < intersections.length && (intersection = intersections[intersectionIndex]).filter(isOwnedBinding).at(-1) === binding) {\n        intersectionMeta.set(intersection, {\n          id: bindingIndex + ++intersectionIndex,\n          scopeOffset: getMaxOwnSourceOffset(intersection, section)\n        });\n      }\n    });\n    while (intersectionIndex < intersections.length) {\n      intersection = intersections[intersectionIndex];\n      intersectionMeta.set(intersection, {\n        id: lastBindingIndex + ++intersectionIndex,\n        scopeOffset: getMaxOwnSourceOffset(intersection, section)\n      });\n    }\n  });\n  mergedReferences.clear();\n  readsByExpression.clear();\n  readsByFn.clear();\n}\nfunction getMaxOwnSourceOffset(intersection, section) {\n  let scopeOffset;\n  for (const binding of intersection) {\n    if (binding.section === section) {\n      for (const sourceBinding of binding.sources) {\n        if (sourceBinding.scopeOffset && (!scopeOffset || scopeOffset.id < sourceBinding.scopeOffset.id)) {\n          scopeOffset = sourceBinding.scopeOffset;\n        }\n      }\n    }\n  }\n  return scopeOffset;\n}\nvar intersectionMeta = /* @__PURE__ */ new WeakMap();\nfunction isSuperset(set, subset) {\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction resolveBindingSources(binding) {\n  const derived = /* @__PURE__ */ new Set();\n  const { sources } = binding;\n  crawl(binding);\n  function crawl(binding2) {\n    if (binding2.type === 4 /* derived */ || binding2.type === 3 /* param */) {\n      let alias;\n      let curBinding = binding2;\n      while (alias = curBinding.upstreamAlias) {\n        curBinding = alias;\n      }\n      if (curBinding.upstreamExpression) {\n        if (derived.has(curBinding)) return;\n        derived.add(curBinding);\n        forEach(curBinding.upstreamExpression.referencedBindings, crawl);\n      } else if (curBinding.type === 2 /* input */) {\n        sources.add(binding2);\n      } else {\n        sources.add(curBinding);\n      }\n    } else {\n      sources.add(binding2);\n    }\n  }\n}\nvar bindingUtil = new Sorted(function compareBindings(a, b) {\n  return a.section.id - b.section.id || a.type !== b.type && (a.type === 0 /* dom */ || b.type === 0 /* dom */) ? a.type - b.type || a.id - b.id : a.id - b.id;\n});\nvar [getReadsByExpression] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nvar [getReadsByFunction] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction addReadToExpression(path5, binding, node) {\n  const exprExtra = path5.node.extra ??= {};\n  const readsByExpression = getReadsByExpression();\n  exprExtra.section = getOrCreateSection(path5);\n  readsByExpression.set(\n    exprExtra,\n    push(readsByExpression.get(exprExtra), { binding, node })\n  );\n  return exprExtra;\n}\nfunction dropReferences(node) {\n  if (Array.isArray(node)) {\n    for (const item of node) {\n      (item.extra ??= {}).pruned = true;\n    }\n  } else {\n    (node.extra ??= {}).pruned = true;\n  }\n}\nfunction getCanonicalBinding(binding) {\n  return binding && (binding.property ? binding : binding.upstreamAlias || binding);\n}\nfunction getAllTagReferenceNodes(tag, referenceNodes = []) {\n  if (tag.arguments) {\n    for (const arg of tag.arguments) {\n      referenceNodes.push(arg);\n    }\n  }\n  for (const attr2 of tag.attributes) {\n    referenceNodes.push(attr2.value);\n  }\n  for (const child of tag.body.attributeTags ? tag.body.body : tag.attributeTags) {\n    switch (child.type) {\n      case \"MarkoTag\":\n        getAllTagReferenceNodes(child, referenceNodes);\n        break;\n      case \"MarkoScriptlet\":\n        for (const statement of child.body) {\n          referenceNodes.push(statement);\n        }\n        break;\n    }\n  }\n  return referenceNodes;\n}\nfunction getScopeAccessorLiteral(binding, includeId) {\n  if (isOptimize()) {\n    return import_compiler22.types.numericLiteral(binding.id);\n  }\n  return import_compiler22.types.stringLiteral(\n    binding.name + (includeId || binding.type === 0 /* dom */ ? `/${binding.id}` : \"\")\n  );\n}\nfunction getScopeAccessor(binding, includeId) {\n  if (isOptimize()) {\n    return binding.id + \"\";\n  }\n  return binding.name + (includeId || binding.type === 0 /* dom */ ? `/${binding.id}` : \"\");\n}\nfunction getSectionInstancesAccessor(section) {\n  return section.sectionAccessor ? getScopeAccessor(section.sectionAccessor.binding) + section.sectionAccessor.suffix : section.id + \"!\" /* ClosureScopes */;\n}\nfunction getSectionInstancesAccessorLiteral(section) {\n  const accessor = getSectionInstancesAccessor(section);\n  return accessor ? typeof accessor === \"number\" ? import_compiler22.types.numericLiteral(accessor) : import_compiler22.types.stringLiteral(accessor) : void 0;\n}\nfunction getReadReplacement(node) {\n  const { extra } = node;\n  if (!extra) return;\n  let { binding, read } = extra;\n  let replacement;\n  if (read) {\n    if (read.props === void 0) {\n      binding = read.binding;\n      read = void 0;\n    } else {\n      binding = void 0;\n    }\n  }\n  if (binding) {\n    if (node.type === \"Identifier\") {\n      if (binding.type === 5 /* hoist */) {\n        replacement = node.extra?.[kIsInvoked] ? import_compiler22.types.callExpression(getHoistFunctionIdentifier(binding), [\n          getScopeExpression(node.extra.section, binding.section)\n        ]) : import_compiler22.types.identifier(getScopeAccessor(binding));\n      } else if (binding.name !== node.name) {\n        node.name = binding.name;\n      }\n    } else {\n      replacement = import_compiler22.types.identifier(binding.name);\n    }\n  } else if (read) {\n    replacement = toMemberExpression(\n      import_compiler22.types.identifier(read.binding.name),\n      Array.isArray(read.props) ? read.props[0] : read.props\n    );\n    if (Array.isArray(read.props)) {\n      for (let i = 1; i < read.props.length; i++) {\n        replacement = toMemberExpression(replacement, read.props[i]);\n      }\n    }\n  }\n  return replacement && withPreviousLocation(replacement, node);\n}\nfunction pruneBinding(bindings, binding) {\n  let shouldPrune = !binding.downstreamExpressions.size;\n  for (const alias of binding.aliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.aliases.delete(alias);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  for (const [key, alias] of binding.propertyAliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.propertyAliases.delete(key);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  if (shouldPrune) {\n    bindings.delete(binding);\n  }\n  return shouldPrune;\n}\nfunction resolveReferencedBindings(expr, reads, intersectionsBySection) {\n  let referencedBindings;\n  if (Array.isArray(reads)) {\n    for (const read of reads) {\n      let { binding } = read;\n      if (read.node) {\n        const exprReference = (read.node.extra ??= {}).read ??= resolveExpressionReference(reads, binding, void 0);\n        ({ binding } = (read.node.extra ??= {}).read = exprReference);\n      }\n      referencedBindings = bindingUtil.add(referencedBindings, binding);\n    }\n  } else if (reads) {\n    if (reads.node) {\n      (reads.node.extra ??= {}).read = createRead(reads.binding, void 0);\n    }\n    referencedBindings = reads.binding;\n  }\n  if (Array.isArray(referencedBindings)) {\n    const intersections = intersectionsBySection.get(expr.section) || [];\n    const intersection = findSorted(\n      compareIntersections,\n      intersections,\n      referencedBindings\n    );\n    if (intersection) {\n      referencedBindings = intersection;\n    } else {\n      intersectionsBySection.set(\n        expr.section,\n        addSorted(compareIntersections, intersections, referencedBindings)\n      );\n    }\n  }\n  return referencedBindings;\n}\nfunction resolveExpressionReference(reads, readBinding, readProps) {\n  const { upstreamAlias } = readBinding;\n  if (upstreamAlias && Array.isArray(reads)) {\n    const prop = getCanonicalProperty(readBinding);\n    const aliasProps = prop === void 0 ? readProps : push(readProps, prop);\n    for (const { binding } of reads) {\n      if (binding !== readBinding) {\n        let alias = upstreamAlias;\n        while (alias) {\n          if (binding === alias) {\n            return resolveExpressionReference(reads, alias, aliasProps);\n          }\n          alias = alias.upstreamAlias;\n        }\n      }\n    }\n  }\n  return createRead(readBinding, readProps);\n}\nfunction getCanonicalProperty(binding) {\n  return binding.property ?? binding.upstreamAlias?.property;\n}\nfunction createRead(binding, props) {\n  return { binding, props };\n}\nfunction getMemberExpressionPropString(expr) {\n  switch (expr.property.type) {\n    case \"StringLiteral\":\n      return expr.property.value;\n    case \"NumericLiteral\":\n      return \"\" + expr.property.value;\n    case \"Identifier\":\n      if (expr.computed) return;\n      return expr.property.name;\n  }\n}\nfunction isEventOrChangeHandler(prop) {\n  return /^on[-A-Z][a-zA-Z0-9_$]|[a-zA-Z_$][a-zA-Z0-9_$]*Change$/.test(prop);\n}\nfunction isReferencedExtra(extra) {\n  return !!(extra && !extra.pruned && extra.section);\n}\nfunction isAssignedBindingExtra(extra) {\n  return isReferencedExtra(extra) && extra.assignment !== void 0;\n}\nfunction isRegisteredFnExtra(extra) {\n  return isReferencedExtra(extra) && extra.registerId !== void 0;\n}\n\n// src/translator/util/is-stateful.ts\nfunction isStatefulReferences(referencedBindings) {\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        if (isStatefulBinding(ref)) {\n          return true;\n        }\n      }\n    } else {\n      return isStatefulBinding(referencedBindings);\n    }\n  }\n  return false;\n}\nfunction isStatefulBinding(binding) {\n  switch (binding.type) {\n    case 1 /* let */:\n    case 2 /* input */:\n      return true;\n    default:\n      return binding.upstreamAlias ? isStatefulBinding(binding.upstreamAlias) : !binding.upstreamExpression || isStatefulReferences(binding.upstreamExpression.referencedBindings);\n  }\n}\n\n// src/translator/core/await.ts\nvar await_default = {\n  analyze(tag) {\n    (0, import_babel_utils12.assertNoVar)(tag);\n    (0, import_babel_utils12.assertNoArgs)(tag);\n    assertNoSpreadAttrs(tag);\n    (0, import_babel_utils12.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `await` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler23.types.isMarkoAttribute(valueAttr) || valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `await` tag only supports the `value` attribute.\"\n      );\n    }\n    if (!node.body.body.length) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `await` tag requires body content.\");\n    }\n    if (node.body.params.length && (node.body.params.length > 1 || import_compiler23.types.isSpreadElement(node.body.params[0]))) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `await` tag only supports a single parameter.\"\n      );\n    }\n    getOrCreateSection(tag);\n    trackParamsReferences(\n      tag.get(\"body\"),\n      4 /* derived */,\n      void 0,\n      evaluate(valueAttr.value)\n    );\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        flushBefore(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const [valueAttr] = node.attributes;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (isStatefulReferences(valueAttr.extra?.referencedBindings) || checkStatefulClosures(bodySection, true)) {\n          setForceResumeScope(bodySection);\n        }\n        flushInto(tag);\n        writeHTMLResumeStatements(tagBody);\n        tag.replaceWith(\n          import_compiler23.types.expressionStatement(\n            callRuntime(\n              \"fork\",\n              valueAttr.value,\n              import_compiler23.types.arrowFunctionExpression(\n                node.body.params,\n                toFirstExpressionOrBlock(node.body.body)\n              )\n            )\n          )\n        )[0].skip();\n      }\n    },\n    dom: {\n      enter(tag) {\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n      },\n      exit(tag) {\n        tag.remove();\n      }\n    }\n  }),\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to consume asynchronous an data.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#await\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/await.d.marko\"\n};\n\n// src/translator/core/client.ts\nvar import_compiler24 = require(\"@marko/compiler\");\nvar import_babel_utils13 = require(\"@marko/compiler/babel-utils\");\nvar client_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^client\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils13.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler24.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler24.types.markoScriptlet(body, true, \"client\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"client <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the client.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#client-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/const.ts\nvar import_compiler26 = require(\"@marko/compiler\");\nvar import_babel_utils14 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/translate-var.ts\nvar import_compiler25 = require(\"@marko/compiler\");\nfunction translateVar(tag, initialValue, kind = \"const\") {\n  const {\n    node: { var: tagVar }\n  } = tag;\n  if (!tagVar) {\n    return;\n  }\n  tag.insertBefore(\n    import_compiler25.types.variableDeclaration(kind, [import_compiler25.types.variableDeclarator(tagVar, initialValue)])\n  );\n}\n\n// src/translator/core/const.ts\nvar const_default = {\n  analyze(tag) {\n    (0, import_babel_utils14.assertNoArgs)(tag);\n    (0, import_babel_utils14.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a tag variable.\");\n    }\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler26.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `const` tag only supports the `value` attribute.\"\n      );\n    }\n    const upstreamAlias = import_compiler26.types.isIdentifier(valueAttr.value) ? tag.scope.getBinding(valueAttr.value.name)?.identifier.extra?.binding : void 0;\n    trackVarReferences(\n      tag,\n      4 /* derived */,\n      upstreamAlias,\n      evaluate(valueAttr.value)\n      // TODO could perform a more extensive \"nullable\" check.\n    );\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      const { value } = valueAttr;\n      if (isOutputDOM()) {\n        const section = getSection(tag);\n        const varBinding = node.var.extra?.binding;\n        if (varBinding && !varBinding.upstreamAlias) {\n          const derivation = initValue(varBinding);\n          addValue(section, value.extra?.referencedBindings, derivation, value);\n        }\n      } else {\n        translateVar(tag, value);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an constant binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#const\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/const.d.marko\"\n};\n\n// src/translator/core/debug.ts\nvar import_compiler27 = require(\"@marko/compiler\");\nvar import_babel_utils15 = require(\"@marko/compiler/babel-utils\");\nvar debug_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils15.assertNoVar)(tag);\n    (0, import_babel_utils15.assertNoArgs)(tag);\n    (0, import_babel_utils15.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (tag.node.attributes.length > 1 || tag.node.attributes.length === 1 && (!import_compiler27.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\")) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `debug` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const referencedBindings = valueAttr?.value.extra?.referencedBindings;\n      const statement = withPreviousLocation(import_compiler27.types.debuggerStatement(), tag.node);\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Debug on value change.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#debug\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/debug.d.marko\"\n};\n\n// src/translator/core/define.ts\nvar import_compiler33 = require(\"@marko/compiler\");\nvar import_babel_utils21 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/nested-attribute-tags.ts\nvar import_compiler28 = require(\"@marko/compiler\");\nvar import_babel_utils16 = require(\"@marko/compiler/babel-utils\");\nvar attrTagToIdentifierLookup = /* @__PURE__ */ new WeakMap();\nfunction getAttrTagIdentifier(meta) {\n  let name2 = attrTagToIdentifierLookup.get(meta);\n  if (!name2) {\n    name2 = currentProgramPath.scope.generateUid(meta.name);\n    attrTagToIdentifierLookup.set(meta, name2);\n  }\n  return import_compiler28.types.identifier(name2);\n}\nfunction analyzeAttributeTags(tag) {\n  if (tag.node.extra?.attributeTags) return tag.node.extra.attributeTags;\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  if (!attrTags2.length) return;\n  const tagExtra = tag.node.extra ??= {};\n  const lookup = tagExtra.attributeTags = {};\n  const attrTagNodesByName = {};\n  const sampleAttrTagsForControlFlow = /* @__PURE__ */ new Map();\n  for (const child of attrTags2) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils16.isAttributeTag)(child)) {\n        const name2 = getTagName(child);\n        lookup[name2] ||= createAttrTagMeta(name2, [name2]);\n        (attrTagNodesByName[name2] ||= []).push(child);\n        analyzeAttributeTags(child);\n      } else {\n        const isRepeated = (0, import_babel_utils16.isLoopTag)(child);\n        let curGroup;\n        for (const name2 of crawlAttrTags(child, attrTagNodesByName)) {\n          const oldMeta = lookup[name2];\n          if (oldMeta) {\n            if (!curGroup) {\n              curGroup = oldMeta.group;\n            } else if (curGroup !== oldMeta.group) {\n              for (const name3 of oldMeta.group) {\n                lookup[name3].group = curGroup;\n                curGroup.push(name3);\n              }\n            }\n          }\n          let attrTagMeta = lookup[name2];\n          if (!attrTagMeta) {\n            attrTagMeta = lookup[name2] = createAttrTagMeta(name2, []);\n            curGroup = attrTagMeta.group;\n            curGroup.push(name2);\n          }\n          attrTagMeta.dynamic = true;\n          if (isRepeated) {\n            attrTagMeta.repeated = true;\n          }\n          sampleAttrTagsForControlFlow.set(child, name2);\n        }\n      }\n    }\n  }\n  for (const [controlFlowTag, sampleAttrName] of sampleAttrTagsForControlFlow) {\n    (controlFlowTag.node.extra ??= {}).attributeTagGroup = lookup[sampleAttrName].group;\n  }\n  for (const name2 in attrTagNodesByName) {\n    const attrTagMeta = lookup[name2];\n    if (!attrTagMeta.repeated) {\n      const attrTagNodes = attrTagNodesByName[name2];\n      if (attrTagNodes.length > 1) {\n        attrTagMeta.repeated = !attrTagMeta.dynamic || hasRepeatedDynamicAttrTags(attrTagNodes);\n      }\n    }\n  }\n  return lookup;\n}\nfunction createAttrTagMeta(name2, group) {\n  return {\n    name: name2.slice(1),\n    dynamic: false,\n    repeated: false,\n    group\n  };\n}\nfunction crawlAttrTags(tag, attrTagNodesByName, attrTagNames = /* @__PURE__ */ new Set()) {\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  for (const child of attrTags2) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils16.isAttributeTag)(child)) {\n        const tagName = getTagName(child);\n        attrTagNames.add(tagName);\n        (attrTagNodesByName[tagName] ||= []).push(child);\n        analyzeAttributeTags(child);\n      } else {\n        crawlAttrTags(child, attrTagNodesByName, attrTagNames);\n      }\n    }\n  }\n  return attrTagNames;\n}\nfunction hasRepeatedDynamicAttrTags(attrTags2) {\n  let conditionRoot;\n  const seenBranches = /* @__PURE__ */ new Set();\n  for (const attrTag2 of attrTags2) {\n    const parentTag = getParentTag(attrTag2);\n    if (seenBranches.has(parentTag) || !isConditionTag(parentTag)) {\n      return true;\n    }\n    const curConditionRoot = getConditionRoot(parentTag);\n    if (curConditionRoot && curConditionRoot !== (conditionRoot ||= curConditionRoot)) {\n      return true;\n    }\n    seenBranches.add(parentTag);\n  }\n  return false;\n}\nfunction getConditionRoot(tag) {\n  if (getTagName(tag) === \"if\") return tag;\n  let prev = tag.getPrevSibling();\n  while (prev.node) {\n    if (prev.isMarkoTag() && getTagName(prev) === \"if\") {\n      return prev;\n    }\n    prev = prev.getPrevSibling();\n  }\n}\n\n// src/translator/util/translate-attrs.ts\nvar import_compiler32 = require(\"@marko/compiler\");\nvar import_babel_utils20 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/core/for.ts\nvar import_compiler31 = require(\"@marko/compiler\");\nvar import_babel_utils19 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/is-only-child-in-parent.ts\nvar import_compiler30 = require(\"@marko/compiler\");\nvar import_babel_utils18 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/visitors/tag/native-tag.ts\nvar import_compiler29 = require(\"@marko/compiler\");\nvar import_babel_utils17 = require(\"@marko/compiler/babel-utils\");\nvar kNativeTagBinding = Symbol(\"native tag binding\");\nvar kSerializeMarker = Symbol(\"serialize marker\");\nvar kGetterId = Symbol(\"node getter id\");\nvar htmlSelectArgs = /* @__PURE__ */ new WeakMap();\nfunction assertExclusiveControllableGroups(tag, attrs2) {\n  const exclusiveGroups = [\n    attrs2.open || attrs2.openChange,\n    attrs2.checked || attrs2.checkedChange,\n    attrs2.checkedValue || attrs2.checkedValueChange,\n    attrs2.valueChange\n  ].filter(Boolean);\n  if (exclusiveGroups.length > 1) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The attributes ${exclusiveGroups.map((attr2) => `\"${attr2.name}\"`).join(\", \")} are mutually exclusive.`\n    );\n  }\n}\nfunction getRelatedControllable(tagName, attrs2) {\n  switch (tagName) {\n    case \"input\":\n      if (attrs2.checked || attrs2.checkedChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_checked\",\n          attrs: [attrs2.checked, attrs2.checkedChange]\n        };\n      }\n      if (attrs2.checkedValue || attrs2.checkedValueChange) {\n        return {\n          special: true,\n          helper: \"controllable_input_checkedValue\",\n          attrs: [attrs2.checkedValue, attrs2.checkedValueChange, attrs2.value]\n        };\n      }\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"select\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_select_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"textarea\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_textarea_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"details\":\n    case \"dialog\":\n      if (attrs2.open || attrs2.openChange) {\n        return {\n          special: false,\n          helper: \"controllable_detailsOrDialog_open\",\n          attrs: [attrs2.open, attrs2.openChange]\n        };\n      }\n      break;\n  }\n}\nvar native_tag_default = {\n  transform: {\n    enter(tag) {\n      const tagName = getTagName(tag);\n      if (tagName === \"textarea\" && tag.node.body.body.length) {\n        const parts = [];\n        for (const child of tag.node.body.body) {\n          if (child.type === \"MarkoText\" || child.type === \"MarkoPlaceholder\" && child.escape) {\n            parts.push(child.value);\n          } else {\n            throw tag.hub.file.hub.buildError(\n              child,\n              \"Unexpected content in textarea, only text and placeholders are supported.\",\n              SyntaxError\n            );\n          }\n        }\n        tag.node.attributes.push(\n          import_compiler29.types.markoAttribute(\n            \"value\",\n            normalizeStringExpression(parts) || buildUndefined()\n          )\n        );\n        tag.node.body.body = [];\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils17.assertNoArgs)(tag);\n      (0, import_babel_utils17.assertNoParams)(tag);\n      (0, import_babel_utils17.assertNoAttributeTags)(tag);\n      const { node } = tag;\n      if (node.var && !import_compiler29.types.isIdentifier(node.var)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"Tag variables on native elements cannot be destructured.\"\n        );\n      }\n      const tagName = getTagName(tag);\n      const section = getOrCreateSection(tag);\n      let hasEventHandlers = false;\n      let hasDynamicAttributes = false;\n      const seen = {};\n      const { attributes } = tag.node;\n      let relatedControllable;\n      let spreadReferenceNodes;\n      for (let i = attributes.length; i--; ) {\n        const attr2 = attributes[i];\n        if (import_compiler29.types.isMarkoAttribute(attr2)) {\n          if (seen[attr2.name]) {\n            dropReferences(attr2.value);\n            continue;\n          }\n          seen[attr2.name] = attr2;\n          if (isEventHandler(attr2.name) || isChangeHandler(attr2.name)) {\n            (attr2.value.extra ??= {}).isEffect = true;\n            hasEventHandlers = true;\n          } else if (!evaluate(attr2.value).confident) {\n            hasDynamicAttributes = true;\n          }\n        } else if (import_compiler29.types.isMarkoSpreadAttribute(attr2)) {\n          hasEventHandlers = true;\n          hasDynamicAttributes = true;\n          (attr2.value.extra ??= {}).isEffect = true;\n        }\n        if (spreadReferenceNodes) {\n          spreadReferenceNodes.push(attr2.value);\n        } else if (import_compiler29.types.isMarkoSpreadAttribute(attr2)) {\n          spreadReferenceNodes = [attr2.value];\n          relatedControllable = getRelatedControllable(tagName, seen);\n        }\n      }\n      assertExclusiveControllableGroups(tag, seen);\n      if (spreadReferenceNodes) {\n        if (relatedControllable && !relatedControllable.attrs.every(Boolean)) {\n          for (const attr2 of relatedControllable.attrs) {\n            if (attr2) {\n              spreadReferenceNodes.push(attr2.value);\n            }\n          }\n          relatedControllable = void 0;\n        }\n        mergeReferences(section, tag.node, spreadReferenceNodes);\n      } else {\n        relatedControllable = getRelatedControllable(tagName, seen);\n      }\n      if (relatedControllable) {\n        mergeReferences(\n          section,\n          relatedControllable.attrs.find(Boolean).value,\n          relatedControllable.attrs.map((it) => it?.value)\n        );\n      }\n      if (node.var || hasEventHandlers || hasDynamicAttributes) {\n        currentProgramPath.node.extra.isInteractive ||= hasEventHandlers;\n        const tagName2 = node.name.type === \"StringLiteral\" ? node.name.value : import_compiler29.types.toIdentifier(tag.get(\"name\"));\n        const tagExtra = node.extra ??= {};\n        const bindingName = \"#\" + tagName2;\n        if (hasEventHandlers || node.var) {\n          tagExtra[kSerializeMarker] = true;\n        }\n        const tagBinding = tagExtra[kNativeTagBinding] = createBinding(\n          bindingName,\n          0 /* dom */,\n          section\n        );\n        if (node.var) {\n          const varBinding = tag.scope.getBinding(node.var.name);\n          for (const referencePath of varBinding.referencePaths) {\n            const referenceSection = getSection(referencePath);\n            setReferencesScope(referencePath);\n            if (!isSameOrChildSection(section, referenceSection)) {\n              trackHoistedReference(\n                referencePath,\n                tagBinding\n              );\n            } else if (!isInvokedFunction(referencePath)) {\n              tagExtra[kGetterId] ||= getRegisterUID(section, bindingName);\n            }\n          }\n        }\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagName = getTagName(tag);\n      const extra = tag.node.extra;\n      const nodeRef2 = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const name2 = tag.get(\"name\");\n      const tagDef = (0, import_babel_utils17.getTagDef)(tag);\n      const write2 = writeTo(tag);\n      const section = getSection(tag);\n      if (isHTML && extra.tagNameNullable) {\n        flushBefore(tag);\n      }\n      if (tag.has(\"var\")) {\n        const varName = tag.node.var.name;\n        const varBinding = tag.scope.getBinding(varName);\n        const getterId = extra[kGetterId];\n        if (isHTML) {\n          for (const reference of varBinding.referencePaths) {\n            const referenceSection = getSection(reference);\n            if (!reference.node.extra?.hoist) {\n              let currentSection = referenceSection;\n              while (currentSection !== section && currentSection.parent) {\n                setSerializedProperty(\n                  currentSection,\n                  \"_\",\n                  callRuntime(\n                    \"ensureScopeWithId\",\n                    getScopeIdIdentifier(\n                      currentSection = currentSection.parent\n                    )\n                  )\n                );\n              }\n            }\n          }\n          setForceResumeScope(section);\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(section),\n              getterId && import_compiler29.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n              `get_${varName}`\n            );\n            currentProgramPath.pushContainer(\n              \"body\",\n              import_compiler29.types.variableDeclaration(\"const\", [\n                import_compiler29.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler29.types.stringLiteral(getterId),\n                    import_compiler29.types.stringLiteral(\n                      getScopeAccessorLiteral(nodeRef2).value + \">\" /* Getter */\n                    )\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of varBinding.referencePaths) {\n            if (!reference.node.extra?.hoistedBinding) {\n              const referenceSection = getSection(reference);\n              if (isInvokedFunction(reference)) {\n                reference.parentPath.replaceWith(\n                  import_compiler29.types.expressionStatement(\n                    createScopeReadExpression(referenceSection, nodeRef2)\n                  )\n                );\n              } else if (getterFnIdentifier) {\n                reference.replaceWith(\n                  import_compiler29.types.callExpression(getterFnIdentifier, [\n                    getScopeExpression(referenceSection, getSection(tag))\n                  ])\n                );\n              } else {\n                reference.replaceWith(\n                  import_compiler29.types.expressionStatement(\n                    import_compiler29.types.memberExpression(\n                      getScopeExpression(section, referenceSection),\n                      import_compiler29.types.stringLiteral(\n                        getScopeAccessorLiteral(nodeRef2).value + \">\" /* Getter */\n                      ),\n                      true\n                    )\n                  )\n                );\n              }\n            }\n          }\n        }\n      }\n      let visitAccessor;\n      if (nodeRef2) {\n        visitAccessor = getScopeAccessorLiteral(nodeRef2);\n        visit(tag, 32 /* Get */);\n      }\n      write2`<${name2.node}`;\n      const usedAttrs = getUsedAttrs(tagName, tag.node);\n      const { staticAttrs, staticControllable, skipExpression } = usedAttrs;\n      let { spreadExpression } = usedAttrs;\n      if (staticControllable) {\n        const { helper, attrs: attrs2 } = staticControllable;\n        const firstAttr = attrs2.find(Boolean);\n        const referencedBindings = firstAttr.value.extra?.referencedBindings;\n        const values = attrs2.map((attr2) => attr2?.value);\n        if (isHTML) {\n          if (tagName !== \"select\" && tagName !== \"textarea\") {\n            write2`${callRuntime(helper, getScopeIdIdentifier(section), visitAccessor, ...values)}`;\n          }\n          addHTMLEffectCall(section, void 0);\n        } else {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            import_compiler29.types.expressionStatement(\n              callRuntime(helper, scopeIdentifier, visitAccessor, ...values)\n            )\n          );\n          addStatement(\n            \"effect\",\n            section,\n            void 0,\n            import_compiler29.types.expressionStatement(\n              callRuntime(`${helper}_effect`, scopeIdentifier, visitAccessor)\n            )\n          );\n        }\n      }\n      let writeAtStartOfBody;\n      if (isHTML) {\n        if (tagName === \"select\") {\n          if (staticControllable) {\n            htmlSelectArgs.set(tag.node, {\n              value: staticControllable.attrs[0]?.value || buildUndefined(),\n              valueChange: staticControllable.attrs[1]?.value || buildUndefined()\n            });\n          } else if (spreadExpression) {\n            const spreadIdentifier = tag.scope.generateUidIdentifier(\"select_input\");\n            tag.insertBefore(\n              import_compiler29.types.variableDeclaration(\"const\", [\n                import_compiler29.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            htmlSelectArgs.set(tag.node, {\n              value: import_compiler29.types.memberExpression(\n                spreadIdentifier,\n                import_compiler29.types.identifier(\"value\")\n              ),\n              valueChange: import_compiler29.types.memberExpression(\n                spreadIdentifier,\n                import_compiler29.types.identifier(\"valueChange\")\n              )\n            });\n            spreadExpression = spreadIdentifier;\n          }\n        } else if (tagName === \"textarea\") {\n          let value;\n          let valueChange;\n          if (staticControllable) {\n            value = staticControllable.attrs[0]?.value;\n            valueChange = staticControllable.attrs[1]?.value;\n          } else if (spreadExpression) {\n            const spreadIdentifier = tag.scope.generateUidIdentifier(\"textarea_input\");\n            tag.insertBefore(\n              import_compiler29.types.variableDeclaration(\"const\", [\n                import_compiler29.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            value = import_compiler29.types.memberExpression(spreadIdentifier, import_compiler29.types.identifier(\"value\"));\n            valueChange = import_compiler29.types.memberExpression(\n              spreadIdentifier,\n              import_compiler29.types.identifier(\"valueChange\")\n            );\n            spreadExpression = spreadIdentifier;\n          }\n          if (value || valueChange) {\n            writeAtStartOfBody = callRuntime(\n              \"controllable_textarea_value\",\n              getScopeIdIdentifier(getSection(tag)),\n              getScopeAccessorLiteral(nodeRef2),\n              value,\n              valueChange\n            );\n          }\n        }\n      }\n      for (const attr2 of staticAttrs) {\n        const { name: name3, value } = attr2;\n        const { confident, computed } = value.extra || {};\n        const valueReferences = value.extra?.referencedBindings;\n        if (isHTML && tagName === \"option\" && name3 === \"value\") {\n          write2`${callRuntime(\"optionValueAttr\", value)}`;\n          continue;\n        }\n        switch (name3) {\n          case \"class\":\n          case \"style\": {\n            const helper = `${name3}Attr`;\n            if (confident) {\n              write2`${getHTMLRuntime()[helper](computed)}`;\n            } else if (isHTML) {\n              write2`${callRuntime(helper, value)}`;\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler29.types.expressionStatement(\n                  callRuntime(\n                    helper,\n                    import_compiler29.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n          }\n          default:\n            if (confident) {\n              write2`${getHTMLRuntime().attr(name3, computed)}`;\n            } else if (isHTML) {\n              if (isEventHandler(name3)) {\n                addHTMLEffectCall(section, valueReferences);\n              } else {\n                write2`${callRuntime(\"attr\", import_compiler29.types.stringLiteral(name3), value)}`;\n              }\n            } else if (isEventHandler(name3)) {\n              addStatement(\n                \"effect\",\n                section,\n                valueReferences,\n                import_compiler29.types.expressionStatement(\n                  callRuntime(\n                    \"on\",\n                    import_compiler29.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler29.types.stringLiteral(getEventHandlerName(name3)),\n                    value\n                  )\n                )\n              );\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler29.types.expressionStatement(\n                  callRuntime(\n                    \"attr\",\n                    import_compiler29.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler29.types.stringLiteral(name3),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n        }\n      }\n      if (spreadExpression) {\n        if (isHTML) {\n          addHTMLEffectCall(section, extra.referencedBindings);\n          if (skipExpression) {\n            write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(section), name2.node)}`;\n          } else {\n            write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(section), name2.node)}`;\n          }\n        } else {\n          if (skipExpression) {\n            addStatement(\n              \"render\",\n              section,\n              extra.referencedBindings,\n              import_compiler29.types.expressionStatement(\n                callRuntime(\n                  \"partialAttrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression,\n                  skipExpression\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              extra.referencedBindings,\n              import_compiler29.types.expressionStatement(\n                callRuntime(\n                  \"attrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression\n                )\n              )\n            );\n          }\n          addStatement(\n            \"effect\",\n            section,\n            extra.referencedBindings,\n            import_compiler29.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            false\n          );\n        }\n      }\n      if (tagDef && tagDef.parseOptions?.openTagOnly) {\n        switch (tagDef.htmlType) {\n          case \"svg\":\n          case \"math\":\n            write2`/>`;\n            break;\n          default:\n            write2`>`;\n            break;\n        }\n      } else {\n        write2`>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(import_compiler29.types.ifStatement(name2.node, consumeHTML(tag)))[0].skip();\n      }\n      if (writeAtStartOfBody) {\n        write2`${writeAtStartOfBody}`;\n      }\n      enter2(tag);\n    },\n    exit(tag) {\n      const extra = tag.node.extra;\n      const nodeRef2 = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const openTagOnly = (0, import_babel_utils17.getTagDef)(tag)?.parseOptions?.openTagOnly;\n      const selectArgs = isHTML && htmlSelectArgs.get(tag.node);\n      const tagName = getTagName(tag);\n      if (isHTML && extra.tagNameNullable) {\n        flushInto(tag);\n      }\n      if (selectArgs) {\n        writeTo(tag)`</${tag.node.name}>`;\n        flushInto(tag);\n        tag.insertBefore(\n          import_compiler29.types.expressionStatement(\n            callRuntime(\n              \"controllable_select_value\",\n              getScopeIdIdentifier(getSection(tag)),\n              getScopeAccessorLiteral(nodeRef2),\n              selectArgs.value,\n              selectArgs.valueChange,\n              import_compiler29.types.arrowFunctionExpression(\n                [],\n                import_compiler29.types.blockStatement(tag.node.body.body)\n              )\n            )\n          )\n        );\n      } else {\n        tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n      }\n      const shouldMark = nodeRef2 && (extra[kSerializeMarker] || extra[kSerializeMarker] === void 0 && (isStatefulReferences(extra.referencedBindings) || tag.node.attributes.some(\n        (attr2) => isStatefulReferences(attr2.value.extra?.referencedBindings)\n      )));\n      if (!openTagOnly && !selectArgs) {\n        writeTo(\n          tag,\n          isHTML && !shouldMark && (tagName === \"html\" || tagName === \"body\")\n        )`</${tag.node.name}>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(\n          import_compiler29.types.ifStatement(tag.node.name, consumeHTML(tag))\n        )[0].skip();\n      }\n      if (shouldMark) {\n        markNode(tag, nodeRef2);\n      }\n      exit2(tag);\n      tag.remove();\n    }\n  }\n};\nfunction getUsedAttrs(tagName, tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  let staticControllable;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler29.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n        staticControllable = getRelatedControllable(tagName, seen);\n        if (staticControllable && !staticControllable.attrs.every(Boolean)) {\n          for (const attr3 of staticControllable.attrs) {\n            if (attr3) {\n              spreadProps.push(toObjectProperty(attr3.name, attr3.value));\n              maybeStaticAttrs.delete(attr3);\n            }\n          }\n          staticControllable = void 0;\n        }\n      }\n      spreadProps.push(import_compiler29.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  if (!spreadProps) {\n    staticControllable = getRelatedControllable(tagName, seen);\n    if (staticControllable?.special === false && !staticControllable.attrs[1]) {\n      staticControllable = void 0;\n    }\n  }\n  if (staticControllable) {\n    for (const attr2 of staticControllable.attrs) {\n      if (attr2) {\n        maybeStaticAttrs.delete(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    if (staticControllable) {\n      for (const attr2 of staticControllable.attrs) {\n        if (attr2) {\n          (skipProps ||= []).push(\n            toObjectProperty(attr2.name, import_compiler29.types.numericLiteral(1))\n          );\n        }\n      }\n    }\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler29.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler29.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    staticControllable,\n    spreadExpression,\n    skipExpression\n  };\n}\nfunction isChangeHandler(propName) {\n  return /^(?:value|checked(?:Value)?|open)Change/.test(propName);\n}\nfunction buildUndefined() {\n  return import_compiler29.types.unaryExpression(\"void\", import_compiler29.types.numericLiteral(0));\n}\n\n// src/translator/util/is-only-child-in-parent.ts\nvar kOnlyChildInParent = Symbol(\"only child in parent\");\nvar kNodeRef = Symbol(\"potential only child node ref\");\nfunction isOnlyChildInParent(tag, branchSize = 1) {\n  const extra = tag.node.extra;\n  if (extra[kOnlyChildInParent] !== void 0) {\n    return extra[kOnlyChildInParent];\n  }\n  const parentTag = getParentTag(tag);\n  if (parentTag && (0, import_babel_utils18.getTagDef)(parentTag)?.html) {\n    return extra[kOnlyChildInParent] = tag.parent.body.length === branchSize;\n  }\n  return extra[kOnlyChildInParent] = false;\n}\nfunction getOptimizedOnlyChildNodeRef(tag, section, branchSize = 1) {\n  if (isOnlyChildInParent(tag, branchSize)) {\n    const parentTag = getParentTag(tag).node;\n    const parentTagName = parentTag.name?.value;\n    return (parentTag.extra ??= {})[kNativeTagBinding] ??= createBinding(\n      \"#\" + parentTagName,\n      0 /* dom */,\n      section\n    );\n  } else {\n    return (tag.node.extra ??= {})[kNodeRef] ??= createBinding(\n      \"#text\",\n      0 /* dom */,\n      section\n    );\n  }\n}\n\n// src/translator/core/for.ts\nvar for_default = {\n  analyze(tag) {\n    const tagExtra = tag.node.extra ??= {};\n    const isAttrTag = tag.node.body.attributeTags;\n    let allowAttrs;\n    (0, import_babel_utils19.assertNoVar)(tag);\n    (0, import_babel_utils19.assertNoArgs)(tag);\n    assertNoSpreadAttrs(tag);\n    switch (getForType(tag.node)) {\n      case \"of\":\n        allowAttrs = [\"of\"];\n        break;\n      case \"in\":\n        allowAttrs = [\"in\"];\n        break;\n      case \"to\":\n        allowAttrs = [\"to\", \"from\", \"step\"];\n        break;\n      default:\n        throw tag.buildCodeFrameError(\n          \"Invalid `for` tag, missing an `of=`, `in=`, `to=` attribute.\"\n        );\n    }\n    if (!isAttrTag) {\n      allowAttrs.push(\"by\");\n    }\n    (0, import_babel_utils19.assertAllowedAttributes)(tag, allowAttrs);\n    if (isAttrTag) return;\n    const tagBody = tag.get(\"body\");\n    const bodySection = startSection(tagBody);\n    if (!bodySection) {\n      dropReferences(getAllTagReferenceNodes(tag.node));\n      return;\n    }\n    const section = getOrCreateSection(tag);\n    trackParamsReferences(tagBody, 3 /* param */, void 0, tagExtra);\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n    bodySection.sectionAccessor = {\n      binding: getOptimizedOnlyChildNodeRef(tag, section),\n      suffix: \"(\" /* LoopScopeMap */\n    };\n    bodySection.upstreamExpression = tagExtra;\n    bodySection.isBranch = true;\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        if (!isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n        flushBefore(tag);\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const isStateful = isStatefulReferences(tagExtra.referencedBindings);\n        const onlyChildInParentOptimization = isOnlyChildInParent(tag);\n        const nodeRef2 = getOptimizedOnlyChildNodeRef(tag, tagSection);\n        const forAttrs = getKnownAttrValues(node);\n        const forType = getForType(node);\n        const params = node.body.params;\n        const statements = [];\n        const bodyStatements = node.body.body;\n        const hasStatefulClosures = checkStatefulClosures(bodySection, true);\n        const hasHoists = bodySection.hoisted || bodySection.isHoistThrough || bodySection.referencedHoists;\n        const singleNodeOptimization = bodySection.content === null || bodySection.content.singleChild && bodySection.content.startType !== 4 /* Text */;\n        let keyExpression;\n        if (isStateful && onlyChildInParentOptimization) {\n          getParentTag(tag).node.extra[kSerializeMarker] = false;\n        }\n        if (isStateful || hasStatefulClosures || hasHoists) {\n          const defaultParamNames = {\n            of: [\"list\", \"index\"],\n            in: [\"key\", \"value\"],\n            to: [\"value\"]\n          }[forType];\n          const defaultByParamIndex = forType === \"of\" ? 1 : 0;\n          const requiredParamsIndex = forAttrs.by ? defaultParamNames.length - 1 : defaultByParamIndex;\n          setForceResumeScope(bodySection);\n          for (let i = 0; i <= requiredParamsIndex; i++) {\n            const existingParam = params[i];\n            if (!existingParam || !import_compiler31.types.isIdentifier(existingParam)) {\n              const id = params[i] = currentProgramPath.scope.generateUidIdentifier(\n                defaultParamNames[i]\n              );\n              if (existingParam) {\n                bodyStatements.unshift(\n                  import_compiler31.types.variableDeclaration(\"let\", [\n                    import_compiler31.types.variableDeclarator(existingParam, id)\n                  ])\n                );\n              }\n            }\n          }\n          if (forAttrs.by) {\n            if (import_compiler31.types.isStringLiteral(forAttrs.by)) {\n              keyExpression = toMemberExpression(\n                params[0],\n                forAttrs.by.value\n              );\n            } else if (import_compiler31.types.isFunction(forAttrs.by)) {\n              const byIdentifier = currentProgramPath.scope.generateUidIdentifier(\"by\");\n              statements.push(\n                import_compiler31.types.variableDeclaration(\"const\", [\n                  import_compiler31.types.variableDeclarator(byIdentifier, forAttrs.by)\n                ])\n              );\n              keyExpression = import_compiler31.types.callExpression(\n                byIdentifier,\n                params\n              );\n            } else {\n              keyExpression = callRuntime(\n                forTypeToHTMLByRuntime(forType),\n                forAttrs.by,\n                ...params\n              );\n            }\n          } else {\n            keyExpression = params[defaultByParamIndex];\n          }\n          const forScopesIdentifier = getScopeIdentifier(bodySection);\n          getHTMLSectionStatements(tagSection).push(\n            import_compiler31.types.variableDeclaration(\"const\", [\n              import_compiler31.types.variableDeclarator(\n                forScopesIdentifier,\n                import_compiler31.types.newExpression(import_compiler31.types.identifier(\"Map\"), [])\n              )\n            ])\n          );\n          if (isStateful || hasStatefulClosures || hasHoists) {\n            bodyStatements.push(\n              import_compiler31.types.expressionStatement(\n                import_compiler31.types.callExpression(\n                  import_compiler31.types.memberExpression(forScopesIdentifier, import_compiler31.types.identifier(\"set\")),\n                  [\n                    keyExpression,\n                    callRuntime(\n                      \"ensureScopeWithId\",\n                      getScopeIdIdentifier(bodySection)\n                    )\n                  ]\n                )\n              )\n            );\n          }\n          setSerializedProperty(\n            tagSection,\n            getScopeAccessor(nodeRef2) + \"(\" /* LoopScopeMap */,\n            import_compiler31.types.conditionalExpression(\n              import_compiler31.types.memberExpression(forScopesIdentifier, import_compiler31.types.identifier(\"size\")),\n              forScopesIdentifier,\n              import_compiler31.types.identifier(\"undefined\")\n            )\n          );\n        }\n        flushInto(tag);\n        writeHTMLResumeStatements(tagBody);\n        const forTagArgs = getBaseArgsInForTag(forType, forAttrs);\n        const forTagHTMLRuntime = isStateful ? forTypeToHTMLResumeRuntime(forType, singleNodeOptimization) : forTypeToRuntime(forType);\n        forTagArgs.push(\n          import_compiler31.types.arrowFunctionExpression(params, import_compiler31.types.blockStatement(bodyStatements))\n        );\n        if (isStateful) {\n          forTagArgs.push(\n            getScopeIdIdentifier(tagSection),\n            getScopeAccessorLiteral(nodeRef2)\n          );\n          if (onlyChildInParentOptimization) {\n            forTagArgs.push(import_compiler31.types.numericLiteral(1));\n          }\n        }\n        statements.push(\n          import_compiler31.types.expressionStatement(callRuntime(forTagHTMLRuntime, ...forTagArgs))\n        );\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        if (!isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const { referencedBindings } = tagExtra;\n        const nodeRef2 = getOptimizedOnlyChildNodeRef(tag, tagSection);\n        setClosureSignalBuilder(tag, (closure, render) => {\n          return callRuntime(\n            \"loopClosure\",\n            getScopeAccessorLiteral(closure),\n            getScopeAccessorLiteral(nodeRef2),\n            render\n          );\n        });\n        const forType = getForType(node);\n        const signal = getSignal(tagSection, nodeRef2, \"for\");\n        signal.build = () => {\n          return callRuntime(\n            forTypeToDOMRuntime(forType),\n            getScopeAccessorLiteral(nodeRef2),\n            import_compiler31.types.identifier(bodySection.name)\n          );\n        };\n        const params = node.body.params;\n        signal.hasDownstreamIntersections = () => {\n          for (const param of params) {\n            const binding = param.extra?.binding;\n            if (binding) {\n              for (const {\n                referencedBindings: referencedBindings2\n              } of binding.downstreamExpressions) {\n                if (getSignal(\n                  bodySection,\n                  referencedBindings2\n                ).hasDownstreamIntersections()) {\n                  return true;\n                }\n              }\n            }\n          }\n          return false;\n        };\n        const forAttrs = getKnownAttrValues(node);\n        const loopArgs = getBaseArgsInForTag(forType, forAttrs);\n        if (forAttrs.by) {\n          loopArgs.push(forAttrs.by);\n        }\n        addValue(\n          tagSection,\n          referencedBindings,\n          signal,\n          import_compiler31.types.arrayExpression(loopArgs)\n        );\n        tag.remove();\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  attributes: {\n    of: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over a list of items.\"\n        }\n      ]\n    },\n    in: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over the keys and values of an object.\"\n        }\n      ]\n    },\n    to: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates up to the provided number (inclusive)\"\n        }\n      ]\n    },\n    from: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates starting from the provided number (inclusive)\"\n        }\n      ]\n    },\n    step: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"The amount to increment during each interation (with from/to)\"\n        }\n      ]\n    }\n  },\n  autocomplete: [\n    {\n      snippet: \"for|${1:value, index}| of=${3:array}\",\n      description: \"Use to iterate over lists, object properties, or between ranges.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-a-list\"\n    },\n    {\n      snippet: \"for|${1:name, value}| in=${3:object}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties\"\n    },\n    {\n      snippet: \"for|${1:index}| to=${2:number}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers\"\n    }\n  ]\n};\nfunction buildForRuntimeCall(type, attrs2, params, statements) {\n  return import_compiler31.types.expressionStatement(\n    callRuntime(\n      forTypeToRuntime(type),\n      ...getBaseArgsInForTag(type, attrs2),\n      import_compiler31.types.arrowFunctionExpression(params, import_compiler31.types.blockStatement(statements))\n    )\n  );\n}\nfunction getForType(tag) {\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      switch (attr2.name) {\n        case \"of\":\n        case \"in\":\n        case \"to\":\n          return attr2.name;\n      }\n    }\n  }\n}\nfunction forTypeToRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"forOf\";\n    case \"in\":\n      return \"forIn\";\n    case \"to\":\n      return \"forTo\";\n  }\n}\nfunction forTypeToHTMLResumeRuntime(type, singleNodeOptimization) {\n  if (singleNodeOptimization) {\n    switch (type) {\n      case \"of\":\n        return \"resumeSingleNodeForOf\";\n      case \"in\":\n        return \"resumeSingleNodeForIn\";\n      case \"to\":\n        return \"resumeSingleNodeForTo\";\n    }\n  } else {\n    switch (type) {\n      case \"of\":\n        return \"resumeForOf\";\n      case \"in\":\n        return \"resumeForIn\";\n      case \"to\":\n        return \"resumeForTo\";\n    }\n  }\n}\nfunction forTypeToDOMRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"loopOf\";\n    case \"in\":\n      return \"loopIn\";\n    case \"to\":\n      return \"loopTo\";\n  }\n}\nfunction forTypeToHTMLByRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"forOfBy\";\n    case \"in\":\n      return \"forInBy\";\n    case \"to\":\n      return \"forToBy\";\n  }\n}\nfunction getBaseArgsInForTag(type, attrs2) {\n  switch (type) {\n    case \"in\":\n      return [attrs2.in];\n    case \"of\":\n      return [attrs2.of];\n    case \"to\":\n      return [\n        attrs2.to,\n        attrs2.from || import_compiler31.types.numericLiteral(0),\n        attrs2.step || import_compiler31.types.numericLiteral(1)\n      ];\n  }\n}\n\n// src/translator/util/translate-attrs.ts\nvar contentProps = /* @__PURE__ */ new WeakSet();\nfunction translateAttrs(tag, templateExports, statements = [], contentKey = \"content\") {\n  const seen = /* @__PURE__ */ new Set();\n  const properties = [];\n  const attrTagLookup = tag.node.extra?.attributeTags;\n  if (attrTagLookup) {\n    for (const name2 in attrTagLookup) {\n      const attrTagMeta = attrTagLookup[name2];\n      if (usesExport(templateExports, attrTagMeta.name)) {\n        seen.add(attrTagMeta.name);\n        if (attrTagMeta.dynamic) {\n          statements.push(\n            import_compiler32.types.variableDeclaration(\"let\", [\n              import_compiler32.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta))\n            ])\n          );\n          properties.push(\n            toObjectProperty(\n              attrTagMeta.name,\n              getAttrTagIdentifier(attrTagMeta)\n            )\n          );\n        }\n      }\n    }\n    const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils20.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          if (attrTagMeta.dynamic) {\n            i = addDynamicAttrTagStatements(\n              attrTags2,\n              i,\n              attrTagLookup,\n              statements,\n              templateExports,\n              contentKey\n            );\n          } else {\n            const translatedAttrTag = translateAttrs(\n              child,\n              templateExports?.[attrTagMeta.name]?.props,\n              statements,\n              contentKey\n            );\n            if (attrTagMeta.repeated) {\n              const prevProp = findObjectProperty(attrTagMeta.name, properties);\n              if (prevProp) {\n                prevProp.value = callRuntime(\n                  \"attrTags\",\n                  prevProp.value,\n                  propsToExpression(translatedAttrTag.properties)\n                );\n              } else {\n                properties.push(\n                  toObjectProperty(\n                    attrTagMeta.name,\n                    callRuntime(\n                      \"attrTag\",\n                      propsToExpression(translatedAttrTag.properties)\n                    )\n                  )\n                );\n              }\n            } else {\n              properties.push(\n                toObjectProperty(\n                  attrTagMeta.name,\n                  callRuntime(\n                    \"attrTag\",\n                    propsToExpression(translatedAttrTag.properties)\n                  )\n                )\n              );\n            }\n          }\n        } else {\n          i = addDynamicAttrTagStatements(\n            attrTags2,\n            i,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        }\n      }\n    }\n  }\n  if (!seen.has(contentKey) && usesExport(templateExports, contentKey)) {\n    seen.add(contentKey);\n    const contentExpression = buildContent(tag.get(\"body\"));\n    if (contentExpression) {\n      const contentProp = import_compiler32.types.objectProperty(\n        import_compiler32.types.identifier(contentKey),\n        contentExpression\n      );\n      contentProps.add(contentProp);\n      properties.push(contentProp);\n    }\n  }\n  const { attributes } = tag.node;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler32.types.isMarkoSpreadAttribute(attr2)) {\n      properties.push(import_compiler32.types.spreadElement(value));\n    } else if (!seen.has(attr2.name) && usesExport(templateExports, attr2.name)) {\n      seen.add(attr2.name);\n      properties.push(toObjectProperty(attr2.name, value));\n    }\n  }\n  properties.reverse();\n  return { properties, statements };\n}\nfunction getTranslatedBodyContentProperty(props) {\n  for (const prop of props) {\n    if (contentProps.has(prop)) {\n      return prop;\n    }\n  }\n}\nfunction addDynamicAttrTagStatements(attrTags2, index, attrTagLookup, statements, templateExports, contentKey = \"content\") {\n  const tag = attrTags2[index];\n  if (tag.isMarkoTag()) {\n    if ((0, import_babel_utils20.isAttributeTag)(tag)) {\n      const attrTagMeta = attrTagLookup[getTagName(tag)];\n      if (usesExport(templateExports, attrTagMeta.name) && attrTagMeta.dynamic) {\n        const translatedAttrTag = translateAttrs(\n          tag,\n          templateExports?.[attrTagMeta.name]?.props,\n          statements,\n          contentKey\n        );\n        if (attrTagMeta.repeated) {\n          statements.push(\n            import_compiler32.types.expressionStatement(\n              import_compiler32.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTags\",\n                  getAttrTagIdentifier(attrTagMeta),\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        } else {\n          statements.push(\n            import_compiler32.types.expressionStatement(\n              import_compiler32.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTag\",\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        }\n      }\n    } else {\n      switch (getTagName(tag)) {\n        case \"if\":\n          return translateIfAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        case \"for\": {\n          return translateForAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        }\n      }\n    }\n  }\n  return index;\n}\nfunction propsToExpression(props) {\n  return props.length === 1 && import_compiler32.types.isSpreadElement(props[0]) ? props[0].argument : import_compiler32.types.objectExpression(props);\n}\nfunction translateForAttrTag(attrTags2, index, attrTagLookup, statements, templateExports, contentKey) {\n  const forTag = attrTags2[index];\n  const bodyStatements = [];\n  addAllAttrTagsAsDynamic(\n    forTag,\n    attrTagLookup,\n    bodyStatements,\n    templateExports,\n    contentKey\n  );\n  statements.push(\n    buildForRuntimeCall(\n      getForType(forTag.node),\n      getKnownAttrValues(forTag.node),\n      forTag.node.body.params,\n      bodyStatements\n    )\n  );\n  return index;\n}\nfunction translateIfAttrTag(attrTags2, index, attrTagLookup, statements, templateExports, contentKey) {\n  const ifTag = attrTags2[index];\n  const consequentStatements = [];\n  let ifStatement = import_compiler32.types.ifStatement(\n    getConditionTestValue(ifTag),\n    import_compiler32.types.blockStatement(consequentStatements)\n  );\n  statements.push(ifStatement);\n  addAllAttrTagsAsDynamic(\n    ifTag,\n    attrTagLookup,\n    consequentStatements,\n    templateExports,\n    contentKey\n  );\n  let nextIndex = index + 1;\n  while (nextIndex < attrTags2.length) {\n    const nextTag = attrTags2[nextIndex];\n    if (nextTag.isMarkoTag()) {\n      switch (getTagName(nextTag)) {\n        case \"else-if\":\n        case \"else\": {\n          const testValue = getConditionTestValue(nextTag);\n          const alternateStatements = [];\n          addAllAttrTagsAsDynamic(\n            nextTag,\n            attrTagLookup,\n            alternateStatements,\n            templateExports,\n            contentKey\n          );\n          if (testValue) {\n            ifStatement.alternate = ifStatement = import_compiler32.types.ifStatement(\n              testValue,\n              import_compiler32.types.blockStatement(alternateStatements)\n            );\n            nextIndex++;\n            continue;\n          } else {\n            ifStatement.alternate = import_compiler32.types.blockStatement(alternateStatements);\n            break;\n          }\n        }\n      }\n    }\n    break;\n  }\n  return nextIndex - 1;\n}\nfunction addAllAttrTagsAsDynamic(tag, attrTagLookup, statements, templateExports, contentKey) {\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  for (let i = 0; i < attrTags2.length; i++) {\n    i = addDynamicAttrTagStatements(\n      attrTags2,\n      i,\n      attrTagLookup,\n      statements,\n      templateExports,\n      contentKey\n    );\n  }\n}\nfunction usesExport(templateExports, name2) {\n  return !templateExports || !!templateExports[name2];\n}\nfunction findObjectProperty(name2, props) {\n  for (const prop of props) {\n    if (prop.type === \"ObjectProperty\") {\n      switch (prop.key.type) {\n        case \"StringLiteral\":\n          if (prop.key.value === name2) {\n            return prop;\n          }\n          break;\n        case \"Identifier\":\n          if (prop.key.name === name2) {\n            return prop;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\nfunction getConditionTestValue({\n  node: { attributes }\n}) {\n  return attributes.length === 1 ? attributes[0].value : void 0;\n}\nfunction buildContent(body) {\n  const bodySection = body.node.extra?.section;\n  if (bodySection) {\n    if (isOutputHTML()) {\n      const serialized = isSerializedSection(bodySection);\n      return callRuntime(\n        serialized ? \"registerContent\" : \"createContent\",\n        import_compiler32.types.stringLiteral(getResumeRegisterId(bodySection, \"renderer\")),\n        import_compiler32.types.arrowFunctionExpression(\n          body.node.params,\n          import_compiler32.types.blockStatement(body.node.body)\n        ),\n        serialized ? getScopeIdIdentifier(\n          getSection(\n            getNonAttributeTagParent(\n              body.parentPath\n            )\n          )\n        ) : void 0\n      );\n    } else {\n      return import_compiler32.types.callExpression(import_compiler32.types.identifier(bodySection.name), [\n        scopeIdentifier\n      ]);\n    }\n  }\n}\nfunction getNonAttributeTagParent(tag) {\n  let cur = tag;\n  while ((0, import_babel_utils20.isAttributeTag)(cur) || (0, import_babel_utils20.isTransparentTag)(cur)) {\n    cur = getParentTag(cur);\n  }\n  return cur;\n}\n\n// src/translator/core/define.ts\nvar define_default = {\n  analyze(tag) {\n    (0, import_babel_utils21.assertNoArgs)(tag);\n    if (!tag.node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `define` tag requires a tag variable.\");\n    }\n    const tagBody = tag.get(\"body\");\n    const bodySection = startSection(tagBody);\n    trackVarReferences(tag, 4 /* derived */);\n    if (bodySection) {\n      const varBinding = tag.node.var?.extra?.binding;\n      if (varBinding) {\n        bodySection.downstreamBinding = varBinding.propertyAliases.get(\"content\") || varBinding;\n      }\n    }\n    trackParamsReferences(tagBody, 3 /* param */);\n    analyzeAttributeTags(tag);\n    mergeReferences(\n      getOrCreateSection(tag),\n      tag.node,\n      getAllTagReferenceNodes(tag.node)\n    );\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const translatedAttrs = translateAttrs(tag);\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        tag.insertBefore(translatedAttrs.statements);\n        translateVar(tag, propsToExpression(translatedAttrs.properties));\n      } else {\n        const section = getSection(tag);\n        const referencedBindings = node.extra?.referencedBindings;\n        const derivation = initValue(tag.get(\"var\").node.extra.binding);\n        if (translatedAttrs.statements.length) {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            translatedAttrs.statements\n          );\n        }\n        addValue(\n          section,\n          referencedBindings,\n          derivation,\n          propsToExpression(translatedAttrs.properties)\n        );\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a constant object binding that can be rendered.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#define\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/define.d.marko\"\n};\n\n// src/translator/core/effect.ts\nvar import_compiler34 = require(\"@marko/compiler\");\nvar import_babel_utils22 = require(\"@marko/compiler/babel-utils\");\nvar effect_default = {\n  migrate: [\n    (tag) => {\n      (0, import_babel_utils22.assertNoArgs)(tag);\n      (0, import_babel_utils22.assertNoParams)(tag);\n      assertNoBodyContent(tag);\n      (0, import_babel_utils22.assertNoAttributeTags)(tag);\n      assertNoSpreadAttrs(tag);\n      (0, import_babel_utils22.assertAllowedAttributes)(tag, [\"value\"]);\n      (0, import_babel_utils22.diagnosticDeprecate)(tag, {\n        label: \"The 'effect' tag has been replaced by the 'script' tag.\",\n        fix() {\n          const { node } = tag;\n          tag.replaceWith(\n            import_compiler34.types.markoTag(\n              withPreviousLocation(import_compiler34.types.stringLiteral(\"script\"), node.name),\n              node.attributes,\n              node.body,\n              node.arguments,\n              node.var,\n              node.attributeTags\n            )\n          );\n        }\n      });\n    }\n  ],\n  attributes: {},\n  types: runtime_info_default.name + \"/tag-types/effect.d.marko\"\n};\n\n// src/translator/core/export.ts\nvar import_babel_utils23 = require(\"@marko/compiler/babel-utils\");\nvar export_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils23.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"export <value>\"\n    }\n  ]\n};\n\n// src/translator/core/html-comment.ts\nvar import_compiler35 = require(\"@marko/compiler\");\nvar import_babel_utils24 = require(\"@marko/compiler/babel-utils\");\nvar kCommentTagBinding = Symbol(\"comment tag binding\");\nvar kGetterId2 = Symbol(\"node getter id\");\nvar html_comment_default = {\n  analyze(tag) {\n    (0, import_babel_utils24.assertNoArgs)(tag);\n    (0, import_babel_utils24.assertNoParams)(tag);\n    (0, import_babel_utils24.assertNoAttributes)(tag);\n    const tagVar = tag.node.var;\n    let needsBinding = false;\n    let needsGetter = false;\n    if (tagVar) {\n      if (!import_compiler35.types.isIdentifier(tagVar)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"The `html-comment` tag variable cannot be destructured.\"\n        );\n      }\n      needsBinding = true;\n      for (const ref of tag.scope.getBinding(tagVar.name).referencePaths) {\n        if (!ref.parentPath?.isCallExpression()) {\n          needsGetter = true;\n          break;\n        }\n      }\n    }\n    const referenceNodes = [];\n    for (const child of tag.get(\"body\").get(\"body\")) {\n      if (child.isMarkoPlaceholder()) {\n        referenceNodes.push(child.node.value);\n        needsBinding = true;\n      } else if (!child.isMarkoText()) {\n        throw child.buildCodeFrameError(\n          \"Invalid child. Only text is allowed inside an html comment.\"\n        );\n      }\n    }\n    if (needsBinding) {\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      if (needsGetter) {\n        tagExtra[kGetterId2] = getRegisterUID(section, \"comment\");\n      }\n      tagExtra[kCommentTagBinding] = createBinding(\n        \"#comment\",\n        0 /* dom */,\n        section\n      );\n      mergeReferences(section, tag.node, referenceNodes);\n    }\n    tag.skip();\n  },\n  translate(tag) {\n    const tagExtra = tag.node.extra;\n    const commentBinding = tagExtra[kCommentTagBinding];\n    const hasVar = !!tag.node.var;\n    if (hasVar) {\n      const getterId = tagExtra[kGetterId2];\n      if (isOutputHTML()) {\n        translateVar(\n          tag,\n          callRuntime(\n            \"nodeRef\",\n            getterId && getScopeIdIdentifier(getSection(tag)),\n            getterId && import_compiler35.types.stringLiteral(getterId)\n          )\n        );\n      } else {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        let getterFnIdentifier;\n        if (getterId) {\n          getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n            `get_${varName}`\n          );\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler35.types.variableDeclaration(\"const\", [\n              import_compiler35.types.variableDeclarator(\n                getterFnIdentifier,\n                callRuntime(\n                  \"nodeRef\",\n                  import_compiler35.types.stringLiteral(getterId),\n                  getScopeAccessorLiteral(commentBinding)\n                )\n              )\n            ])\n          );\n        }\n        for (const reference of references) {\n          const referenceSection = getSection(reference);\n          if (reference.parentPath?.isCallExpression()) {\n            reference.parentPath.replaceWith(\n              import_compiler35.types.expressionStatement(\n                createScopeReadExpression(referenceSection, commentBinding)\n              )\n            );\n          } else if (getterFnIdentifier) {\n            reference.replaceWith(\n              import_compiler35.types.callExpression(getterFnIdentifier, [\n                getScopeExpression(referenceSection, getSection(tag))\n              ])\n            );\n          }\n        }\n      }\n    }\n    if (tagExtra[kCommentTagBinding]) {\n      visit(tag, 32 /* Get */);\n    }\n    const write2 = writeTo(tag);\n    enter2(tag);\n    write2`<!--`;\n    if (isOutputHTML()) {\n      for (const child of tag.node.body.body) {\n        if (import_compiler35.types.isMarkoText(child)) {\n          write2`${child.value}`;\n        } else if (import_compiler35.types.isMarkoPlaceholder(child)) {\n          write2`${callRuntime(\"escapeXML\", child.value)}`;\n        }\n      }\n    } else {\n      const templateQuasis = [];\n      const templateExpressions = [];\n      let currentQuasi = \"\";\n      for (const child of tag.node.body.body) {\n        if (import_compiler35.types.isMarkoText(child)) {\n          currentQuasi += child.value;\n        } else if (import_compiler35.types.isMarkoPlaceholder(child)) {\n          templateQuasis.push(import_compiler35.types.templateElement({ raw: currentQuasi }));\n          templateExpressions.push(child.value);\n          currentQuasi = \"\";\n        }\n      }\n      if (templateExpressions.length === 0) {\n        write2`${currentQuasi}`;\n      } else {\n        templateQuasis.push(import_compiler35.types.templateElement({ raw: currentQuasi }));\n        addStatement(\n          \"render\",\n          getSection(tag),\n          tagExtra.referencedBindings,\n          import_compiler35.types.expressionStatement(\n            callRuntime(\n              \"data\",\n              import_compiler35.types.memberExpression(\n                scopeIdentifier,\n                getScopeAccessorLiteral(commentBinding),\n                true\n              ),\n              import_compiler35.types.templateLiteral(templateQuasis, templateExpressions)\n            )\n          )\n        );\n      }\n    }\n    exit2(tag);\n    write2`-->`;\n    if (commentBinding) {\n      markNode(tag, commentBinding);\n    }\n    tag.remove();\n  },\n  parseOptions: {\n    text: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an html comment that is not stripped from the output.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#html-comment\"\n    }\n  ]\n};\n\n// src/translator/core/html-script.ts\nvar import_compiler36 = require(\"@marko/compiler\");\nvar import_babel_utils25 = require(\"@marko/compiler/babel-utils\");\nvar kGetterId3 = Symbol(\"node getter id\");\nvar html_script_default = {\n  analyze(tag) {\n    (0, import_babel_utils25.assertNoArgs)(tag);\n    (0, import_babel_utils25.assertNoParams)(tag);\n    const { node } = tag;\n    if (node.var && !import_compiler36.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\n        \"Tag variables on native elements cannot be destructured.\"\n      );\n    }\n    const section = getOrCreateSection(tag);\n    let hasEventHandlers = false;\n    let hasDynamicAttributes = false;\n    const seen = {};\n    const { attributes } = tag.node;\n    let spreadReferenceNodes;\n    for (let i = attributes.length; i--; ) {\n      const attr2 = attributes[i];\n      if (import_compiler36.types.isMarkoAttribute(attr2)) {\n        if (seen[attr2.name]) {\n          dropReferences(attr2.value);\n          continue;\n        }\n        seen[attr2.name] = attr2;\n        if (isEventHandler(attr2.name)) {\n          (attr2.value.extra ??= {}).isEffect = true;\n          hasEventHandlers = true;\n        } else if (!evaluate(attr2.value).confident) {\n          hasDynamicAttributes = true;\n        }\n      } else if (import_compiler36.types.isMarkoSpreadAttribute(attr2)) {\n        hasEventHandlers = true;\n        hasDynamicAttributes = true;\n        (attr2.value.extra ??= {}).isEffect = true;\n      }\n      if (spreadReferenceNodes) {\n        spreadReferenceNodes.push(attr2.value);\n      } else if (import_compiler36.types.isMarkoSpreadAttribute(attr2)) {\n        spreadReferenceNodes = [attr2.value];\n      }\n    }\n    if (spreadReferenceNodes) {\n      mergeReferences(section, tag.node, spreadReferenceNodes);\n    }\n    const bodyPlaceholderNodes = [];\n    let hasBodyPlaceholders = false;\n    for (const child of tag.node.body.body) {\n      if (import_compiler36.types.isMarkoPlaceholder(child)) {\n        bodyPlaceholderNodes.push(child.value);\n        hasBodyPlaceholders = true;\n      } else if (!import_compiler36.types.isMarkoText(child)) {\n        throw tag.hub.buildError(\n          child,\n          \"Invalid child. Only text is allowed inside an html-script.\"\n        );\n      }\n    }\n    if (bodyPlaceholderNodes.length > 1) {\n      mergeReferences(\n        section,\n        bodyPlaceholderNodes[0],\n        bodyPlaceholderNodes.slice(1)\n      );\n    }\n    if (node.var || hasEventHandlers || hasDynamicAttributes || hasBodyPlaceholders) {\n      currentProgramPath.node.extra.isInteractive ||= hasEventHandlers;\n      const tagExtra = node.extra ??= {};\n      const bindingName = \"#script\";\n      tagExtra[kSerializeMarker] = hasEventHandlers || !!node.var;\n      tagExtra[kNativeTagBinding] = createBinding(\n        bindingName,\n        0 /* dom */,\n        section\n      );\n      if (node.var) {\n        for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n          if (!ref.parentPath?.isCallExpression()) {\n            tagExtra[kGetterId3] = getRegisterUID(section, bindingName);\n            break;\n          }\n        }\n      }\n    }\n  },\n  translate(tag) {\n    const tagExtra = tag.node.extra;\n    const nodeRef2 = tagExtra[kNativeTagBinding];\n    const isHTML = isOutputHTML();\n    const write2 = writeTo(tag);\n    const section = getSection(tag);\n    const hasVar = !!tag.node.var;\n    if (hasVar) {\n      const getterId = tagExtra[kGetterId3];\n      if (isHTML) {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        for (const reference of references) {\n          let currentSection = getSection(reference);\n          while (currentSection !== section && currentSection.parent) {\n            setSerializedProperty(\n              currentSection,\n              \"_\",\n              callRuntime(\n                \"ensureScopeWithId\",\n                getScopeIdIdentifier(currentSection = currentSection.parent)\n              )\n            );\n          }\n        }\n        translateVar(\n          tag,\n          callRuntime(\n            \"nodeRef\",\n            getterId && getScopeIdIdentifier(section),\n            getterId && import_compiler36.types.stringLiteral(getterId)\n          )\n        );\n      } else {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        let getterFnIdentifier;\n        if (getterId) {\n          getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n            `get_${varName}`\n          );\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler36.types.variableDeclaration(\"const\", [\n              import_compiler36.types.variableDeclarator(\n                getterFnIdentifier,\n                callRuntime(\n                  \"nodeRef\",\n                  import_compiler36.types.stringLiteral(getterId),\n                  getScopeAccessorLiteral(nodeRef2)\n                )\n              )\n            ])\n          );\n        }\n        for (const reference of references) {\n          const referenceSection = getSection(reference);\n          if (reference.parentPath?.isCallExpression()) {\n            reference.parentPath.replaceWith(\n              import_compiler36.types.expressionStatement(\n                createScopeReadExpression(referenceSection, nodeRef2)\n              )\n            );\n          } else if (getterFnIdentifier) {\n            reference.replaceWith(\n              import_compiler36.types.callExpression(getterFnIdentifier, [\n                getScopeExpression(referenceSection, getSection(tag))\n              ])\n            );\n          }\n        }\n      }\n    }\n    let visitAccessor;\n    if (nodeRef2) {\n      visitAccessor = getScopeAccessorLiteral(nodeRef2);\n      visit(tag, 32 /* Get */);\n    }\n    write2`<script`;\n    const usedAttrs = getUsedAttrs2(tag.node);\n    const { staticAttrs, skipExpression, spreadExpression } = usedAttrs;\n    for (const attr2 of staticAttrs) {\n      const { name: name2, value } = attr2;\n      const { confident, computed } = value.extra || {};\n      const valueReferences = value.extra?.referencedBindings;\n      switch (name2) {\n        case \"class\":\n        case \"style\": {\n          const helper = `${name2}Attr`;\n          if (confident) {\n            write2`${getHTMLRuntime()[helper](computed)}`;\n          } else if (isHTML) {\n            write2`${callRuntime(helper, value)}`;\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              valueReferences,\n              import_compiler36.types.expressionStatement(\n                callRuntime(\n                  helper,\n                  import_compiler36.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  value\n                )\n              )\n            );\n          }\n          break;\n        }\n        default:\n          if (confident) {\n            write2`${getHTMLRuntime().attr(name2, computed)}`;\n          } else if (isHTML) {\n            if (isEventHandler(name2)) {\n              addHTMLEffectCall(section, valueReferences);\n            } else {\n              write2`${callRuntime(\"attr\", import_compiler36.types.stringLiteral(name2), value)}`;\n            }\n          } else if (isEventHandler(name2)) {\n            addStatement(\n              \"effect\",\n              section,\n              valueReferences,\n              import_compiler36.types.expressionStatement(\n                callRuntime(\n                  \"on\",\n                  import_compiler36.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  import_compiler36.types.stringLiteral(getEventHandlerName(name2)),\n                  value\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              valueReferences,\n              import_compiler36.types.expressionStatement(\n                callRuntime(\n                  \"attr\",\n                  import_compiler36.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  import_compiler36.types.stringLiteral(name2),\n                  value\n                )\n              )\n            );\n          }\n          break;\n      }\n    }\n    if (spreadExpression) {\n      if (isHTML) {\n        addHTMLEffectCall(section, tagExtra.referencedBindings);\n        if (skipExpression) {\n          write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler36.types.stringLiteral(\"script\"))}`;\n        } else {\n          write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler36.types.stringLiteral(\"script\"))}`;\n        }\n      } else {\n        if (skipExpression) {\n          addStatement(\n            \"render\",\n            section,\n            tagExtra.referencedBindings,\n            import_compiler36.types.expressionStatement(\n              callRuntime(\n                \"partialAttrs\",\n                scopeIdentifier,\n                visitAccessor,\n                spreadExpression,\n                skipExpression\n              )\n            )\n          );\n        } else {\n          addStatement(\n            \"render\",\n            section,\n            tagExtra.referencedBindings,\n            import_compiler36.types.expressionStatement(\n              callRuntime(\n                \"attrs\",\n                scopeIdentifier,\n                visitAccessor,\n                spreadExpression\n              )\n            )\n          );\n        }\n        addStatement(\n          \"effect\",\n          section,\n          tagExtra.referencedBindings,\n          import_compiler36.types.expressionStatement(\n            callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n          ),\n          false\n        );\n      }\n    }\n    write2`>`;\n    enter2(tag);\n    if (isOutputHTML()) {\n      for (const child of tag.node.body.body) {\n        if (import_compiler36.types.isMarkoText(child)) {\n          write2`${child.value}`;\n        } else if (import_compiler36.types.isMarkoPlaceholder(child)) {\n          write2`${callRuntime(\"escapeScript\", child.value)}`;\n        }\n      }\n    } else {\n      const templateQuasis = [];\n      const templateExpressions = [];\n      let currentQuasi = \"\";\n      let referencePlaceholder;\n      for (const child of tag.node.body.body) {\n        if (import_compiler36.types.isMarkoText(child)) {\n          currentQuasi += child.value;\n        } else if (import_compiler36.types.isMarkoPlaceholder(child)) {\n          referencePlaceholder ||= child;\n          templateQuasis.push(import_compiler36.types.templateElement({ raw: currentQuasi }));\n          templateExpressions.push(child.value);\n          currentQuasi = \"\";\n        }\n      }\n      if (!referencePlaceholder) {\n        write2`${currentQuasi}`;\n      } else {\n        templateQuasis.push(import_compiler36.types.templateElement({ raw: currentQuasi }));\n        addStatement(\n          \"render\",\n          getSection(tag),\n          referencePlaceholder.value.extra?.referencedBindings,\n          import_compiler36.types.expressionStatement(\n            callRuntime(\n              \"textContent\",\n              import_compiler36.types.memberExpression(scopeIdentifier, visitAccessor, true),\n              import_compiler36.types.templateLiteral(templateQuasis, templateExpressions)\n            )\n          )\n        );\n      }\n    }\n    write2`</script>`;\n    if (nodeRef2) {\n      markNode(tag, nodeRef2);\n    }\n    exit2(tag);\n    tag.remove();\n  },\n  \"@async\": \"#html-async\",\n  \"@crossorigin\": \"#html-crossorigin\",\n  \"@defer\": \"#html-defer\",\n  \"@integrity\": \"#html-integrity\",\n  \"@nomodule\": \"#html-nomodule\",\n  \"@nonce\": \"#html-nonce\",\n  \"@referrerpolicy\": \"#html-referrerpolicy\",\n  \"@src\": \"#html-src\",\n  \"@type\": \"#html-type\",\n  \"attribute-groups\": [\"html-attributes\"],\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  }\n};\nfunction getUsedAttrs2(tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler36.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n      }\n      spreadProps.push(import_compiler36.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler36.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler36.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    spreadExpression,\n    skipExpression\n  };\n}\n\n// src/translator/core/html-style.ts\nvar import_compiler37 = require(\"@marko/compiler\");\nvar import_babel_utils26 = require(\"@marko/compiler/babel-utils\");\nvar kGetterId4 = Symbol(\"node getter id\");\nvar html_style_default = {\n  analyze(tag) {\n    (0, import_babel_utils26.assertNoArgs)(tag);\n    (0, import_babel_utils26.assertNoParams)(tag);\n    const { node } = tag;\n    if (node.var && !import_compiler37.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\n        \"Tag variables on native elements cannot be destructured.\"\n      );\n    }\n    const section = getOrCreateSection(tag);\n    let hasEventHandlers = false;\n    let hasDynamicAttributes = false;\n    const seen = {};\n    const { attributes } = tag.node;\n    let spreadReferenceNodes;\n    for (let i = attributes.length; i--; ) {\n      const attr2 = attributes[i];\n      if (import_compiler37.types.isMarkoAttribute(attr2)) {\n        if (seen[attr2.name]) {\n          dropReferences(attr2.value);\n          continue;\n        }\n        seen[attr2.name] = attr2;\n        if (isEventHandler(attr2.name)) {\n          (attr2.value.extra ??= {}).isEffect = true;\n          hasEventHandlers = true;\n        } else if (!evaluate(attr2.value).confident) {\n          hasDynamicAttributes = true;\n        }\n      } else if (import_compiler37.types.isMarkoSpreadAttribute(attr2)) {\n        hasEventHandlers = true;\n        hasDynamicAttributes = true;\n        (attr2.value.extra ??= {}).isEffect = true;\n      }\n      if (spreadReferenceNodes) {\n        spreadReferenceNodes.push(attr2.value);\n      } else if (import_compiler37.types.isMarkoSpreadAttribute(attr2)) {\n        spreadReferenceNodes = [attr2.value];\n      }\n    }\n    if (spreadReferenceNodes) {\n      mergeReferences(section, tag.node, spreadReferenceNodes);\n    }\n    const bodyPlaceholderNodes = [];\n    let hasBodyPlaceholders = false;\n    for (const child of tag.node.body.body) {\n      if (import_compiler37.types.isMarkoPlaceholder(child)) {\n        bodyPlaceholderNodes.push(child.value);\n        hasBodyPlaceholders = true;\n      } else if (!import_compiler37.types.isMarkoText(child)) {\n        throw tag.hub.buildError(\n          child,\n          \"Invalid child. Only text is allowed inside an html-style.\"\n        );\n      }\n    }\n    if (bodyPlaceholderNodes.length > 1) {\n      mergeReferences(\n        section,\n        bodyPlaceholderNodes[0],\n        bodyPlaceholderNodes.slice(1)\n      );\n    }\n    if (node.var || hasEventHandlers || hasDynamicAttributes || hasBodyPlaceholders) {\n      currentProgramPath.node.extra.isInteractive ||= hasEventHandlers;\n      const tagExtra = node.extra ??= {};\n      const bindingName = \"#style\";\n      tagExtra[kSerializeMarker] = hasEventHandlers || !!node.var;\n      tagExtra[kNativeTagBinding] = createBinding(\n        bindingName,\n        0 /* dom */,\n        section\n      );\n      if (node.var) {\n        for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n          if (!ref.parentPath?.isCallExpression()) {\n            tagExtra[kGetterId4] = getRegisterUID(section, bindingName);\n            break;\n          }\n        }\n      }\n    }\n  },\n  translate(tag) {\n    const tagExtra = tag.node.extra;\n    const nodeRef2 = tagExtra[kNativeTagBinding];\n    const isHTML = isOutputHTML();\n    const write2 = writeTo(tag);\n    const section = getSection(tag);\n    const hasVar = !!tag.node.var;\n    if (hasVar) {\n      const getterId = tagExtra[kGetterId4];\n      if (isHTML) {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        for (const reference of references) {\n          let currentSection = getSection(reference);\n          while (currentSection !== section && currentSection.parent) {\n            setSerializedProperty(\n              currentSection,\n              \"_\",\n              callRuntime(\n                \"ensureScopeWithId\",\n                getScopeIdIdentifier(currentSection = currentSection.parent)\n              )\n            );\n          }\n        }\n        translateVar(\n          tag,\n          callRuntime(\n            \"nodeRef\",\n            getterId && getScopeIdIdentifier(section),\n            getterId && import_compiler37.types.stringLiteral(getterId)\n          )\n        );\n      } else {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        let getterFnIdentifier;\n        if (getterId) {\n          getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n            `get_${varName}`\n          );\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler37.types.variableDeclaration(\"const\", [\n              import_compiler37.types.variableDeclarator(\n                getterFnIdentifier,\n                callRuntime(\n                  \"nodeRef\",\n                  import_compiler37.types.stringLiteral(getterId),\n                  getScopeAccessorLiteral(nodeRef2)\n                )\n              )\n            ])\n          );\n        }\n        for (const reference of references) {\n          const referenceSection = getSection(reference);\n          if (reference.parentPath?.isCallExpression()) {\n            reference.parentPath.replaceWith(\n              import_compiler37.types.expressionStatement(\n                createScopeReadExpression(referenceSection, nodeRef2)\n              )\n            );\n          } else if (getterFnIdentifier) {\n            reference.replaceWith(\n              import_compiler37.types.callExpression(getterFnIdentifier, [\n                getScopeExpression(referenceSection, getSection(tag))\n              ])\n            );\n          }\n        }\n      }\n    }\n    let visitAccessor;\n    if (nodeRef2) {\n      visitAccessor = getScopeAccessorLiteral(nodeRef2);\n      visit(tag, 32 /* Get */);\n    }\n    write2`<style`;\n    const usedAttrs = getUsedAttrs3(tag.node);\n    const { staticAttrs, skipExpression, spreadExpression } = usedAttrs;\n    for (const attr2 of staticAttrs) {\n      const { name: name2, value } = attr2;\n      const { confident, computed } = value.extra || {};\n      const valueReferences = value.extra?.referencedBindings;\n      switch (name2) {\n        case \"class\":\n        case \"style\": {\n          const helper = `${name2}Attr`;\n          if (confident) {\n            write2`${getHTMLRuntime()[helper](computed)}`;\n          } else if (isHTML) {\n            write2`${callRuntime(helper, value)}`;\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              valueReferences,\n              import_compiler37.types.expressionStatement(\n                callRuntime(\n                  helper,\n                  import_compiler37.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  value\n                )\n              )\n            );\n          }\n          break;\n        }\n        default:\n          if (confident) {\n            write2`${getHTMLRuntime().attr(name2, computed)}`;\n          } else if (isHTML) {\n            if (isEventHandler(name2)) {\n              addHTMLEffectCall(section, valueReferences);\n            } else {\n              write2`${callRuntime(\"attr\", import_compiler37.types.stringLiteral(name2), value)}`;\n            }\n          } else if (isEventHandler(name2)) {\n            addStatement(\n              \"effect\",\n              section,\n              valueReferences,\n              import_compiler37.types.expressionStatement(\n                callRuntime(\n                  \"on\",\n                  import_compiler37.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  import_compiler37.types.stringLiteral(getEventHandlerName(name2)),\n                  value\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              valueReferences,\n              import_compiler37.types.expressionStatement(\n                callRuntime(\n                  \"attr\",\n                  import_compiler37.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  import_compiler37.types.stringLiteral(name2),\n                  value\n                )\n              )\n            );\n          }\n          break;\n      }\n    }\n    if (spreadExpression) {\n      if (isHTML) {\n        addHTMLEffectCall(section, tagExtra.referencedBindings);\n        if (skipExpression) {\n          write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler37.types.stringLiteral(\"style\"))}`;\n        } else {\n          write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler37.types.stringLiteral(\"style\"))}`;\n        }\n      } else {\n        if (skipExpression) {\n          addStatement(\n            \"render\",\n            section,\n            tagExtra.referencedBindings,\n            import_compiler37.types.expressionStatement(\n              callRuntime(\n                \"partialAttrs\",\n                scopeIdentifier,\n                visitAccessor,\n                spreadExpression,\n                skipExpression\n              )\n            )\n          );\n        } else {\n          addStatement(\n            \"render\",\n            section,\n            tagExtra.referencedBindings,\n            import_compiler37.types.expressionStatement(\n              callRuntime(\n                \"attrs\",\n                scopeIdentifier,\n                visitAccessor,\n                spreadExpression\n              )\n            )\n          );\n        }\n        addStatement(\n          \"effect\",\n          section,\n          tagExtra.referencedBindings,\n          import_compiler37.types.expressionStatement(\n            callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n          ),\n          false\n        );\n      }\n    }\n    write2`>`;\n    enter2(tag);\n    if (isOutputHTML()) {\n      for (const child of tag.node.body.body) {\n        if (import_compiler37.types.isMarkoText(child)) {\n          write2`${child.value}`;\n        } else if (import_compiler37.types.isMarkoPlaceholder(child)) {\n          write2`${callRuntime(\"escapeStyle\", child.value)}`;\n        }\n      }\n    } else {\n      const templateQuasis = [];\n      const templateExpressions = [];\n      let currentQuasi = \"\";\n      let referencePlaceholder;\n      for (const child of tag.node.body.body) {\n        if (import_compiler37.types.isMarkoText(child)) {\n          currentQuasi += child.value;\n        } else if (import_compiler37.types.isMarkoPlaceholder(child)) {\n          referencePlaceholder ||= child;\n          templateQuasis.push(import_compiler37.types.templateElement({ raw: currentQuasi }));\n          templateExpressions.push(child.value);\n          currentQuasi = \"\";\n        }\n      }\n      if (!referencePlaceholder) {\n        write2`${currentQuasi}`;\n      } else {\n        templateQuasis.push(import_compiler37.types.templateElement({ raw: currentQuasi }));\n        addStatement(\n          \"render\",\n          getSection(tag),\n          referencePlaceholder.value.extra?.referencedBindings,\n          import_compiler37.types.expressionStatement(\n            callRuntime(\n              \"textContent\",\n              import_compiler37.types.memberExpression(scopeIdentifier, visitAccessor, true),\n              import_compiler37.types.templateLiteral(templateQuasis, templateExpressions)\n            )\n          )\n        );\n      }\n    }\n    write2`</style>`;\n    if (nodeRef2) {\n      markNode(tag, nodeRef2);\n    }\n    exit2(tag);\n    tag.remove();\n  },\n  \"@disabled\": \"#html-disabled\",\n  \"@media\": \"#html-media\",\n  \"@nonce\": \"#html-nonce\",\n  \"@type\": \"#html-type\",\n  \"attribute-groups\": [\"html-attributes\"],\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  }\n};\nfunction getUsedAttrs3(tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler37.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n      }\n      spreadProps.push(import_compiler37.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler37.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler37.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    spreadExpression,\n    skipExpression\n  };\n}\n\n// src/translator/core/id.ts\nvar import_compiler38 = require(\"@marko/compiler\");\nvar import_babel_utils27 = require(\"@marko/compiler/babel-utils\");\nvar id_default = {\n  analyze(tag) {\n    (0, import_babel_utils27.assertNoArgs)(tag);\n    (0, import_babel_utils27.assertNoParams)(tag);\n    (0, import_babel_utils27.assertNoAttributes)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils27.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `id` tag requires a tag variable.\");\n    }\n    if (!import_compiler38.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `id` tag cannot be destructured\");\n    }\n    trackVarReferences(tag, 4 /* derived */);\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const id = isOutputHTML() ? callRuntime(\"nextTagId\") : callRuntime(\"nextTagId\", scopeIdentifier);\n      if (isOutputHTML()) {\n        tag.replaceWith(\n          import_compiler38.types.variableDeclaration(\"const\", [import_compiler38.types.variableDeclarator(node.var, id)])\n        );\n      } else {\n        const source = initValue(node.var.extra.binding);\n        addValue(getSection(tag), void 0, source, id);\n        tag.remove();\n      }\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"id/<name>\",\n      description: \"Use to create a unique identifier.\",\n      snippet: \"id/${1:name}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#id\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/id.d.marko\"\n};\n\n// src/translator/core/if.ts\nvar import_compiler40 = require(\"@marko/compiler\");\nvar import_babel_utils28 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/to-first-statement-or-block.ts\nvar import_compiler39 = require(\"@marko/compiler\");\nfunction toFirstStatementOrBlock(body) {\n  if (Array.isArray(body)) {\n    if (body.length === 1) {\n      return body[0];\n    }\n    return import_compiler39.types.blockStatement(body);\n  }\n  return body;\n}\n\n// src/translator/core/if.ts\nvar BRANCHES_LOOKUP = /* @__PURE__ */ new WeakMap();\nvar IfTag = {\n  analyze(tag) {\n    assertValidCondition(tag);\n    if (tag.node.body.attributeTags) return;\n    const bodySection = startSection(tag.get(\"body\"));\n    const [isLast, branches] = getBranches(tag, bodySection);\n    if (isLast) {\n      const [rootTag] = branches[0];\n      const rootExtra = rootTag.node.extra ??= {};\n      const mergeReferenceNodes = [];\n      let singleNodeOptimization = true;\n      for (const [branchTag, branchBodySection] of branches) {\n        if (branchBodySection) {\n          branchBodySection.isBranch = true;\n          branchBodySection.upstreamExpression = rootExtra;\n          if (!(branchBodySection.content === null || branchBodySection.content?.singleChild && branchBodySection.content.startType !== 4 /* Text */)) {\n            singleNodeOptimization = false;\n          }\n        }\n        if (branchTag.node.attributes.length) {\n          mergeReferenceNodes.push(branchTag.node.attributes[0].value);\n        }\n      }\n      const section = getOrCreateSection(tag);\n      mergeReferences(section, rootTag.node, mergeReferenceNodes);\n      bodySection.sectionAccessor = {\n        binding: getOptimizedOnlyChildNodeRef(\n          rootTag,\n          section,\n          branches.length\n        ),\n        suffix: \"!\" /* ConditionalScope */\n      };\n      rootExtra.singleNodeOptimization = singleNodeOptimization;\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (isRoot(tag) && !isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n        flushBefore(tag);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const [isLast, branches] = getBranches(tag, bodySection);\n        const [rootTag] = branches[0];\n        const rootExtra = rootTag.node.extra;\n        const isStateful = isStatefulReferences(rootExtra.referencedBindings);\n        const singleNodeOptimization = rootExtra.singleNodeOptimization;\n        const hasStatefulClosures = bodySection && checkStatefulClosures(bodySection, true);\n        const hasHoists = bodySection && (bodySection.hoisted || bodySection.isHoistThrough || bodySection.referencedHoists);\n        if (bodySection) {\n          if (isStateful || hasStatefulClosures || hasHoists) {\n            setForceResumeScope(bodySection);\n          }\n          flushInto(tag);\n          writeHTMLResumeStatements(tagBody);\n        }\n        if (isLast) {\n          const nodeRef2 = getOptimizedOnlyChildNodeRef(rootTag, section);\n          const onlyChildInParentOptimization = isOnlyChildInParent(rootTag);\n          const nextTag = tag.getNextSibling();\n          const ifScopeIdIdentifier = rootTag.scope.generateUidIdentifier(\"ifScopeId\");\n          const ifBranchIdentifier = rootTag.scope.generateUidIdentifier(\"ifBranch\");\n          let statement;\n          if (isStateful && onlyChildInParentOptimization) {\n            getParentTag(rootTag).node.extra[kSerializeMarker] = false;\n          }\n          for (let i = branches.length; i--; ) {\n            const [branchTag, branchBodySection] = branches[i];\n            const bodyStatements = branchTag.node.body.body;\n            if (branchBodySection) {\n              const branchHasStatefulClosures = checkStatefulClosures(\n                branchBodySection,\n                true\n              );\n              const branchHasHoists = branchBodySection.hoisted || branchBodySection.isHoistThrough || branchBodySection.referencedHoists;\n              if (isStateful) {\n                bodyStatements.push(\n                  import_compiler40.types.expressionStatement(\n                    import_compiler40.types.assignmentExpression(\n                      \"=\",\n                      ifBranchIdentifier,\n                      import_compiler40.types.numericLiteral(i)\n                    )\n                  )\n                );\n              }\n              if (isStateful || branchHasStatefulClosures || branchHasHoists) {\n                bodyStatements.push(\n                  import_compiler40.types.expressionStatement(\n                    import_compiler40.types.assignmentExpression(\n                      \"=\",\n                      ifScopeIdIdentifier,\n                      getScopeIdIdentifier(branchBodySection)\n                    )\n                  )\n                );\n              }\n            }\n            const [testAttr] = branchTag.node.attributes;\n            const curStatement = toFirstStatementOrBlock(bodyStatements);\n            if (testAttr) {\n              statement = import_compiler40.types.ifStatement(\n                testAttr.value,\n                curStatement,\n                statement\n              );\n            } else {\n              statement = curStatement;\n            }\n            branchTag.remove();\n          }\n          if (isStateful || hasStatefulClosures || hasHoists) {\n            if (isStateful) {\n              setSerializedProperty(\n                section,\n                getScopeAccessor(nodeRef2) + \"(\" /* ConditionalRenderer */,\n                ifBranchIdentifier\n              );\n              const cbNode = import_compiler40.types.arrowFunctionExpression(\n                [],\n                import_compiler40.types.blockStatement([statement])\n              );\n              statement = import_compiler40.types.expressionStatement(\n                singleNodeOptimization ? callRuntime(\n                  \"resumeSingleNodeConditional\",\n                  cbNode,\n                  getScopeIdIdentifier(section),\n                  getScopeAccessorLiteral(nodeRef2),\n                  onlyChildInParentOptimization && import_compiler40.types.numericLiteral(1)\n                ) : callRuntime(\n                  \"resumeConditional\",\n                  cbNode,\n                  getScopeIdIdentifier(section),\n                  getScopeAccessorLiteral(nodeRef2)\n                )\n              );\n            }\n            nextTag.insertBefore(statement);\n            getHTMLSectionStatements(section).push(\n              import_compiler40.types.variableDeclaration(\n                \"let\",\n                [\n                  import_compiler40.types.variableDeclarator(ifScopeIdIdentifier),\n                  isStateful && import_compiler40.types.variableDeclarator(ifBranchIdentifier)\n                ].filter(Boolean)\n              )\n            );\n            setSerializedProperty(\n              section,\n              getScopeAccessor(nodeRef2) + \"!\" /* ConditionalScope */,\n              callRuntime(\"getScopeById\", ifScopeIdIdentifier)\n            );\n          } else {\n            nextTag.insertBefore(statement);\n          }\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n        }\n        if (isRoot(tag) && !isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const [isLast, branches] = getBranches(\n          tag,\n          getSectionForBody(tag.get(\"body\"))\n        );\n        if (isLast) {\n          const [rootTag] = branches[0];\n          const section = getSection(rootTag);\n          const rootExtra = branches[0][0].node.extra;\n          const nodeRef2 = getOptimizedOnlyChildNodeRef(rootTag, section);\n          const rendererIdentifiers = [];\n          let expr = import_compiler40.types.numericLiteral(branches.length);\n          for (let i = branches.length; i--; ) {\n            const [branchTag, branchBodySection] = branches[i];\n            const [testAttr] = branchTag.node.attributes;\n            const consequent = import_compiler40.types.numericLiteral(branchBodySection ? i : -1);\n            if (branchBodySection) {\n              rendererIdentifiers.push(import_compiler40.types.identifier(branchBodySection.name));\n              setClosureSignalBuilder(branchTag, (closure, render) => {\n                return callRuntime(\n                  \"conditionalClosure\",\n                  getScopeAccessorLiteral(closure),\n                  getScopeAccessorLiteral(nodeRef2),\n                  import_compiler40.types.numericLiteral(i),\n                  render\n                );\n              });\n            }\n            branchTag.remove();\n            expr = testAttr ? import_compiler40.types.conditionalExpression(testAttr.value, consequent, expr) : consequent;\n          }\n          const signal = getSignal(section, nodeRef2, \"if\");\n          signal.build = () => {\n            return callRuntime(\n              \"conditional\",\n              getScopeAccessorLiteral(nodeRef2),\n              ...rendererIdentifiers.reverse()\n            );\n          };\n          addValue(section, rootExtra.referencedBindings, signal, expr);\n        }\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  autocomplete: [\n    {\n      snippet: \"if=${1:condition}\",\n      description: \"Use to display content only if the condition is met.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseIfTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      snippet: \"else-if=${1:condition}\",\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nfunction assertValidCondition(tag) {\n  (0, import_babel_utils28.assertNoVar)(tag);\n  (0, import_babel_utils28.assertNoArgs)(tag);\n  (0, import_babel_utils28.assertNoParams)(tag);\n  assertHasBody(tag);\n  assertNoSpreadAttrs(tag);\n  switch (getTagName(tag)) {\n    case \"if\":\n      assertHasValueAttribute(tag);\n      break;\n    case \"else-if\":\n      assertHasValueAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n    case \"else\":\n      assertOptionalIfAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n  }\n}\nfunction assertHasPrecedingCondition(tag) {\n  let prev = tag.getPrevSibling();\n  while (prev.node && prev.isMarkoComment()) prev = prev.getPrevSibling();\n  if (!isConditionTag(prev) || getTagName(prev) !== \"else\" && !prev.node.attributes.length) {\n    throw tag.buildCodeFrameError(\n      `The \\`<${getTagName(tag)}>\\` must have a preceding \\`<if=cond>\\`, \\`<else-if=cond>\\`, or \\`<else if=cond>\\`.`\n    );\n  }\n}\nfunction assertHasBody(tag) {\n  if (!(tag.node.body.body.length || tag.node.attributeTags.length)) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${getTagName(tag)}\\` tag requires body content.`\n    );\n  }\n}\nfunction assertHasValueAttribute(tag) {\n  const { node } = tag;\n  const [valueAttr] = node.attributes;\n  if (!import_compiler40.types.isMarkoAttribute(valueAttr) || !valueAttr.default) {\n    throw tag.get(\"name\").buildCodeFrameError(`The \\`${getTagName(tag)}\\` tag requires a value.`);\n  }\n  if (node.attributes.length > 1) {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports the \\`value\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction assertOptionalIfAttribute(tag) {\n  const { node } = tag;\n  const [ifAttr] = node.attributes;\n  if (node.attributes.length > 1 || ifAttr && ifAttr.name !== \"if\") {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports an \\`if=\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction getBranches(tag, bodySection) {\n  const branches = BRANCHES_LOOKUP.get(tag) ?? [];\n  let nextTag = tag.getNextSibling();\n  while (nextTag.isMarkoComment()) nextTag = nextTag.getNextSibling();\n  const isLast = !(isCoreTagName(nextTag, \"else\") || isCoreTagName(nextTag, \"else-if\"));\n  branches.push([tag, bodySection]);\n  if (!isLast) {\n    BRANCHES_LOOKUP.set(nextTag, branches);\n  }\n  return [isLast, branches];\n}\nfunction isRoot(tag) {\n  return isCoreTagName(tag, \"if\");\n}\n\n// src/translator/core/import.ts\nvar import_babel_utils29 = require(\"@marko/compiler/babel-utils\");\nvar import_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils29.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: 'import <scope> from \"<path>\"',\n      description: \"Use to import external modules, follows the same syntax as JavaScript imports.\",\n      snippet: 'import ${2} from \"${1:path}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#importing-external-files\"\n    }\n  ]\n};\n\n// src/translator/core/let.ts\nvar import_compiler41 = require(\"@marko/compiler\");\nvar import_babel_utils30 = require(\"@marko/compiler/babel-utils\");\nvar let_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    let valueAttr;\n    let valueChangeAttr;\n    for (const attr2 of node.attributes) {\n      if (import_compiler41.types.isMarkoAttribute(attr2)) {\n        if (attr2.name === \"value\") {\n          valueAttr = attr2;\n        } else if (attr2.name === \"valueChange\") {\n          valueChangeAttr = attr2;\n        } else {\n          const start = attr2.loc?.start;\n          const end = attr2.loc?.end;\n          const msg = \"The `let` tag only supports the `value` attribute and its change handler.\";\n          if (start == null || end == null) {\n            throw tag.get(\"name\").buildCodeFrameError(msg);\n          } else {\n            throw tag.hub.buildError(\n              { loc: { start, end } },\n              msg,\n              Error\n            );\n          }\n        }\n      }\n    }\n    (0, import_babel_utils30.assertNoArgs)(tag);\n    (0, import_babel_utils30.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    if (!tagVar) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `let` tag requires a tag variable.\");\n    }\n    if (!import_compiler41.types.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `let` tag variable cannot be destructured.\");\n    }\n    if (valueChangeAttr && (0, import_babel_utils30.computeNode)(valueChangeAttr.value)) {\n      throw tag.get(\"attributes\").find((attr2) => attr2.node === valueChangeAttr).get(\"value\").buildCodeFrameError(\n        \"The `let` tag `valueChange` attribute must be a function.\"\n      );\n    }\n    mergeReferences(getOrCreateSection(tag), tag.node, [\n      valueAttr?.value,\n      valueChangeAttr?.value\n    ]);\n    trackVarReferences(tag, 1 /* let */, void 0, tag.node.extra);\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const tagVar = node.var;\n      const valueAttr = node.attributes.find(\n        (attr2) => import_compiler41.types.isMarkoAttribute(attr2) && (attr2.default || attr2.name === \"value\")\n      ) ?? import_compiler41.types.markoAttribute(\"value\", import_compiler41.types.identifier(\"undefined\"));\n      const valueChangeAttr = node.attributes.find(\n        (attr2) => import_compiler41.types.isMarkoAttribute(attr2) && attr2.name === \"valueChange\"\n      );\n      const section = getSection(tag);\n      const binding = tagVar.extra.binding;\n      if (isOutputDOM()) {\n        const signal = initValue(binding, \"state\");\n        const referencedBindings = tag.node.extra.referencedBindings;\n        addValue(section, referencedBindings, signal, valueAttr.value);\n        if (valueChangeAttr) {\n          signal.extraArgs = [valueChangeAttr.value];\n        }\n        signal.buildAssignment = (valueSection, value) => {\n          const scope = getScopeExpression(valueSection, signal.section);\n          return import_compiler41.types.callExpression(signal.identifier, [scope, value]);\n        };\n      } else {\n        translateVar(tag, valueAttr.value, \"let\");\n        if (valueChangeAttr) {\n          setSerializedProperty(\n            section,\n            getScopeAccessor(binding) + \"@\" /* TagVariableChange */,\n            valueChangeAttr.value\n          );\n        }\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a mutable binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#let\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/let.d.marko\"\n};\n\n// src/translator/core/lifecycle.ts\nvar import_compiler42 = require(\"@marko/compiler\");\nvar import_babel_utils31 = require(\"@marko/compiler/babel-utils\");\nvar kRef = Symbol(\"lifecycle attrs reference\");\nvar lifecycle_default = {\n  analyze(tag) {\n    (0, import_babel_utils31.assertNoArgs)(tag);\n    (0, import_babel_utils31.assertNoVar)(tag);\n    (0, import_babel_utils31.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const tagExtra = node.extra ??= {};\n    const section = getOrCreateSection(tag);\n    tagExtra[kRef] = createBinding(\n      currentProgramPath.scope.generateUid(\"lifecycle\"),\n      4 /* derived */,\n      section,\n      void 0,\n      tagExtra\n    );\n    if (node.attributes.length === 0) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `lifecycle` tag requires at least one attribute.\"\n      );\n    }\n    for (const attr2 of node.attributes) {\n      if (import_compiler42.types.isMarkoSpreadAttribute(attr2)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The `lifecycle` tag does not support `...spread` attributes.\"\n        );\n      }\n      (attr2.value.extra ??= {}).isEffect = true;\n    }\n    (currentProgramPath.node.extra ??= {}).isInteractive = true;\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const section = getSection(tag);\n      const tagExtra = node.extra;\n      const { referencedBindings } = tagExtra;\n      const lifecycleAttrsRef = tagExtra[kRef];\n      if (isOutputDOM()) {\n        const translatedAttrs = translateAttrs(tag);\n        translatedAttrs.statements.push(\n          import_compiler42.types.expressionStatement(\n            callRuntime(\n              \"lifecycle\",\n              scopeIdentifier,\n              getScopeAccessorLiteral(lifecycleAttrsRef),\n              propsToExpression(translatedAttrs.properties)\n            )\n          )\n        );\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          translatedAttrs.statements\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/lifecycle.d.marko\"\n};\n\n// src/translator/core/log.ts\nvar import_compiler43 = require(\"@marko/compiler\");\nvar import_babel_utils32 = require(\"@marko/compiler/babel-utils\");\nvar log_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils32.assertNoArgs)(tag);\n    (0, import_babel_utils32.assertNoVar)(tag);\n    (0, import_babel_utils32.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `log` tag requires a value.\");\n    }\n    if (tag.node.attributes.length > 1 || !import_compiler43.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `log` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      const statement = import_compiler43.types.expressionStatement(\n        import_compiler43.types.callExpression(\n          import_compiler43.types.memberExpression(import_compiler43.types.identifier(\"console\"), import_compiler43.types.identifier(\"log\")),\n          [value]\n        )\n      );\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to log a value to the console.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#log\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/log.d.marko\"\n};\n\n// src/translator/core/script.ts\nvar import_compiler44 = require(\"@marko/compiler\");\nvar import_babel_utils33 = require(\"@marko/compiler/babel-utils\");\nvar htmlScriptTagAlternateMsg = \" For a native html `script` tag use the `html-script` core tag instead.\";\nvar script_default = {\n  parse(tag) {\n    const { node } = tag;\n    const { body } = node.body;\n    if (body.length) {\n      let code = \"\";\n      for (const child of body) {\n        if (child.type !== \"MarkoText\") {\n          throw tag.hub.file.hub.buildError(\n            child,\n            \"Unexpected content in `script` tag. Only javascript and typescript is supported.\" + htmlScriptTagAlternateMsg,\n            SyntaxError\n          );\n        }\n        code += child.value;\n      }\n      const start = body[0]?.start;\n      const end = body[body.length - 1]?.end;\n      const bodyStatements = (0, import_babel_utils33.parseStatements)(tag.hub.file, code, start, end);\n      const valueFn = import_compiler44.types.arrowFunctionExpression(\n        [],\n        import_compiler44.types.blockStatement(bodyStatements),\n        traverseContains(bodyStatements, isAwaitExpression)\n      );\n      node.attributes.push(import_compiler44.types.markoAttribute(\"value\", valueFn));\n      node.body.body = [];\n    }\n  },\n  analyze(tag) {\n    const { node } = tag;\n    (0, import_babel_utils33.assertNoArgs)(tag);\n    (0, import_babel_utils33.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils33.assertNoAttributeTags)(tag);\n    if (node.var) {\n      throw tag.hub.buildError(\n        node.var,\n        \"The `script` tag does not support a tag variable reference.\" + htmlScriptTagAlternateMsg\n      );\n    }\n    let seenValueAttr = false;\n    for (const attr2 of node.attributes) {\n      if (attr2.type === \"MarkoAttribute\" && attr2.name === \"value\") {\n        if (seenValueAttr) {\n          throw tag.hub.buildError(attr2, \"Invalid duplicate value attribute.\");\n        }\n        seenValueAttr = true;\n        (attr2.value.extra ??= {}).isEffect = true;\n        (currentProgramPath.node.extra ??= {}).isInteractive = true;\n      } else {\n        throw tag.hub.buildError(\n          attr2,\n          \"The `script` tag does not support html attributes.\" + htmlScriptTagAlternateMsg\n        );\n      }\n    }\n    if (!seenValueAttr) {\n      dropReferences(getAllTagReferenceNodes(node));\n    }\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      if (!valueAttr) {\n        tag.remove();\n        return;\n      }\n      const section = getSection(tag);\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      if (isOutputDOM()) {\n        const { value: value2 } = valueAttr;\n        const isFunction2 = import_compiler44.types.isFunctionExpression(value2) || import_compiler44.types.isArrowFunctionExpression(value2);\n        let inlineBody = null;\n        if (isFunction2 && !(value2.async || value2.generator)) {\n          if (import_compiler44.types.isBlockStatement(value2.body)) {\n            let hasDeclaration = false;\n            for (const child of value2.body.body) {\n              if (import_compiler44.types.isDeclaration(child)) {\n                hasDeclaration = true;\n                break;\n              }\n            }\n            inlineBody = hasDeclaration ? value2.body : value2.body.body;\n          } else {\n            inlineBody = import_compiler44.types.expressionStatement(value2.body);\n          }\n        }\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          inlineBody || import_compiler44.types.expressionStatement(\n            import_compiler44.types.callExpression(value2, isFunction2 ? [] : [scopeIdentifier])\n          )\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  html: false,\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#script\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/script.d.marko\"\n};\nfunction isAwaitExpression(node) {\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ObjectMethod\":\n    case \"ClassPrivateMethod\":\n      return skip;\n    case \"AwaitExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// src/translator/core/server.ts\nvar import_compiler45 = require(\"@marko/compiler\");\nvar import_babel_utils34 = require(\"@marko/compiler/babel-utils\");\nvar server_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^server\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils34.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler45.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler45.types.markoScriptlet(body, true, \"server\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"server <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the server.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#server-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/static.ts\nvar import_compiler46 = require(\"@marko/compiler\");\nvar import_babel_utils35 = require(\"@marko/compiler/babel-utils\");\nvar static_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^static\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils35.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler46.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler46.types.markoScriptlet(body, true));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"static <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#static-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/style.ts\nvar import_compiler47 = require(\"@marko/compiler\");\nvar import_babel_utils36 = require(\"@marko/compiler/babel-utils\");\nvar import_magic_string = __toESM(require(\"magic-string\"));\nvar import_path3 = __toESM(require(\"path\"));\nvar STYLE_EXT_REG = /^style((?:\\.[a-zA-Z0-9$_-]+)+)?/;\nvar htmlStyleTagAlternateMsg = \" For a native html `style` tag use the `html-style` core tag instead.\";\nvar style_default = {\n  analyze(tag) {\n    (0, import_babel_utils36.assertNoArgs)(tag);\n    (0, import_babel_utils36.assertNoParams)(tag);\n    (0, import_babel_utils36.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    const ext = STYLE_EXT_REG.exec(node.rawValue || \"\")?.[1]?.slice(1);\n    for (const attr2 of node.attributes) {\n      if (attr2.start == null && attr2.type === \"MarkoAttribute\" && attr2.name === \"class\" && attr2.value.type === \"StringLiteral\" && attr2.value.value === ext) {\n        continue;\n      }\n      throw tag.hub.buildError(\n        attr2.value,\n        \"The `style` does not support html attributes.\" + htmlStyleTagAlternateMsg\n      );\n    }\n    for (const child of node.body.body) {\n      if (child.type !== \"MarkoText\") {\n        throw tag.hub.buildError(\n          child,\n          \"The `style` tag currently only supports static content.\" + htmlStyleTagAlternateMsg\n        );\n      }\n    }\n    if (node.body.body.length > 1) {\n      throw tag.hub.buildError(\n        node.name,\n        \"The `style` tag currently only supports static content.\" + htmlStyleTagAlternateMsg\n      );\n    }\n  },\n  translate(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const { filename, sourceMaps } = file.opts;\n    let ext = STYLE_EXT_REG.exec(node.rawValue || \"\")?.[1] || \".css\";\n    if (node.var && !/\\.module\\./.test(ext)) {\n      ext = \".module\" + ext;\n    }\n    const markoText = node.body.body[0];\n    const { resolveVirtualDependency } = getMarkoOpts();\n    const start = (0, import_babel_utils36.getStart)(file, markoText);\n    const end = (0, import_babel_utils36.getEnd)(file, markoText);\n    let code = markoText.value;\n    let map2;\n    if (resolveVirtualDependency && sourceMaps && start !== null && end !== null) {\n      const magicString = new import_magic_string.default(file.code, { filename });\n      magicString.remove(0, start);\n      magicString.remove(end, file.code.length);\n      map2 = magicString.generateMap({\n        source: filename,\n        includeContent: true\n      });\n      if (sourceMaps === \"inline\" || sourceMaps === \"both\") {\n        code += `\n/*# sourceMappingURL=${map2.toUrl()}*/`;\n        if (sourceMaps === \"inline\") {\n          map2 = void 0;\n        }\n      }\n    }\n    const importPath = resolveVirtualDependency?.(filename, {\n      virtualPath: `./${import_path3.default.basename(filename) + ext}`,\n      code,\n      map: map2\n    });\n    if (importPath) {\n      if (!node.var) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler47.types.importDeclaration([], import_compiler47.types.stringLiteral(importPath))\n        );\n      } else if (import_compiler47.types.isIdentifier(node.var)) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler47.types.importDeclaration(\n            [import_compiler47.types.importDefaultSpecifier(node.var)],\n            import_compiler47.types.stringLiteral(importPath)\n          )\n        );\n      } else {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler47.types.variableDeclaration(\"const\", [\n            import_compiler47.types.variableDeclarator(\n              node.var,\n              (0, import_babel_utils36.importDefault)(file, importPath, \"style\")\n            )\n          ])\n        );\n      }\n    }\n    tag.remove();\n  },\n  parseOptions: {\n    html: false,\n    text: true,\n    rawOpenTag: true,\n    preserveWhitespace: true\n  },\n  attributes: {}\n};\n\n// src/translator/core/try.ts\nvar import_compiler48 = require(\"@marko/compiler\");\nvar import_babel_utils37 = require(\"@marko/compiler/babel-utils\");\nvar try_default = {\n  analyze(tag) {\n    (0, import_babel_utils37.assertNoVar)(tag);\n    (0, import_babel_utils37.assertNoArgs)(tag);\n    (0, import_babel_utils37.assertNoParams)(tag);\n    (0, import_babel_utils37.assertNoAttributes)(tag);\n    assertNoSpreadAttrs(tag);\n    analyzeAttributeTags(tag);\n    const { node } = tag;\n    const section = getOrCreateSection(tag);\n    if (!node.body.body.length) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `try` tag requires body content.\");\n    }\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (!getSectionForBody(tag.get(\"body\"))) {\n          tag.remove();\n          return;\n        }\n        setAllSectionsParentIsOwner(tag);\n        flushBefore(tag);\n      },\n      exit(tag) {\n        const tagBody = tag.get(\"body\");\n        const translatedAttrs = translateAttrs(tag);\n        flushInto(tag);\n        writeHTMLResumeStatements(tagBody);\n        tag.insertBefore(translatedAttrs.statements);\n        tag.replaceWith(\n          import_compiler48.types.expressionStatement(\n            callRuntime(\n              \"tryContent\",\n              propsToExpression(translatedAttrs.properties)\n            )\n          )\n        )[0].skip();\n      }\n    },\n    dom: {\n      enter(tag) {\n        setAllSectionsParentIsOwner(tag);\n      },\n      exit(tag) {\n        tag.remove();\n      }\n    }\n  }),\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Used to capture errors and display placeholders for nested content.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#try\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/try.d.marko\"\n};\nfunction setAllSectionsParentIsOwner(tag) {\n  for (const attrTag2 of tag.get(\"attributeTags\")) {\n    if (attrTag2.isMarkoTag()) {\n      setAllSectionsParentIsOwner(attrTag2);\n    }\n  }\n  const bodySection = getSectionForBody(tag.get(\"body\"));\n  if (bodySection) {\n    setSectionParentIsOwner(bodySection, true);\n  }\n}\n\n// src/translator/core/index.ts\nvar core_default = {\n  taglibId: runtime_info_default.taglibId,\n  \"<attrs>\": attrs_default,\n  \"<await>\": await_default,\n  \"<client>\": client_default,\n  \"<const>\": const_default,\n  \"<debug>\": debug_default,\n  \"<define>\": define_default,\n  \"<effect>\": effect_default,\n  \"<else-if>\": ElseIfTag,\n  \"<else>\": ElseTag,\n  \"<export>\": export_default,\n  \"<for>\": for_default,\n  \"<html-comment>\": html_comment_default,\n  \"<html-script>\": html_script_default,\n  \"<html-style>\": html_style_default,\n  \"<id>\": id_default,\n  \"<if>\": IfTag,\n  \"<import>\": import_default,\n  \"<let>\": let_default,\n  \"<lifecycle>\": lifecycle_default,\n  \"<log>\": log_default,\n  \"<return>\": return_default,\n  \"<script>\": script_default,\n  \"<server>\": server_default,\n  \"<static>\": static_default,\n  \"<style>\": style_default,\n  \"<try>\": try_default\n};\n\n// src/translator/visitors/cdata.ts\nvar cdata_default = {\n  translate: {\n    enter(cdata) {\n      throw cdata.buildCodeFrameError(\n        \"CDATA sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/translator/visitors/comment.ts\nvar comment_default = {\n  translate: {\n    exit(comment) {\n      comment.remove();\n    }\n  }\n};\n\n// src/translator/visitors/declaration.ts\nvar declaration_default = {\n  translate: {\n    enter(decl) {\n      throw decl.buildCodeFrameError(\n        \"XML declarations sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/translator/visitors/document-type.ts\nvar document_type_default = {\n  translate: {\n    exit(documentType) {\n      if (isOutputHTML()) {\n        writeTo(documentType)`<!${documentType.node.value}>`;\n      }\n      documentType.remove();\n    }\n  }\n};\n\n// src/translator/visitors/function.ts\nvar import_compiler49 = require(\"@marko/compiler\");\nvar import_babel_utils38 = require(\"@marko/compiler/babel-utils\");\nvar functionIdsBySection = /* @__PURE__ */ new WeakMap();\nvar function_default = {\n  analyze(fn) {\n    if (fn !== getFnRoot(fn)) {\n      return;\n    }\n    const markoRoot = getMarkoRoot(fn);\n    if (markoRoot && (markoRoot.isMarkoPlaceholder() || markoRoot.isMarkoScriptlet() && markoRoot.node.target === \"server\")) {\n      return;\n    }\n    if (isMarkoAttribute(markoRoot) && ((0, import_babel_utils38.isNativeTag)(markoRoot.parentPath) && /^on[A-Z-]/.test(markoRoot.node.name) || isCoreTagName(markoRoot.parentPath, \"script\") || isCoreTagName(markoRoot.parentPath, \"lifecycle\") || isCoreTagName(markoRoot.parentPath, \"for\"))) {\n      return;\n    }\n    const { node } = fn;\n    const extra = node.extra ??= {};\n    const name2 = extra.name = fn.node.id?.name || (isMarkoAttribute(markoRoot) ? markoRoot.node.default ? import_compiler49.types.toIdentifier(\n      markoRoot.parentPath.has(\"var\") ? markoRoot.parentPath.get(\"var\") : markoRoot.parentPath.get(\"name\")\n    ) : markoRoot.node.name : import_compiler49.types.isVariableDeclarator(fn.parent) && import_compiler49.types.isIdentifier(fn.parent.id) ? fn.parent.id.name : import_compiler49.types.isObjectMethod(node) && import_compiler49.types.isIdentifier(node.key) ? node.key.name : \"anonymous\");\n    const {\n      markoOpts,\n      opts: { filename }\n    } = currentProgramPath.hub.file;\n    const section = getSection(fn);\n    let functionNameCounts = functionIdsBySection.get(section);\n    if (!functionNameCounts) {\n      functionNameCounts = /* @__PURE__ */ new Map();\n      functionIdsBySection.set(section, functionNameCounts);\n    }\n    const index = functionNameCounts.get(name2);\n    let id = \"\";\n    if (index === void 0) {\n      functionNameCounts.set(name2, 0);\n    } else {\n      functionNameCounts.set(name2, index + 1);\n      id = `_${index}`;\n    }\n    extra.section = section;\n    extra.registerId = (0, import_babel_utils38.getTemplateId)(\n      markoOpts,\n      filename,\n      `${section.id}/${name2 + id}`\n    );\n  }\n};\nfunction isMarkoAttribute(path5) {\n  return path5 ? path5.isMarkoAttribute() : false;\n}\n\n// src/translator/visitors/import-declaration.ts\nvar import_babel_utils39 = require(\"@marko/compiler/babel-utils\");\nvar import_declaration_default = {\n  analyze(importDecl) {\n    const { node } = importDecl;\n    const { source } = node;\n    const { value } = source;\n    const tagImport = (0, import_babel_utils39.resolveTagImport)(importDecl, value);\n    if (tagImport) {\n      node.extra ??= {};\n      node.extra.tagImport = tagImport;\n      const tags = importDecl.hub.file.metadata.marko.tags;\n      if (!tags.includes(tagImport)) {\n        tags.push(tagImport);\n      }\n    }\n  },\n  translate: {\n    exit(importDecl) {\n      const { node } = importDecl;\n      const { extra } = node;\n      const tagImport = extra?.tagImport;\n      if (tagImport) {\n        node.source.value = tagImport;\n      }\n    }\n  }\n};\n\n// src/translator/visitors/placeholder.ts\nvar import_compiler50 = require(\"@marko/compiler\");\nvar kBinding = Symbol(\"placeholder node binding\");\nvar kSiblingText = Symbol(\"placeholder has sibling text\");\nvar placeholder_default = {\n  analyze(placeholder) {\n    const { node } = placeholder;\n    const { confident, computed } = evaluate(node.value);\n    if (!(confident && (node.escape || isVoid2(computed)))) {\n      (node.extra ??= {})[kBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        getOrCreateSection(placeholder),\n        void 0,\n        node.value.extra\n      );\n      analyzeSiblingText(placeholder);\n    }\n  },\n  translate: {\n    exit(placeholder) {\n      const { node } = placeholder;\n      const { value } = node;\n      const { confident, computed, referencedBindings } = evaluate(value);\n      if (confident && isVoid2(computed)) {\n        placeholder.remove();\n        return;\n      }\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(placeholder);\n      const extra = node.extra || {};\n      const nodeBinding = extra[kBinding];\n      const canWriteHTML = isHTML || confident && node.escape;\n      const method = canWriteHTML ? node.escape ? \"escapeXML\" : \"toString\" : node.escape ? \"data\" : \"html\";\n      const isStateful = isStatefulReferences(referencedBindings);\n      const siblingText = extra[kSiblingText];\n      if (confident && canWriteHTML) {\n        write2`${getHTMLRuntime()[method](computed)}`;\n      } else {\n        if (siblingText === 1 /* Before */) {\n          if (isHTML && isStateful) {\n            write2`<!>`;\n          }\n          visit(placeholder, 37 /* Replace */);\n        } else if (siblingText === 2 /* After */) {\n          visit(placeholder, 37 /* Replace */);\n        } else {\n          if (!isHTML) write2` `;\n          visit(placeholder, 32 /* Get */);\n        }\n        if (isHTML) {\n          write2`${callRuntime(method, value)}`;\n          if (isStateful) {\n            markNode(placeholder, nodeBinding);\n          }\n        } else {\n          addStatement(\n            \"render\",\n            getSection(placeholder),\n            value.extra?.referencedBindings,\n            import_compiler50.types.expressionStatement(\n              method === \"data\" ? callRuntime(\n                \"data\",\n                import_compiler50.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(nodeBinding),\n                  true\n                ),\n                value\n              ) : callRuntime(\n                \"html\",\n                scopeIdentifier,\n                value,\n                getScopeAccessorLiteral(nodeBinding)\n              )\n            )\n          );\n        }\n      }\n      enterShallow(placeholder);\n      placeholder.remove();\n    }\n  }\n};\nfunction analyzeSiblingText(placeholder) {\n  const placeholderExtra = placeholder.node.extra;\n  let prev = placeholder.getPrevSibling();\n  while (prev.node) {\n    const contentType = getNodeContentType(\n      prev,\n      \"endType\"\n    );\n    if (contentType === null) {\n      prev = prev.getPrevSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 1 /* Before */;\n    } else {\n      break;\n    }\n  }\n  if (!prev.node && import_compiler50.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 1 /* Before */;\n  }\n  let next = placeholder.getNextSibling();\n  while (next.node) {\n    const contentType = getNodeContentType(\n      next,\n      \"startType\"\n    );\n    if (contentType === null) {\n      next = next.getNextSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 2 /* After */;\n    } else {\n      break;\n    }\n  }\n  if (!next.node && import_compiler50.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 2 /* After */;\n  }\n  return placeholderExtra[kSiblingText] = 0 /* None */;\n}\nfunction isVoid2(value) {\n  return value == null || value === false;\n}\n\n// src/translator/visitors/referenced-identifier.ts\nvar import_compiler51 = require(\"@marko/compiler\");\nvar abortIdsByExpressionForSection = /* @__PURE__ */ new WeakMap();\nvar referenced_identifier_default = {\n  migrate(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    switch (name2) {\n      case \"out\":\n        if (import_compiler51.types.isMemberExpression(identifier.parent) && import_compiler51.types.isIdentifier(identifier.parent.property) && identifier.parent.property.name === \"global\") {\n          identifier.parentPath.replaceWith(import_compiler51.types.identifier(\"$global\"));\n        } else {\n          throw identifier.buildCodeFrameError(\n            \"Only `out.global` is supported for compatibility.\"\n          );\n        }\n        break;\n    }\n  },\n  analyze(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    if (name2 === \"$global\") {\n      setReferencesScope(identifier);\n    } else if (name2 === \"$signal\") {\n      const section = getOrCreateSection(identifier);\n      section.hasAbortSignal = true;\n      setReferencesScope(identifier);\n    }\n  },\n  translate(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    switch (name2) {\n      case \"$global\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler51.types.callExpression(importRuntime(\"$global\"), [])\n          );\n        } else {\n          identifier.replaceWith(\n            import_compiler51.types.memberExpression(scopeIdentifier, import_compiler51.types.identifier(\"$global\"))\n          );\n        }\n        break;\n      case \"$signal\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler51.types.callExpression(\n              import_compiler51.types.arrowFunctionExpression(\n                [],\n                import_compiler51.types.blockStatement([\n                  import_compiler51.types.throwStatement(\n                    import_compiler51.types.newExpression(import_compiler51.types.identifier(\"Error\"), [\n                      import_compiler51.types.stringLiteral(\"Cannot use $signal in a server render.\")\n                    ])\n                  )\n                ])\n              ),\n              []\n            )\n          );\n        } else {\n          const section = getSection(identifier);\n          const exprRoot = getExprRoot(identifier);\n          let abortIdsByExpression = abortIdsByExpressionForSection.get(section);\n          let exprId;\n          if (abortIdsByExpression) {\n            exprId = abortIdsByExpression.get(exprRoot);\n          } else {\n            abortIdsByExpression = /* @__PURE__ */ new Map();\n            abortIdsByExpressionForSection.set(section, abortIdsByExpression);\n          }\n          if (!exprId) {\n            exprId = abortIdsByExpression.size;\n            abortIdsByExpression.set(exprRoot, exprId);\n            addStatement(\n              \"render\",\n              section,\n              exprRoot.node.extra?.referencedBindings,\n              import_compiler51.types.expressionStatement(\n                import_compiler51.types.callExpression(importRuntime(\"resetAbortSignal\"), [\n                  scopeIdentifier,\n                  import_compiler51.types.numericLiteral(exprId)\n                ])\n              )\n            );\n          }\n          identifier.replaceWith(\n            import_compiler51.types.callExpression(importRuntime(\"getAbortSignal\"), [\n              scopeIdentifier,\n              import_compiler51.types.numericLiteral(exprId)\n            ])\n          );\n        }\n    }\n  }\n};\n\n// src/translator/visitors/scriptlet.ts\nvar scriptlet_default = {\n  analyze(scriptlet) {\n    if (!scriptlet.node.static) {\n      throw scriptlet.buildCodeFrameError(\n        \"Scriptlets are not supported when using the tags api.\"\n      );\n    }\n    mergeReferences(\n      getOrCreateSection(scriptlet),\n      scriptlet.node,\n      scriptlet.node.body\n    );\n  },\n  translate: {\n    exit(scriptlet) {\n      const { node } = scriptlet;\n      const isHTML = isOutputHTML();\n      if (node.target && node.target !== (isHTML ? \"server\" : \"client\")) {\n        scriptlet.remove();\n        return;\n      }\n      if (isHTML) {\n      } else {\n        traverseReplace(node, \"body\", replaceRegisteredFunctionNode);\n        scriptlet.replaceWithMultiple(node.body);\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/index.ts\nvar import_compiler55 = require(\"@marko/compiler\");\nvar import_babel_utils43 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/visitors/tag/attribute-tag.ts\nvar import_compiler52 = require(\"@marko/compiler\");\nvar import_babel_utils40 = require(\"@marko/compiler/babel-utils\");\nvar attribute_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils40.assertNoVar)(tag);\n      (0, import_babel_utils40.assertNoArgs)(tag);\n      const body = tag.get(\"body\");\n      startSection(body);\n      trackParamsReferences(body, 3 /* param */);\n      if (!(0, import_babel_utils40.findParentTag)(tag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags must be nested within another tag.\");\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/custom-tag.ts\nvar import_compiler53 = require(\"@marko/compiler\");\nvar import_babel_utils41 = require(\"@marko/compiler/babel-utils\");\nvar import_path4 = __toESM(require(\"path\"));\nvar kChildScopeBinding = Symbol(\"custom tag child scope\");\nvar kChildOffsetScopeBinding = Symbol(\"custom tag scope offset\");\nvar kChildAttrExprs = Symbol(\"custom tag child attribute expressions\");\nvar custom_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils41.assertAttributesOrSingleArg)(tag);\n      analyzeAttributeTags(tag);\n      const templateFile = (0, import_babel_utils41.getTagTemplate)(tag);\n      if (!templateFile) {\n        const tagName = getTagName(tag);\n        if (tagName && tag.scope.hasBinding(tagName)) {\n          throw tag.get(\"name\").buildCodeFrameError(\n            `Local variables must be in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n          );\n        }\n        throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n      }\n      const section = getOrCreateSection(tag);\n      const tagBody = tag.get(\"body\");\n      const tagExtra = tag.node.extra ??= {};\n      tagExtra[kChildScopeBinding] = createBinding(\n        \"#childScope\",\n        0 /* dom */,\n        section,\n        void 0,\n        tagExtra\n      );\n      tagExtra[kChildAttrExprs] = /* @__PURE__ */ new Set([tagExtra]);\n      if (tag.has(\"var\")) {\n        trackVarReferences(tag, 4 /* derived */);\n        tag.node.var.extra.binding.scopeOffset = tagExtra[kChildOffsetScopeBinding] = createBinding(\n          \"#scopeOffset\",\n          0 /* dom */,\n          section,\n          void 0,\n          tagExtra\n        );\n      }\n      startSection(tagBody);\n      trackParamsReferences(tagBody, 3 /* param */);\n      const childFile = (0, import_babel_utils41.loadFileForTag)(tag);\n      if (childFile.opts.filename === tag.hub.file.opts.filename) {\n        mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n      } else {\n        const childProgramExtra = childFile.ast.program.extra;\n        analyzeAttrs(\n          tagExtra,\n          section,\n          tag,\n          childProgramExtra?.domExports.input\n        );\n        currentProgramPath.node.extra.hasInteractiveChild = childProgramExtra?.isInteractive || childProgramExtra?.hasInteractiveChild || false;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML(tag);\n      } else {\n        translateDOM(tag);\n      }\n    }\n  }\n};\nfunction translateHTML(tag) {\n  const tagBody = tag.get(\"body\");\n  const { node } = tag;\n  const tagExtra = node.extra;\n  let tagIdentifier;\n  flushInto(tag);\n  writeHTMLResumeStatements(tagBody);\n  if (import_compiler53.types.isStringLiteral(node.name)) {\n    const relativePath = getTagRelativePath(tag);\n    tagIdentifier = isCircularRequest(tag.hub.file, relativePath) ? import_compiler53.types.identifier(getTemplateContentName()) : (0, import_babel_utils41.importDefault)(tag.hub.file, relativePath, getTagName(tag));\n  } else {\n    tagIdentifier = node.name;\n  }\n  const tagVar = node.var;\n  const section = getSection(tag);\n  const inputExport = (0, import_babel_utils41.loadFileForTag)(tag)?.ast.program.extra?.domExports?.input;\n  const { properties, statements } = inputExport ? translateAttrs(tag, inputExport.props) : {\n    properties: [],\n    statements: []\n  };\n  let providesStatefulAttrs = false;\n  for (const expr of tagExtra[kChildAttrExprs]) {\n    if (isReferencedExtra(expr) && isStatefulReferences(expr.referencedBindings)) {\n      providesStatefulAttrs = true;\n      break;\n    }\n  }\n  if (providesStatefulAttrs || tagVar) {\n    const childScopeBinding = tagExtra[kChildScopeBinding];\n    const peekScopeId = tag.scope.generateUidIdentifier(\n      childScopeBinding?.name\n    );\n    tag.insertBefore(\n      import_compiler53.types.variableDeclaration(\"const\", [\n        import_compiler53.types.variableDeclarator(peekScopeId, callRuntime(\"peekNextScope\"))\n      ])\n    );\n    setSerializedProperty(\n      section,\n      getScopeAccessor(childScopeBinding),\n      callRuntime(\"writeExistingScope\", peekScopeId)\n    );\n    if (tagVar) {\n      statements.push(\n        import_compiler53.types.expressionStatement(\n          callRuntime(\n            \"setTagVar\",\n            getScopeIdIdentifier(section),\n            getScopeAccessorLiteral(tag.node.extra[kChildOffsetScopeBinding]),\n            peekScopeId,\n            import_compiler53.types.stringLiteral(\n              getResumeRegisterId(\n                section,\n                node.var.extra?.binding,\n                // TODO: node.var is not always an identifier.\n                \"var\"\n              )\n            )\n          )\n        )\n      );\n    }\n  }\n  if (node.extra.tagNameNullable) {\n    const contentProp = getTranslatedBodyContentProperty(properties);\n    let contentId = void 0;\n    if (contentProp) {\n      const contentExpression = contentProp.value;\n      contentProp.value = contentId = tag.scope.generateUidIdentifier(\"content\");\n      const [contentPath] = tag.insertBefore(\n        import_compiler53.types.variableDeclaration(\"const\", [\n          import_compiler53.types.variableDeclarator(\n            contentId,\n            // TODO: only register if needed (child template analysis)\n            contentExpression\n          )\n        ])\n      );\n      contentPath.skip();\n    }\n    let renderTagExpr = callExpression(\n      tagIdentifier,\n      propsToExpression(properties)\n    );\n    if (tagVar) {\n      translateVar(tag, import_compiler53.types.unaryExpression(\"void\", import_compiler53.types.numericLiteral(0)), \"let\");\n      renderTagExpr = import_compiler53.types.assignmentExpression(\"=\", tagVar, renderTagExpr);\n    }\n    statements.push(\n      import_compiler53.types.ifStatement(\n        tagIdentifier,\n        import_compiler53.types.expressionStatement(renderTagExpr),\n        contentId && callStatement(contentId)\n      )\n    );\n  } else if (tagVar) {\n    translateVar(\n      tag,\n      callExpression(tagIdentifier, propsToExpression(properties))\n    );\n    setForceResumeScope(section);\n  } else {\n    statements.push(\n      callStatement(tagIdentifier, propsToExpression(properties))\n    );\n  }\n  for (const replacement of tag.replaceWithMultiple(statements)) {\n    replacement.skip();\n  }\n}\nfunction translateDOM(tag) {\n  const tagSection = getSection(tag);\n  const { node } = tag;\n  const extra = node.extra;\n  const childScopeBinding = extra[kChildScopeBinding];\n  const write2 = writeTo(tag);\n  const { file } = tag.hub;\n  const tagName = import_compiler53.types.isIdentifier(node.name) ? node.name.name : import_compiler53.types.isStringLiteral(node.name) ? node.name.value : \"tag\";\n  const relativePath = getTagRelativePath(tag);\n  const childFile = (0, import_babel_utils41.loadFileForTag)(tag);\n  const childExports = childFile.ast.program.extra.domExports;\n  const tagIdentifier = importOrSelfReferenceName(\n    file,\n    relativePath,\n    childExports.setup,\n    tagName\n  );\n  const inputExport = childExports.input;\n  if (inputExport) {\n    writeAttrsToExports(tag, inputExport, `${getTagName(tag) || \"tag\"}_input`, {\n      circular: childFile.opts.filename === file.opts.filename,\n      tagSection,\n      relativePath,\n      childScopeBinding,\n      attrTagCallsByTag: void 0\n    });\n  }\n  write2`${(0, import_babel_utils41.importNamed)(file, relativePath, childExports.template, `${tagName}_template`)}`;\n  injectWalks(\n    tag,\n    (0, import_babel_utils41.importNamed)(file, relativePath, childExports.walks, `${tagName}_walks`)\n  );\n  if (node.var) {\n    const source = initValue(\n      // TODO: support destructuring\n      node.var.extra.binding\n    );\n    source.register = true;\n    source.buildAssignment = (valueSection, value) => {\n      return import_compiler53.types.callExpression(importRuntime(\"tagVarSignalChange\"), [\n        createScopeReadExpression(valueSection, childScopeBinding),\n        value\n      ]);\n    };\n    addStatement(\n      \"render\",\n      tagSection,\n      void 0,\n      import_compiler53.types.expressionStatement(\n        callRuntime(\n          \"setTagVar\",\n          scopeIdentifier,\n          getScopeAccessorLiteral(childScopeBinding),\n          source.identifier\n        )\n      )\n    );\n  }\n  addStatement(\n    \"render\",\n    tagSection,\n    void 0,\n    import_compiler53.types.expressionStatement(\n      import_compiler53.types.callExpression(tagIdentifier, [\n        createScopeReadExpression(tagSection, childScopeBinding)\n      ])\n    )\n  );\n  tag.remove();\n}\nfunction getTagRelativePath(tag) {\n  const {\n    node,\n    hub: { file }\n  } = tag;\n  let relativePath;\n  if (import_compiler53.types.isStringLiteral(node.name)) {\n    const template = (0, import_babel_utils41.getTagTemplate)(tag);\n    relativePath = template && (0, import_babel_utils41.resolveRelativePath)(file, template);\n  } else if (node.extra?.tagNameImported) {\n    relativePath = node.extra.tagNameImported;\n  }\n  if (!relativePath) {\n    const tagName = getTagName(tag);\n    if (tagName && tag.scope.hasBinding(tagName)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        `Local variables must be in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n      );\n    }\n    throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n  }\n  return relativePath;\n}\nfunction analyzeAttrs(rootTagExtra, section, tag, templateExport) {\n  if (!templateExport) {\n    dropReferences(getAllTagReferenceNodes(tag.node));\n    return;\n  }\n  if (!templateExport.props || tag.node.arguments?.length) {\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n    return;\n  }\n  const bodySection = getSectionForBody(tag.get(\"body\"));\n  if (bodySection) {\n    bodySection.downstreamBinding = (templateExport.props.content || templateExport.props).binding;\n  }\n  const attrTagLookup = analyzeAttributeTags(tag);\n  const seen = /* @__PURE__ */ new Set();\n  if (attrTagLookup) {\n    const nodeReferencesByGroup = /* @__PURE__ */ new Map();\n    const analyzeDynamicChildGroup = (group, child) => {\n      const referenceNodes = getAllTagReferenceNodes(child.node);\n      const groupReferences = nodeReferencesByGroup.get(group);\n      if (groupReferences) {\n        groupReferences.referenceNodes = groupReferences.referenceNodes.concat(referenceNodes);\n      } else {\n        nodeReferencesByGroup.set(group, {\n          firstTag: child,\n          referenceNodes\n        });\n      }\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n    for (const child of attrTags2) {\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils41.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExports = templateExport.props[attrTagMeta.name];\n          if (childAttrExports) {\n            if (childAttrExports.props && !attrTagMeta.dynamic) {\n              analyzeAttrs(rootTagExtra, section, child, childAttrExports);\n            } else {\n              analyzeDynamicChildGroup(attrTagMeta.group, child);\n            }\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        } else {\n          const group = child.node.extra.attributeTagGroup;\n          let childUsesGroupProp = false;\n          for (const name2 of group) {\n            if (templateExport.props[attrTagLookup[name2].name]) {\n              childUsesGroupProp = true;\n              break;\n            }\n          }\n          if (childUsesGroupProp) {\n            analyzeDynamicChildGroup(group, child);\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        }\n      }\n    }\n    for (const {\n      firstTag: { node },\n      referenceNodes\n    } of nodeReferencesByGroup.values()) {\n      mergeReferences(section, node, referenceNodes);\n      rootTagExtra[kChildAttrExprs].add(node.extra);\n    }\n  }\n  const { attributes } = tag.node;\n  let spreadReferenceNodes;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler53.types.isMarkoAttribute(attr2)) {\n      if (seen.has(attr2.name) || !templateExport.props[attr2.name]) {\n        dropReferences(attr2.value);\n        continue;\n      }\n      seen.add(attr2.name);\n    }\n    if (spreadReferenceNodes) {\n      spreadReferenceNodes.push(attr2.value);\n    } else if (import_compiler53.types.isMarkoSpreadAttribute(attr2)) {\n      spreadReferenceNodes = [attr2.value];\n    } else {\n      rootTagExtra[kChildAttrExprs].add(attr2.value.extra ??= {});\n    }\n  }\n  if (spreadReferenceNodes) {\n    mergeReferences(section, tag.node, spreadReferenceNodes);\n  }\n}\nfunction writeAttrsToExports(tag, templateExport, importAlias, info) {\n  if (tag.node.arguments?.length) {\n    const [arg] = tag.node.arguments;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    addValue(\n      info.tagSection,\n      // technically this should be `arg.extra?.referencedBindings`\n      // but we should probably ensure all other references are dropped in this case before we do that.\n      tag.node.extra?.referencedBindings,\n      identifierToSignal(tagInputIdentifier),\n      import_compiler53.types.isSpreadElement(arg) ? import_compiler53.types.memberExpression(arg.argument, import_compiler53.types.numericLiteral(0), true) : arg,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding)\n    );\n    return;\n  }\n  if (!templateExport.props || info.circular) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    const translatedAttrs = translateAttrs(tag);\n    if (translatedAttrs.statements.length) {\n      addStatement(\n        \"render\",\n        info.tagSection,\n        referencedBindings,\n        translatedAttrs.statements\n      );\n    }\n    let translatedProps = propsToExpression(translatedAttrs.properties);\n    if ((0, import_babel_utils41.isAttributeTag)(tag)) {\n      const attrTagName = getTagName(tag);\n      const parentTag = tag.parentPath;\n      const repeated = analyzeAttributeTags(parentTag)?.[attrTagName]?.repeated;\n      if (repeated) {\n        let attrTagCallsForTag = (info.attrTagCallsByTag ||= /* @__PURE__ */ new Map()).get(\n          parentTag\n        );\n        if (!attrTagCallsForTag) {\n          info.attrTagCallsByTag.set(\n            parentTag,\n            attrTagCallsForTag = /* @__PURE__ */ new Map()\n          );\n        }\n        const attrTagCall = attrTagCallsForTag.get(attrTagName);\n        if (attrTagCall) {\n          attrTagCall.expression = callRuntime(\n            \"attrTags\",\n            attrTagCall.expression,\n            translatedProps\n          );\n          return;\n        } else {\n          attrTagCallsForTag.set(\n            attrTagName,\n            translatedProps = import_compiler53.types.parenthesizedExpression(\n              callRuntime(\"attrTag\", translatedProps)\n            )\n          );\n        }\n      } else {\n        translatedProps = callRuntime(\"attrTag\", translatedProps);\n      }\n    }\n    addValue(\n      info.tagSection,\n      referencedBindings,\n      identifierToSignal(tagInputIdentifier),\n      translatedProps,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding)\n    );\n    return;\n  }\n  const seen = /* @__PURE__ */ new Set();\n  const attrTagLookup = analyzeAttributeTags(tag);\n  if (attrTagLookup) {\n    const attrTags2 = tag.get(\"attributeTags\");\n    const statementsByGroup = /* @__PURE__ */ new Map();\n    const translateDynamicAttrTagChildInGroup = (group, index) => {\n      const child = attrTags2[index];\n      let statements = statementsByGroup.get(group)?.statements;\n      if (!statements) {\n        statements = [];\n        statementsByGroup.set(group, {\n          referencedBindings: child.node.extra?.referencedBindings,\n          statements\n        });\n      }\n      return addDynamicAttrTagStatements(\n        attrTags2,\n        index,\n        attrTagLookup,\n        statements,\n        templateExport.props\n      );\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils41.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExport = templateExport.props[attrTagMeta.name];\n          if (childAttrExport) {\n            if (attrTagMeta.dynamic) {\n              i = translateDynamicAttrTagChildInGroup(attrTagMeta.group, i);\n            } else {\n              writeAttrsToExports(\n                child,\n                childAttrExport,\n                `${importAlias}_${attrTagMeta.name}`,\n                info\n              );\n            }\n          }\n        } else if (child.node.extra?.attributeTagGroup) {\n          i = translateDynamicAttrTagChildInGroup(\n            child.node.extra.attributeTagGroup,\n            i\n          );\n        }\n      }\n    }\n    for (const [\n      group,\n      { referencedBindings, statements }\n    ] of statementsByGroup) {\n      const decls = [];\n      for (const name2 of group) {\n        const attrTagMeta = attrTagLookup[name2];\n        const childAttrExports = templateExport.props[attrTagMeta.name];\n        if (!childAttrExports) continue;\n        const attrExportIdentifier = importOrSelfReferenceName(\n          tag.hub.file,\n          info.relativePath,\n          childAttrExports.id,\n          `${importAlias}_${attrTagMeta.name}`\n        );\n        decls.push(import_compiler53.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta)));\n        addValue(\n          info.tagSection,\n          referencedBindings,\n          identifierToSignal(attrExportIdentifier),\n          getAttrTagIdentifier(attrTagMeta),\n          createScopeReadExpression(info.tagSection, info.childScopeBinding)\n        );\n      }\n      addStatement(\"render\", info.tagSection, referencedBindings, [\n        import_compiler53.types.variableDeclaration(\"let\", decls),\n        ...statements\n      ]);\n    }\n  }\n  const bodySection = tag.node.body.extra?.section;\n  if (bodySection && !seen.has(\"content\")) {\n    seen.add(\"content\");\n    if (templateExport.props.content) {\n      const contentExportIdentifier = (0, import_babel_utils41.importNamed)(\n        tag.hub.file,\n        info.relativePath,\n        templateExport.props.content.id,\n        `${importAlias}_content`\n      );\n      addValue(\n        info.tagSection,\n        void 0,\n        // TODO: pretty sure content needs to have the reference group of it's param defaults.\n        identifierToSignal(contentExportIdentifier),\n        import_compiler53.types.callExpression(import_compiler53.types.identifier(bodySection.name), [scopeIdentifier]),\n        createScopeReadExpression(info.tagSection, info.childScopeBinding)\n      );\n    }\n  }\n  const { attributes } = tag.node;\n  const staticAttrs = [];\n  let spreadProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler53.types.isMarkoAttribute(attr2)) {\n      const childAttrExports = templateExport.props[attr2.name];\n      if (!childAttrExports || seen.has(attr2.name)) continue;\n      seen.add(attr2.name);\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n        continue;\n      }\n      staticAttrs.push(attr2);\n    } else if (spreadProps) {\n      spreadProps.push(import_compiler53.types.spreadElement(attr2.value));\n    } else {\n      spreadProps = [import_compiler53.types.spreadElement(attr2.value)];\n    }\n  }\n  for (const attr2 of staticAttrs.reverse()) {\n    const childAttrExports = templateExport.props[attr2.name];\n    const attrExportIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      childAttrExports.id,\n      `${importAlias}_${attr2.name}`\n    );\n    addValue(\n      info.tagSection,\n      attr2.value.extra?.referencedBindings,\n      identifierToSignal(attrExportIdentifier),\n      attr2.value,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding)\n    );\n  }\n  const missing = new Set(Object.keys(templateExport.props));\n  for (const name2 of seen) missing.delete(name2);\n  if (missing.size) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    let getMissingPropValue = buildUndefined2;\n    if (spreadProps) {\n      const spreadId = tag.scope.generateUidIdentifier(`${importAlias}_spread`);\n      spreadProps.reverse();\n      getMissingPropValue = (name2) => toMemberExpression(spreadId, name2);\n      addStatement(\"render\", info.tagSection, referencedBindings, [\n        import_compiler53.types.variableDeclaration(\"const\", [\n          import_compiler53.types.variableDeclarator(spreadId, propsToExpression(spreadProps))\n        ])\n      ]);\n    }\n    for (const name2 of missing) {\n      const childAttrExports = templateExport.props[name2];\n      const attrExportIdentifier = importOrSelfReferenceName(\n        tag.hub.file,\n        info.relativePath,\n        childAttrExports.id,\n        `${importAlias}_${name2}`\n      );\n      addValue(\n        info.tagSection,\n        referencedBindings,\n        identifierToSignal(attrExportIdentifier),\n        getMissingPropValue(name2),\n        createScopeReadExpression(info.tagSection, info.childScopeBinding)\n      );\n    }\n  }\n}\nfunction importOrSelfReferenceName(file, request, name2, nameHint) {\n  if (isCircularRequest(file, request)) {\n    return import_compiler53.types.identifier(name2);\n  }\n  return (0, import_babel_utils41.importNamed)(file, request, name2, nameHint);\n}\nfunction isCircularRequest(file, request) {\n  const { filename } = file.opts;\n  return request === filename || request[0] === \".\" && import_path4.default.resolve(filename, \"..\", request) === filename;\n}\nfunction callStatement(id, ...args) {\n  return import_compiler53.types.expressionStatement(callExpression(id, ...args));\n}\nfunction callExpression(id, ...args) {\n  return import_compiler53.types.callExpression(id, args.filter(Boolean));\n}\nfunction identifierToSignal(identifier) {\n  return {\n    identifier,\n    hasDownstreamIntersections: always\n  };\n}\nfunction buildUndefined2() {\n  return import_compiler53.types.unaryExpression(\"void\", import_compiler53.types.numericLiteral(0));\n}\nfunction always() {\n  return true;\n}\n\n// src/translator/visitors/tag/dynamic-tag.ts\nvar import_compiler54 = require(\"@marko/compiler\");\nvar import_babel_utils42 = require(\"@marko/compiler/babel-utils\");\nvar kDOMBinding = Symbol(\"dynamic tag dom binding\");\nvar kChildOffsetScopeBinding2 = Symbol(\"custom tag scope offset\");\nvar dynamic_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils42.assertAttributesOrArgs)(tag);\n      analyzeAttributeTags(tag);\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      const tagBody = tag.get(\"body\");\n      tagExtra[kDOMBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section,\n        void 0,\n        tagExtra\n      );\n      if (tag.has(\"var\")) {\n        trackVarReferences(tag, 4 /* derived */);\n        tag.node.var.extra.binding.scopeOffset = tagExtra[kChildOffsetScopeBinding2] = createBinding(\n          \"#scopeOffset\",\n          0 /* dom */,\n          section,\n          void 0,\n          tagExtra\n        );\n      }\n      startSection(tagBody);\n      trackParamsReferences(tagBody, 3 /* param */);\n      mergeReferences(section, tag.node, [\n        tag.node.name,\n        ...getAllTagReferenceNodes(tag.node)\n      ]);\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(\n        tag,\n        tag.node.var ? 49 /* DynamicTagWithVar */ : 37 /* Replace */\n      );\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const tagExtra = node.extra;\n      const nodeRef2 = tagExtra[kDOMBinding];\n      const section = getSection(tag);\n      const isClassAPI = tagExtra.featureType === \"class\";\n      const referencedBindings = tagExtra.referencedBindings;\n      let tagExpression = node.name;\n      if (import_compiler54.types.isStringLiteral(tagExpression)) {\n        tagExpression = (0, import_babel_utils42.importDefault)(\n          tag.hub.file,\n          getTagRelativePath(tag),\n          tagExpression.value\n        );\n      }\n      if (isClassAPI) {\n        if (isOutputHTML()) {\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler54.types.expressionStatement(\n              import_compiler54.types.callExpression(\n                (0, import_babel_utils42.importNamed)(tag.hub.file, getCompatRuntimeFile(), \"s\"),\n                [\n                  import_compiler54.types.identifier(tagExpression.name),\n                  import_compiler54.types.stringLiteral((0, import_babel_utils42.loadFileForTag)(tag).metadata.marko.id)\n                ]\n              )\n            )\n          );\n        } else {\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler54.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                import_compiler54.types.stringLiteral((0, import_babel_utils42.loadFileForTag)(tag).metadata.marko.id),\n                import_compiler54.types.identifier(tagExpression.name)\n              )\n            )\n          );\n        }\n      }\n      const { properties, statements } = translateAttrs(\n        tag,\n        void 0,\n        void 0,\n        isClassAPI ? \"renderBody\" : \"content\"\n      );\n      const args = [];\n      let hasMultipleArgs = false;\n      if (node.arguments?.length) {\n        args.push(...node.arguments);\n        if (properties.length) {\n          hasMultipleArgs = true;\n          args.push(propsToExpression(properties));\n        } else {\n          hasMultipleArgs = node.arguments.length > 1 || import_compiler54.types.isSpreadElement(node.arguments[0]);\n        }\n      } else {\n        const contentProp = getTranslatedBodyContentProperty(properties);\n        if (contentProp) {\n          properties.splice(properties.indexOf(contentProp), 1);\n          args.push(propsToExpression(properties), contentProp.value);\n        } else {\n          args.push(propsToExpression(properties));\n        }\n      }\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        if (node.var) {\n          if (!hasMultipleArgs && args.length === 1) {\n            args.push(import_compiler54.types.unaryExpression(\"void\", import_compiler54.types.numericLiteral(0)));\n          }\n        }\n        const dynamicScopeIdentifier = currentProgramPath.scope.generateUidIdentifier(\"dynamicScope\");\n        const dynamicTagExpr = hasMultipleArgs ? callRuntime(\n          \"dynamicTagArgs\",\n          getScopeIdIdentifier(section),\n          getScopeAccessorLiteral(nodeRef2),\n          tagExpression,\n          import_compiler54.types.arrayExpression(args)\n        ) : callRuntime(\n          \"dynamicTagInput\",\n          getScopeIdIdentifier(section),\n          getScopeAccessorLiteral(nodeRef2),\n          tagExpression,\n          ...args\n        );\n        statements.push(\n          import_compiler54.types.variableDeclaration(\"const\", [\n            import_compiler54.types.variableDeclarator(\n              dynamicScopeIdentifier,\n              callRuntime(\"peekNextScope\")\n            )\n          ])\n        );\n        if (node.var) {\n          statements.push(\n            import_compiler54.types.variableDeclaration(\"const\", [\n              import_compiler54.types.variableDeclarator(node.var, dynamicTagExpr)\n            ]),\n            import_compiler54.types.expressionStatement(\n              callRuntime(\n                \"setTagVar\",\n                getScopeIdIdentifier(section),\n                getScopeAccessorLiteral(\n                  tag.node.extra[kChildOffsetScopeBinding2]\n                ),\n                dynamicScopeIdentifier,\n                import_compiler54.types.stringLiteral(\n                  getResumeRegisterId(\n                    section,\n                    node.var.extra?.binding,\n                    // TODO: node.var is not always an identifier.\n                    \"var\"\n                  )\n                )\n              )\n            )\n          );\n        } else {\n          statements.push(import_compiler54.types.expressionStatement(dynamicTagExpr));\n        }\n        setSerializedProperty(\n          section,\n          getScopeAccessor(nodeRef2) + \"!\" /* ConditionalScope */,\n          callRuntime(\"writeExistingScope\", dynamicScopeIdentifier)\n        );\n        setSerializedProperty(\n          section,\n          getScopeAccessor(nodeRef2) + \"(\" /* ConditionalRenderer */,\n          callRuntime(\n            \"dynamicTagId\",\n            import_compiler54.types.isIdentifier(tagExpression) ? import_compiler54.types.identifier(tagExpression.name) : tagExpression\n          )\n        );\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      } else {\n        const section2 = getSection(tag);\n        const bodySection = getSectionForBody(tag.get(\"body\"));\n        const signal = getSignal(section2, nodeRef2, \"dynamicTag\");\n        let tagVarSignal;\n        if (tag.node.var) {\n          tagVarSignal = initValue(\n            // TODO: support destructuring\n            tag.node.var.extra.binding\n          );\n          tagVarSignal.register = true;\n          tagVarSignal.buildAssignment = (valueSection, value) => {\n            return import_compiler54.types.callExpression(importRuntime(\"tagVarSignalChange\"), [\n              import_compiler54.types.memberExpression(\n                getScopeExpression(tagVarSignal.section, valueSection),\n                import_compiler54.types.stringLiteral(\n                  getScopeAccessor(nodeRef2) + \"!\" /* ConditionalScope */\n                ),\n                true\n              ),\n              value\n            ]);\n          };\n        }\n        signal.build = () => {\n          return callRuntime(\n            \"dynamicTag\",\n            getScopeAccessorLiteral(nodeRef2),\n            bodySection && import_compiler54.types.identifier(bodySection.name),\n            tagVarSignal ? import_compiler54.types.arrowFunctionExpression([], tagVarSignal.identifier) : void 0,\n            hasMultipleArgs && import_compiler54.types.numericLiteral(1)\n          );\n        };\n        if (args.length) {\n          const argsOrInput = hasMultipleArgs ? import_compiler54.types.arrayExpression(args) : args[0];\n          if (!import_compiler54.types.isObjectExpression(argsOrInput) || argsOrInput.properties.length) {\n            signal.extraArgs = [\n              import_compiler54.types.arrowFunctionExpression(\n                [],\n                statements.length ? import_compiler54.types.blockStatement(\n                  statements.concat(import_compiler54.types.returnStatement(argsOrInput))\n                ) : argsOrInput\n              )\n            ];\n          }\n        }\n        signal.hasDownstreamIntersections = () => true;\n        addValue(section2, referencedBindings, signal, tagExpression);\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/index.ts\nvar TAG_NAME_IDENTIFIER_REG = /^[A-Z][a-zA-Z0-9_$]*$/;\nvar BINDING_CHANGE_HANDLER = /* @__PURE__ */ new WeakMap();\nvar tag_default = {\n  transform: {\n    enter(tag) {\n      const { node } = tag;\n      const { name: name2, attributes } = tag.node;\n      let crawl = false;\n      if (import_compiler55.types.isStringLiteral(name2)) {\n        const tagName = name2.value;\n        if (tag.scope.getBinding(tagName) && TAG_NAME_IDENTIFIER_REG.test(tagName)) {\n          node.name = withPreviousLocation(import_compiler55.types.identifier(tagName), name2);\n          crawl = true;\n        }\n      }\n      for (let i = 0; i < attributes.length; i++) {\n        const attr2 = attributes[i];\n        if (import_compiler55.types.isMarkoAttribute(attr2) && attr2.bound) {\n          attr2.bound = false;\n          attributes.splice(++i, 0, getChangeHandler(tag, attr2));\n          crawl = true;\n        }\n      }\n      if (crawl) {\n        tag.scope.crawl();\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils43.getTagDef)(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        enter(hook, tag);\n        return;\n      }\n      if (type === 0 /* NativeTag */) {\n        native_tag_default.analyze.enter(tag);\n        return;\n      }\n      switch (type) {\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.analyze.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.analyze.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const hook = (0, import_babel_utils43.getTagDef)(tag)?.analyzer?.hook;\n      if (hook) {\n        exit(hook, tag);\n        return;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils43.getTagDef)(tag);\n      const extra = tag.node.extra;\n      if (tagDef?.translator) {\n        if (tagDef.translator.path) {\n          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);\n        }\n        enter(tagDef.translator.hook, tag);\n        return;\n      }\n      for (const attr2 of tag.get(\"attributes\")) {\n        if (attr2.isMarkoAttribute()) {\n          if (attr2.node.arguments) {\n            throw attr2.buildCodeFrameError(\n              `Unsupported arguments on the \\`${attr2.node.name}\\` attribute.`\n            );\n          }\n          if (attr2.node.modifier) {\n            if ((0, import_babel_utils43.isNativeTag)(attr2.parentPath)) {\n              attr2.node.name += `:${attr2.node.modifier}`;\n            } else {\n              throw attr2.buildCodeFrameError(\n                `Unsupported modifier \\`${attr2.node.modifier}\\`.`\n              );\n            }\n          }\n        }\n      }\n      if (extra.tagNameDynamic && extra.tagNameNullable && !tag.get(\"name\").isIdentifier() && isOutputHTML()) {\n        const tagNameId = tag.scope.generateUidIdentifier(\"tagName\");\n        const [tagNameVarPath] = tag.insertBefore(\n          import_compiler55.types.variableDeclaration(\"const\", [\n            import_compiler55.types.variableDeclarator(tagNameId, tag.node.name)\n          ])\n        );\n        tagNameVarPath.skip();\n        tag.set(\"name\", tagNameId);\n      }\n      switch (extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const translator = (0, import_babel_utils43.getTagDef)(tag)?.translator;\n      if (translator) {\n        exit(translator.hook, tag);\n        return;\n      }\n      switch (tag.node.extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.exit(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.exit(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.exit(tag);\n          break;\n      }\n    }\n  }\n};\nfunction getChangeHandler(tag, attr2) {\n  const attrName = attr2.name;\n  const changeAttrName = attrName + \"Change\";\n  if (import_compiler55.types.isIdentifier(attr2.value)) {\n    const binding = tag.scope.getBinding(attr2.value.name);\n    if (!binding)\n      return import_compiler55.types.markoAttribute(\n        changeAttrName,\n        buildChangeHandlerFunction(attr2.value)\n      );\n    const existingChangedAttr = BINDING_CHANGE_HANDLER.get(binding.identifier);\n    if (!existingChangedAttr) {\n      const changeHandlerAttr = import_compiler55.types.markoAttribute(\n        changeAttrName,\n        buildChangeHandlerFunction(attr2.value)\n      );\n      BINDING_CHANGE_HANDLER.set(binding.identifier, changeHandlerAttr);\n      return changeHandlerAttr;\n    }\n    if (existingChangedAttr.type === \"Identifier\") {\n      return import_compiler55.types.markoAttribute(\n        changeAttrName,\n        withPreviousLocation(\n          import_compiler55.types.identifier(existingChangedAttr.name),\n          attr2.value\n        )\n      );\n    }\n    const markoRoot = isMarko(binding.path) ? binding.path : getMarkoRoot(binding.path);\n    if (!(markoRoot?.isMarkoTag() || markoRoot?.isMarkoTagBody())) {\n      throw tag.hub.buildError(attr2.value, \"Unable to bind to value.\");\n    }\n    const changeHandlerId = markoRoot.scope.generateUid(changeAttrName);\n    const changeHandlerConst = import_compiler55.types.markoTag(\n      import_compiler55.types.stringLiteral(\"const\"),\n      [import_compiler55.types.markoAttribute(\"value\", existingChangedAttr.value, null, null, true)],\n      import_compiler55.types.markoTagBody([]),\n      null,\n      import_compiler55.types.identifier(changeHandlerId)\n    );\n    BINDING_CHANGE_HANDLER.set(\n      binding.identifier,\n      existingChangedAttr.value = import_compiler55.types.identifier(changeHandlerId)\n    );\n    if (markoRoot.isMarkoTag()) {\n      markoRoot.insertAfter(changeHandlerConst);\n    } else {\n      markoRoot.unshiftContainer(\"body\", changeHandlerConst);\n    }\n    return import_compiler55.types.markoAttribute(\n      changeAttrName,\n      withPreviousLocation(import_compiler55.types.identifier(changeHandlerId), attr2.value)\n    );\n  } else if (import_compiler55.types.isMemberExpression(attr2.value)) {\n    const prop = attr2.value.property;\n    if (!import_compiler55.types.isPrivateName(attr2.value.property)) {\n      return import_compiler55.types.markoAttribute(\n        changeAttrName,\n        import_compiler55.types.memberExpression(\n          import_compiler55.types.cloneNode(attr2.value.object),\n          prop.type === \"Identifier\" ? withPreviousLocation(import_compiler55.types.identifier(prop.name + \"Change\"), prop) : import_compiler55.types.binaryExpression(\n            \"+\",\n            import_compiler55.types.cloneNode(prop),\n            import_compiler55.types.stringLiteral(\"Change\")\n          ),\n          prop.type !== \"Identifier\"\n        )\n      );\n    }\n  }\n  throw tag.hub.buildError(\n    attr2.value,\n    \"Attributes may only be bound to identifiers or member expressions\"\n  );\n}\nfunction buildChangeHandlerFunction(id) {\n  const newId = \"_new_\" + id.name;\n  return import_compiler55.types.arrowFunctionExpression(\n    [withPreviousLocation(import_compiler55.types.identifier(newId), id)],\n    import_compiler55.types.blockStatement([\n      import_compiler55.types.expressionStatement(\n        import_compiler55.types.assignmentExpression(\n          \"=\",\n          withPreviousLocation(import_compiler55.types.identifier(id.name), id),\n          withPreviousLocation(import_compiler55.types.identifier(newId), id)\n        )\n      )\n    ])\n  );\n}\n\n// src/translator/visitors/text.ts\nvar import_compiler56 = require(\"@marko/compiler\");\nvar text_default = {\n  translate: {\n    exit(text) {\n      writeTo(text)`${text.node.value}`;\n      enterShallow(text);\n      text.remove();\n    }\n  }\n};\n\n// src/translator/index.ts\nvar visitors = extractVisitors({\n  Program: program_default,\n  Function: function_default,\n  ReferencedIdentifier: referenced_identifier_default,\n  ImportDeclaration: import_declaration_default,\n  MarkoDocumentType: document_type_default,\n  MarkoDeclaration: declaration_default,\n  MarkoCDATA: cdata_default,\n  MarkoText: text_default,\n  MarkoTag: tag_default,\n  MarkoPlaceholder: placeholder_default,\n  MarkoScriptlet: scriptlet_default,\n  MarkoComment: comment_default\n});\nvar tagDiscoveryDirs = [\"tags\"];\nvar preferAPI = \"tags\";\nvar { transform, analyze, translate } = visitors;\nvar taglibs = [\n  [\n    __dirname,\n    {\n      ...core_default,\n      migrate: visitors.migrate\n    }\n  ]\n];\nfunction getRuntimeEntryFiles(output, optimize) {\n  return [\n    `${runtime_info_default.name}${optimize ? \"\" : \"/debug\"}/${output === \"html\" ? \"html\" : \"dom\"}`\n  ];\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  analyze,\n  getRuntimeEntryFiles,\n  internalEntryBuilder,\n  preferAPI,\n  tagDiscoveryDirs,\n  taglibs,\n  transform,\n  translate\n});\n"],"names":["mod","__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__copyProps","to","from","except","desc","key","call","get","enumerable","__toESM","isNodeMode","target","__esModule","value","translator_exports","__export","all","name2","analyze","getRuntimeEntryFiles","internalEntryBuilder","entry_builder_default","preferAPI","tagDiscoveryDirs","taglibs","transform","translate","module","exports","runtime_info_default","name","require","taglibId","import_compiler","import_babel_utils","assertNoSpreadAttrs","tag","attr2","isMarkoSpreadAttribute","buildCodeFrameError","node","assertNoBodyContent","body","length","attrs_default","migrate","assertNoArgs","assertNoParams","assertNoAttributes","assertNoAttributeTags","diagnosticDeprecate","label","fix","tagVar","var","type","remove","constTag","types","markoTag","stringLiteral","markoAttribute","identifier","markoTagBody","replaceWith","attributes","autocomplete","displayText","description","snippet","import_compiler23","import_babel_utils12","import_babel_utils2","evaluate","extra","confident","computed","computeNode","import_compiler22","import_compiler20","import_babel_utils11","import_path2","bindingHasDownstreamExpressions","binding","downstreamExpressions","size","alias","aliases","propertyAliases","values","import_compiler2","import_babel_utils3","kState","Symbol","build","entryFile","state","path","imports","map","it","importDeclaration","init","unshift","importSpecifier","markoOpts","optimize","push","expressionStatement","callExpression","visit","file","visitChild","analyzedTags","metadata","marko","resolveRelativePath","opts","filename","hasInteractiveChild","isInteractive","isOutputHTML","getMarkoOpts","output","isOutputDOM","currentProgramPath","hub","isOptimize","import_compiler4","import_babel_utils4","stringifyClassObject","stringifyStyleObject","test","toDelimitedString","val","delimiter","stringify","result","curDelimiter","Array","isArray","v","part","isEventHandler","getEventHandlerName","slice","toLowerCase","toString","unsafeXMLReg","replaceUnsafeXML","c","escapeXML","str","replace","unsafeScriptReg","escapeScript","unsafeStyleReg","escapeStyle","toAccess","accessor","start","classAttr","stringAttr","classValue","styleAttr","styleValue","attr","isVoid","attrAssignment","RegExp","source","nonVoidAttr","constructor","async","KNOWN_SYMBOLS2","Map","symbol","set","AggregateError","of","ArrayBuffer","isView","Atomics","add","and","compareExchange","exchange","isLockFree","load","notify","or","store","sub","wait","BigInt","asIntN","asUintN","BigInt64Array","BigUint64Array","Boolean","console","assert","clear","count","countReset","debug","dir","dirxml","error","group","groupCollapsed","groupEnd","info","log","table","time","timeEnd","timeLog","timeStamp","trace","warn","DataView","Date","now","parse","UTC","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","Error","EvalError","Float32Array","Float64Array","Function","globalThis","atob","btoa","clearImmediate","clearInterval","clearTimeout","crypto","getRandomValues","randomUUID","fetch","performance","queueMicrotask","setImmediate","setInterval","setTimeout","structuredClone","URL","URLSearchParams","WritableStream","Int16Array","Int32Array","Int8Array","Intl","Collator","DateTimeFormat","DisplayNames","getCanonicalLocales","ListFormat","Locale","NumberFormat","PluralRules","RelativeTimeFormat","Segmenter","supportedValuesOf","isFinite","isNaN","JSON","groupBy","Math","abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","floor","fround","hypot","imul","log10","log1p","log2","max","min","pow","random","round","sign","sin","sinh","sqrt","tan","tanh","trunc","Number","isInteger","isSafeInteger","parseFloat","parseInt","assign","defineProperties","entries","freeze","fromEntries","getOwnPropertyDescriptors","getOwnPropertySymbols","is","isExtensible","isFrozen","isSealed","keys","preventExtensions","seal","setPrototypeOf","Promise","Proxy","RangeError","ReferenceError","Reflect","apply","construct","deleteProperty","has","ownKeys","Set","String","fromCharCode","fromCodePoint","raw","for","SyntaxError","TypeError","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","URIError","WeakMap","WeakSet","singleQuoteAttrReplacements","doubleQuoteAttrReplacements","needsQuotedAttr","lastIndex","replaceUnsafeSingleQuoteAttrChar","escapeSingleQuotedAttrValue","replaceUnsafeDoubleQuoteAttrChar","escapeDoubleQuotedAttrValue","match","import_compiler3","isValidPropertyIdentifier","toPropertyName","numericLiteral","toObjectProperty","objectProperty","toMemberExpression","object","optional","prop","optionalMemberExpression","memberExpression","pureFunctions","importRuntime","importStar","getRuntimePath","callRuntime","args","callExpression2","filteredArgs","i","arg","unaryExpression","filterArguments","includes","leadingComments","getHTMLRuntime","getCompatRuntimeFile","modules","import_compiler6","import_babel_utils7","import_babel_utils5","getTagName","isCoreTag","isMarkoTag","tagDef","getTagDef","isCoreTagName","isConditionTag","Sorted","compare","this","data","item","addSorted","joinRepeatable","union","a","b","aLen","bLen","aIndex","bIndex","aValue","bValue","delta","unionSortedRepeatable","find","findSorted","forEach","cb","pos","mid","cur","compareResult","len","next","createProgramState","map2","createSectionState","section","arrayOfSectionData","id","import_compiler5","import_babel_utils6","MARKO_FILE_REG","analyzeTagNameType","tagNameType","isStringLiteral","isNativeTag","tagNameNullable","isIdentifier","pending","path5","tagNameImported","nullable","pop","isConditionalExpression","alternate","isLogicalExpression","operator","isAssignmentExpression","isBinaryExpression","isTemplateLiteral","isNullLiteral","scope","getBinding","kind","decl","parent","specifiers","some","isImportDefaultSpecifier","resolvedImport","resolveTagImport","bindingTag","bindingTagName","tagNameDynamic","analyzeExpressionTagName","expressions","childFile","loadFileForTag","ast","program","featureType","needsCompat","sectionUtil","startSection","parentSection","parentPath","getOrCreateSection","sectionNamePath","sectionName","isProgram","generateUid","programExtra","sections","loc","depth","sectionAccessor","params","referencedClosures","referencedHoists","bindings","hoisted","isHoistThrough","assignments","content","getContentInfo","upstreamExpression","downstreamBinding","hasAbortSignal","isBranch","attributeTags","isNativeNode","getSectionForBody","getSection","currentPath","getScopeIdIdentifier","generateUidIdentifier","getSectionParentIsOwner","setSectionParentIsOwner","_getScopeIdentifier","forEachSection","fn","contentInfo","startType","endType","singleChild","endIndex","getNodeContentType","startIndex","extraMember","isAttributeTag","tagSection","isSerializedSection","serialize","checkStatefulClosures","immediateOnly","closure","isStatefulReferences","isImmediateOwner","isDynamicClosure","isSameOrChildSection","other","import_compiler18","import_babel_utils10","import_path","regexpCharsReg","import_compiler17","import_babel_utils9","import_compiler11","import_babel_utils8","getKnownAttrValues","attrs2","getParentTag","import_compiler7","enter","modulePlugin","plugin","isModulePlugin","default","isFunctionPlugin","exit","translateByTarget","html","dom","import_compiler10","import_compiler8","normalizeStringExpression","parts","strs","exprs","curStr","nextIndex","exprLen","shiftItems","quasis","j","templateLiteral","templateElement","appendLiteral","arr","list","offset","getWalks","getWalkComment","getSteps","walkCodeToName","enter2","exit2","enterShallow","code","steps","walks","walkComment","walkString","walkCodes","step","lastIndexOf","current","walk","nCodeString","writeTo","number","toCharString","startCode","rangeSize","multiplier","getWalkString","prefix2","postfix","walkLiteral","join","getWrites","getTrailerWrites","trailer","exprsLen","writes","consumeHTML","trailers","writeResult","trailerResult","sequenceExpression","flushBefore","expr","insertBefore","skip","flushInto","pushContainer","getSectionMeta","writePrefix","writePostfix","setup","getSetup","markNode","getScopeAccessorLiteral","tagsWithReturn","getSectionReturnValueIdentifier","setReturnValueIdentifier","return_default","assertNoVar","assertAllowedAttributes","parentTag","isControlFlowTag","valueChange","setSerializedProperty","returnId","variableDeclaration","variableDeclarator","addValue","referencedBindings","hasDownstreamIntersections","parseOptions","openTagOnly","descriptionMoreURL","forEachIdentifier","properties","left","argument","el","elements","import_compiler12","getDeclaredBindingExpression","declared","upstreamAlias","property","import_compiler13","createScopeReadPattern","rootDepth","rootPattern","objectPattern","nestedPatterns","ref","propertyValue","propertyKey","getScopeAccessor","isShorthand","pattern","relativeDepth","prev","nestedPattern","getScopeExpression","targetSection","scopeIdentifier","diff","createScopeReadExpression","reference","propName","import_compiler14","simplifyFunction","functionExpression","generator","import_compiler15","toFirstExpressionOrBlock","stmts","isExpressionStatement","expression","toParenthesizedExpressionIfNeeded","blockStatement","parenthesizedExpression","import_compiler16","traverseReplace","container","enter3","VISITOR_KEYS","replacement","traverseContains","check","getSignals","getClosureSignalBuilder","_setClosureSignalBuilder","setClosureSignalBuilder","builder","forceResumeScope","_setForceResumeScope","setForceResumeScope","getSerializedScopeProperties","getSectionWriteScopeBuilder","setSectionWriteScopeBuilder","addWriteScopeBuilder","htmlDynamicClosureInstancesIdentifier","getHTMLSectionStatements","getHoistFunctionsIdsMap","getHoistFunctionIdentifier","hoistedBinding","idsMap","unimplementedBuild","getSignal","generateSignalName","signals","signal","exportName","export","domExports","intersection","render","renderReferencedBindings","effect","effectReferencedBindings","subscribers","subscribe","scopeOffset","intersectionMeta","getSignalFn","bindingUtil","arrowFunctionExpression","initValue","runtimeHelper","isParamBinding","needsCache","needsMarks","hoists","valueAccessor","scopeIdentifier2","valueIdentifier","isValueSignal","aliasSignal","getTranslatedExtraArgs","dynamicClosureArgs","dynamicClosureSignalIdentifier","closureSections","closureSection","prependStatements","effectIdentifier","hasTranslatedExtraArgs","emptyExtraArgs","extraArgs","replaceRenderNode","provider","subscriber","p","providerSignal","replaceNullishAndEmptyFunctionsWith0","isArrowFunctionExpression","isBlockStatement","isUnaryExpression","isNumericLiteral","addStatement","statement","usedReferences","statements","addEffectReferences","addRenderReferences","getResumeRegisterId","getTemplateId","usedRegisterIdsBySection","getRegisterUID","used","baseId","writeSignals","accessors","currentSection","getSectionInstancesAccessorLiteral","hoistIdentifier","sort","sortSignals","value2","effectDeclarator","replaceEffectNode","referencesScope","isScopeIdentifier","isCallExpression","arguments","register","signalDeclarator","signalDeclaration","isFunctionExpression","functionDeclaration","isExpression","exportNamedDeclaration","signalStatements","toReturnedFunction","rawFn","returnStatement","aReferencedBindings","getReferencedBindings","bReferencedBindings","reserve","getMappedId","addHTMLEffectCall","writeHTMLResumeStatements","allSignals","scopeIdIdentifier","serializeOwnersUntilBindingSection","currentSerialized","closureSignal","newExpression","index","getDynamicClosureIndex","sectionDynamicSubscribers","subscribersIdentifier","getSectionInstancesAccessor","signalRefs","serializedLookup","serializedProperties","delete","writeScopeBuilder","shorthand","writeScopeArgs","objectExpression","debugVars","root","access","locExpr","line","column","arrayExpression","filenameRelative","additionalStatements","unshiftContainer","returnIdentifier","replaceAssignedNode","replaceBindingReadNode","replaceRegisteredFunctionNode","getReadReplacement","isAssignedBindingExtra","buildAssignment","assignment","binaryExpression","prefix","right","resultId","assignmentExpression","registeredFnsForProgram","getRegisteredFnExpression","classProperty","classPrivateProperty","isRegisteredFnExtra","referencedBindingsInFunction","registedFns","registerId","dom_default","templateIdentifier","template","walksIdentifier","setupIdentifier","inputBinding","programInputSignal","styleFile","fs","fileSystem","base","sep","leftDot","indexOf","rightDot","closeBracket","openBracket","getBase","styleMatch","file2","readdirSync","dirname","getStyleFile","importDefault","forEachSectionReverse","childSection","tagParamsSignal","walks2","writes2","setup2","renderer","registeredFns","registeredFn","assignmentPattern","stmt","writeRegisteredFns","exportDefaultDeclaration","import_compiler19","templateContentIdentifierForProgram","html_default","replaceNode","renderContent","child","isImportDeclaration","isExportDeclaration","isMarkoScriptlet","static","replaceWithMultiple","contentId","contentFn","exportDefault","read","replaceBindingReadNode2","getRegisteredFnExpression2","registeredFnDeclarations","registeredFnDeclarationsByBody","addRegisteredDeclarations","replaceRegisteredFunctionNode2","previousProgramPath","program_default","crawl","trackParamsReferences","input","closures","getBindings","readsByExpression","getReadsByExpression","readsByFn","getReadsByFunction","mergedReferences","getMergedReferences","nodes","targetExtra","reads","isEffect","isReferencedExtra","additionalReads","concat","intersectionsBySection","resolveReferencedBindings","pruneBinding","resolveBindingSources","name3","section2","bindingReference","intersections","numReferences","binding1","binding2","isSuperset","sources","sourceSection","intersectionIndex","bindings2","isOwnedBinding","lastBindingIndex","filter","bindingIndex","at","getMaxOwnSourceOffset","finalizeReferences","buildTemplateExports","visitedFiles","resolved","loadFileForImport","req","resolveRelativeToEntry","compatFile","templateExport","props","getMarkoRoot","curPath","isMarko","getExprRoot","getFnRoot","fnPath","isFunction","declare","isInvokedFunction","callee","withPreviousLocation","newNode","originalNode","end","kIsInvoked","getNextBindingId","setNextBindingId","createBinding","excludeProperties","propBinding","trackVarReferences","canonicalUpstreamAlias","getCanonicalBinding","pruned","createBindingsAndTrackReferences","paramsBinding","trackHoistedReference","referencePath","referenceSection","hoistSection","ancestor","getCommonSection","createRead","trackReference","trackAssignment","setReferencesScope","fnRoot","lVal","babelBinding","referencePaths","constantViolations","isUpdateExpression","trackReferencesForBinding","patternBinding","element","propPath","isMemberExpression","getMemberExpressionPropString","isEventOrChangeHandler","exprRoot","exprExtra","addReadToExpression","fnExtra","mergeReferences","compareIntersections","lenDelta","sourceBinding","subset","elem","derived","curBinding","dropReferences","getAllTagReferenceNodes","referenceNodes","includeId","suffix","shouldPrune","exprReference","resolveExpressionReference","readBinding","readProps","aliasProps","isStatefulBinding","await_default","valueAttr","isMarkoAttribute","isSpreadElement","bodySection","tagBody","import_compiler24","import_babel_utils13","client_default","rawValue","trim","parseStatements","markoScriptlet","rawOpenTag","import_compiler26","import_babel_utils14","import_compiler25","translateVar","initialValue","const_default","varBinding","derivation","import_compiler27","import_babel_utils15","debug_default","debuggerStatement","import_babel_utils21","import_compiler28","import_babel_utils16","attrTagToIdentifierLookup","getAttrTagIdentifier","meta","analyzeAttributeTags","attrTags2","lookup","attrTagNodesByName","sampleAttrTagsForControlFlow","createAttrTagMeta","isRepeated","isLoopTag","curGroup","crawlAttrTags","oldMeta","attrTagMeta","dynamic","repeated","controlFlowTag","sampleAttrName","attributeTagGroup","attrTagNodes","hasRepeatedDynamicAttrTags","attrTagNames","tagName","conditionRoot","seenBranches","attrTag2","curConditionRoot","getConditionRoot","getPrevSibling","import_compiler32","import_babel_utils20","import_compiler31","import_babel_utils19","import_babel_utils18","import_compiler29","import_babel_utils17","kNativeTagBinding","kSerializeMarker","kGetterId","htmlSelectArgs","getRelatedControllable","checked","checkedChange","special","helper","attrs","checkedValue","checkedValueChange","open","openChange","native_tag_default","escape","buildError","buildUndefined","hasEventHandlers","hasDynamicAttributes","seen","relatedControllable","spreadReferenceNodes","exclusiveGroups","assertExclusiveControllableGroups","every","tagName2","toIdentifier","tagExtra","bindingName","tagBinding","nodeRef2","isHTML","write2","varName","getterId","hoist","getterFnIdentifier","visitAccessor","usedAttrs","maybeStaticAttrs","spreadExpression","skipExpression","spreadProps","skipProps","staticControllable","attr3","spreadElement","staticAttrs","reverse","propsToExpression","getUsedAttrs","writeAtStartOfBody","firstAttr","spreadIdentifier","valueReferences","htmlType","ifStatement","selectArgs","shouldMark","kOnlyChildInParent","kNodeRef","isOnlyChildInParent","branchSize","getOptimizedOnlyChildNodeRef","parentTagName","for_default","isAttrTag","allowAttrs","getForType","isStateful","onlyChildInParentOptimization","forAttrs","forType","bodyStatements","hasStatefulClosures","hasHoists","singleNodeOptimization","keyExpression","defaultParamNames","in","defaultByParamIndex","requiredParamsIndex","by","existingParam","byIdentifier","forTypeToHTMLByRuntime","forScopesIdentifier","getScopeIdentifier","scopeId","conditionalExpression","forTagArgs","getBaseArgsInForTag","forTagHTMLRuntime","forTypeToHTMLResumeRuntime","forTypeToRuntime","forTypeToDOMRuntime","param","referencedBindings2","loopArgs","controlFlow","contentProps","translateAttrs","templateExports","contentKey","attrTagLookup","usesExport","addDynamicAttrTagStatements","translatedAttrTag","prevProp","findObjectProperty","contentExpression","serialized","isTransparentTag","getNonAttributeTagParent","buildContent","contentProp","getTranslatedBodyContentProperty","ifTag","consequentStatements","getConditionTestValue","addAllAttrTagsAsDynamic","nextTag","testValue","alternateStatements","translateIfAttrTag","forTag","buildForRuntimeCall","translateForAttrTag","define_default","translatedAttrs","import_compiler34","import_babel_utils22","effect_default","import_babel_utils23","export_default","import_compiler35","import_babel_utils24","kCommentTagBinding","kGetterId2","html_comment_default","needsBinding","needsGetter","isMarkoPlaceholder","isMarkoText","commentBinding","references","templateQuasis","templateExpressions","currentQuasi","text","import_compiler36","import_babel_utils25","kGetterId3","html_script_default","bodyPlaceholderNodes","hasBodyPlaceholders","getUsedAttrs2","referencePlaceholder","preserveWhitespace","import_compiler37","import_babel_utils26","kGetterId4","html_style_default","getUsedAttrs3","import_compiler38","import_babel_utils27","id_default","import_compiler40","import_babel_utils28","import_compiler39","BRANCHES_LOOKUP","IfTag","assertHasBody","assertHasValueAttribute","assertHasPrecedingCondition","ifAttr","msg","assertOptionalIfAttribute","assertValidCondition","isLast","branches","getBranches","rootTag","rootExtra","mergeReferenceNodes","branchTag","branchBodySection","isRoot","getNextSibling","ifScopeIdIdentifier","ifBranchIdentifier","branchHasStatefulClosures","branchHasHoists","testAttr","curStatement","cbNode","rendererIdentifiers","consequent","ElseIfTag","ElseTag","isMarkoComment","import_babel_utils29","import_default","import_compiler41","import_babel_utils30","let_default","valueChangeAttr","valueSection","import_compiler42","import_babel_utils31","kRef","lifecycle_default","lifecycleAttrsRef","import_compiler43","import_babel_utils32","log_default","import_compiler44","import_babel_utils33","htmlScriptTagAlternateMsg","script_default","valueFn","isAwaitExpression","seenValueAttr","isFunction2","inlineBody","hasDeclaration","isDeclaration","import_compiler45","import_babel_utils34","server_default","import_compiler46","import_babel_utils35","static_default","import_compiler47","import_babel_utils36","import_magic_string","import_path3","STYLE_EXT_REG","htmlStyleTagAlternateMsg","style_default","ext","exec","sourceMaps","markoText","resolveVirtualDependency","getStart","getEnd","magicString","generateMap","includeContent","toUrl","importPath","virtualPath","basename","importDefaultSpecifier","import_compiler48","import_babel_utils37","try_default","setAllSectionsParentIsOwner","core_default","cdata_default","cdata","comment_default","comment","declaration_default","document_type_default","documentType","import_compiler49","import_babel_utils38","functionIdsBySection","function_default","markoRoot","isVariableDeclarator","isObjectMethod","functionNameCounts","import_babel_utils39","import_declaration_default","importDecl","tagImport","tags","import_compiler50","kBinding","kSiblingText","placeholder_default","placeholder","isVoid2","placeholderExtra","contentType","analyzeSiblingText","nodeBinding","canWriteHTML","method","siblingText","import_compiler51","abortIdsByExpressionForSection","referenced_identifier_default","hasBinding","throwStatement","exprId","abortIdsByExpression","scriptlet_default","scriptlet","import_compiler55","import_babel_utils43","import_babel_utils40","attribute_tag_default","findParentTag","import_compiler53","import_babel_utils41","import_path4","kChildScopeBinding","kChildOffsetScopeBinding","kChildAttrExprs","custom_tag_default","assertAttributesOrSingleArg","getTagTemplate","charAt","toUpperCase","childProgramExtra","analyzeAttrs","tagIdentifier","relativePath","getTagRelativePath","isCircularRequest","getTemplateContentName","inputExport","providesStatefulAttrs","childScopeBinding","peekScopeId","contentPath","renderTagExpr","callStatement","translateHTML","childExports","importOrSelfReferenceName","writeAttrsToExports","circular","attrTagCallsByTag","importNamed","injectWalks","translateDOM","rootTagExtra","nodeReferencesByGroup","analyzeDynamicChildGroup","groupReferences","firstTag","attrTagName","childAttrExports","childUsesGroupProp","importAlias","tagInputIdentifier","identifierToSignal","translatedProps","attrTagCallsForTag","attrTagCall","statementsByGroup","translateDynamicAttrTagChildInGroup","childAttrExport","decls","attrExportIdentifier","contentExportIdentifier","missing","getMissingPropValue","buildUndefined2","spreadId","request","nameHint","resolve","always","import_compiler54","import_babel_utils42","kDOMBinding","kChildOffsetScopeBinding2","dynamic_tag_default","assertAttributesOrArgs","isClassAPI","tagExpression","hasMultipleArgs","splice","dynamicScopeIdentifier","dynamicTagExpr","tagVarSignal","argsOrInput","isObjectExpression","TAG_NAME_IDENTIFIER_REG","BINDING_CHANGE_HANDLER","tag_default","bound","getChangeHandler","hook","analyzer","translator","watchFiles","modifier","tagNameId","tagNameVarPath","changeAttrName","buildChangeHandlerFunction","existingChangedAttr","changeHandlerAttr","isMarkoTagBody","changeHandlerId","changeHandlerConst","insertAfter","isPrivateName","cloneNode","newId","visitors","visitors2","_name","extractVisitors","Program","ReferencedIdentifier","ImportDeclaration","MarkoDocumentType","MarkoDeclaration","MarkoCDATA","MarkoText","MarkoTag","MarkoPlaceholder","MarkoScriptlet","MarkoComment"],"sourceRoot":""}