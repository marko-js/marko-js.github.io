{"version":3,"file":"215.6107c339.js","mappings":"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","sources":["webpack:///../../node_modules/@marko/translator-tags/dist/index.js"],"sourcesContent":["\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  analyze: () => analyze,\n  getRuntimeEntryFiles: () => getRuntimeEntryFiles,\n  internalEntryBuilder: () => entry_builder_default,\n  taglibs: () => taglibs,\n  transform: () => transform,\n  translate: () => translate\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/util/is-core-tag.ts\nvar import_babel_utils = require(\"@marko/babel-utils\");\n\n// src/util/get-tag-name.ts\nfunction getTagName(tag) {\n  return tag.node.name.value;\n}\n\n// src/util/is-core-tag.ts\nvar taglibId = \"marko-core\";\nvar interopTaglibId = \"@marko/translator-interop-class-tags\";\nfunction isCoreTag(tag) {\n  const id = tag.isMarkoTag() && (0, import_babel_utils.getTagDef)(tag)?.taglibId;\n  return id === taglibId || id === interopTaglibId;\n}\nfunction isCoreTagName(tag, name) {\n  return isCoreTag(tag) && getTagName(tag) === name;\n}\nfunction isConditionTag(tag) {\n  if (isCoreTag(tag)) {\n    switch (getTagName(tag)) {\n      case \"if\":\n      case \"else-if\":\n      case \"else\":\n        return true;\n    }\n  }\n  return false;\n}\n\n// src/core/__flush_here_and_after__.ts\nvar import_babel_utils2 = require(\"@marko/babel-utils\");\nvar flush_here_and_after_default = {\n  transform: [\n    (tag) => {\n      if ((0, import_babel_utils2.getTagDef)(tag)?.renderer) {\n        return;\n      }\n      tag.replaceWithMultiple(tag.node.body.body);\n    }\n  ]\n};\n\n// src/core/attrs.ts\nvar import_compiler = require(\"@marko/compiler\");\nvar attrs_default = {\n  migrate: [\n    (tag) => {\n      const tagVar = tag.node.var;\n      if (tagVar && !(tagVar.type === \"Identifier\" && tagVar.name === \"input\")) {\n        const constTag = import_compiler.types.markoTag(\n          import_compiler.types.stringLiteral(\"const\"),\n          [import_compiler.types.markoAttribute(\"value\", import_compiler.types.identifier(\"input\"))],\n          import_compiler.types.markoTagBody([])\n        );\n        constTag.var = tagVar;\n        tag.replaceWith(constTag);\n      } else {\n        tag.remove();\n      }\n    }\n  ],\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"attrs/{ ... }\",\n      description: \"Use to receive the attributes passed into this template.\",\n      snippet: \"attrs/{ $1 }$2\"\n    }\n  ]\n};\n\n// src/core/client.ts\nvar import_babel_utils3 = require(\"@marko/babel-utils\");\nvar import_compiler2 = require(\"@marko/compiler\");\nvar client_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^client\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils3.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler2.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler2.types.markoScriptlet(body, true, \"client\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"client <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the client.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#client-javascript\"\n    }\n  ]\n};\n\n// src/core/const.ts\nvar import_babel_utils11 = require(\"@marko/babel-utils\");\nvar import_compiler18 = require(\"@marko/compiler\");\n\n// src/util/assert.ts\nfunction assertNoSpreadAttrs(tag) {\n  for (const attr2 of tag.get(\"attributes\")) {\n    if (attr2.isMarkoSpreadAttribute()) {\n      throw attr2.buildCodeFrameError(\n        `The \\`${tag.get(\"name\").node.value}\\` tag does not support \\`...spread\\` attributes.`\n      );\n    }\n  }\n}\nfunction assertNoBodyContent(tag) {\n  if (tag.node.body.body.length) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${tag.get(\"name\").node.value}\\` tag does not support body content.`\n    );\n  }\n}\n\n// src/visitors/program/index.ts\nvar import_babel_utils10 = require(\"@marko/babel-utils\");\nvar import_compiler16 = require(\"@marko/compiler\");\nvar import_path = __toESM(require(\"path\"));\n\n// src/util/binding-has-downstream-expressions.ts\nfunction bindingHasDownstreamExpressions(binding) {\n  if (binding.downstreamExpressions.size) return true;\n  for (const alias of binding.aliases) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  return false;\n}\n\n// src/util/entry-builder.ts\nvar import_babel_utils4 = require(\"@marko/babel-utils\");\nvar import_compiler3 = require(\"@marko/compiler\");\nvar kState = Symbol();\nvar entry_builder_default = {\n  build(entryFile) {\n    const state = entryFile[kState];\n    if (!state) {\n      throw entryFile.path.buildCodeFrameError(\n        \"Unable to build hydrate code, no files were visited before finalizing the build\"\n      );\n    }\n    const body = state.imports.map(\n      (it) => import_compiler3.types.importDeclaration([], import_compiler3.types.stringLiteral(it))\n    );\n    if (state.init) {\n      body.unshift(\n        import_compiler3.types.importDeclaration(\n          [import_compiler3.types.importSpecifier(import_compiler3.types.identifier(\"init\"), import_compiler3.types.identifier(\"init\"))],\n          import_compiler3.types.stringLiteral(\n            `@marko/runtime-tags/${entryFile.markoOpts.optimize ? \"\" : \"debug/\"}dom`\n          )\n        )\n      );\n      body.push(\n        import_compiler3.types.expressionStatement(import_compiler3.types.callExpression(import_compiler3.types.identifier(\"init\"), []))\n      );\n    }\n    return body;\n  },\n  visit(file, entryFile, visitChild) {\n    const state = entryFile[kState] ||= {\n      imports: [],\n      init: false\n    };\n    const { analyzedTags } = file.metadata.marko;\n    state.imports.push(\n      (0, import_babel_utils4.resolveRelativePath)(entryFile, file.opts.filename)\n    );\n    state.init ||= file.path.node.extra.hasInteractiveChild || file.path.node.extra.isInteractive || false;\n    for (const tag of analyzedTags || []) {\n      visitChild(tag);\n    }\n  }\n};\n\n// src/util/references.ts\nvar import_compiler6 = require(\"@marko/compiler\");\n\n// src/util/get-root.ts\nfunction getMarkoRoot(path4) {\n  let curPath = path4;\n  do\n    curPath = curPath.parentPath;\n  while (curPath && !isMarko(curPath));\n  return curPath;\n}\nfunction getExprRoot(path4) {\n  let curPath = path4;\n  while (!isMarko(curPath.parentPath)) {\n    curPath = curPath.parentPath;\n    if (curPath.type === \"AssignmentExpression\") {\n      const destructRoot = getDestructureRoot(curPath);\n      if (isMarko(destructRoot.parentPath)) {\n        curPath = curPath.get(\"right\");\n        break;\n      }\n      curPath = destructRoot.parentPath;\n    }\n  }\n  return curPath;\n}\nfunction getFnRoot(path4) {\n  let curPath = path4;\n  if (curPath.isProgram()) return;\n  while (!isFunctionExpression(curPath)) {\n    if (isMarko(curPath)) return;\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction isMarko(path4) {\n  switch (path4.type) {\n    case \"MarkoTag\":\n    case \"MarkoTagBody\":\n    case \"MarkoAttribute\":\n    case \"MarkoSpreadAttribute\":\n    case \"MarkoPlaceholder\":\n    case \"MarkoScriptlet\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isFunctionExpression(path4) {\n  switch (path4.type) {\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction getDestructureRoot(path4) {\n  switch (path4.parent.type) {\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"ObjectProperty\":\n      return getDestructureRoot(path4.parentPath);\n    default:\n      return path4;\n  }\n}\n\n// src/util/is-stateful.ts\nfunction isStatefulReferences(referencedBindings) {\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        if (isStatefulBinding(ref)) {\n          return true;\n        }\n      }\n    } else {\n      return isStatefulBinding(referencedBindings);\n    }\n  }\n  return false;\n}\nfunction isStatefulBinding(binding) {\n  switch (binding.type) {\n    case 1 /* let */:\n    case 2 /* input */:\n      return true;\n    default:\n      return !binding.upstreamExpression || isStatefulReferences(binding.upstreamExpression.referencedBindings);\n  }\n}\n\n// src/util/optional.ts\nvar Sorted = class {\n  constructor(compare) {\n    this.compare = compare;\n  }\n  add(data, item) {\n    return data ? Array.isArray(data) ? addSorted(this.compare, data, item) : joinRepeatable(this.compare, data, item) : item;\n  }\n  union(a, b) {\n    if (a) {\n      if (Array.isArray(a)) {\n        if (b) {\n          if (Array.isArray(b)) {\n            return unionSortedRepeatable(this.compare, a, b);\n          } else {\n            return addSorted(this.compare, a, b);\n          }\n        }\n        return a;\n      }\n      if (b) {\n        if (Array.isArray(b)) {\n          return addSorted(this.compare, [...b], a);\n        }\n        return joinRepeatable(this.compare, b, a);\n      }\n      return a;\n    }\n    return b;\n  }\n  find(data, item) {\n    if (data) {\n      if (Array.isArray(data)) {\n        return findSorted(this.compare, data, item);\n      } else if (this.compare(data, item) === 0) {\n        return data;\n      }\n    }\n  }\n};\nfunction push(data, item) {\n  if (data) {\n    if (Array.isArray(data)) {\n      data.push(item);\n      return data;\n    }\n    return [data, item];\n  }\n  return item;\n}\nfunction size(data) {\n  return data ? Array.isArray(data) ? data.length : 1 : 0;\n}\nfunction filter(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      const len = data.length;\n      let result;\n      let i = 0;\n      while (i < len) {\n        let item = data[i++];\n        if (cb(item)) {\n          result = item;\n          while (i < len) {\n            item = data[i++];\n            if (cb(item)) {\n              result = [result, item];\n              while (i < len) {\n                item = data[i++];\n                if (cb(item)) {\n                  result.push(item);\n                }\n              }\n              return result;\n            }\n          }\n          return result;\n        }\n      }\n      return result;\n    }\n    if (cb(data)) {\n      return data;\n    }\n  }\n  return void 0;\n}\nfunction forEach(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      let i = 0;\n      for (const item of data) {\n        cb(item, i++);\n      }\n    } else {\n      cb(data, 0);\n    }\n  }\n}\nfunction find(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      return data.find(cb);\n    }\n    if (cb(data, 0)) {\n      return data;\n    }\n  }\n}\nfunction map(data, cb) {\n  return data ? Array.isArray(data) ? data.map(cb) : [cb(data, 0)] : [];\n}\nfunction findSorted(compare, data, item) {\n  let max = data.length;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const cur = data[mid];\n    const compareResult = compare(cur, item);\n    if (compareResult === 0) return cur;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n}\nfunction addSorted(compare, data, item) {\n  const len = data.length;\n  let max = len;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(data[mid], item);\n    if (compareResult === 0) return data;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n  const result = new Array(len + 1);\n  for (let i = 0; i < pos; i++) {\n    result[i] = data[i];\n  }\n  let cur = item;\n  while (pos < len) {\n    const next = cur;\n    cur = data[pos];\n    result[pos++] = next;\n  }\n  result[len] = cur;\n  return result;\n}\nfunction unionSortedRepeatable(compare, a, b) {\n  const aLen = a.length;\n  const bLen = b.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  const result = [];\n  while (aIndex < aLen && bIndex < bLen) {\n    const aValue = a[aIndex];\n    const bValue = b[bIndex];\n    const delta = compare(aValue, bValue);\n    if (delta === 0) {\n      aIndex++;\n      bIndex++;\n      result.push(aValue);\n    } else if (delta < 0) {\n      aIndex++;\n      result.push(aValue);\n    } else {\n      bIndex++;\n      result.push(bValue);\n    }\n  }\n  if (aLen === bLen && aIndex === aLen) {\n    return a;\n  }\n  while (aIndex < aLen) {\n    result.push(a[aIndex++]);\n  }\n  while (bIndex < bLen) {\n    result.push(b[bIndex++]);\n  }\n  return result;\n}\nfunction joinRepeatable(compare, a, b) {\n  const compareResult = compare(a, b);\n  return compareResult === 0 ? a : compareResult < 0 ? [a, b] : [b, a];\n}\n\n// src/util/sections.ts\nvar import_babel_utils6 = require(\"@marko/babel-utils\");\nvar import_compiler5 = require(\"@marko/compiler\");\n\n// src/util/state.ts\nvar createProgramState = (init) => {\n  const map2 = /* @__PURE__ */ new WeakMap();\n  return [\n    () => {\n      let state = map2.get(currentProgramPath);\n      if (!state) {\n        map2.set(currentProgramPath, state = init());\n      }\n      return state;\n    },\n    (value) => {\n      map2.set(currentProgramPath, value);\n    }\n  ];\n};\nfunction createSectionState(key, init) {\n  return [\n    (section) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      const sectionData = arrayOfSectionData[section.id] ??= init && init(section);\n      return sectionData;\n    },\n    (section, value) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      arrayOfSectionData[section.id] = value;\n    }\n  ];\n}\n\n// src/util/tag-name-type.ts\nvar import_babel_utils5 = require(\"@marko/babel-utils\");\nvar import_compiler4 = require(\"@marko/compiler\");\n\n// src/util/with-previous-location.ts\nfunction withPreviousLocation(newNode, originalNode) {\n  newNode.start = originalNode.start;\n  newNode.loc = originalNode.loc;\n  newNode.end = originalNode.end;\n  return newNode;\n}\n\n// src/util/tag-name-type.ts\nvar MARKO_FILE_REG = /^<.*>$|\\.marko$/;\nvar TAG_NAME_IDENTIFIER_REG = /^[A-Z][a-zA-Z0-9_$]*$/;\nfunction analyzeTagNameType(tag) {\n  const extra = tag.node.extra ??= {};\n  if (extra.tagNameType === void 0) {\n    const name = tag.get(\"name\");\n    if (name.isStringLiteral()) {\n      extra.tagNameType = name.node.value[0] === \"@\" ? 3 /* AttributeTag */ : (0, import_babel_utils5.isNativeTag)(tag) ? 0 /* NativeTag */ : 1 /* CustomTag */;\n      if (extra.tagNameType === 1 /* CustomTag */) {\n        const bindingName = name.node.value;\n        const bindingIdentifier = tag.scope.getBinding(bindingName)?.identifier;\n        if (bindingIdentifier && TAG_NAME_IDENTIFIER_REG.test(bindingIdentifier.name)) {\n          const tagIdentifier = withPreviousLocation(\n            import_compiler4.types.identifier(bindingName),\n            name.node\n          );\n          tagIdentifier.extra = {\n            referencedBindings: bindingIdentifier.extra?.binding\n          };\n          analyzeExpressionTagName(name.replaceWith(tagIdentifier)[0], extra);\n        } else {\n          const childFile = (0, import_babel_utils5.loadFileForTag)(tag);\n          const childProgram = childFile?.ast.program;\n          if (childProgram?.extra.featureType === \"class\") {\n            extra.tagNameType = 2 /* DynamicTag */;\n            extra.featureType = \"class\";\n          }\n        }\n      }\n      extra.tagNameNullable = extra.tagNameNullable = false;\n    } else {\n      analyzeExpressionTagName(name, extra);\n    }\n    if (extra.tagNameType === void 0) {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n  }\n  return extra.tagNameType;\n}\nfunction analyzeExpressionTagName(name, extra) {\n  const pending = [name];\n  let path4;\n  let type;\n  let nullable = false;\n  let tagNameImported;\n  while ((path4 = pending.pop()) && type !== 2 /* DynamicTag */) {\n    if (path4.isConditionalExpression()) {\n      pending.push(path4.get(\"consequent\"));\n      if (path4.node.alternate) {\n        pending.push(path4.get(\"alternate\"));\n      }\n    } else if (path4.isLogicalExpression()) {\n      if (path4.node.operator === \"||\") {\n        pending.push(path4.get(\"left\"));\n      } else {\n        nullable = true;\n      }\n      pending.push(path4.get(\"right\"));\n    } else if (path4.isAssignmentExpression()) {\n      pending.push(path4.get(\"right\"));\n    } else if (path4.isBinaryExpression()) {\n      type = path4.node.operator !== \"+\" || type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path4.isStringLiteral() || path4.isTemplateLiteral()) {\n      type = type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path4.isNullLiteral()) {\n      nullable = true;\n    } else if (path4.isIdentifier()) {\n      if (path4.node.name === \"undefined\") {\n        nullable = true;\n        continue;\n      }\n      const binding = path4.scope.getBinding(path4.node.name);\n      if (!binding) {\n        type = 2 /* DynamicTag */;\n        continue;\n      }\n      if (binding.kind === \"module\") {\n        const decl = binding.path.parent;\n        if (MARKO_FILE_REG.test(decl.source.value) && decl.specifiers.some((it) => import_compiler4.types.isImportDefaultSpecifier(it))) {\n          const resolvedImport = (0, import_babel_utils5.resolveTagImport)(name, decl.source.value) || decl.source.value;\n          if (type === 0 /* NativeTag */ || tagNameImported && tagNameImported !== resolvedImport) {\n            type = 2 /* DynamicTag */;\n            tagNameImported = void 0;\n          } else {\n            type = 1 /* CustomTag */;\n            tagNameImported = resolvedImport;\n          }\n        } else {\n          type = 2 /* DynamicTag */;\n        }\n        continue;\n      }\n      const bindingTag = binding.path;\n      if (bindingTag.isMarkoTag() && binding.kind === \"local\") {\n        const bindingTagName = bindingTag.get(\"name\").node.value;\n        if (bindingTagName === \"const\") {\n          pending.push(\n            bindingTag.get(\"attributes\")[0].get(\"value\")\n          );\n          continue;\n        }\n        if (bindingTagName === \"let\") {\n          type = 2 /* DynamicTag */;\n          continue;\n        }\n        continue;\n      }\n      type = 2 /* DynamicTag */;\n    } else {\n      type = 2 /* DynamicTag */;\n    }\n  }\n  extra.tagNameType = type;\n  extra.tagNameNullable = nullable;\n  extra.tagNameDynamic = true;\n  if (type === 1 /* CustomTag */ && tagNameImported) {\n    extra.tagNameImported = tagNameImported;\n  }\n}\n\n// src/util/sections.ts\nfunction startSection(path4) {\n  const extra = path4.node.extra ??= {};\n  let section = extra.section;\n  if (!section && (path4.type === \"Program\" || path4.get(\"body\").length)) {\n    const parentSection = path4.parentPath ? getOrCreateSection(path4.parentPath) : void 0;\n    const sectionNamePath = path4.parentPath?.get(\n      \"name\"\n    );\n    const sectionName = path4.isProgram() ? \"\" : currentProgramPath.scope.generateUid(\n      sectionNamePath.toString() + \"Body\"\n    );\n    const programExtra = path4.hub.file.path.node.extra ??= {};\n    const sections = programExtra.sections ??= [];\n    section = extra.section = {\n      id: sections.length,\n      name: sectionName,\n      depth: parentSection ? parentSection.depth + 1 : 0,\n      parent: parentSection,\n      params: void 0,\n      closures: void 0,\n      bindings: void 0,\n      content: getContentInfo(path4),\n      upstreamExpression: void 0,\n      hasCleanup: false\n    };\n    sections.push(section);\n  }\n  return section;\n}\nfunction getOrCreateSection(path4) {\n  let cur = path4;\n  while (true) {\n    if (cur.type === \"Program\" || cur.type === \"MarkoTagBody\" && analyzeTagNameType(cur.parentPath) !== 0 /* NativeTag */ && cur.parent.name.value !== \"html-comment\") {\n      return startSection(cur);\n    }\n    cur = cur.parentPath;\n  }\n}\nfunction getSectionForBody(body) {\n  return body.node.extra?.section;\n}\nfunction getSection(path4) {\n  let section;\n  let currentPath = path4;\n  while ((section = currentPath.node.extra?.section) === void 0) {\n    currentPath = currentPath.parentPath;\n  }\n  return section;\n}\nvar [getScopeIdIdentifier] = createSectionState(\n  \"scopeIdIdentifier\",\n  (section) => currentProgramPath.scope.generateUidIdentifier(`scope${section.id}_id`)\n);\nvar [getSectionParentIsOwner, setSectionParentIsOwner] = createSectionState(\"parentIsOwner\", () => false);\nvar [_getScopeIdentifier] = createSectionState(\n  \"scopeIdentifier\",\n  () => import_compiler5.types.identifier(\"undefined\")\n);\nvar getScopeIdentifier = (section, ignoreDefault) => {\n  const scopeId = _getScopeIdentifier(section);\n  if (!ignoreDefault && scopeId.name === \"undefined\") {\n    scopeId.name = currentProgramPath.scope.generateUid(`scope${section.id}_`);\n  }\n  return scopeId;\n};\nfunction forEachSection(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  sections?.forEach(fn);\n}\nfunction forEachSectionReverse(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  for (let i = sections.length; i--; ) {\n    fn(sections[i]);\n  }\n}\nfunction getContentInfo(path4) {\n  const body = path4.get(\"body\");\n  const contentInfo = {\n    startType: null,\n    endType: null,\n    singleChild: true\n  };\n  for (let endIndex = body.length; endIndex--; ) {\n    const endType = getNodeContentType(body[endIndex], \"endType\", contentInfo);\n    if (endType !== null) {\n      contentInfo.endType = endType;\n      for (let startIndex = 0; startIndex < endIndex; startIndex++) {\n        const startType = getNodeContentType(body[startIndex], \"startType\");\n        if (startType !== null) {\n          contentInfo.startType = startType;\n          contentInfo.singleChild = false;\n          return contentInfo;\n        }\n      }\n      contentInfo.startType = getNodeContentType(body[endIndex], \"startType\");\n      return contentInfo;\n    }\n  }\n  return null;\n}\nfunction getNodeContentType(path4, extraMember, contentInfo) {\n  if (import_compiler5.types.isMarkoText(path4)) {\n    return 4 /* Text */;\n  }\n  if (import_compiler5.types.isMarkoPlaceholder(path4)) {\n    return 2 /* Placeholder */;\n  }\n  if (import_compiler5.types.isMarkoScriptlet(path4) || import_compiler5.types.isMarkoComment(path4)) {\n    return null;\n  }\n  if (import_compiler5.types.isMarkoTag(path4.node)) {\n    const tag = path4;\n    if ((0, import_babel_utils6.isNativeTag)(tag)) {\n      return 3 /* Tag */;\n    }\n    if ((0, import_babel_utils6.isAttributeTag)(tag)) {\n      return null;\n    }\n    if (import_compiler5.types.isStringLiteral(path4.node.name)) {\n      switch (path4.node.name.value) {\n        case \"html-comment\":\n          return 0 /* Comment */;\n        case \"let\":\n        case \"const\":\n        case \"attrs\":\n        case \"effect\":\n        case \"lifecycle\":\n        case \"return\":\n        case \"id\":\n        case \"define\":\n          return null;\n      }\n      const tagSection = (0, import_babel_utils6.loadFileForTag)(tag)?.ast.program.extra.section;\n      if (tagSection) {\n        if (tagSection.content) {\n          if (contentInfo && !tagSection.content.singleChild) {\n            if (extraMember === \"endType\") {\n              contentInfo.startType = tagSection.content.startType;\n              contentInfo.singleChild = false;\n            }\n          }\n          return tagSection.content[extraMember];\n        } else {\n          return null;\n        }\n      }\n    }\n  }\n  return 1 /* Dynamic */;\n}\nvar isStatefulSection = (section) => {\n  const upstreamExpression = section.upstreamExpression;\n  return !upstreamExpression || isStatefulReferences(upstreamExpression.referencedBindings);\n};\nvar checkStatefulClosures = (section, immediateOnly) => {\n  return !!find(\n    section.closures,\n    (closure) => (!immediateOnly || section.parent === closure.section) && isStatefulReferences(closure)\n  );\n};\n\n// src/util/references.ts\nvar [getBindings] = createProgramState(() => /* @__PURE__ */ new Set());\nvar [getNextBindingId, setNextBindingId] = createProgramState(() => 0);\nfunction createBinding(name, type, section, upstreamAlias, upstreamExpression, property) {\n  const id = getNextBindingId();\n  const binding = {\n    id,\n    name,\n    type,\n    section,\n    property,\n    excludeProperties: void 0,\n    serialize: false,\n    aliases: /* @__PURE__ */ new Set(),\n    propertyAliases: /* @__PURE__ */ new Map(),\n    upstreamAlias,\n    upstreamExpression,\n    downstreamExpressions: /* @__PURE__ */ new Set(),\n    export: void 0\n  };\n  if (property) {\n    const propBinding = upstreamAlias.propertyAliases.get(property);\n    if (propBinding) {\n      binding.property = void 0;\n      binding.upstreamAlias = propBinding;\n      propBinding.aliases.add(binding);\n    } else {\n      upstreamAlias.propertyAliases.set(property, binding);\n    }\n  } else if (upstreamAlias) {\n    upstreamAlias.aliases.add(binding);\n  }\n  setNextBindingId(id + 1);\n  getBindings().add(binding);\n  return binding;\n}\nfunction trackVarReferences(tag, type, upstreamAlias, upstreamExpression, changeBinding) {\n  const tagVar = tag.node.var;\n  if (tagVar) {\n    const section = getOrCreateSection(tag);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    upstreamAlias?.downstreamExpressions.delete(upstreamExpression);\n    createBindingsAndTrackReferences(\n      tagVar,\n      type,\n      tag.scope,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0,\n      changeBinding\n    );\n  }\n}\nfunction trackParamsReferences(body, type, upstreamAlias, upstreamExpression) {\n  const params = body.node.params;\n  if (body.node.body.length && params.length) {\n    upstreamAlias?.downstreamExpressions.delete(upstreamExpression);\n    const section = getOrCreateSection(body);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    const paramsBinding = canonicalUpstreamAlias || ((body.node.extra ??= {}).binding = createBinding(\n      body.scope.generateUid(\"params_\"),\n      type,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0\n    ));\n    section.params = paramsBinding;\n    for (let i = 0; i < params.length; i++) {\n      createBindingsAndTrackReferences(\n        params[i],\n        type,\n        body.scope,\n        section,\n        paramsBinding,\n        void 0,\n        i + \"\"\n      );\n    }\n  }\n}\nfunction trackReferencesForBinding(babelBinding, changeBinding) {\n  const { identifier, referencePaths, constantViolations } = babelBinding;\n  const binding = identifier.extra.binding;\n  for (const referencePath of referencePaths) {\n    trackReference(referencePath, binding);\n  }\n  for (const referencePath of constantViolations) {\n    const node = referencePath.node;\n    if (import_compiler6.types.isAssignmentExpression(node)) {\n      assignBinding(node.left, binding);\n    }\n    if (import_compiler6.types.isUpdateExpression(node)) {\n      assignBinding(node.argument, binding);\n    }\n    if (import_compiler6.types.isAssignmentExpression(node) && import_compiler6.types.isIdentifier(node.left) && node.operator !== \"=\") {\n      trackReference(\n        referencePath.get(\n          \"left\"\n        ),\n        binding\n      );\n    }\n    if (changeBinding) {\n      if (referencePath.isUpdateExpression()) {\n        trackReference(\n          referencePath.get(\"argument\"),\n          changeBinding\n        );\n      } else if (referencePath.isAssignmentExpression()) {\n        trackReference(\n          referencePath.get(\"left\"),\n          changeBinding\n        );\n      }\n    }\n  }\n}\nfunction assignBinding(node, binding) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        assignBinding(prop, binding);\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const element of node.elements) {\n        if (element !== null) {\n          assignBinding(element, binding);\n        }\n      }\n      break;\n    case \"RestElement\":\n      assignBinding(node.argument, binding);\n      break;\n    case \"ObjectProperty\":\n      assignBinding(node.value, binding);\n      break;\n    case \"Identifier\":\n      if (node.name === binding.name) {\n        (node.extra ??= {}).source = binding;\n      }\n      break;\n  }\n}\nfunction createBindingsAndTrackReferences(lVal, type, scope, section, upstreamAlias, upstreamExpression, property, changeBinding) {\n  switch (lVal.type) {\n    case \"Identifier\":\n      (lVal.extra ??= {}).binding = createBinding(\n        lVal.name,\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      );\n      trackReferencesForBinding(scope.getBinding(lVal.name), changeBinding);\n      break;\n    case \"ObjectPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        scope.generateUid(\"pattern_\"),\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      ));\n      for (const prop of lVal.properties) {\n        if (prop.type === \"RestElement\") {\n          createBindingsAndTrackReferences(\n            prop.argument,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            property\n          );\n        } else {\n          let key;\n          if (prop.key.type === \"Identifier\") {\n            key = prop.key.name;\n          } else if (prop.key.type === \"StringLiteral\") {\n            key = prop.key.value;\n          } else {\n            throw new Error(\"computed keys not supported in object pattern\");\n          }\n          createBindingsAndTrackReferences(\n            prop.value,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            key\n          );\n        }\n      }\n      break;\n    }\n    case \"ArrayPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        scope.generateUid(\"pattern_\"),\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      ));\n      let i = -1;\n      for (const element of lVal.elements) {\n        i++;\n        if (element) {\n          if (element.type === \"RestElement\") {\n            createBindingsAndTrackReferences(\n              element.argument,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              property\n            );\n          } else {\n            createBindingsAndTrackReferences(\n              element,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              `${i}`\n            );\n          }\n        }\n      }\n      break;\n    }\n    case \"AssignmentPattern\":\n      createBindingsAndTrackReferences(\n        lVal.left,\n        type,\n        scope,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property\n      );\n      break;\n  }\n}\nfunction trackReference(referencePath, binding) {\n  const fnRoot = getFnRoot(referencePath.scope.path);\n  const exprRoot = getExprRoot(fnRoot || referencePath);\n  const section = getOrCreateSection(exprRoot);\n  const reference = binding;\n  const exprExtra = exprRoot.node.extra ??= {};\n  addReferenceToExpression(exprRoot, binding);\n  assignBinding(referencePath.node, binding);\n  if (fnRoot) {\n    let fnExtra = exprExtra;\n    if (fnRoot !== exprRoot) {\n      fnExtra = fnRoot.node.extra ??= {};\n      fnExtra.referencedBindings = addReference(\n        section,\n        fnExtra.referencedBindings,\n        reference\n      );\n    }\n  }\n}\nvar [getMergedReferences] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction mergeReferences(section, target, nodes) {\n  getMergedReferences().set(target, { section, nodes });\n}\nfunction compareIntersections(a, b) {\n  const len = a.length;\n  const lenDelta = len - b.length;\n  if (lenDelta !== 0) {\n    return lenDelta;\n  }\n  for (let i = 0; i < len; i++) {\n    const compareResult = bindingUtil.compare(a[i], b[i]);\n    if (compareResult !== 0) {\n      return compareResult;\n    }\n  }\n  return 0;\n}\nfunction finalizeReferences() {\n  const droppedReferences = getDroppedReferences();\n  if (droppedReferences.size) {\n    for (const expr of droppedReferences) {\n      const { extra } = expr;\n      if (extra && extra.referencedBindings) {\n        forEach(extra.referencedBindings, ({ downstreamExpressions }) => {\n          downstreamExpressions.delete(extra);\n        });\n        extra.referencedBindings = void 0;\n      }\n    }\n    droppedReferences.clear();\n  }\n  const mergedReferences = getMergedReferences();\n  if (mergedReferences.size) {\n    for (const [target, { section, nodes }] of mergedReferences) {\n      const targetExtra = target.extra ??= {};\n      let { referencedBindings, isEffect } = targetExtra;\n      for (const node of nodes) {\n        const extra = node?.extra;\n        if (extra) {\n          const additionalBindings = extra.referencedBindings;\n          isEffect ||= extra.isEffect;\n          if (additionalBindings) {\n            referencedBindings = bindingUtil.union(\n              referencedBindings,\n              additionalBindings\n            );\n            forEach(additionalBindings, ({ downstreamExpressions }) => {\n              downstreamExpressions.delete(extra);\n              downstreamExpressions.add(targetExtra);\n            });\n          }\n        }\n      }\n      referencedBindings = findReferences(section, referencedBindings);\n      targetExtra.referencedBindings = referencedBindings;\n      targetExtra.isEffect = isEffect;\n    }\n    mergedReferences.clear();\n  }\n  const bindings = getBindings();\n  for (const binding of bindings) {\n    if (binding.type !== 0 /* dom */ && !binding.upstreamAlias) {\n      if (pruneBinding(bindings, binding)) {\n        const { upstreamExpression } = binding;\n        if (upstreamExpression) {\n          forEach(\n            upstreamExpression.referencedBindings,\n            (referencedBinding) => {\n              referencedBinding.downstreamExpressions.delete(\n                upstreamExpression\n              );\n              pruneBinding(bindings, referencedBinding);\n            }\n          );\n        }\n      }\n    }\n  }\n  const intersections = /* @__PURE__ */ new Set();\n  for (const binding of bindings) {\n    const { name, section } = binding;\n    if (binding.type !== 0 /* dom */) {\n      if (find(section.bindings, ({ name: name2 }) => name2 === binding.name)) {\n        binding.name = currentProgramPath.scope.generateUid(name);\n      }\n    }\n    section.bindings = bindingUtil.add(section.bindings, binding);\n    for (const {\n      referencedBindings,\n      isEffect\n    } of binding.downstreamExpressions) {\n      if (Array.isArray(referencedBindings)) {\n        intersections.add(referencedBindings);\n      }\n      forEach(referencedBindings, (bindingReference) => {\n        if (isEffect) {\n          bindingReference.serialize = true;\n        }\n      });\n    }\n  }\n  for (const intersection of intersections) {\n    const numReferences = intersection.length;\n    for (let i = 0; i < numReferences - 1; i++) {\n      for (let j = i + 1; j < numReferences; j++) {\n        const binding1 = intersection[i];\n        const binding2 = intersection[j];\n        const sources1 = getSourceBindings(binding1);\n        const sources2 = getSourceBindings(binding2);\n        if (!binding1.serialize && !isSuperset(sources1, sources2)) {\n          binding1.serialize = true;\n        }\n        if (!binding2.serialize && !isSuperset(sources2, sources1)) {\n          binding2.serialize = true;\n        }\n      }\n    }\n  }\n  forEachSection((section) => {\n    forEach(section.closures, (binding) => {\n      if (!binding.serialize) {\n        let serialize = false;\n        const sourceSection = binding.section;\n        let currentSection = section;\n        while (currentSection !== sourceSection && !(serialize = !currentSection.upstreamExpression || isStatefulReferences(\n          currentSection.upstreamExpression.referencedBindings\n        ))) {\n          currentSection = currentSection.parent;\n        }\n        binding.serialize = serialize;\n      }\n    });\n  });\n  forEachSection(({ id, bindings: bindings2 }) => {\n    forEach(\n      filter(bindings2, ({ section }) => section.id === id),\n      (binding, i) => {\n        binding.id = i;\n      }\n    );\n  });\n}\nfunction isSuperset(set, subset) {\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getSourceBindings(binding) {\n  const derived = /* @__PURE__ */ new Set();\n  const sources = /* @__PURE__ */ new Set();\n  crawl(binding);\n  return sources;\n  function crawl(binding2) {\n    if (binding2.type === 4 /* derived */ || binding2.type === 3 /* param */) {\n      let alias;\n      let curBinding = binding2;\n      while (alias = curBinding.upstreamAlias) {\n        curBinding = alias;\n      }\n      if (curBinding.upstreamExpression) {\n        if (derived.has(curBinding)) return;\n        derived.add(curBinding);\n        forEach(curBinding.upstreamExpression.referencedBindings, crawl);\n      } else {\n        sources.add(curBinding);\n      }\n    } else {\n      sources.add(binding2);\n    }\n  }\n}\nvar bindingUtil = new Sorted(function compareBindings(a, b) {\n  return a.section.id - b.section.id || a.type !== b.type && (a.type === 0 /* dom */ || b.type === 0 /* dom */) ? a.type - b.type || a.id - b.id : a.id - b.id;\n});\nvar [getIntersections, setIntersections] = createSectionState(\n  \"intersections\",\n  () => []\n);\nfunction addReferenceToExpression(path4, binding) {\n  const exprExtra = path4.node.extra ??= {};\n  const section = getOrCreateSection(path4);\n  exprExtra.referencedBindings = addReference(\n    section,\n    exprExtra.referencedBindings,\n    binding\n  );\n  binding.downstreamExpressions.add(exprExtra);\n}\nvar [getDroppedReferences] = createProgramState(() => /* @__PURE__ */ new Set());\nfunction dropReferences(node) {\n  const droppedReferences = getDroppedReferences();\n  if (Array.isArray(node)) {\n    for (const item of node) {\n      droppedReferences.add(item);\n    }\n  } else {\n    droppedReferences.add(node);\n  }\n}\nfunction getCanonicalBinding(binding) {\n  return binding && (binding.property ? binding : binding.upstreamAlias || binding);\n}\nfunction getAllTagReferenceNodes(tag, referenceNodes = []) {\n  if (tag.arguments) {\n    for (const arg of tag.arguments) {\n      referenceNodes.push(arg);\n    }\n  }\n  for (const attr2 of tag.attributes) {\n    referenceNodes.push(attr2.value);\n  }\n  for (const child of tag.attributeTags) {\n    switch (child.type) {\n      case \"MarkoTag\":\n        getAllTagReferenceNodes(child, referenceNodes);\n        break;\n      case \"MarkoScriptlet\":\n        for (const statement of child.body) {\n          referenceNodes.push(statement);\n        }\n        break;\n    }\n  }\n  return referenceNodes;\n}\nfunction addReference(section, referencedBindings, binding) {\n  if (section !== binding.section) {\n    section.closures = bindingUtil.add(section.closures, binding);\n  }\n  const newIntersection = bindingUtil.add(referencedBindings, binding);\n  return findReferences(section, newIntersection);\n}\nfunction findReferences(section, referencedBindings) {\n  if (!referencedBindings || !Array.isArray(referencedBindings)) {\n    return referencedBindings;\n  }\n  const intersections = getIntersections(section);\n  let intersection = findSorted(\n    compareIntersections,\n    intersections,\n    referencedBindings\n  );\n  if (!intersection) {\n    setIntersections(\n      section,\n      addSorted(compareIntersections, intersections, referencedBindings)\n    );\n    intersection = referencedBindings;\n  }\n  return intersection;\n}\nfunction getScopeAccessorLiteral(binding) {\n  if (isOptimize()) {\n    return import_compiler6.types.numericLiteral(binding.id);\n  }\n  return import_compiler6.types.stringLiteral(\n    binding.name + (binding.type === 0 /* dom */ ? `/${binding.id}` : \"\")\n  );\n}\nfunction pruneBinding(bindings, binding) {\n  let shouldPrune = !binding.downstreamExpressions.size;\n  for (const alias of binding.aliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.aliases.delete(alias);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  for (const [key, alias] of binding.propertyAliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.propertyAliases.delete(key);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  if (shouldPrune) {\n    bindings.delete(binding);\n  }\n  return shouldPrune;\n}\n\n// src/visitors/program/dom.ts\nvar import_compiler14 = require(\"@marko/compiler\");\n\n// src/util/runtime.ts\nvar import_babel_utils7 = require(\"@marko/babel-utils\");\nvar import_compiler8 = require(\"@marko/compiler\");\n\n// ../runtime-tags/src/common/attr-tag.ts\nvar rest = false ? Symbol(\"Attribute Tag\") : Symbol();\n\n// ../runtime-tags/src/common/helpers.ts\nfunction classValue(value) {\n  return toDelimitedString(value, \" \", stringifyClassObject);\n}\nfunction stringifyClassObject(name, value) {\n  return value ? name : \"\";\n}\nfunction styleValue(value) {\n  return toDelimitedString(value, \";\", stringifyStyleObject);\n}\nvar NON_DIMENSIONAL = /^(--|ta|or|li|z)|n-c|i(do|nk|m|t)|w$|we/;\nfunction stringifyStyleObject(name, value) {\n  return value || value === 0 ? `${name}:${typeof value === \"number\" && value && !NON_DIMENSIONAL.test(name) ? value + \"px\" : value}` : \"\";\n}\nfunction toDelimitedString(val, delimiter, stringify) {\n  switch (typeof val) {\n    case \"string\":\n      return val;\n    case \"object\":\n      if (val !== null) {\n        let result = \"\";\n        let curDelimiter = \"\";\n        if (Array.isArray(val)) {\n          for (const v of val) {\n            const part = toDelimitedString(v, delimiter, stringify);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        } else {\n          for (const name in val) {\n            const v = val[name];\n            const part = stringify(name, v);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        }\n        return result;\n      }\n  }\n  return \"\";\n}\nfunction isVoid(value) {\n  return value == null || value === false;\n}\n\n// ../runtime-tags/src/html/content.ts\nfunction toString(val) {\n  return val ? val + \"\" : val === 0 ? \"0\" : \"\";\n}\nvar unsafeXMLReg = /[<&]/g;\nvar replaceUnsafeXML = (c) => c === \"&\" ? \"&amp;\" : \"&lt;\";\nvar escapeXMLStr = (str) => unsafeXMLReg.test(str) ? str.replace(unsafeXMLReg, replaceUnsafeXML) : str;\nfunction escapeXML(val) {\n  return val ? escapeXMLStr(val + \"\") : val === 0 ? \"0\" : \"&zwj;\";\n}\nvar unsafeScriptReg = /<\\/script/g;\nvar escapeScriptStr = (str) => unsafeScriptReg.test(str) ? str.replace(unsafeScriptReg, \"\\\\x3C/script\") : str;\nfunction escapeScript(val) {\n  return val ? escapeScriptStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\nvar unsafeStyleReg = /<\\/style/g;\nvar escapeStyleStr = (str) => unsafeStyleReg.test(str) ? str.replace(unsafeStyleReg, \"\\\\3C/style\") : str;\nfunction escapeStyle(val) {\n  return val ? escapeStyleStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\n\n// ../runtime-tags/src/html/serializer.ts\nvar { hasOwnProperty } = {};\nvar Generator = function* () {\n}().constructor;\nvar AsyncGenerator = async function* () {\n}().constructor;\nvar KNOWN_SYMBOLS = (() => {\n  const KNOWN_SYMBOLS2 = /* @__PURE__ */ new Map();\n  for (const name of Object.getOwnPropertyNames(Symbol)) {\n    const symbol = Symbol[name];\n    if (typeof symbol === \"symbol\") {\n      KNOWN_SYMBOLS2.set(symbol, \"Symbol.\" + name);\n    }\n  }\n  return KNOWN_SYMBOLS2;\n})();\nvar KNOWN_FUNCTIONS = /* @__PURE__ */ new Map([\n  // This is by no means an exhaustive list,\n  // but it should cover most of the built-in functions.\n  [AggregateError, \"AggregateError\"],\n  [Array, \"Array\"],\n  [Array.from, \"Array.from\"],\n  [Array.isArray, \"Array.isArray\"],\n  [Array.of, \"Array.of\"],\n  [ArrayBuffer, \"ArrayBuffer\"],\n  [ArrayBuffer.isView, \"ArrayBuffer.isView\"],\n  [Atomics.add, \"Atomics.add\"],\n  [Atomics.and, \"Atomics.and\"],\n  [Atomics.compareExchange, \"Atomics.compareExchange\"],\n  [Atomics.exchange, \"Atomics.exchange\"],\n  [Atomics.isLockFree, \"Atomics.isLockFree\"],\n  [Atomics.load, \"Atomics.load\"],\n  [Atomics.notify, \"Atomics.notify\"],\n  [Atomics.or, \"Atomics.or\"],\n  [Atomics.store, \"Atomics.store\"],\n  [Atomics.sub, \"Atomics.sub\"],\n  [Atomics.wait, \"Atomics.wait\"],\n  [BigInt, \"BigInt\"],\n  [BigInt.asIntN, \"BigInt.asIntN\"],\n  [BigInt.asUintN, \"BigInt.asUintN\"],\n  [BigInt64Array, \"BigInt64Array\"],\n  [BigInt64Array.from, \"BigInt64Array.from\"],\n  [BigInt64Array.of, \"BigInt64Array.of\"],\n  [BigUint64Array, \"BigUint64Array\"],\n  [BigUint64Array.from, \"BigUint64Array.from\"],\n  [BigUint64Array.of, \"BigUint64Array.of\"],\n  [Boolean, \"Boolean\"],\n  [console.assert, \"console.assert\"],\n  [console.clear, \"console.clear\"],\n  [console.count, \"console.count\"],\n  [console.countReset, \"console.countReset\"],\n  [console.debug, \"console.debug\"],\n  [console.dir, \"console.dir\"],\n  [console.dirxml, \"console.dirxml\"],\n  [console.error, \"console.error\"],\n  [console.group, \"console.group\"],\n  [console.groupCollapsed, \"console.groupCollapsed\"],\n  [console.groupEnd, \"console.groupEnd\"],\n  [console.info, \"console.info\"],\n  [console.log, \"console.log\"],\n  [console.table, \"console.table\"],\n  [console.time, \"console.time\"],\n  [console.timeEnd, \"console.timeEnd\"],\n  [console.timeLog, \"console.timeLog\"],\n  [console.timeStamp, \"console.timeStamp\"],\n  [console.trace, \"console.trace\"],\n  [console.warn, \"console.warn\"],\n  [DataView, \"DataView\"],\n  [Date, \"Date\"],\n  [Date.now, \"Date.now\"],\n  [Date.parse, \"Date.parse\"],\n  [Date.UTC, \"Date.UTC\"],\n  [decodeURI, \"decodeURI\"],\n  [decodeURIComponent, \"decodeURIComponent\"],\n  [encodeURI, \"encodeURI\"],\n  [encodeURIComponent, \"encodeURIComponent\"],\n  [Error, \"Error\"],\n  [EvalError, \"EvalError\"],\n  [Float32Array, \"Float32Array\"],\n  [Float32Array.from, \"Float32Array.from\"],\n  [Float32Array.of, \"Float32Array.of\"],\n  [Float64Array, \"Float64Array\"],\n  [Float64Array.from, \"Float64Array.from\"],\n  [Float64Array.of, \"Float64Array.of\"],\n  [Function, \"Function\"],\n  [globalThis.atob, \"atob\"],\n  [globalThis.btoa, \"btoa\"],\n  [globalThis.clearImmediate, \"clearImmediate\"],\n  [globalThis.clearInterval, \"clearInterval\"],\n  [globalThis.clearTimeout, \"clearTimeout\"],\n  [globalThis.crypto?.getRandomValues, \"crypto.getRandomValues\"],\n  [globalThis.crypto?.randomUUID, \"crypto.randomUUID\"],\n  [globalThis.fetch, \"fetch\"],\n  [globalThis.performance?.now, \"performance.now\"],\n  [globalThis.queueMicrotask, \"queueMicrotask\"],\n  [globalThis.setImmediate, \"setImmediate\"],\n  [globalThis.setInterval, \"setInterval\"],\n  [globalThis.setTimeout, \"setTimeout\"],\n  [globalThis.structuredClone, \"structuredClone\"],\n  [globalThis.URL, \"URL\"],\n  [globalThis.URLSearchParams, \"URLSearchParams\"],\n  [globalThis.WritableStream, \"WritableStream\"],\n  [Int16Array, \"Int16Array\"],\n  [Int16Array.from, \"Int16Array.from\"],\n  [Int16Array.of, \"Int16Array.of\"],\n  [Int32Array, \"Int32Array\"],\n  [Int32Array.from, \"Int32Array.from\"],\n  [Int32Array.of, \"Int32Array.of\"],\n  [Int8Array, \"Int8Array\"],\n  [Int8Array.from, \"Int8Array.from\"],\n  [Int8Array.of, \"Int8Array.of\"],\n  [Intl.Collator, \"Intl.Collator\"],\n  [Intl.DateTimeFormat, \"Intl.DateTimeFormat\"],\n  [Intl.DisplayNames, \"Intl.DisplayNames\"],\n  [Intl.getCanonicalLocales, \"Intl.getCanonicalLocales\"],\n  [Intl.ListFormat, \"Intl.ListFormat\"],\n  [Intl.Locale, \"Intl.Locale\"],\n  [Intl.NumberFormat, \"Intl.NumberFormat\"],\n  [Intl.PluralRules, \"Intl.PluralRules\"],\n  [Intl.RelativeTimeFormat, \"Intl.RelativeTimeFormat\"],\n  [Intl.Segmenter, \"Intl.Segmenter\"],\n  [Intl.supportedValuesOf, \"Intl.supportedValuesOf\"],\n  [isFinite, \"isFinite\"],\n  [isNaN, \"isNaN\"],\n  [JSON.parse, \"JSON.parse\"],\n  [JSON.stringify, \"JSON.stringify\"],\n  [Map, \"Map\"],\n  [Map.groupBy, \"Map.groupBy\"],\n  [Math.abs, \"Math.abs\"],\n  [Math.acos, \"Math.acos\"],\n  [Math.acosh, \"Math.acosh\"],\n  [Math.asin, \"Math.asin\"],\n  [Math.asinh, \"Math.asinh\"],\n  [Math.atan, \"Math.atan\"],\n  [Math.atan2, \"Math.atan2\"],\n  [Math.atanh, \"Math.atanh\"],\n  [Math.cbrt, \"Math.cbrt\"],\n  [Math.ceil, \"Math.ceil\"],\n  [Math.clz32, \"Math.clz32\"],\n  [Math.cos, \"Math.cos\"],\n  [Math.cosh, \"Math.cosh\"],\n  [Math.exp, \"Math.exp\"],\n  [Math.expm1, \"Math.expm1\"],\n  [Math.floor, \"Math.floor\"],\n  [Math.fround, \"Math.fround\"],\n  [Math.hypot, \"Math.hypot\"],\n  [Math.imul, \"Math.imul\"],\n  [Math.log, \"Math.log\"],\n  [Math.log10, \"Math.log10\"],\n  [Math.log1p, \"Math.log1p\"],\n  [Math.log2, \"Math.log2\"],\n  [Math.max, \"Math.max\"],\n  [Math.min, \"Math.min\"],\n  [Math.pow, \"Math.pow\"],\n  [Math.random, \"Math.random\"],\n  [Math.round, \"Math.round\"],\n  [Math.sign, \"Math.sign\"],\n  [Math.sin, \"Math.sin\"],\n  [Math.sinh, \"Math.sinh\"],\n  [Math.sqrt, \"Math.sqrt\"],\n  [Math.tan, \"Math.tan\"],\n  [Math.tanh, \"Math.tanh\"],\n  [Math.trunc, \"Math.trunc\"],\n  [Number, \"Number\"],\n  [Number.isFinite, \"Number.isFinite\"],\n  [Number.isInteger, \"Number.isInteger\"],\n  [Number.isNaN, \"Number.isNaN\"],\n  [Number.isSafeInteger, \"Number.isSafeInteger\"],\n  [Number.parseFloat, \"Number.parseFloat\"],\n  [Number.parseInt, \"Number.parseInt\"],\n  [Object, \"Object\"],\n  [Object.assign, \"Object.assign\"],\n  [Object.create, \"Object.create\"],\n  [Object.defineProperties, \"Object.defineProperties\"],\n  [Object.defineProperty, \"Object.defineProperty\"],\n  [Object.entries, \"Object.entries\"],\n  [Object.freeze, \"Object.freeze\"],\n  [Object.fromEntries, \"Object.fromEntries\"],\n  [Object.getOwnPropertyDescriptor, \"Object.getOwnPropertyDescriptor\"],\n  [Object.getOwnPropertyDescriptors, \"Object.getOwnPropertyDescriptors\"],\n  [Object.getOwnPropertyNames, \"Object.getOwnPropertyNames\"],\n  [Object.getOwnPropertySymbols, \"Object.getOwnPropertySymbols\"],\n  [Object.getPrototypeOf, \"Object.getPrototypeOf\"],\n  [Object.is, \"Object.is\"],\n  [Object.isExtensible, \"Object.isExtensible\"],\n  [Object.isFrozen, \"Object.isFrozen\"],\n  [Object.isSealed, \"Object.isSealed\"],\n  [Object.keys, \"Object.keys\"],\n  [Object.preventExtensions, \"Object.preventExtensions\"],\n  [Object.seal, \"Object.seal\"],\n  [Object.setPrototypeOf, \"Object.setPrototypeOf\"],\n  [Object.values, \"Object.values\"],\n  [parseFloat, \"parseFloat\"],\n  [parseInt, \"parseInt\"],\n  [Promise, \"Promise\"],\n  [Proxy, \"Proxy\"],\n  [RangeError, \"RangeError\"],\n  [ReferenceError, \"ReferenceError\"],\n  [Reflect.apply, \"Reflect.apply\"],\n  [Reflect.construct, \"Reflect.construct\"],\n  [Reflect.defineProperty, \"Reflect.defineProperty\"],\n  [Reflect.deleteProperty, \"Reflect.deleteProperty\"],\n  [Reflect.get, \"Reflect.get\"],\n  [Reflect.getOwnPropertyDescriptor, \"Reflect.getOwnPropertyDescriptor\"],\n  [Reflect.getPrototypeOf, \"Reflect.getPrototypeOf\"],\n  [Reflect.has, \"Reflect.has\"],\n  [Reflect.isExtensible, \"Reflect.isExtensible\"],\n  [Reflect.ownKeys, \"Reflect.ownKeys\"],\n  [Reflect.preventExtensions, \"Reflect.preventExtensions\"],\n  [Reflect.set, \"Reflect.set\"],\n  [Reflect.setPrototypeOf, \"Reflect.setPrototypeOf\"],\n  [RegExp, \"RegExp\"],\n  [Set, \"Set\"],\n  [String, \"String\"],\n  [String.fromCharCode, \"String.fromCharCode\"],\n  [String.fromCodePoint, \"String.fromCodePoint\"],\n  [String.raw, \"String.raw\"],\n  [Symbol, \"Symbol\"],\n  [Symbol.for, \"Symbol.for\"],\n  [SyntaxError, \"SyntaxError\"],\n  [TypeError, \"TypeError\"],\n  [Uint16Array, \"Uint16Array\"],\n  [Uint16Array.from, \"Uint16Array.from\"],\n  [Uint16Array.of, \"Uint16Array.of\"],\n  [Uint32Array, \"Uint32Array\"],\n  [Uint32Array.from, \"Uint32Array.from\"],\n  [Uint32Array.of, \"Uint32Array.of\"],\n  [Uint8Array, \"Uint8Array\"],\n  [Uint8Array.from, \"Uint8Array.from\"],\n  [Uint8Array.of, \"Uint8Array.of\"],\n  [Uint8ClampedArray, \"Uint8ClampedArray\"],\n  [Uint8ClampedArray.from, \"Uint8ClampedArray.from\"],\n  [Uint8ClampedArray.of, \"Uint8ClampedArray.of\"],\n  [URIError, \"URIError\"],\n  [WeakMap, \"WeakMap\"],\n  [WeakSet, \"WeakSet\"]\n]);\nvar KNOWN_OBJECTS = /* @__PURE__ */ new Map([\n  [Atomics, \"Atomics\"],\n  [console, \"console\"],\n  [globalThis, \"globalThis\"],\n  [globalThis.crypto, \"crypto\"],\n  [Intl, \"Intl\"],\n  [JSON, \"JSON\"],\n  [Math, \"Math\"],\n  [Reflect, \"Reflect\"]\n]);\n\n// ../runtime-tags/src/html/writer.ts\nvar K_SCOPE_ID = Symbol(\"Scope ID\");\nvar kPendingContexts = Symbol(\"Pending Contexts\");\nvar tick = globalThis.setImmediate || globalThis.setTimeout || globalThis.queueMicrotask || ((cb) => Promise.resolve().then(cb));\n\n// ../runtime-tags/src/html/attrs.ts\nfunction classAttr(val) {\n  return stringAttr(\"class\", classValue(val));\n}\nfunction styleAttr(val) {\n  return stringAttr(\"style\", styleValue(val));\n}\nvar kSelectedValue = Symbol(\"selectedValue\");\nfunction attr(name, val) {\n  return isVoid(val) ? \"\" : nonVoidAttr(name, val);\n}\nfunction stringAttr(name, val) {\n  return val && ` ${name}=${escapeAttrValue(val)}`;\n}\nfunction nonVoidAttr(name, val) {\n  switch (typeof val) {\n    case \"string\":\n      return ` ${name + attrAssignment(val)}`;\n    case \"boolean\":\n      return ` ${name}`;\n    case \"number\":\n      return ` ${name}=${val}`;\n    case \"object\":\n      if (val instanceof RegExp) {\n        return ` ${name + attrAssignment(val.source)}`;\n      }\n      break;\n  }\n  return ` ${name + attrAssignment(val + \"\")}`;\n}\nfunction attrAssignment(val) {\n  return val ? `=${escapeAttrValue(val)}` : \"\";\n}\nvar unsafeAttrChars = /[\"'>\\s]/g;\nfunction escapeAttrValue(str) {\n  if (unsafeAttrChars.test(str)) {\n    const c = str[unsafeAttrChars.lastIndex - 1];\n    unsafeAttrChars.lastIndex = 0;\n    return c === '\"' ? `'${str.replace(/'/g, \"&#39;\")}'` : `\"${str.replace(/\"/g, \"&#34;\")}\"`;\n  }\n  return str;\n}\n\n// ../runtime-tags/src/common/compat-meta.ts\nvar prefix = false ? \"$compat_\" : \"$C_\";\nvar RENDERER_REGISTER_ID = prefix + (false ? \"renderer\" : \"r\");\nvar SET_SCOPE_REGISTER_ID = prefix + (false ? \"setScope\" : \"s\");\n\n// ../runtime-tags/src/html/compat.ts\nvar K_TAGS_API_STATE = Symbol();\n\n// src/util/scope-read.ts\nvar import_compiler7 = require(\"@marko/compiler\");\nfunction createScopeReadPattern(section, referencedBindings) {\n  const rootDepth = section.depth;\n  const rootPattern = import_compiler7.types.objectPattern([]);\n  let nestedPatterns;\n  forEach(referencedBindings, (ref) => {\n    if (ref.name.includes(\"#\")) return;\n    const propertyKey = getScopeAccessorLiteral(ref);\n    const propertyValue = import_compiler7.types.identifier(ref.name);\n    const isShorthand = propertyKey.value === propertyValue.name;\n    let pattern = rootPattern;\n    if (ref.section !== section) {\n      if (!nestedPatterns) nestedPatterns = [rootPattern];\n      const relativeDepth = rootDepth - ref.section.depth;\n      let i = nestedPatterns.length;\n      let prev = nestedPatterns[i - 1];\n      for (; i <= relativeDepth; i++) {\n        const nestedPattern = import_compiler7.types.objectPattern([]);\n        prev.properties.push(\n          import_compiler7.types.objectProperty(import_compiler7.types.identifier(\"_\"), nestedPattern)\n        );\n        nestedPatterns.push(nestedPattern);\n        prev = nestedPattern;\n      }\n      pattern = nestedPatterns[relativeDepth];\n    }\n    pattern.properties.push(\n      import_compiler7.types.objectProperty(\n        isShorthand ? propertyValue : propertyKey,\n        propertyValue,\n        false,\n        isShorthand\n      )\n    );\n  });\n  return rootPattern;\n}\nfunction getScopeExpression(section, targetSection) {\n  let scope = scopeIdentifier ?? import_compiler7.types.identifier(\"undefined\");\n  const diff = section.depth - targetSection.depth;\n  for (let i = 0; i < diff; i++) {\n    scope = import_compiler7.types.memberExpression(scope, import_compiler7.types.identifier(\"_\"));\n  }\n  if (diff < 0) {\n    throw new Error(\"Unable to find scope for reference.\");\n  }\n  return scope;\n}\nfunction createScopeReadExpression(section, reference) {\n  return import_compiler7.types.memberExpression(\n    getScopeExpression(section, reference.section),\n    getScopeAccessorLiteral(reference),\n    true\n  );\n}\n\n// src/util/runtime.ts\nvar pureFunctions = [\n  \"createTemplate\",\n  \"createRenderer\",\n  \"createRendererWithOwner\",\n  \"value\",\n  \"intersection\",\n  \"closure\",\n  \"dynamicClosure\",\n  \"loopOf\",\n  \"loopIn\",\n  \"loopTo\",\n  \"conditional\"\n];\nfunction importRuntime(name) {\n  const { output } = getMarkoOpts();\n  return (0, import_babel_utils7.importNamed)(currentProgramPath.hub.file, getRuntimePath(output), name);\n}\nfunction callRuntime(name, ...args) {\n  const callExpression2 = import_compiler8.types.callExpression(\n    importRuntime(name),\n    filterArguments(args)\n  );\n  if (pureFunctions.includes(\n    name\n  )) {\n    callExpression2.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: ` @__PURE__ `\n      }\n    ];\n  }\n  return callExpression2;\n}\nfunction getHTMLRuntime() {\n  return {\n    escapeXML,\n    toString,\n    attr,\n    classAttr,\n    styleAttr,\n    escapeScript,\n    escapeStyle\n  };\n}\nfunction getRuntimePath(output) {\n  const { optimize } = getMarkoOpts();\n  return `@marko/runtime-tags/${optimize ? \"\" : \"debug/\"}${output === \"html\" ? \"html\" : \"dom\"}`;\n}\nfunction filterArguments(args) {\n  const filteredArgs = [];\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (arg || filteredArgs.length) {\n      filteredArgs[i] = arg || import_compiler8.types.unaryExpression(\"void\", import_compiler8.types.numericLiteral(0));\n    }\n  }\n  return filteredArgs;\n}\n\n// src/util/signals.ts\nvar import_babel_utils9 = require(\"@marko/babel-utils\");\nvar import_compiler13 = require(\"@marko/compiler\");\n\n// src/core/return.ts\nvar import_babel_utils8 = require(\"@marko/babel-utils\");\nvar import_compiler12 = require(\"@marko/compiler\");\n\n// src/util/writer.ts\nvar import_compiler11 = require(\"@marko/compiler\");\n\n// src/util/to-template-string-or-literal.ts\nvar import_compiler9 = require(\"@marko/compiler\");\nfunction toTemplateOrStringLiteral(parts) {\n  const strs = [];\n  const exprs = [];\n  let curStr = parts[0];\n  for (let i = 1; i < parts.length; i++) {\n    let content = parts[i];\n    if (typeof content === \"object\") {\n      if (import_compiler9.types.isStringLiteral(content)) {\n        content = content.value;\n      } else if (import_compiler9.types.isTemplateLiteral(content)) {\n        let nextIndex = i + 1;\n        const exprLen = content.expressions.length;\n        shiftItems(parts, nextIndex, content.quasis.length + exprLen);\n        for (let j = 0; j < exprLen; j++) {\n          parts[nextIndex++] = content.quasis[j].value.raw;\n          parts[nextIndex++] = content.expressions[j];\n        }\n        parts[nextIndex] = content.quasis[exprLen].value.raw;\n        continue;\n      } else {\n        exprs.push(content);\n        strs.push(curStr);\n        curStr = \"\";\n        continue;\n      }\n    }\n    curStr += content;\n  }\n  if (exprs.length) {\n    strs.push(curStr);\n    return import_compiler9.types.templateLiteral(\n      strs.map((raw) => import_compiler9.types.templateElement({ raw })),\n      exprs\n    );\n  } else if (curStr) {\n    return import_compiler9.types.stringLiteral(curStr);\n  }\n}\nfunction appendLiteral(arr, str) {\n  arr[arr.length - 1] += str;\n}\nfunction shiftItems(list, start, offset) {\n  for (let i = list.length - 1; i >= start; i--) {\n    list[i + offset] = list[i];\n  }\n}\n\n// src/util/walks.ts\nvar import_compiler10 = require(\"@marko/compiler\");\nvar [getWalks] = createSectionState(\n  \"walks\",\n  () => [\"\"]\n);\nvar [getWalkComment] = createSectionState(\n  \"walkComment\",\n  () => []\n);\nvar [getSteps] = createSectionState(\"steps\", () => []);\nvar walkCodeToName = {\n  [32 /* Get */]: \"get\",\n  [36 /* Inside */]: \"inside\",\n  [37 /* Replace */]: \"replace\",\n  [38 /* EndChild */]: \"endChild\",\n  [47 /* BeginChild */]: \"beginChild\",\n  [67 /* Next */]: \"next\",\n  [97 /* Over */]: \"over\",\n  [107 /* Out */]: \"out\",\n  [117 /* Multiplier */]: \"multiplier\",\n  [91 /* NextEnd */]: \"nextEnd\",\n  [106 /* OverEnd */]: \"overEnd\",\n  [116 /* OutEnd */]: \"outEnd\",\n  [126 /* MultiplierEnd */]: \"multiplierEnd\"\n};\nfunction enter(path4) {\n  getSteps(getSection(path4)).push(0 /* Enter */);\n}\nfunction exit(path4) {\n  getSteps(getSection(path4)).push(1 /* Exit */);\n}\nfunction enterShallow(path4) {\n  getSteps(getSection(path4)).push(0 /* Enter */, 1 /* Exit */);\n}\nfunction injectWalks(path4, expr) {\n  const walks = getWalks(getSection(path4));\n  const walkComment = getWalkComment(getSection(path4));\n  walkComment.push(\n    `${walkCodeToName[47 /* BeginChild */]}`,\n    expr.name,\n    walkCodeToName[38 /* EndChild */]\n  );\n  appendLiteral(walks, String.fromCharCode(47 /* BeginChild */));\n  walks.push(expr, String.fromCharCode(38 /* EndChild */));\n}\nfunction visit(path4, code) {\n  if (isOutputHTML()) {\n    return;\n  }\n  const section = getSection(path4);\n  const steps = getSteps(section);\n  const walks = getWalks(section);\n  const walkComment = getWalkComment(section);\n  let walkString = \"\";\n  if (steps.length) {\n    const walkCodes = [];\n    let depth = 0;\n    for (const step of steps) {\n      if (step === 0 /* Enter */) {\n        depth++;\n        walkCodes.push(67 /* Next */);\n      } else {\n        depth--;\n        if (depth >= 0) {\n          walkCodes.length = walkCodes.lastIndexOf(67 /* Next */);\n          walkCodes.push(97 /* Over */);\n        } else {\n          walkCodes.length = walkCodes.lastIndexOf(107 /* Out */) + 1;\n          walkCodes.push(107 /* Out */);\n          depth = 0;\n        }\n      }\n    }\n    let current = walkCodes[0];\n    let count = 0;\n    for (const walk of walkCodes) {\n      if (walk !== current) {\n        walkComment.push(`${walkCodeToName[current]}(${count})`);\n        walkString += nCodeString(current, count);\n        current = walk;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n    walkComment.push(`${walkCodeToName[current]}(${count})`);\n    walkString += nCodeString(current, count);\n    steps.length = 0;\n  }\n  if (code !== void 0) {\n    if (code !== 32 /* Get */) {\n      writeTo(path4)`<!>`;\n    }\n    walkComment.push(`${walkCodeToName[code]}`);\n    walkString += String.fromCharCode(code);\n  }\n  appendLiteral(walks, walkString);\n}\nfunction nCodeString(code, number) {\n  switch (code) {\n    case 67 /* Next */:\n      return toCharString(number, code, 20 /* Next */);\n    case 97 /* Over */:\n      return toCharString(number, code, 10 /* Over */);\n    case 107 /* Out */:\n      return toCharString(number, code, 10 /* Out */);\n    default:\n      throw new Error(`Unexpected walk code: ${code}`);\n  }\n}\nfunction toCharString(number, startCode, rangeSize) {\n  let result = \"\";\n  if (number >= rangeSize) {\n    const multiplier = Math.floor(number / rangeSize);\n    result += toCharString(\n      multiplier,\n      117 /* Multiplier */,\n      10 /* Multiplier */\n    );\n    number -= multiplier * rangeSize;\n  }\n  result += String.fromCharCode(startCode + number);\n  return result;\n}\nfunction getWalkString(section) {\n  const prefix2 = section.content?.startType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const postfix = section.content?.endType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const walks = getWalks(section);\n  const walkLiteral = toTemplateOrStringLiteral([prefix2, ...walks, postfix]) || import_compiler10.types.stringLiteral(\"\");\n  if (walkLiteral.value !== \"\") {\n    walkLiteral.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: \" \" + getWalkComment(section).join(\", \") + \" \"\n      }\n    ];\n  }\n  return walkLiteral;\n}\n\n// src/util/writer.ts\nvar [getWrites] = createSectionState(\n  \"writes\",\n  () => [\"\"]\n);\nfunction writeTo(path4) {\n  const section = getSection(path4);\n  return (strs, ...exprs) => {\n    const exprsLen = exprs.length;\n    const writes = getWrites(section);\n    appendLiteral(writes, strs[0]);\n    for (let i = 0; i < exprsLen; i++) {\n      writes.push(exprs[i], strs[i + 1]);\n    }\n  };\n}\nfunction consumeHTML(path4) {\n  const writes = getWrites(getSection(path4));\n  const result = toTemplateOrStringLiteral(writes);\n  writes.length = 0;\n  writes[0] = \"\";\n  if (result) {\n    return import_compiler11.types.expressionStatement(callRuntime(\"write\", result));\n  }\n}\nfunction flushBefore(path4) {\n  const expr = consumeHTML(path4);\n  if (expr) {\n    path4.insertBefore(expr)[0].skip();\n  }\n}\nfunction flushInto(path4) {\n  const target = path4.isProgram() ? path4 : path4.get(\"body\");\n  const expr = consumeHTML(target);\n  if (expr) {\n    target.pushContainer(\"body\", expr)[0].skip();\n  }\n}\nfunction getSectionMeta(section) {\n  const writePrefix = section.content?.startType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writePostfix = section.content?.endType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writes = getWrites(section);\n  return {\n    setup: getSetup(section),\n    walks: getWalkString(section),\n    writes: toTemplateOrStringLiteral([writePrefix, ...writes, writePostfix]) || import_compiler11.types.stringLiteral(\"\")\n  };\n}\nfunction markNode(path4, binding) {\n  const section = getSection(path4);\n  if (binding.type !== 0 /* dom */) {\n    throw path4.buildCodeFrameError(\n      \"Tried to mark a node that was not determined to need a mark during analyze.\"\n    );\n  }\n  if (isOutputHTML()) {\n    writeTo(path4)`${callRuntime(\n      \"markResumeNode\",\n      getScopeIdIdentifier(section),\n      getScopeAccessorLiteral(binding)\n    )}`;\n  }\n}\n\n// src/core/return.ts\nvar [returnId, _setReturnId] = createSectionState(\n  \"returnId\"\n);\nvar usedTag = /* @__PURE__ */ new WeakSet();\nvar return_default = {\n  analyze(tag) {\n    (0, import_babel_utils8.assertNoArgs)(tag);\n    (0, import_babel_utils8.assertNoVar)(tag);\n    (0, import_babel_utils8.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    if (usedTag.has(tag.hub)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `return` tag can only be used once per template.\"\n      );\n    }\n    usedTag.add(tag.hub);\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    if (!import_compiler12.types.isMarkoAttribute(valueAttr) || !valueAttr.default) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `return` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 && node.attributes[1].name !== \"valueChange\") {\n      const start = node.attributes[1].loc?.start;\n      const end = node.attributes[node.attributes.length - 1].loc?.end;\n      const msg = \"The `return` tag only supports the `value` attribute.\";\n      if (start == null || end == null) {\n        throw tag.get(\"name\").buildCodeFrameError(msg);\n      } else {\n        throw tag.hub.buildError(\n          { loc: { start, end } },\n          msg,\n          Error\n        );\n      }\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const {\n        node: {\n          attributes: [{ value }]\n        },\n        hub: { file }\n      } = tag;\n      if (isOutputHTML()) {\n        flushBefore(tag);\n        const returnId2 = file.path.scope.generateUidIdentifier(\"return\");\n        _setReturnId(section, returnId2);\n        tag.replaceWith(\n          import_compiler12.types.variableDeclaration(\"const\", [\n            import_compiler12.types.variableDeclarator(returnId2, value)\n          ])\n        )[0].skip();\n      } else {\n        addValue(\n          section,\n          value.extra?.referencedBindings,\n          {\n            identifier: importRuntime(\"tagVarSignal\"),\n            hasDownstreamIntersections: () => true\n          },\n          value\n        );\n        tag.remove();\n      }\n    }\n  },\n  autocomplete: [\n    {\n      displayText: \"return=<value>\",\n      description: \"Provides a value for use in a parent template.\",\n      snippet: \"return=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#return\"\n    }\n  ]\n};\n\n// src/util/signals.ts\nvar [getSignals] = createSectionState(\n  \"signals\",\n  () => /* @__PURE__ */ new Map()\n);\nvar [getSubscribeBuilder, _setSubscribeBuilder] = createSectionState(\"queue\");\nfunction setSubscriberBuilder(tag, builder) {\n  _setSubscribeBuilder(getSectionForBody(tag.get(\"body\")), builder);\n}\nvar [forceResumeScope, _setForceResumeScope] = createSectionState(\"forceResumeScope\");\nfunction setForceResumeScope(section) {\n  _setForceResumeScope(section, true);\n}\nvar [getSerializedScopeProperties] = createSectionState(\"serializedScopeProperties\", () => /* @__PURE__ */ new Map());\nvar unimplementedBuild = () => {\n  return import_compiler13.types.stringLiteral(\"SIGNAL NOT INITIALIZED\");\n};\nfunction getSignal(section, referencedBindings, name = generateSignalName(referencedBindings)) {\n  const signals = getSignals(section);\n  let signal = signals.get(referencedBindings);\n  if (!signal) {\n    const exportName = referencedBindings ? !Array.isArray(referencedBindings) && referencedBindings.section === section && referencedBindings.export : !section.parent && currentProgramPath.node.extra.domExports?.setup;\n    signals.set(\n      referencedBindings,\n      signal = {\n        identifier: exportName ? import_compiler13.types.identifier(exportName) : currentProgramPath.scope.generateUidIdentifier(\n          name + section.name.replace(\"_\", \"$\")\n        ),\n        referencedBindings,\n        section,\n        values: [],\n        intersection: void 0,\n        render: [],\n        effect: [],\n        effectInlineReferences: void 0,\n        subscribers: [],\n        closures: /* @__PURE__ */ new Map(),\n        hasDownstreamIntersections: () => {\n          let hasDownstreamIntersections = !!(signal.intersection || signal.closures.size);\n          if (!hasDownstreamIntersections) {\n            for (const value of signal.values) {\n              if (value.signal.hasDownstreamIntersections()) {\n                hasDownstreamIntersections = true;\n                break;\n              }\n            }\n          }\n          if (!hasDownstreamIntersections) {\n            if (!Array.isArray(referencedBindings) && referencedBindings) {\n              for (const alias of referencedBindings.aliases) {\n                if (getSignal(section, alias).hasDownstreamIntersections()) {\n                  hasDownstreamIntersections = true;\n                  break;\n                }\n              }\n              if (!hasDownstreamIntersections) {\n                for (const [, alias] of referencedBindings.propertyAliases) {\n                  if (getSignal(section, alias).hasDownstreamIntersections()) {\n                    hasDownstreamIntersections = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          signal.hasDownstreamIntersections = () => hasDownstreamIntersections;\n          return hasDownstreamIntersections;\n        },\n        build: unimplementedBuild,\n        export: !!exportName\n      }\n    );\n    if (isOutputHTML()) {\n      return signal;\n    } else if (!referencedBindings) {\n      signal.build = () => getSignalFn(signal, [scopeIdentifier]);\n    } else if (Array.isArray(referencedBindings)) {\n      subscribe(referencedBindings, signal);\n      signal.build = () => {\n        return callRuntime(\n          \"intersection\",\n          import_compiler13.types.numericLiteral(referencedBindings.length),\n          getSignalFn(signal, [scopeIdentifier], referencedBindings),\n          buildSignalIntersections(signal)\n        );\n      };\n    } else if (referencedBindings.section !== section) {\n      getSignal(referencedBindings.section, referencedBindings).closures.set(\n        section,\n        signal\n      );\n      signal.build = () => {\n        const builder = getSubscribeBuilder(section);\n        const ownerScope = getScopeExpression(\n          section,\n          referencedBindings.section\n        );\n        const isImmediateOwner = ownerScope.object === scopeIdentifier;\n        const isDynamicClosure = signal.isDynamicClosure = !(isImmediateOwner && builder);\n        return callRuntime(\n          isDynamicClosure ? \"dynamicClosure\" : \"closure\",\n          getScopeAccessorLiteral(referencedBindings),\n          getSignalFn(signal, [\n            scopeIdentifier,\n            import_compiler13.types.identifier(referencedBindings.name)\n          ]),\n          isImmediateOwner ? null : import_compiler13.types.arrowFunctionExpression([scopeIdentifier], ownerScope),\n          buildSignalIntersections(signal)\n        );\n      };\n    }\n  }\n  return signal;\n}\nfunction initValue(binding) {\n  const valueAccessor = getScopeAccessorLiteral(binding);\n  const section = binding.section;\n  const signal = getSignal(section, binding);\n  signal.build = () => {\n    const fn = getSignalFn(signal, [\n      scopeIdentifier,\n      import_compiler13.types.identifier(binding.name)\n    ]);\n    const intersections = buildSignalIntersections(signal);\n    const isParamBinding = !binding.upstreamAlias && (binding.type === 3 /* param */ || binding.type === 2 /* input */);\n    const isNakedAlias = binding.upstreamAlias && !binding.property;\n    const needsGuard = !isNakedAlias && (binding.downstreamExpressions.size || fn.body.body.length > 0);\n    const needsCache = needsGuard || intersections;\n    const needsMarks = isParamBinding || intersections;\n    if (needsCache || needsMarks) {\n      return callRuntime(\"value\", valueAccessor, fn, intersections);\n    } else {\n      return fn;\n    }\n  };\n  signal.valueAccessor = valueAccessor;\n  for (const alias of binding.aliases) {\n    initValue(alias);\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    initValue(alias);\n  }\n  return signal;\n}\nfunction getSignalFn(signal, params, referencedBindings) {\n  const section = signal.section;\n  const binding = signal.referencedBindings;\n  if (binding && !Array.isArray(binding) && binding.section === section) {\n    const [scopeIdentifier2, valueIdentifier] = params;\n    for (const alias of binding.aliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler13.types.expressionStatement(\n          import_compiler13.types.callExpression(aliasSignal.callee || aliasSignal.identifier, [\n            scopeIdentifier2,\n            valueIdentifier\n          ])\n        )\n      );\n    }\n    for (const [key, alias] of binding.propertyAliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler13.types.expressionStatement(\n          import_compiler13.types.callExpression(aliasSignal.callee || aliasSignal.identifier, [\n            scopeIdentifier2,\n            toMemberExpression(valueIdentifier, key)\n          ])\n        )\n      );\n    }\n  }\n  for (const value of signal.values) {\n    signal.render.push(\n      import_compiler13.types.expressionStatement(\n        import_compiler13.types.callExpression(value.signal.callee || value.signal.identifier, [\n          value.scope,\n          value.value\n        ])\n      )\n    );\n  }\n  if (referencedBindings) {\n    signal.render.unshift(\n      import_compiler13.types.variableDeclaration(\"const\", [\n        import_compiler13.types.variableDeclarator(\n          createScopeReadPattern(section, referencedBindings),\n          scopeIdentifier\n        )\n      ])\n    );\n  }\n  return import_compiler13.types.arrowFunctionExpression(params, import_compiler13.types.blockStatement(signal.render));\n}\nfunction buildSignalIntersections(signal) {\n  const section = signal.section;\n  let intersections = signal.intersection;\n  const binding = signal.referencedBindings;\n  if (binding && !Array.isArray(binding) && binding.section === signal.section) {\n    for (const alias of binding.aliases) {\n      const signal2 = getSignal(alias.section, alias);\n      if (signal2.hasDownstreamIntersections()) {\n        intersections = push(\n          intersections,\n          import_compiler13.types.identifier(signal2.identifier.name)\n        );\n      }\n    }\n    for (const [, alias] of binding.propertyAliases) {\n      const signal2 = getSignal(alias.section, alias);\n      if (signal2.hasDownstreamIntersections()) {\n        intersections = push(\n          intersections,\n          import_compiler13.types.identifier(signal2.identifier.name)\n        );\n      }\n    }\n  }\n  for (const value of signal.values) {\n    if (value.signal.hasDownstreamIntersections()) {\n      intersections = push(\n        intersections,\n        value.intersectionExpression ?? import_compiler13.types.identifier(value.signal.identifier.name)\n      );\n    }\n  }\n  const closureEntries = Array.from(signal.closures.entries()).sort(\n    ([a], [b]) => a.id - b.id\n  );\n  for (const [closureSection, closureSignal] of closureEntries) {\n    const builder = getSubscribeBuilder(closureSection);\n    const isImmediateOwner = closureSection.parent === section;\n    if (builder && isImmediateOwner) {\n      intersections = push(intersections, builder(closureSignal.identifier));\n    } else if (!signal.hasDynamicSubscribers) {\n      signal.hasDynamicSubscribers = true;\n    }\n  }\n  if (signal.hasDynamicSubscribers) {\n    signal.hasDynamicSubscribers = true;\n    intersections = push(\n      intersections,\n      callRuntime(\"dynamicSubscribers\", signal.valueAccessor)\n    );\n  }\n  return intersections && import_compiler13.types.arrowFunctionExpression(\n    [],\n    Array.isArray(intersections) ? callRuntime(\"intersections\", import_compiler13.types.arrayExpression(intersections)) : intersections\n  );\n}\nfunction subscribe(provider, subscriber) {\n  if (Array.isArray(provider)) {\n    provider.forEach((p) => subscribe(p, subscriber));\n    return;\n  }\n  const providerSignal = getSignal(subscriber.section, provider);\n  providerSignal.intersection = push(\n    providerSignal.intersection,\n    subscriber.identifier\n  );\n}\nfunction generateSignalName(referencedBindings) {\n  let name;\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      name = \"expr\";\n      for (const ref of referencedBindings) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name = referencedBindings.name;\n    }\n  } else {\n    name = \"setup\";\n  }\n  return name;\n}\nfunction queueSource(source, value, targetSection, changeBinding) {\n  if (!changeBinding) {\n    return callRuntime(\n      \"queueSource\",\n      getScopeExpression(targetSection, source.section),\n      source.identifier,\n      value\n    );\n  }\n  const changeBindingId = import_compiler13.types.identifier(changeBinding.name);\n  if (changeBinding.upstreamExpression?.static) {\n    return import_compiler13.types.callExpression(changeBindingId, [value]);\n  }\n  return callRuntime(\n    \"queueControllableSource\",\n    getScopeExpression(targetSection, source.section),\n    source.identifier,\n    changeBindingId,\n    value\n  );\n}\nfunction finalizeSignalArgs(args) {\n  for (let i = args.length - 1; i >= 0; i--) {\n    const arg = args[i];\n    if (import_compiler13.types.isArrowFunctionExpression(arg)) {\n      const body = arg.body.body;\n      if (body) {\n        if (body.length === 0) {\n          args[i] = import_compiler13.types.nullLiteral();\n        } else if (body.length === 1 && import_compiler13.types.isExpressionStatement(body[0])) {\n          arg.body = body[0].expression;\n        }\n      }\n    }\n  }\n  for (let i = args.length - 1; import_compiler13.types.isNullLiteral(args[i]); ) {\n    args.length = i--;\n  }\n}\nfunction addStatement(type, targetSection, referencedBindings, statement, originalNodes, isInlined) {\n  const signal = getSignal(targetSection, referencedBindings);\n  const statements = signal[type] ??= [];\n  if (Array.isArray(statement)) {\n    statements.push(...statement);\n  } else {\n    statements.push(statement);\n  }\n  if (type === \"effect\") {\n    if (Array.isArray(originalNodes)) {\n      for (const node of originalNodes) {\n        if (isInlined || !import_compiler13.types.isFunction(node)) {\n          addEffectReferences(signal, node);\n        }\n      }\n    } else if (originalNodes && (isInlined || !import_compiler13.types.isFunction(originalNodes))) {\n      addEffectReferences(signal, originalNodes);\n    }\n  }\n}\nfunction addValue(targetSection, referencedBindings, signal, value, scope = scopeIdentifier, intersectionExpression) {\n  getSignal(targetSection, referencedBindings).values.push({\n    signal,\n    value,\n    scope,\n    intersectionExpression\n  });\n}\nfunction addEffectReferences(signal, expression) {\n  signal.effectInlineReferences = bindingUtil.union(\n    signal.effectInlineReferences,\n    expression.extra?.referencedBindings\n  );\n}\nfunction getResumeRegisterId(section, referencedBindings, type) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let name = \"\";\n  if (referencedBindings) {\n    if (typeof referencedBindings === \"string\") {\n      name += `_${referencedBindings}`;\n    } else if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        name += `_${ref.name}`;\n      }\n    } else {\n      name += `_${referencedBindings.name}`;\n    }\n  }\n  return (0, import_babel_utils9.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}${name}${type ? \"/\" + type : \"\"}`\n  );\n}\nvar usedRegisterIdsBySection = /* @__PURE__ */ new WeakMap();\nfunction getRegisterUID(section, name) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let used = usedRegisterIdsBySection.get(section);\n  if (!used) usedRegisterIdsBySection.set(section, used = /* @__PURE__ */ new Set());\n  const baseId = (0, import_babel_utils9.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}/${name}`\n  );\n  let count = 0;\n  let id = baseId;\n  while (used.has(id)) {\n    id = baseId + \"_\" + ++count;\n  }\n  used.add(id);\n  return id;\n}\nfunction renameBindings() {\n  import_compiler13.types.traverseFast(currentProgramPath.node, (node) => {\n    if (import_compiler13.types.isIdentifier(node)) {\n      const binding = node.extra && (node.extra.source || node.extra.binding);\n      if (binding && binding.name !== node.name) {\n        node.name = binding.name;\n      }\n    }\n  });\n}\nfunction replaceAssignments() {\n  if (currentProgramPath.node.extra.assignments) {\n    for (const [valueSection, assignment] of currentProgramPath.node.extra.assignments) {\n      const { node } = assignment;\n      if (node.type === \"UpdateExpression\") {\n        const binding = node.argument.extra?.source;\n        if (binding) {\n          const { buildAssignment } = getSignal(binding.section, binding);\n          if (buildAssignment) {\n            const replacement = buildAssignment(\n              valueSection,\n              import_compiler13.types.binaryExpression(\n                node.operator === \"++\" ? \"+\" : \"-\",\n                node.argument,\n                import_compiler13.types.numericLiteral(1)\n              )\n            );\n            assignment.replaceWith(\n              node.prefix || assignment.parentPath.isExpressionStatement() ? replacement : import_compiler13.types.sequenceExpression([replacement, node.argument])\n            );\n          }\n        }\n      } else {\n        if (node.left.type === \"ObjectPattern\" || node.left.type === \"ArrayPattern\") {\n          handleDestructure(assignment, node.left, valueSection);\n        } else if (node.left.type === \"Identifier\") {\n          const binding = node.left.extra?.source;\n          if (binding) {\n            const { buildAssignment } = getSignal(binding.section, binding);\n            if (buildAssignment) {\n              const replacement = buildAssignment(\n                valueSection,\n                node.operator === \"=\" ? node.right : import_compiler13.types.binaryExpression(\n                  node.operator.slice(\n                    0,\n                    -1\n                  ),\n                  node.left,\n                  node.right\n                )\n              );\n              assignment.replaceWith(replacement);\n            }\n          }\n        }\n      }\n    }\n  }\n}\nfunction writeSignals(section) {\n  const signals = [...getSignals(section).values()].sort(sortSignals);\n  for (const signal of signals) {\n    let effectDeclarator;\n    if (signal.effect.length) {\n      const effectIdentifier = import_compiler13.types.identifier(`${signal.identifier.name}_effect`);\n      if (signal.effectInlineReferences) {\n        signal.effect.unshift(\n          import_compiler13.types.variableDeclaration(\"const\", [\n            import_compiler13.types.variableDeclarator(\n              createScopeReadPattern(section, signal.effectInlineReferences),\n              scopeIdentifier\n            )\n          ])\n        );\n      }\n      effectDeclarator = import_compiler13.types.variableDeclarator(\n        effectIdentifier,\n        callRuntime(\n          \"register\",\n          import_compiler13.types.stringLiteral(\n            getResumeRegisterId(section, signal.referencedBindings)\n          ),\n          import_compiler13.types.arrowFunctionExpression(\n            [scopeIdentifier],\n            signal.effect.length === 1 && import_compiler13.types.isExpressionStatement(signal.effect[0]) ? signal.effect[0].expression : import_compiler13.types.blockStatement(signal.effect)\n          )\n        )\n      );\n      signal.render.push(\n        import_compiler13.types.expressionStatement(\n          callRuntime(\"queueEffect\", scopeIdentifier, effectIdentifier)\n        )\n      );\n    }\n    let value = signal.build();\n    if (import_compiler13.types.isCallExpression(value)) {\n      finalizeSignalArgs(value.arguments);\n    }\n    if (signal.register) {\n      value = callRuntime(\n        \"registerBoundSignal\",\n        import_compiler13.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings)\n        ),\n        value\n      );\n    }\n    if (signal.isDynamicClosure && isStatefulReferences(signal.referencedBindings)) {\n      value = callRuntime(\n        \"registerSubscriber\",\n        import_compiler13.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings, \"subscriber\")\n        ),\n        value\n      );\n    }\n    const signalDeclarator = import_compiler13.types.variableDeclarator(signal.identifier, value);\n    let signalDeclaration = !section.parent && !signal.referencedBindings && (import_compiler13.types.isFunctionExpression(value) || import_compiler13.types.isArrowFunctionExpression(value)) ? import_compiler13.types.functionDeclaration(\n      signal.identifier,\n      value.params,\n      import_compiler13.types.isExpression(value.body) ? import_compiler13.types.blockStatement([import_compiler13.types.expressionStatement(value.body)]) : value.body\n    ) : import_compiler13.types.variableDeclaration(\"const\", [signalDeclarator]);\n    if (signal.export) {\n      signalDeclaration = import_compiler13.types.exportNamedDeclaration(signalDeclaration);\n    }\n    const roots = currentProgramPath.pushContainer(\n      \"body\",\n      effectDeclarator ? [\n        import_compiler13.types.variableDeclaration(\"const\", [effectDeclarator]),\n        signalDeclaration\n      ] : signalDeclaration\n    );\n    for (const root of roots) {\n      root.traverse(bindFunctionsVisitor, { root, section });\n    }\n  }\n}\nfunction sortSignals(a, b) {\n  const aReferencedBindings = getReferencedBindings(a);\n  const bReferencedBindings = getReferencedBindings(b);\n  for (let i = Math.max(aReferencedBindings.length, bReferencedBindings.length) - 1; i >= 0; i--) {\n    const diff = (bReferencedBindings[i] ?? -1) - (aReferencedBindings[i] ?? -1);\n    if (diff !== 0) return diff;\n  }\n  return 0;\n}\nfunction getReferencedBindings({ referencedBindings: reserve }) {\n  if (!reserve) {\n    return [];\n  } else if (Array.isArray(reserve)) {\n    return reserve.map(getMappedId).sort();\n  } else {\n    return [getMappedId(reserve)];\n  }\n}\nfunction getMappedId(reference) {\n  return (reference.type === 0 /* dom */ ? 1 : 0) * 1e4 + reference.id;\n}\nfunction addHTMLEffectCall(section, referencedBindings) {\n  addStatement(\"effect\", section, referencedBindings, void 0, []);\n}\nfunction writeHTMLResumeStatements(path4, tagVarIdentifier) {\n  const section = getSectionForBody(path4);\n  if (!section) return;\n  const allSignals = Array.from(getSignals(section).values());\n  const scopeIdIdentifier = getScopeIdIdentifier(section);\n  forEach(section.closures, (closure) => {\n    if (isStatefulReferences(closure)) {\n      let currentSection = section;\n      while (currentSection !== closure.section) {\n        getSerializedScopeProperties(currentSection).set(\n          import_compiler13.types.stringLiteral(\"_\"),\n          callRuntime(\n            \"ensureScopeWithId\",\n            getScopeIdIdentifier(currentSection = currentSection.parent)\n          )\n        );\n      }\n      setForceResumeScope(closure.section);\n      const isImmediateOwner = section.parent?.id === closure.section.id;\n      const isDynamicClosure = !getSubscribeBuilder(section) || !isImmediateOwner;\n      if (isDynamicClosure) {\n        path4.pushContainer(\n          \"body\",\n          import_compiler13.types.expressionStatement(\n            callRuntime(\n              \"writeEffect\",\n              scopeIdIdentifier,\n              import_compiler13.types.stringLiteral(\n                getResumeRegisterId(section, closure, \"subscriber\")\n              )\n            )\n          )\n        );\n      }\n    }\n  });\n  for (let i = allSignals.length; i--; ) {\n    if (allSignals[i].effect.length) {\n      const signalRefs = allSignals[i].referencedBindings;\n      path4.pushContainer(\n        \"body\",\n        import_compiler13.types.expressionStatement(\n          callRuntime(\n            \"writeEffect\",\n            scopeIdIdentifier,\n            import_compiler13.types.stringLiteral(getResumeRegisterId(section, signalRefs))\n          )\n        )\n      );\n    }\n  }\n  const accessors = /* @__PURE__ */ new Set();\n  const additionalProperties = getSerializedScopeProperties(section);\n  const serializedProperties = [];\n  forEach(section.bindings, (binding) => {\n    if (binding.serialize && binding.type !== 0 /* dom */) {\n      const accessor = getScopeAccessorLiteral(binding);\n      serializedProperties.push(\n        import_compiler13.types.objectProperty(accessor, import_compiler13.types.identifier(binding.name))\n      );\n      accessors.add(accessor.value);\n    }\n  });\n  if (tagVarIdentifier && returnId(section) !== void 0) {\n    serializedProperties.push(\n      import_compiler13.types.objectProperty(\n        import_compiler13.types.stringLiteral(\"/\" /* TagVariable */),\n        tagVarIdentifier\n      )\n    );\n  }\n  for (const [key, value] of additionalProperties) {\n    if (!accessors.has(key.value)) {\n      serializedProperties.push(\n        import_compiler13.types.objectProperty(key, value, !import_compiler13.types.isLiteral(key))\n      );\n      accessors.add(key.value);\n    }\n  }\n  if (serializedProperties.length || forceResumeScope(section)) {\n    path4.pushContainer(\n      \"body\",\n      import_compiler13.types.expressionStatement(\n        callRuntime(\n          \"writeScope\",\n          scopeIdIdentifier,\n          import_compiler13.types.objectExpression(serializedProperties)\n        )\n      )\n    );\n  }\n  if (path4.get(\"body\").length) {\n    path4.unshiftContainer(\n      \"body\",\n      import_compiler13.types.variableDeclaration(\"const\", [\n        import_compiler13.types.variableDeclarator(scopeIdIdentifier, callRuntime(\"nextScopeId\"))\n      ])\n    );\n  }\n}\nvar bindFunctionsVisitor = {\n  FunctionExpression: { exit: bindFunction },\n  ArrowFunctionExpression: { exit: bindFunction }\n};\nfunction handleDestructure(assignment, node, section, ctx, replace) {\n  if (!ctx) {\n    ctx = {\n      statement: assignment.getStatementParent(),\n      end: assignment.getStatementParent()\n    };\n  }\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        handleDestructure(assignment, prop, section, ctx);\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const i in node.elements) {\n        if (node.elements[i] === null) continue;\n        handleDestructure(\n          assignment,\n          node.elements[i],\n          section,\n          ctx,\n          (id) => node.elements[i] = id\n        );\n      }\n      break;\n    case \"RestElement\":\n      handleDestructure(\n        assignment,\n        node.argument,\n        section,\n        ctx,\n        (id) => node.argument = id\n      );\n      break;\n    case \"ObjectProperty\":\n      handleDestructure(\n        assignment,\n        node.value,\n        section,\n        ctx,\n        (id) => node.value = id\n      );\n      break;\n    case \"Identifier\":\n      {\n        const binding = node.extra?.source;\n        if (binding) {\n          const { buildAssignment } = getSignal(binding.section, binding);\n          if (buildAssignment) {\n            const valueId = ctx.statement.scope.generateUidIdentifier(\n              node.name\n            );\n            ctx.statement.insertBefore(\n              import_compiler13.types.variableDeclaration(\"let\", [import_compiler13.types.variableDeclarator(valueId)])\n            );\n            replace?.(valueId);\n            [ctx.end] = ctx.end.insertAfter(\n              import_compiler13.types.expressionStatement(buildAssignment(section, valueId))\n            );\n          }\n        }\n      }\n      break;\n  }\n}\nfunction bindFunction(fn, { root, section }) {\n  const { node } = fn;\n  const { extra } = node;\n  if (!extra?.referencedBindings) return;\n  const { name, referencedBindings } = extra;\n  const fnId = fn.hub.file.path.scope.generateUidIdentifier(name);\n  root.insertBefore(\n    import_compiler13.types.variableDeclaration(\"const\", [\n      import_compiler13.types.variableDeclarator(\n        fnId,\n        import_compiler13.types.arrowFunctionExpression(\n          [scopeIdentifier],\n          referencedBindings ? import_compiler13.types.blockStatement([\n            import_compiler13.types.variableDeclaration(\"const\", [\n              import_compiler13.types.variableDeclarator(\n                createScopeReadPattern(section, referencedBindings),\n                scopeIdentifier\n              )\n            ]),\n            import_compiler13.types.returnStatement(node)\n          ]) : node\n        )\n      )\n    ])\n  )[0].skip();\n  fn.replaceWith(import_compiler13.types.callExpression(fnId, [scopeIdentifier]))[0].skip();\n}\nfunction getSetup(section) {\n  return getSignals(section).get(void 0)?.identifier;\n}\nfunction toMemberExpression(value, key) {\n  const keyLiteral = keyToNode(key);\n  return import_compiler13.types.memberExpression(\n    value,\n    keyLiteral,\n    keyLiteral.type !== \"Identifier\"\n  );\n}\nfunction keyToNode(key) {\n  if (/^[a-z_$][a-z0-9_$]*$/i.test(key)) {\n    return import_compiler13.types.identifier(key);\n  } else if (/^(?:0|[1-9][0-9]*)$/.test(key)) {\n    return import_compiler13.types.numericLiteral(parseInt(key, 10));\n  }\n  return import_compiler13.types.stringLiteral(key);\n}\n\n// src/visitors/program/dom.ts\nvar dom_default = {\n  translate: {\n    exit(program) {\n      visit(program);\n      const section = getSectionForBody(program);\n      const { walks, writes, setup } = getSectionMeta(section);\n      const domExports = program.node.extra.domExports;\n      const templateIdentifier = import_compiler14.types.identifier(domExports.template);\n      const walksIdentifier = import_compiler14.types.identifier(domExports.walks);\n      const setupIdentifier = import_compiler14.types.identifier(domExports.setup);\n      const closuresIdentifier = import_compiler14.types.identifier(domExports.closures);\n      const paramsBinding = program.node.extra.binding;\n      const programParamsSignal = paramsBinding && bindingHasDownstreamExpressions(paramsBinding) ? initValue(paramsBinding) : void 0;\n      replaceAssignments();\n      forEachSectionReverse((childSection) => {\n        if (childSection !== section) {\n          const tagParamsSignal = childSection.params && initValue(childSection.params);\n          const { walks: walks2, writes: writes2, setup: setup2 } = getSectionMeta(childSection);\n          const closures2 = getSectionClosuresExpr(childSection);\n          const identifier = import_compiler14.types.identifier(childSection.name);\n          const renderer = callRuntime(\n            getSectionParentIsOwner(childSection) ? \"createRenderer\" : \"createRendererWithOwner\",\n            writes2,\n            walks2,\n            setup2,\n            closures2 && import_compiler14.types.arrowFunctionExpression([], closures2),\n            void 0,\n            tagParamsSignal?.identifier && import_compiler14.types.arrowFunctionExpression([], tagParamsSignal.identifier)\n          );\n          writeSignals(childSection);\n          program.node.body.push(\n            import_compiler14.types.variableDeclaration(\"const\", [\n              import_compiler14.types.variableDeclarator(\n                identifier,\n                isStatefulSection(childSection) ? callRuntime(\n                  \"register\",\n                  import_compiler14.types.stringLiteral(\n                    getResumeRegisterId(childSection, \"renderer\")\n                  ),\n                  renderer\n                ) : renderer\n              )\n            ])\n          );\n        }\n      });\n      const closures = getSectionClosuresExpr(section);\n      writeSignals(section);\n      renameBindings();\n      if (!setup) {\n        program.node.body.unshift(\n          import_compiler14.types.exportNamedDeclaration(\n            import_compiler14.types.variableDeclaration(\"const\", [\n              import_compiler14.types.variableDeclarator(\n                setupIdentifier,\n                import_compiler14.types.arrowFunctionExpression([], import_compiler14.types.blockStatement([]))\n              )\n            ])\n          )\n        );\n      }\n      program.node.body.unshift(\n        import_compiler14.types.exportNamedDeclaration(\n          import_compiler14.types.variableDeclaration(\"const\", [\n            import_compiler14.types.variableDeclarator(\n              templateIdentifier,\n              writes || import_compiler14.types.stringLiteral(\"\")\n            )\n          ])\n        ),\n        import_compiler14.types.exportNamedDeclaration(\n          import_compiler14.types.variableDeclaration(\"const\", [\n            import_compiler14.types.variableDeclarator(walksIdentifier, walks || import_compiler14.types.stringLiteral(\"\"))\n          ])\n        )\n      );\n      if (closures) {\n        program.node.body.push(\n          import_compiler14.types.exportNamedDeclaration(\n            import_compiler14.types.variableDeclaration(\"const\", [\n              import_compiler14.types.variableDeclarator(closuresIdentifier, closures)\n            ])\n          )\n        );\n      }\n      program.node.body.push(\n        import_compiler14.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            callRuntime(\n              \"createRenderer\",\n              templateIdentifier,\n              walksIdentifier,\n              setupIdentifier,\n              closures && import_compiler14.types.arrowFunctionExpression([], closuresIdentifier),\n              void 0,\n              programParamsSignal?.identifier && import_compiler14.types.arrowFunctionExpression([], programParamsSignal.identifier)\n            ),\n            import_compiler14.types.stringLiteral(program.hub.file.metadata.marko.id)\n          )\n        )\n      );\n    }\n  }\n};\nfunction getSectionClosuresExpr(section) {\n  if (section.closures) {\n    return import_compiler14.types.arrayExpression(\n      map(\n        section.closures,\n        (closure) => getSignal(section, closure).identifier\n      ).reverse()\n    );\n  }\n}\n\n// src/visitors/program/html.ts\nvar import_compiler15 = require(\"@marko/compiler\");\n\n// src/util/is-static.ts\nfunction isStatic(path4) {\n  return path4.isImportDeclaration() || path4.isExportDeclaration() || path4.isMarkoScriptlet({ static: true });\n}\n\n// src/visitors/program/html.ts\nvar html_default = {\n  translate: {\n    exit(program) {\n      const section = getSectionForBody(program);\n      const tagVarIdentifier = program.scope.generateUidIdentifier(\"tagVar\");\n      flushInto(program);\n      writeHTMLResumeStatements(program, tagVarIdentifier);\n      renameBindings();\n      const returnIdentifier = returnId(section);\n      if (returnIdentifier !== void 0) {\n        program.pushContainer(\"body\", import_compiler15.types.returnStatement(returnIdentifier));\n      }\n      const renderContent = [];\n      for (const child of program.get(\"body\")) {\n        if (!isStatic(child)) {\n          renderContent.push(child.node);\n          child.remove();\n        } else if (child.isMarkoScriptlet()) {\n          if (child.node.target && child.node.target !== \"server\") {\n            child.remove();\n          } else {\n            child.replaceWithMultiple(child.node.body);\n          }\n        }\n      }\n      program.pushContainer(\"body\", [\n        import_compiler15.types.variableDeclaration(\"const\", [\n          import_compiler15.types.variableDeclarator(\n            htmlRendererIdentifier,\n            callRuntime(\n              \"createRenderer\",\n              import_compiler15.types.arrowFunctionExpression(\n                [import_compiler15.types.identifier(\"input\"), tagVarIdentifier],\n                import_compiler15.types.blockStatement(renderContent)\n              )\n            )\n          )\n        ]),\n        import_compiler15.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            htmlRendererIdentifier,\n            import_compiler15.types.stringLiteral(program.hub.file.metadata.marko.id)\n          )\n        )\n      ]);\n    }\n  }\n};\n\n// src/visitors/program/index.ts\nvar currentProgramPath;\nvar scopeIdentifier;\nvar cleanIdentifier;\nvar htmlRendererIdentifier;\nvar previousProgramPath = /* @__PURE__ */ new WeakMap();\nvar program_default = {\n  migrate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      program.node.params = [import_compiler16.types.identifier(\"input\")];\n      currentProgramPath = program;\n    },\n    exit() {\n      currentProgramPath.scope.crawl();\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  analyze: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      startSection(program);\n      trackParamsReferences(program, 2 /* input */);\n      const { scope } = program;\n      (program.node.extra ??= {}).domExports = {\n        template: scope.generateUid(\"template_\"),\n        walks: scope.generateUid(\"walks_\"),\n        setup: scope.generateUid(\"setup_\"),\n        params: void 0,\n        // TODO look into recursive components with fine grained params.\n        closures: scope.generateUid(\"closures_\")\n      };\n    },\n    exit(program) {\n      finalizeReferences();\n      const {\n        scope,\n        node: { extra }\n      } = program;\n      if (extra.binding && bindingHasDownstreamExpressions(extra.binding)) {\n        extra.domExports.params = buildTemplateExports(extra.binding, scope);\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  translate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      scopeIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"scope\") : null;\n      cleanIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"clean\") : null;\n      htmlRendererIdentifier = isOutputHTML() ? program.scope.generateUidIdentifier(\"renderer\") : null;\n      if (getMarkoOpts().output === \"hydrate\") {\n        const entryFile = program.hub.file;\n        const visitedFiles = /* @__PURE__ */ new Set([\n          (0, import_babel_utils10.resolveRelativePath)(entryFile, entryFile.opts.filename)\n        ]);\n        entry_builder_default.visit(entryFile, entryFile, function visitChild(resolved) {\n          if (!visitedFiles.has(resolved)) {\n            visitedFiles.add(resolved);\n            const file = (0, import_babel_utils10.loadFileForImport)(entryFile, resolved);\n            if (file) {\n              entry_builder_default.visit(\n                file,\n                entryFile,\n                (id) => visitChild(resolveRelativeToEntry(entryFile, file, id))\n              );\n            }\n          }\n        });\n        program.node.body = entry_builder_default.build(entryFile);\n        program.skip();\n        return;\n      }\n    },\n    exit(program) {\n      if (isOutputHTML()) {\n        html_default.translate.exit(program);\n      } else {\n        dom_default.translate.exit(program);\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  }\n};\nfunction resolveRelativeToEntry(entryFile, file, req) {\n  return file === entryFile ? (0, import_babel_utils10.resolveRelativePath)(file, req) : (0, import_babel_utils10.resolveRelativePath)(\n    entryFile,\n    req[0] === \".\" ? import_path.default.join(file.opts.filename, \"..\", req) : req\n  );\n}\nfunction buildTemplateExports(binding, scope) {\n  const templateExport = {\n    id: binding.export ??= scope.generateUid(binding.name + \"_\"),\n    props: void 0\n  };\n  const { aliases, propertyAliases, downstreamExpressions } = binding;\n  if (!downstreamExpressions.size) {\n    templateExport.props = {};\n    for (const [property, alias] of propertyAliases) {\n      templateExport.props[property] = buildTemplateExports(alias, scope);\n    }\n    for (const alias of aliases) {\n      const exports2 = buildTemplateExports(alias, scope);\n      if (exports2.props) {\n        templateExport.props = { ...templateExport.props, ...exports2.props };\n      } else {\n        templateExport.props = void 0;\n        return templateExport;\n      }\n    }\n  }\n  return templateExport;\n}\n\n// src/util/marko-config.ts\nfunction isOutputHTML() {\n  return getMarkoOpts().output === \"html\";\n}\nfunction isOutputDOM() {\n  return !isOutputHTML();\n}\nfunction getMarkoOpts() {\n  return currentProgramPath.hub.file.markoOpts;\n}\nfunction isOptimize() {\n  return getMarkoOpts().optimize;\n}\n\n// src/util/translate-var.ts\nvar import_compiler17 = require(\"@marko/compiler\");\nfunction translateVar(tag, initialValue, kind = \"const\") {\n  const {\n    node: { var: tagVar }\n  } = tag;\n  if (!tagVar) {\n    return;\n  }\n  tag.insertBefore(\n    import_compiler17.types.variableDeclaration(kind, [import_compiler17.types.variableDeclarator(tagVar, initialValue)])\n  );\n}\n\n// src/core/const.ts\nvar const_default = {\n  analyze(tag) {\n    (0, import_babel_utils11.assertNoArgs)(tag);\n    (0, import_babel_utils11.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a tag variable.\");\n    }\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler18.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `const` tag only supports the `value` attribute.\"\n      );\n    }\n    const upstreamAlias = import_compiler18.types.isIdentifier(valueAttr.value) ? tag.scope.getBinding(valueAttr.value.name)?.identifier.extra?.binding : void 0;\n    trackVarReferences(\n      tag,\n      4 /* derived */,\n      upstreamAlias,\n      valueAttr.value.extra ??= {}\n    );\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      const { value } = valueAttr;\n      if (isOutputDOM()) {\n        const section = getSection(tag);\n        const varBinding = node.var.extra?.binding;\n        if (varBinding && !varBinding.upstreamAlias) {\n          const derivation = initValue(varBinding);\n          addValue(section, value.extra?.referencedBindings, derivation, value);\n        }\n      } else {\n        translateVar(tag, value);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an constant binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#const\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/const.d.marko\"\n};\n\n// src/core/debug.ts\nvar import_babel_utils12 = require(\"@marko/babel-utils\");\nvar import_compiler19 = require(\"@marko/compiler\");\nvar debug_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils12.assertNoVar)(tag);\n    (0, import_babel_utils12.assertNoArgs)(tag);\n    (0, import_babel_utils12.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (tag.node.attributes.length > 1 || tag.node.attributes.length === 1 && (!import_compiler19.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\")) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `debug` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const referencedBindings = valueAttr?.value.extra?.referencedBindings;\n      const statement = withPreviousLocation(import_compiler19.types.debuggerStatement(), tag.node);\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Debug on value change.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#debug\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/debug.d.marko\"\n};\n\n// src/core/define.ts\nvar import_babel_utils19 = require(\"@marko/babel-utils\");\nvar import_compiler29 = require(\"@marko/compiler\");\n\n// src/util/translate-attrs.ts\nvar import_babel_utils18 = require(\"@marko/babel-utils\");\nvar import_compiler28 = require(\"@marko/compiler\");\n\n// src/core/for.ts\nvar import_babel_utils16 = require(\"@marko/babel-utils\");\nvar import_compiler26 = require(\"@marko/compiler\");\n\n// src/util/get-known-attr-values.ts\nfunction getKnownAttrValues(tag) {\n  const attrs2 = {};\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      attrs2[attr2.name] = attr2.value;\n    }\n  }\n  return attrs2;\n}\n\n// src/util/plugin-hooks.ts\nvar import_compiler20 = require(\"@marko/compiler\");\nfunction enter2(modulePlugin, path4) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path4;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (isFunctionPlugin(plugin)) {\n    plugin(path4, import_compiler20.types);\n  } else if (plugin.enter) {\n    plugin.enter(path4, import_compiler20.types);\n  }\n  return node !== path4.node;\n}\nfunction exit2(modulePlugin, path4) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path4;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (!isFunctionPlugin(plugin) && plugin.exit) {\n    plugin.exit(path4, import_compiler20.types);\n  }\n  return node !== path4.node;\n}\nfunction isModulePlugin(plugin) {\n  return Boolean(plugin.default);\n}\nfunction isFunctionPlugin(plugin) {\n  return typeof plugin === \"function\";\n}\n\n// src/util/visitors.ts\nfunction extractVisitors(visitors2) {\n  const result = {\n    migrate: {},\n    transform: {},\n    analyze: {},\n    translate: {}\n  };\n  for (const _name in visitors2) {\n    const name = _name;\n    const value = visitors2[name];\n    if (value.migrate) result.migrate[name] = value.migrate;\n    if (value.transform) result.transform[name] = value.transform;\n    if (value.analyze) result.analyze[name] = value.analyze;\n    if (value.translate) result.translate[name] = value.translate;\n  }\n  return result;\n}\nfunction translateByTarget({\n  html,\n  dom\n}) {\n  return {\n    enter(path4) {\n      enter2(isOutputHTML() ? html : dom, path4);\n    },\n    exit(path4) {\n      exit2(isOutputHTML() ? html : dom, path4);\n    }\n  };\n}\n\n// src/visitors/tag/native-tag.ts\nvar import_babel_utils15 = require(\"@marko/babel-utils\");\nvar import_compiler25 = require(\"@marko/compiler\");\n\n// src/util/evaluate.ts\nvar import_babel_utils13 = require(\"@marko/babel-utils\");\nfunction evaluate(path4) {\n  let { extra } = path4.node;\n  if (!extra) {\n    extra = path4.node.extra = {};\n  }\n  if (extra.confident === void 0) {\n    const computed = (0, import_babel_utils13.computeNode)(path4.node.value);\n    if (computed) {\n      extra.computed = computed.value;\n      extra.confident = true;\n    } else {\n      extra.computed = void 0;\n      extra.confident = false;\n    }\n  }\n  return extra;\n}\n\n// src/util/to-property-name.ts\nvar import_compiler21 = require(\"@marko/compiler\");\nvar IDENTIFIER_REG = /^[0-9A-Z_$]+$/i;\nfunction toPropertyName(name) {\n  return IDENTIFIER_REG.test(name) ? import_compiler21.types.identifier(name) : import_compiler21.types.stringLiteral(name);\n}\n\n// src/visitors/assignment-expression.ts\nvar import_compiler22 = require(\"@marko/compiler\");\nvar assignment_expression_default = {\n  translate: {\n    exit(assignment) {\n      if (isOutputDOM()) {\n        handleDestructure2(assignment, assignment.node.left);\n      }\n    }\n  }\n};\nfunction handleDestructure2(assignment, node) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        handleDestructure2(assignment, prop);\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const i in node.elements) {\n        if (node.elements[i] === null) continue;\n        handleDestructure2(assignment, node.elements[i]);\n      }\n      break;\n    case \"RestElement\":\n      handleDestructure2(assignment, node.argument);\n      break;\n    case \"ObjectProperty\":\n      handleDestructure2(assignment, node.value);\n      break;\n    case \"Identifier\": {\n      const source = node.extra?.source;\n      if (source) {\n        const section = getSection(assignment);\n        (currentProgramPath.node.extra.assignments ??= []).push([\n          section,\n          assignment\n        ]);\n      }\n      break;\n    }\n  }\n}\n\n// src/visitors/function.ts\nvar import_babel_utils14 = require(\"@marko/babel-utils\");\nvar import_compiler23 = require(\"@marko/compiler\");\nvar functionIdsBySection = /* @__PURE__ */ new WeakMap();\nvar registeredFunctions = /* @__PURE__ */ new WeakSet();\nvar function_default = {\n  analyze(fn) {\n    const markoRoot = getMarkoRoot(fn);\n    const isStatic2 = !markoRoot || markoRoot.isMarkoScriptlet({ static: true });\n    if (!isFunction(fn, isStatic2)) return;\n    if (markoRoot && (markoRoot.isMarkoPlaceholder() || markoRoot.isMarkoScriptlet({ target: \"server\" }))) {\n      return;\n    }\n    const { node } = fn;\n    const extra = node.extra ??= {};\n    const name = extra.name = fn.node.id?.name || (isMarkoAttribute(markoRoot) ? markoRoot.node.default ? import_compiler23.types.toIdentifier(\n      markoRoot.parentPath.has(\"var\") ? markoRoot.parentPath.get(\"var\") : markoRoot.parentPath.get(\"name\")\n    ) : markoRoot.node.name : \"anonymous\");\n    if (isMarkoAttribute(markoRoot) && ((0, import_babel_utils14.isNativeTag)(markoRoot.parentPath) && /^on[A-Z-]/.test(markoRoot.node.name) || isCoreTagName(markoRoot.parentPath, \"effect\") || isCoreTagName(markoRoot.parentPath, \"lifecycle\") || isCoreTagName(markoRoot.parentPath, \"for\") || isCoreTagName(markoRoot.parentPath, \"do\"))) {\n      return;\n    }\n    const {\n      markoOpts,\n      opts: { filename }\n    } = currentProgramPath.hub.file;\n    const section = getSection(fn);\n    let functionNameCounts = functionIdsBySection.get(section);\n    if (!functionNameCounts) {\n      functionNameCounts = /* @__PURE__ */ new Map();\n      functionIdsBySection.set(section, functionNameCounts);\n    }\n    const index = functionNameCounts.get(name);\n    let id = \"\";\n    if (index === void 0) {\n      functionNameCounts.set(name, 0);\n    } else {\n      id = `_${index}`;\n    }\n    extra.registerId = (0, import_babel_utils14.getTemplateId)(\n      markoOpts,\n      filename,\n      `${section.id}/${name + id}`\n    );\n  },\n  translate: {\n    exit(fn) {\n      const markoRoot = getMarkoRoot(fn);\n      const isStatic2 = !markoRoot || markoRoot.isMarkoScriptlet({ static: true });\n      if (!isFunction(fn, isStatic2)) return;\n      const { node } = fn;\n      const { extra } = node;\n      if (!extra?.registerId) return;\n      if (registeredFunctions.has(node)) return;\n      const section = getSection(fn);\n      if (!section) return;\n      registeredFunctions.add(node);\n      if (isOutputHTML()) {\n        const serializedScopeProperties = getSerializedScopeProperties(section);\n        forEach(extra.referencedBindings, (ref) => {\n          serializedScopeProperties.set(\n            getScopeAccessorLiteral(ref),\n            import_compiler23.types.identifier(ref.name)\n          );\n        });\n        if (import_compiler23.types.isFunctionDeclaration(node)) {\n          currentProgramPath.unshiftContainer(\n            \"body\",\n            import_compiler23.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                node.id,\n                import_compiler23.types.stringLiteral(extra.registerId),\n                isStatic2 ? void 0 : getScopeIdIdentifier(section)\n              )\n            )\n          )[0].skip();\n        } else {\n          const replacement = callRuntime(\n            \"register\",\n            node,\n            import_compiler23.types.stringLiteral(extra.registerId),\n            isStatic2 ? void 0 : getScopeIdIdentifier(section)\n          );\n          if (isMarko(fn.parentPath)) {\n            replacement.extra = node.extra;\n          }\n          fn.replaceWith(replacement)[0].skip();\n        }\n      } else {\n        const { referencedBindings } = extra;\n        const fnId = currentProgramPath.scope.generateUidIdentifier(extra.name);\n        if (import_compiler23.types.isFunctionDeclaration(node)) {\n          currentProgramPath.unshiftContainer(\n            \"body\",\n            import_compiler23.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                import_compiler23.types.stringLiteral(extra.registerId),\n                node.id\n              )\n            )\n          )[0].skip();\n        } else if (isStatic2) {\n          const replacement = callRuntime(\n            \"register\",\n            import_compiler23.types.stringLiteral(extra.registerId),\n            node\n          );\n          if (isMarko(fn.parentPath)) {\n            replacement.extra = node.extra;\n          }\n          fn.replaceWith(replacement)[0].skip();\n        } else {\n          const replacement = import_compiler23.types.callExpression(fnId, [scopeIdentifier]);\n          if (isMarko(fn.parentPath)) {\n            replacement.extra = node.extra;\n          }\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler23.types.variableDeclaration(\"const\", [\n              import_compiler23.types.variableDeclarator(\n                fnId,\n                callRuntime(\n                  \"register\",\n                  import_compiler23.types.stringLiteral(extra.registerId),\n                  import_compiler23.types.arrowFunctionExpression(\n                    [scopeIdentifier],\n                    referencedBindings ? import_compiler23.types.blockStatement([\n                      import_compiler23.types.variableDeclaration(\"const\", [\n                        import_compiler23.types.variableDeclarator(\n                          createScopeReadPattern(\n                            section,\n                            referencedBindings\n                          ),\n                          scopeIdentifier\n                        )\n                      ]),\n                      import_compiler23.types.returnStatement(node)\n                    ]) : node\n                  )\n                )\n              )\n            ])\n          )[0].skip();\n          fn.replaceWith(replacement)[0].skip();\n        }\n      }\n    }\n  }\n};\nfunction isFunction(fn, isStatic2) {\n  switch (fn.node.type) {\n    case \"FunctionDeclaration\":\n      return isStatic2;\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isMarkoAttribute(path4) {\n  return path4 ? path4.isMarkoAttribute() : false;\n}\n\n// src/visitors/update-expression.ts\nvar import_compiler24 = require(\"@marko/compiler\");\nvar update_expression_default = {\n  translate: {\n    exit(expr) {\n      if (isOutputDOM()) {\n        const source = expr.node.argument.extra?.source;\n        if (source) {\n          const section = getSection(expr);\n          (currentProgramPath.node.extra.assignments ??= []).push([\n            section,\n            expr\n          ]);\n        }\n      }\n    }\n  }\n};\n\n// src/visitors/tag/native-tag.ts\nvar kNativeTagBinding = Symbol(\"native tag binding\");\nvar kSerializeMarker = Symbol(\"serialize marker\");\nvar kGetterId = Symbol(\"node getter id\");\nvar htmlSelectArgs = /* @__PURE__ */ new WeakMap();\nfunction assertExclusiveControllableGroups(tag, attrs2) {\n  const exclusiveGroups = [\n    attrs2.open || attrs2.openChange,\n    attrs2.checked || attrs2.checkedChange,\n    attrs2.checkedValue || attrs2.checkedValueChange,\n    attrs2.valueChange\n  ].filter(Boolean);\n  if (exclusiveGroups.length > 1) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The attributes ${exclusiveGroups.map((attr2) => `\"${attr2.name}\"`).join(\", \")} are mutually exclusive.`\n    );\n  }\n}\nfunction getRelatedControllable(tagName, attrs2) {\n  switch (tagName) {\n    case \"input\":\n      if (attrs2.checked || attrs2.checkedChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_checked\",\n          attrs: [attrs2.checked, attrs2.checkedChange]\n        };\n      }\n      if (attrs2.checkedValue || attrs2.checkedValueChange) {\n        return {\n          special: true,\n          helper: \"controllable_input_checkedValue\",\n          attrs: [attrs2.checkedValue, attrs2.checkedValueChange, attrs2.value]\n        };\n      }\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"select\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_select_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"textarea\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_textarea_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"details\":\n    case \"dialog\":\n      if (attrs2.open || attrs2.openChange) {\n        return {\n          special: false,\n          helper: \"controllable_detailsOrDialog_open\",\n          attrs: [attrs2.open, attrs2.openChange]\n        };\n      }\n      break;\n  }\n}\nvar native_tag_default = {\n  transform: {\n    enter(tag) {\n      const tagName = getTagName(tag);\n      if (tagName === \"textarea\" && tag.node.body.body.length) {\n        const parts = [];\n        for (const child of tag.node.body.body) {\n          if (child.type === \"MarkoText\" || child.type === \"MarkoPlaceholder\" && child.escape) {\n            parts.push(child.value);\n          } else {\n            throw tag.hub.file.hub.buildError(\n              child,\n              \"Unexpected content in textarea, only text and placeholders are supported.\",\n              SyntaxError\n            );\n          }\n        }\n        tag.node.attributes.push(\n          import_compiler25.types.markoAttribute(\n            \"value\",\n            toTemplateOrStringLiteral(parts) || buildUndefined()\n          )\n        );\n        tag.node.body.body = [];\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils15.assertNoArgs)(tag);\n      (0, import_babel_utils15.assertNoParams)(tag);\n      (0, import_babel_utils15.assertNoAttributeTags)(tag);\n      const { node } = tag;\n      if (node.var && !import_compiler25.types.isIdentifier(node.var)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"Tag variables on native elements cannot be destructured.\"\n        );\n      }\n      const tagName = getTagName(tag);\n      const section = getOrCreateSection(tag);\n      let hasEventHandlers = false;\n      let hasDynamicAttributes = false;\n      const seen = {};\n      const { attributes } = tag.node;\n      let relatedControllable;\n      let spreadReferenceNodes;\n      for (let i = attributes.length; i--; ) {\n        const attr2 = attributes[i];\n        if (import_compiler25.types.isMarkoAttribute(attr2)) {\n          if (seen[attr2.name]) {\n            dropReferences(attr2.value);\n            continue;\n          }\n          seen[attr2.name] = attr2;\n          if (isEventHandler(attr2.name) || isChangeHandler(attr2.name)) {\n            (attr2.value.extra ??= {}).isEffect = true;\n            hasEventHandlers = true;\n          } else if (!evaluate(tag.get(\"attributes\")[i]).confident) {\n            hasDynamicAttributes = true;\n          }\n        } else if (import_compiler25.types.isMarkoSpreadAttribute(attr2)) {\n          hasEventHandlers = true;\n          hasDynamicAttributes = true;\n          (attr2.value.extra ??= {}).isEffect = true;\n        }\n        if (spreadReferenceNodes) {\n          spreadReferenceNodes.push(attr2.value);\n        } else if (import_compiler25.types.isMarkoSpreadAttribute(attr2)) {\n          spreadReferenceNodes = [attr2.value];\n          relatedControllable = getRelatedControllable(tagName, seen);\n        }\n      }\n      assertExclusiveControllableGroups(tag, seen);\n      if (spreadReferenceNodes) {\n        if (relatedControllable && !relatedControllable.attrs.every(Boolean)) {\n          for (const attr2 of relatedControllable.attrs) {\n            if (attr2) {\n              spreadReferenceNodes.push(attr2.value);\n            }\n          }\n          relatedControllable = void 0;\n        }\n        mergeReferences(section, tag.node, spreadReferenceNodes);\n      } else {\n        relatedControllable = getRelatedControllable(tagName, seen);\n      }\n      if (relatedControllable) {\n        mergeReferences(\n          section,\n          relatedControllable.attrs.find(Boolean),\n          relatedControllable.attrs.map((it) => it?.value)\n        );\n      }\n      if (node.var || hasEventHandlers || hasDynamicAttributes) {\n        currentProgramPath.node.extra.isInteractive ||= hasEventHandlers;\n        const tagName2 = node.name.type === \"StringLiteral\" ? node.name.value : import_compiler25.types.toIdentifier(tag.get(\"name\"));\n        const tagExtra = node.extra ??= {};\n        const bindingName = \"#\" + tagName2;\n        tagExtra[kSerializeMarker] = hasEventHandlers || !!node.var;\n        tagExtra[kNativeTagBinding] = createBinding(\n          bindingName,\n          0 /* dom */,\n          section\n        );\n        if (node.var) {\n          for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n            if (!ref.parentPath?.isCallExpression()) {\n              tagExtra[kGetterId] = getRegisterUID(section, bindingName);\n              break;\n            }\n          }\n        }\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagName = getTagName(tag);\n      const extra = tag.node.extra;\n      const nodeRef2 = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const name = tag.get(\"name\");\n      const tagDef = (0, import_babel_utils15.getTagDef)(tag);\n      const write2 = writeTo(tag);\n      const section = getSection(tag);\n      if (isHTML && extra.tagNameNullable) {\n        flushBefore(tag);\n      }\n      if (tag.has(\"var\")) {\n        const getterId = extra[kGetterId];\n        if (isHTML) {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          for (const reference of references) {\n            let currentSection = getSection(reference);\n            while (currentSection !== section && currentSection.parent) {\n              getSerializedScopeProperties(currentSection).set(\n                import_compiler25.types.stringLiteral(\"_\"),\n                callRuntime(\n                  \"ensureScopeWithId\",\n                  getScopeIdIdentifier(\n                    currentSection = currentSection.parent\n                  )\n                )\n              );\n            }\n          }\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(section),\n              getterId && import_compiler25.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n              `get_${varName}`\n            );\n            currentProgramPath.pushContainer(\n              \"body\",\n              import_compiler25.types.variableDeclaration(\"const\", [\n                import_compiler25.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler25.types.stringLiteral(getterId),\n                    getScopeAccessorLiteral(nodeRef2)\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (reference.parentPath?.isCallExpression()) {\n              reference.parentPath.replaceWith(\n                import_compiler25.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, nodeRef2)\n                )\n              );\n            } else if (getterFnIdentifier) {\n              reference.replaceWith(\n                import_compiler25.types.callExpression(getterFnIdentifier, [\n                  getScopeExpression(referenceSection, getSection(tag))\n                ])\n              );\n            }\n          }\n        }\n      }\n      let visitAccessor;\n      if (nodeRef2) {\n        visitAccessor = getScopeAccessorLiteral(nodeRef2);\n        visit(tag, 32 /* Get */);\n      }\n      write2`<${name.node}`;\n      const usedAttrs = getUsedAttrs(tagName, tag.node);\n      const { staticAttrs, staticControllable, skipExpression } = usedAttrs;\n      let { spreadExpression } = usedAttrs;\n      if (staticControllable) {\n        const { helper, attrs: attrs2 } = staticControllable;\n        const changeAttr = attrs2[1];\n        const firstAttr = attrs2.find(Boolean);\n        const referencedBindings = firstAttr.value.extra?.referencedBindings;\n        if (changeAttr) {\n          tag.get(\"attributes\").find((it) => it.node === changeAttr).traverse(HoistVisitors);\n        }\n        const values = attrs2.map((attr2) => attr2?.value);\n        if (isHTML) {\n          if (tagName !== \"select\" && tagName !== \"textarea\") {\n            write2`${callRuntime(helper, getScopeIdIdentifier(section), visitAccessor, ...values)}`;\n          }\n          addHTMLEffectCall(section, void 0);\n        } else {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            import_compiler25.types.expressionStatement(\n              callRuntime(helper, scopeIdentifier, visitAccessor, ...values)\n            )\n          );\n          addStatement(\n            \"effect\",\n            section,\n            void 0,\n            import_compiler25.types.expressionStatement(\n              callRuntime(`${helper}_effect`, scopeIdentifier, visitAccessor)\n            )\n          );\n        }\n      }\n      let writeAtStartOfBody;\n      if (isHTML) {\n        if (tagName === \"select\") {\n          if (staticControllable) {\n            htmlSelectArgs.set(tag.node, {\n              value: staticControllable.attrs[0]?.value || buildUndefined(),\n              valueChange: staticControllable.attrs[1]?.value || buildUndefined()\n            });\n          } else if (spreadExpression) {\n            const spreadIdentifier = tag.scope.generateUidIdentifier(\"select_input\");\n            tag.insertBefore(\n              import_compiler25.types.variableDeclaration(\"const\", [\n                import_compiler25.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            htmlSelectArgs.set(tag.node, {\n              value: import_compiler25.types.memberExpression(\n                spreadIdentifier,\n                import_compiler25.types.identifier(\"value\")\n              ),\n              valueChange: import_compiler25.types.memberExpression(\n                spreadIdentifier,\n                import_compiler25.types.identifier(\"valueChange\")\n              )\n            });\n            spreadExpression = spreadIdentifier;\n          }\n        } else if (tagName === \"textarea\") {\n          let value;\n          let valueChange;\n          if (staticControllable) {\n            value = staticControllable.attrs[0]?.value;\n            valueChange = staticControllable.attrs[1]?.value;\n          } else if (spreadExpression) {\n            const spreadIdentifier = tag.scope.generateUidIdentifier(\"textarea_input\");\n            tag.insertBefore(\n              import_compiler25.types.variableDeclaration(\"const\", [\n                import_compiler25.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            value = import_compiler25.types.memberExpression(spreadIdentifier, import_compiler25.types.identifier(\"value\"));\n            valueChange = import_compiler25.types.memberExpression(\n              spreadIdentifier,\n              import_compiler25.types.identifier(\"valueChange\")\n            );\n            spreadExpression = spreadIdentifier;\n          }\n          if (value || valueChange) {\n            writeAtStartOfBody = callRuntime(\n              \"controllable_textarea_value\",\n              getScopeIdIdentifier(getSection(tag)),\n              getScopeAccessorLiteral(nodeRef2),\n              value,\n              valueChange\n            );\n          }\n        }\n      }\n      for (const attr2 of staticAttrs) {\n        const { name: name2, value } = attr2;\n        const { confident, computed } = attr2.extra ?? {};\n        const valueReferences = value.extra?.referencedBindings;\n        if (isHTML && tagName === \"option\" && name2 === \"value\") {\n          write2`${callRuntime(\"optionValueAttr\", value)}`;\n          continue;\n        }\n        switch (name2) {\n          case \"class\":\n          case \"style\": {\n            const helper = `${name2}Attr`;\n            if (confident) {\n              write2`${getHTMLRuntime()[helper](computed)}`;\n            } else if (isHTML) {\n              write2`${callRuntime(helper, value)}`;\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler25.types.expressionStatement(\n                  callRuntime(\n                    helper,\n                    import_compiler25.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n          }\n          default:\n            if (confident) {\n              write2`${getHTMLRuntime().attr(name2, computed)}`;\n            } else if (isHTML) {\n              if (isEventHandler(name2)) {\n                addHTMLEffectCall(section, valueReferences);\n              } else {\n                write2`${callRuntime(\"attr\", import_compiler25.types.stringLiteral(name2), value)}`;\n              }\n            } else if (isEventHandler(name2)) {\n              addStatement(\n                \"effect\",\n                section,\n                valueReferences,\n                import_compiler25.types.expressionStatement(\n                  callRuntime(\n                    \"on\",\n                    import_compiler25.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler25.types.stringLiteral(getEventHandlerName(name2)),\n                    value\n                  )\n                ),\n                value\n              );\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler25.types.expressionStatement(\n                  callRuntime(\n                    \"attr\",\n                    import_compiler25.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler25.types.stringLiteral(name2),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n        }\n      }\n      if (spreadExpression) {\n        if (isHTML) {\n          addHTMLEffectCall(section, extra.referencedBindings);\n          if (skipExpression) {\n            write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(section), name.node)}`;\n          } else {\n            write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(section), name.node)}`;\n          }\n        } else {\n          if (skipExpression) {\n            addStatement(\n              \"render\",\n              section,\n              extra.referencedBindings,\n              import_compiler25.types.expressionStatement(\n                callRuntime(\n                  \"partialAttrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression,\n                  skipExpression\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              extra.referencedBindings,\n              import_compiler25.types.expressionStatement(\n                callRuntime(\n                  \"attrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression\n                )\n              )\n            );\n          }\n          addStatement(\n            \"effect\",\n            section,\n            extra.referencedBindings,\n            import_compiler25.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            spreadExpression\n          );\n        }\n      }\n      if (tagDef && tagDef.parseOptions?.openTagOnly) {\n        switch (tagDef.htmlType) {\n          case \"svg\":\n          case \"math\":\n            write2`/>`;\n            break;\n          default:\n            write2`>`;\n            break;\n        }\n      } else {\n        write2`>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(import_compiler25.types.ifStatement(name.node, consumeHTML(tag)))[0].skip();\n      }\n      if (writeAtStartOfBody) {\n        write2`${writeAtStartOfBody}`;\n      }\n      enter(tag);\n    },\n    exit(tag) {\n      const extra = tag.node.extra;\n      const nodeRef2 = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const openTagOnly = (0, import_babel_utils15.getTagDef)(tag)?.parseOptions?.openTagOnly;\n      const selectArgs = isHTML && htmlSelectArgs.get(tag.node);\n      if (isHTML && extra.tagNameNullable) {\n        flushInto(tag);\n      }\n      if (selectArgs) {\n        writeTo(tag)`</${tag.node.name}>`;\n        flushInto(tag);\n        tag.insertBefore(\n          import_compiler25.types.expressionStatement(\n            callRuntime(\n              \"controllable_select_value\",\n              getScopeIdIdentifier(getSection(tag)),\n              getScopeAccessorLiteral(nodeRef2),\n              selectArgs.value,\n              selectArgs.valueChange,\n              import_compiler25.types.arrowFunctionExpression(\n                [],\n                import_compiler25.types.blockStatement(tag.node.body.body)\n              )\n            )\n          )\n        );\n      } else {\n        tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n      }\n      if (!openTagOnly && !selectArgs) {\n        writeTo(tag)`</${tag.node.name}>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(\n          import_compiler25.types.ifStatement(tag.node.name, consumeHTML(tag))\n        )[0].skip();\n      }\n      if (nodeRef2 && (extra[kSerializeMarker] || tag.node.attributes.some(\n        (attr2) => isStatefulReferences(attr2.value.extra?.referencedBindings)\n      ))) {\n        markNode(tag, nodeRef2);\n      }\n      exit(tag);\n      tag.remove();\n    }\n  }\n};\nfunction getUsedAttrs(tagName, tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  let staticControllable;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler25.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n        staticControllable = getRelatedControllable(tagName, seen);\n        if (staticControllable && !staticControllable.attrs.every(Boolean)) {\n          for (const attr3 of staticControllable.attrs) {\n            if (attr3) {\n              spreadProps.push(attrToObjectProperty(attr3));\n              maybeStaticAttrs.delete(attr3);\n            }\n          }\n          staticControllable = void 0;\n        }\n      }\n      spreadProps.push(import_compiler25.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(attrToObjectProperty(attr2));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  if (!spreadProps) {\n    staticControllable = getRelatedControllable(tagName, seen);\n    if (staticControllable?.special === false && !staticControllable.attrs[1]) {\n      staticControllable = void 0;\n    }\n  }\n  if (staticControllable) {\n    for (const attr2 of staticControllable.attrs) {\n      if (attr2) {\n        maybeStaticAttrs.delete(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    if (staticControllable) {\n      for (const attr2 of staticControllable.attrs) {\n        if (attr2) {\n          (skipProps ||= []).push(\n            import_compiler25.types.objectProperty(toPropertyName(attr2.name), import_compiler25.types.numericLiteral(1))\n          );\n        }\n      }\n    }\n    for (const { name } of staticAttrs) {\n      (skipProps ||= []).push(\n        import_compiler25.types.objectProperty(toPropertyName(name), import_compiler25.types.numericLiteral(1))\n      );\n    }\n    if (skipProps) {\n      skipExpression = import_compiler25.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    staticControllable,\n    spreadExpression,\n    skipExpression\n  };\n}\nfunction isEventHandler(propName) {\n  return /^on[A-Z-]/.test(propName);\n}\nfunction isChangeHandler(propName) {\n  return /^(?:value|checked(?:Values?)?|open)Change/.test(propName);\n}\nfunction getEventHandlerName(propName) {\n  return propName.charAt(2) === \"-\" ? propName.slice(3) : propName.charAt(2).toLowerCase() + propName.slice(3);\n}\nfunction attrToObjectProperty(attr2) {\n  return import_compiler25.types.objectProperty(toPropertyName(attr2.name), attr2.value);\n}\nvar HoistVisitors = {\n  Function: function_default.translate,\n  UpdateExpression: update_expression_default.translate,\n  AssignmentExpression: assignment_expression_default.translate\n};\nfunction buildUndefined() {\n  return import_compiler25.types.unaryExpression(\"void\", import_compiler25.types.numericLiteral(0));\n}\n\n// src/core/for.ts\nvar kForMarkerBinding = Symbol(\"for marker binding\");\nvar kForScopeStartIndex = Symbol(\"for scope start index\");\nvar kOnlyChildInParent = Symbol(\"only child in parent\");\nvar for_default = {\n  analyze(tag) {\n    const tagExtra = tag.node.extra ??= {};\n    const isAttrTag = !!tag.node.attributeTags.length;\n    let allowAttrs;\n    (0, import_babel_utils16.assertNoVar)(tag);\n    (0, import_babel_utils16.assertNoArgs)(tag);\n    assertNoSpreadAttrs(tag);\n    switch (getForType(tag.node)) {\n      case \"of\":\n        allowAttrs = [\"of\"];\n        break;\n      case \"in\":\n        allowAttrs = [\"in\"];\n        break;\n      case \"to\":\n        allowAttrs = [\"to\", \"from\", \"step\"];\n        break;\n      default:\n        throw tag.buildCodeFrameError(\n          \"Invalid `for` tag, missing an `of=`, `in=`, `to=` attribute.\"\n        );\n    }\n    if (!isAttrTag) {\n      allowAttrs.push(\"by\");\n    }\n    (0, import_babel_utils16.assertAllowedAttributes)(tag, allowAttrs);\n    if (isAttrTag) return;\n    const tagBody = tag.get(\"body\");\n    const bodySection = startSection(tagBody);\n    if (!bodySection) {\n      dropReferences(getAllTagReferenceNodes(tag.node));\n      return;\n    }\n    const section = getOrCreateSection(tag);\n    if (isOnlyChildInParent(tag)) {\n      const parentTag = tag.parentPath.parent;\n      const parentTagName = parentTag.name?.value;\n      (parentTag.extra ??= {})[kNativeTagBinding] ??= createBinding(\n        \"#\" + parentTagName,\n        0 /* dom */,\n        section\n      );\n    } else {\n      tagExtra[kForMarkerBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section\n      );\n    }\n    trackParamsReferences(tagBody, 3 /* param */, void 0, tagExtra);\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n    bodySection.upstreamExpression = tagExtra;\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.attributeTags.length) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        const tagExtra = tag.node.extra;\n        const isStateful = isStatefulReferences(tagExtra.referencedBindings);\n        setSectionParentIsOwner(bodySection, true);\n        if (!isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n        flushBefore(tag);\n        if (isStateful && !bodySection.content?.singleChild) {\n          tagExtra[kForScopeStartIndex] = tag.scope.generateUidIdentifier(\"k\");\n          writeTo(tagBody)`${callRuntime(\n            \"markResumeScopeStart\",\n            getScopeIdIdentifier(bodySection),\n            import_compiler26.types.updateExpression(\"++\", tagExtra[kForScopeStartIndex])\n          )}`;\n        }\n      },\n      exit(tag) {\n        if (tag.node.attributeTags.length) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const isStateful = isStatefulReferences(tagExtra.referencedBindings);\n        const nodeRef2 = isOnlyChildInParent(tag) ? tag.parentPath.parent.extra[kNativeTagBinding] : tag.node.extra[kForMarkerBinding];\n        const forAttrs = getKnownAttrValues(node);\n        const forType = getForType(node);\n        const params = node.body.params;\n        const statements = [];\n        const bodyStatements = node.body.body;\n        const hasStatefulClosures = checkStatefulClosures(bodySection, true);\n        let keyExpression;\n        if (isStateful && isOnlyChildInParent(tag)) {\n          tag.parentPath.parent.extra[kSerializeMarker] = true;\n        }\n        if (tagExtra[kForScopeStartIndex]) {\n          statements.push(\n            import_compiler26.types.variableDeclaration(\"let\", [\n              import_compiler26.types.variableDeclarator(\n                tagExtra[kForScopeStartIndex],\n                import_compiler26.types.numericLiteral(0)\n              )\n            ])\n          );\n        }\n        if (isStateful || hasStatefulClosures) {\n          const singleNodeOptimization = bodySection.content === null || bodySection.content.singleChild;\n          const defaultParamNames = {\n            of: [\"list\", \"index\"],\n            in: [\"key\", \"value\"],\n            to: [\"value\"]\n          }[forType];\n          const defaultByParamIndex = forType === \"of\" ? 1 : 0;\n          const requiredParamsIndex = forAttrs.by ? defaultParamNames.length - 1 : defaultByParamIndex;\n          setForceResumeScope(bodySection);\n          for (let i = 0; i <= requiredParamsIndex; i++) {\n            const existingParam = params[i];\n            if (!existingParam || !import_compiler26.types.isIdentifier(existingParam)) {\n              const id = params[i] = currentProgramPath.scope.generateUidIdentifier(\n                defaultParamNames[i]\n              );\n              if (existingParam) {\n                bodyStatements.unshift(\n                  import_compiler26.types.variableDeclaration(\"let\", [\n                    import_compiler26.types.variableDeclarator(existingParam, id)\n                  ])\n                );\n              }\n            }\n          }\n          if (forAttrs.by) {\n            const byIdentifier = currentProgramPath.scope.generateUidIdentifier(\"by\");\n            statements.push(\n              import_compiler26.types.variableDeclaration(\"const\", [\n                import_compiler26.types.variableDeclarator(byIdentifier, forAttrs.by)\n              ])\n            );\n            keyExpression = import_compiler26.types.callExpression(\n              byIdentifier,\n              params\n            );\n          } else {\n            keyExpression = params[defaultByParamIndex];\n          }\n          const write2 = writeTo(tag);\n          const forScopeIdsIdentifier = tag.scope.generateUidIdentifier(\"forScopeIds\");\n          const forScopesIdentifier = getScopeIdentifier(bodySection);\n          statements.push(\n            import_compiler26.types.variableDeclaration(\n              \"const\",\n              [\n                isStateful && singleNodeOptimization && import_compiler26.types.variableDeclarator(\n                  forScopeIdsIdentifier,\n                  import_compiler26.types.arrayExpression([])\n                ),\n                import_compiler26.types.variableDeclarator(\n                  forScopesIdentifier,\n                  import_compiler26.types.newExpression(import_compiler26.types.identifier(\"Map\"), [])\n                )\n              ].filter(Boolean)\n            )\n          );\n          if (isStateful) {\n            if (singleNodeOptimization) {\n              bodyStatements.push(\n                import_compiler26.types.expressionStatement(\n                  import_compiler26.types.callExpression(\n                    import_compiler26.types.memberExpression(\n                      forScopeIdsIdentifier,\n                      import_compiler26.types.identifier(\"push\")\n                    ),\n                    [getScopeIdIdentifier(bodySection)]\n                  )\n                )\n              );\n              write2`${callRuntime(\n                \"markResumeControlSingleNodeEnd\",\n                getScopeIdIdentifier(tagSection),\n                getScopeAccessorLiteral(nodeRef2),\n                forScopeIdsIdentifier\n              )}`;\n            } else {\n              write2`${callRuntime(\n                \"markResumeControlEnd\",\n                getScopeIdIdentifier(tagSection),\n                getScopeAccessorLiteral(nodeRef2)\n              )}`;\n            }\n          }\n          getSerializedScopeProperties(tagSection).set(\n            import_compiler26.types.stringLiteral(\n              getScopeAccessorLiteral(nodeRef2).value + \"(\" /* LoopScopeMap */\n            ),\n            import_compiler26.types.conditionalExpression(\n              import_compiler26.types.memberExpression(forScopesIdentifier, import_compiler26.types.identifier(\"size\")),\n              forScopesIdentifier,\n              import_compiler26.types.identifier(\"undefined\")\n            )\n          );\n        }\n        flushInto(tag);\n        setSubscriberBuilder(tag, () => {\n        });\n        writeHTMLResumeStatements(tagBody);\n        if (keyExpression && (isStateful || hasStatefulClosures)) {\n          bodyStatements.push(\n            import_compiler26.types.expressionStatement(\n              import_compiler26.types.callExpression(\n                import_compiler26.types.memberExpression(\n                  getScopeIdentifier(bodySection),\n                  import_compiler26.types.identifier(\"set\")\n                ),\n                [\n                  keyExpression,\n                  callRuntime(\n                    \"getScopeById\",\n                    getScopeIdIdentifier(bodySection)\n                  )\n                ]\n              )\n            )\n          );\n        }\n        statements.push(\n          buildForRuntimeCall(forType, forAttrs, params, bodyStatements)\n        );\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.attributeTags.length) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        if (!isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n      },\n      exit(tag) {\n        if (tag.node.attributeTags.length) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const { referencedBindings } = tagExtra;\n        const nodeRef2 = isOnlyChildInParent(tag) ? tag.parentPath.parent.extra[kNativeTagBinding] : tag.node.extra[kForMarkerBinding];\n        setSubscriberBuilder(tag, (signal2) => {\n          return callRuntime(\n            \"inLoopScope\",\n            signal2,\n            getScopeAccessorLiteral(nodeRef2)\n          );\n        });\n        const forType = getForType(node);\n        const signal = getSignal(tagSection, nodeRef2, \"for\");\n        signal.build = () => {\n          return callRuntime(\n            forTypeToDOMRuntime(forType),\n            getScopeAccessorLiteral(nodeRef2),\n            import_compiler26.types.identifier(bodySection.name)\n          );\n        };\n        const params = node.body.params;\n        signal.hasDownstreamIntersections = () => {\n          if (bodySection.closures) {\n            return true;\n          }\n          for (const param of params) {\n            const binding = param.extra?.binding;\n            if (binding) {\n              for (const {\n                referencedBindings: referencedBindings2\n              } of binding.downstreamExpressions) {\n                if (getSignal(\n                  bodySection,\n                  referencedBindings2\n                ).hasDownstreamIntersections()) {\n                  return true;\n                }\n              }\n            }\n          }\n          return false;\n        };\n        const forAttrs = getKnownAttrValues(node);\n        const loopArgs = getBaseArgsInForTag(forType, forAttrs);\n        if (forAttrs.by) {\n          loopArgs.push(forAttrs.by);\n        }\n        addValue(\n          tagSection,\n          referencedBindings,\n          signal,\n          import_compiler26.types.arrayExpression(loopArgs)\n        );\n        tag.remove();\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  attributes: {\n    of: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over a list of items.\"\n        }\n      ]\n    },\n    in: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over the keys and values of an object.\"\n        }\n      ]\n    },\n    to: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates up to the provided number (inclusive)\"\n        }\n      ]\n    },\n    from: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates starting from the provided number (inclusive)\"\n        }\n      ]\n    },\n    step: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"The amount to increment during each interation (with from/to)\"\n        }\n      ]\n    }\n  },\n  autocomplete: [\n    {\n      snippet: \"for|${1:value, index}| of=${3:array}\",\n      description: \"Use to iterate over lists, object properties, or between ranges.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-a-list\"\n    },\n    {\n      snippet: \"for|${1:name, value}| in=${3:object}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties\"\n    },\n    {\n      snippet: \"for|${1:index}| to=${2:number}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers\"\n    }\n  ]\n};\nfunction buildForRuntimeCall(type, attrs2, params, statements) {\n  return import_compiler26.types.expressionStatement(\n    callRuntime(\n      forTypeToRuntime(type),\n      ...getBaseArgsInForTag(type, attrs2),\n      import_compiler26.types.arrowFunctionExpression(params, import_compiler26.types.blockStatement(statements))\n    )\n  );\n}\nfunction getForType(tag) {\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      switch (attr2.name) {\n        case \"of\":\n        case \"in\":\n        case \"to\":\n          return attr2.name;\n      }\n    }\n  }\n}\nfunction forTypeToRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"forOf\";\n    case \"in\":\n      return \"forIn\";\n    case \"to\":\n      return \"forTo\";\n  }\n}\nfunction forTypeToDOMRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"loopOf\";\n    case \"in\":\n      return \"loopIn\";\n    case \"to\":\n      return \"loopTo\";\n  }\n}\nfunction getBaseArgsInForTag(type, attrs2) {\n  switch (type) {\n    case \"in\":\n      return [attrs2.in];\n    case \"of\":\n      return [attrs2.of];\n    case \"to\":\n      return [\n        attrs2.to,\n        attrs2.from || import_compiler26.types.numericLiteral(0),\n        attrs2.step || import_compiler26.types.numericLiteral(1)\n      ];\n  }\n}\nfunction isOnlyChildInParent(tag) {\n  const extra = tag.node.extra;\n  if (extra[kOnlyChildInParent] !== void 0) {\n    return extra[kOnlyChildInParent];\n  }\n  if (import_compiler26.types.isMarkoTag(tag.parentPath?.parent) && (0, import_babel_utils16.getTagDef)(tag.parentPath.parentPath)?.html) {\n    return extra[kOnlyChildInParent] = tag.parent.body.length === 1;\n  }\n  return extra[kOnlyChildInParent] = false;\n}\n\n// src/util/nested-attribute-tags.ts\nvar import_babel_utils17 = require(\"@marko/babel-utils\");\nvar import_compiler27 = require(\"@marko/compiler\");\nvar attrTagToIdentifierLookup = /* @__PURE__ */ new WeakMap();\nfunction getAttrTagIdentifier(meta) {\n  let name = attrTagToIdentifierLookup.get(meta);\n  if (!name) {\n    name = currentProgramPath.scope.generateUid(meta.name);\n    attrTagToIdentifierLookup.set(meta, name);\n  }\n  return import_compiler27.types.identifier(name);\n}\nfunction analyzeAttributeTags(tag) {\n  if (tag.node.extra?.attributeTags) return tag.node.extra.attributeTags;\n  if (!tag.node.attributeTags.length) return;\n  const tagExtra = tag.node.extra ??= {};\n  const lookup = tagExtra.attributeTags = {};\n  const attrTagNodesByName = {};\n  const sampleAttrTagsForControlFlow = /* @__PURE__ */ new Map();\n  for (const child of tag.get(\"attributeTags\")) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils17.isAttributeTag)(child)) {\n        const name = getTagName(child);\n        lookup[name] ||= createAttrTagMeta(name, [name]);\n        analyzeAttributeTags(child);\n      } else {\n        const isRepeated = (0, import_babel_utils17.isLoopTag)(child);\n        let curGroup;\n        for (const name of crawlAttrTags(child, attrTagNodesByName)) {\n          const oldMeta = lookup[name];\n          if (oldMeta) {\n            if (!curGroup) {\n              curGroup = oldMeta.group;\n            } else if (curGroup !== oldMeta.group) {\n              for (const name2 of oldMeta.group) {\n                lookup[name2].group = curGroup;\n                curGroup.push(name2);\n              }\n            }\n          }\n          let attrTagMeta = lookup[name];\n          if (!attrTagMeta) {\n            attrTagMeta = lookup[name] = createAttrTagMeta(name, []);\n            curGroup = attrTagMeta.group;\n            curGroup.push(name);\n          }\n          attrTagMeta.dynamic = true;\n          if (isRepeated) {\n            attrTagMeta.repeated = true;\n          }\n          sampleAttrTagsForControlFlow.set(child, name);\n        }\n      }\n    }\n  }\n  for (const [controlFlowTag, sampleAttrName] of sampleAttrTagsForControlFlow) {\n    (controlFlowTag.node.extra ??= {}).attributeTagGroup = lookup[sampleAttrName].group;\n  }\n  for (const name in attrTagNodesByName) {\n    const attrTagMeta = lookup[name];\n    if (!attrTagMeta.repeated) {\n      const attrTagNodes = attrTagNodesByName[name];\n      if (attrTagNodes.length > 1) {\n        attrTagMeta.repeated = !attrTagMeta.dynamic || hasRepeatedDynamicAttrTags(attrTagNodes);\n      }\n    }\n  }\n  return lookup;\n}\nfunction createAttrTagMeta(name, group) {\n  return {\n    name: name.slice(1),\n    dynamic: false,\n    repeated: false,\n    group\n  };\n}\nfunction crawlAttrTags(tag, attrTagNodesByName, attrTagNames = /* @__PURE__ */ new Set()) {\n  for (const child of tag.get(\"attributeTags\")) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils17.isAttributeTag)(child)) {\n        const tagName = getTagName(child);\n        attrTagNames.add(tagName);\n        (attrTagNodesByName[tagName] ||= []).push(child);\n        analyzeAttributeTags(child);\n      } else {\n        crawlAttrTags(child, attrTagNodesByName, attrTagNames);\n      }\n    }\n  }\n  return attrTagNames;\n}\nfunction hasRepeatedDynamicAttrTags(attrTags2) {\n  let conditionRoot;\n  const seenBranches = /* @__PURE__ */ new Set();\n  for (const attrTag2 of attrTags2) {\n    const parentTag = attrTag2.parentPath;\n    if (seenBranches.has(parentTag) || !isConditionTag(parentTag)) {\n      return true;\n    }\n    const curConditionRoot = getConditionRoot(parentTag);\n    if (curConditionRoot && curConditionRoot !== (conditionRoot ||= curConditionRoot)) {\n      return true;\n    }\n    seenBranches.add(parentTag);\n  }\n  return false;\n}\nfunction getConditionRoot(tag) {\n  if (getTagName(tag) === \"if\") return tag;\n  let prev = tag.getPrevSibling();\n  while (prev.node) {\n    if (prev.isMarkoTag() && getTagName(prev) === \"if\") {\n      return prev;\n    }\n    prev = prev.getPrevSibling();\n  }\n}\n\n// src/util/translate-attrs.ts\nvar renderBodyProps = /* @__PURE__ */ new WeakSet();\nfunction translateAttrs(tag, templateExports, statements = []) {\n  const seen = /* @__PURE__ */ new Set();\n  const properties = [];\n  const attrTagLookup = tag.node.extra?.attributeTags;\n  if (attrTagLookup) {\n    for (const name in attrTagLookup) {\n      const attrTagMeta = attrTagLookup[name];\n      if (usesExport(templateExports, attrTagMeta.name)) {\n        seen.add(attrTagMeta.name);\n        if (attrTagMeta.dynamic) {\n          statements.push(\n            import_compiler28.types.variableDeclaration(\"let\", [\n              import_compiler28.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta))\n            ])\n          );\n          properties.push(\n            import_compiler28.types.objectProperty(\n              toPropertyName(attrTagMeta.name),\n              getAttrTagIdentifier(attrTagMeta)\n            )\n          );\n        }\n      }\n    }\n    const attrTags2 = tag.get(\"attributeTags\");\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils18.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          if (attrTagMeta.dynamic) {\n            i = addDynamicAttrTagStatements(\n              attrTags2,\n              i,\n              attrTagLookup,\n              statements,\n              templateExports\n            );\n          } else {\n            const translatedAttrTag = translateAttrs(\n              child,\n              templateExports?.[attrTagMeta.name]?.props,\n              statements\n            );\n            if (attrTagMeta.repeated) {\n              const prevProp = findObjectProperty(attrTagMeta.name, properties);\n              if (prevProp) {\n                prevProp.value = callRuntime(\n                  \"attrTags\",\n                  prevProp.value,\n                  propsToExpression(translatedAttrTag.properties)\n                );\n              } else {\n                properties.push(\n                  import_compiler28.types.objectProperty(\n                    toPropertyName(attrTagMeta.name),\n                    callRuntime(\n                      \"attrTag\",\n                      propsToExpression(translatedAttrTag.properties)\n                    )\n                  )\n                );\n              }\n            } else {\n              properties.push(\n                import_compiler28.types.objectProperty(\n                  toPropertyName(attrTagMeta.name),\n                  callRuntime(\n                    \"attrTag\",\n                    propsToExpression(translatedAttrTag.properties)\n                  )\n                )\n              );\n            }\n          }\n        } else {\n          i = addDynamicAttrTagStatements(\n            attrTags2,\n            i,\n            attrTagLookup,\n            statements,\n            templateExports\n          );\n        }\n      }\n    }\n  }\n  if (!seen.has(\"renderBody\") && usesExport(templateExports, \"renderBody\")) {\n    seen.add(\"renderBody\");\n    const renderBodyExpression = buildRenderBody(tag.get(\"body\"));\n    if (renderBodyExpression) {\n      const renderBodyProp = import_compiler28.types.objectProperty(\n        import_compiler28.types.identifier(\"renderBody\"),\n        renderBodyExpression\n      );\n      renderBodyProps.add(renderBodyProp);\n      properties.push(renderBodyProp);\n    }\n  }\n  const { attributes } = tag.node;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler28.types.isMarkoSpreadAttribute(attr2)) {\n      properties.push(import_compiler28.types.spreadElement(value));\n    } else if (!seen.has(attr2.name) && usesExport(templateExports, attr2.name)) {\n      seen.add(attr2.name);\n      properties.push(import_compiler28.types.objectProperty(toPropertyName(attr2.name), value));\n    }\n  }\n  properties.reverse();\n  return { properties, statements };\n}\nfunction getTranslatedRenderBodyProperty(props) {\n  for (const prop of props) {\n    if (renderBodyProps.has(prop)) {\n      return prop;\n    }\n  }\n}\nfunction addDynamicAttrTagStatements(attrTags2, index, attrTagLookup, statements, templateExports) {\n  const tag = attrTags2[index];\n  if (tag.isMarkoTag()) {\n    if ((0, import_babel_utils18.isAttributeTag)(tag)) {\n      const attrTagMeta = attrTagLookup[getTagName(tag)];\n      if (usesExport(templateExports, attrTagMeta.name) && attrTagMeta.dynamic) {\n        const translatedAttrTag = translateAttrs(\n          tag,\n          templateExports?.[attrTagMeta.name]?.props,\n          statements\n        );\n        if (attrTagMeta.repeated) {\n          statements.push(\n            import_compiler28.types.expressionStatement(\n              import_compiler28.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTags\",\n                  getAttrTagIdentifier(attrTagMeta),\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        } else {\n          statements.push(\n            import_compiler28.types.expressionStatement(\n              import_compiler28.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTag\",\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        }\n      }\n    } else {\n      switch (getTagName(tag)) {\n        case \"if\":\n          return translateIfAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports\n          );\n        case \"for\": {\n          return translateForAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports\n          );\n        }\n      }\n    }\n  }\n  return index;\n}\nfunction propsToExpression(props) {\n  return props.length === 1 && import_compiler28.types.isSpreadElement(props[0]) ? props[0].argument : import_compiler28.types.objectExpression(props);\n}\nfunction translateForAttrTag(attrTags2, index, attrTagLookup, statements, templateExports) {\n  const forTag = attrTags2[index];\n  const bodyStatements = [];\n  addAllAttrTagsAsDynamic(\n    forTag,\n    attrTagLookup,\n    bodyStatements,\n    templateExports\n  );\n  statements.push(\n    buildForRuntimeCall(\n      getForType(forTag.node),\n      getKnownAttrValues(forTag.node),\n      forTag.node.body.params,\n      bodyStatements\n    )\n  );\n  return index;\n}\nfunction translateIfAttrTag(attrTags2, index, attrTagLookup, statements, templateExports) {\n  const ifTag = attrTags2[index];\n  const consequentStatements = [];\n  let ifStatement = import_compiler28.types.ifStatement(\n    getConditionTestValue(ifTag),\n    import_compiler28.types.blockStatement(consequentStatements)\n  );\n  statements.push(ifStatement);\n  addAllAttrTagsAsDynamic(\n    ifTag,\n    attrTagLookup,\n    consequentStatements,\n    templateExports\n  );\n  let nextIndex = index + 1;\n  while (nextIndex < attrTags2.length) {\n    const nextTag = attrTags2[nextIndex];\n    if (nextTag.isMarkoTag()) {\n      switch (getTagName(nextTag)) {\n        case \"else-if\":\n        case \"else\": {\n          const testValue = getConditionTestValue(nextTag);\n          const alternateStatements = [];\n          addAllAttrTagsAsDynamic(\n            nextTag,\n            attrTagLookup,\n            alternateStatements,\n            templateExports\n          );\n          if (testValue) {\n            ifStatement.alternate = ifStatement = import_compiler28.types.ifStatement(\n              testValue,\n              import_compiler28.types.blockStatement(alternateStatements)\n            );\n            nextIndex++;\n            continue;\n          } else {\n            ifStatement.alternate = import_compiler28.types.blockStatement(alternateStatements);\n            break;\n          }\n        }\n      }\n    }\n    break;\n  }\n  return nextIndex - 1;\n}\nfunction addAllAttrTagsAsDynamic(tag, attrTagLookup, statements, templateExports) {\n  const attrTags2 = tag.get(\"attributeTags\");\n  for (let i = 0; i < attrTags2.length; i++) {\n    i = addDynamicAttrTagStatements(\n      attrTags2,\n      i,\n      attrTagLookup,\n      statements,\n      templateExports\n    );\n  }\n}\nfunction usesExport(templateExports, name) {\n  return !templateExports || !!templateExports[name];\n}\nfunction findObjectProperty(name, props) {\n  for (const prop of props) {\n    if (prop.type === \"ObjectProperty\") {\n      switch (prop.key.type) {\n        case \"StringLiteral\":\n          if (prop.key.value === name) {\n            return prop;\n          }\n          break;\n        case \"Identifier\":\n          if (prop.key.name === name) {\n            return prop;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\nfunction getConditionTestValue({\n  node: { attributes }\n}) {\n  return attributes.length === 1 ? attributes[0].value : void 0;\n}\nfunction buildRenderBody(body) {\n  const bodySection = body.node.extra?.section;\n  if (bodySection) {\n    if (isOutputHTML()) {\n      return callRuntime(\n        \"register\",\n        callRuntime(\n          \"createRenderer\",\n          import_compiler28.types.arrowFunctionExpression(\n            body.node.params,\n            import_compiler28.types.blockStatement(body.node.body)\n          )\n        ),\n        import_compiler28.types.stringLiteral(getResumeRegisterId(bodySection, \"renderer\")),\n        getScopeIdIdentifier(\n          getSection(\n            getNonAttributeTagParent(body.parentPath)\n          )\n        )\n      );\n    } else {\n      return import_compiler28.types.callExpression(import_compiler28.types.identifier(bodySection.name), [\n        scopeIdentifier\n      ]);\n    }\n  }\n}\nfunction getNonAttributeTagParent(tag) {\n  let cur = tag;\n  while (cur.node && cur.listKey === \"attributeTags\") {\n    cur = cur.parentPath;\n  }\n  return cur;\n}\n\n// src/core/define.ts\nvar define_default = {\n  analyze(tag) {\n    (0, import_babel_utils19.assertNoArgs)(tag);\n    if (!tag.node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `define` tag requires a tag variable.\");\n    }\n    const tagBody = tag.get(\"body\");\n    startSection(tagBody);\n    trackVarReferences(tag, 4 /* derived */);\n    trackParamsReferences(tagBody, 3 /* param */);\n    mergeReferences(\n      getOrCreateSection(tag),\n      tag.node,\n      getAllTagReferenceNodes(tag.node)\n    );\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const translatedAttrs = translateAttrs(tag);\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        tag.insertBefore(translatedAttrs.statements);\n        translateVar(tag, propsToExpression(translatedAttrs.properties));\n      } else {\n        const section = getSection(tag);\n        const referencedBindings = node.extra?.referencedBindings;\n        const derivation = initValue(tag.get(\"var\").node.extra.binding);\n        if (translatedAttrs.statements.length) {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            translatedAttrs.statements\n          );\n        }\n        addValue(\n          section,\n          referencedBindings,\n          derivation,\n          propsToExpression(translatedAttrs.properties)\n        );\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a constant object binding that can be rendered.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#define\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/define.d.marko\"\n};\n\n// src/core/do.ts\nvar import_babel_utils20 = require(\"@marko/babel-utils\");\nvar import_compiler30 = require(\"@marko/compiler\");\nvar do_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils20.assertNoArgs)(tag);\n    (0, import_babel_utils20.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils20.assertNoVar)(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `do` tag requires a value.\");\n    }\n    if (tag.node.attributes.length > 1 || !import_compiler30.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `do` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      let statement = null;\n      if (import_compiler30.types.isFunctionExpression(value) || import_compiler30.types.isArrowFunctionExpression(value)) {\n        if (import_compiler30.types.isBlockStatement(value.body)) {\n          let hasDeclaration = false;\n          for (const child of value.body.body) {\n            if (import_compiler30.types.isDeclaration(child)) {\n              hasDeclaration = true;\n              break;\n            }\n          }\n          statement = hasDeclaration ? value.body : value.body.body;\n        } else {\n          statement = import_compiler30.types.expressionStatement(value.body);\n        }\n      }\n      if (isOutputHTML()) {\n        if (statement) {\n          tag.insertBefore(statement);\n        } else {\n          tag.insertBefore(import_compiler30.types.expressionStatement(import_compiler30.types.callExpression(value, [])));\n        }\n      } else {\n        addStatement(\n          \"render\",\n          section,\n          referencedBindings,\n          statement ?? import_compiler30.types.expressionStatement(import_compiler30.types.callExpression(value, [scopeIdentifier]))\n        );\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to run a function on render.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#do\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/do.d.marko\"\n};\n\n// src/core/effect.ts\nvar import_babel_utils21 = require(\"@marko/babel-utils\");\nvar import_compiler31 = require(\"@marko/compiler\");\nvar effect_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    (0, import_babel_utils21.assertNoArgs)(tag);\n    (0, import_babel_utils21.assertNoVar)(tag);\n    (0, import_babel_utils21.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `effect` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler31.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `effect` tag only supports the `value` attribute.\"\n      );\n    }\n    (valueAttr.value.extra ??= {}).isEffect = true;\n    (currentProgramPath.node.extra ??= {}).isInteractive = true;\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      const section = getSection(tag);\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      if (isOutputDOM()) {\n        const { value: value2 } = valueAttr;\n        let inlineBody = null;\n        if (import_compiler31.types.isFunctionExpression(value2) || import_compiler31.types.isArrowFunctionExpression(value2)) {\n          if (import_compiler31.types.isBlockStatement(value2.body)) {\n            let hasDeclaration = false;\n            for (const child of value2.body.body) {\n              if (import_compiler31.types.isDeclaration(child)) {\n                hasDeclaration = true;\n                break;\n              }\n            }\n            inlineBody = hasDeclaration ? value2.body : value2.body.body;\n          } else {\n            inlineBody = import_compiler31.types.expressionStatement(value2.body);\n          }\n        }\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          inlineBody || import_compiler31.types.expressionStatement(import_compiler31.types.callExpression(value2, [scopeIdentifier])),\n          value2,\n          !!inlineBody\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/effect.d.marko\"\n};\n\n// src/core/export.ts\nvar import_babel_utils22 = require(\"@marko/babel-utils\");\nvar export_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils22.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"export <value>\"\n    }\n  ]\n};\n\n// src/core/html-comment.ts\nvar import_babel_utils23 = require(\"@marko/babel-utils\");\nvar import_compiler32 = require(\"@marko/compiler\");\nvar kCommentTagBinding = Symbol(\"comment tag binding\");\nvar kGetterId2 = Symbol(\"node getter id\");\nvar html_comment_default = {\n  analyze(tag) {\n    (0, import_babel_utils23.assertNoArgs)(tag);\n    (0, import_babel_utils23.assertNoParams)(tag);\n    (0, import_babel_utils23.assertNoAttributes)(tag);\n    const tagVar = tag.node.var;\n    let needsBinding = false;\n    let needsGetter = false;\n    if (tagVar) {\n      if (!import_compiler32.types.isIdentifier(tagVar)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"The `html-comment` tag variable cannot be destructured.\"\n        );\n      }\n      needsBinding = true;\n      for (const ref of tag.scope.getBinding(tagVar.name).referencePaths) {\n        if (!ref.parentPath?.isCallExpression()) {\n          needsGetter = true;\n          break;\n        }\n      }\n    }\n    const referenceNodes = [];\n    for (const child of tag.get(\"body\").get(\"body\")) {\n      if (child.isMarkoPlaceholder()) {\n        referenceNodes.push(child.node.value);\n        needsBinding = true;\n      } else if (!child.isMarkoText()) {\n        throw child.buildCodeFrameError(\n          \"Invalid child. Only text is allowed inside an html comment.\"\n        );\n      }\n    }\n    if (needsBinding) {\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      if (needsGetter) {\n        tagExtra[kGetterId2] = getRegisterUID(section, \"comment\");\n      }\n      tagExtra[kCommentTagBinding] = createBinding(\n        \"#comment\",\n        0 /* dom */,\n        section\n      );\n      mergeReferences(section, tag.node, referenceNodes);\n    }\n    tag.skip();\n  },\n  translate(tag) {\n    const tagExtra = tag.node.extra;\n    const commentBinding = tagExtra[kCommentTagBinding];\n    const hasVar = !!tag.node.var;\n    if (hasVar) {\n      const getterId = tagExtra[kGetterId2];\n      if (isOutputHTML()) {\n        translateVar(\n          tag,\n          callRuntime(\n            \"nodeRef\",\n            getterId && getScopeIdIdentifier(getSection(tag)),\n            getterId && import_compiler32.types.stringLiteral(getterId)\n          )\n        );\n      } else {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        let getterFnIdentifier;\n        if (getterId) {\n          getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n            `get_${varName}`\n          );\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler32.types.variableDeclaration(\"const\", [\n              import_compiler32.types.variableDeclarator(\n                getterFnIdentifier,\n                callRuntime(\n                  \"nodeRef\",\n                  import_compiler32.types.stringLiteral(getterId),\n                  getScopeAccessorLiteral(commentBinding)\n                )\n              )\n            ])\n          );\n        }\n        for (const reference of references) {\n          const referenceSection = getSection(reference);\n          if (reference.parentPath?.isCallExpression()) {\n            reference.parentPath.replaceWith(\n              import_compiler32.types.expressionStatement(\n                createScopeReadExpression(referenceSection, commentBinding)\n              )\n            );\n          } else if (getterFnIdentifier) {\n            reference.replaceWith(\n              import_compiler32.types.callExpression(getterFnIdentifier, [\n                getScopeExpression(referenceSection, getSection(tag))\n              ])\n            );\n          }\n        }\n      }\n    }\n    if (tagExtra[kCommentTagBinding]) {\n      visit(tag, 32 /* Get */);\n    }\n    const write2 = writeTo(tag);\n    enter(tag);\n    write2`<!--`;\n    if (isOutputHTML()) {\n      for (const child of tag.node.body.body) {\n        if (import_compiler32.types.isMarkoText(child)) {\n          write2`${child.value}`;\n        } else if (import_compiler32.types.isMarkoPlaceholder(child)) {\n          write2`${callRuntime(\"escapeXML\", child.value)}`;\n        }\n      }\n    } else {\n      const templateQuasis = [];\n      const templateExpressions = [];\n      let currentQuasi = \"\";\n      for (const child of tag.node.body.body) {\n        if (import_compiler32.types.isMarkoText(child)) {\n          currentQuasi += child.value;\n        } else if (import_compiler32.types.isMarkoPlaceholder(child)) {\n          templateQuasis.push(import_compiler32.types.templateElement({ raw: currentQuasi }));\n          templateExpressions.push(child.value);\n          currentQuasi = \"\";\n        }\n      }\n      if (templateExpressions.length === 0) {\n        write2`${currentQuasi}`;\n      } else {\n        templateQuasis.push(import_compiler32.types.templateElement({ raw: currentQuasi }));\n        addStatement(\n          \"render\",\n          getSection(tag),\n          tagExtra.referencedBindings,\n          import_compiler32.types.expressionStatement(\n            callRuntime(\n              \"data\",\n              import_compiler32.types.memberExpression(\n                scopeIdentifier,\n                getScopeAccessorLiteral(commentBinding),\n                true\n              ),\n              import_compiler32.types.templateLiteral(templateQuasis, templateExpressions)\n            )\n          )\n        );\n      }\n    }\n    exit(tag);\n    write2`-->`;\n    if (commentBinding) {\n      markNode(tag, commentBinding);\n    }\n    tag.remove();\n  },\n  parseOptions: {\n    // TODO: fix the types for Tag or parseOptions or something\n    text: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an html comment that is not stripped from the output.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#html-comment\"\n    }\n  ]\n};\n\n// src/core/id.ts\nvar import_babel_utils24 = require(\"@marko/babel-utils\");\nvar import_compiler33 = require(\"@marko/compiler\");\nvar id_default = {\n  analyze(tag) {\n    (0, import_babel_utils24.assertNoArgs)(tag);\n    (0, import_babel_utils24.assertNoParams)(tag);\n    (0, import_babel_utils24.assertNoAttributes)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils24.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `id` tag requires a tag variable.\");\n    }\n    if (!import_compiler33.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `id` tag cannot be destructured\");\n    }\n    trackVarReferences(tag, 4 /* derived */);\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const id = isOutputHTML() ? callRuntime(\"nextTagId\") : callRuntime(\"nextTagId\", scopeIdentifier);\n      if (isOutputHTML()) {\n        tag.replaceWith(\n          import_compiler33.types.variableDeclaration(\"const\", [import_compiler33.types.variableDeclarator(node.var, id)])\n        );\n      } else {\n        const source = initValue(node.var.extra.binding);\n        addValue(getSection(tag), void 0, source, id);\n        tag.remove();\n      }\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"id/<name>\",\n      description: \"Use to create a unique identifier.\",\n      snippet: \"id/${1:name}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#id\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/id.d.marko\"\n};\n\n// src/core/if.ts\nvar import_babel_utils25 = require(\"@marko/babel-utils\");\nvar import_compiler35 = require(\"@marko/compiler\");\n\n// src/util/to-first-statement-or-block.ts\nvar import_compiler34 = require(\"@marko/compiler\");\nfunction toFirstStatementOrBlock(body) {\n  if (Array.isArray(body)) {\n    if (body.length === 1) {\n      return body[0];\n    }\n    return import_compiler34.types.blockStatement(body);\n  }\n  return body;\n}\n\n// src/core/if.ts\nvar kBinding = Symbol(\"if node binding\");\nvar BRANCHES_LOOKUP = /* @__PURE__ */ new WeakMap();\nvar IfTag = {\n  analyze(tag) {\n    assertValidCondition(tag);\n    if (tag.node.attributeTags.length) return;\n    const [isLast, branches] = getBranches(tag, startSection(tag.get(\"body\")));\n    if (isLast) {\n      const [rootTag] = branches[0];\n      const rootExtra = rootTag.node.extra ??= {};\n      const mergeReferenceNodes = [];\n      let singleNodeOptimization = true;\n      for (const [branchTag, branchBodySection] of branches) {\n        if (branchBodySection) {\n          branchBodySection.upstreamExpression = rootExtra;\n          if (!(branchBodySection.content === null || branchBodySection.content?.singleChild)) {\n            singleNodeOptimization = false;\n          }\n        }\n        if (branchTag.node.attributes.length) {\n          mergeReferenceNodes.push(branchTag.node.attributes[0].value);\n        }\n      }\n      const section = getOrCreateSection(tag);\n      rootExtra[kBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section,\n        void 0,\n        rootExtra\n      );\n      rootExtra.singleNodeOptimization = singleNodeOptimization;\n      mergeReferences(section, rootTag.node, mergeReferenceNodes);\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.attributeTags.length) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        const rootExtra = getRoot(tag).node.extra;\n        const isStateful = isStatefulReferences(rootExtra.referencedBindings);\n        const singleNodeOptimization = rootExtra.singleNodeOptimization;\n        if (isRoot(tag)) {\n          visit(tag, 37 /* Replace */);\n        }\n        enterShallow(tag);\n        flushBefore(tag);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n          if (isStateful && !singleNodeOptimization) {\n            writeTo(tagBody)`${callRuntime(\n              \"markResumeScopeStart\",\n              getScopeIdIdentifier(bodySection)\n            )}`;\n          }\n        }\n      },\n      exit(tag) {\n        if (tag.node.attributeTags.length) return;\n        const tagBody = tag.get(\"body\");\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const [isLast, branches] = getBranches(tag, bodySection);\n        const rootExtra = branches[0][0].node.extra;\n        const nodeRef2 = rootExtra[kBinding];\n        const isStateful = isStatefulReferences(rootExtra.referencedBindings);\n        const singleNodeOptimization = rootExtra.singleNodeOptimization;\n        const hasStatefulClosures = bodySection && checkStatefulClosures(bodySection, true);\n        if (bodySection) {\n          if (isStateful || hasStatefulClosures) {\n            setForceResumeScope(bodySection);\n          }\n          flushInto(tag);\n          setSubscriberBuilder(tag, () => {\n          });\n          writeHTMLResumeStatements(tagBody);\n        }\n        if (isLast) {\n          const write2 = writeTo(tag);\n          const nextTag = tag.getNextSibling();\n          const ifScopeIdIdentifier = tag.scope.generateUidIdentifier(\"ifScopeId\");\n          const ifRendererIdentifier = tag.scope.generateUidIdentifier(\"ifRenderer\");\n          let statement;\n          for (let i = branches.length; i--; ) {\n            const [branchTag, branchBodySection] = branches[i];\n            const bodyStatements = branchTag.node.body.body;\n            if (branchBodySection) {\n              const branchHasStatefulClosures = checkStatefulClosures(\n                branchBodySection,\n                true\n              );\n              if (isStateful) {\n                bodyStatements.push(\n                  import_compiler35.types.expressionStatement(\n                    callRuntime(\n                      \"register\",\n                      import_compiler35.types.assignmentExpression(\n                        \"=\",\n                        ifRendererIdentifier,\n                        callRuntime(\n                          \"createRenderer\",\n                          import_compiler35.types.arrowFunctionExpression([], import_compiler35.types.blockStatement([]))\n                        )\n                      ),\n                      import_compiler35.types.stringLiteral(\n                        getResumeRegisterId(branchBodySection, \"renderer\")\n                      )\n                    )\n                  )\n                );\n              }\n              if (isStateful || branchHasStatefulClosures) {\n                bodyStatements.push(\n                  import_compiler35.types.expressionStatement(\n                    import_compiler35.types.assignmentExpression(\n                      \"=\",\n                      ifScopeIdIdentifier,\n                      getScopeIdIdentifier(branchBodySection)\n                    )\n                  )\n                );\n              }\n            }\n            const [testAttr] = branchTag.node.attributes;\n            const curStatement = toFirstStatementOrBlock(bodyStatements);\n            if (testAttr) {\n              statement = import_compiler35.types.ifStatement(\n                testAttr.value,\n                curStatement,\n                statement\n              );\n            } else {\n              statement = curStatement;\n            }\n            branchTag.remove();\n          }\n          if (!(isStateful || hasStatefulClosures)) {\n            nextTag.insertBefore(statement);\n          } else {\n            nextTag.insertBefore([\n              import_compiler35.types.variableDeclaration(\n                \"let\",\n                [\n                  import_compiler35.types.variableDeclarator(ifScopeIdIdentifier),\n                  isStateful && import_compiler35.types.variableDeclarator(ifRendererIdentifier)\n                ].filter(Boolean)\n              ),\n              statement\n            ]);\n            if (isStateful) {\n              if (singleNodeOptimization) {\n                write2`${callRuntime(\n                  \"markResumeControlSingleNodeEnd\",\n                  getScopeIdIdentifier(section),\n                  getScopeAccessorLiteral(nodeRef2),\n                  ifScopeIdIdentifier\n                )}`;\n              } else {\n                write2`${callRuntime(\n                  \"markResumeControlEnd\",\n                  getScopeIdIdentifier(section),\n                  getScopeAccessorLiteral(nodeRef2)\n                )}`;\n              }\n              getSerializedScopeProperties(section).set(\n                import_compiler35.types.stringLiteral(\n                  getScopeAccessorLiteral(nodeRef2).value + \"(\" /* ConditionalRenderer */\n                ),\n                ifRendererIdentifier\n              );\n            }\n            getSerializedScopeProperties(section).set(\n              import_compiler35.types.stringLiteral(\n                getScopeAccessorLiteral(nodeRef2).value + \"!\" /* ConditionalScope */\n              ),\n              callRuntime(\"getScopeById\", ifScopeIdIdentifier)\n            );\n          }\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.attributeTags.length) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n        }\n        if (isRoot(tag)) {\n          visit(tag, 37 /* Replace */);\n        }\n        enterShallow(tag);\n      },\n      exit(tag) {\n        if (tag.node.attributeTags.length) return;\n        const [isLast, branches] = getBranches(\n          tag,\n          getSectionForBody(tag.get(\"body\"))\n        );\n        if (isLast) {\n          const section = getSection(tag);\n          const rootExtra = branches[0][0].node.extra;\n          const nodeRef2 = rootExtra[kBinding];\n          let expr = import_compiler35.types.nullLiteral();\n          for (let i = branches.length; i--; ) {\n            const [branchTag, branchBodySection] = branches[i];\n            const [testAttr] = branchTag.node.attributes;\n            const consequent = branchBodySection ? import_compiler35.types.identifier(branchBodySection.name) : import_compiler35.types.numericLiteral(0);\n            setSubscriberBuilder(branchTag, (subscriber) => {\n              return callRuntime(\n                \"inConditionalScope\",\n                subscriber,\n                getScopeAccessorLiteral(nodeRef2)\n                /*t.identifier(section.name)*/\n              );\n            });\n            branchTag.remove();\n            expr = testAttr ? import_compiler35.types.conditionalExpression(testAttr.value, consequent, expr) : consequent;\n          }\n          const signal = getSignal(section, nodeRef2, \"if\");\n          signal.build = () => {\n            return callRuntime(\n              \"conditional\",\n              getScopeAccessorLiteral(nodeRef2),\n              getSignalFn(signal, [scopeIdentifier])\n            );\n          };\n          signal.hasDownstreamIntersections = () => branches.some(([, bodySection]) => bodySection?.closures);\n          addValue(section, rootExtra.referencedBindings, signal, expr);\n        }\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  autocomplete: [\n    {\n      snippet: \"if=${1:condition}\",\n      description: \"Use to display content only if the condition is met.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseIfTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      snippet: \"else-if=${1:condition}\",\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nfunction assertValidCondition(tag) {\n  (0, import_babel_utils25.assertNoVar)(tag);\n  (0, import_babel_utils25.assertNoArgs)(tag);\n  (0, import_babel_utils25.assertNoParams)(tag);\n  assertHasBody(tag);\n  assertNoSpreadAttrs(tag);\n  switch (getTagName(tag)) {\n    case \"if\":\n      assertHasValueAttribute(tag);\n      break;\n    case \"else-if\":\n      assertHasValueAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n    case \"else\":\n      assertOptionalIfAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n  }\n}\nfunction assertHasPrecedingCondition(tag) {\n  let prev = tag.getPrevSibling();\n  while (prev.node && prev.isMarkoComment()) prev = prev.getPrevSibling();\n  if (!isConditionTag(prev) || getTagName(prev) !== \"else\" && !prev.node.attributes.length) {\n    throw tag.buildCodeFrameError(\n      `The \\`<${getTagName(tag)}>\\` must have a preceding \\`<if=cond>\\`, \\`<else-if=cond>\\`, or \\`<else if=cond>\\`.`\n    );\n  }\n}\nfunction assertHasBody(tag) {\n  if (!(tag.node.body.body.length || tag.node.attributeTags.length)) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${getTagName(tag)}\\` tag requires body content.`\n    );\n  }\n}\nfunction assertHasValueAttribute(tag) {\n  const { node } = tag;\n  const [valueAttr] = node.attributes;\n  if (!import_compiler35.types.isMarkoAttribute(valueAttr) || !valueAttr.default) {\n    throw tag.get(\"name\").buildCodeFrameError(`The \\`${getTagName(tag)}\\` tag requires a value.`);\n  }\n  if (node.attributes.length > 1) {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports the \\`value\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction assertOptionalIfAttribute(tag) {\n  const { node } = tag;\n  const [ifAttr] = node.attributes;\n  if (node.attributes.length > 1 || ifAttr && ifAttr.name !== \"if\") {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports an \\`if=\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction getBranches(tag, bodySection) {\n  const branches = BRANCHES_LOOKUP.get(tag) ?? [];\n  let nextTag = tag.getNextSibling();\n  while (nextTag.isMarkoComment()) nextTag = nextTag.getNextSibling();\n  const isLast = !(isCoreTagName(nextTag, \"else\") || isCoreTagName(nextTag, \"else-if\"));\n  branches.push([tag, bodySection]);\n  if (!isLast) {\n    BRANCHES_LOOKUP.set(nextTag, branches);\n  }\n  return [isLast, branches];\n}\nfunction getRoot(tag) {\n  return isRoot(tag) ? tag : BRANCHES_LOOKUP.get(tag)[0][0];\n}\nfunction isRoot(tag) {\n  return isCoreTagName(tag, \"if\");\n}\n\n// src/core/import.ts\nvar import_babel_utils26 = require(\"@marko/babel-utils\");\nvar import_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils26.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: 'import <scope> from \"<path>\"',\n      description: \"Use to import external modules, follows the same syntax as JavaScript imports.\",\n      snippet: 'import ${2} from \"${1:path}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#importing-external-files\"\n    }\n  ]\n};\n\n// src/core/let.ts\nvar import_babel_utils27 = require(\"@marko/babel-utils\");\nvar import_compiler36 = require(\"@marko/compiler\");\nvar let_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    const { optimize } = getMarkoOpts();\n    let valueAttr;\n    let valueChangeAttr;\n    for (const attr2 of node.attributes) {\n      if (import_compiler36.types.isMarkoAttribute(attr2)) {\n        if (attr2.name === \"value\") {\n          valueAttr = attr2;\n        } else if (attr2.name === \"valueChange\") {\n          valueChangeAttr = attr2;\n        } else {\n          const start = attr2.loc?.start;\n          const end = attr2.loc?.end;\n          const msg = \"The `let` tag only supports the `value` attribute and its change handler.\";\n          if (start == null || end == null) {\n            throw tag.get(\"name\").buildCodeFrameError(msg);\n          } else {\n            throw tag.hub.buildError(\n              { loc: { start, end } },\n              msg,\n              Error\n            );\n          }\n        }\n      }\n    }\n    (0, import_babel_utils27.assertNoArgs)(tag);\n    (0, import_babel_utils27.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    if (!tagVar) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `let` tag requires a tag variable.\");\n    }\n    if (!import_compiler36.types.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `let` tag variable cannot be destructured.\");\n    }\n    if (valueChangeAttr && (0, import_babel_utils27.computeNode)(valueChangeAttr.value)) {\n      throw tag.get(\"attributes\").find((attr2) => attr2.node === valueChangeAttr).get(\"value\").buildCodeFrameError(\n        \"The `let` tag `valueChange` attribute must be a function.\"\n      );\n    }\n    if (valueChangeAttr) {\n      const valueChangeReferences = (valueChangeAttr.value.extra ??= {})?.referencedBindings;\n      valueChangeAttr.value.extra.static = import_compiler36.types.isFunction(valueChangeAttr.value);\n      if (optimize && import_compiler36.types.isIdentifier(valueChangeAttr.value) && size(valueChangeReferences) === 1) {\n        valueChangeAttr.value.extra.binding = valueChangeReferences;\n      } else {\n        valueChangeAttr.value.extra.binding = createBinding(\n          tag.scope.generateUid(tagVar.name + \"_change\"),\n          1 /* let */,\n          getSection(tag),\n          void 0,\n          valueChangeAttr.value.extra\n        );\n      }\n    }\n    const upstreamExpressionExtra = valueAttr ? valueAttr.value.extra ??= {} : void 0;\n    trackVarReferences(\n      tag,\n      1 /* let */,\n      void 0,\n      upstreamExpressionExtra,\n      valueChangeAttr?.value.extra?.binding\n    );\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const tagVar = node.var;\n      const { optimize } = getMarkoOpts();\n      const valueAttr = node.attributes.find(\n        (attr2) => import_compiler36.types.isMarkoAttribute(attr2) && (attr2.default || attr2.name === \"value\")\n      ) ?? import_compiler36.types.markoAttribute(\"value\", import_compiler36.types.identifier(\"undefined\"));\n      const valueChangeAttr = node.attributes.find(\n        (attr2) => import_compiler36.types.isMarkoAttribute(attr2) && attr2.name === \"valueChange\"\n      );\n      const valueChangeBinding = valueChangeAttr?.value.extra?.binding;\n      if (isOutputDOM()) {\n        const section = getSection(tag);\n        const binding = tagVar.extra.binding;\n        const signal = initValue(binding);\n        const referencedBindings = valueAttr.value.extra?.referencedBindings;\n        const isSetup = !referencedBindings;\n        if (valueChangeBinding && (!optimize || !import_compiler36.types.isIdentifier(valueChangeAttr.value))) {\n          const valueChangeSource = initValue(valueChangeBinding);\n          if (!optimize && !import_compiler36.types.isFunction(valueChangeAttr.value)) {\n            const build = valueChangeSource.build;\n            valueChangeSource.build = () => {\n              const fn = build();\n              return callRuntime(\n                \"changeHandler\",\n                getScopeAccessorLiteral(valueChangeBinding),\n                fn\n              );\n            };\n          }\n          addValue(\n            section,\n            valueChangeAttr.value.extra?.referencedBindings,\n            valueChangeSource,\n            valueChangeAttr.value\n          );\n        }\n        addValue(section, referencedBindings, signal, valueAttr.value);\n        if (!isSetup && !valueChangeAttr?.value.extra?.static) {\n          let calleeExpression;\n          Object.defineProperty(signal, \"callee\", {\n            get() {\n              if (!calleeExpression) {\n                const initValueId = tag.scope.generateUidIdentifier(\n                  signal.identifier.name + \"_init\"\n                );\n                calleeExpression = valueChangeBinding ? import_compiler36.types.conditionalExpression(\n                  createScopeReadExpression(section, valueChangeBinding),\n                  signal.identifier,\n                  initValueId\n                ) : initValueId;\n                currentProgramPath.pushContainer(\n                  \"body\",\n                  import_compiler36.types.variableDeclaration(\"const\", [\n                    import_compiler36.types.variableDeclarator(\n                      initValueId,\n                      callRuntime(\n                        \"initValue\",\n                        getScopeAccessorLiteral(binding),\n                        signal.identifier\n                      )\n                    )\n                  ])\n                );\n              }\n              return calleeExpression;\n            }\n          });\n        }\n        signal.buildAssignment = (valueSection, value) => {\n          return queueSource(signal, value, valueSection, valueChangeBinding);\n        };\n      } else {\n        translateVar(tag, valueAttr.value);\n        if (valueChangeBinding) {\n          tag.insertBefore(\n            import_compiler36.types.variableDeclaration(\"const\", [\n              import_compiler36.types.variableDeclarator(\n                import_compiler36.types.identifier(valueChangeBinding.name),\n                valueChangeAttr.value\n              )\n            ])\n          );\n        }\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a mutable binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#let\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/let.d.marko\"\n};\n\n// src/core/lifecycle.ts\nvar import_babel_utils28 = require(\"@marko/babel-utils\");\nvar import_compiler37 = require(\"@marko/compiler\");\nvar kRef = Symbol(\"lifecycle attrs reference\");\nvar supportedAttrNames = /* @__PURE__ */ new Set([\"onMount\", \"onUpdate\", \"onDestroy\"]);\nvar lifecycle_default = {\n  analyze(tag) {\n    (0, import_babel_utils28.assertNoArgs)(tag);\n    (0, import_babel_utils28.assertNoVar)(tag);\n    (0, import_babel_utils28.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const tagExtra = node.extra ??= {};\n    const section = getOrCreateSection(tag);\n    tagExtra[kRef] = createBinding(\n      tag.scope.generateUid(\"lifecycle\"),\n      4 /* derived */,\n      section,\n      void 0,\n      tagExtra\n    );\n    if (node.attributes.length === 0) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `lifecycle` tag requires at least one attribute.\"\n      );\n    }\n    for (const attr2 of node.attributes) {\n      if (import_compiler37.types.isMarkoSpreadAttribute(attr2)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The `lifecycle` tag does not support `...spread` attributes.\"\n        );\n      } else if (!supportedAttrNames.has(attr2.name)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          `The \\`lifecycle\\` tag does not support the \\`${attr2.name}\\` attribute.`\n        );\n      }\n      (attr2.value.extra ??= {}).isEffect = true;\n    }\n    (currentProgramPath.node.extra ??= {}).isInteractive = true;\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const section = getSection(tag);\n      const tagExtra = node.extra;\n      const { referencedBindings } = tagExtra;\n      const lifecycleAttrsRef = tagExtra[kRef];\n      if (isOutputDOM()) {\n        const translatedAttrs = translateAttrs(tag);\n        translatedAttrs.statements.push(\n          import_compiler37.types.expressionStatement(\n            callRuntime(\n              \"lifecycle\",\n              scopeIdentifier,\n              getScopeAccessorLiteral(lifecycleAttrsRef),\n              propsToExpression(translatedAttrs.properties)\n            )\n          )\n        );\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          translatedAttrs.statements,\n          node.attributes.map((a) => a.value)\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/lifecycle.d.marko\"\n};\n\n// src/core/log.ts\nvar import_babel_utils29 = require(\"@marko/babel-utils\");\nvar import_compiler38 = require(\"@marko/compiler\");\nvar log_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils29.assertNoArgs)(tag);\n    (0, import_babel_utils29.assertNoVar)(tag);\n    (0, import_babel_utils29.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `log` tag requires a value.\");\n    }\n    if (tag.node.attributes.length > 1 || !import_compiler38.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `log` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      const statement = import_compiler38.types.expressionStatement(\n        import_compiler38.types.callExpression(\n          import_compiler38.types.memberExpression(import_compiler38.types.identifier(\"console\"), import_compiler38.types.identifier(\"log\")),\n          [value]\n        )\n      );\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to log a value to the console.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#log\"\n    }\n  ],\n  types: \"@marko/translator-tags/tag-types/log.d.marko\"\n};\n\n// src/core/noop.ts\nvar noop_default = {\n  migrate: [(tag) => tag.remove()]\n};\n\n// src/core/server.ts\nvar import_babel_utils30 = require(\"@marko/babel-utils\");\nvar import_compiler39 = require(\"@marko/compiler\");\nvar server_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^server\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils30.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler39.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler39.types.markoScriptlet(body, true, \"server\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"server <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the server.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#server-javascript\"\n    }\n  ]\n};\n\n// src/core/static.ts\nvar import_babel_utils31 = require(\"@marko/babel-utils\");\nvar import_compiler40 = require(\"@marko/compiler\");\nvar static_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^static\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils31.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler40.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler40.types.markoScriptlet(body, true));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"static <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#static-javascript\"\n    }\n  ]\n};\n\n// src/core/style.ts\nvar import_babel_utils32 = require(\"@marko/babel-utils\");\nvar import_compiler41 = require(\"@marko/compiler\");\n\n// ../../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs\nvar comma = \",\".charCodeAt(0);\nvar semicolon = \";\".charCodeAt(0);\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar intToChar = new Uint8Array(64);\nvar charToInt = new Uint8Array(128);\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\nfunction encodeInteger(builder, num, relative) {\n  let delta = num - relative;\n  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;\n  do {\n    let clamped = delta & 31;\n    delta >>>= 5;\n    if (delta > 0)\n      clamped |= 32;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n  return num;\n}\nvar bufLength = 1024 * 16;\nvar td = typeof TextDecoder !== \"undefined\" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== \"undefined\" ? {\n  decode(buf) {\n    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n    return out.toString();\n  }\n} : {\n  decode(buf) {\n    let out = \"\";\n    for (let i = 0; i < buf.length; i++) {\n      out += String.fromCharCode(buf[i]);\n    }\n    return out;\n  }\n};\nvar StringWriter = class {\n  constructor() {\n    this.pos = 0;\n    this.out = \"\";\n    this.buffer = new Uint8Array(bufLength);\n  }\n  write(v) {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n  flush() {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n};\nfunction encode(decoded) {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0)\n      writer.write(semicolon);\n    if (line.length === 0)\n      continue;\n    let genColumn = 0;\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0)\n        writer.write(comma);\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n      if (segment.length === 1)\n        continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n      if (segment.length === 4)\n        continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n  return writer.flush();\n}\n\n// ../../node_modules/magic-string/dist/magic-string.es.mjs\nvar BitSet = class _BitSet {\n  constructor(arg) {\n    this.bits = arg instanceof _BitSet ? arg.bits.slice() : [];\n  }\n  add(n2) {\n    this.bits[n2 >> 5] |= 1 << (n2 & 31);\n  }\n  has(n2) {\n    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));\n  }\n};\nvar Chunk2 = class _Chunk {\n  constructor(start, end, content) {\n    this.start = start;\n    this.end = end;\n    this.original = content;\n    this.intro = \"\";\n    this.outro = \"\";\n    this.content = content;\n    this.storeName = false;\n    this.edited = false;\n    {\n      this.previous = null;\n      this.next = null;\n    }\n  }\n  appendLeft(content) {\n    this.outro += content;\n  }\n  appendRight(content) {\n    this.intro = this.intro + content;\n  }\n  clone() {\n    const chunk = new _Chunk(this.start, this.end, this.original);\n    chunk.intro = this.intro;\n    chunk.outro = this.outro;\n    chunk.content = this.content;\n    chunk.storeName = this.storeName;\n    chunk.edited = this.edited;\n    return chunk;\n  }\n  contains(index) {\n    return this.start < index && index < this.end;\n  }\n  eachNext(fn) {\n    let chunk = this;\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.next;\n    }\n  }\n  eachPrevious(fn) {\n    let chunk = this;\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.previous;\n    }\n  }\n  edit(content, storeName, contentOnly) {\n    this.content = content;\n    if (!contentOnly) {\n      this.intro = \"\";\n      this.outro = \"\";\n    }\n    this.storeName = storeName;\n    this.edited = true;\n    return this;\n  }\n  prependLeft(content) {\n    this.outro = content + this.outro;\n  }\n  prependRight(content) {\n    this.intro = content + this.intro;\n  }\n  reset() {\n    this.intro = \"\";\n    this.outro = \"\";\n    if (this.edited) {\n      this.content = this.original;\n      this.storeName = false;\n      this.edited = false;\n    }\n  }\n  split(index) {\n    const sliceIndex = index - this.start;\n    const originalBefore = this.original.slice(0, sliceIndex);\n    const originalAfter = this.original.slice(sliceIndex);\n    this.original = originalBefore;\n    const newChunk = new _Chunk(index, this.end, originalAfter);\n    newChunk.outro = this.outro;\n    this.outro = \"\";\n    this.end = index;\n    if (this.edited) {\n      newChunk.edit(\"\", false);\n      this.content = \"\";\n    } else {\n      this.content = originalBefore;\n    }\n    newChunk.next = this.next;\n    if (newChunk.next) newChunk.next.previous = newChunk;\n    newChunk.previous = this;\n    this.next = newChunk;\n    return newChunk;\n  }\n  toString() {\n    return this.intro + this.content + this.outro;\n  }\n  trimEnd(rx) {\n    this.outro = this.outro.replace(rx, \"\");\n    if (this.outro.length) return true;\n    const trimmed = this.content.replace(rx, \"\");\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        this.split(this.start + trimmed.length).edit(\"\", void 0, true);\n        if (this.edited) {\n          this.edit(trimmed, this.storeName, true);\n        }\n      }\n      return true;\n    } else {\n      this.edit(\"\", void 0, true);\n      this.intro = this.intro.replace(rx, \"\");\n      if (this.intro.length) return true;\n    }\n  }\n  trimStart(rx) {\n    this.intro = this.intro.replace(rx, \"\");\n    if (this.intro.length) return true;\n    const trimmed = this.content.replace(rx, \"\");\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        const newChunk = this.split(this.end - trimmed.length);\n        if (this.edited) {\n          newChunk.edit(trimmed, this.storeName, true);\n        }\n        this.edit(\"\", void 0, true);\n      }\n      return true;\n    } else {\n      this.edit(\"\", void 0, true);\n      this.outro = this.outro.replace(rx, \"\");\n      if (this.outro.length) return true;\n    }\n  }\n};\nfunction getBtoa() {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));\n  } else if (typeof Buffer === \"function\") {\n    return (str) => Buffer.from(str, \"utf-8\").toString(\"base64\");\n  } else {\n    return () => {\n      throw new Error(\"Unsupported environment: `window.btoa` or `Buffer` should be supported.\");\n    };\n  }\n}\nvar btoa = /* @__PURE__ */ getBtoa();\nvar SourceMap = class {\n  constructor(properties) {\n    this.version = 3;\n    this.file = properties.file;\n    this.sources = properties.sources;\n    this.sourcesContent = properties.sourcesContent;\n    this.names = properties.names;\n    this.mappings = encode(properties.mappings);\n    if (typeof properties.x_google_ignoreList !== \"undefined\") {\n      this.x_google_ignoreList = properties.x_google_ignoreList;\n    }\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  toUrl() {\n    return \"data:application/json;charset=utf-8;base64,\" + btoa(this.toString());\n  }\n};\nfunction guessIndent(code) {\n  const lines = code.split(\"\\n\");\n  const tabbed = lines.filter((line) => /^\\t+/.test(line));\n  const spaced = lines.filter((line) => /^ {2,}/.test(line));\n  if (tabbed.length === 0 && spaced.length === 0) {\n    return null;\n  }\n  if (tabbed.length >= spaced.length) {\n    return \"\t\";\n  }\n  const min = spaced.reduce((previous, current) => {\n    const numSpaces = /^ +/.exec(current)[0].length;\n    return Math.min(numSpaces, previous);\n  }, Infinity);\n  return new Array(min + 1).join(\" \");\n}\nfunction getRelativePath(from, to) {\n  const fromParts = from.split(/[/\\\\]/);\n  const toParts = to.split(/[/\\\\]/);\n  fromParts.pop();\n  while (fromParts[0] === toParts[0]) {\n    fromParts.shift();\n    toParts.shift();\n  }\n  if (fromParts.length) {\n    let i = fromParts.length;\n    while (i--) fromParts[i] = \"..\";\n  }\n  return fromParts.concat(toParts).join(\"/\");\n}\nvar toString2 = Object.prototype.toString;\nfunction isObject(thing) {\n  return toString2.call(thing) === \"[object Object]\";\n}\nfunction getLocator(source) {\n  const originalLines = source.split(\"\\n\");\n  const lineOffsets = [];\n  for (let i = 0, pos = 0; i < originalLines.length; i++) {\n    lineOffsets.push(pos);\n    pos += originalLines[i].length + 1;\n  }\n  return function locate(index) {\n    let i = 0;\n    let j = lineOffsets.length;\n    while (i < j) {\n      const m = i + j >> 1;\n      if (index < lineOffsets[m]) {\n        j = m;\n      } else {\n        i = m + 1;\n      }\n    }\n    const line = i - 1;\n    const column = index - lineOffsets[line];\n    return { line, column };\n  };\n}\nvar wordRegex = /\\w/;\nvar Mappings = class {\n  constructor(hires) {\n    this.hires = hires;\n    this.generatedCodeLine = 0;\n    this.generatedCodeColumn = 0;\n    this.raw = [];\n    this.rawSegments = this.raw[this.generatedCodeLine] = [];\n    this.pending = null;\n  }\n  addEdit(sourceIndex, content, loc, nameIndex) {\n    if (content.length) {\n      const contentLengthMinusOne = content.length - 1;\n      let contentLineEnd = content.indexOf(\"\\n\", 0);\n      let previousContentLineEnd = -1;\n      while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {\n        const segment2 = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n        if (nameIndex >= 0) {\n          segment2.push(nameIndex);\n        }\n        this.rawSegments.push(segment2);\n        this.generatedCodeLine += 1;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n        this.generatedCodeColumn = 0;\n        previousContentLineEnd = contentLineEnd;\n        contentLineEnd = content.indexOf(\"\\n\", contentLineEnd + 1);\n      }\n      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n      if (nameIndex >= 0) {\n        segment.push(nameIndex);\n      }\n      this.rawSegments.push(segment);\n      this.advance(content.slice(previousContentLineEnd + 1));\n    } else if (this.pending) {\n      this.rawSegments.push(this.pending);\n      this.advance(content);\n    }\n    this.pending = null;\n  }\n  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n    let originalCharIndex = chunk.start;\n    let first = true;\n    let charInHiresBoundary = false;\n    while (originalCharIndex < chunk.end) {\n      if (original[originalCharIndex] === \"\\n\") {\n        loc.line += 1;\n        loc.column = 0;\n        this.generatedCodeLine += 1;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n        this.generatedCodeColumn = 0;\n        first = true;\n      } else {\n        if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n          const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n          if (this.hires === \"boundary\") {\n            if (wordRegex.test(original[originalCharIndex])) {\n              if (!charInHiresBoundary) {\n                this.rawSegments.push(segment);\n                charInHiresBoundary = true;\n              }\n            } else {\n              this.rawSegments.push(segment);\n              charInHiresBoundary = false;\n            }\n          } else {\n            this.rawSegments.push(segment);\n          }\n        }\n        loc.column += 1;\n        this.generatedCodeColumn += 1;\n        first = false;\n      }\n      originalCharIndex += 1;\n    }\n    this.pending = null;\n  }\n  advance(str) {\n    if (!str) return;\n    const lines = str.split(\"\\n\");\n    if (lines.length > 1) {\n      for (let i = 0; i < lines.length - 1; i++) {\n        this.generatedCodeLine++;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n      }\n      this.generatedCodeColumn = 0;\n    }\n    this.generatedCodeColumn += lines[lines.length - 1].length;\n  }\n};\nvar n = \"\\n\";\nvar warned = {\n  insertLeft: false,\n  insertRight: false,\n  storeName: false\n};\nvar MagicString = class _MagicString {\n  constructor(string, options = {}) {\n    const chunk = new Chunk2(0, string.length, string);\n    Object.defineProperties(this, {\n      original: { writable: true, value: string },\n      outro: { writable: true, value: \"\" },\n      intro: { writable: true, value: \"\" },\n      firstChunk: { writable: true, value: chunk },\n      lastChunk: { writable: true, value: chunk },\n      lastSearchedChunk: { writable: true, value: chunk },\n      byStart: { writable: true, value: {} },\n      byEnd: { writable: true, value: {} },\n      filename: { writable: true, value: options.filename },\n      indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n      sourcemapLocations: { writable: true, value: new BitSet() },\n      storedNames: { writable: true, value: {} },\n      indentStr: { writable: true, value: void 0 },\n      ignoreList: { writable: true, value: options.ignoreList }\n    });\n    this.byStart[0] = chunk;\n    this.byEnd[string.length] = chunk;\n  }\n  addSourcemapLocation(char) {\n    this.sourcemapLocations.add(char);\n  }\n  append(content) {\n    if (typeof content !== \"string\") throw new TypeError(\"outro content must be a string\");\n    this.outro += content;\n    return this;\n  }\n  appendLeft(index, content) {\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byEnd[index];\n    if (chunk) {\n      chunk.appendLeft(content);\n    } else {\n      this.intro += content;\n    }\n    return this;\n  }\n  appendRight(index, content) {\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byStart[index];\n    if (chunk) {\n      chunk.appendRight(content);\n    } else {\n      this.outro += content;\n    }\n    return this;\n  }\n  clone() {\n    const cloned = new _MagicString(this.original, { filename: this.filename });\n    let originalChunk = this.firstChunk;\n    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();\n    while (originalChunk) {\n      cloned.byStart[clonedChunk.start] = clonedChunk;\n      cloned.byEnd[clonedChunk.end] = clonedChunk;\n      const nextOriginalChunk = originalChunk.next;\n      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n      if (nextClonedChunk) {\n        clonedChunk.next = nextClonedChunk;\n        nextClonedChunk.previous = clonedChunk;\n        clonedChunk = nextClonedChunk;\n      }\n      originalChunk = nextOriginalChunk;\n    }\n    cloned.lastChunk = clonedChunk;\n    if (this.indentExclusionRanges) {\n      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n    }\n    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n    cloned.intro = this.intro;\n    cloned.outro = this.outro;\n    return cloned;\n  }\n  generateDecodedMap(options) {\n    options = options || {};\n    const sourceIndex = 0;\n    const names = Object.keys(this.storedNames);\n    const mappings = new Mappings(options.hires);\n    const locate = getLocator(this.original);\n    if (this.intro) {\n      mappings.advance(this.intro);\n    }\n    this.firstChunk.eachNext((chunk) => {\n      const loc = locate(chunk.start);\n      if (chunk.intro.length) mappings.advance(chunk.intro);\n      if (chunk.edited) {\n        mappings.addEdit(\n          sourceIndex,\n          chunk.content,\n          loc,\n          chunk.storeName ? names.indexOf(chunk.original) : -1\n        );\n      } else {\n        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n      }\n      if (chunk.outro.length) mappings.advance(chunk.outro);\n    });\n    return {\n      file: options.file ? options.file.split(/[/\\\\]/).pop() : void 0,\n      sources: [\n        options.source ? getRelativePath(options.file || \"\", options.source) : options.file || \"\"\n      ],\n      sourcesContent: options.includeContent ? [this.original] : void 0,\n      names,\n      mappings: mappings.raw,\n      x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0\n    };\n  }\n  generateMap(options) {\n    return new SourceMap(this.generateDecodedMap(options));\n  }\n  _ensureindentStr() {\n    if (this.indentStr === void 0) {\n      this.indentStr = guessIndent(this.original);\n    }\n  }\n  _getRawIndentString() {\n    this._ensureindentStr();\n    return this.indentStr;\n  }\n  getIndentString() {\n    this._ensureindentStr();\n    return this.indentStr === null ? \"\t\" : this.indentStr;\n  }\n  indent(indentStr, options) {\n    const pattern = /^[^\\r\\n]/gm;\n    if (isObject(indentStr)) {\n      options = indentStr;\n      indentStr = void 0;\n    }\n    if (indentStr === void 0) {\n      this._ensureindentStr();\n      indentStr = this.indentStr || \"\t\";\n    }\n    if (indentStr === \"\") return this;\n    options = options || {};\n    const isExcluded = {};\n    if (options.exclude) {\n      const exclusions = typeof options.exclude[0] === \"number\" ? [options.exclude] : options.exclude;\n      exclusions.forEach((exclusion) => {\n        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n          isExcluded[i] = true;\n        }\n      });\n    }\n    let shouldIndentNextCharacter = options.indentStart !== false;\n    const replacer = (match) => {\n      if (shouldIndentNextCharacter) return `${indentStr}${match}`;\n      shouldIndentNextCharacter = true;\n      return match;\n    };\n    this.intro = this.intro.replace(pattern, replacer);\n    let charIndex = 0;\n    let chunk = this.firstChunk;\n    while (chunk) {\n      const end = chunk.end;\n      if (chunk.edited) {\n        if (!isExcluded[charIndex]) {\n          chunk.content = chunk.content.replace(pattern, replacer);\n          if (chunk.content.length) {\n            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === \"\\n\";\n          }\n        }\n      } else {\n        charIndex = chunk.start;\n        while (charIndex < end) {\n          if (!isExcluded[charIndex]) {\n            const char = this.original[charIndex];\n            if (char === \"\\n\") {\n              shouldIndentNextCharacter = true;\n            } else if (char !== \"\\r\" && shouldIndentNextCharacter) {\n              shouldIndentNextCharacter = false;\n              if (charIndex === chunk.start) {\n                chunk.prependRight(indentStr);\n              } else {\n                this._splitChunk(chunk, charIndex);\n                chunk = chunk.next;\n                chunk.prependRight(indentStr);\n              }\n            }\n          }\n          charIndex += 1;\n        }\n      }\n      charIndex = chunk.end;\n      chunk = chunk.next;\n    }\n    this.outro = this.outro.replace(pattern, replacer);\n    return this;\n  }\n  insert() {\n    throw new Error(\n      \"magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)\"\n    );\n  }\n  insertLeft(index, content) {\n    if (!warned.insertLeft) {\n      console.warn(\n        \"magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead\"\n      );\n      warned.insertLeft = true;\n    }\n    return this.appendLeft(index, content);\n  }\n  insertRight(index, content) {\n    if (!warned.insertRight) {\n      console.warn(\n        \"magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead\"\n      );\n      warned.insertRight = true;\n    }\n    return this.prependRight(index, content);\n  }\n  move(start, end, index) {\n    if (index >= start && index <= end) throw new Error(\"Cannot move a selection inside itself\");\n    this._split(start);\n    this._split(end);\n    this._split(index);\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n    const oldLeft = first.previous;\n    const oldRight = last.next;\n    const newRight = this.byStart[index];\n    if (!newRight && last === this.lastChunk) return this;\n    const newLeft = newRight ? newRight.previous : this.lastChunk;\n    if (oldLeft) oldLeft.next = oldRight;\n    if (oldRight) oldRight.previous = oldLeft;\n    if (newLeft) newLeft.next = first;\n    if (newRight) newRight.previous = last;\n    if (!first.previous) this.firstChunk = last.next;\n    if (!last.next) {\n      this.lastChunk = first.previous;\n      this.lastChunk.next = null;\n    }\n    first.previous = newLeft;\n    last.next = newRight || null;\n    if (!newLeft) this.firstChunk = first;\n    if (!newRight) this.lastChunk = last;\n    return this;\n  }\n  overwrite(start, end, content, options) {\n    options = options || {};\n    return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n  }\n  update(start, end, content, options) {\n    if (typeof content !== \"string\") throw new TypeError(\"replacement content must be a string\");\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (end > this.original.length) throw new Error(\"end is out of bounds\");\n    if (start === end)\n      throw new Error(\n        \"Cannot overwrite a zero-length range \\u2013 use appendLeft or prependRight instead\"\n      );\n    this._split(start);\n    this._split(end);\n    if (options === true) {\n      if (!warned.storeName) {\n        console.warn(\n          \"The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string\"\n        );\n        warned.storeName = true;\n      }\n      options = { storeName: true };\n    }\n    const storeName = options !== void 0 ? options.storeName : false;\n    const overwrite = options !== void 0 ? options.overwrite : false;\n    if (storeName) {\n      const original = this.original.slice(start, end);\n      Object.defineProperty(this.storedNames, original, {\n        writable: true,\n        value: true,\n        enumerable: true\n      });\n    }\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n    if (first) {\n      let chunk = first;\n      while (chunk !== last) {\n        if (chunk.next !== this.byStart[chunk.end]) {\n          throw new Error(\"Cannot overwrite across a split point\");\n        }\n        chunk = chunk.next;\n        chunk.edit(\"\", false);\n      }\n      first.edit(content, storeName, !overwrite);\n    } else {\n      const newChunk = new Chunk2(start, end, \"\").edit(content, storeName);\n      last.next = newChunk;\n      newChunk.previous = last;\n    }\n    return this;\n  }\n  prepend(content) {\n    if (typeof content !== \"string\") throw new TypeError(\"outro content must be a string\");\n    this.intro = content + this.intro;\n    return this;\n  }\n  prependLeft(index, content) {\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byEnd[index];\n    if (chunk) {\n      chunk.prependLeft(content);\n    } else {\n      this.intro = content + this.intro;\n    }\n    return this;\n  }\n  prependRight(index, content) {\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byStart[index];\n    if (chunk) {\n      chunk.prependRight(content);\n    } else {\n      this.outro = content + this.outro;\n    }\n    return this;\n  }\n  remove(start, end) {\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (start === end) return this;\n    if (start < 0 || end > this.original.length) throw new Error(\"Character is out of bounds\");\n    if (start > end) throw new Error(\"end must be greater than start\");\n    this._split(start);\n    this._split(end);\n    let chunk = this.byStart[start];\n    while (chunk) {\n      chunk.intro = \"\";\n      chunk.outro = \"\";\n      chunk.edit(\"\");\n      chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n    }\n    return this;\n  }\n  reset(start, end) {\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (start === end) return this;\n    if (start < 0 || end > this.original.length) throw new Error(\"Character is out of bounds\");\n    if (start > end) throw new Error(\"end must be greater than start\");\n    this._split(start);\n    this._split(end);\n    let chunk = this.byStart[start];\n    while (chunk) {\n      chunk.reset();\n      chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n    }\n    return this;\n  }\n  lastChar() {\n    if (this.outro.length) return this.outro[this.outro.length - 1];\n    let chunk = this.lastChunk;\n    do {\n      if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n      if (chunk.content.length) return chunk.content[chunk.content.length - 1];\n      if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n    } while (chunk = chunk.previous);\n    if (this.intro.length) return this.intro[this.intro.length - 1];\n    return \"\";\n  }\n  lastLine() {\n    let lineIndex = this.outro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n    let lineStr = this.outro;\n    let chunk = this.lastChunk;\n    do {\n      if (chunk.outro.length > 0) {\n        lineIndex = chunk.outro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.outro + lineStr;\n      }\n      if (chunk.content.length > 0) {\n        lineIndex = chunk.content.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.content + lineStr;\n      }\n      if (chunk.intro.length > 0) {\n        lineIndex = chunk.intro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.intro + lineStr;\n      }\n    } while (chunk = chunk.previous);\n    lineIndex = this.intro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n    return this.intro + lineStr;\n  }\n  slice(start = 0, end = this.original.length) {\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    let result = \"\";\n    let chunk = this.firstChunk;\n    while (chunk && (chunk.start > start || chunk.end <= start)) {\n      if (chunk.start < end && chunk.end >= end) {\n        return result;\n      }\n      chunk = chunk.next;\n    }\n    if (chunk && chunk.edited && chunk.start !== start)\n      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n    const startChunk = chunk;\n    while (chunk) {\n      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n        result += chunk.intro;\n      }\n      const containsEnd = chunk.start < end && chunk.end >= end;\n      if (containsEnd && chunk.edited && chunk.end !== end)\n        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n      const sliceStart = startChunk === chunk ? start - chunk.start : 0;\n      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n      result += chunk.content.slice(sliceStart, sliceEnd);\n      if (chunk.outro && (!containsEnd || chunk.end === end)) {\n        result += chunk.outro;\n      }\n      if (containsEnd) {\n        break;\n      }\n      chunk = chunk.next;\n    }\n    return result;\n  }\n  // TODO deprecate this? not really very useful\n  snip(start, end) {\n    const clone = this.clone();\n    clone.remove(0, start);\n    clone.remove(end, clone.original.length);\n    return clone;\n  }\n  _split(index) {\n    if (this.byStart[index] || this.byEnd[index]) return;\n    let chunk = this.lastSearchedChunk;\n    const searchForward = index > chunk.end;\n    while (chunk) {\n      if (chunk.contains(index)) return this._splitChunk(chunk, index);\n      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n    }\n  }\n  _splitChunk(chunk, index) {\n    if (chunk.edited && chunk.content.length) {\n      const loc = getLocator(this.original)(index);\n      throw new Error(\n        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \\u2013 \"${chunk.original}\")`\n      );\n    }\n    const newChunk = chunk.split(index);\n    this.byEnd[index] = chunk;\n    this.byStart[index] = newChunk;\n    this.byEnd[newChunk.end] = newChunk;\n    if (chunk === this.lastChunk) this.lastChunk = newChunk;\n    this.lastSearchedChunk = chunk;\n    return true;\n  }\n  toString() {\n    let str = this.intro;\n    let chunk = this.firstChunk;\n    while (chunk) {\n      str += chunk.toString();\n      chunk = chunk.next;\n    }\n    return str + this.outro;\n  }\n  isEmpty() {\n    let chunk = this.firstChunk;\n    do {\n      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())\n        return false;\n    } while (chunk = chunk.next);\n    return true;\n  }\n  length() {\n    let chunk = this.firstChunk;\n    let length = 0;\n    do {\n      length += chunk.intro.length + chunk.content.length + chunk.outro.length;\n    } while (chunk = chunk.next);\n    return length;\n  }\n  trimLines() {\n    return this.trim(\"[\\\\r\\\\n]\");\n  }\n  trim(charType) {\n    return this.trimStart(charType).trimEnd(charType);\n  }\n  trimEndAborted(charType) {\n    const rx = new RegExp((charType || \"\\\\s\") + \"+$\");\n    this.outro = this.outro.replace(rx, \"\");\n    if (this.outro.length) return true;\n    let chunk = this.lastChunk;\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimEnd(rx);\n      if (chunk.end !== end) {\n        if (this.lastChunk === chunk) {\n          this.lastChunk = chunk.next;\n        }\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n      if (aborted) return true;\n      chunk = chunk.previous;\n    } while (chunk);\n    return false;\n  }\n  trimEnd(charType) {\n    this.trimEndAborted(charType);\n    return this;\n  }\n  trimStartAborted(charType) {\n    const rx = new RegExp(\"^\" + (charType || \"\\\\s\") + \"+\");\n    this.intro = this.intro.replace(rx, \"\");\n    if (this.intro.length) return true;\n    let chunk = this.firstChunk;\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimStart(rx);\n      if (chunk.end !== end) {\n        if (chunk === this.lastChunk) this.lastChunk = chunk.next;\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n      if (aborted) return true;\n      chunk = chunk.next;\n    } while (chunk);\n    return false;\n  }\n  trimStart(charType) {\n    this.trimStartAborted(charType);\n    return this;\n  }\n  hasChanged() {\n    return this.original !== this.toString();\n  }\n  _replaceRegexp(searchValue, replacement) {\n    function getReplacement(match, str) {\n      if (typeof replacement === \"string\") {\n        return replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n          if (i === \"$\") return \"$\";\n          if (i === \"&\") return match[0];\n          const num = +i;\n          if (num < match.length) return match[+i];\n          return `$${i}`;\n        });\n      } else {\n        return replacement(...match, match.index, str, match.groups);\n      }\n    }\n    function matchAll(re, str) {\n      let match;\n      const matches = [];\n      while (match = re.exec(str)) {\n        matches.push(match);\n      }\n      return matches;\n    }\n    if (searchValue.global) {\n      const matches = matchAll(searchValue, this.original);\n      matches.forEach((match) => {\n        if (match.index != null) {\n          const replacement2 = getReplacement(match, this.original);\n          if (replacement2 !== match[0]) {\n            this.overwrite(\n              match.index,\n              match.index + match[0].length,\n              replacement2\n            );\n          }\n        }\n      });\n    } else {\n      const match = this.original.match(searchValue);\n      if (match && match.index != null) {\n        const replacement2 = getReplacement(match, this.original);\n        if (replacement2 !== match[0]) {\n          this.overwrite(\n            match.index,\n            match.index + match[0].length,\n            replacement2\n          );\n        }\n      }\n    }\n    return this;\n  }\n  _replaceString(string, replacement) {\n    const { original } = this;\n    const index = original.indexOf(string);\n    if (index !== -1) {\n      this.overwrite(index, index + string.length, replacement);\n    }\n    return this;\n  }\n  replace(searchValue, replacement) {\n    if (typeof searchValue === \"string\") {\n      return this._replaceString(searchValue, replacement);\n    }\n    return this._replaceRegexp(searchValue, replacement);\n  }\n  _replaceAllString(string, replacement) {\n    const { original } = this;\n    const stringLength = string.length;\n    for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {\n      const previous = original.slice(index, index + stringLength);\n      if (previous !== replacement)\n        this.overwrite(index, index + stringLength, replacement);\n    }\n    return this;\n  }\n  replaceAll(searchValue, replacement) {\n    if (typeof searchValue === \"string\") {\n      return this._replaceAllString(searchValue, replacement);\n    }\n    if (!searchValue.global) {\n      throw new TypeError(\n        \"MagicString.prototype.replaceAll called with a non-global RegExp argument\"\n      );\n    }\n    return this._replaceRegexp(searchValue, replacement);\n  }\n};\n\n// src/core/style.ts\nvar import_path2 = __toESM(require(\"path\"));\nvar style_default = {\n  analyze(tag) {\n    (0, import_babel_utils32.assertNoArgs)(tag);\n    (0, import_babel_utils32.assertNoParams)(tag);\n    (0, import_babel_utils32.assertNoAttributeTags)(tag);\n  },\n  translate(tag) {\n    const {\n      hub: { file }\n    } = tag;\n    const { filename, sourceMaps } = file.opts;\n    (0, import_babel_utils32.assertNoParams)(tag);\n    assertNoSpreadAttrs(tag);\n    let type = \"text/css\";\n    const attrs2 = tag.get(\"attributes\");\n    const base = import_path2.default.basename(filename);\n    const typeAttr = attrs2.find(\n      (attr2) => attr2.isMarkoAttribute() && attr2.node.name === \"type\"\n    );\n    const classAttr2 = attrs2.find(\n      (attr2) => attr2.isMarkoAttribute() && attr2.node.name === \"class\"\n    );\n    if (typeAttr && classAttr2) {\n      throw classAttr2.buildCodeFrameError(\n        \"The `style` tag must only use `type` or `class` and not both.\"\n      );\n    } else if (typeAttr) {\n      const typeValue = typeAttr.get(\"value\");\n      if (typeValue.isStringLiteral()) {\n        type = typeValue.node.value;\n      } else {\n        throw typeValue.buildCodeFrameError(\n          \"The `style` tag `type` attribute can only be a string literal.\"\n        );\n      }\n    } else if (classAttr2) {\n      const classValue2 = classAttr2.get(\"value\");\n      if (classValue2.isStringLiteral()) {\n        type = classValue2.node.value;\n      } else {\n        throw classValue2.buildCodeFrameError(\n          \"The `style` tag `class` attribute can only be a string literal.\"\n        );\n      }\n    }\n    if (type === \"text/css\") {\n      type = \"css\";\n    }\n    if (tag.node.var && !type.startsWith(\"module\")) {\n      type = \"module.\" + type;\n    }\n    const body = tag.get(\"body\").get(\"body\");\n    const markoText = body[0];\n    if (body.length !== 1 || !markoText.isMarkoText()) {\n      throw (markoText.isMarkoText() ? body[1] : body[0]).buildCodeFrameError(\n        \"The `style` tag currently only supports static content.\"\n      );\n    }\n    const { resolveVirtualDependency } = getMarkoOpts();\n    const start = (0, import_babel_utils32.getStart)(file, markoText.node);\n    const end = (0, import_babel_utils32.getEnd)(file, markoText.node);\n    let code = markoText.node.value;\n    let map2;\n    if (resolveVirtualDependency && sourceMaps && start !== null && end !== null) {\n      const magicString = new MagicString(file.code, { filename });\n      magicString.remove(0, start);\n      magicString.remove(end, file.code.length);\n      map2 = magicString.generateMap({\n        source: filename,\n        includeContent: true\n      });\n      if (sourceMaps === \"inline\" || sourceMaps === \"both\") {\n        code += `\n/*# sourceMappingURL=${map2.toUrl()}*/`;\n        if (sourceMaps === \"inline\") {\n          map2 = void 0;\n        }\n      }\n    }\n    const importPath = resolveVirtualDependency?.(filename, {\n      virtualPath: `./${base}.${type}`,\n      code,\n      map: map2\n    });\n    if (importPath) {\n      if (!tag.node.var) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler41.types.importDeclaration([], import_compiler41.types.stringLiteral(importPath))\n        );\n      } else if (import_compiler41.types.isIdentifier(tag.node.var)) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler41.types.importDeclaration(\n            [import_compiler41.types.importDefaultSpecifier(tag.node.var)],\n            import_compiler41.types.stringLiteral(importPath)\n          )\n        );\n      } else {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler41.types.variableDeclaration(\"const\", [\n            import_compiler41.types.variableDeclarator(\n              tag.node.var,\n              (0, import_babel_utils32.importDefault)(file, importPath, \"style\")\n            )\n          ])\n        );\n      }\n    }\n    tag.remove();\n  },\n  attributes: {}\n};\n\n// src/core/index.ts\nvar core_default = {\n  taglibId,\n  \"<import>\": import_default,\n  \"<export>\": export_default,\n  \"<attrs>\": attrs_default,\n  \"<if>\": IfTag,\n  \"<else-if>\": ElseIfTag,\n  \"<else>\": ElseTag,\n  \"<for>\": for_default,\n  \"<let>\": let_default,\n  \"<const>\": const_default,\n  \"<define>\": define_default,\n  \"<effect>\": effect_default,\n  \"<do>\": do_default,\n  \"<log>\": log_default,\n  \"<debug>\": debug_default,\n  \"<lifecycle>\": lifecycle_default,\n  \"<id>\": id_default,\n  \"<html-comment>\": html_comment_default,\n  \"<return>\": return_default,\n  \"<style>\": style_default,\n  \"<await-reorderer>\": noop_default,\n  \"<init-widgets>\": noop_default,\n  \"<init-components>\": noop_default,\n  \"<static>\": static_default,\n  \"<server>\": server_default,\n  \"<client>\": client_default,\n  \"<__flush_here_and_after__>\": flush_here_and_after_default\n};\n\n// src/visitors/cdata.ts\nvar cdata_default = {\n  translate: {\n    enter(cdata) {\n      throw cdata.buildCodeFrameError(\n        \"CDATA sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/visitors/comment.ts\nvar comment_default = {\n  translate: {\n    exit(comment) {\n      comment.remove();\n    }\n  }\n};\n\n// src/visitors/declaration.ts\nvar declaration_default = {\n  translate: {\n    enter(decl) {\n      throw decl.buildCodeFrameError(\n        \"XML declarations sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/visitors/document-type.ts\nvar document_type_default = {\n  translate: {\n    exit(documentType) {\n      if (isOutputHTML()) {\n        writeTo(documentType)`<!${documentType.node.value}>`;\n      }\n      documentType.remove();\n    }\n  }\n};\n\n// src/visitors/import-declaration.ts\nvar import_babel_utils33 = require(\"@marko/babel-utils\");\nvar import_declaration_default = {\n  analyze(importDecl) {\n    const { node } = importDecl;\n    const { source } = node;\n    const { value } = source;\n    const tagImport = (0, import_babel_utils33.resolveTagImport)(importDecl, value);\n    if (tagImport) {\n      node.extra ??= {};\n      node.extra.tagImport = tagImport;\n      const tags = importDecl.hub.file.metadata.marko.tags;\n      if (!tags.includes(tagImport)) {\n        tags.push(tagImport);\n      }\n    }\n  },\n  translate: {\n    exit(importDecl) {\n      const { node } = importDecl;\n      const { extra } = node;\n      const tagImport = extra?.tagImport;\n      if (tagImport) {\n        node.source.value = tagImport;\n      }\n    }\n  }\n};\n\n// src/visitors/placeholder.ts\nvar import_babel_utils34 = require(\"@marko/babel-utils\");\nvar import_compiler42 = require(\"@marko/compiler\");\nvar kBinding2 = Symbol(\"placeholder node binding\");\nvar kSiblingText = Symbol(\"placeholder has sibling text\");\nvar ESCAPE_TYPES = {\n  script: \"escapeScript\",\n  style: \"escapeStyle\"\n};\nvar placeholder_default = {\n  analyze(placeholder) {\n    const { node } = placeholder;\n    const { confident, computed } = evaluate(placeholder);\n    if (!(confident && (node.escape || !computed))) {\n      (node.extra ??= {})[kBinding2] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        getOrCreateSection(placeholder),\n        void 0,\n        node.value.extra\n      );\n      analyzeSiblingText(placeholder);\n    }\n  },\n  translate: {\n    exit(placeholder) {\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(placeholder);\n      const { node } = placeholder;\n      const { value } = node;\n      const extra = node.extra;\n      const { confident, computed } = extra;\n      const nodeBinding = extra[kBinding2];\n      const canWriteHTML = isHTML || confident && (node.escape || !computed);\n      const method = canWriteHTML ? node.escape ? ESCAPE_TYPES[getParentTagName(placeholder)] || \"escapeXML\" : \"toString\" : node.escape ? \"data\" : \"html\";\n      const isStateful = isStatefulReferences(value.extra?.referencedBindings);\n      const siblingText = extra[kSiblingText];\n      if (confident && canWriteHTML) {\n        write2`${getHTMLRuntime()[method](computed)}`;\n      } else {\n        if (siblingText === 1 /* Before */) {\n          if (isHTML && isStateful) {\n            write2`<!>`;\n          }\n          visit(placeholder, 37 /* Replace */);\n        } else if (siblingText === 2 /* After */) {\n          visit(placeholder, 37 /* Replace */);\n        } else {\n          if (!isHTML) write2` `;\n          visit(placeholder, 32 /* Get */);\n        }\n        if (isHTML) {\n          write2`${callRuntime(method, value)}`;\n          if (isStateful) {\n            markNode(placeholder, nodeBinding);\n          }\n        } else {\n          addStatement(\n            \"render\",\n            getSection(placeholder),\n            value.extra?.referencedBindings,\n            import_compiler42.types.expressionStatement(\n              method === \"data\" ? callRuntime(\n                \"data\",\n                import_compiler42.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(nodeBinding),\n                  true\n                ),\n                value\n              ) : callRuntime(\n                \"html\",\n                scopeIdentifier,\n                value,\n                getScopeAccessorLiteral(nodeBinding)\n              )\n            )\n          );\n        }\n      }\n      enterShallow(placeholder);\n      placeholder.remove();\n    }\n  }\n};\nfunction getParentTagName({ parentPath }) {\n  return parentPath.isMarkoTag() && (0, import_babel_utils34.isNativeTag)(parentPath) && parentPath.node.name.value || \"\";\n}\nfunction analyzeSiblingText(placeholder) {\n  const placeholderExtra = placeholder.node.extra;\n  let prev = placeholder.getPrevSibling();\n  while (prev.node) {\n    const contentType = getNodeContentType(\n      prev,\n      \"endType\"\n    );\n    if (contentType === null) {\n      prev = prev.getPrevSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 1 /* Before */;\n    } else {\n      break;\n    }\n  }\n  if (!prev.node && import_compiler42.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 1 /* Before */;\n  }\n  let next = placeholder.getNextSibling();\n  while (next.node) {\n    const contentType = getNodeContentType(\n      next,\n      \"startType\"\n    );\n    if (contentType === null) {\n      next = next.getNextSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 2 /* After */;\n    } else {\n      break;\n    }\n  }\n  if (!next.node && import_compiler42.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 2 /* After */;\n  }\n  return placeholderExtra[kSiblingText] = 0 /* None */;\n}\n\n// src/visitors/referenced-identifier.ts\nvar import_compiler43 = require(\"@marko/compiler\");\nvar abortIdsByExpressionForSection = /* @__PURE__ */ new WeakMap();\nvar referenced_identifier_default = {\n  migrate(identifier) {\n    const { name } = identifier.node;\n    if (identifier.scope.hasBinding(name)) return;\n    switch (name) {\n      case \"out\":\n        if (import_compiler43.types.isMemberExpression(identifier.parent) && import_compiler43.types.isIdentifier(identifier.parent.property) && identifier.parent.property.name === \"global\") {\n          identifier.parentPath.replaceWith(import_compiler43.types.identifier(\"$global\"));\n        } else {\n          throw identifier.buildCodeFrameError(\n            \"Only `out.global` is supported for compatibility.\"\n          );\n        }\n        break;\n    }\n  },\n  translate(identifier) {\n    const { name } = identifier.node;\n    if (identifier.scope.hasBinding(name)) return;\n    switch (name) {\n      case \"$global\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler43.types.memberExpression(\n              import_compiler43.types.callExpression(importRuntime(\"getStreamData\"), []),\n              import_compiler43.types.identifier(\"global\")\n            )\n          );\n        } else {\n          identifier.replaceWith(\n            import_compiler43.types.memberExpression(scopeIdentifier, import_compiler43.types.identifier(\"$global\"))\n          );\n        }\n        break;\n      case \"$signal\":\n        if (isOutputHTML()) {\n          const section = getSection(identifier);\n          if (!section.hasCleanup) {\n            section.hasCleanup = true;\n            const exprRoot = getExprRoot(identifier);\n            const write2 = writeTo(exprRoot);\n            write2`${callRuntime(\"markResumeCleanup\", getScopeIdIdentifier(section))}`;\n          }\n          identifier.replaceWith(\n            import_compiler43.types.callExpression(\n              import_compiler43.types.arrowFunctionExpression(\n                [],\n                import_compiler43.types.blockStatement([\n                  import_compiler43.types.throwStatement(\n                    import_compiler43.types.newExpression(import_compiler43.types.identifier(\"Error\"), [\n                      import_compiler43.types.stringLiteral(\"Cannot use $signal in a server render.\")\n                    ])\n                  )\n                ])\n              ),\n              []\n            )\n          );\n        } else {\n          const section = getSection(identifier);\n          const exprRoot = getExprRoot(identifier);\n          let abortIdsByExpression = abortIdsByExpressionForSection.get(section);\n          let exprId;\n          if (abortIdsByExpression) {\n            exprId = abortIdsByExpression.get(exprRoot);\n          } else {\n            abortIdsByExpression = /* @__PURE__ */ new Map();\n            abortIdsByExpressionForSection.set(section, abortIdsByExpression);\n          }\n          if (!exprId) {\n            exprId = abortIdsByExpression.size;\n            abortIdsByExpression.set(exprRoot, exprId);\n            addStatement(\n              \"render\",\n              section,\n              exprRoot.node.extra?.referencedBindings,\n              import_compiler43.types.expressionStatement(\n                import_compiler43.types.callExpression(importRuntime(\"resetAbortSignal\"), [\n                  scopeIdentifier,\n                  import_compiler43.types.numericLiteral(exprId)\n                ])\n              )\n            );\n          }\n          identifier.replaceWith(\n            import_compiler43.types.callExpression(importRuntime(\"getAbortSignal\"), [\n              scopeIdentifier,\n              import_compiler43.types.numericLiteral(exprId)\n            ])\n          );\n        }\n    }\n  }\n};\n\n// src/visitors/scriptlet.ts\nvar scriptlet_default = {\n  analyze(scriptlet) {\n    mergeReferences(\n      getOrCreateSection(scriptlet),\n      scriptlet.node,\n      scriptlet.node.body\n    );\n  },\n  translate: {\n    exit(scriptlet) {\n      const { node } = scriptlet;\n      if (isOutputHTML()) {\n        if (node.static) return;\n        scriptlet.replaceWithMultiple(node.body);\n      } else {\n        if (node.target && node.target !== \"client\") {\n          scriptlet.remove();\n        } else if (node.static) {\n          scriptlet.replaceWithMultiple(node.body);\n        } else {\n          addStatement(\n            \"render\",\n            getSection(scriptlet),\n            node.extra?.referencedBindings,\n            node.body\n          );\n          scriptlet.remove();\n        }\n      }\n    }\n  }\n};\n\n// src/visitors/tag/index.ts\nvar import_babel_utils38 = require(\"@marko/babel-utils\");\nvar import_compiler47 = require(\"@marko/compiler\");\n\n// src/visitors/tag/attribute-tag.ts\nvar import_babel_utils35 = require(\"@marko/babel-utils\");\nvar import_compiler44 = require(\"@marko/compiler\");\nvar attribute_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils35.assertNoVar)(tag);\n      (0, import_babel_utils35.assertNoArgs)(tag);\n      startSection(tag.get(\"body\"));\n      if (!(0, import_babel_utils35.findParentTag)(tag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags must be nested within another tag.\");\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n      }\n    }\n  }\n};\n\n// src/visitors/tag/custom-tag.ts\nvar import_babel_utils36 = require(\"@marko/babel-utils\");\nvar import_compiler45 = require(\"@marko/compiler\");\nvar import_path3 = __toESM(require(\"path\"));\nvar kChildScopeBinding = Symbol(\"custom tag child scope\");\nvar custom_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils36.assertAttributesOrSingleArg)(tag);\n      analyzeAttributeTags(tag);\n      const templateFile = (0, import_babel_utils36.getTagTemplate)(tag);\n      if (!templateFile) {\n        const tagName = getTagName(tag);\n        if (tagName && tag.scope.hasBinding(tagName)) {\n          throw tag.get(\"name\").buildCodeFrameError(\n            `Local variables must in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n          );\n        }\n        throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n      }\n      const section = getOrCreateSection(tag);\n      const tagBody = tag.get(\"body\");\n      const tagExtra = tag.node.extra ??= {};\n      startSection(tagBody);\n      trackVarReferences(tag, 4 /* derived */);\n      trackParamsReferences(tagBody, 3 /* param */);\n      tagExtra[kChildScopeBinding] = createBinding(\n        \"#childScope\",\n        0 /* dom */,\n        section,\n        void 0,\n        tagExtra\n      );\n      const childFile = (0, import_babel_utils36.loadFileForTag)(tag);\n      if (childFile.opts.filename === tag.hub.file.opts.filename) {\n        mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n      } else {\n        const childProgramExtra = childFile?.ast.program.extra;\n        analyzeAttrs(\n          section,\n          tag,\n          childProgramExtra?.domExports.params?.props?.[0]\n        );\n        currentProgramPath.node.extra.hasInteractiveChild = childProgramExtra?.isInteractive || childProgramExtra?.hasInteractiveChild || false;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML(tag);\n      } else {\n        translateDOM(tag);\n      }\n    }\n  }\n};\nfunction translateHTML(tag) {\n  const tagBody = tag.get(\"body\");\n  const { node } = tag;\n  let tagIdentifier;\n  flushInto(tag);\n  writeHTMLResumeStatements(tagBody);\n  if (import_compiler45.types.isStringLiteral(node.name)) {\n    const relativePath = getTagRelativePath(tag);\n    tagIdentifier = isCircularRequest(tag.hub.file, relativePath) ? htmlRendererIdentifier : (0, import_babel_utils36.importDefault)(tag.hub.file, relativePath, getTagName(tag));\n  } else {\n    tagIdentifier = node.name;\n  }\n  const tagVar = node.var;\n  const section = getSection(tag);\n  const childScopeBinding = node.extra[kChildScopeBinding];\n  const peekScopeId = tag.scope.generateUidIdentifier(childScopeBinding?.name);\n  tag.insertBefore(\n    import_compiler45.types.variableDeclaration(\"const\", [\n      import_compiler45.types.variableDeclarator(peekScopeId, callRuntime(\"peekNextScope\"))\n    ])\n  );\n  getSerializedScopeProperties(section).set(\n    getScopeAccessorLiteral(childScopeBinding),\n    callRuntime(\"writeExistingScope\", peekScopeId)\n  );\n  const inputExport = (0, import_babel_utils36.loadFileForTag)(tag)?.ast.program.extra?.domExports?.params?.props?.[0];\n  const { properties, statements } = inputExport ? translateAttrs(tag, inputExport.props) : {\n    properties: [],\n    statements: []\n  };\n  if (node.extra.tagNameNullable) {\n    const renderBodyProp = getTranslatedRenderBodyProperty(properties);\n    let renderBodyId = void 0;\n    if (renderBodyProp) {\n      const renderBodyExpression = renderBodyProp.value;\n      renderBodyProp.value = renderBodyId = tag.scope.generateUidIdentifier(\"renderBody\");\n      const [renderBodyPath] = tag.insertBefore(\n        import_compiler45.types.variableDeclaration(\"const\", [\n          import_compiler45.types.variableDeclarator(\n            renderBodyId,\n            // TODO: only register if needed (child template analysis)\n            renderBodyExpression\n          )\n        ])\n      );\n      renderBodyPath.skip();\n    }\n    let renderTagExpr = callExpression(\n      tagIdentifier,\n      propsToExpression(properties)\n    );\n    if (tagVar) {\n      translateVar(tag, import_compiler45.types.unaryExpression(\"void\", import_compiler45.types.numericLiteral(0)), \"let\");\n      renderTagExpr = import_compiler45.types.assignmentExpression(\"=\", tagVar, renderTagExpr);\n    }\n    statements.push(\n      import_compiler45.types.ifStatement(\n        tagIdentifier,\n        import_compiler45.types.expressionStatement(renderTagExpr),\n        renderBodyId && callStatement(renderBodyId)\n      )\n    );\n  } else if (tagVar) {\n    translateVar(\n      tag,\n      callExpression(\n        tagIdentifier,\n        propsToExpression(properties),\n        callRuntime(\n          \"register\",\n          import_compiler45.types.arrowFunctionExpression([], import_compiler45.types.blockStatement([])),\n          import_compiler45.types.stringLiteral(\n            getResumeRegisterId(\n              section,\n              node.var.extra?.binding\n              // TODO: node.var is not always an identifier.\n            )\n          ),\n          getScopeIdIdentifier(section)\n        )\n      )\n    );\n    setForceResumeScope(section);\n  } else {\n    statements.push(\n      callStatement(tagIdentifier, propsToExpression(properties))\n    );\n  }\n  for (const replacement of tag.replaceWithMultiple(statements)) {\n    replacement.skip();\n  }\n}\nfunction translateDOM(tag) {\n  const tagSection = getSection(tag);\n  const { node } = tag;\n  const extra = node.extra;\n  const childScopeBinding = extra[kChildScopeBinding];\n  const write2 = writeTo(tag);\n  const { file } = tag.hub;\n  const tagName = import_compiler45.types.isIdentifier(node.name) ? node.name.name : import_compiler45.types.isStringLiteral(node.name) ? node.name.value : \"tag\";\n  const relativePath = getTagRelativePath(tag);\n  const childFile = (0, import_babel_utils36.loadFileForTag)(tag);\n  const childExports = childFile.ast.program.extra.domExports;\n  const tagIdentifier = importOrSelfReferenceName(\n    file,\n    relativePath,\n    childExports.setup,\n    tagName\n  );\n  const inputExport = childExports.params?.props?.[0];\n  if (inputExport) {\n    writeAttrsToExports(tag, inputExport, `${getTagName(tag) || \"tag\"}_input`, {\n      circular: childFile.opts.filename === file.opts.filename,\n      tagSection,\n      relativePath,\n      childScopeBinding\n    });\n  }\n  write2`${(0, import_babel_utils36.importNamed)(file, relativePath, childExports.template, `${tagName}_template`)}`;\n  injectWalks(\n    tag,\n    (0, import_babel_utils36.importNamed)(file, relativePath, childExports.walks, `${tagName}_walks`)\n  );\n  if (node.var) {\n    const source = initValue(\n      // TODO: support destructuring\n      node.var.extra.binding\n    );\n    source.register = true;\n    addStatement(\n      \"render\",\n      tagSection,\n      void 0,\n      import_compiler45.types.expressionStatement(\n        callRuntime(\n          \"setTagVar\",\n          scopeIdentifier,\n          getScopeAccessorLiteral(childScopeBinding),\n          source.identifier\n        )\n      )\n    );\n  }\n  addStatement(\n    \"render\",\n    tagSection,\n    void 0,\n    import_compiler45.types.expressionStatement(\n      import_compiler45.types.callExpression(tagIdentifier, [\n        createScopeReadExpression(tagSection, childScopeBinding)\n      ])\n    )\n  );\n  tag.remove();\n}\nfunction getTagRelativePath(tag) {\n  const {\n    node,\n    hub: { file }\n  } = tag;\n  let relativePath;\n  if (import_compiler45.types.isStringLiteral(node.name)) {\n    const template = (0, import_babel_utils36.getTagTemplate)(tag);\n    relativePath = template && (0, import_babel_utils36.resolveRelativePath)(file, template);\n  } else if (node.extra?.tagNameImported) {\n    relativePath = node.extra.tagNameImported;\n  }\n  if (!relativePath) {\n    const tagName = getTagName(tag);\n    if (tagName && tag.scope.hasBinding(tagName)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        `Local variables must in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n      );\n    }\n    throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n  }\n  return relativePath;\n}\nfunction analyzeAttrs(section, tag, templateExport) {\n  if (!templateExport) {\n    dropReferences(getAllTagReferenceNodes(tag.node));\n    return;\n  }\n  if (!templateExport.props || tag.node.arguments?.length) {\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n    return;\n  }\n  const attrTagLookup = analyzeAttributeTags(tag);\n  const seen = /* @__PURE__ */ new Set();\n  if (attrTagLookup) {\n    const nodeReferencesByGroup = /* @__PURE__ */ new Map();\n    const analyzeDynamicChildGroup = (group, child) => {\n      const referenceNodes = getAllTagReferenceNodes(child.node);\n      const groupReferences = nodeReferencesByGroup.get(group);\n      if (groupReferences) {\n        groupReferences.referenceNodes = groupReferences.referenceNodes.concat(referenceNodes);\n      } else {\n        nodeReferencesByGroup.set(group, {\n          firstTag: child,\n          referenceNodes\n        });\n      }\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    for (const child of tag.get(\"attributeTags\")) {\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils36.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExports = templateExport.props[attrTagMeta.name];\n          if (childAttrExports) {\n            if (childAttrExports.props && !attrTagMeta.dynamic) {\n              analyzeAttrs(section, child, childAttrExports);\n            } else {\n              analyzeDynamicChildGroup(attrTagMeta.group, child);\n            }\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        } else {\n          const group = child.node.extra.attributeTagGroup;\n          let childUsesGroupProp = false;\n          for (const name of group) {\n            if (templateExport.props[attrTagLookup[name].name]) {\n              childUsesGroupProp = true;\n              break;\n            }\n          }\n          if (childUsesGroupProp) {\n            analyzeDynamicChildGroup(group, child);\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        }\n      }\n    }\n    for (const { firstTag, referenceNodes } of nodeReferencesByGroup.values()) {\n      mergeReferences(section, firstTag.node, referenceNodes);\n    }\n  }\n  const { attributes } = tag.node;\n  let spreadReferenceNodes;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler45.types.isMarkoAttribute(attr2)) {\n      if (seen.has(attr2.name) || !templateExport.props[attr2.name]) {\n        dropReferences(attr2.value);\n        continue;\n      }\n      seen.add(attr2.name);\n    }\n    if (spreadReferenceNodes) {\n      spreadReferenceNodes.push(attr2.value);\n    } else if (import_compiler45.types.isMarkoSpreadAttribute(attr2)) {\n      spreadReferenceNodes = [attr2.value];\n    }\n  }\n  if (spreadReferenceNodes) {\n    mergeReferences(section, tag.node, spreadReferenceNodes);\n  }\n}\nfunction writeAttrsToExports(tag, templateExport, importAlias, info) {\n  if (tag.node.arguments?.length) {\n    const [arg] = tag.node.arguments;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    addValue(\n      info.tagSection,\n      // technically this should be `arg.extra?.referencedBindings`\n      // but we should probably ensure all other references are dropped in this case before we do that.\n      tag.node.extra?.referencedBindings,\n      identifierToSignal(tagInputIdentifier),\n      import_compiler45.types.isSpreadElement(arg) ? import_compiler45.types.memberExpression(arg.argument, import_compiler45.types.numericLiteral(0)) : arg,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding),\n      callRuntime(\n        \"inChild\",\n        getScopeAccessorLiteral(info.childScopeBinding),\n        import_compiler45.types.identifier(tagInputIdentifier.name)\n      )\n    );\n    return;\n  }\n  if (!templateExport.props || info.circular) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    const translatedAttrs = translateAttrs(tag);\n    if (translatedAttrs.statements.length) {\n      addStatement(\n        \"render\",\n        info.tagSection,\n        referencedBindings,\n        translatedAttrs.statements\n      );\n    }\n    addValue(\n      info.tagSection,\n      referencedBindings,\n      identifierToSignal(tagInputIdentifier),\n      propsToExpression(translatedAttrs.properties),\n      createScopeReadExpression(info.tagSection, info.childScopeBinding),\n      callRuntime(\n        \"inChild\",\n        getScopeAccessorLiteral(info.childScopeBinding),\n        import_compiler45.types.identifier(tagInputIdentifier.name)\n      )\n    );\n    return;\n  }\n  const seen = /* @__PURE__ */ new Set();\n  const attrTagLookup = analyzeAttributeTags(tag);\n  if (attrTagLookup) {\n    const attrTags2 = tag.get(\"attributeTags\");\n    const statementsByGroup = /* @__PURE__ */ new Map();\n    const translateDynamicAttrTagChildInGroup = (group, index) => {\n      const child = attrTags2[index];\n      let statements = statementsByGroup.get(group)?.statements;\n      if (!statements) {\n        statements = [];\n        statementsByGroup.set(group, {\n          referencedBindings: child.node.extra?.referencedBindings,\n          statements\n        });\n      }\n      return addDynamicAttrTagStatements(\n        attrTags2,\n        index,\n        attrTagLookup,\n        statements,\n        templateExport.props\n      );\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils36.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExport = templateExport.props[attrTagMeta.name];\n          if (childAttrExport) {\n            if (attrTagMeta.dynamic) {\n              i = translateDynamicAttrTagChildInGroup(attrTagMeta.group, i);\n            } else {\n              writeAttrsToExports(\n                child,\n                childAttrExport,\n                `${importAlias}_${attrTagMeta.name}`,\n                info\n              );\n            }\n          }\n        } else if (child.node.extra?.attributeTagGroup) {\n          i = translateDynamicAttrTagChildInGroup(\n            child.node.extra.attributeTagGroup,\n            i\n          );\n        }\n      }\n    }\n    for (const [\n      group,\n      { referencedBindings, statements }\n    ] of statementsByGroup) {\n      const decls = [];\n      for (const name of group) {\n        const attrTagMeta = attrTagLookup[name];\n        const childAttrExports = templateExport.props[attrTagMeta.name];\n        if (!childAttrExports) continue;\n        const attrExportIdentifier = importOrSelfReferenceName(\n          tag.hub.file,\n          info.relativePath,\n          childAttrExports.id,\n          `${importAlias}_${attrTagMeta.name}`\n        );\n        decls.push(import_compiler45.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta)));\n        addValue(\n          info.tagSection,\n          referencedBindings,\n          identifierToSignal(attrExportIdentifier),\n          getAttrTagIdentifier(attrTagMeta),\n          createScopeReadExpression(info.tagSection, info.childScopeBinding),\n          callRuntime(\n            \"inChild\",\n            getScopeAccessorLiteral(info.childScopeBinding),\n            import_compiler45.types.identifier(attrExportIdentifier.name)\n          )\n        );\n      }\n      addStatement(\"render\", info.tagSection, referencedBindings, [\n        import_compiler45.types.variableDeclaration(\"let\", decls),\n        ...statements\n      ]);\n    }\n  }\n  const bodySection = tag.node.body.extra?.section;\n  if (bodySection && !seen.has(\"renderBody\")) {\n    seen.add(\"renderBody\");\n    if (templateExport.props.renderBody) {\n      const renderBodyExportIdentifier = (0, import_babel_utils36.importNamed)(\n        tag.hub.file,\n        info.relativePath,\n        templateExport.props.renderBody.id,\n        `${importAlias}_renderBody`\n      );\n      addValue(\n        info.tagSection,\n        void 0,\n        // TODO: pretty sure renderBody needs to have the reference group of it's param defaults.\n        identifierToSignal(renderBodyExportIdentifier),\n        import_compiler45.types.callExpression(import_compiler45.types.identifier(bodySection.name), [scopeIdentifier]),\n        createScopeReadExpression(info.tagSection, info.childScopeBinding),\n        callRuntime(\n          \"inChild\",\n          getScopeAccessorLiteral(info.childScopeBinding),\n          import_compiler45.types.identifier(renderBodyExportIdentifier.name)\n        )\n      );\n    }\n  }\n  const { attributes } = tag.node;\n  const staticAttrs = [];\n  let spreadProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler45.types.isMarkoAttribute(attr2)) {\n      const childAttrExports = templateExport.props[attr2.name];\n      if (!childAttrExports || seen.has(attr2.name)) continue;\n      seen.add(attr2.name);\n      if (spreadProps) {\n        spreadProps.push(\n          import_compiler45.types.objectProperty(toPropertyName(attr2.name), attr2.value)\n        );\n        continue;\n      }\n      staticAttrs.push(attr2);\n    } else if (spreadProps) {\n      spreadProps.push(import_compiler45.types.spreadElement(attr2.value));\n    } else {\n      spreadProps = [import_compiler45.types.spreadElement(attr2.value)];\n    }\n  }\n  for (const attr2 of staticAttrs.reverse()) {\n    const childAttrExports = templateExport.props[attr2.name];\n    const attrExportIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      childAttrExports.id,\n      `${importAlias}_${attr2.name}`\n    );\n    addValue(\n      info.tagSection,\n      attr2.value.extra?.referencedBindings,\n      identifierToSignal(attrExportIdentifier),\n      attr2.value,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding),\n      callRuntime(\n        \"inChild\",\n        getScopeAccessorLiteral(info.childScopeBinding),\n        import_compiler45.types.identifier(attrExportIdentifier.name)\n      )\n    );\n  }\n  const missing = new Set(Object.keys(templateExport.props));\n  for (const name of seen) missing.delete(name);\n  if (missing.size) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    let getMissingPropValue = buildUndefined2;\n    if (spreadProps) {\n      const spreadId = tag.scope.generateUidIdentifier(`${importAlias}_spread`);\n      spreadProps.reverse();\n      getMissingPropValue = (name) => import_compiler45.types.memberExpression(spreadId, toPropertyName(name));\n      addStatement(\"render\", info.tagSection, referencedBindings, [\n        import_compiler45.types.variableDeclaration(\"const\", [\n          import_compiler45.types.variableDeclarator(spreadId, propsToExpression(spreadProps))\n        ])\n      ]);\n    }\n    for (const name of missing) {\n      const childAttrExports = templateExport.props[name];\n      const attrExportIdentifier = importOrSelfReferenceName(\n        tag.hub.file,\n        info.relativePath,\n        childAttrExports.id,\n        `${importAlias}_${name}`\n      );\n      addValue(\n        info.tagSection,\n        referencedBindings,\n        identifierToSignal(attrExportIdentifier),\n        getMissingPropValue(name),\n        createScopeReadExpression(info.tagSection, info.childScopeBinding),\n        callRuntime(\n          \"inChild\",\n          getScopeAccessorLiteral(info.childScopeBinding),\n          import_compiler45.types.identifier(attrExportIdentifier.name)\n        )\n      );\n    }\n  }\n}\nfunction importOrSelfReferenceName(file, request, name, nameHint) {\n  if (isCircularRequest(file, request)) {\n    return import_compiler45.types.identifier(name);\n  }\n  return (0, import_babel_utils36.importNamed)(file, request, name, nameHint);\n}\nfunction isCircularRequest(file, request) {\n  const { filename } = file.opts;\n  return request === filename || request[0] === \".\" && import_path3.default.resolve(filename, \"..\", request) === filename;\n}\nfunction callStatement(id, ...args) {\n  return import_compiler45.types.expressionStatement(callExpression(id, ...args));\n}\nfunction callExpression(id, ...args) {\n  return import_compiler45.types.callExpression(id, args.filter(Boolean));\n}\nfunction identifierToSignal(identifier) {\n  return {\n    identifier,\n    hasDownstreamIntersections: always\n  };\n}\nfunction buildUndefined2() {\n  return import_compiler45.types.unaryExpression(\"void\", import_compiler45.types.numericLiteral(0));\n}\nfunction always() {\n  return true;\n}\n\n// src/visitors/tag/dynamic-tag.ts\nvar import_babel_utils37 = require(\"@marko/babel-utils\");\nvar import_compiler46 = require(\"@marko/compiler\");\nvar kDOMBinding = Symbol(\"dynamic tag dom binding\");\nvar dynamic_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils37.assertAttributesOrArgs)(tag);\n      analyzeAttributeTags(tag);\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      const tagBody = tag.get(\"body\");\n      const domBinding = tagExtra[kDOMBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section,\n        void 0,\n        tagExtra\n      );\n      startSection(tagBody);\n      trackVarReferences(tag, 4 /* derived */);\n      trackParamsReferences(tagBody, 3 /* param */);\n      mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n      addReferenceToExpression(tag, domBinding);\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag, 37 /* Replace */);\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const extra = node.extra;\n      const nodeRef2 = extra[kDOMBinding];\n      const section = getSection(tag);\n      let tagExpression = node.name;\n      if (import_compiler46.types.isStringLiteral(tagExpression)) {\n        tagExpression = (0, import_babel_utils37.importDefault)(\n          tag.hub.file,\n          getTagRelativePath(tag),\n          tagExpression.value\n        );\n      }\n      if (extra.featureType === \"class\") {\n        const compatRuntimeFile = getCompatRuntimeFile(tag.hub.file.markoOpts);\n        (0, import_babel_utils37.importDefault)(tag.hub.file, compatRuntimeFile);\n        if (isOutputHTML()) {\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler46.types.expressionStatement(\n              import_compiler46.types.callExpression(\n                (0, import_babel_utils37.importNamed)(tag.hub.file, compatRuntimeFile, \"s\"),\n                [\n                  import_compiler46.types.identifier(tagExpression.name),\n                  import_compiler46.types.stringLiteral((0, import_babel_utils37.loadFileForTag)(tag).metadata.marko.id)\n                ]\n              )\n            )\n          );\n        } else {\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler46.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                import_compiler46.types.stringLiteral((0, import_babel_utils37.loadFileForTag)(tag).metadata.marko.id),\n                import_compiler46.types.identifier(tagExpression.name)\n              )\n            )\n          );\n        }\n      }\n      const { properties, statements } = translateAttrs(tag);\n      const args = [];\n      let hasMultipleArgs = false;\n      if (node.arguments?.length) {\n        args.push(...node.arguments);\n        if (properties.length) {\n          hasMultipleArgs = true;\n          args.push(propsToExpression(properties));\n        } else {\n          hasMultipleArgs = node.arguments.length > 1 || import_compiler46.types.isSpreadElement(node.arguments[0]);\n        }\n      } else {\n        const renderBodyProp = getTranslatedRenderBodyProperty(properties);\n        if (renderBodyProp) {\n          properties.splice(properties.indexOf(renderBodyProp), 1);\n          args.push(propsToExpression(properties), renderBodyProp.value);\n        } else {\n          args.push(propsToExpression(properties));\n        }\n      }\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        const write2 = writeTo(tag);\n        if (node.var) {\n          if (!hasMultipleArgs && args.length === 1) {\n            args.push(import_compiler46.types.unaryExpression(\"void\", import_compiler46.types.numericLiteral(0)));\n          }\n          args.push(\n            callRuntime(\n              \"register\",\n              import_compiler46.types.arrowFunctionExpression([], import_compiler46.types.blockStatement([])),\n              import_compiler46.types.stringLiteral(\n                getResumeRegisterId(\n                  section,\n                  node.var.extra?.binding\n                  // TODO: node.var is not always an identifier.\n                )\n              ),\n              getScopeIdIdentifier(section)\n            )\n          );\n        }\n        const dynamicScopeIdentifier = currentProgramPath.scope.generateUidIdentifier(\"dynamicScope\");\n        const dynamicTagExpr = hasMultipleArgs ? callRuntime(\n          \"dynamicTagArgs\",\n          dynamicScopeIdentifier,\n          tagExpression,\n          import_compiler46.types.arrayExpression(args)\n        ) : callRuntime(\n          \"dynamicTagInput\",\n          dynamicScopeIdentifier,\n          tagExpression,\n          ...args\n        );\n        statements.push(\n          import_compiler46.types.variableDeclaration(\"const\", [\n            import_compiler46.types.variableDeclarator(\n              dynamicScopeIdentifier,\n              callRuntime(\"peekNextScope\")\n            )\n          ])\n        );\n        statements.push(\n          node.var ? import_compiler46.types.variableDeclaration(\"const\", [\n            import_compiler46.types.variableDeclarator(node.var, dynamicTagExpr)\n          ]) : import_compiler46.types.expressionStatement(dynamicTagExpr)\n        );\n        write2`${callRuntime(\n          \"markResumeControlEnd\",\n          getScopeIdIdentifier(section),\n          getScopeAccessorLiteral(nodeRef2)\n        )}`;\n        getSerializedScopeProperties(section).set(\n          import_compiler46.types.stringLiteral(\n            getScopeAccessorLiteral(nodeRef2).value + \"!\" /* ConditionalScope */\n          ),\n          callRuntime(\"writeExistingScope\", dynamicScopeIdentifier)\n        );\n        getSerializedScopeProperties(section).set(\n          import_compiler46.types.stringLiteral(\n            getScopeAccessorLiteral(nodeRef2).value + \"(\" /* ConditionalRenderer */\n          ),\n          callRuntime(\n            \"normalizeDynamicRenderer\",\n            import_compiler46.types.isIdentifier(tagExpression) ? import_compiler46.types.identifier(tagExpression.name) : tagExpression\n          )\n        );\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      } else {\n        const section2 = getSection(tag);\n        const bodySection = getSectionForBody(tag.get(\"body\"));\n        const signal = getSignal(section2, nodeRef2, \"dynamicTagName\");\n        signal.build = () => {\n          return callRuntime(\n            \"conditional\",\n            getScopeAccessorLiteral(nodeRef2),\n            getSignalFn(signal, [scopeIdentifier]),\n            buildSignalIntersections(signal)\n          );\n        };\n        signal.hasDownstreamIntersections = () => true;\n        addValue(\n          section2,\n          node.name.extra?.referencedBindings,\n          signal,\n          bodySection ? import_compiler46.types.logicalExpression(\n            \"||\",\n            tagExpression,\n            import_compiler46.types.callExpression(import_compiler46.types.identifier(bodySection.name), [\n              scopeIdentifier\n            ])\n          ) : tagExpression\n        );\n        if (tag.node.var) {\n          const source = initValue(\n            // TODO: support destructuring\n            tag.node.var.extra.binding\n          );\n          source.register = true;\n          addStatement(\n            \"render\",\n            section2,\n            nodeRef2,\n            import_compiler46.types.expressionStatement(\n              callRuntime(\n                \"setTagVar\",\n                scopeIdentifier,\n                import_compiler46.types.stringLiteral(\n                  getScopeAccessorLiteral(extra[kDOMBinding]).value + \"!\" /* ConditionalScope */\n                ),\n                source.identifier\n              )\n            )\n          );\n        }\n        if (args.length) {\n          const argsOrInput = hasMultipleArgs ? import_compiler46.types.arrayExpression(args) : args[0];\n          const attrsGetter = import_compiler46.types.arrowFunctionExpression(\n            [],\n            statements.length ? import_compiler46.types.blockStatement(\n              statements.concat(import_compiler46.types.returnStatement(argsOrInput))\n            ) : argsOrInput\n          );\n          const id = currentProgramPath.scope.generateUidIdentifier(\n            tag.get(\"name\").toString() + \"_input\"\n          );\n          let added = false;\n          addValue(\n            section2,\n            node.extra?.referencedBindings,\n            {\n              get identifier() {\n                if (!added) {\n                  currentProgramPath.pushContainer(\n                    \"body\",\n                    import_compiler46.types.variableDeclaration(\"const\", [\n                      import_compiler46.types.variableDeclarator(\n                        id,\n                        callRuntime(\n                          \"dynamicTagAttrs\",\n                          getScopeAccessorLiteral(nodeRef2),\n                          bodySection && import_compiler46.types.identifier(bodySection.name),\n                          hasMultipleArgs && import_compiler46.types.numericLiteral(1)\n                        )\n                      )\n                    ])\n                  );\n                  added = true;\n                }\n                return id;\n              },\n              hasDownstreamIntersections: () => true\n            },\n            attrsGetter\n          );\n        }\n        tag.remove();\n      }\n    }\n  }\n};\nfunction getCompatRuntimeFile(markoOpts) {\n  return `marko/src/runtime/helpers/tags-compat/${isOutputHTML() ? \"html\" : \"dom\"}${markoOpts.optimize ? \"\" : \"-debug\"}.${markoOpts.modules === \"esm\" ? \"mjs\" : \"js\"}`;\n}\n\n// src/visitors/tag/index.ts\nvar tag_default = {\n  transform: {\n    enter(tag) {\n      const attrs2 = tag.get(\"attributes\");\n      for (let i = 0; i < attrs2.length; i++) {\n        const attr2 = attrs2[i];\n        if (import_compiler47.types.isMarkoAttribute(attr2.node) && attr2.node.bound) {\n          attr2.node.bound = false;\n          const changeValue = getChangeHandler(tag, attr2);\n          if (changeValue === null) {\n            throw attr2.buildCodeFrameError(\n              \"Attributes may only be bound to identifiers or member expressions\"\n            );\n          }\n          tag.node.attributes.splice(\n            ++i,\n            0,\n            import_compiler47.types.markoAttribute(attr2.node.name + \"Change\", changeValue)\n          );\n          tag.scope.crawl();\n        }\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils38.getTagDef)(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        enter2(hook, tag);\n        return;\n      }\n      if (type === 0 /* NativeTag */) {\n        native_tag_default.analyze.enter(tag);\n        return;\n      }\n      switch (type) {\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.analyze.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.analyze.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const hook = (0, import_babel_utils38.getTagDef)(tag)?.analyzer?.hook;\n      if (hook) {\n        exit2(hook, tag);\n        return;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils38.getTagDef)(tag);\n      const extra = tag.node.extra;\n      if (tagDef?.translator) {\n        if (tagDef.translator.path) {\n          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);\n        }\n        enter2(tagDef.translator.hook, tag);\n        return;\n      }\n      for (const attr2 of tag.get(\"attributes\")) {\n        if (attr2.isMarkoAttribute()) {\n          if (attr2.node.arguments) {\n            throw attr2.buildCodeFrameError(\n              `Unsupported arguments on the \\`${attr2.node.name}\\` attribute.`\n            );\n          }\n          if (attr2.node.modifier) {\n            if ((0, import_babel_utils38.isNativeTag)(attr2.parentPath)) {\n              attr2.node.name += `:${attr2.node.modifier}`;\n            } else {\n              throw attr2.buildCodeFrameError(\n                `Unsupported modifier \\`${attr2.node.modifier}\\`.`\n              );\n            }\n          }\n        }\n      }\n      if (extra.tagNameDynamic && extra.tagNameNullable && !tag.get(\"name\").isIdentifier() && isOutputHTML()) {\n        const tagNameId = tag.scope.generateUidIdentifier(\"tagName\");\n        const [tagNameVarPath] = tag.insertBefore(\n          import_compiler47.types.variableDeclaration(\"const\", [\n            import_compiler47.types.variableDeclarator(tagNameId, tag.node.name)\n          ])\n        );\n        tagNameVarPath.skip();\n        tag.set(\"name\", tagNameId);\n      }\n      switch (extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const translator = (0, import_babel_utils38.getTagDef)(tag)?.translator;\n      if (translator) {\n        exit2(translator.hook, tag);\n        return;\n      }\n      switch (tag.node.extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.exit(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.exit(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.exit(tag);\n          break;\n      }\n    }\n  }\n};\nfunction getChangeHandler(tag, attr2) {\n  if (import_compiler47.types.isIdentifier(attr2.node.value)) {\n    const valueId = tag.scope.generateUidIdentifier(\n      \"new_\" + attr2.node.value.name\n    );\n    return import_compiler47.types.functionExpression(\n      null,\n      [valueId],\n      import_compiler47.types.blockStatement([\n        import_compiler47.types.expressionStatement(\n          import_compiler47.types.assignmentExpression(\"=\", attr2.node.value, valueId)\n        )\n      ])\n    );\n  } else if (import_compiler47.types.isMemberExpression(attr2.node.value)) {\n    const prop = attr2.node.value.property;\n    if (import_compiler47.types.isPrivateName(prop)) return null;\n    if (import_compiler47.types.isIdentifier(prop)) {\n      return import_compiler47.types.memberExpression(\n        import_compiler47.types.cloneNode(attr2.node.value.object),\n        import_compiler47.types.identifier(prop.name + \"Change\")\n      );\n    } else {\n      return import_compiler47.types.memberExpression(\n        import_compiler47.types.cloneNode(attr2.node.value.object),\n        import_compiler47.types.binaryExpression(\"+\", import_compiler47.types.cloneNode(prop), import_compiler47.types.stringLiteral(\"Change\")),\n        true\n      );\n    }\n  }\n  return null;\n}\n\n// src/visitors/text.ts\nvar import_compiler48 = require(\"@marko/compiler\");\nvar text_default = {\n  translate: {\n    exit(text) {\n      writeTo(text)`${text.node.value}`;\n      enterShallow(text);\n      text.remove();\n    }\n  }\n};\n\n// src/index.ts\nvar visitors = extractVisitors({\n  Program: program_default,\n  Function: function_default,\n  AssignmentExpression: assignment_expression_default,\n  UpdateExpression: update_expression_default,\n  ReferencedIdentifier: referenced_identifier_default,\n  ImportDeclaration: import_declaration_default,\n  MarkoDocumentType: document_type_default,\n  MarkoDeclaration: declaration_default,\n  MarkoCDATA: cdata_default,\n  MarkoText: text_default,\n  MarkoTag: tag_default,\n  MarkoPlaceholder: placeholder_default,\n  MarkoScriptlet: scriptlet_default,\n  MarkoComment: comment_default\n});\nvar { transform, analyze, translate } = visitors;\nvar taglibs = [\n  [\n    __dirname,\n    {\n      ...core_default,\n      migrate: visitors.migrate\n    }\n  ]\n];\nfunction getRuntimeEntryFiles(output, optimize) {\n  return [\n    `@marko/runtime-tags${optimize ? \"\" : \"/debug\"}/${output === \"html\" ? \"html\" : \"dom\"}`\n  ];\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  analyze,\n  getRuntimeEntryFiles,\n  internalEntryBuilder,\n  taglibs,\n  transform,\n  translate\n});\n"],"names":["mod","__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__copyProps","to","from","except","desc","key","call","get","enumerable","__toESM","isNodeMode","target","__esModule","value","src_exports","__export","all","name","analyze","getRuntimeEntryFiles","internalEntryBuilder","entry_builder_default","taglibs","transform","translate","module","exports","import_babel_utils","require","getTagName","tag","node","taglibId","isCoreTag","id","isMarkoTag","getTagDef","isCoreTagName","isConditionTag","import_babel_utils2","flush_here_and_after_default","renderer","replaceWithMultiple","body","import_compiler","attrs_default","migrate","tagVar","var","type","remove","constTag","types","markoTag","stringLiteral","markoAttribute","identifier","markoTagBody","replaceWith","attributes","autocomplete","displayText","description","snippet","import_babel_utils3","import_compiler2","client_default","parse","hub","file","rawValue","code","replace","trim","start","length","parseStatements","isBlockStatement","markoScriptlet","parseOptions","statement","rawOpenTag","descriptionMoreURL","import_babel_utils11","import_compiler18","assertNoSpreadAttrs","attr2","isMarkoSpreadAttribute","buildCodeFrameError","assertNoBodyContent","import_babel_utils10","import_compiler16","import_path","bindingHasDownstreamExpressions","binding","downstreamExpressions","size","alias","aliases","propertyAliases","values","import_babel_utils4","import_compiler3","kState","Symbol","build","entryFile","state","path","imports","map","it","importDeclaration","init","unshift","importSpecifier","markoOpts","optimize","push","expressionStatement","callExpression","visit","visitChild","analyzedTags","metadata","marko","resolveRelativePath","opts","filename","extra","hasInteractiveChild","isInteractive","import_compiler6","getMarkoRoot","path4","curPath","parentPath","isMarko","getExprRoot","destructRoot","getDestructureRoot","isFunctionExpression","parent","isStatefulReferences","referencedBindings","Array","isArray","isStatefulBinding","ref","upstreamExpression","data","item","forEach","cb","i","find","findSorted","compare","max","pos","mid","cur","compareResult","addSorted","len","result","next","joinRepeatable","a","b","import_babel_utils6","import_compiler5","createProgramState","map2","WeakMap","currentProgramPath","set","createSectionState","section","arrayOfSectionData","import_babel_utils5","import_compiler4","withPreviousLocation","newNode","originalNode","loc","end","MARKO_FILE_REG","TAG_NAME_IDENTIFIER_REG","analyzeTagNameType","tagNameType","isStringLiteral","isNativeTag","bindingName","bindingIdentifier","scope","getBinding","test","tagIdentifier","analyzeExpressionTagName","childFile","loadFileForTag","childProgram","ast","program","featureType","tagNameNullable","pending","tagNameImported","nullable","pop","isConditionalExpression","alternate","isLogicalExpression","operator","isAssignmentExpression","isBinaryExpression","isTemplateLiteral","isNullLiteral","isIdentifier","kind","decl","source","specifiers","some","isImportDefaultSpecifier","resolvedImport","resolveTagImport","bindingTag","bindingTagName","tagNameDynamic","startSection","parentSection","getOrCreateSection","sectionNamePath","sectionName","isProgram","generateUid","toString","programExtra","sections","depth","params","closures","bindings","content","getContentInfo","hasCleanup","getSectionForBody","getSection","currentPath","getScopeIdIdentifier","generateUidIdentifier","getSectionParentIsOwner","setSectionParentIsOwner","_getScopeIdentifier","getScopeIdentifier","ignoreDefault","scopeId","forEachSection","fn","contentInfo","startType","endType","singleChild","endIndex","getNodeContentType","startIndex","extraMember","isMarkoText","isMarkoPlaceholder","isMarkoScriptlet","isMarkoComment","isAttributeTag","tagSection","isStatefulSection","checkStatefulClosures","immediateOnly","closure","getBindings","Set","getNextBindingId","setNextBindingId","createBinding","upstreamAlias","property","excludeProperties","serialize","Map","export","propBinding","add","trackVarReferences","changeBinding","canonicalUpstreamAlias","getCanonicalBinding","delete","createBindingsAndTrackReferences","trackParamsReferences","paramsBinding","assignBinding","prop","properties","element","elements","argument","lVal","babelBinding","referencePaths","constantViolations","referencePath","trackReference","left","isUpdateExpression","trackReferencesForBinding","patternBinding","Error","fnRoot","getFnRoot","exprRoot","reference","exprExtra","addReferenceToExpression","fnExtra","addReference","getMergedReferences","mergeReferences","nodes","compareIntersections","lenDelta","bindingUtil","isSuperset","subset","elem","has","getSourceBindings","derived","sources","crawl","binding2","curBinding","constructor","this","union","aLen","bLen","aIndex","bIndex","aValue","bValue","delta","unionSortedRepeatable","getIntersections","setIntersections","getDroppedReferences","dropReferences","droppedReferences","getAllTagReferenceNodes","referenceNodes","arguments","arg","child","attributeTags","findReferences","intersections","intersection","getScopeAccessorLiteral","getMarkoOpts","numericLiteral","pruneBinding","shouldPrune","import_compiler14","import_babel_utils7","import_compiler8","stringifyClassObject","NON_DIMENSIONAL","stringifyStyleObject","toDelimitedString","val","delimiter","stringify","curDelimiter","v","part","unsafeXMLReg","replaceUnsafeXML","c","escapeXML","str","unsafeScriptReg","escapeScript","unsafeStyleReg","escapeStyle","classAttr","stringAttr","styleAttr","attr","attrAssignment","RegExp","nonVoidAttr","escapeAttrValue","async","KNOWN_SYMBOLS2","symbol","AggregateError","of","ArrayBuffer","isView","Atomics","and","compareExchange","exchange","isLockFree","load","notify","or","store","sub","wait","BigInt","asIntN","asUintN","BigInt64Array","BigUint64Array","Boolean","console","assert","clear","count","countReset","debug","dir","dirxml","error","group","groupCollapsed","groupEnd","info","log","table","time","timeEnd","timeLog","timeStamp","trace","warn","DataView","Date","now","UTC","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","EvalError","Float32Array","Float64Array","Function","globalThis","atob","btoa","clearImmediate","clearInterval","clearTimeout","crypto","getRandomValues","randomUUID","fetch","performance","queueMicrotask","setImmediate","setInterval","setTimeout","structuredClone","URL","URLSearchParams","WritableStream","Int16Array","Int32Array","Int8Array","Intl","Collator","DateTimeFormat","DisplayNames","getCanonicalLocales","ListFormat","Locale","NumberFormat","PluralRules","RelativeTimeFormat","Segmenter","supportedValuesOf","isFinite","isNaN","JSON","groupBy","Math","abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","floor","fround","hypot","imul","log10","log1p","log2","min","pow","random","round","sign","sin","sinh","sqrt","tan","tanh","trunc","Number","isInteger","isSafeInteger","parseFloat","parseInt","assign","defineProperties","entries","freeze","fromEntries","getOwnPropertyDescriptors","getOwnPropertySymbols","is","isExtensible","isFrozen","isSealed","keys","preventExtensions","seal","setPrototypeOf","Promise","Proxy","RangeError","ReferenceError","Reflect","apply","construct","deleteProperty","ownKeys","String","fromCharCode","fromCodePoint","raw","for","SyntaxError","TypeError","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","URIError","WeakSet","unsafeAttrChars","lastIndex","import_compiler7","createScopeReadPattern","rootDepth","rootPattern","objectPattern","nestedPatterns","includes","propertyKey","propertyValue","isShorthand","pattern","relativeDepth","prev","nestedPattern","objectProperty","getScopeExpression","targetSection","scopeIdentifier","diff","memberExpression","createScopeReadExpression","pureFunctions","importRuntime","output","importNamed","getRuntimePath","callRuntime","args","callExpression2","filteredArgs","unaryExpression","filterArguments","leadingComments","getHTMLRuntime","import_babel_utils9","import_compiler13","import_babel_utils8","import_compiler12","import_compiler11","import_compiler9","toTemplateOrStringLiteral","parts","strs","exprs","curStr","nextIndex","exprLen","expressions","shiftItems","quasis","j","templateLiteral","templateElement","appendLiteral","arr","list","offset","import_compiler10","getWalks","getWalkComment","getSteps","walkCodeToName","enter","exit","enterShallow","isOutputHTML","steps","walks","walkComment","walkString","walkCodes","step","lastIndexOf","current","walk","nCodeString","writeTo","number","toCharString","startCode","rangeSize","multiplier","getWalkString","prefix2","postfix","walkLiteral","join","getWrites","exprsLen","writes","consumeHTML","flushBefore","expr","insertBefore","skip","flushInto","pushContainer","getSectionMeta","writePrefix","writePostfix","setup","getSetup","markNode","returnId","_setReturnId","usedTag","return_default","assertNoArgs","assertNoVar","assertNoParams","valueAttr","isMarkoAttribute","default","msg","buildError","returnId2","variableDeclaration","variableDeclarator","addValue","hasDownstreamIntersections","getSignals","getSubscribeBuilder","_setSubscribeBuilder","setSubscriberBuilder","builder","forceResumeScope","_setForceResumeScope","setForceResumeScope","getSerializedScopeProperties","unimplementedBuild","getSignal","generateSignalName","signals","signal","exportName","domExports","render","effect","effectInlineReferences","subscribers","subscribe","getSignalFn","buildSignalIntersections","ownerScope","isImmediateOwner","object","isDynamicClosure","arrowFunctionExpression","initValue","valueAccessor","isParamBinding","scopeIdentifier2","valueIdentifier","aliasSignal","callee","toMemberExpression","blockStatement","signal2","intersectionExpression","closureEntries","sort","closureSection","closureSignal","hasDynamicSubscribers","arrayExpression","provider","subscriber","p","providerSignal","finalizeSignalArgs","isArrowFunctionExpression","nullLiteral","isExpressionStatement","expression","addStatement","originalNodes","isInlined","statements","isFunction","addEffectReferences","getResumeRegisterId","getTemplateId","usedRegisterIdsBySection","getRegisterUID","used","baseId","renameBindings","traverseFast","writeSignals","sortSignals","effectDeclarator","effectIdentifier","isCallExpression","register","signalDeclarator","signalDeclaration","functionDeclaration","isExpression","exportNamedDeclaration","roots","root","traverse","bindFunctionsVisitor","aReferencedBindings","getReferencedBindings","bReferencedBindings","reserve","getMappedId","addHTMLEffectCall","writeHTMLResumeStatements","tagVarIdentifier","allSignals","scopeIdIdentifier","currentSection","signalRefs","accessors","additionalProperties","serializedProperties","accessor","isLiteral","objectExpression","unshiftContainer","FunctionExpression","bindFunction","ArrowFunctionExpression","handleDestructure","assignment","ctx","getStatementParent","buildAssignment","valueId","insertAfter","fnId","returnStatement","keyLiteral","keyToNode","dom_default","templateIdentifier","template","walksIdentifier","setupIdentifier","closuresIdentifier","programParamsSignal","assignments","valueSection","replacement","binaryExpression","prefix","sequenceExpression","right","slice","replaceAssignments","forEachSectionReverse","childSection","tagParamsSignal","walks2","writes2","setup2","closures2","getSectionClosuresExpr","exportDefaultDeclaration","reverse","htmlRendererIdentifier","import_compiler15","html_default","returnIdentifier","renderContent","isImportDeclaration","isExportDeclaration","static","previousProgramPath","program_default","mergedReferences","targetExtra","isEffect","additionalBindings","referencedBinding","name2","bindingReference","numReferences","binding1","sources1","sources2","sourceSection","bindings2","filter","finalizeReferences","buildTemplateExports","isOutputDOM","visitedFiles","resolved","loadFileForImport","req","resolveRelativeToEntry","templateExport","props","exports2","import_compiler17","translateVar","initialValue","const_default","varBinding","derivation","import_babel_utils12","import_compiler19","debug_default","debuggerStatement","import_babel_utils19","import_babel_utils18","import_compiler28","import_babel_utils16","import_compiler26","getKnownAttrValues","attrs2","import_compiler20","enter2","modulePlugin","plugin","isModulePlugin","isFunctionPlugin","exit2","translateByTarget","html","dom","import_babel_utils15","import_compiler25","import_babel_utils13","evaluate","confident","computed","computeNode","import_compiler21","IDENTIFIER_REG","toPropertyName","assignment_expression_default","handleDestructure2","import_babel_utils14","import_compiler23","functionIdsBySection","registeredFunctions","function_default","markoRoot","toIdentifier","functionNameCounts","index","registerId","isStatic2","serializedScopeProperties","isFunctionDeclaration","update_expression_default","kNativeTagBinding","kSerializeMarker","kGetterId","htmlSelectArgs","getRelatedControllable","tagName","checked","checkedChange","special","helper","attrs","checkedValue","checkedValueChange","valueChange","open","openChange","native_tag_default","escape","buildUndefined","assertNoAttributeTags","hasEventHandlers","hasDynamicAttributes","seen","relatedControllable","spreadReferenceNodes","isEventHandler","propName","exclusiveGroups","assertExclusiveControllableGroups","every","tagName2","tagExtra","nodeRef2","isHTML","tagDef","write2","getterId","varName","references","getterFnIdentifier","referenceSection","visitAccessor","usedAttrs","maybeStaticAttrs","spreadExpression","skipExpression","spreadProps","skipProps","staticControllable","attr3","attrToObjectProperty","spreadElement","staticAttrs","propsToExpression","getUsedAttrs","writeAtStartOfBody","changeAttr","firstAttr","HoistVisitors","spreadIdentifier","valueReferences","charAt","toLowerCase","openTagOnly","htmlType","ifStatement","selectArgs","UpdateExpression","AssignmentExpression","kForMarkerBinding","kForScopeStartIndex","kOnlyChildInParent","for_default","isAttrTag","allowAttrs","getForType","assertAllowedAttributes","tagBody","bodySection","isOnlyChildInParent","parentTag","parentTagName","isStateful","updateExpression","forAttrs","forType","bodyStatements","hasStatefulClosures","keyExpression","singleNodeOptimization","defaultParamNames","in","defaultByParamIndex","requiredParamsIndex","by","existingParam","byIdentifier","forScopeIdsIdentifier","forScopesIdentifier","newExpression","conditionalExpression","buildForRuntimeCall","forTypeToDOMRuntime","param","referencedBindings2","loopArgs","getBaseArgsInForTag","controlFlow","forTypeToRuntime","import_babel_utils17","import_compiler27","attrTagToIdentifierLookup","getAttrTagIdentifier","meta","analyzeAttributeTags","lookup","attrTagNodesByName","sampleAttrTagsForControlFlow","createAttrTagMeta","isRepeated","isLoopTag","curGroup","crawlAttrTags","oldMeta","attrTagMeta","dynamic","repeated","controlFlowTag","sampleAttrName","attributeTagGroup","attrTagNodes","hasRepeatedDynamicAttrTags","attrTagNames","attrTags2","conditionRoot","seenBranches","attrTag2","curConditionRoot","getConditionRoot","getPrevSibling","renderBodyProps","translateAttrs","templateExports","attrTagLookup","usesExport","addDynamicAttrTagStatements","translatedAttrTag","prevProp","findObjectProperty","renderBodyExpression","listKey","getNonAttributeTagParent","buildRenderBody","renderBodyProp","getTranslatedRenderBodyProperty","assignmentExpression","ifTag","consequentStatements","getConditionTestValue","addAllAttrTagsAsDynamic","nextTag","testValue","alternateStatements","translateIfAttrTag","forTag","translateForAttrTag","isSpreadElement","define_default","translatedAttrs","import_babel_utils20","import_compiler30","do_default","hasDeclaration","isDeclaration","import_babel_utils21","import_compiler31","effect_default","value2","inlineBody","import_babel_utils22","export_default","import_babel_utils23","import_compiler32","kCommentTagBinding","kGetterId2","html_comment_default","assertNoAttributes","needsBinding","needsGetter","commentBinding","templateQuasis","templateExpressions","currentQuasi","text","import_babel_utils24","import_compiler33","id_default","import_babel_utils25","import_compiler35","import_compiler34","kBinding","BRANCHES_LOOKUP","IfTag","assertHasBody","assertHasValueAttribute","assertHasPrecedingCondition","ifAttr","assertOptionalIfAttribute","assertValidCondition","isLast","branches","getBranches","rootTag","rootExtra","mergeReferenceNodes","branchTag","branchBodySection","isRoot","getRoot","getNextSibling","ifScopeIdIdentifier","ifRendererIdentifier","branchHasStatefulClosures","testAttr","curStatement","consequent","ElseIfTag","ElseTag","import_babel_utils26","import_default","import_babel_utils27","import_compiler36","let_default","valueChangeAttr","valueChangeReferences","valueChangeBinding","isSetup","valueChangeSource","calleeExpression","initValueId","changeBindingId","queueSource","import_babel_utils28","import_compiler37","kRef","supportedAttrNames","lifecycle_default","lifecycleAttrsRef","import_babel_utils29","import_compiler38","log_default","noop_default","import_babel_utils30","import_compiler39","server_default","import_babel_utils31","import_compiler40","static_default","import_babel_utils32","import_compiler41","comma","charCodeAt","semicolon","intToChar","charToInt","chars","encodeInteger","num","relative","clamped","write","td","TextDecoder","Buffer","decode","buf","buffer","byteOffset","byteLength","out","StringWriter","flush","subarray","BitSet","_BitSet","bits","n2","Chunk2","_Chunk","original","intro","outro","storeName","edited","previous","appendLeft","appendRight","clone","chunk","contains","eachNext","eachPrevious","edit","contentOnly","prependLeft","prependRight","reset","split","sliceIndex","originalBefore","originalAfter","newChunk","trimEnd","rx","trimmed","trimStart","unescape","SourceMap","version","sourcesContent","names","mappings","decoded","writer","sourcesIndex","sourceLine","sourceColumn","namesIndex","line","genColumn","segment","encode","x_google_ignoreList","toUrl","getRelativePath","fromParts","toParts","shift","concat","toString2","getLocator","originalLines","lineOffsets","m","column","wordRegex","Mappings","hires","generatedCodeLine","generatedCodeColumn","rawSegments","addEdit","sourceIndex","nameIndex","contentLengthMinusOne","contentLineEnd","indexOf","previousContentLineEnd","segment2","advance","addUneditedChunk","sourcemapLocations","originalCharIndex","first","charInHiresBoundary","lines","n","warned","insertLeft","insertRight","MagicString","_MagicString","string","options","writable","firstChunk","lastChunk","lastSearchedChunk","byStart","byEnd","indentExclusionRanges","storedNames","indentStr","ignoreList","addSourcemapLocation","char","append","_split","cloned","originalChunk","clonedChunk","nextOriginalChunk","nextClonedChunk","generateDecodedMap","locate","includeContent","generateMap","_ensureindentStr","tabbed","spaced","reduce","numSpaces","exec","Infinity","guessIndent","_getRawIndentString","getIndentString","indent","thing","isExcluded","exclude","exclusion","shouldIndentNextCharacter","indentStart","replacer","match","charIndex","_splitChunk","insert","move","last","oldLeft","oldRight","newRight","newLeft","overwrite","update","prepend","lastChar","lastLine","lineIndex","substr","lineStr","startChunk","containsEnd","sliceStart","sliceEnd","snip","searchForward","isEmpty","trimLines","charType","trimEndAborted","aborted","trimStartAborted","hasChanged","_replaceRegexp","searchValue","getReplacement","_","groups","global","re","matches","matchAll","replacement2","_replaceString","_replaceAllString","stringLength","replaceAll","import_path2","core_default","sourceMaps","base","basename","typeAttr","classAttr2","typeValue","classValue2","startsWith","markoText","resolveVirtualDependency","getStart","getEnd","magicString","importPath","virtualPath","importDefaultSpecifier","importDefault","cdata_default","cdata","comment_default","comment","declaration_default","document_type_default","documentType","import_babel_utils33","import_declaration_default","importDecl","tagImport","tags","import_babel_utils34","import_compiler42","kBinding2","kSiblingText","ESCAPE_TYPES","script","style","placeholder_default","placeholder","placeholderExtra","contentType","analyzeSiblingText","nodeBinding","canWriteHTML","method","getParentTagName","siblingText","import_compiler43","abortIdsByExpressionForSection","referenced_identifier_default","hasBinding","isMemberExpression","throwStatement","exprId","abortIdsByExpression","scriptlet_default","scriptlet","import_babel_utils38","import_compiler47","import_babel_utils35","attribute_tag_default","findParentTag","import_babel_utils36","import_compiler45","import_path3","kChildScopeBinding","custom_tag_default","assertAttributesOrSingleArg","getTagTemplate","toUpperCase","childProgramExtra","analyzeAttrs","relativePath","getTagRelativePath","isCircularRequest","childScopeBinding","peekScopeId","inputExport","renderBodyId","renderBodyPath","renderTagExpr","callStatement","translateHTML","childExports","importOrSelfReferenceName","writeAttrsToExports","circular","injectWalks","translateDOM","nodeReferencesByGroup","analyzeDynamicChildGroup","groupReferences","firstTag","attrTagName","childAttrExports","childUsesGroupProp","importAlias","tagInputIdentifier","identifierToSignal","statementsByGroup","translateDynamicAttrTagChildInGroup","childAttrExport","decls","attrExportIdentifier","renderBody","renderBodyExportIdentifier","missing","getMissingPropValue","buildUndefined2","spreadId","request","nameHint","resolve","always","import_babel_utils37","import_compiler46","kDOMBinding","dynamic_tag_default","assertAttributesOrArgs","domBinding","tagExpression","compatRuntimeFile","modules","hasMultipleArgs","splice","dynamicScopeIdentifier","dynamicTagExpr","section2","logicalExpression","argsOrInput","attrsGetter","added","tag_default","bound","changeValue","getChangeHandler","hook","analyzer","translator","watchFiles","modifier","tagNameId","tagNameVarPath","functionExpression","isPrivateName","cloneNode","visitors","visitors2","_name","extractVisitors","Program","ReferencedIdentifier","ImportDeclaration","MarkoDocumentType","MarkoDeclaration","MarkoCDATA","MarkoText","MarkoTag","MarkoPlaceholder","MarkoScriptlet","MarkoComment"],"sourceRoot":""}