{"version":3,"file":"420.d8f93bd5.js","mappings":"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","sources":["webpack:///../../node_modules/@marko/runtime-tags/dist/translator/index.js"],"sourcesContent":["\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name2 in all)\n    __defProp(target, name2, { get: all[name2], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/translator/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  analyze: () => analyze,\n  getRuntimeEntryFiles: () => getRuntimeEntryFiles,\n  internalEntryBuilder: () => entry_builder_default,\n  preferAPI: () => preferAPI,\n  tagDiscoveryDirs: () => tagDiscoveryDirs,\n  taglibs: () => taglibs,\n  transform: () => transform,\n  translate: () => translate\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// src/translator/util/runtime-info.ts\nvar import_package = require(\"../../package.json\");\nvar runtime_info_default = {\n  name: import_package.name,\n  taglibId: \"marko-core\"\n};\n\n// src/translator/core/attrs.ts\nvar import_compiler = require(\"@marko/compiler\");\nvar import_babel_utils = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/assert.ts\nfunction assertNoSpreadAttrs(tag) {\n  for (const attr2 of tag.get(\"attributes\")) {\n    if (attr2.isMarkoSpreadAttribute()) {\n      throw attr2.buildCodeFrameError(\n        `The \\`${tag.get(\"name\").node.value}\\` tag does not support \\`...spread\\` attributes.`\n      );\n    }\n  }\n}\nfunction assertNoBodyContent(tag) {\n  if (tag.node.body.body.length) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${tag.get(\"name\").node.value}\\` tag does not support body content.`\n    );\n  }\n}\n\n// src/translator/core/attrs.ts\nvar attrs_default = {\n  migrate: [\n    (tag) => {\n      (0, import_babel_utils.assertNoArgs)(tag);\n      (0, import_babel_utils.assertNoParams)(tag);\n      (0, import_babel_utils.assertNoAttributes)(tag);\n      assertNoBodyContent(tag);\n      (0, import_babel_utils.assertNoAttributeTags)(tag);\n      (0, import_babel_utils.diagnosticDeprecate)(tag, {\n        label: \"The `attrs` tag is deprecated, prefer destructuring `input` via the `const` tag.\",\n        fix() {\n          const tagVar = tag.node.var;\n          if (tagVar && !(tagVar.type === \"Identifier\" && tagVar.name === \"input\")) {\n            const constTag = import_compiler.types.markoTag(\n              import_compiler.types.stringLiteral(\"const\"),\n              [import_compiler.types.markoAttribute(\"value\", import_compiler.types.identifier(\"input\"))],\n              import_compiler.types.markoTagBody([])\n            );\n            constTag.var = tagVar;\n            tag.replaceWith(constTag);\n          } else {\n            tag.remove();\n          }\n        }\n      });\n    }\n  ],\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"attrs/{ ... }\",\n      description: \"Use to receive the attributes passed into this template.\",\n      snippet: \"attrs/{ $1 }$2\"\n    }\n  ]\n};\n\n// src/translator/core/await.ts\nvar import_compiler27 = require(\"@marko/compiler\");\nvar import_babel_utils12 = require(\"@marko/compiler/babel-utils\");\n\n// src/common/accessor.debug.ts\nvar AccessorPrefix = /* @__PURE__ */ ((AccessorPrefix3) => {\n  AccessorPrefix3[\"ClosureScopes\"] = \"ClosureScopes:\";\n  AccessorPrefix3[\"ClosureSignalIndex\"] = \"ClosureSignalIndex:\";\n  AccessorPrefix3[\"ConditionalRenderer\"] = \"ConditionalRenderer:\";\n  AccessorPrefix3[\"ConditionalScope\"] = \"ConditionalScope:\";\n  AccessorPrefix3[\"ControlledHandler\"] = \"ControlledHandler:\";\n  AccessorPrefix3[\"ControlledType\"] = \"ControlledType:\";\n  AccessorPrefix3[\"ControlledValue\"] = \"ControlledValue:\";\n  AccessorPrefix3[\"DynamicPlaceholderLastChild\"] = \"DynamicPlaceholderLastChild:\";\n  AccessorPrefix3[\"EventAttributes\"] = \"EventAttributes:\";\n  AccessorPrefix3[\"Getter\"] = \"Getter:\";\n  AccessorPrefix3[\"LifecycleAbortController\"] = \"LifecycleAbortController:\";\n  AccessorPrefix3[\"LoopScopeArray\"] = \"LoopScopeArray:\";\n  AccessorPrefix3[\"LoopScopeMap\"] = \"LoopScopeMap:\";\n  AccessorPrefix3[\"Promise\"] = \"Promise:\";\n  AccessorPrefix3[\"TagVariableChange\"] = \"TagVariableChange:\";\n  return AccessorPrefix3;\n})(AccessorPrefix || {});\nvar AccessorProp = /* @__PURE__ */ ((AccessorProp3) => {\n  AccessorProp3[\"BranchAccessor\"] = \"#BranchAccessor\";\n  AccessorProp3[\"CatchContent\"] = \"#CatchContent\";\n  AccessorProp3[\"PlaceholderBranch\"] = \"#PlaceholderBranch\";\n  AccessorProp3[\"PlaceholderContent\"] = \"#PlaceholderContent\";\n  AccessorProp3[\"TagVariable\"] = \"#TagVariable\";\n  AccessorProp3[\"TagVariableChange\"] = \"#TagVariableChange\";\n  AccessorProp3[\"ClosestBranchId\"] = \"#ClosestBranchId\";\n  return AccessorProp3;\n})(AccessorProp || {});\n\n// src/translator/util/evaluate.ts\nvar import_babel_utils2 = require(\"@marko/compiler/babel-utils\");\nfunction evaluate(value) {\n  let { extra } = value;\n  if (!extra) {\n    extra = value.extra = {};\n  }\n  if (extra.confident === void 0) {\n    const computed = (0, import_babel_utils2.computeNode)(value);\n    if (computed) {\n      extra.computed = computed.value;\n      extra.confident = true;\n    } else {\n      extra.computed = void 0;\n      extra.confident = false;\n    }\n  }\n  return extra;\n}\n\n// src/translator/util/references.ts\nvar import_compiler26 = require(\"@marko/compiler\");\n\n// src/translator/util/dynamic-sources.ts\nvar import_compiler7 = require(\"@marko/compiler\");\n\n// src/translator/util/sections.ts\nvar import_compiler6 = require(\"@marko/compiler\");\nvar import_babel_utils5 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/generate-uid.ts\nvar import_compiler3 = require(\"@marko/compiler\");\n\n// src/translator/util/traverse.ts\nvar import_compiler2 = require(\"@marko/compiler\");\nvar skip = Symbol(\"skip\");\nfunction traverseReplace(container, key, enter3) {\n  const node = container[key];\n  if (node) {\n    if (Array.isArray(node)) {\n      for (let i = node.length; i--; ) {\n        traverseReplace(node, i, enter3);\n      }\n    } else {\n      const keys = import_compiler2.types.VISITOR_KEYS[node.type];\n      for (let i = keys.length; i--; ) {\n        traverseReplace(node, keys[i], enter3);\n      }\n      const replacement = enter3(node, container, key);\n      if (replacement) container[key] = replacement;\n    }\n  }\n}\nfunction traverseContains(node, check) {\n  if (node) {\n    if (Array.isArray(node)) {\n      for (const item of node) {\n        if (traverseContains(item, check)) {\n          return true;\n        }\n      }\n    } else {\n      switch (check(node)) {\n        case true:\n          return true;\n        case skip:\n          return false;\n      }\n      for (const key of import_compiler2.types.VISITOR_KEYS[node.type]) {\n        if (traverseContains(node[key], check)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction traverse(visit2, node, parent, grandParent) {\n  if (node) {\n    if (Array.isArray(node)) {\n      for (const item of node) {\n        traverse(visit2, item, parent, grandParent);\n      }\n    } else if (visit2(node, parent, grandParent) !== skip) {\n      for (const key of import_compiler2.types.VISITOR_KEYS[node.type]) {\n        traverse(visit2, node[key], node, parent);\n      }\n    }\n  }\n}\n\n// src/translator/util/generate-uid.ts\nvar countsForFile = /* @__PURE__ */ new WeakMap();\nfunction generateUid(name2 = \"\") {\n  const file = (0, import_compiler3.getFile)();\n  let counts = countsForFile.get(file);\n  if (!counts) {\n    const { cache } = file.markoOpts;\n    const { filename } = file.opts;\n    const cacheKey = `uid-counts:${filename}`;\n    counts = cache.get(cacheKey);\n    if (counts) {\n      if (isTranslate(file)) {\n        counts = new Map(counts);\n      }\n    } else {\n      counts = getInitialCounts(file);\n      if (!isTranslate(file)) {\n        cache.set(cacheKey, counts);\n      }\n    }\n    countsForFile.set(file, counts);\n  }\n  name2 = name2.replace(/^[^a-z$_]|[^a-z$_0-9]/gi, \"\") || \"temp\";\n  name2 = /^_?(.*?)\\d*$/.exec(name2)?.[1] || name2;\n  const i = (counts.get(name2) || 0) + 1;\n  const uniqueName = `_${i > 1 ? name2 + i : name2}`;\n  counts.set(name2, i);\n  return uniqueName;\n}\nfunction generateUidIdentifier(name2) {\n  return import_compiler3.types.identifier(generateUid(name2));\n}\nfunction getInitialCounts(file) {\n  const counts = /* @__PURE__ */ new Map();\n  const program = file.path;\n  const countName = (name2) => {\n    const match = /^_(.*?)([1-9]\\d*)?$/.exec(name2);\n    if (match) {\n      const name3 = match[1];\n      const count = match[2] ? +match[2] + 1 : 1;\n      counts.set(name3, Math.max(counts.get(name3) || 0, count));\n    }\n  };\n  for (const name2 in program.scope.globals) {\n    countName(name2);\n  }\n  traverse((node, parent, grandParent) => {\n    if (node.type === \"Identifier\" && import_compiler3.types.isBinding(node, parent, grandParent)) {\n      countName(node.name);\n    }\n  }, program.node);\n  return counts;\n}\nfunction isTranslate(file) {\n  return file.___compileStage === \"translate\";\n}\n\n// src/translator/util/is-core-tag.ts\nvar import_babel_utils3 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-tag-name.ts\nfunction getTagName(tag) {\n  return tag.node.name.value;\n}\n\n// src/translator/util/is-core-tag.ts\nvar { taglibId } = runtime_info_default;\nvar htmlTaglibId = \"marko-html\";\nvar interopTaglibId = \"@marko/translator-interop-class-tags\";\nfunction isCoreTag(tag) {\n  if (tag.isMarkoTag()) {\n    const tagDef = (0, import_babel_utils3.getTagDef)(tag);\n    if (tagDef) {\n      switch (tagDef.taglibId) {\n        case taglibId:\n        case interopTaglibId:\n          return true;\n        case htmlTaglibId:\n          switch (tagDef.name) {\n            case \"script\":\n            case \"style\":\n              return true;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\nfunction isCoreTagName(tag, name2) {\n  return isCoreTag(tag) && getTagName(tag) === name2;\n}\nfunction isConditionTag(tag) {\n  if (isCoreTag(tag)) {\n    switch (getTagName(tag)) {\n      case \"if\":\n      case \"else-if\":\n      case \"else\":\n        return true;\n    }\n  }\n  return false;\n}\nfunction isControlFlowTag(tag) {\n  if (isCoreTag(tag)) {\n    switch (getTagName(tag)) {\n      case \"if\":\n      case \"else-if\":\n      case \"else\":\n      case \"for\":\n      case \"await\":\n      case \"try\":\n        return true;\n    }\n  }\n  return false;\n}\n\n// src/translator/util/optional.ts\nvar Sorted = class {\n  constructor(compare) {\n    this.compare = compare;\n  }\n  add(data, item) {\n    return data ? Array.isArray(data) ? addSorted(this.compare, data, item) : joinRepeatable(this.compare, data, item) : item;\n  }\n  union(a, b) {\n    if (a) {\n      if (Array.isArray(a)) {\n        if (b) {\n          if (Array.isArray(b)) {\n            return unionSortedRepeatable(this.compare, a, b);\n          } else {\n            return addSorted(this.compare, a, b);\n          }\n        }\n        return a;\n      }\n      if (b) {\n        if (Array.isArray(b)) {\n          return addSorted(this.compare, [...b], a);\n        }\n        return joinRepeatable(this.compare, b, a);\n      }\n      return a;\n    }\n    return b;\n  }\n  find(data, item) {\n    if (data) {\n      if (Array.isArray(data)) {\n        return findSorted(this.compare, data, item);\n      } else if (this.compare(data, item) === 0) {\n        return data;\n      }\n    }\n  }\n  findIndex(data, item) {\n    if (data) {\n      if (Array.isArray(data)) {\n        let max = data.length;\n        let pos = 0;\n        while (pos < max) {\n          const mid = pos + max >>> 1;\n          const compareResult = this.compare(data[mid], item);\n          if (compareResult === 0) return mid;\n          if (compareResult > 0) max = mid;\n          else pos = mid + 1;\n        }\n        return -1;\n      }\n      if (this.compare(data, item) === 0) {\n        return 0;\n      }\n    }\n    return -1;\n  }\n  isSuperset(superset, subset) {\n    if (!subset) {\n      return true;\n    }\n    if (!Array.isArray(subset)) {\n      return this.findIndex(superset, subset) !== -1;\n    }\n    if (!Array.isArray(superset)) {\n      return false;\n    }\n    const subLen = subset.length;\n    const supLen = superset.length;\n    if (subLen > supLen) {\n      return false;\n    }\n    for (let i = subLen; i--; ) {\n      const supIndex = this.findIndex(superset, subset[i]);\n      if (supIndex === -1 || supLen - supIndex <= i) return false;\n    }\n    return true;\n  }\n};\nfunction push(data, item) {\n  if (data) {\n    if (Array.isArray(data)) {\n      data.push(item);\n      return data;\n    }\n    return [data, item];\n  }\n  return item;\n}\nfunction concat(a, b) {\n  if (a) {\n    if (b) {\n      if (Array.isArray(a)) {\n        return a.concat(b);\n      } else if (Array.isArray(b)) {\n        return [a, ...b];\n      } else {\n        return [a, b];\n      }\n    }\n    return a;\n  }\n  return b;\n}\nfunction filter(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      const len = data.length;\n      let result;\n      let i = 0;\n      while (i < len) {\n        let item = data[i++];\n        if (cb(item)) {\n          result = item;\n          while (i < len) {\n            item = data[i++];\n            if (cb(item)) {\n              result = [result, item];\n              while (i < len) {\n                item = data[i++];\n                if (cb(item)) {\n                  result.push(item);\n                }\n              }\n              return result;\n            }\n          }\n          return result;\n        }\n      }\n      return result;\n    }\n    if (cb(data)) {\n      return data;\n    }\n  }\n  return void 0;\n}\nfunction forEach(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      let i = 0;\n      for (const item of data) {\n        cb(item, i++);\n      }\n    } else {\n      cb(data, 0);\n    }\n  }\n}\nfunction find(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      return data.find(cb);\n    }\n    if (cb(data, 0)) {\n      return data;\n    }\n  }\n}\nfunction map(data, cb) {\n  return data ? Array.isArray(data) ? data.map(cb) : [cb(data, 0)] : [];\n}\nfunction findSorted(compare, data, item) {\n  let max = data.length;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const cur = data[mid];\n    const compareResult = compare(cur, item);\n    if (compareResult === 0) return cur;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n}\nfunction addSorted(compare, data, item) {\n  const len = data.length;\n  let max = len;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(data[mid], item);\n    if (compareResult === 0) return data;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n  const result = new Array(len + 1);\n  for (let i = 0; i < pos; i++) {\n    result[i] = data[i];\n  }\n  let cur = item;\n  while (pos < len) {\n    const next = cur;\n    cur = data[pos];\n    result[pos++] = next;\n  }\n  result[len] = cur;\n  return result;\n}\nfunction unionSortedRepeatable(compare, a, b) {\n  const aLen = a.length;\n  const bLen = b.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  const result = [];\n  while (aIndex < aLen && bIndex < bLen) {\n    const aValue = a[aIndex];\n    const bValue = b[bIndex];\n    const delta = compare(aValue, bValue);\n    if (delta === 0) {\n      aIndex++;\n      bIndex++;\n      result.push(aValue);\n    } else if (delta < 0) {\n      aIndex++;\n      result.push(aValue);\n    } else {\n      bIndex++;\n      result.push(bValue);\n    }\n  }\n  if (aLen === bLen && aIndex === aLen) {\n    return a;\n  }\n  while (aIndex < aLen) {\n    result.push(a[aIndex++]);\n  }\n  while (bIndex < bLen) {\n    result.push(b[bIndex++]);\n  }\n  return result;\n}\nfunction joinRepeatable(compare, a, b) {\n  const compareResult = compare(a, b);\n  return compareResult === 0 ? a : compareResult < 0 ? [a, b] : [b, a];\n}\n\n// src/translator/util/state.ts\nvar import_compiler4 = require(\"@marko/compiler\");\nvar createProgramState = (init) => {\n  const map2 = /* @__PURE__ */ new WeakMap();\n  return [\n    () => {\n      let state = map2.get((0, import_compiler4.getProgram)());\n      if (!state) {\n        map2.set((0, import_compiler4.getProgram)(), state = init());\n      }\n      return state;\n    },\n    (value) => {\n      map2.set((0, import_compiler4.getProgram)(), value);\n    }\n  ];\n};\nfunction createSectionState(key, init) {\n  return [\n    (section) => {\n      const arrayOfSectionData = (0, import_compiler4.getProgram)().state[key] ??= {};\n      const sectionData = arrayOfSectionData[section.id] ??= init && init(section);\n      return sectionData;\n    },\n    (section, value) => {\n      const arrayOfSectionData = (0, import_compiler4.getProgram)().state[key] ??= {};\n      arrayOfSectionData[section.id] = value;\n    }\n  ];\n}\n\n// src/translator/util/tag-name-type.ts\nvar import_compiler5 = require(\"@marko/compiler\");\nvar import_babel_utils4 = require(\"@marko/compiler/babel-utils\");\nvar MARKO_FILE_REG = /^<.*>$|\\.marko$/;\nfunction analyzeTagNameType(tag) {\n  const extra = tag.node.extra ??= {};\n  if (extra.tagNameType === void 0) {\n    const name2 = tag.get(\"name\");\n    if (name2.isStringLiteral()) {\n      extra.tagNameType = name2.node.value[0] === \"@\" ? 3 /* AttributeTag */ : (0, import_babel_utils4.isNativeTag)(tag) ? 0 /* NativeTag */ : 1 /* CustomTag */;\n      extra.tagNameNullable = extra.tagNameNullable = false;\n    } else if (name2.isIdentifier()) {\n      analyzeExpressionTagName(name2, extra);\n      if (extra.tagNameType === 0 /* NativeTag */) {\n        extra.tagNameType = 2 /* DynamicTag */;\n      }\n    } else if (name2.isTemplateLiteral() && !name2.node.expressions.length) {\n      extra.tagNameType = 0 /* NativeTag */;\n    } else {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n    if (extra.tagNameType === void 0) {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n    if (extra.tagNameType === 1 /* CustomTag */) {\n      const childFile = (0, import_babel_utils4.loadFileForTag)(tag);\n      if (!childFile) {\n        extra.tagNameType = 2 /* DynamicTag */;\n      } else if (childFile.ast.program.extra.featureType === \"class\") {\n        extra.tagNameType = 2 /* DynamicTag */;\n        extra.featureType = \"class\";\n        ((0, import_compiler5.getProgram)().node.extra ??= {}).needsCompat = true;\n      }\n    }\n  }\n  return extra.tagNameType;\n}\nfunction analyzeExpressionTagName(name2, extra) {\n  const pending = [name2];\n  let path5;\n  let type;\n  let nullable = false;\n  let tagNameImported;\n  while ((path5 = pending.pop()) && type !== 2 /* DynamicTag */) {\n    if (path5.isConditionalExpression()) {\n      pending.push(path5.get(\"consequent\"));\n      if (path5.node.alternate) {\n        pending.push(path5.get(\"alternate\"));\n      }\n    } else if (path5.isLogicalExpression()) {\n      if (path5.node.operator === \"||\") {\n        pending.push(path5.get(\"left\"));\n      } else {\n        nullable = true;\n      }\n      pending.push(path5.get(\"right\"));\n    } else if (path5.isAssignmentExpression()) {\n      pending.push(path5.get(\"right\"));\n    } else if (path5.isBinaryExpression()) {\n      type = path5.node.operator !== \"+\" || type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path5.isStringLiteral() || path5.isTemplateLiteral()) {\n      type = type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path5.isNullLiteral()) {\n      nullable = true;\n    } else if (path5.isIdentifier()) {\n      if (path5.node.name === \"undefined\") {\n        nullable = true;\n        continue;\n      }\n      const binding = path5.scope.getBinding(path5.node.name);\n      if (!binding) {\n        type = 2 /* DynamicTag */;\n        continue;\n      }\n      if (binding.kind === \"module\") {\n        const decl = binding.path.parent;\n        if (MARKO_FILE_REG.test(decl.source.value) && decl.specifiers.some((it) => import_compiler5.types.isImportDefaultSpecifier(it))) {\n          const resolvedImport = (0, import_babel_utils4.resolveTagImport)(name2, decl.source.value) || decl.source.value;\n          if (type === 0 /* NativeTag */ || tagNameImported && tagNameImported !== resolvedImport) {\n            type = 2 /* DynamicTag */;\n            tagNameImported = void 0;\n          } else {\n            type = 1 /* CustomTag */;\n            tagNameImported = resolvedImport;\n          }\n        } else {\n          type = 2 /* DynamicTag */;\n        }\n        continue;\n      }\n      const bindingTag = binding.path;\n      if (bindingTag.isMarkoTag() && binding.kind === \"local\") {\n        const bindingTagName = bindingTag.get(\"name\").node.value;\n        if (bindingTagName === \"const\") {\n          pending.push(\n            bindingTag.get(\"attributes\")[0].get(\"value\")\n          );\n          continue;\n        }\n        if (bindingTagName === \"let\") {\n          type = 2 /* DynamicTag */;\n          continue;\n        }\n        continue;\n      }\n      type = 2 /* DynamicTag */;\n    } else {\n      type = 2 /* DynamicTag */;\n    }\n  }\n  extra.tagNameType = type;\n  extra.tagNameNullable = nullable;\n  extra.tagNameDynamic = true;\n  if (type === 1 /* CustomTag */ && tagNameImported) {\n    extra.tagNameImported = tagNameImported;\n  }\n}\n\n// src/translator/util/sections.ts\nvar sectionUtil = new Sorted(function compareSections(a, b) {\n  return a.id - b.id;\n});\nfunction startSection(path5) {\n  const extra = path5.node.extra ??= {};\n  let section = extra.section;\n  if (!section && (path5.type === \"Program\" || path5.get(\"body\").length)) {\n    const parentSection = path5.parentPath ? getOrCreateSection(path5.parentPath) : void 0;\n    const sectionNamePath = path5.parentPath?.get(\n      \"name\"\n    );\n    const sectionName = path5.isProgram() ? \"\" : generateUid(sectionNamePath.toString() + \"_content\");\n    const programExtra = path5.hub.file.path.node.extra ??= {};\n    const sections = programExtra.sections ??= [];\n    section = extra.section = {\n      id: sections.length,\n      name: sectionName,\n      loc: sectionNamePath?.node.loc || void 0,\n      depth: parentSection ? parentSection.depth + 1 : 0,\n      parent: parentSection,\n      sectionAccessor: void 0,\n      params: void 0,\n      referencedClosures: void 0,\n      referencedHoists: void 0,\n      bindings: void 0,\n      hoisted: void 0,\n      isHoistThrough: void 0,\n      assignments: void 0,\n      content: getContentInfo(path5),\n      upstreamExpression: void 0,\n      downstreamBinding: void 0,\n      hasAbortSignal: false,\n      isBranch: false\n    };\n    sections.push(section);\n  }\n  return section;\n}\nfunction getOrCreateSection(path5) {\n  let cur = path5;\n  while (true) {\n    if (cur.type === \"Program\" || cur.type === \"MarkoTagBody\" && !cur.node.attributeTags && !isNativeNode(cur.parentPath)) {\n      return startSection(cur);\n    }\n    cur = cur.parentPath;\n  }\n}\nfunction getSectionForBody(body) {\n  return body.node.extra?.section;\n}\nfunction getSection(path5) {\n  let section;\n  let currentPath = path5;\n  while ((section = currentPath.node.extra?.section) === void 0) {\n    currentPath = currentPath.parentPath;\n  }\n  return section;\n}\nvar [getScopeIdIdentifier] = createSectionState(\n  \"scopeIdIdentifier\",\n  (section) => generateUidIdentifier(`scope${section.id}_id`)\n);\nvar [getSectionParentIsOwner, setSectionParentIsOwner] = createSectionState(\"parentIsOwner\", () => false);\nvar [_getScopeIdentifier] = createSectionState(\n  \"scopeIdentifier\",\n  () => import_compiler6.types.identifier(\"undefined\")\n);\nfunction forEachSection(fn) {\n  const { sections } = (0, import_compiler6.getProgram)().node.extra;\n  sections?.forEach(fn);\n}\nfunction forEachSectionReverse(fn) {\n  const { sections } = (0, import_compiler6.getProgram)().node.extra;\n  for (let i = sections.length; i--; ) {\n    fn(sections[i]);\n  }\n}\nfunction getContentInfo(path5) {\n  const body = path5.get(\"body\");\n  const contentInfo = {\n    startType: null,\n    endType: null,\n    singleChild: true\n  };\n  for (let endIndex = body.length; endIndex--; ) {\n    const endType = getNodeContentType(body[endIndex], \"endType\", contentInfo);\n    if (endType !== null) {\n      contentInfo.endType = endType;\n      for (let startIndex = 0; startIndex < endIndex; startIndex++) {\n        const startType = getNodeContentType(body[startIndex], \"startType\");\n        if (startType !== null) {\n          contentInfo.startType = startType;\n          contentInfo.singleChild = false;\n          return contentInfo;\n        }\n      }\n      contentInfo.startType = getNodeContentType(body[endIndex], \"startType\");\n      return contentInfo;\n    }\n  }\n  return null;\n}\nfunction getNodeContentType(path5, extraMember, contentInfo) {\n  switch (path5.type) {\n    case \"MarkoText\":\n      return 4 /* Text */;\n    case \"MarkoPlaceholder\":\n      return 2 /* Placeholder */;\n    case \"MarkoScriptlet\":\n    case \"MarkoComment\":\n    case \"ImportDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportNamedDeclaration\":\n      return null;\n    case \"MarkoTag\": {\n      const tag = path5;\n      if (isCoreTag(tag)) {\n        switch (tag.node.name.value) {\n          case \"html-comment\":\n            return 0 /* Comment */;\n          case \"html-script\":\n          case \"html-style\":\n            return 3 /* Tag */;\n          case \"for\":\n          case \"if\":\n          case \"await\":\n          case \"try\":\n            return 1 /* Dynamic */;\n          default:\n            return null;\n        }\n      } else if ((0, import_babel_utils5.isNativeTag)(tag)) {\n        return 3 /* Tag */;\n      } else if ((0, import_babel_utils5.isAttributeTag)(tag)) {\n        return null;\n      } else if (import_compiler6.types.isStringLiteral(tag.node.name)) {\n        const tagSection = (0, import_babel_utils5.loadFileForTag)(tag)?.ast.program.extra.section;\n        if (tagSection) {\n          if (tagSection.content) {\n            if (contentInfo && !tagSection.content.singleChild) {\n              if (extraMember === \"endType\") {\n                contentInfo.startType = tagSection.content.startType;\n                contentInfo.singleChild = false;\n              }\n            }\n            return tagSection.content[extraMember];\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n  }\n  return 1 /* Dynamic */;\n}\nvar isSerializedSection = (section) => {\n  return !(section.isBranch || section.downstreamBinding?.serialize === false);\n};\nfunction isSectionWithHoists(section) {\n  if (section.hoisted || section.isHoistThrough || section.referencedHoists)\n    return true;\n}\nfunction isImmediateOwner(section, binding) {\n  return section.parent?.id === binding.section.id;\n}\nfunction isDirectClosure(section, closure) {\n  return section.isBranch && isImmediateOwner(section, closure);\n}\nfunction isDynamicClosure(section, closure) {\n  return !isDirectClosure(section, closure);\n}\nfunction getDirectClosures(section) {\n  if (section.isBranch) {\n    return filter(\n      section.referencedClosures,\n      (closure) => isImmediateOwner(section, closure)\n    );\n  }\n}\nfunction isSameOrChildSection(section, other) {\n  do {\n    if (other === section) {\n      return true;\n    }\n  } while (other = other.parent);\n  return false;\n}\nfunction getCommonSection(section, other) {\n  let ancestor = section;\n  if (other.depth < section.depth) {\n    ancestor = other;\n    other = section;\n  }\n  while (ancestor) {\n    if (other === ancestor || !other.parent) {\n      return ancestor;\n    }\n    other = other.parent;\n    if (other.depth < ancestor.depth) {\n      ancestor = ancestor.parent;\n    }\n  }\n  throw new Error(\"No common section\");\n}\nfunction isNativeNode(tag) {\n  if (isCoreTag(tag)) {\n    switch (tag.node.name.value) {\n      case \"html-comment\":\n      case \"html-script\":\n      case \"html-style\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  return analyzeTagNameType(tag) === 0 /* NativeTag */;\n}\n\n// src/translator/util/dynamic-sources.ts\nfunction getDynamicSourcesForBinding(binding) {\n  if (binding.sources) {\n    if (Array.isArray(binding.sources) ? binding.sources.every(isInputBinding) : isInputBinding(binding.sources)) {\n      return binding.sources;\n    }\n    return true;\n  }\n}\nfunction getDynamicSourcesForExtra(extra) {\n  if (isReferencedExtra(extra)) {\n    return getDynamicSourcesForReferences(extra.referencedBindings);\n  }\n}\nfunction getDynamicSourcesForExtras(extras) {\n  let allDynamicSources;\n  for (const extra of extras) {\n    const dynamicSources = getDynamicSourcesForExtra(extra);\n    if (dynamicSources === true) return true;\n    allDynamicSources = bindingUtil.union(allDynamicSources, dynamicSources);\n  }\n  return allDynamicSources;\n}\nfunction getDynamicSourcesForSection(section) {\n  const referenced = getDynamicSourcesForReferences(\n    section.upstreamExpression?.referencedBindings\n  );\n  const closures = getDynamicSourcesForReferences(getDirectClosures(section));\n  if (referenced || closures) {\n    return {\n      referenced,\n      closures,\n      all: referenced === true || closures === true ? true : bindingUtil.union(referenced, closures)\n    };\n  }\n}\nfunction getDynamicSourcesForSections(sections) {\n  let first;\n  let merged;\n  for (const section of sections) {\n    const sources = section && getDynamicSourcesForSection(section);\n    if (sources) {\n      if (merged) {\n        merged.referenced = mergeDynamicSources(\n          merged.referenced,\n          sources.referenced\n        );\n        merged.closures = mergeDynamicSources(\n          merged.closures,\n          sources.closures\n        );\n        merged.all = mergeDynamicSources(merged.all, sources.all);\n      } else if (first) {\n        merged = {\n          referenced: mergeDynamicSources(first.referenced, sources.referenced),\n          closures: mergeDynamicSources(first.closures, sources.closures),\n          all: mergeDynamicSources(first.all, sources.all)\n        };\n      } else {\n        first = sources;\n      }\n    }\n  }\n  return merged || first;\n}\nfunction getDynamicSourcesForReferences(referencedBindings) {\n  if (referencedBindings) {\n    let dynamicSources;\n    if (Array.isArray(referencedBindings)) {\n      for (const binding of referencedBindings) {\n        const newDynamicSources = getDynamicSourcesForBinding(binding);\n        if (newDynamicSources === true) return true;\n        dynamicSources = bindingUtil.union(dynamicSources, newDynamicSources);\n      }\n      return dynamicSources;\n    } else {\n      return getDynamicSourcesForBinding(referencedBindings);\n    }\n  }\n}\nfunction mergeDynamicSources(a, b) {\n  if (a === true || b === true) return true;\n  return bindingUtil.union(a, b);\n}\nfunction isInputBinding(binding) {\n  return binding.type === 2 /* input */;\n}\n\n// src/translator/util/for-each-identifier.ts\nfunction forEachIdentifier(node, cb) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        switch (prop.type) {\n          case \"ObjectProperty\":\n            if (prop.value.type === \"AssignmentPattern\") {\n              forEachIdentifier(prop.value.left, cb);\n            } else {\n              forEachIdentifier(prop.value, cb);\n            }\n            break;\n          case \"RestElement\":\n            forEachIdentifier(prop.argument, cb);\n            break;\n        }\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const el of node.elements) {\n        if (el != null) {\n          switch (el.type) {\n            case \"RestElement\":\n              forEachIdentifier(el.argument, cb);\n              break;\n            case \"AssignmentPattern\":\n              forEachIdentifier(el.left, cb);\n              break;\n            default:\n              forEachIdentifier(el, cb);\n              break;\n          }\n        }\n      }\n      break;\n    case \"Identifier\":\n      cb(node);\n      break;\n  }\n}\n\n// src/common/accessor.ts\nvar AccessorPrefix2 = /* @__PURE__ */ ((AccessorPrefix3) => {\n  AccessorPrefix3[\"ClosureScopes\"] = \"a\";\n  AccessorPrefix3[\"ClosureSignalIndex\"] = \"b\";\n  AccessorPrefix3[\"ConditionalRenderer\"] = \"c\";\n  AccessorPrefix3[\"ConditionalScope\"] = \"d\";\n  AccessorPrefix3[\"ControlledHandler\"] = \"e\";\n  AccessorPrefix3[\"ControlledType\"] = \"f\";\n  AccessorPrefix3[\"ControlledValue\"] = \"g\";\n  AccessorPrefix3[\"DynamicPlaceholderLastChild\"] = \"h\";\n  AccessorPrefix3[\"EventAttributes\"] = \"i\";\n  AccessorPrefix3[\"Getter\"] = \"j\";\n  AccessorPrefix3[\"LifecycleAbortController\"] = \"k\";\n  AccessorPrefix3[\"LoopScopeArray\"] = \"l\";\n  AccessorPrefix3[\"LoopScopeMap\"] = \"m\";\n  AccessorPrefix3[\"Promise\"] = \"n\";\n  AccessorPrefix3[\"TagVariableChange\"] = \"o\";\n  return AccessorPrefix3;\n})(AccessorPrefix2 || {});\nvar AccessorProp2 = /* @__PURE__ */ ((AccessorProp3) => {\n  AccessorProp3[\"BranchAccessor\"] = \"a\";\n  AccessorProp3[\"CatchContent\"] = \"b\";\n  AccessorProp3[\"PlaceholderBranch\"] = \"c\";\n  AccessorProp3[\"PlaceholderContent\"] = \"d\";\n  AccessorProp3[\"TagVariable\"] = \"e\";\n  AccessorProp3[\"TagVariableChange\"] = \"f\";\n  AccessorProp3[\"ClosestBranchId\"] = \"g\";\n  return AccessorProp3;\n})(AccessorProp2 || {});\n\n// src/translator/util/marko-config.ts\nvar import_compiler8 = require(\"@marko/compiler\");\nfunction isOutputHTML() {\n  return getMarkoOpts().output === \"html\";\n}\nfunction isOutputDOM() {\n  return !isOutputHTML();\n}\nfunction getMarkoOpts() {\n  return (0, import_compiler8.getFile)().markoOpts;\n}\nfunction isOptimize() {\n  return getMarkoOpts().optimize;\n}\n\n// src/translator/util/get-accessor-char.ts\nfunction getAccessorPrefix() {\n  return isOptimize() ? AccessorPrefix2 : AccessorPrefix;\n}\nfunction getAccessorProp() {\n  return isOptimize() ? AccessorProp2 : AccessorProp;\n}\n\n// src/translator/util/get-root.ts\nfunction getMarkoRoot(path5) {\n  let curPath = path5;\n  do\n    curPath = curPath.parentPath;\n  while (curPath && !isMarko(curPath));\n  return curPath;\n}\nfunction getExprRoot(path5) {\n  let curPath = path5;\n  while (!isMarko(curPath.parentPath)) {\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction getFnRoot(path5) {\n  let curPath = path5;\n  let fnPath;\n  if (curPath.isProgram()) return;\n  while (!isMarko(curPath)) {\n    if (isFunction(curPath)) {\n      fnPath = curPath;\n    } else {\n      switch (curPath.type) {\n        case \"CallExpression\":\n        case \"NewExpression\":\n          fnPath = void 0;\n          break;\n      }\n    }\n    curPath = curPath.parentPath;\n  }\n  return fnPath;\n}\nfunction isMarko(path5) {\n  switch (path5.type) {\n    case \"MarkoTag\":\n    case \"MarkoTagBody\":\n    case \"MarkoAttribute\":\n    case \"MarkoSpreadAttribute\":\n    case \"MarkoPlaceholder\":\n    case \"MarkoScriptlet\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isFunction(path5) {\n  switch (path5.type) {\n    case \"FunctionDeclaration\":\n      return !path5.node.declare;\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ObjectMethod\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// src/translator/util/is-invoked-function.ts\nvar import_compiler9 = require(\"@marko/compiler\");\nfunction isInvokedFunction(expr) {\n  let curPath = expr;\n  while (curPath) {\n    const { parent, node } = curPath;\n    switch (parent.type) {\n      case \"CallExpression\":\n        return parent.callee === node;\n      case \"TSNonNullExpression\":\n        curPath = curPath.parentPath;\n        break;\n      default:\n        return false;\n    }\n  }\n  return false;\n}\n\n// src/translator/util/scope-read.ts\nvar import_compiler25 = require(\"@marko/compiler\");\n\n// src/translator/visitors/program/index.ts\nvar import_compiler24 = require(\"@marko/compiler\");\nvar import_babel_utils11 = require(\"@marko/compiler/babel-utils\");\nvar import_path2 = __toESM(require(\"path\"));\n\n// src/translator/util/binding-has-downstream-expressions.ts\nfunction bindingHasDownstreamExpressions(binding) {\n  if (binding.downstreamExpressions.size) return true;\n  for (const alias of binding.aliases) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  return false;\n}\n\n// src/translator/util/entry-builder.ts\nvar import_compiler10 = require(\"@marko/compiler\");\nvar import_babel_utils6 = require(\"@marko/compiler/babel-utils\");\nvar kState = Symbol();\nvar entry_builder_default = {\n  build(entryFile) {\n    const state = entryFile[kState];\n    if (!state) {\n      throw entryFile.path.buildCodeFrameError(\n        \"Unable to build hydrate code, no files were visited before finalizing the build\"\n      );\n    }\n    const body = state.imports.map(\n      (it) => import_compiler10.types.importDeclaration([], import_compiler10.types.stringLiteral(it))\n    );\n    if (state.init) {\n      body.unshift(\n        import_compiler10.types.importDeclaration(\n          [import_compiler10.types.importSpecifier(import_compiler10.types.identifier(\"init\"), import_compiler10.types.identifier(\"init\"))],\n          import_compiler10.types.stringLiteral(\n            `${runtime_info_default.name}/${entryFile.markoOpts.optimize ? \"\" : \"debug/\"}dom`\n          )\n        )\n      );\n      body.push(\n        import_compiler10.types.expressionStatement(import_compiler10.types.callExpression(import_compiler10.types.identifier(\"init\"), []))\n      );\n    }\n    return body;\n  },\n  visit(file, entryFile, visitChild) {\n    const state = entryFile[kState] ||= {\n      imports: [],\n      init: false\n    };\n    const { analyzedTags } = file.metadata.marko;\n    state.imports.push(\n      (0, import_babel_utils6.resolveRelativePath)(entryFile, file.opts.filename)\n    );\n    state.init ||= file.path.node.extra.hasInteractiveChild || file.path.node.extra.isInteractive || false;\n    for (const tag of analyzedTags || []) {\n      visitChild(tag);\n    }\n  }\n};\n\n// src/translator/util/runtime.ts\nvar import_compiler12 = require(\"@marko/compiler\");\nvar import_babel_utils7 = require(\"@marko/compiler/babel-utils\");\n\n// src/common/attr-tag.ts\nvar rest = false ? Symbol(\"Attribute Tag\") : Symbol();\n\n// src/common/helpers.ts\nfunction classValue(value) {\n  return toDelimitedString(value, \" \", stringifyClassObject);\n}\nfunction stringifyClassObject(name2, value) {\n  return value ? name2 : \"\";\n}\nfunction styleValue(value) {\n  return toDelimitedString(value, \";\", stringifyStyleObject);\n}\nfunction stringifyStyleObject(name2, value) {\n  return value || value === 0 ? `${name2}:${typeof value === \"number\" && value && !/^(--|ta|or|li|z)|cou|nk|it|ag|we|do|w$/.test(name2) ? value + \"px\" : value}` : \"\";\n}\nfunction toDelimitedString(val, delimiter, stringify) {\n  switch (typeof val) {\n    case \"string\":\n      return val;\n    case \"object\":\n      if (val !== null) {\n        let result = \"\";\n        let curDelimiter = \"\";\n        if (Array.isArray(val)) {\n          for (const v of val) {\n            const part = toDelimitedString(v, delimiter, stringify);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        } else {\n          for (const name2 in val) {\n            const v = val[name2];\n            const part = stringify(name2, v);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        }\n        return result;\n      }\n  }\n  return \"\";\n}\nfunction isEventHandler(name2) {\n  return /^on[A-Z-]/.test(name2);\n}\nfunction getEventHandlerName(name2) {\n  return name2[2] === \"-\" ? name2.slice(3) : name2.slice(2).toLowerCase();\n}\nfunction isVoid(value) {\n  return value == null || value === false;\n}\n\n// src/html/content.ts\nfunction toString(val) {\n  return val ? val + \"\" : val === 0 ? \"0\" : \"\";\n}\nvar unsafeXMLReg = /[<&]/g;\nvar replaceUnsafeXML = (c) => c === \"&\" ? \"&amp;\" : \"&lt;\";\nvar escapeXMLStr = (str) => unsafeXMLReg.test(str) ? str.replace(unsafeXMLReg, replaceUnsafeXML) : str;\nfunction escapeXML(val) {\n  return val ? escapeXMLStr(val + \"\") : val === 0 ? \"0\" : \"&zwj;\";\n}\nvar unsafeScriptReg = /<\\/script/g;\nvar escapeScriptStr = (str) => unsafeScriptReg.test(str) ? str.replace(unsafeScriptReg, \"\\\\x3C/script\") : str;\nfunction escapeScript(val) {\n  return val ? escapeScriptStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\nvar unsafeStyleReg = /<\\/style/g;\nvar escapeStyleStr = (str) => unsafeStyleReg.test(str) ? str.replace(unsafeStyleReg, \"\\\\3C/style\") : str;\nfunction escapeStyle(val) {\n  return val ? escapeStyleStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\n\n// src/html/serializer.ts\nvar kTouchedIterator = Symbol();\nvar { hasOwnProperty } = {};\nvar Generator = function* () {\n}().constructor;\nvar AsyncGenerator = async function* () {\n}().constructor;\npatchIteratorNext(Generator.prototype);\npatchIteratorNext(AsyncGenerator.prototype);\nvar KNOWN_SYMBOLS = (() => {\n  const KNOWN_SYMBOLS2 = /* @__PURE__ */ new Map();\n  for (const name2 of Object.getOwnPropertyNames(Symbol)) {\n    const symbol = Symbol[name2];\n    if (typeof symbol === \"symbol\") {\n      KNOWN_SYMBOLS2.set(symbol, \"Symbol.\" + name2);\n    }\n  }\n  return KNOWN_SYMBOLS2;\n})();\nvar KNOWN_FUNCTIONS = /* @__PURE__ */ new Map([\n  // This is by no means an exhaustive list,\n  // but it should cover most of the built-in functions.\n  [AggregateError, \"AggregateError\"],\n  [Array, \"Array\"],\n  [Array.from, \"Array.from\"],\n  [Array.isArray, \"Array.isArray\"],\n  [Array.of, \"Array.of\"],\n  [ArrayBuffer, \"ArrayBuffer\"],\n  [ArrayBuffer.isView, \"ArrayBuffer.isView\"],\n  [Atomics.add, \"Atomics.add\"],\n  [Atomics.and, \"Atomics.and\"],\n  [Atomics.compareExchange, \"Atomics.compareExchange\"],\n  [Atomics.exchange, \"Atomics.exchange\"],\n  [Atomics.isLockFree, \"Atomics.isLockFree\"],\n  [Atomics.load, \"Atomics.load\"],\n  [Atomics.notify, \"Atomics.notify\"],\n  [Atomics.or, \"Atomics.or\"],\n  [Atomics.store, \"Atomics.store\"],\n  [Atomics.sub, \"Atomics.sub\"],\n  [Atomics.wait, \"Atomics.wait\"],\n  [BigInt, \"BigInt\"],\n  [BigInt.asIntN, \"BigInt.asIntN\"],\n  [BigInt.asUintN, \"BigInt.asUintN\"],\n  [BigInt64Array, \"BigInt64Array\"],\n  [BigInt64Array.from, \"BigInt64Array.from\"],\n  [BigInt64Array.of, \"BigInt64Array.of\"],\n  [BigUint64Array, \"BigUint64Array\"],\n  [BigUint64Array.from, \"BigUint64Array.from\"],\n  [BigUint64Array.of, \"BigUint64Array.of\"],\n  [Boolean, \"Boolean\"],\n  [console.assert, \"console.assert\"],\n  [console.clear, \"console.clear\"],\n  [console.count, \"console.count\"],\n  [console.countReset, \"console.countReset\"],\n  [console.debug, \"console.debug\"],\n  [console.dir, \"console.dir\"],\n  [console.dirxml, \"console.dirxml\"],\n  [console.error, \"console.error\"],\n  [console.group, \"console.group\"],\n  [console.groupCollapsed, \"console.groupCollapsed\"],\n  [console.groupEnd, \"console.groupEnd\"],\n  [console.info, \"console.info\"],\n  [console.log, \"console.log\"],\n  [console.table, \"console.table\"],\n  [console.time, \"console.time\"],\n  [console.timeEnd, \"console.timeEnd\"],\n  [console.timeLog, \"console.timeLog\"],\n  [console.timeStamp, \"console.timeStamp\"],\n  [console.trace, \"console.trace\"],\n  [console.warn, \"console.warn\"],\n  [DataView, \"DataView\"],\n  [Date, \"Date\"],\n  [Date.now, \"Date.now\"],\n  [Date.parse, \"Date.parse\"],\n  [Date.UTC, \"Date.UTC\"],\n  [decodeURI, \"decodeURI\"],\n  [decodeURIComponent, \"decodeURIComponent\"],\n  [encodeURI, \"encodeURI\"],\n  [encodeURIComponent, \"encodeURIComponent\"],\n  [Error, \"Error\"],\n  [EvalError, \"EvalError\"],\n  [Float32Array, \"Float32Array\"],\n  [Float32Array.from, \"Float32Array.from\"],\n  [Float32Array.of, \"Float32Array.of\"],\n  [Float64Array, \"Float64Array\"],\n  [Float64Array.from, \"Float64Array.from\"],\n  [Float64Array.of, \"Float64Array.of\"],\n  [Function, \"Function\"],\n  [globalThis.atob, \"atob\"],\n  [globalThis.btoa, \"btoa\"],\n  [globalThis.clearImmediate, \"clearImmediate\"],\n  [globalThis.clearInterval, \"clearInterval\"],\n  [globalThis.clearTimeout, \"clearTimeout\"],\n  [globalThis.crypto?.getRandomValues, \"crypto.getRandomValues\"],\n  [globalThis.crypto?.randomUUID, \"crypto.randomUUID\"],\n  [globalThis.fetch, \"fetch\"],\n  [globalThis.performance?.now, \"performance.now\"],\n  [globalThis.queueMicrotask, \"queueMicrotask\"],\n  [globalThis.setImmediate, \"setImmediate\"],\n  [globalThis.setInterval, \"setInterval\"],\n  [globalThis.setTimeout, \"setTimeout\"],\n  [globalThis.structuredClone, \"structuredClone\"],\n  [globalThis.URL, \"URL\"],\n  [globalThis.URLSearchParams, \"URLSearchParams\"],\n  [globalThis.WritableStream, \"WritableStream\"],\n  [Int16Array, \"Int16Array\"],\n  [Int16Array.from, \"Int16Array.from\"],\n  [Int16Array.of, \"Int16Array.of\"],\n  [Int32Array, \"Int32Array\"],\n  [Int32Array.from, \"Int32Array.from\"],\n  [Int32Array.of, \"Int32Array.of\"],\n  [Int8Array, \"Int8Array\"],\n  [Int8Array.from, \"Int8Array.from\"],\n  [Int8Array.of, \"Int8Array.of\"],\n  [Intl.Collator, \"Intl.Collator\"],\n  [Intl.DateTimeFormat, \"Intl.DateTimeFormat\"],\n  [Intl.DisplayNames, \"Intl.DisplayNames\"],\n  [Intl.getCanonicalLocales, \"Intl.getCanonicalLocales\"],\n  [Intl.ListFormat, \"Intl.ListFormat\"],\n  [Intl.Locale, \"Intl.Locale\"],\n  [Intl.NumberFormat, \"Intl.NumberFormat\"],\n  [Intl.PluralRules, \"Intl.PluralRules\"],\n  [Intl.RelativeTimeFormat, \"Intl.RelativeTimeFormat\"],\n  [Intl.Segmenter, \"Intl.Segmenter\"],\n  [Intl.supportedValuesOf, \"Intl.supportedValuesOf\"],\n  [isFinite, \"isFinite\"],\n  [isNaN, \"isNaN\"],\n  [JSON.parse, \"JSON.parse\"],\n  [JSON.stringify, \"JSON.stringify\"],\n  [Map, \"Map\"],\n  [Map.groupBy, \"Map.groupBy\"],\n  [Math.abs, \"Math.abs\"],\n  [Math.acos, \"Math.acos\"],\n  [Math.acosh, \"Math.acosh\"],\n  [Math.asin, \"Math.asin\"],\n  [Math.asinh, \"Math.asinh\"],\n  [Math.atan, \"Math.atan\"],\n  [Math.atan2, \"Math.atan2\"],\n  [Math.atanh, \"Math.atanh\"],\n  [Math.cbrt, \"Math.cbrt\"],\n  [Math.ceil, \"Math.ceil\"],\n  [Math.clz32, \"Math.clz32\"],\n  [Math.cos, \"Math.cos\"],\n  [Math.cosh, \"Math.cosh\"],\n  [Math.exp, \"Math.exp\"],\n  [Math.expm1, \"Math.expm1\"],\n  [Math.floor, \"Math.floor\"],\n  [Math.fround, \"Math.fround\"],\n  [Math.hypot, \"Math.hypot\"],\n  [Math.imul, \"Math.imul\"],\n  [Math.log, \"Math.log\"],\n  [Math.log10, \"Math.log10\"],\n  [Math.log1p, \"Math.log1p\"],\n  [Math.log2, \"Math.log2\"],\n  [Math.max, \"Math.max\"],\n  [Math.min, \"Math.min\"],\n  [Math.pow, \"Math.pow\"],\n  [Math.random, \"Math.random\"],\n  [Math.round, \"Math.round\"],\n  [Math.sign, \"Math.sign\"],\n  [Math.sin, \"Math.sin\"],\n  [Math.sinh, \"Math.sinh\"],\n  [Math.sqrt, \"Math.sqrt\"],\n  [Math.tan, \"Math.tan\"],\n  [Math.tanh, \"Math.tanh\"],\n  [Math.trunc, \"Math.trunc\"],\n  [Number, \"Number\"],\n  [Number.isFinite, \"Number.isFinite\"],\n  [Number.isInteger, \"Number.isInteger\"],\n  [Number.isNaN, \"Number.isNaN\"],\n  [Number.isSafeInteger, \"Number.isSafeInteger\"],\n  [Number.parseFloat, \"Number.parseFloat\"],\n  [Number.parseInt, \"Number.parseInt\"],\n  [Object, \"Object\"],\n  [Object.assign, \"Object.assign\"],\n  [Object.create, \"Object.create\"],\n  [Object.defineProperties, \"Object.defineProperties\"],\n  [Object.defineProperty, \"Object.defineProperty\"],\n  [Object.entries, \"Object.entries\"],\n  [Object.freeze, \"Object.freeze\"],\n  [Object.fromEntries, \"Object.fromEntries\"],\n  [Object.getOwnPropertyDescriptor, \"Object.getOwnPropertyDescriptor\"],\n  [Object.getOwnPropertyDescriptors, \"Object.getOwnPropertyDescriptors\"],\n  [Object.getOwnPropertyNames, \"Object.getOwnPropertyNames\"],\n  [Object.getOwnPropertySymbols, \"Object.getOwnPropertySymbols\"],\n  [Object.getPrototypeOf, \"Object.getPrototypeOf\"],\n  [Object.is, \"Object.is\"],\n  [Object.isExtensible, \"Object.isExtensible\"],\n  [Object.isFrozen, \"Object.isFrozen\"],\n  [Object.isSealed, \"Object.isSealed\"],\n  [Object.keys, \"Object.keys\"],\n  [Object.preventExtensions, \"Object.preventExtensions\"],\n  [Object.seal, \"Object.seal\"],\n  [Object.setPrototypeOf, \"Object.setPrototypeOf\"],\n  [Object.values, \"Object.values\"],\n  [parseFloat, \"parseFloat\"],\n  [parseInt, \"parseInt\"],\n  [Promise, \"Promise\"],\n  [Proxy, \"Proxy\"],\n  [RangeError, \"RangeError\"],\n  [ReferenceError, \"ReferenceError\"],\n  [Reflect.apply, \"Reflect.apply\"],\n  [Reflect.construct, \"Reflect.construct\"],\n  [Reflect.defineProperty, \"Reflect.defineProperty\"],\n  [Reflect.deleteProperty, \"Reflect.deleteProperty\"],\n  [Reflect.get, \"Reflect.get\"],\n  [Reflect.getOwnPropertyDescriptor, \"Reflect.getOwnPropertyDescriptor\"],\n  [Reflect.getPrototypeOf, \"Reflect.getPrototypeOf\"],\n  [Reflect.has, \"Reflect.has\"],\n  [Reflect.isExtensible, \"Reflect.isExtensible\"],\n  [Reflect.ownKeys, \"Reflect.ownKeys\"],\n  [Reflect.preventExtensions, \"Reflect.preventExtensions\"],\n  [Reflect.set, \"Reflect.set\"],\n  [Reflect.setPrototypeOf, \"Reflect.setPrototypeOf\"],\n  [RegExp, \"RegExp\"],\n  [Set, \"Set\"],\n  [String, \"String\"],\n  [String.fromCharCode, \"String.fromCharCode\"],\n  [String.fromCodePoint, \"String.fromCodePoint\"],\n  [String.raw, \"String.raw\"],\n  [Symbol, \"Symbol\"],\n  [Symbol.for, \"Symbol.for\"],\n  [SyntaxError, \"SyntaxError\"],\n  [TypeError, \"TypeError\"],\n  [Uint16Array, \"Uint16Array\"],\n  [Uint16Array.from, \"Uint16Array.from\"],\n  [Uint16Array.of, \"Uint16Array.of\"],\n  [Uint32Array, \"Uint32Array\"],\n  [Uint32Array.from, \"Uint32Array.from\"],\n  [Uint32Array.of, \"Uint32Array.of\"],\n  [Uint8Array, \"Uint8Array\"],\n  [Uint8Array.from, \"Uint8Array.from\"],\n  [Uint8Array.of, \"Uint8Array.of\"],\n  [Uint8ClampedArray, \"Uint8ClampedArray\"],\n  [Uint8ClampedArray.from, \"Uint8ClampedArray.from\"],\n  [Uint8ClampedArray.of, \"Uint8ClampedArray.of\"],\n  [URIError, \"URIError\"],\n  [WeakMap, \"WeakMap\"],\n  [WeakSet, \"WeakSet\"]\n]);\nvar KNOWN_OBJECTS = /* @__PURE__ */ new Map([\n  [Atomics, \"Atomics\"],\n  [console, \"console\"],\n  [globalThis, \"globalThis\"],\n  [globalThis.crypto, \"crypto\"],\n  [Intl, \"Intl\"],\n  [JSON, \"JSON\"],\n  [Math, \"Math\"],\n  [Reflect, \"Reflect\"]\n]);\nfunction toAccess(accessor) {\n  const start = accessor[0];\n  return start === '\"' || start >= \"0\" && start <= \"9\" ? \"[\" + accessor + \"]\" : \".\" + accessor;\n}\nfunction patchIteratorNext(proto) {\n  const { next } = proto;\n  proto.next = function(value) {\n    this[kTouchedIterator] = 1;\n    return next.call(this, value);\n  };\n}\n\n// src/html/writer.ts\nvar K_SCOPE_ID = Symbol(\"Scope ID\");\nvar kPendingContexts = Symbol(\"Pending Contexts\");\nvar branchIdKey = Symbol();\nif (false) {\n  writeScope = /* @__PURE__ */ ((writeScope2) => (scopeId, partialScope, file, loc, vars) => {\n    const scope = writeScope2(scopeId, partialScope);\n    if (file && loc !== void 0) {\n      setDebugInfo(scope, file, loc, vars);\n    }\n    return scope;\n  })(writeScope);\n}\nvar tick = globalThis.setImmediate || globalThis.setTimeout || globalThis.queueMicrotask || ((cb) => Promise.resolve().then(cb));\n\n// src/html/attrs.ts\nfunction classAttr(value) {\n  return stringAttr(\"class\", classValue(value));\n}\nfunction styleAttr(value) {\n  return stringAttr(\"style\", styleValue(value));\n}\nvar kSelectedValue = Symbol(\"selectedValue\");\nfunction attr(name2, value) {\n  return isVoid(value) ? \"\" : nonVoidAttr(name2, value);\n}\nfunction stringAttr(name2, value) {\n  return value && \" \" + name2 + attrAssignment(value);\n}\nfunction nonVoidAttr(name2, value) {\n  switch (typeof value) {\n    case \"string\":\n      return \" \" + name2 + attrAssignment(value);\n    case \"boolean\":\n      return \" \" + name2;\n    case \"number\":\n      return \" \" + name2 + \"=\" + value;\n    case \"object\":\n      if (value instanceof RegExp) {\n        return \" \" + name2 + attrAssignment(value.source);\n      }\n      break;\n  }\n  return \" \" + name2 + attrAssignment(value + \"\");\n}\nvar singleQuoteAttrReplacements = /'|&(?=#?\\w+;)/g;\nvar doubleQuoteAttrReplacements = /\"|&(?=#?\\w+;)/g;\nvar needsQuotedAttr = /[\"'>\\s]|&#?\\w+;|\\/$/g;\nfunction attrAssignment(value) {\n  return value ? needsQuotedAttr.test(value) ? value[needsQuotedAttr.lastIndex - 1] === (needsQuotedAttr.lastIndex = 0, '\"') ? \"='\" + escapeSingleQuotedAttrValue(value) + \"'\" : '=\"' + escapeDoubleQuotedAttrValue(value) + '\"' : \"=\" + value : \"\";\n}\nfunction escapeSingleQuotedAttrValue(value) {\n  return singleQuoteAttrReplacements.test(value) ? value.replace(\n    singleQuoteAttrReplacements,\n    replaceUnsafeSingleQuoteAttrChar\n  ) : value;\n}\nfunction replaceUnsafeSingleQuoteAttrChar(match) {\n  return match === \"'\" ? \"&#39;\" : \"&amp;\";\n}\nfunction escapeDoubleQuotedAttrValue(value) {\n  return doubleQuoteAttrReplacements.test(value) ? value.replace(\n    doubleQuoteAttrReplacements,\n    replaceUnsafeDoubleQuoteAttrChar\n  ) : value;\n}\nfunction replaceUnsafeDoubleQuoteAttrChar(match) {\n  return match === '\"' ? \"&#34;\" : \"&amp;\";\n}\n\n// src/common/compat-meta.ts\nvar prefix = false ? \"$compat_\" : \"$C_\";\nvar RENDERER_REGISTER_ID = prefix + (false ? \"renderer\" : \"r\");\nvar SET_SCOPE_REGISTER_ID = prefix + (false ? \"setScope\" : \"s\");\nvar RENDER_BODY_ID = prefix + (false ? \"renderBody\" : \"b\");\n\n// src/html/compat.ts\nvar K_TAGS_API_STATE = Symbol();\n\n// src/translator/util/to-property-name.ts\nvar import_compiler11 = require(\"@marko/compiler\");\nfunction isValidPropertyIdentifier(name2) {\n  return /^[a-z_$][a-z0-9_$]*$/i.test(name2);\n}\nfunction toPropertyName(name2) {\n  if (isValidPropertyIdentifier(name2)) {\n    return import_compiler11.types.identifier(name2);\n  } else if (/^(?:0|[1-9][0-9]*)$/.test(name2)) {\n    return import_compiler11.types.numericLiteral(parseInt(name2, 10));\n  }\n  return import_compiler11.types.stringLiteral(name2);\n}\nfunction toObjectProperty(name2, value) {\n  return import_compiler11.types.objectProperty(toPropertyName(name2), value);\n}\nfunction toMemberExpression(object, key, optional) {\n  const prop = toPropertyName(key);\n  const computed = prop.type !== \"Identifier\";\n  return optional ? import_compiler11.types.optionalMemberExpression(object, prop, computed, true) : import_compiler11.types.memberExpression(object, prop, computed);\n}\n\n// src/translator/util/runtime.ts\nvar pureDOMFunctions = /* @__PURE__ */ new Set([\n  \"awaitTag\",\n  \"conditional\",\n  \"conditionalClosure\",\n  \"createTry\",\n  \"dynamicTag\",\n  \"createRenderer\",\n  \"createContent\",\n  \"createTemplate\",\n  \"dynamicClosure\",\n  \"dynamicClosureRead\",\n  \"intersection\",\n  \"loopClosure\",\n  \"loopIn\",\n  \"loopOf\",\n  \"loopTo\",\n  \"state\",\n  \"value\"\n]);\nfunction importRuntime(name2) {\n  const { output } = getMarkoOpts();\n  return toMemberExpression(\n    (0, import_babel_utils7.importStar)((0, import_compiler12.getFile)(), getRuntimePath(output), \"$\"),\n    name2\n  );\n}\nfunction callRuntime(name2, ...args) {\n  const callExpression2 = import_compiler12.types.callExpression(\n    importRuntime(name2),\n    filterArguments(args)\n  );\n  if (isOutputDOM() && pureDOMFunctions.has(name2)) {\n    callExpression2.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: ` @__PURE__ `\n      }\n    ];\n  }\n  return callExpression2;\n}\nfunction getHTMLRuntime() {\n  return {\n    escapeXML,\n    toString,\n    attr,\n    classAttr,\n    styleAttr,\n    escapeScript,\n    escapeStyle\n  };\n}\nfunction getRuntimePath(output) {\n  const { optimize } = getMarkoOpts();\n  return `${runtime_info_default.name}/${optimize ? \"\" : \"debug/\"}${output === \"html\" ? \"html\" : \"dom\"}`;\n}\nfunction filterArguments(args) {\n  const filteredArgs = [];\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (arg || filteredArgs.length) {\n      filteredArgs[i] = arg || import_compiler12.types.unaryExpression(\"void\", import_compiler12.types.numericLiteral(0));\n    }\n  }\n  return filteredArgs;\n}\nfunction getCompatRuntimeFile() {\n  const markoOpts = getMarkoOpts();\n  return `marko/src/runtime/helpers/tags-compat/${isOutputHTML() ? \"html\" : \"dom\"}${markoOpts.optimize ? \"\" : \"-debug\"}.${markoOpts.modules === \"esm\" ? \"mjs\" : \"js\"}`;\n}\n\n// src/translator/visitors/program/dom.ts\nvar import_compiler22 = require(\"@marko/compiler\");\nvar import_babel_utils10 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-style-file.ts\nvar import_path = __toESM(require(\"path\"));\nfunction getStyleFile(file) {\n  const { filename } = file.opts;\n  const fs = file.markoOpts.fileSystem;\n  const base = getBase(filename);\n  const styleMatch = new RegExp(\n    `^(${escapeRegExp(base)}\\\\.${\"index\" === base ? \"|\" : \"\"})style\\\\.\\\\w+$`\n  );\n  for (const file2 of fs.readdirSync(import_path.default.dirname(filename)).sort()) {\n    if (styleMatch.test(file2)) {\n      return `./${file2}`;\n    }\n  }\n}\nfunction getBase(filename) {\n  const start = filename.lastIndexOf(import_path.default.sep) + 1;\n  const leftDot = filename.indexOf(\".\", start);\n  if (leftDot === -1) {\n    return filename.slice(start);\n  }\n  const rightDot = filename.lastIndexOf(\".\");\n  const closeBracket = leftDot - 1;\n  if (filename[closeBracket] === \"]\") {\n    const openBracket = filename.lastIndexOf(\"[\", closeBracket);\n    if (openBracket > start) {\n      return filename.slice(start, openBracket) + filename.slice(leftDot, rightDot);\n    }\n  }\n  return filename.slice(start, rightDot);\n}\nvar regexpCharsReg = /[\\\\^$.*+?()[\\]{}|]/g;\nfunction escapeRegExp(str) {\n  return str.replace(regexpCharsReg, \"\\\\$&\");\n}\n\n// src/translator/util/signals.ts\nvar import_compiler21 = require(\"@marko/compiler\");\nvar import_babel_utils9 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/core/return.ts\nvar import_compiler17 = require(\"@marko/compiler\");\nvar import_babel_utils8 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-known-attr-values.ts\nfunction getKnownAttrValues(tag) {\n  const attrs2 = {};\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      attrs2[attr2.name] = attr2.value;\n    }\n  }\n  return attrs2;\n}\n\n// src/translator/util/get-parent-tag.ts\nfunction getParentTag(tag) {\n  const parent = tag.parent.type === \"MarkoTagBody\" ? tag.parentPath.parentPath : tag.parentPath;\n  if (parent.type === \"MarkoTag\") {\n    return parent;\n  }\n}\n\n// src/translator/util/plugin-hooks.ts\nvar import_compiler13 = require(\"@marko/compiler\");\nfunction enter(modulePlugin, path5) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path5;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (isFunctionPlugin(plugin)) {\n    plugin(path5, import_compiler13.types);\n  } else if (plugin.enter) {\n    plugin.enter(path5, import_compiler13.types);\n  }\n  return node !== path5.node;\n}\nfunction exit(modulePlugin, path5) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path5;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (!isFunctionPlugin(plugin) && plugin.exit) {\n    plugin.exit(path5, import_compiler13.types);\n  }\n  return node !== path5.node;\n}\nfunction isModulePlugin(plugin) {\n  return Boolean(plugin.default);\n}\nfunction isFunctionPlugin(plugin) {\n  return typeof plugin === \"function\";\n}\n\n// src/translator/util/visitors.ts\nfunction extractVisitors(visitors2) {\n  const result = {\n    migrate: {},\n    transform: {},\n    analyze: {},\n    translate: {}\n  };\n  for (const _name in visitors2) {\n    const name2 = _name;\n    const value = visitors2[name2];\n    if (value.migrate) result.migrate[name2] = value.migrate;\n    if (value.transform) result.transform[name2] = value.transform;\n    if (value.analyze) result.analyze[name2] = value.analyze;\n    if (value.translate) result.translate[name2] = value.translate;\n  }\n  return result;\n}\nfunction translateByTarget({\n  html,\n  dom\n}) {\n  return {\n    enter(path5) {\n      enter(isOutputHTML() ? html : dom, path5);\n    },\n    exit(path5) {\n      exit(isOutputHTML() ? html : dom, path5);\n    }\n  };\n}\n\n// src/translator/util/writer.ts\nvar import_compiler16 = require(\"@marko/compiler\");\n\n// src/translator/util/normalize-string-expression.ts\nvar import_compiler14 = require(\"@marko/compiler\");\nfunction normalizeStringExpression(parts) {\n  const strs = [];\n  const exprs = [];\n  let curStr = parts[0];\n  for (let i = 1; i < parts.length; i++) {\n    let content = parts[i];\n    if (typeof content === \"object\") {\n      if (import_compiler14.types.isStringLiteral(content)) {\n        content = content.value;\n      } else if (import_compiler14.types.isTemplateLiteral(content)) {\n        let nextIndex = i + 1;\n        const exprLen = content.expressions.length;\n        shiftItems(parts, nextIndex, content.quasis.length + exprLen);\n        for (let j = 0; j < exprLen; j++) {\n          parts[nextIndex++] = content.quasis[j].value.raw;\n          parts[nextIndex++] = content.expressions[j];\n        }\n        parts[nextIndex] = content.quasis[exprLen].value.raw;\n        continue;\n      } else {\n        exprs.push(content);\n        strs.push(curStr);\n        curStr = \"\";\n        continue;\n      }\n    }\n    curStr += content;\n  }\n  if (exprs.length) {\n    if (exprs.length === 1 && !curStr && !strs[0]) {\n      return exprs[0];\n    }\n    strs.push(curStr);\n    return import_compiler14.types.templateLiteral(\n      strs.map((raw) => import_compiler14.types.templateElement({ raw })),\n      exprs\n    );\n  } else if (curStr) {\n    return import_compiler14.types.stringLiteral(curStr);\n  }\n}\nfunction appendLiteral(arr, str) {\n  arr[arr.length - 1] += str;\n}\nfunction shiftItems(list, start, offset) {\n  for (let i = list.length - 1; i >= start; i--) {\n    list[i + offset] = list[i];\n  }\n}\n\n// src/translator/util/walks.ts\nvar import_compiler15 = require(\"@marko/compiler\");\nvar [getWalks] = createSectionState(\n  \"walks\",\n  () => [\"\"]\n);\nvar [getWalkComment] = createSectionState(\n  \"walkComment\",\n  () => []\n);\nvar [getSteps] = createSectionState(\"steps\", () => []);\nvar walkCodeToName = {\n  [32 /* Get */]: \"get\",\n  [36 /* Inside */]: \"inside\",\n  [37 /* Replace */]: \"replace\",\n  [38 /* EndChild */]: \"endChild\",\n  [47 /* BeginChild */]: \"beginChild\",\n  [48 /* BeginChildWithVar */]: \"beginChildWithVar\",\n  [49 /* DynamicTagWithVar */]: \"dynamicTagWithVar\",\n  [67 /* Next */]: \"next\",\n  [97 /* Over */]: \"over\",\n  [107 /* Out */]: \"out\",\n  [117 /* Multiplier */]: \"multiplier\",\n  [91 /* NextEnd */]: \"nextEnd\",\n  [106 /* OverEnd */]: \"overEnd\",\n  [116 /* OutEnd */]: \"outEnd\",\n  [126 /* MultiplierEnd */]: \"multiplierEnd\"\n};\nfunction enter2(path5) {\n  getSteps(getSection(path5)).push(0 /* Enter */);\n}\nfunction exit2(path5) {\n  getSteps(getSection(path5)).push(1 /* Exit */);\n}\nfunction enterShallow(path5) {\n  getSteps(getSection(path5)).push(0 /* Enter */, 1 /* Exit */);\n}\nfunction injectWalks(tag, expr) {\n  const walks = getWalks(getSection(tag));\n  const walkComment = getWalkComment(getSection(tag));\n  walkComment.push(\n    `${walkCodeToName[tag.node.var ? 48 /* BeginChildWithVar */ : 47 /* BeginChild */]}`,\n    expr.name,\n    walkCodeToName[38 /* EndChild */]\n  );\n  appendLiteral(\n    walks,\n    String.fromCharCode(\n      tag.node.var ? 48 /* BeginChildWithVar */ : 47 /* BeginChild */\n    )\n  );\n  walks.push(expr, String.fromCharCode(38 /* EndChild */));\n}\nfunction visit(path5, code) {\n  if (isOutputHTML()) {\n    return;\n  }\n  const section = getSection(path5);\n  const steps = getSteps(section);\n  const walks = getWalks(section);\n  const walkComment = getWalkComment(section);\n  let walkString = \"\";\n  if (steps.length) {\n    const walkCodes = [];\n    let depth = 0;\n    for (const step of steps) {\n      if (step === 0 /* Enter */) {\n        depth++;\n        walkCodes.push(67 /* Next */);\n      } else {\n        depth--;\n        if (depth >= 0) {\n          walkCodes.length = walkCodes.lastIndexOf(67 /* Next */);\n          walkCodes.push(97 /* Over */);\n        } else {\n          walkCodes.length = walkCodes.lastIndexOf(107 /* Out */) + 1;\n          walkCodes.push(107 /* Out */);\n          depth = 0;\n        }\n      }\n    }\n    let current = walkCodes[0];\n    let count = 0;\n    for (const walk of walkCodes) {\n      if (walk !== current) {\n        walkComment.push(`${walkCodeToName[current]}(${count})`);\n        walkString += nCodeString(current, count);\n        current = walk;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n    walkComment.push(`${walkCodeToName[current]}(${count})`);\n    walkString += nCodeString(current, count);\n    steps.length = 0;\n  }\n  if (code !== void 0) {\n    if (code !== 32 /* Get */) {\n      writeTo(path5)`<!>`;\n    }\n    walkComment.push(`${walkCodeToName[code]}`);\n    walkString += String.fromCharCode(code);\n  }\n  appendLiteral(walks, walkString);\n}\nfunction nCodeString(code, number) {\n  switch (code) {\n    case 67 /* Next */:\n      return toCharString(number, code, 20 /* Next */);\n    case 97 /* Over */:\n      return toCharString(number, code, 10 /* Over */);\n    case 107 /* Out */:\n      return toCharString(number, code, 10 /* Out */);\n    default:\n      throw new Error(`Unexpected walk code: ${code}`);\n  }\n}\nfunction toCharString(number, startCode, rangeSize) {\n  let result = \"\";\n  if (number >= rangeSize) {\n    const multiplier = Math.floor(number / rangeSize);\n    result += toCharString(\n      multiplier,\n      117 /* Multiplier */,\n      10 /* Multiplier */\n    );\n    number -= multiplier * rangeSize;\n  }\n  result += String.fromCharCode(startCode + number);\n  return result;\n}\nfunction getWalkString(section) {\n  const prefix2 = section.content?.startType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const postfix = section.content?.endType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const walks = getWalks(section);\n  const walkLiteral = normalizeStringExpression([prefix2, ...walks, postfix]);\n  if (walkLiteral && walkLiteral.value !== \"\") {\n    walkLiteral.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: \" \" + getWalkComment(section).join(\", \") + \" \"\n      }\n    ];\n  }\n  return walkLiteral;\n}\n\n// src/translator/util/writer.ts\nvar [getWrites] = createSectionState(\n  \"writes\",\n  () => [\"\"]\n);\nvar [getTrailerWrites] = createSectionState(\n  \"trailerWrites\",\n  () => [\"\"]\n);\nfunction writeTo(path5, trailer) {\n  const section = getSection(path5);\n  const get = trailer ? getTrailerWrites : getWrites;\n  return (strs, ...exprs) => {\n    const exprsLen = exprs.length;\n    const writes = get(section);\n    appendLiteral(writes, strs[0]);\n    for (let i = 0; i < exprsLen; i++) {\n      writes.push(exprs[i], strs[i + 1]);\n    }\n  };\n}\nfunction consumeHTML(path5) {\n  const section = getSection(path5);\n  const writes = getWrites(section);\n  const trailers = getTrailerWrites(section);\n  const writeResult = normalizeStringExpression(writes);\n  const trailerResult = normalizeStringExpression(trailers);\n  writes.length = 0;\n  writes[0] = \"\";\n  trailers.length = 0;\n  trailers[0] = \"\";\n  if (writeResult && trailerResult) {\n    return import_compiler16.types.expressionStatement(\n      import_compiler16.types.sequenceExpression([\n        callRuntime(\"write\", writeResult),\n        callRuntime(\"writeTrailers\", trailerResult)\n      ])\n    );\n  } else if (writeResult) {\n    return import_compiler16.types.expressionStatement(callRuntime(\"write\", writeResult));\n  } else if (trailerResult) {\n    return import_compiler16.types.expressionStatement(callRuntime(\"writeTrailers\", trailerResult));\n  }\n}\nfunction flushBefore(path5) {\n  const expr = consumeHTML(path5);\n  if (expr) {\n    path5.insertBefore(expr)[0].skip();\n  }\n}\nfunction flushInto(path5) {\n  const target = path5.isProgram() ? path5 : path5.get(\"body\");\n  const expr = consumeHTML(target);\n  if (expr) {\n    target.node.body.push(expr);\n  }\n}\nfunction getSectionMeta(section) {\n  const writePrefix = section.content?.startType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writePostfix = section.content?.endType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writes = getWrites(section);\n  return {\n    setup: getSetup(section),\n    walks: getWalkString(section),\n    writes: normalizeStringExpression([writePrefix, ...writes, writePostfix])\n  };\n}\nfunction markNode(path5, binding) {\n  const section = getSection(path5);\n  if (binding.type !== 0 /* dom */) {\n    throw path5.buildCodeFrameError(\n      \"Tried to mark a node that was not determined to need a mark during analyze.\"\n    );\n  }\n  if (isOutputHTML()) {\n    writeTo(path5)`${callRuntime(\n      \"markResumeNode\",\n      getScopeIdIdentifier(section),\n      getScopeAccessorLiteral(binding)\n    )}`;\n  }\n}\n\n// src/translator/core/return.ts\nvar tagsWithReturn = /* @__PURE__ */ new WeakSet();\nvar [getSectionReturnValueIdentifier, setReturnValueIdentifier] = createSectionState(\"returnValue\");\nvar return_default = {\n  analyze(tag) {\n    (0, import_babel_utils8.assertNoArgs)(tag);\n    (0, import_babel_utils8.assertNoVar)(tag);\n    (0, import_babel_utils8.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils8.assertAllowedAttributes)(tag, [\"value\", \"valueChange\"]);\n    const parentTag = getParentTag(tag);\n    if (parentTag) {\n      if ((0, import_babel_utils8.isNativeTag)(parentTag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The `return` tag can not be used in a native tag.\"\n        );\n      } else if (isControlFlowTag(parentTag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          `The \\`return\\` tag can not be used under an \\`${parentTag.get(\"name\").toString()}\\` tag.`\n        );\n      }\n    }\n    if (tagsWithReturn.has(tag.parentPath)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        `Cannot have multiple \\`return\\` tags ${tag.parent.type === \"Program\" ? \"for the template\" : \"within a tag's body content\"}.`\n      );\n    } else {\n      tagsWithReturn.add(tag.parentPath);\n    }\n    if (!getKnownAttrValues(tag.node).value) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `return` tag requires a value.\");\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      exit(tag) {\n        const section = getSection(tag);\n        const attrs2 = getKnownAttrValues(tag.node);\n        flushBefore(tag);\n        if (attrs2.valueChange) {\n          setSerializedProperty(\n            section,\n            getAccessorProp().TagVariableChange,\n            attrs2.valueChange,\n            true\n            // TODO: this should be based on the child actually mutating the tag variable.\n          );\n        }\n        if (attrs2.value) {\n          const returnId = generateUidIdentifier(\"return\");\n          setReturnValueIdentifier(section, returnId);\n          tag.replaceWith(\n            import_compiler17.types.variableDeclaration(\"const\", [\n              import_compiler17.types.variableDeclarator(returnId, attrs2.value)\n            ])\n          )[0].skip();\n        }\n      }\n    },\n    dom: {\n      exit(tag) {\n        const section = getSection(tag);\n        const attrs2 = getKnownAttrValues(tag.node);\n        if (attrs2.value) {\n          addValue(\n            section,\n            attrs2.value.extra?.referencedBindings,\n            {\n              identifier: importRuntime(\"tagVarSignal\"),\n              hasDownstreamIntersections: () => true\n            },\n            attrs2.value\n          );\n        }\n        if (attrs2.valueChange) {\n          addValue(\n            section,\n            attrs2.valueChange.extra?.referencedBindings,\n            {\n              identifier: importRuntime(\"setTagVarChange\"),\n              hasDownstreamIntersections: () => false\n            },\n            attrs2.valueChange\n          );\n        }\n        tag.remove();\n      }\n    }\n  }),\n  parseOptions: {\n    openTagOnly: true\n  },\n  autocomplete: [\n    {\n      displayText: \"return=<value>\",\n      description: \"Provides a value for use in a parent template.\",\n      snippet: \"return=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#return\"\n    }\n  ]\n};\n\n// src/translator/util/get-defined-binding-expression.ts\nvar import_compiler18 = require(\"@marko/compiler\");\nfunction getDeclaredBindingExpression(binding) {\n  if (binding.declared || !binding.upstreamAlias) {\n    return import_compiler18.types.identifier(binding.name);\n  } else if (binding.property !== void 0) {\n    return toMemberExpression(\n      getDeclaredBindingExpression(binding.upstreamAlias),\n      binding.property,\n      binding.upstreamAlias.nullable\n    );\n  } else {\n    return getDeclaredBindingExpression(binding.upstreamAlias);\n  }\n}\n\n// src/translator/util/simplify-fn.ts\nvar import_compiler19 = require(\"@marko/compiler\");\nfunction simplifyFunction(fn) {\n  switch (fn.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return fn;\n    default:\n      return import_compiler19.types.functionExpression(\n        null,\n        fn.params,\n        fn.body,\n        fn.async,\n        fn.generator\n      );\n  }\n}\n\n// src/translator/util/to-first-expression-or-block.ts\nvar import_compiler20 = require(\"@marko/compiler\");\nfunction toFirstExpressionOrBlock(stmts) {\n  if (stmts.length === 1 && import_compiler20.types.isExpressionStatement(stmts[0])) {\n    const { expression } = stmts[0];\n    switch (expression.type) {\n      case \"ObjectExpression\":\n      case \"AssignmentExpression\":\n        return toParenthesizedExpressionIfNeeded(expression);\n      default:\n        return expression;\n    }\n  }\n  return import_compiler20.types.blockStatement(stmts);\n}\nfunction toParenthesizedExpressionIfNeeded(expr) {\n  switch (expr.type) {\n    case \"ObjectExpression\":\n    case \"AssignmentExpression\":\n      return import_compiler20.types.parenthesizedExpression(expr);\n    default:\n      return expr;\n  }\n}\n\n// src/translator/util/signals.ts\nvar [getSignals] = createSectionState(\n  \"signals\",\n  () => /* @__PURE__ */ new Map()\n);\nvar [getClosureSignalBuilder, _setClosureSignalBuilder] = createSectionState(\"queue\");\nfunction setClosureSignalBuilder(tag, builder) {\n  _setClosureSignalBuilder(getSectionForBody(tag.get(\"body\")), builder);\n}\nvar [serializeSectionReason, setSerializeSectionReason] = createSectionState(\"serializeSectionSources\");\nfunction serializeSectionIfNeeded(section, reason) {\n  if (reason) {\n    const existingReason = serializeSectionReason(section);\n    if (existingReason === true) return;\n    if (!existingReason || reason === true) {\n      setSerializeSectionReason(section, reason);\n    } else {\n      setSerializeSectionReason(\n        section,\n        bindingUtil.union(existingReason, reason)\n      );\n    }\n  }\n}\nvar [getSerializedScopeProperties] = createSectionState(\"serializedScopeProperties\", () => /* @__PURE__ */ new Map());\nfunction setSerializedProperty(section, key, expression, reason) {\n  if (reason) {\n    getSerializedScopeProperties(section).set(key, { expression, reason });\n  }\n}\nvar [getSectionWriteScopeBuilder, setSectionWriteScopeBuilder] = createSectionState(\n  \"sectionWriteScopeBuilder\"\n);\nfunction addWriteScopeBuilder(section, builder) {\n  const prev = getSectionWriteScopeBuilder(section);\n  setSectionWriteScopeBuilder(\n    section,\n    prev ? (expr) => builder(prev(expr)) : builder\n  );\n}\nvar htmlDynamicClosureInstancesIdentifier = /* @__PURE__ */ new WeakMap();\nvar [getHTMLSectionStatements] = createSectionState(\n  \"htmlScopeStatements\",\n  () => []\n);\nvar [getHoistFunctionsIdsMap] = createSectionState(\"hoistFunctionsIdsMap\", () => /* @__PURE__ */ new Map());\nfunction getHoistFunctionIdentifier(hoistedBinding) {\n  const idsMap = getHoistFunctionsIdsMap(hoistedBinding.section);\n  let identifier = idsMap.get(hoistedBinding);\n  if (!identifier) {\n    idsMap.set(\n      hoistedBinding,\n      identifier = generateUidIdentifier(`get${hoistedBinding.name}`)\n    );\n  }\n  return identifier;\n}\nvar unimplementedBuild = () => {\n  return import_compiler21.types.stringLiteral(\"SIGNAL NOT INITIALIZED\");\n};\nfunction getSignal(section, referencedBindings, name2 = generateSignalName(referencedBindings)) {\n  const signals = getSignals(section);\n  let signal = signals.get(referencedBindings);\n  if (!signal) {\n    const exportName = referencedBindings ? !Array.isArray(referencedBindings) && referencedBindings.section === section && referencedBindings.export : !section.parent && (0, import_compiler21.getProgram)().node.extra.domExports?.setup;\n    signals.set(\n      referencedBindings,\n      signal = {\n        identifier: exportName ? import_compiler21.types.identifier(exportName) : generateUidIdentifier(name2 + section.name.replace(\"_\", \"$\")),\n        referencedBindings,\n        section,\n        values: [],\n        intersection: void 0,\n        render: [],\n        renderReferencedBindings: void 0,\n        effect: [],\n        effectReferencedBindings: void 0,\n        subscribers: [],\n        hasDownstreamIntersections: () => {\n          let hasDownstreamIntersections = !!signal.intersection;\n          if (!hasDownstreamIntersections) {\n            for (const value of signal.values) {\n              if (value.signal.hasDownstreamIntersections()) {\n                hasDownstreamIntersections = true;\n                break;\n              }\n            }\n          }\n          if (!hasDownstreamIntersections) {\n            if (!Array.isArray(referencedBindings) && referencedBindings) {\n              for (const alias of referencedBindings.aliases) {\n                if (getSignal(section, alias).hasDownstreamIntersections()) {\n                  hasDownstreamIntersections = true;\n                  break;\n                }\n              }\n              if (!hasDownstreamIntersections) {\n                for (const [, alias] of referencedBindings.propertyAliases) {\n                  if (getSignal(section, alias).hasDownstreamIntersections()) {\n                    hasDownstreamIntersections = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          signal.hasDownstreamIntersections = () => hasDownstreamIntersections;\n          return hasDownstreamIntersections;\n        },\n        build: unimplementedBuild,\n        export: !!exportName\n      }\n    );\n    if (isOutputHTML()) {\n      return signal;\n    } else if (!referencedBindings) {\n      signal.build = () => getSignalFn(signal);\n    } else if (Array.isArray(referencedBindings)) {\n      subscribe(referencedBindings, signal);\n      signal.build = () => {\n        const { id, scopeOffset } = intersectionMeta.get(referencedBindings);\n        return callRuntime(\n          \"intersection\",\n          import_compiler21.types.numericLiteral(id),\n          getSignalFn(signal),\n          scopeOffset || referencedBindings.length > 2 ? import_compiler21.types.numericLiteral(referencedBindings.length - 1) : void 0,\n          scopeOffset && getScopeAccessorLiteral(scopeOffset)\n        );\n      };\n    } else if (referencedBindings.section !== section && bindingUtil.find(section.referencedClosures, referencedBindings)) {\n      signal.build = () => {\n        const render = getSignalFn(signal);\n        const closureSignalBuilder = getClosureSignalBuilder(section);\n        return !closureSignalBuilder || isDynamicClosure(section, referencedBindings) ? callRuntime(\n          \"dynamicClosureRead\",\n          getScopeAccessorLiteral(referencedBindings),\n          render,\n          isImmediateOwner(section, referencedBindings) ? void 0 : import_compiler21.types.arrowFunctionExpression(\n            [scopeIdentifier],\n            getScopeExpression(section, referencedBindings.section)\n          )\n        ) : getClosureSignalBuilder(section)(referencedBindings, render);\n      };\n    }\n  }\n  return signal;\n}\nfunction initValue(binding, runtimeHelper = \"value\") {\n  const section = binding.section;\n  const signal = getSignal(section, binding);\n  signal.build = () => {\n    const fn = getSignalFn(signal);\n    const isParamBinding = !binding.upstreamAlias && (binding.type === 3 /* param */ || binding.type === 2 /* input */);\n    const isNakedAlias = binding.upstreamAlias && !binding.property;\n    const needsGuard = !isNakedAlias && (binding.downstreamExpressions.size || fn.type === \"ArrowFunctionExpression\" && fn.body.body.length > 0);\n    const needsCache = needsGuard || signal.intersection;\n    const needsMarks = isParamBinding || signal.intersection;\n    if (needsCache || needsMarks || binding.hoists.size) {\n      return callRuntime(\n        runtimeHelper,\n        getScopeAccessorLiteral(binding, runtimeHelper === \"state\"),\n        fn\n      );\n    } else {\n      return fn;\n    }\n  };\n  signal.valueAccessor = getScopeAccessorLiteral(binding);\n  for (const alias of binding.aliases) {\n    initValue(alias);\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    initValue(alias);\n  }\n  return signal;\n}\nfunction getSignalFn(signal) {\n  const section = signal.section;\n  const binding = signal.referencedBindings;\n  const params = [scopeIdentifier];\n  const isIntersection = Array.isArray(binding);\n  const isBinding = binding && !isIntersection;\n  const isValue = isBinding && binding.section === section;\n  let canUseCalleeDirectly = !signal.render.length;\n  if (isBinding && (signal.renderReferencedBindings || binding.aliases.size || binding.propertyAliases.size)) {\n    const valueParam = import_compiler21.types.identifier(binding.name);\n    if (binding.loc) {\n      valueParam.loc = binding.loc;\n      valueParam.start = binding.loc.start.index;\n      valueParam.end = binding.loc.end.index;\n    }\n    params.push(valueParam);\n  }\n  if (isValue) {\n    for (const alias of binding.aliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler21.types.expressionStatement(\n          import_compiler21.types.callExpression(aliasSignal.identifier, [\n            scopeIdentifier,\n            import_compiler21.types.identifier(binding.name),\n            ...getTranslatedExtraArgs(aliasSignal)\n          ])\n        )\n      );\n    }\n    for (const [key, alias] of binding.propertyAliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler21.types.expressionStatement(\n          import_compiler21.types.callExpression(aliasSignal.identifier, [\n            scopeIdentifier,\n            toMemberExpression(\n              import_compiler21.types.identifier(binding.name),\n              key,\n              binding.nullable\n            ),\n            ...getTranslatedExtraArgs(aliasSignal)\n          ])\n        )\n      );\n    }\n  }\n  for (const value of signal.values) {\n    signal.render.push(\n      import_compiler21.types.expressionStatement(\n        import_compiler21.types.callExpression(value.signal.identifier, [\n          value.scope,\n          value.value,\n          ...getTranslatedExtraArgs(value.signal)\n        ])\n      )\n    );\n  }\n  forEach(signal.intersection, (intersection) => {\n    signal.render.push(\n      import_compiler21.types.expressionStatement(import_compiler21.types.callExpression(intersection, [scopeIdentifier]))\n    );\n  });\n  if (isValue) {\n    let dynamicClosureArgs;\n    let dynamicClosureSignalIdentifier;\n    forEach(binding.closureSections, (closureSection) => {\n      if (binding.sources) {\n        if (isDynamicClosure(closureSection, binding)) {\n          if (!dynamicClosureArgs) {\n            dynamicClosureArgs = [];\n            dynamicClosureSignalIdentifier = generateUidIdentifier(\n              signal.identifier.name + \"_closure\"\n            );\n            signal.render.push(\n              import_compiler21.types.expressionStatement(\n                import_compiler21.types.callExpression(dynamicClosureSignalIdentifier, [\n                  scopeIdentifier\n                ])\n              )\n            );\n          }\n          dynamicClosureArgs.push(\n            getSignal(closureSection, binding).identifier\n          );\n        } else {\n          signal.render.push(\n            import_compiler21.types.expressionStatement(\n              import_compiler21.types.callExpression(getSignal(closureSection, binding).identifier, [\n                scopeIdentifier\n              ])\n            )\n          );\n        }\n      }\n    });\n    if (dynamicClosureSignalIdentifier) {\n      (signal.prependStatements ||= []).push(\n        import_compiler21.types.variableDeclaration(\"const\", [\n          import_compiler21.types.variableDeclarator(\n            dynamicClosureSignalIdentifier,\n            callRuntime(\"dynamicClosure\", ...dynamicClosureArgs)\n          )\n        ])\n      );\n    }\n  }\n  if (signal.effect.length) {\n    const effectIdentifier = import_compiler21.types.identifier(`${signal.identifier.name}_effect`);\n    signal.render.push(\n      import_compiler21.types.expressionStatement(\n        import_compiler21.types.callExpression(effectIdentifier, [scopeIdentifier])\n      )\n    );\n  }\n  if (isIntersection && signal.renderReferencedBindings) {\n    signal.render.unshift(\n      import_compiler21.types.variableDeclaration(\"const\", [\n        import_compiler21.types.variableDeclarator(\n          createScopeReadPattern(section, signal.renderReferencedBindings),\n          scopeIdentifier\n        )\n      ])\n    );\n  }\n  if (canUseCalleeDirectly && signal.render.length === 1) {\n    const render = signal.render[0];\n    if (render.type === \"ExpressionStatement\") {\n      const { expression } = render;\n      if (expression.type === \"CallExpression\") {\n        const args = expression.arguments;\n        if (params.length >= args.length) {\n          for (let i = args.length; i--; ) {\n            const param = params[i];\n            const arg = args[i];\n            if (arg.type !== \"Identifier\" || param.name !== arg.name) {\n              canUseCalleeDirectly = false;\n              break;\n            }\n          }\n          if (canUseCalleeDirectly) {\n            return expression.callee;\n          }\n        }\n      }\n    }\n  }\n  return import_compiler21.types.arrowFunctionExpression(params, import_compiler21.types.blockStatement(signal.render));\n}\nvar hasTranslatedExtraArgs = /* @__PURE__ */ new WeakSet();\nvar emptyExtraArgs = [];\nfunction getTranslatedExtraArgs(signal) {\n  if (signal.extraArgs) {\n    if (!hasTranslatedExtraArgs.has(signal)) {\n      hasTranslatedExtraArgs.add(signal);\n      traverseReplace(signal, \"extraArgs\", replaceRenderNode);\n    }\n    return signal.extraArgs;\n  }\n  return emptyExtraArgs;\n}\nfunction subscribe(provider, subscriber) {\n  if (Array.isArray(provider)) {\n    provider.forEach((p) => subscribe(p, subscriber));\n    return;\n  }\n  const providerSignal = getSignal(subscriber.section, provider);\n  providerSignal.intersection = push(\n    providerSignal.intersection,\n    subscriber.identifier\n  );\n}\nfunction generateSignalName(referencedBindings) {\n  let name2;\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      name2 = \"expr\";\n      for (const ref of referencedBindings) {\n        name2 += `_${ref.name}`;\n      }\n    } else {\n      name2 = referencedBindings.name;\n    }\n  } else {\n    name2 = \"setup\";\n  }\n  return name2;\n}\nfunction replaceNullishAndEmptyFunctionsWith0(args) {\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (!arg) {\n      args[i] = import_compiler21.types.numericLiteral(0);\n    } else if (import_compiler21.types.isArrowFunctionExpression(arg) && import_compiler21.types.isBlockStatement(arg.body)) {\n      const body = arg.body.body;\n      if (body.length === 0) {\n        args[i] = import_compiler21.types.numericLiteral(0);\n      } else if (body.length === 1 && import_compiler21.types.isExpressionStatement(body[0])) {\n        arg.body = toParenthesizedExpressionIfNeeded(body[0].expression);\n      }\n    } else if (import_compiler21.types.isNullLiteral(arg) || import_compiler21.types.isUnaryExpression(arg) && arg.operator === \"void\") {\n      args[i] = import_compiler21.types.numericLiteral(0);\n    }\n  }\n  for (let i = args.length - 1; import_compiler21.types.isNumericLiteral(args[i]) && args[i].value === 0; ) {\n    args.length = i--;\n  }\n  return args;\n}\nfunction addStatement(type, targetSection, referencedBindings, statement, usedReferences) {\n  const signal = getSignal(targetSection, referencedBindings);\n  const statements = signal[type] ??= [];\n  const add = type === \"effect\" ? addEffectReferences : addRenderReferences;\n  if (Array.isArray(statement)) {\n    statements.push(...statement);\n  } else {\n    statements.push(statement);\n  }\n  if (usedReferences !== false) {\n    if (usedReferences) {\n      for (const ref of usedReferences) {\n        add(signal, ref);\n      }\n    } else {\n      add(signal, referencedBindings);\n    }\n  }\n}\nfunction addEffectReferences(signal, referencedBindings) {\n  signal.effectReferencedBindings = bindingUtil.union(\n    signal.effectReferencedBindings,\n    referencedBindings\n  );\n}\nfunction addRenderReferences(signal, referencedBindings) {\n  signal.renderReferencedBindings = bindingUtil.union(\n    signal.renderReferencedBindings,\n    referencedBindings\n  );\n}\nfunction addValue(targetSection, referencedBindings, signal, value, scope = scopeIdentifier) {\n  const parentSignal = getSignal(targetSection, referencedBindings);\n  addRenderReferences(parentSignal, referencedBindings);\n  parentSignal.values.push({\n    signal,\n    value,\n    scope\n  });\n}\nfunction getResumeRegisterId(section, referencedBindings, type) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = (0, import_compiler21.getFile)();\n  let name2 = \"\";\n  if (referencedBindings) {\n    if (typeof referencedBindings === \"string\") {\n      name2 += `_${referencedBindings}`;\n    } else if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        name2 += `_${ref.name}`;\n      }\n    } else {\n      name2 += `_${referencedBindings.name}`;\n    }\n  }\n  return (0, import_babel_utils9.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}${name2}${type ? \"/\" + type : \"\"}`\n  );\n}\nvar usedRegisterIdsBySection = /* @__PURE__ */ new WeakMap();\nfunction getRegisterUID(section, name2) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = (0, import_compiler21.getFile)();\n  let used = usedRegisterIdsBySection.get(section);\n  if (!used) usedRegisterIdsBySection.set(section, used = /* @__PURE__ */ new Set());\n  const baseId = (0, import_babel_utils9.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}/${name2}`\n  );\n  let count = 0;\n  let id = baseId;\n  while (used.has(id)) {\n    id = baseId + \"_\" + ++count;\n  }\n  used.add(id);\n  return id;\n}\nfunction writeSignals(section) {\n  forEach(section.hoisted, (binding) => {\n    for (const hoistedBinding of binding.hoists.values()) {\n      const accessors = [\n        binding.type === 0 /* dom */ ? import_compiler21.types.stringLiteral(\n          getAccessorPrefix().Getter + getScopeAccessor(binding)\n        ) : getScopeAccessorLiteral(binding)\n      ];\n      let currentSection = section;\n      while (currentSection && currentSection !== hoistedBinding.section) {\n        const parentSection = currentSection.parent;\n        if (parentSection) {\n          accessors.push(getSectionInstancesAccessorLiteral(currentSection));\n        }\n        currentSection = parentSection;\n      }\n      const hoistIdentifier = getHoistFunctionIdentifier(hoistedBinding);\n      (0, import_compiler21.getProgram)().node.body.push(\n        import_compiler21.types.variableDeclaration(\"const\", [\n          import_compiler21.types.variableDeclarator(\n            hoistIdentifier,\n            hoistedBinding.downstreamExpressions.size ? callRuntime(\n              \"register\",\n              import_compiler21.types.stringLiteral(\n                getResumeRegisterId(\n                  hoistedBinding.section,\n                  hoistedBinding,\n                  \"hoist\"\n                )\n              ),\n              callRuntime(\"hoist\", ...accessors)\n            ) : callRuntime(\"hoist\", ...accessors)\n          )\n        ])\n      );\n      if (hoistedBinding.downstreamExpressions.size) {\n        addValue(\n          hoistedBinding.section,\n          void 0,\n          initValue(hoistedBinding),\n          import_compiler21.types.callExpression(hoistIdentifier, [scopeIdentifier])\n        );\n      }\n    }\n  });\n  const signals = [...getSignals(section).values()].sort(sortSignals);\n  for (const signal of signals) {\n    traverseReplace(signal, \"render\", replaceRenderNode);\n    for (const value2 of signal.values) {\n      traverseReplace(value2, \"value\", replaceRenderNode);\n    }\n    let effectDeclarator;\n    if (signal.effect.length) {\n      traverseReplace(signal, \"effect\", replaceEffectNode);\n      const effectIdentifier = import_compiler21.types.identifier(`${signal.identifier.name}_effect`);\n      const referencedBindings = signal.effectReferencedBindings;\n      const referencesScope = traverseContains(\n        signal.effect,\n        isScopeIdentifier\n      );\n      effectDeclarator = import_compiler21.types.variableDeclarator(\n        effectIdentifier,\n        callRuntime(\n          \"effect\",\n          import_compiler21.types.stringLiteral(\n            getResumeRegisterId(section, signal.referencedBindings)\n          ),\n          import_compiler21.types.arrowFunctionExpression(\n            referencedBindings ? referencesScope ? [\n              scopeIdentifier,\n              createScopeReadPattern(section, referencedBindings)\n            ] : [createScopeReadPattern(section, referencedBindings)] : referencesScope ? [scopeIdentifier] : [],\n            toFirstExpressionOrBlock(signal.effect)\n          )\n        )\n      );\n    }\n    let value = signal.build();\n    if (import_compiler21.types.isCallExpression(value)) {\n      replaceNullishAndEmptyFunctionsWith0(value.arguments);\n    }\n    if (signal.register) {\n      value = callRuntime(\n        \"registerBoundSignal\",\n        import_compiler21.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings, \"var\")\n        ),\n        value\n      );\n    }\n    const signalDeclarator = import_compiler21.types.variableDeclarator(signal.identifier, value);\n    let signalDeclaration = !section.parent && !signal.referencedBindings && (import_compiler21.types.isFunctionExpression(value) || import_compiler21.types.isArrowFunctionExpression(value)) ? import_compiler21.types.functionDeclaration(\n      signal.identifier,\n      value.params,\n      import_compiler21.types.isExpression(value.body) ? import_compiler21.types.blockStatement([import_compiler21.types.expressionStatement(value.body)]) : value.body\n    ) : import_compiler21.types.variableDeclaration(\"const\", [signalDeclarator]);\n    if (signal.export) {\n      signalDeclaration = import_compiler21.types.exportNamedDeclaration(signalDeclaration);\n    }\n    const signalStatements = signal.prependStatements || [];\n    if (effectDeclarator) {\n      signalStatements.push(import_compiler21.types.variableDeclaration(\"const\", [effectDeclarator]));\n    }\n    signalStatements.push(signalDeclaration);\n    (0, import_compiler21.getProgram)().node.body.push(...signalStatements);\n  }\n}\nfunction writeRegisteredFns() {\n  const registeredFns = registeredFnsForProgram.get((0, import_compiler21.getProgram)().node);\n  const statements = [];\n  if (registeredFns) {\n    for (const registeredFn of registeredFns) {\n      let fn;\n      const params = registeredFn.referencedBindings ? registeredFn.referencesScope ? [\n        scopeIdentifier,\n        import_compiler21.types.assignmentPattern(\n          createScopeReadPattern(\n            registeredFn.section,\n            registeredFn.referencedBindings\n          ),\n          scopeIdentifier\n        )\n      ] : [\n        createScopeReadPattern(\n          registeredFn.section,\n          registeredFn.referencedBindings\n        )\n      ] : registeredFn.referencesScope ? [scopeIdentifier] : void 0;\n      if (params) {\n        fn = import_compiler21.types.functionDeclaration(\n          import_compiler21.types.identifier(registeredFn.id),\n          params,\n          import_compiler21.types.blockStatement(toReturnedFunction(registeredFn.node))\n        );\n      } else if (registeredFn.node.type === \"FunctionDeclaration\" && registeredFn.node.id?.name === registeredFn.id) {\n        fn = registeredFn.node;\n      } else {\n        fn = import_compiler21.types.functionDeclaration(\n          import_compiler21.types.identifier(registeredFn.id),\n          registeredFn.node.params,\n          registeredFn.node.body.type === \"BlockStatement\" ? registeredFn.node.body : import_compiler21.types.blockStatement([import_compiler21.types.returnStatement(registeredFn.node.body)]),\n          registeredFn.node.generator,\n          registeredFn.node.async\n        );\n      }\n      statements.push(fn);\n    }\n    for (const registeredFn of registeredFns) {\n      statements.push(\n        import_compiler21.types.expressionStatement(\n          callRuntime(\n            \"register\",\n            import_compiler21.types.stringLiteral(registeredFn.registerId),\n            import_compiler21.types.identifier(registeredFn.id)\n          )\n        )\n      );\n    }\n    (0, import_compiler21.getProgram)().node.body.push(...statements);\n  }\n}\nfunction toReturnedFunction(rawFn) {\n  const fn = simplifyFunction(rawFn);\n  return fn.type === \"FunctionDeclaration\" ? [fn, import_compiler21.types.returnStatement(fn.id)] : [import_compiler21.types.returnStatement(fn)];\n}\nfunction sortSignals(a, b) {\n  const aReferencedBindings = getReferencedBindings(a);\n  const bReferencedBindings = getReferencedBindings(b);\n  for (let i = Math.max(aReferencedBindings.length, bReferencedBindings.length) - 1; i >= 0; i--) {\n    const diff = (bReferencedBindings[i] ?? -1) - (aReferencedBindings[i] ?? -1);\n    if (diff !== 0) return diff;\n  }\n  return 0;\n}\nfunction getReferencedBindings({ referencedBindings: reserve }) {\n  if (!reserve) {\n    return [];\n  } else if (Array.isArray(reserve)) {\n    return reserve.map(getMappedId).sort();\n  } else {\n    return [getMappedId(reserve)];\n  }\n}\nfunction getMappedId(reference) {\n  return (reference.type === 0 /* dom */ ? 1 : 0) * 1e4 + reference.id;\n}\nfunction addHTMLEffectCall(section, referencedBindings) {\n  addStatement(\"effect\", section, referencedBindings, void 0, false);\n}\nfunction writeHTMLResumeStatements(path5) {\n  const section = getSectionForBody(path5);\n  if (!section) return;\n  const body = path5.node.body;\n  const allSignals = Array.from(getSignals(section).values());\n  const scopeIdIdentifier = getScopeIdIdentifier(section);\n  const serializeOwnersUntilBinding = (binding) => serializeOwners(section, binding.section);\n  forEach(section.assignments, serializeOwnersUntilBinding);\n  forEach(section.referencedHoists, serializeOwnersUntilBinding);\n  forEach(section.referencedClosures, (closure) => {\n    if (closure.sources) {\n      const serializeReason = getDynamicSourcesForBinding(closure);\n      serializeOwnersUntilBinding(closure);\n      serializeSectionIfNeeded(closure.section, serializeReason);\n      if (isDynamicClosure(section, closure)) {\n        const closureSignal = getSignal(closure.section, closure);\n        let identifier = htmlDynamicClosureInstancesIdentifier.get(closureSignal);\n        if (!identifier) {\n          htmlDynamicClosureInstancesIdentifier.set(\n            closureSignal,\n            identifier = generateUidIdentifier(\n              closureSignal.identifier.name + \"_closures\"\n            )\n          );\n          getHTMLSectionStatements(closure.section).push(\n            import_compiler21.types.variableDeclaration(\"const\", [\n              import_compiler21.types.variableDeclarator(\n                identifier,\n                import_compiler21.types.newExpression(import_compiler21.types.identifier(\"Set\"), [])\n              )\n            ])\n          );\n          setSerializedProperty(\n            closure.section,\n            getAccessorPrefix().ClosureScopes + getScopeAccessor(closure),\n            identifier,\n            serializeReason\n          );\n        }\n        setSerializedProperty(\n          section,\n          getAccessorPrefix().ClosureSignalIndex + getScopeAccessor(closure),\n          import_compiler21.types.numericLiteral(getDynamicClosureIndex(closure, section)),\n          serializeReason\n        );\n        addWriteScopeBuilder(\n          section,\n          (expr) => callRuntime(\"writeSubscribe\", identifier, expr)\n        );\n      }\n    }\n  });\n  const sectionDynamicSubscribers = /* @__PURE__ */ new Set();\n  forEach(section.hoisted, (binding) => {\n    for (const hoistedBinding of binding.hoists.values()) {\n      if (hoistedBinding.downstreamExpressions.size) {\n        getHTMLSectionStatements(hoistedBinding.section).push(\n          import_compiler21.types.variableDeclaration(\"const\", [\n            import_compiler21.types.variableDeclarator(\n              import_compiler21.types.identifier(hoistedBinding.name),\n              callRuntime(\n                \"hoist\",\n                getScopeIdIdentifier(hoistedBinding.section),\n                import_compiler21.types.stringLiteral(\n                  getResumeRegisterId(\n                    hoistedBinding.section,\n                    hoistedBinding,\n                    \"hoist\"\n                  )\n                )\n              )\n            )\n          ])\n        );\n      }\n      let currentSection = section;\n      while (currentSection && currentSection !== hoistedBinding.section) {\n        const parentSection = currentSection.parent;\n        if (!currentSection.sectionAccessor && !sectionDynamicSubscribers.has(currentSection)) {\n          const subscribersIdentifier = generateUidIdentifier(\n            `${currentSection.name}_subscribers`\n          );\n          sectionDynamicSubscribers.add(currentSection);\n          getHTMLSectionStatements(parentSection).push(\n            import_compiler21.types.variableDeclaration(\"const\", [\n              import_compiler21.types.variableDeclarator(\n                subscribersIdentifier,\n                import_compiler21.types.newExpression(import_compiler21.types.identifier(\"Set\"), [])\n              )\n            ])\n          );\n          addWriteScopeBuilder(\n            currentSection,\n            (expr) => callRuntime(\"writeSubscribe\", subscribersIdentifier, expr)\n          );\n          setSerializedProperty(\n            parentSection,\n            getSectionInstancesAccessor(currentSection),\n            subscribersIdentifier,\n            true\n          );\n        }\n        currentSection = parentSection;\n      }\n    }\n    if (binding.hoists.size && binding.type !== 0 /* dom */) {\n      setSerializedProperty(\n        section,\n        getScopeAccessor(binding),\n        getDeclaredBindingExpression(binding),\n        true\n      );\n    }\n  });\n  for (let i = allSignals.length; i--; ) {\n    if (allSignals[i].effect.length) {\n      const signalRefs = allSignals[i].referencedBindings;\n      body.push(\n        import_compiler21.types.expressionStatement(\n          callRuntime(\n            \"writeEffect\",\n            scopeIdIdentifier,\n            import_compiler21.types.stringLiteral(getResumeRegisterId(section, signalRefs))\n          )\n        )\n      );\n    }\n  }\n  const serializedLookup = getSerializedScopeProperties(section);\n  const serializedProperties = [];\n  forEach(section.bindings, (binding) => {\n    if (binding.serialize && binding.type !== 0 /* dom */) {\n      const accessor = getScopeAccessor(binding);\n      serializedLookup.delete(accessor);\n      serializedProperties.push(\n        toObjectProperty(accessor, getDeclaredBindingExpression(binding))\n      );\n    }\n  });\n  for (const [key, { expression }] of serializedLookup) {\n    serializedProperties.push(toObjectProperty(key, expression));\n  }\n  const writeScopeBuilder = getSectionWriteScopeBuilder(section);\n  const forceSerializeReason = serializeSectionReason(section);\n  if (writeScopeBuilder || serializedProperties.length || forceSerializeReason) {\n    for (const prop of serializedProperties) {\n      if (prop.key.type === \"Identifier\" && prop.value.type === \"Identifier\" && prop.key.name === prop.value.name) {\n        prop.shorthand = true;\n      }\n    }\n    const writeScopeArgs = [\n      scopeIdIdentifier,\n      import_compiler21.types.objectExpression(serializedProperties)\n    ];\n    if (!isOptimize()) {\n      let debugVars;\n      forEach(section.bindings, (binding) => {\n        if (!binding.serialize || binding.type === 0 /* dom */) return;\n        let root = binding;\n        let access = \"\";\n        while (!(root.loc || root.declared) && root.upstreamAlias) {\n          if (root.property !== void 0) {\n            access = toAccess(root.property) + access;\n          }\n          root = root.upstreamAlias;\n        }\n        const locExpr = root.loc && import_compiler21.types.stringLiteral(\n          `${root.loc.start.line}:${root.loc.start.column + 1}`\n        );\n        (debugVars ||= []).push(\n          toObjectProperty(\n            getScopeAccessor(binding),\n            root !== binding ? import_compiler21.types.arrayExpression(\n              locExpr ? [import_compiler21.types.stringLiteral(root.name + access), locExpr] : [import_compiler21.types.stringLiteral(root.name + access)]\n            ) : locExpr || import_compiler21.types.numericLiteral(0)\n          )\n        );\n      });\n      writeScopeArgs.push(\n        import_compiler21.types.stringLiteral(path5.hub.file.opts.filenameRelative),\n        section.loc && section.loc.start.line != null ? import_compiler21.types.stringLiteral(\n          `${section.loc.start.line}:${section.loc.start.column + 1}`\n        ) : import_compiler21.types.numericLiteral(0)\n      );\n      if (debugVars) {\n        writeScopeArgs.push(import_compiler21.types.objectExpression(debugVars));\n      }\n    }\n    body.push(\n      import_compiler21.types.expressionStatement(\n        writeScopeBuilder ? writeScopeBuilder(callRuntime(\"writeScope\", ...writeScopeArgs)) : callRuntime(\"writeScope\", ...writeScopeArgs)\n      )\n    );\n  }\n  const resumeClosestBranch2 = !section.isBranch && (section.hasAbortSignal || !!section.referencedClosures || !!find(section.bindings, (binding) => binding.type === 1 /* let */));\n  if (resumeClosestBranch2) {\n    body.push(\n      import_compiler21.types.expressionStatement(\n        callRuntime(\"resumeClosestBranch\", scopeIdIdentifier)\n      )\n    );\n  }\n  const additionalStatements = getHTMLSectionStatements(section);\n  if (body.length || additionalStatements.length) {\n    body.unshift(\n      import_compiler21.types.variableDeclaration(\"const\", [\n        import_compiler21.types.variableDeclarator(scopeIdIdentifier, callRuntime(\"nextScopeId\"))\n      ]),\n      ...additionalStatements\n    );\n  }\n  const returnIdentifier = getSectionReturnValueIdentifier(section);\n  if (returnIdentifier !== void 0) {\n    body.push(import_compiler21.types.returnStatement(returnIdentifier));\n  }\n}\nfunction serializeOwners(from, to) {\n  let cur = from;\n  while (cur !== to) {\n    const parent = cur.parent;\n    if (!parent) break;\n    const serialized = getSerializedScopeProperties(cur);\n    cur = parent;\n    if (!serialized.has(\"_\")) {\n      serialized.set(\"_\", {\n        expression: callRuntime(\"ensureScopeWithId\", getScopeIdIdentifier(cur)),\n        reason: true\n      });\n    }\n  }\n}\nfunction getSetup(section) {\n  return getSignals(section).get(void 0)?.identifier;\n}\nfunction replaceRenderNode(node) {\n  return replaceAssignedNode(node) || replaceBindingReadNode(node) || replaceRegisteredFunctionNode(node);\n}\nfunction replaceEffectNode(node) {\n  return replaceAssignedNode(node) || replaceBindingReadNode(node);\n}\nfunction replaceBindingReadNode(node) {\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\": {\n      return getReadReplacement(node);\n    }\n  }\n}\nfunction replaceAssignedNode(node) {\n  switch (node.type) {\n    case \"UpdateExpression\": {\n      const { extra } = node.argument;\n      if (isAssignedBindingExtra(extra)) {\n        const { buildAssignment } = getSignal(\n          extra.assignment.section,\n          extra.assignment\n        );\n        if (buildAssignment) {\n          const replacement = buildAssignment(\n            extra.section,\n            import_compiler21.types.binaryExpression(\n              node.operator === \"++\" ? \"+\" : \"-\",\n              node.argument,\n              import_compiler21.types.numericLiteral(1)\n            )\n          );\n          if (!node.prefix) {\n            return import_compiler21.types.sequenceExpression([replacement, node.argument]);\n          }\n          return replacement;\n        }\n      }\n      break;\n    }\n    case \"AssignmentExpression\":\n      switch (node.left.type) {\n        case \"Identifier\": {\n          const { extra } = node.left;\n          if (isAssignedBindingExtra(extra)) {\n            const { buildAssignment } = getSignal(\n              extra.assignment.section,\n              extra.assignment\n            );\n            if (buildAssignment) {\n              return buildAssignment(\n                extra.section,\n                node.operator === \"=\" ? node.right : import_compiler21.types.binaryExpression(\n                  node.operator.slice(\n                    0,\n                    -1\n                  ),\n                  node.left,\n                  node.right\n                )\n              );\n            }\n          }\n          break;\n        }\n        case \"ArrayPattern\":\n        case \"ObjectPattern\": {\n          let params;\n          let assignments;\n          forEachIdentifier(node.left, (id) => {\n            const { extra } = id;\n            if (isAssignedBindingExtra(extra)) {\n              const signal = getSignal(\n                extra.assignment.section,\n                extra.assignment\n              );\n              if (signal?.buildAssignment) {\n                id.name = generateUid(id.name);\n                (params ||= []).push(import_compiler21.types.identifier(id.name));\n                (assignments ||= []).push(\n                  signal.buildAssignment(extra.section, import_compiler21.types.identifier(id.name))\n                );\n              }\n            }\n          });\n          if (params && assignments) {\n            const resultId = generateUid(\"result\");\n            return import_compiler21.types.callExpression(\n              import_compiler21.types.arrowFunctionExpression(\n                [import_compiler21.types.identifier(resultId), ...params],\n                import_compiler21.types.sequenceExpression([\n                  import_compiler21.types.assignmentExpression(\n                    \"=\",\n                    node.left,\n                    import_compiler21.types.identifier(resultId)\n                  ),\n                  ...assignments,\n                  import_compiler21.types.identifier(resultId)\n                ])\n              ),\n              [node.right]\n            );\n          }\n          break;\n        }\n      }\n      break;\n  }\n}\nvar registeredFnsForProgram = /* @__PURE__ */ new WeakMap();\nfunction replaceRegisteredFunctionNode(node) {\n  switch (node.type) {\n    case \"ClassMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler21.types.classProperty(node.key, replacement);\n    }\n    case \"ClassPrivateMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler21.types.classPrivateProperty(node.key, replacement);\n    }\n    case \"ObjectMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler21.types.objectProperty(node.key, replacement);\n    }\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\": {\n      return getRegisteredFnExpression(node);\n    }\n    case \"FunctionDeclaration\": {\n      const replacement = getRegisteredFnExpression(node);\n      if (replacement) {\n        return import_compiler21.types.variableDeclaration(\"const\", [\n          import_compiler21.types.variableDeclarator(node.id, replacement)\n        ]);\n      }\n      break;\n    }\n  }\n}\nfunction getRegisteredFnExpression(node) {\n  const { extra } = node;\n  if (isRegisteredFnExtra(extra)) {\n    const id = generateUid(extra.name);\n    const referencesScope = extra.referencesScope;\n    const referencedBindings = extra.referencedBindingsInFunction;\n    let registedFns = registeredFnsForProgram.get((0, import_compiler21.getProgram)().node);\n    if (!registedFns) {\n      registeredFnsForProgram.set((0, import_compiler21.getProgram)().node, registedFns = []);\n    }\n    registedFns.push({\n      id,\n      node,\n      registerId: extra.registerId,\n      section: extra.section,\n      referencesScope,\n      referencedBindings\n    });\n    if (referencesScope || referencedBindings) {\n      return import_compiler21.types.callExpression(import_compiler21.types.identifier(id), [scopeIdentifier]);\n    } else {\n      return import_compiler21.types.identifier(id);\n    }\n  }\n}\nfunction getDynamicClosureIndex(closure, closureSection) {\n  let index = 0;\n  find(closure.closureSections, (section) => {\n    if (section === closureSection) return true;\n    if (isDynamicClosure(section, closure)) {\n      index++;\n    }\n    return false;\n  });\n  return index;\n}\n\n// src/translator/visitors/program/dom.ts\nvar dom_default = {\n  translate: {\n    exit(program) {\n      visit(program);\n      const section = getSectionForBody(program);\n      const { walks, writes, setup } = getSectionMeta(section);\n      const domExports = program.node.extra.domExports;\n      const templateIdentifier = import_compiler22.types.identifier(domExports.template);\n      const walksIdentifier = import_compiler22.types.identifier(domExports.walks);\n      const setupIdentifier = import_compiler22.types.identifier(domExports.setup);\n      const inputBinding = program.node.params[0].extra?.binding;\n      const programInputSignal = inputBinding && bindingHasDownstreamExpressions(inputBinding) ? initValue(inputBinding) : void 0;\n      const styleFile = getStyleFile(program.hub.file);\n      if (styleFile) {\n        (0, import_babel_utils10.importDefault)(program.hub.file, styleFile);\n      }\n      forEachSectionReverse((childSection) => {\n        if (childSection !== section) {\n          const tagParamsSignal = childSection.params && initValue(childSection.params);\n          const { walks: walks2, writes: writes2, setup: setup2 } = getSectionMeta(childSection);\n          const identifier = import_compiler22.types.identifier(childSection.name);\n          const referencedClosures = childSection.referencedClosures ? import_compiler22.types.arrowFunctionExpression(\n            [scopeIdentifier],\n            toFirstExpressionOrBlock(\n              map(childSection.referencedClosures, (closure) => {\n                const closureSignal = getSignal(childSection, closure);\n                return import_compiler22.types.expressionStatement(\n                  import_compiler22.types.callExpression(\n                    isDynamicClosure(childSection, closure) ? closureSignal.identifier : import_compiler22.types.memberExpression(\n                      closureSignal.identifier,\n                      import_compiler22.types.identifier(\"_\")\n                    ),\n                    [scopeIdentifier]\n                  )\n                );\n              })\n            )\n          ) : void 0;\n          const renderer = getSectionParentIsOwner(childSection) ? callRuntime(\n            \"createRenderer\",\n            ...replaceNullishAndEmptyFunctionsWith0([\n              writes2,\n              walks2,\n              setup2,\n              tagParamsSignal?.identifier,\n              referencedClosures\n            ])\n          ) : callRuntime(\n            isSerializedSection(childSection) ? \"registerContent\" : \"createContent\",\n            import_compiler22.types.stringLiteral(getResumeRegisterId(childSection, \"renderer\")),\n            ...replaceNullishAndEmptyFunctionsWith0([\n              writes2,\n              walks2,\n              setup2,\n              tagParamsSignal?.identifier,\n              referencedClosures,\n              childSection.hoisted || childSection.isHoistThrough ? getSectionInstancesAccessorLiteral(childSection) : void 0\n            ])\n          );\n          writeSignals(childSection);\n          program.node.body.push(\n            import_compiler22.types.variableDeclaration(\"const\", [\n              import_compiler22.types.variableDeclarator(identifier, renderer)\n            ])\n          );\n        }\n      });\n      writeSignals(section);\n      writeRegisteredFns();\n      if (!setup) {\n        program.node.body.unshift(\n          import_compiler22.types.exportNamedDeclaration(\n            import_compiler22.types.variableDeclaration(\"const\", [\n              import_compiler22.types.variableDeclarator(\n                setupIdentifier,\n                import_compiler22.types.arrowFunctionExpression([], import_compiler22.types.blockStatement([]))\n              )\n            ])\n          )\n        );\n      }\n      program.node.body.unshift(\n        import_compiler22.types.exportNamedDeclaration(\n          import_compiler22.types.variableDeclaration(\"const\", [\n            import_compiler22.types.variableDeclarator(\n              templateIdentifier,\n              writes || import_compiler22.types.stringLiteral(\"\")\n            )\n          ])\n        ),\n        import_compiler22.types.exportNamedDeclaration(\n          import_compiler22.types.variableDeclaration(\"const\", [\n            import_compiler22.types.variableDeclarator(walksIdentifier, walks || import_compiler22.types.stringLiteral(\"\"))\n          ])\n        )\n      );\n      program.node.body.push(\n        import_compiler22.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            import_compiler22.types.stringLiteral(program.hub.file.metadata.marko.id),\n            templateIdentifier,\n            walksIdentifier,\n            setupIdentifier,\n            programInputSignal?.identifier\n          )\n        )\n      );\n    }\n  }\n};\n\n// src/translator/visitors/program/html.ts\nvar import_compiler23 = require(\"@marko/compiler\");\n\n// src/translator/util/is-static.ts\nfunction isStatic(path5) {\n  return path5.isImportDeclaration() || path5.isExportDeclaration() || path5.isMarkoScriptlet({ static: true });\n}\n\n// src/translator/visitors/program/html.ts\nvar templateContentIdentifierForProgram = /* @__PURE__ */ new WeakMap();\nfunction getTemplateContentName() {\n  let name2 = templateContentIdentifierForProgram.get((0, import_compiler23.getProgram)());\n  if (!name2) {\n    templateContentIdentifierForProgram.set(\n      (0, import_compiler23.getProgram)(),\n      name2 = generateUid(\"content\")\n    );\n  }\n  return name2;\n}\nvar html_default = {\n  translate: {\n    exit(program) {\n      flushInto(program);\n      writeHTMLResumeStatements(program);\n      traverseReplace(program.node, \"body\", replaceNode);\n      const renderContent = [];\n      for (const child of program.get(\"body\")) {\n        if (!isStatic(child)) {\n          renderContent.push(child.node);\n          child.remove();\n        } else if (child.isMarkoScriptlet()) {\n          if (child.node.target && child.node.target !== \"server\") {\n            child.remove();\n          } else {\n            child.replaceWithMultiple(child.node.body);\n          }\n        }\n      }\n      const contentId = templateContentIdentifierForProgram.get(program);\n      const contentFn = import_compiler23.types.arrowFunctionExpression(\n        [import_compiler23.types.identifier(\"input\")],\n        import_compiler23.types.blockStatement(renderContent)\n      );\n      const exportDefault = import_compiler23.types.exportDefaultDeclaration(\n        callRuntime(\n          \"createTemplate\",\n          import_compiler23.types.stringLiteral(program.hub.file.metadata.marko.id),\n          contentId ? import_compiler23.types.identifier(contentId) : contentFn\n        )\n      );\n      if (contentId) {\n        program.node.body.push(\n          import_compiler23.types.variableDeclaration(\"const\", [\n            import_compiler23.types.variableDeclarator(import_compiler23.types.identifier(contentId), contentFn)\n          ]),\n          exportDefault\n        );\n      } else {\n        program.node.body.push(exportDefault);\n      }\n    }\n  }\n};\nfunction replaceNode(node, container) {\n  return replaceBindingReadNode2(node) || replaceRegisteredFunctionNode2(node, container);\n}\nfunction replaceBindingReadNode2(node) {\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\": {\n      const { extra } = node;\n      if (extra && !(extra.read && !extra.read.binding.declared || extra.binding && !extra.binding.declared)) {\n        return getReadReplacement(node);\n      }\n    }\n  }\n}\nfunction replaceRegisteredFunctionNode2(node, container) {\n  switch (node.type) {\n    case \"ClassMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler23.types.classProperty(node.key, replacement);\n    }\n    case \"ClassPrivateMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler23.types.classPrivateProperty(node.key, replacement);\n    }\n    case \"ObjectMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler23.types.objectProperty(node.key, replacement);\n    }\n    case \"FunctionDeclaration\": {\n      const { extra } = node;\n      if (isRegisteredFnExtra(extra)) {\n        let registeredFnDeclarations = registeredFnDeclarationsByBody.get(\n          container\n        );\n        if (!registeredFnDeclarations) {\n          registeredFnDeclarationsByBody.set(\n            container,\n            registeredFnDeclarations = []\n          );\n        }\n        registeredFnDeclarations.push({\n          id: node.id.name,\n          registerId: extra.registerId\n        });\n      }\n      break;\n    }\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\": {\n      return getRegisteredFnExpression2(node);\n    }\n    case \"BlockStatement\":\n    case \"MarkoScriptlet\":\n      addRegisteredDeclarations(node.body);\n      break;\n  }\n}\nvar registeredFnDeclarationsByBody = /* @__PURE__ */ new WeakMap();\nfunction addRegisteredDeclarations(body) {\n  const registeredFnDeclarations = registeredFnDeclarationsByBody.get(body);\n  if (registeredFnDeclarations) {\n    for (const { id, registerId } of registeredFnDeclarations) {\n      body.push(\n        import_compiler23.types.expressionStatement(\n          callRuntime(\n            \"register\",\n            import_compiler23.types.identifier(id),\n            import_compiler23.types.stringLiteral(registerId)\n          )\n        )\n      );\n    }\n  }\n}\nfunction getRegisteredFnExpression2(node) {\n  const { extra } = node;\n  if (isRegisteredFnExtra(extra)) {\n    return callRuntime(\n      \"register\",\n      simplifyFunction(node),\n      import_compiler23.types.stringLiteral(extra.registerId),\n      (extra.referencedBindingsInFunction || extra.referencesScope) && getScopeIdIdentifier(extra.section)\n    );\n  }\n}\n\n// src/translator/visitors/program/index.ts\nvar cleanIdentifier;\nvar scopeIdentifier;\nfunction isScopeIdentifier(node) {\n  return node === scopeIdentifier;\n}\nvar program_default = {\n  migrate: {\n    enter(program) {\n      program.node.params = [import_compiler24.types.identifier(\"input\")];\n    },\n    exit(program) {\n      program.scope.crawl();\n    }\n  },\n  analyze: {\n    enter(program) {\n      startSection(program);\n      trackParamsReferences(program, 2 /* input */);\n      const inputBinding = program.node.params[0].extra?.binding;\n      if (inputBinding) {\n        inputBinding.nullable = false;\n      }\n      (program.node.extra ??= {}).domExports = {\n        template: generateUid(\"template\"),\n        walks: generateUid(\"walks\"),\n        setup: generateUid(\"setup\"),\n        input: void 0,\n        // TODO look into recursive components with fine grained params.\n        closures: generateUid(\"closures\")\n      };\n    },\n    exit(program) {\n      finalizeReferences();\n      const programExtra = program.node.extra;\n      const inputBinding = program.node.params[0].extra?.binding;\n      if (inputBinding && bindingHasDownstreamExpressions(inputBinding)) {\n        programExtra.domExports.input = buildTemplateExports(\n          inputBinding,\n          program\n        );\n      }\n    }\n  },\n  translate: {\n    enter(program) {\n      scopeIdentifier = isOutputDOM() ? generateUidIdentifier(\"scope\") : null;\n      cleanIdentifier = isOutputDOM() ? generateUidIdentifier(\"clean\") : null;\n      if (getMarkoOpts().output === \"hydrate\") {\n        const entryFile = program.hub.file;\n        const visitedFiles = /* @__PURE__ */ new Set([\n          (0, import_babel_utils11.resolveRelativePath)(entryFile, entryFile.opts.filename)\n        ]);\n        entry_builder_default.visit(entryFile, entryFile, function visitChild(resolved) {\n          if (!visitedFiles.has(resolved)) {\n            visitedFiles.add(resolved);\n            const file = (0, import_babel_utils11.loadFileForImport)(entryFile, resolved);\n            if (file) {\n              entry_builder_default.visit(\n                file,\n                entryFile,\n                (id) => visitChild(resolveRelativeToEntry(entryFile, file, id))\n              );\n            }\n          }\n        });\n        program.node.body = entry_builder_default.build(entryFile);\n        program.skip();\n        return;\n      }\n    },\n    exit(program) {\n      if (isOutputHTML()) {\n        html_default.translate.exit(program);\n      } else {\n        dom_default.translate.exit(program);\n      }\n      if (program.node.extra?.needsCompat) {\n        const compatFile = getCompatRuntimeFile();\n        const body = [void 0];\n        for (const child of program.node.body) {\n          if (child.type === \"ImportDeclaration\" && child.source.value === compatFile) {\n            body[0] = child;\n          } else {\n            body.push(child);\n          }\n        }\n        body[0] ??= import_compiler24.types.importDeclaration([], import_compiler24.types.stringLiteral(compatFile));\n        program.node.body = body;\n      }\n    }\n  }\n};\nfunction resolveRelativeToEntry(entryFile, file, req) {\n  return file === entryFile ? (0, import_babel_utils11.resolveRelativePath)(file, req) : (0, import_babel_utils11.resolveRelativePath)(\n    entryFile,\n    req[0] === \".\" ? import_path2.default.join(file.opts.filename, \"..\", req) : req\n  );\n}\nfunction buildTemplateExports(binding, program) {\n  const templateExport = {\n    id: binding.export ??= generateUid(binding.name),\n    binding,\n    props: void 0\n  };\n  if (!(binding.aliases.size || binding.downstreamExpressions.size)) {\n    templateExport.props = {};\n    for (const [property, alias] of binding.propertyAliases) {\n      templateExport.props[property] = buildTemplateExports(alias, program);\n    }\n  }\n  return templateExport;\n}\n\n// src/translator/util/scope-read.ts\nfunction createScopeReadPattern(section, referencedBindings) {\n  const rootDepth = section.depth;\n  const rootPattern = import_compiler25.types.objectPattern([]);\n  let nestedPatterns;\n  forEach(referencedBindings, (ref) => {\n    const propertyValue = ref.name;\n    if (!isValidPropertyIdentifier(propertyValue)) return;\n    const propertyKey = getScopeAccessor(ref);\n    const isShorthand = propertyKey === propertyValue;\n    let pattern = rootPattern;\n    if (ref.section !== section) {\n      if (!nestedPatterns) nestedPatterns = [rootPattern];\n      const relativeDepth = rootDepth - ref.section.depth;\n      let i = nestedPatterns.length;\n      let prev = nestedPatterns[i - 1];\n      for (; i <= relativeDepth; i++) {\n        const nestedPattern = import_compiler25.types.objectPattern([]);\n        prev.properties.push(\n          import_compiler25.types.objectProperty(import_compiler25.types.identifier(\"_\"), nestedPattern)\n        );\n        nestedPatterns.push(nestedPattern);\n        prev = nestedPattern;\n      }\n      pattern = nestedPatterns[relativeDepth];\n    }\n    pattern.properties.push(\n      import_compiler25.types.objectProperty(\n        toPropertyName(propertyKey),\n        import_compiler25.types.identifier(propertyValue),\n        false,\n        isShorthand\n      )\n    );\n  });\n  return rootPattern;\n}\nfunction getScopeExpression(section, targetSection) {\n  let scope = scopeIdentifier ?? import_compiler25.types.identifier(\"undefined\");\n  const diff = section.depth - targetSection.depth;\n  for (let i = 0; i < diff; i++) {\n    scope = import_compiler25.types.memberExpression(scope, import_compiler25.types.identifier(\"_\"));\n  }\n  if (diff < 0) {\n    throw new Error(\"Unable to find scope for reference.\");\n  }\n  return scope;\n}\nfunction createScopeReadExpression(section, reference) {\n  const propName = toPropertyName(getScopeAccessor(reference));\n  return import_compiler25.types.memberExpression(\n    getScopeExpression(section, reference.section),\n    propName,\n    propName.type !== \"Identifier\"\n  );\n}\n\n// src/translator/util/with-previous-location.ts\nfunction withPreviousLocation(newNode, originalNode) {\n  newNode.start = originalNode.start;\n  newNode.loc = originalNode.loc;\n  newNode.end = originalNode.end;\n  return newNode;\n}\n\n// src/translator/util/references.ts\nvar kIsInvoked = Symbol(\"hoist is invoked\");\nvar [getBindings] = createProgramState(() => /* @__PURE__ */ new Set());\nvar [getNextBindingId, setNextBindingId] = createProgramState(() => 0);\nfunction createBinding(name2, type, section, upstreamAlias, upstreamExpression, property, loc = null, declared = false) {\n  const id = getNextBindingId();\n  const binding = {\n    id,\n    name: name2,\n    type,\n    loc,\n    section,\n    property,\n    declared,\n    closureSections: void 0,\n    excludeProperties: void 0,\n    serialize: false,\n    sources: void 0,\n    aliases: /* @__PURE__ */ new Set(),\n    hoists: /* @__PURE__ */ new Map(),\n    propertyAliases: /* @__PURE__ */ new Map(),\n    upstreamAlias,\n    upstreamExpression,\n    downstreamExpressions: /* @__PURE__ */ new Set(),\n    scopeOffset: void 0,\n    export: void 0,\n    nullable: !upstreamExpression?.confident || upstreamExpression.computed == null\n  };\n  if (property) {\n    if (declared) upstreamAlias.nullable = false;\n    const propBinding = upstreamAlias.propertyAliases.get(property);\n    if (propBinding) {\n      binding.property = void 0;\n      binding.upstreamAlias = propBinding;\n      propBinding.aliases.add(binding);\n    } else {\n      upstreamAlias.propertyAliases.set(property, binding);\n    }\n  } else if (upstreamAlias) {\n    upstreamAlias.aliases.add(binding);\n  }\n  setNextBindingId(id + 1);\n  getBindings().add(binding);\n  return binding;\n}\nfunction trackVarReferences(tag, type, upstreamAlias, upstreamExpression) {\n  const tagVar = tag.node.var;\n  if (tagVar) {\n    const section = getOrCreateSection(tag);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    if (upstreamAlias && upstreamExpression) upstreamExpression.pruned = true;\n    createBindingsAndTrackReferences(\n      tagVar,\n      type,\n      tag.scope,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0\n    );\n  }\n}\nfunction trackParamsReferences(body, type, upstreamAlias, upstreamExpression) {\n  const params = body.node.params;\n  if (body.node.body.length && params.length) {\n    if (upstreamAlias && upstreamExpression) upstreamExpression.pruned = true;\n    const section = getOrCreateSection(body);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    const paramsBinding = canonicalUpstreamAlias || ((body.node.extra ??= {}).binding = createBinding(\n      generateUid(\"params\"),\n      type,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0\n    ));\n    section.params = paramsBinding;\n    for (let i = 0; i < params.length; i++) {\n      createBindingsAndTrackReferences(\n        params[i],\n        type,\n        body.scope,\n        section,\n        paramsBinding,\n        upstreamExpression,\n        i + \"\"\n      );\n    }\n  }\n}\nfunction trackHoistedReference(referencePath, binding) {\n  const section = binding.section;\n  const referenceSection = getOrCreateSection(referencePath);\n  const hoistSection = getCommonSection(referenceSection, section);\n  const extra = referencePath.node.extra ??= {};\n  let hoistedBinding = binding.hoists.get(hoistSection);\n  if (!hoistedBinding) {\n    binding.hoists.set(\n      hoistSection,\n      hoistedBinding = createBinding(\n        generateUid(\"hoisted_\" + referencePath.node.name),\n        5 /* hoist */,\n        hoistSection,\n        void 0,\n        void 0,\n        void 0,\n        binding.loc,\n        true\n      )\n    );\n    section.hoisted = bindingUtil.add(section.hoisted, binding);\n    let currentSection = section.parent;\n    while (currentSection && currentSection !== hoistSection) {\n      currentSection.isHoistThrough = true;\n      currentSection = currentSection.parent;\n    }\n  }\n  extra.hoistedBinding = hoistedBinding;\n  if (isInvokedFunction(referencePath)) {\n    extra.read = createRead(hoistedBinding, void 0);\n    extra.section = referenceSection;\n    extra[kIsInvoked] = true;\n  } else {\n    trackReference(referencePath, hoistedBinding);\n  }\n  referenceSection.referencedHoists = bindingUtil.add(\n    referenceSection.referencedHoists,\n    hoistedBinding\n  );\n}\nfunction trackReferencesForBinding(babelBinding) {\n  const { identifier, referencePaths, constantViolations } = babelBinding;\n  const binding = identifier.extra.binding;\n  for (const referencePath of referencePaths) {\n    const referenceSection = getOrCreateSection(referencePath);\n    if (isSameOrChildSection(binding.section, referenceSection)) {\n      trackReference(referencePath, binding);\n    } else {\n      trackHoistedReference(referencePath, binding);\n    }\n  }\n  for (const ref of constantViolations) {\n    if (ref.isUpdateExpression()) {\n      trackAssignment(ref.get(\"argument\"), binding);\n    } else if (ref.isAssignmentExpression()) {\n      trackAssignment(ref.get(\"left\"), binding);\n      if (ref.node.operator !== \"=\") {\n        const left = ref.get(\"left\");\n        if (left.isIdentifier()) {\n          trackReference(left, binding);\n        }\n      }\n    }\n  }\n}\nfunction trackAssignment(assignment, binding) {\n  const section = getOrCreateSection(assignment);\n  setReferencesScope(assignment);\n  forEachIdentifier(assignment.node, (id) => {\n    if (id.name === binding.name) {\n      const extra = id.extra ??= {};\n      section.assignments = bindingUtil.add(section.assignments, binding);\n      extra.assignment = binding;\n      extra.section = section;\n    }\n  });\n}\nfunction setReferencesScope(path5) {\n  const fnRoot = getFnRoot(path5);\n  if (fnRoot) {\n    (fnRoot.node.extra ??= {}).referencesScope = true;\n  }\n}\nfunction createBindingsAndTrackReferences(lVal, type, scope, section, upstreamAlias, upstreamExpression, property) {\n  switch (lVal.type) {\n    case \"Identifier\":\n      (lVal.extra ??= {}).binding = createBinding(\n        lVal.name,\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property,\n        lVal.loc,\n        true\n      );\n      trackReferencesForBinding(scope.getBinding(lVal.name));\n      break;\n    case \"ObjectPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        generateUid(property || \"pattern\"),\n        type,\n        section,\n        upstreamAlias,\n        void 0,\n        property,\n        lVal.loc\n      ));\n      for (const prop of lVal.properties) {\n        if (prop.type === \"RestElement\") {\n          createBindingsAndTrackReferences(\n            prop.argument,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            property\n          );\n        } else {\n          let key;\n          if (prop.key.type === \"Identifier\") {\n            key = prop.key.name;\n          } else if (prop.key.type === \"StringLiteral\") {\n            key = prop.key.value;\n          } else {\n            throw new Error(\"computed keys not supported in object pattern\");\n          }\n          createBindingsAndTrackReferences(\n            prop.value,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            key\n          );\n        }\n      }\n      break;\n    }\n    case \"ArrayPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        generateUid(property || \"pattern\"),\n        type,\n        section,\n        upstreamAlias,\n        void 0,\n        property,\n        lVal.loc\n      ));\n      let i = -1;\n      for (const element of lVal.elements) {\n        i++;\n        if (element) {\n          if (element.type === \"RestElement\") {\n            createBindingsAndTrackReferences(\n              element.argument,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              property\n            );\n          } else {\n            createBindingsAndTrackReferences(\n              element,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              `${i}`\n            );\n          }\n        }\n      }\n      break;\n    }\n    case \"AssignmentPattern\":\n      createBindingsAndTrackReferences(\n        lVal.left,\n        type,\n        scope,\n        section,\n        upstreamAlias,\n        void 0,\n        property\n      );\n      break;\n  }\n}\nfunction trackReference(referencePath, binding) {\n  let root = referencePath;\n  let reference = binding;\n  let propPath = binding.name;\n  while (true) {\n    const { parent } = root;\n    if (!import_compiler26.types.isMemberExpression(parent)) break;\n    const prop = getMemberExpressionPropString(parent);\n    if (prop === void 0) break;\n    if (reference.propertyAliases.has(prop)) {\n      root = root.parentPath;\n      reference = reference.propertyAliases.get(prop);\n      propPath = reference.name;\n      continue;\n    }\n    if (isInvokedFunction(root.parentPath) && !isEventOrChangeHandler(prop)) {\n      break;\n    }\n    root = root.parentPath;\n    reference = createBinding(\n      propPath += `_${prop.replace(/[^a-zA-Z0-9_$]/g, \"_\")}`,\n      reference.type,\n      reference.section,\n      reference,\n      void 0,\n      prop\n    );\n  }\n  const fnRoot = getFnRoot(root);\n  const exprRoot = getExprRoot(fnRoot || root);\n  const { section } = addReadToExpression(exprRoot, reference, root.node);\n  if (fnRoot) {\n    const readsByFn = getReadsByFunction();\n    const fnExtra = fnRoot.node.extra ??= {};\n    fnExtra.section = section;\n    readsByFn.set(\n      fnExtra,\n      push(readsByFn.get(fnExtra), {\n        binding: reference,\n        node: root.node\n      })\n    );\n  }\n}\nvar [getMergedReferences] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction mergeReferences(section, target, nodes) {\n  (target.extra ??= {}).section = section;\n  getMergedReferences().set(target, nodes);\n}\nfunction compareIntersections(a, b) {\n  const len = a.length;\n  const lenDelta = len - b.length;\n  if (lenDelta !== 0) {\n    return lenDelta;\n  }\n  for (let i = 0; i < len; i++) {\n    const compareResult = bindingUtil.compare(a[i], b[i]);\n    if (compareResult !== 0) {\n      return compareResult;\n    }\n  }\n  return 0;\n}\nfunction finalizeReferences() {\n  const bindings = getBindings();\n  const readsByExpression = getReadsByExpression();\n  const readsByFn = getReadsByFunction();\n  const mergedReferences = getMergedReferences();\n  if (mergedReferences.size) {\n    for (const [target, nodes] of mergedReferences) {\n      const targetExtra = target.extra;\n      let reads = readsByExpression.get(targetExtra);\n      let { isEffect } = targetExtra;\n      for (const node of nodes) {\n        const extra = node?.extra;\n        if (isReferencedExtra(extra)) {\n          isEffect ||= extra.isEffect;\n          const additionalReads = readsByExpression.get(extra);\n          if (additionalReads) {\n            reads = concat(reads, additionalReads);\n            readsByExpression.delete(extra);\n          }\n        }\n      }\n      readsByExpression.set(targetExtra, reads);\n      targetExtra.isEffect = isEffect;\n    }\n  }\n  const intersectionsBySection = /* @__PURE__ */ new Map();\n  for (const [expr, reads] of readsByExpression) {\n    if (isReferencedExtra(expr)) {\n      expr.referencedBindings = resolveReferencedBindings(\n        expr,\n        reads,\n        intersectionsBySection\n      );\n      forEach(expr.referencedBindings, (binding) => {\n        binding.downstreamExpressions.add(expr);\n      });\n    }\n  }\n  for (const [fn, reads] of readsByFn) {\n    fn.referencedBindingsInFunction = resolveReferencedBindings(\n      fn,\n      reads,\n      intersectionsBySection\n    );\n    forEach(fn.referencedBindingsInFunction, (binding) => {\n      binding.serialize = true;\n    });\n  }\n  for (const binding of bindings) {\n    if (binding.type !== 0 /* dom */ && !binding.upstreamAlias) {\n      pruneBinding(bindings, binding);\n    }\n  }\n  for (const binding of bindings) {\n    const { name: name2, section } = binding;\n    if (binding.type !== 0 /* dom */) {\n      resolveBindingSources(binding);\n      if (find(section.bindings, ({ name: name3 }) => name3 === binding.name)) {\n        binding.name = generateUid(name2);\n      }\n    }\n    section.bindings = bindingUtil.add(section.bindings, binding);\n    for (const {\n      referencedBindings,\n      isEffect,\n      section: section2\n    } of binding.downstreamExpressions) {\n      if (section2 !== binding.section) {\n        binding.closureSections = sectionUtil.add(\n          binding.closureSections,\n          section2\n        );\n        section2.referencedClosures = bindingUtil.add(\n          section2.referencedClosures,\n          binding\n        );\n      }\n      if (isEffect) {\n        forEach(referencedBindings, (bindingReference) => {\n          bindingReference.serialize = true;\n        });\n      }\n    }\n  }\n  forEachSection((section) => {\n    const intersections = intersectionsBySection.get(section);\n    if (intersections) {\n      for (const intersection of intersections) {\n        const numReferences = intersection.length;\n        for (let i = 0; i < numReferences - 1; i++) {\n          for (let j = i + 1; j < numReferences; j++) {\n            const binding1 = intersection[i];\n            const binding2 = intersection[j];\n            if (!binding1.serialize && !bindingUtil.isSuperset(binding1.sources, binding2.sources)) {\n              binding1.serialize = true;\n            }\n            if (!binding2.serialize && !bindingUtil.isSuperset(binding2.sources, binding1.sources)) {\n              binding2.serialize = true;\n            }\n          }\n        }\n      }\n    }\n    forEach(section.referencedClosures, (binding) => {\n      if (!binding.serialize) {\n        let serialize = false;\n        const sourceSection = binding.section;\n        let currentSection = section;\n        while (currentSection !== sourceSection && !(serialize = !currentSection.upstreamExpression || !!getDynamicSourcesForExtra(currentSection.upstreamExpression))) {\n          currentSection = currentSection.parent;\n        }\n        binding.serialize = serialize;\n      }\n    });\n  });\n  forEachSection((section) => {\n    let intersectionIndex = 0;\n    const intersections = intersectionsBySection.get(section) || [];\n    const { id, bindings: bindings2 } = section;\n    const isOwnedBinding = ({ section: section2 }) => section2.id === id;\n    let lastBindingIndex = 0;\n    let intersection;\n    forEach(filter(bindings2, isOwnedBinding), (binding, bindingIndex) => {\n      binding.id = (lastBindingIndex = bindingIndex) + intersectionIndex;\n      while (intersectionIndex < intersections.length && (intersection = intersections[intersectionIndex]).filter(isOwnedBinding).at(-1) === binding) {\n        intersectionMeta.set(intersection, {\n          id: bindingIndex + ++intersectionIndex,\n          scopeOffset: getMaxOwnSourceOffset(intersection, section)\n        });\n      }\n    });\n    while (intersectionIndex < intersections.length) {\n      intersection = intersections[intersectionIndex];\n      intersectionMeta.set(intersection, {\n        id: lastBindingIndex + ++intersectionIndex,\n        scopeOffset: getMaxOwnSourceOffset(intersection, section)\n      });\n    }\n  });\n  mergedReferences.clear();\n  readsByExpression.clear();\n  readsByFn.clear();\n}\nfunction getMaxOwnSourceOffset(intersection, section) {\n  let scopeOffset;\n  for (const binding of intersection) {\n    if (binding.section === section) {\n      forEach(binding.sources, (source) => {\n        if (source.scopeOffset && (!scopeOffset || scopeOffset.id < source.scopeOffset.id)) {\n          scopeOffset = source.scopeOffset;\n        }\n      });\n    }\n  }\n  return scopeOffset;\n}\nvar intersectionMeta = /* @__PURE__ */ new WeakMap();\nfunction resolveBindingSources(binding) {\n  const derived = /* @__PURE__ */ new Set();\n  let sources;\n  crawl(binding);\n  binding.sources = sources;\n  function crawl(binding2) {\n    if (binding2.type === 4 /* derived */ || binding2.type === 3 /* param */) {\n      let alias;\n      let curBinding = binding2;\n      while (alias = curBinding.upstreamAlias) {\n        curBinding = alias;\n      }\n      if (curBinding.upstreamExpression) {\n        if (derived.has(curBinding)) return;\n        derived.add(curBinding);\n        forEach(curBinding.upstreamExpression.referencedBindings, crawl);\n      } else if (curBinding.type === 2 /* input */) {\n        sources = bindingUtil.add(sources, binding2);\n      } else {\n        sources = bindingUtil.add(sources, curBinding);\n      }\n    } else {\n      sources = bindingUtil.add(sources, binding2);\n    }\n  }\n}\nvar bindingUtil = new Sorted(function compareBindings(a, b) {\n  return a.section.id - b.section.id || a.type !== b.type && (a.type === 0 /* dom */ || b.type === 0 /* dom */) ? a.type - b.type || a.id - b.id : a.id - b.id;\n});\nvar [getReadsByExpression] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nvar [getReadsByFunction] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction addReadToExpression(path5, binding, node) {\n  const exprExtra = path5.node.extra ??= {};\n  const readsByExpression = getReadsByExpression();\n  exprExtra.section = getOrCreateSection(path5);\n  readsByExpression.set(\n    exprExtra,\n    push(readsByExpression.get(exprExtra), { binding, node })\n  );\n  return exprExtra;\n}\nfunction dropReferences(node) {\n  if (Array.isArray(node)) {\n    for (const item of node) {\n      (item.extra ??= {}).pruned = true;\n    }\n  } else {\n    (node.extra ??= {}).pruned = true;\n  }\n}\nfunction getCanonicalBinding(binding) {\n  return binding && (binding.property ? binding : binding.upstreamAlias || binding);\n}\nfunction getAllTagReferenceNodes(tag, referenceNodes = []) {\n  if (tag.arguments) {\n    for (const arg of tag.arguments) {\n      referenceNodes.push(arg);\n    }\n  }\n  for (const attr2 of tag.attributes) {\n    referenceNodes.push(attr2.value);\n  }\n  for (const child of tag.body.attributeTags ? tag.body.body : tag.attributeTags) {\n    switch (child.type) {\n      case \"MarkoTag\":\n        getAllTagReferenceNodes(child, referenceNodes);\n        break;\n      case \"MarkoScriptlet\":\n        for (const statement of child.body) {\n          referenceNodes.push(statement);\n        }\n        break;\n    }\n  }\n  return referenceNodes;\n}\nfunction getScopeAccessorLiteral(binding, includeId) {\n  if (isOptimize()) {\n    return import_compiler26.types.numericLiteral(binding.id);\n  }\n  return import_compiler26.types.stringLiteral(\n    binding.name + (includeId || binding.type === 0 /* dom */ ? `/${binding.id}` : \"\")\n  );\n}\nfunction getScopeAccessor(binding, includeId) {\n  if (isOptimize()) {\n    return binding.id + \"\";\n  }\n  return binding.name + (includeId || binding.type === 0 /* dom */ ? `/${binding.id}` : \"\");\n}\nfunction getSectionInstancesAccessor(section) {\n  return section.sectionAccessor ? section.sectionAccessor.prefix + getScopeAccessor(section.sectionAccessor.binding) : getAccessorPrefix().ClosureScopes + section.id;\n}\nfunction getSectionInstancesAccessorLiteral(section) {\n  const accessor = getSectionInstancesAccessor(section);\n  return accessor ? typeof accessor === \"number\" ? import_compiler26.types.numericLiteral(accessor) : import_compiler26.types.stringLiteral(accessor) : void 0;\n}\nfunction getReadReplacement(node) {\n  const { extra } = node;\n  if (!extra) return;\n  let { binding, read } = extra;\n  let replacement;\n  if (read) {\n    if (read.props === void 0) {\n      binding = read.binding;\n      read = void 0;\n    } else {\n      binding = void 0;\n    }\n  }\n  if (binding) {\n    if (node.type === \"Identifier\") {\n      if (binding.type === 5 /* hoist */) {\n        replacement = node.extra?.[kIsInvoked] ? import_compiler26.types.callExpression(getHoistFunctionIdentifier(binding), [\n          getScopeExpression(node.extra.section, binding.section)\n        ]) : import_compiler26.types.identifier(getScopeAccessor(binding));\n      } else if (binding.name !== node.name) {\n        node.name = binding.name;\n      }\n    } else {\n      replacement = import_compiler26.types.identifier(binding.name);\n    }\n  } else if (read) {\n    replacement = toMemberExpression(\n      import_compiler26.types.identifier(read.binding.name),\n      Array.isArray(read.props) ? read.props[0] : read.props\n    );\n    if (Array.isArray(read.props)) {\n      for (let i = 1; i < read.props.length; i++) {\n        replacement = toMemberExpression(replacement, read.props[i]);\n      }\n    }\n  }\n  return replacement && withPreviousLocation(replacement, node);\n}\nfunction pruneBinding(bindings, binding) {\n  let shouldPrune = !binding.downstreamExpressions.size;\n  for (const alias of binding.aliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.aliases.delete(alias);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  for (const [key, alias] of binding.propertyAliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.propertyAliases.delete(key);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  if (shouldPrune) {\n    bindings.delete(binding);\n  }\n  return shouldPrune;\n}\nfunction resolveReferencedBindings(expr, reads, intersectionsBySection) {\n  let referencedBindings;\n  if (Array.isArray(reads)) {\n    for (const read of reads) {\n      let { binding } = read;\n      if (read.node) {\n        const exprReference = (read.node.extra ??= {}).read ??= resolveExpressionReference(reads, binding, void 0);\n        ({ binding } = (read.node.extra ??= {}).read = exprReference);\n      }\n      referencedBindings = bindingUtil.add(referencedBindings, binding);\n    }\n  } else if (reads) {\n    if (reads.node) {\n      (reads.node.extra ??= {}).read = createRead(reads.binding, void 0);\n    }\n    referencedBindings = reads.binding;\n  }\n  if (Array.isArray(referencedBindings)) {\n    const intersections = intersectionsBySection.get(expr.section) || [];\n    const intersection = findSorted(\n      compareIntersections,\n      intersections,\n      referencedBindings\n    );\n    if (intersection) {\n      referencedBindings = intersection;\n    } else {\n      intersectionsBySection.set(\n        expr.section,\n        addSorted(compareIntersections, intersections, referencedBindings)\n      );\n    }\n  }\n  return referencedBindings;\n}\nfunction resolveExpressionReference(reads, readBinding, readProps) {\n  const { upstreamAlias } = readBinding;\n  if (upstreamAlias && Array.isArray(reads)) {\n    const prop = getCanonicalProperty(readBinding);\n    const aliasProps = prop === void 0 ? readProps : push(readProps, prop);\n    for (const { binding } of reads) {\n      if (binding !== readBinding) {\n        let alias = upstreamAlias;\n        while (alias) {\n          if (binding === alias) {\n            return resolveExpressionReference(reads, alias, aliasProps);\n          }\n          alias = alias.upstreamAlias;\n        }\n      }\n    }\n  }\n  return createRead(readBinding, readProps);\n}\nfunction getCanonicalProperty(binding) {\n  return binding.property ?? binding.upstreamAlias?.property;\n}\nfunction createRead(binding, props) {\n  return { binding, props };\n}\nfunction getMemberExpressionPropString(expr) {\n  switch (expr.property.type) {\n    case \"StringLiteral\":\n      return expr.property.value;\n    case \"NumericLiteral\":\n      return \"\" + expr.property.value;\n    case \"Identifier\":\n      if (expr.computed) return;\n      return expr.property.name;\n  }\n}\nfunction isEventOrChangeHandler(prop) {\n  return /^on[-A-Z][a-zA-Z0-9_$]|[a-zA-Z_$][a-zA-Z0-9_$]*Change$/.test(prop);\n}\nfunction isReferencedExtra(extra) {\n  return !!(extra && !extra.pruned && extra.section);\n}\nfunction isAssignedBindingExtra(extra) {\n  return isReferencedExtra(extra) && extra.assignment !== void 0;\n}\nfunction isRegisteredFnExtra(extra) {\n  return isReferencedExtra(extra) && extra.registerId !== void 0;\n}\n\n// src/translator/core/await.ts\nvar kDOMBinding = Symbol(\"await tag dom binding\");\nvar await_default = {\n  analyze(tag) {\n    (0, import_babel_utils12.assertNoVar)(tag);\n    (0, import_babel_utils12.assertNoArgs)(tag);\n    assertNoSpreadAttrs(tag);\n    (0, import_babel_utils12.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    const tagBody = tag.get(\"body\");\n    const section = getOrCreateSection(tag);\n    const [valueAttr] = node.attributes;\n    const tagExtra = tag.node.extra ??= {};\n    tagExtra[kDOMBinding] = createBinding(\n      \"#text\",\n      0 /* dom */,\n      section,\n      void 0,\n      tagExtra\n    );\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `await` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler27.types.isMarkoAttribute(valueAttr) || valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `await` tag only supports the `value` attribute.\"\n      );\n    }\n    if (!node.body.body.length) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `await` tag requires body content.\");\n    }\n    if (node.body.params.length && (node.body.params.length > 1 || import_compiler27.types.isSpreadElement(node.body.params[0]))) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `await` tag only supports a single parameter.\"\n      );\n    }\n    const bodySection = startSection(tagBody);\n    getOrCreateSection(tag);\n    trackParamsReferences(\n      tagBody,\n      3 /* param */,\n      void 0,\n      evaluate(valueAttr.value)\n    );\n    bodySection.upstreamExpression = valueAttr.value.extra;\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        flushBefore(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const [valueAttr] = node.attributes;\n        const tagExtra = node.extra;\n        const nodeRef2 = tagExtra[kDOMBinding];\n        const tagBody = tag.get(\"body\");\n        const section = getSection(tag);\n        flushInto(tag);\n        writeHTMLResumeStatements(tagBody);\n        tag.replaceWith(\n          import_compiler27.types.expressionStatement(\n            callRuntime(\n              \"fork\",\n              getScopeIdIdentifier(section),\n              getScopeAccessorLiteral(nodeRef2),\n              valueAttr.value,\n              import_compiler27.types.arrowFunctionExpression(\n                node.body.params,\n                toFirstExpressionOrBlock(node.body.body)\n              )\n            )\n          )\n        )[0].skip();\n      }\n    },\n    dom: {\n      enter(tag) {\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        visit(tag, 37 /* Replace */);\n        enterShallow(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const nodeRef2 = tagExtra[kDOMBinding];\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tag.get(\"body\"));\n        const signal = getSignal(section, nodeRef2, \"await\");\n        signal.build = () => {\n          return callRuntime(\n            \"awaitTag\",\n            getScopeAccessorLiteral(nodeRef2),\n            import_compiler27.types.identifier(bodySection.name)\n          );\n        };\n        addValue(\n          section,\n          bodySection.upstreamExpression?.referencedBindings,\n          signal,\n          tag.node.attributes[0].value\n        );\n        tag.remove();\n      }\n    }\n  }),\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to consume asynchronous an data.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#await\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/await.d.marko\"\n};\n\n// src/translator/core/client.ts\nvar import_compiler28 = require(\"@marko/compiler\");\nvar import_babel_utils13 = require(\"@marko/compiler/babel-utils\");\nvar client_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^client\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils13.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler28.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler28.types.markoScriptlet(body, true, \"client\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"client <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the client.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#client-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/const.ts\nvar import_compiler30 = require(\"@marko/compiler\");\nvar import_babel_utils14 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/translate-var.ts\nvar import_compiler29 = require(\"@marko/compiler\");\nfunction translateVar(tag, initialValue, kind = \"const\") {\n  const {\n    node: { var: tagVar }\n  } = tag;\n  if (!tagVar) {\n    return;\n  }\n  tag.insertBefore(\n    import_compiler29.types.variableDeclaration(kind, [import_compiler29.types.variableDeclarator(tagVar, initialValue)])\n  );\n}\n\n// src/translator/core/const.ts\nvar const_default = {\n  analyze(tag) {\n    (0, import_babel_utils14.assertNoArgs)(tag);\n    (0, import_babel_utils14.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a tag variable.\");\n    }\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler30.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `const` tag only supports the `value` attribute.\"\n      );\n    }\n    const upstreamAlias = import_compiler30.types.isIdentifier(valueAttr.value) ? tag.scope.getBinding(valueAttr.value.name)?.identifier.extra?.binding : void 0;\n    trackVarReferences(\n      tag,\n      4 /* derived */,\n      upstreamAlias,\n      evaluate(valueAttr.value)\n      // TODO could perform a more extensive \"nullable\" check.\n    );\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      const { value } = valueAttr;\n      if (isOutputDOM()) {\n        const section = getSection(tag);\n        const varBinding = node.var.extra?.binding;\n        if (varBinding && !varBinding.upstreamAlias) {\n          const derivation = initValue(varBinding);\n          addValue(section, value.extra?.referencedBindings, derivation, value);\n        }\n      } else {\n        translateVar(tag, value);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an constant binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#const\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/const.d.marko\"\n};\n\n// src/translator/core/debug.ts\nvar import_compiler31 = require(\"@marko/compiler\");\nvar import_babel_utils15 = require(\"@marko/compiler/babel-utils\");\nvar debug_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils15.assertNoVar)(tag);\n    (0, import_babel_utils15.assertNoArgs)(tag);\n    (0, import_babel_utils15.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (tag.node.attributes.length > 1 || tag.node.attributes.length === 1 && (!import_compiler31.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\")) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `debug` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const referencedBindings = valueAttr?.value.extra?.referencedBindings;\n      const statement = withPreviousLocation(import_compiler31.types.debuggerStatement(), tag.node);\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Debug on value change.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#debug\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/debug.d.marko\"\n};\n\n// src/translator/core/define.ts\nvar import_compiler37 = require(\"@marko/compiler\");\nvar import_babel_utils21 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/nested-attribute-tags.ts\nvar import_compiler32 = require(\"@marko/compiler\");\nvar import_babel_utils16 = require(\"@marko/compiler/babel-utils\");\nvar attrTagToIdentifierLookup = /* @__PURE__ */ new WeakMap();\nfunction getAttrTagIdentifier(meta) {\n  let name2 = attrTagToIdentifierLookup.get(meta);\n  if (!name2) {\n    name2 = generateUid(meta.name);\n    attrTagToIdentifierLookup.set(meta, name2);\n  }\n  return import_compiler32.types.identifier(name2);\n}\nfunction analyzeAttributeTags(tag) {\n  if (tag.node.extra?.attributeTags) return tag.node.extra.attributeTags;\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  if (!attrTags2.length) return;\n  const tagExtra = tag.node.extra ??= {};\n  const lookup = tagExtra.attributeTags = {};\n  const attrTagNodesByName = {};\n  const sampleAttrTagsForControlFlow = /* @__PURE__ */ new Map();\n  for (const child of attrTags2) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils16.isAttributeTag)(child)) {\n        const name2 = getTagName(child);\n        lookup[name2] ||= createAttrTagMeta(name2, [name2]);\n        (attrTagNodesByName[name2] ||= []).push(child);\n        analyzeAttributeTags(child);\n      } else {\n        const isRepeated = (0, import_babel_utils16.isLoopTag)(child);\n        let curGroup;\n        for (const name2 of crawlAttrTags(child, attrTagNodesByName)) {\n          const oldMeta = lookup[name2];\n          if (oldMeta) {\n            if (!curGroup) {\n              curGroup = oldMeta.group;\n            } else if (curGroup !== oldMeta.group) {\n              for (const name3 of oldMeta.group) {\n                lookup[name3].group = curGroup;\n                curGroup.push(name3);\n              }\n            }\n          }\n          let attrTagMeta = lookup[name2];\n          if (!attrTagMeta) {\n            attrTagMeta = lookup[name2] = createAttrTagMeta(name2, []);\n            curGroup = attrTagMeta.group;\n            curGroup.push(name2);\n          }\n          attrTagMeta.dynamic = true;\n          if (isRepeated) {\n            attrTagMeta.repeated = true;\n          }\n          sampleAttrTagsForControlFlow.set(child, name2);\n        }\n      }\n    }\n  }\n  for (const [controlFlowTag, sampleAttrName] of sampleAttrTagsForControlFlow) {\n    (controlFlowTag.node.extra ??= {}).attributeTagGroup = lookup[sampleAttrName].group;\n  }\n  for (const name2 in attrTagNodesByName) {\n    const attrTagMeta = lookup[name2];\n    if (!attrTagMeta.repeated) {\n      const attrTagNodes = attrTagNodesByName[name2];\n      if (attrTagNodes.length > 1) {\n        attrTagMeta.repeated = !attrTagMeta.dynamic || hasRepeatedDynamicAttrTags(attrTagNodes);\n      }\n    }\n  }\n  return lookup;\n}\nfunction createAttrTagMeta(name2, group) {\n  return {\n    name: name2.slice(1),\n    dynamic: false,\n    repeated: false,\n    group\n  };\n}\nfunction crawlAttrTags(tag, attrTagNodesByName, attrTagNames = /* @__PURE__ */ new Set()) {\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  for (const child of attrTags2) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils16.isAttributeTag)(child)) {\n        const tagName = getTagName(child);\n        attrTagNames.add(tagName);\n        (attrTagNodesByName[tagName] ||= []).push(child);\n        analyzeAttributeTags(child);\n      } else {\n        crawlAttrTags(child, attrTagNodesByName, attrTagNames);\n      }\n    }\n  }\n  return attrTagNames;\n}\nfunction hasRepeatedDynamicAttrTags(attrTags2) {\n  let conditionRoot;\n  const seenBranches = /* @__PURE__ */ new Set();\n  for (const attrTag2 of attrTags2) {\n    const parentTag = getParentTag(attrTag2);\n    if (seenBranches.has(parentTag) || !isConditionTag(parentTag)) {\n      return true;\n    }\n    const curConditionRoot = getConditionRoot(parentTag);\n    if (curConditionRoot && curConditionRoot !== (conditionRoot ||= curConditionRoot)) {\n      return true;\n    }\n    seenBranches.add(parentTag);\n  }\n  return false;\n}\nfunction getConditionRoot(tag) {\n  if (getTagName(tag) === \"if\") return tag;\n  let prev = tag.getPrevSibling();\n  while (prev.node) {\n    if (prev.isMarkoTag() && getTagName(prev) === \"if\") {\n      return prev;\n    }\n    prev = prev.getPrevSibling();\n  }\n}\n\n// src/translator/util/translate-attrs.ts\nvar import_compiler36 = require(\"@marko/compiler\");\nvar import_babel_utils20 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/core/for.ts\nvar import_compiler35 = require(\"@marko/compiler\");\nvar import_babel_utils19 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/is-only-child-in-parent.ts\nvar import_compiler34 = require(\"@marko/compiler\");\nvar import_babel_utils18 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/visitors/tag/native-tag.ts\nvar import_compiler33 = require(\"@marko/compiler\");\nvar import_babel_utils17 = require(\"@marko/compiler/babel-utils\");\nvar kNativeTagBinding = Symbol(\"native tag binding\");\nvar kSerializeMarker = Symbol(\"serialize marker\");\nvar kGetterId = Symbol(\"node getter id\");\nvar htmlSelectArgs = /* @__PURE__ */ new WeakMap();\nfunction assertExclusiveControllableGroups(tag, attrs2) {\n  const exclusiveGroups = [\n    attrs2.open || attrs2.openChange,\n    attrs2.checked || attrs2.checkedChange,\n    attrs2.checkedValue || attrs2.checkedValueChange,\n    attrs2.valueChange\n  ].filter(Boolean);\n  if (exclusiveGroups.length > 1) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The attributes ${exclusiveGroups.map((attr2) => `\"${attr2.name}\"`).join(\", \")} are mutually exclusive.`\n    );\n  }\n}\nfunction getRelatedControllable(tagName, attrs2) {\n  switch (tagName) {\n    case \"input\":\n      if (attrs2.checked || attrs2.checkedChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_checked\",\n          attrs: [attrs2.checked, attrs2.checkedChange]\n        };\n      }\n      if (attrs2.checkedValue || attrs2.checkedValueChange) {\n        return {\n          special: true,\n          helper: \"controllable_input_checkedValue\",\n          attrs: [attrs2.checkedValue, attrs2.checkedValueChange, attrs2.value]\n        };\n      }\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"select\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_select_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"textarea\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_textarea_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"details\":\n    case \"dialog\":\n      if (attrs2.open || attrs2.openChange) {\n        return {\n          special: false,\n          helper: \"controllable_detailsOrDialog_open\",\n          attrs: [attrs2.open, attrs2.openChange]\n        };\n      }\n      break;\n  }\n}\nvar native_tag_default = {\n  transform: {\n    enter(tag) {\n      const tagName = getTagName(tag);\n      if (tagName === \"textarea\" && tag.node.body.body.length) {\n        const parts = [];\n        for (const child of tag.node.body.body) {\n          if (child.type === \"MarkoText\" || child.type === \"MarkoPlaceholder\" && child.escape) {\n            parts.push(child.value);\n          } else {\n            throw tag.hub.file.hub.buildError(\n              child,\n              \"Unexpected content in textarea, only text and placeholders are supported.\",\n              SyntaxError\n            );\n          }\n        }\n        tag.node.attributes.push(\n          import_compiler33.types.markoAttribute(\n            \"value\",\n            normalizeStringExpression(parts) || buildUndefined()\n          )\n        );\n        tag.node.body.body = [];\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils17.assertNoArgs)(tag);\n      (0, import_babel_utils17.assertNoParams)(tag);\n      (0, import_babel_utils17.assertNoAttributeTags)(tag);\n      const { node } = tag;\n      if (node.var && !import_compiler33.types.isIdentifier(node.var)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"Tag variables on native elements cannot be destructured.\"\n        );\n      }\n      const tagName = getTagName(tag);\n      const section = getOrCreateSection(tag);\n      let hasEventHandlers = false;\n      let hasDynamicAttributes = false;\n      const seen = {};\n      const { attributes } = tag.node;\n      let relatedControllable;\n      let spreadReferenceNodes;\n      for (let i = attributes.length; i--; ) {\n        const attr2 = attributes[i];\n        if (import_compiler33.types.isMarkoAttribute(attr2)) {\n          if (seen[attr2.name]) {\n            dropReferences(attr2.value);\n            continue;\n          }\n          seen[attr2.name] = attr2;\n          if (isEventHandler(attr2.name) || isChangeHandler(attr2.name)) {\n            (attr2.value.extra ??= {}).isEffect = true;\n            hasEventHandlers = true;\n          } else if (!evaluate(attr2.value).confident) {\n            hasDynamicAttributes = true;\n          }\n        } else if (import_compiler33.types.isMarkoSpreadAttribute(attr2)) {\n          hasEventHandlers = true;\n          hasDynamicAttributes = true;\n          (attr2.value.extra ??= {}).isEffect = true;\n        }\n        if (spreadReferenceNodes) {\n          spreadReferenceNodes.push(attr2.value);\n        } else if (import_compiler33.types.isMarkoSpreadAttribute(attr2)) {\n          spreadReferenceNodes = [attr2.value];\n          relatedControllable = getRelatedControllable(tagName, seen);\n        }\n      }\n      assertExclusiveControllableGroups(tag, seen);\n      if (spreadReferenceNodes) {\n        if (relatedControllable && !relatedControllable.attrs.every(Boolean)) {\n          for (const attr2 of relatedControllable.attrs) {\n            if (attr2) {\n              spreadReferenceNodes.push(attr2.value);\n            }\n          }\n          relatedControllable = void 0;\n        }\n        mergeReferences(section, tag.node, spreadReferenceNodes);\n      } else {\n        relatedControllable = getRelatedControllable(tagName, seen);\n      }\n      if (relatedControllable) {\n        mergeReferences(\n          section,\n          relatedControllable.attrs.find(Boolean).value,\n          relatedControllable.attrs.map((it) => it?.value)\n        );\n      }\n      if (node.var || hasEventHandlers || hasDynamicAttributes) {\n        (0, import_compiler33.getProgram)().node.extra.isInteractive ||= hasEventHandlers;\n        const tagName2 = node.name.type === \"StringLiteral\" ? node.name.value : import_compiler33.types.toIdentifier(tag.get(\"name\"));\n        const tagExtra = node.extra ??= {};\n        const bindingName = \"#\" + tagName2;\n        if (hasEventHandlers || node.var) {\n          tagExtra[kSerializeMarker] = true;\n        }\n        const tagBinding = tagExtra[kNativeTagBinding] = createBinding(\n          bindingName,\n          0 /* dom */,\n          section\n        );\n        if (node.var) {\n          const varBinding = tag.scope.getBinding(node.var.name);\n          for (const referencePath of varBinding.referencePaths) {\n            const referenceSection = getSection(referencePath);\n            setReferencesScope(referencePath);\n            if (!isSameOrChildSection(section, referenceSection)) {\n              trackHoistedReference(\n                referencePath,\n                tagBinding\n              );\n            } else if (!isInvokedFunction(referencePath)) {\n              tagExtra[kGetterId] ||= getRegisterUID(section, bindingName);\n            }\n          }\n        }\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagName = getTagName(tag);\n      const extra = tag.node.extra;\n      const nodeRef2 = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const name2 = tag.get(\"name\");\n      const tagDef = (0, import_babel_utils17.getTagDef)(tag);\n      const write2 = writeTo(tag);\n      const section = getSection(tag);\n      if (isHTML && extra.tagNameNullable) {\n        flushBefore(tag);\n      }\n      if (tag.has(\"var\")) {\n        const varName = tag.node.var.name;\n        const varBinding = tag.scope.getBinding(varName);\n        const getterId = extra[kGetterId];\n        if (isHTML) {\n          for (const reference of varBinding.referencePaths) {\n            const referenceSection = getSection(reference);\n            if (!reference.node.extra?.hoist) {\n              serializeOwners(referenceSection, section);\n            }\n          }\n          serializeSectionIfNeeded(section, true);\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(section),\n              getterId && import_compiler33.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);\n            (0, import_compiler33.getProgram)().node.body.push(\n              import_compiler33.types.variableDeclaration(\"const\", [\n                import_compiler33.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler33.types.stringLiteral(getterId),\n                    import_compiler33.types.stringLiteral(\n                      getAccessorPrefix().Getter + getScopeAccessorLiteral(nodeRef2).value\n                    )\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of varBinding.referencePaths) {\n            if (!reference.node.extra?.hoistedBinding) {\n              const referenceSection = getSection(reference);\n              if (isInvokedFunction(reference)) {\n                reference.parentPath.replaceWith(\n                  import_compiler33.types.expressionStatement(\n                    createScopeReadExpression(referenceSection, nodeRef2)\n                  )\n                );\n              } else if (getterFnIdentifier) {\n                reference.replaceWith(\n                  import_compiler33.types.callExpression(getterFnIdentifier, [\n                    getScopeExpression(referenceSection, getSection(tag))\n                  ])\n                );\n              } else {\n                reference.replaceWith(\n                  import_compiler33.types.expressionStatement(\n                    import_compiler33.types.memberExpression(\n                      getScopeExpression(section, referenceSection),\n                      import_compiler33.types.stringLiteral(\n                        getAccessorPrefix().Getter + getScopeAccessorLiteral(nodeRef2).value\n                      ),\n                      true\n                    )\n                  )\n                );\n              }\n            }\n          }\n        }\n      }\n      let visitAccessor;\n      if (nodeRef2) {\n        visitAccessor = getScopeAccessorLiteral(nodeRef2);\n        visit(tag, 32 /* Get */);\n      }\n      write2`<${name2.node}`;\n      const usedAttrs = getUsedAttrs(tagName, tag.node);\n      const { staticAttrs, staticControllable, skipExpression } = usedAttrs;\n      let { spreadExpression } = usedAttrs;\n      if (staticControllable) {\n        const { helper, attrs: attrs2 } = staticControllable;\n        const firstAttr = attrs2.find(Boolean);\n        const referencedBindings = firstAttr.value.extra?.referencedBindings;\n        const values = attrs2.map((attr2) => attr2?.value);\n        if (isHTML) {\n          if (tagName !== \"select\" && tagName !== \"textarea\") {\n            write2`${callRuntime(helper, getScopeIdIdentifier(section), visitAccessor, ...values)}`;\n          }\n          addHTMLEffectCall(section, void 0);\n        } else {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            import_compiler33.types.expressionStatement(\n              callRuntime(helper, scopeIdentifier, visitAccessor, ...values)\n            )\n          );\n          addStatement(\n            \"effect\",\n            section,\n            void 0,\n            import_compiler33.types.expressionStatement(\n              callRuntime(`${helper}_effect`, scopeIdentifier, visitAccessor)\n            )\n          );\n        }\n      }\n      let writeAtStartOfBody;\n      if (isHTML) {\n        if (tagName === \"select\") {\n          if (staticControllable) {\n            htmlSelectArgs.set(tag.node, {\n              value: staticControllable.attrs[0]?.value || buildUndefined(),\n              valueChange: staticControllable.attrs[1]?.value || buildUndefined()\n            });\n          } else if (spreadExpression) {\n            const spreadIdentifier = generateUidIdentifier(\"select_input\");\n            tag.insertBefore(\n              import_compiler33.types.variableDeclaration(\"const\", [\n                import_compiler33.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            htmlSelectArgs.set(tag.node, {\n              value: import_compiler33.types.memberExpression(\n                spreadIdentifier,\n                import_compiler33.types.identifier(\"value\")\n              ),\n              valueChange: import_compiler33.types.memberExpression(\n                spreadIdentifier,\n                import_compiler33.types.identifier(\"valueChange\")\n              )\n            });\n            spreadExpression = spreadIdentifier;\n          }\n        } else if (tagName === \"textarea\") {\n          let value;\n          let valueChange;\n          if (staticControllable) {\n            value = staticControllable.attrs[0]?.value;\n            valueChange = staticControllable.attrs[1]?.value;\n          } else if (spreadExpression) {\n            const spreadIdentifier = generateUidIdentifier(\"textarea_input\");\n            tag.insertBefore(\n              import_compiler33.types.variableDeclaration(\"const\", [\n                import_compiler33.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            value = import_compiler33.types.memberExpression(spreadIdentifier, import_compiler33.types.identifier(\"value\"));\n            valueChange = import_compiler33.types.memberExpression(\n              spreadIdentifier,\n              import_compiler33.types.identifier(\"valueChange\")\n            );\n            spreadExpression = spreadIdentifier;\n          }\n          if (value || valueChange) {\n            writeAtStartOfBody = callRuntime(\n              \"controllable_textarea_value\",\n              getScopeIdIdentifier(getSection(tag)),\n              getScopeAccessorLiteral(nodeRef2),\n              value,\n              valueChange\n            );\n          }\n        }\n      }\n      for (const attr2 of staticAttrs) {\n        const { name: name3, value } = attr2;\n        const { confident, computed } = value.extra || {};\n        const valueReferences = value.extra?.referencedBindings;\n        if (isHTML && tagName === \"option\" && name3 === \"value\") {\n          write2`${callRuntime(\"optionValueAttr\", value)}`;\n          continue;\n        }\n        switch (name3) {\n          case \"class\":\n          case \"style\": {\n            const helper = `${name3}Attr`;\n            if (confident) {\n              write2`${getHTMLRuntime()[helper](computed)}`;\n            } else if (isHTML) {\n              write2`${callRuntime(helper, value)}`;\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler33.types.expressionStatement(\n                  callRuntime(\n                    helper,\n                    import_compiler33.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n          }\n          default:\n            if (confident) {\n              write2`${getHTMLRuntime().attr(name3, computed)}`;\n            } else if (isHTML) {\n              if (isEventHandler(name3)) {\n                addHTMLEffectCall(section, valueReferences);\n              } else {\n                write2`${callRuntime(\"attr\", import_compiler33.types.stringLiteral(name3), value)}`;\n              }\n            } else if (isEventHandler(name3)) {\n              addStatement(\n                \"effect\",\n                section,\n                valueReferences,\n                import_compiler33.types.expressionStatement(\n                  callRuntime(\n                    \"on\",\n                    import_compiler33.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler33.types.stringLiteral(getEventHandlerName(name3)),\n                    value\n                  )\n                )\n              );\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler33.types.expressionStatement(\n                  callRuntime(\n                    \"attr\",\n                    import_compiler33.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler33.types.stringLiteral(name3),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n        }\n      }\n      if (spreadExpression) {\n        if (isHTML) {\n          addHTMLEffectCall(section, extra.referencedBindings);\n          if (skipExpression) {\n            write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(section), name2.node)}`;\n          } else {\n            write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(section), name2.node)}`;\n          }\n        } else {\n          if (skipExpression) {\n            addStatement(\n              \"render\",\n              section,\n              extra.referencedBindings,\n              import_compiler33.types.expressionStatement(\n                callRuntime(\n                  \"partialAttrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression,\n                  skipExpression\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              extra.referencedBindings,\n              import_compiler33.types.expressionStatement(\n                callRuntime(\n                  \"attrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression\n                )\n              )\n            );\n          }\n          addStatement(\n            \"effect\",\n            section,\n            extra.referencedBindings,\n            import_compiler33.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            false\n          );\n        }\n      }\n      if (tagDef && tagDef.parseOptions?.openTagOnly) {\n        switch (tagDef.htmlType) {\n          case \"svg\":\n          case \"math\":\n            write2`/>`;\n            break;\n          default:\n            write2`>`;\n            break;\n        }\n      } else {\n        write2`>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(import_compiler33.types.ifStatement(name2.node, consumeHTML(tag)))[0].skip();\n      }\n      if (writeAtStartOfBody) {\n        write2`${writeAtStartOfBody}`;\n      }\n      enter2(tag);\n    },\n    exit(tag) {\n      const extra = tag.node.extra;\n      const nodeRef2 = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const openTagOnly = (0, import_babel_utils17.getTagDef)(tag)?.parseOptions?.openTagOnly;\n      const selectArgs = isHTML && htmlSelectArgs.get(tag.node);\n      const tagName = getTagName(tag);\n      if (isHTML && extra.tagNameNullable) {\n        flushInto(tag);\n      }\n      if (selectArgs) {\n        writeTo(tag)`</${tag.node.name}>`;\n        flushInto(tag);\n        tag.insertBefore(\n          import_compiler33.types.expressionStatement(\n            callRuntime(\n              \"controllable_select_value\",\n              getScopeIdIdentifier(getSection(tag)),\n              getScopeAccessorLiteral(nodeRef2),\n              selectArgs.value,\n              selectArgs.valueChange,\n              import_compiler33.types.arrowFunctionExpression(\n                [],\n                import_compiler33.types.blockStatement(tag.node.body.body)\n              )\n            )\n          )\n        );\n      } else {\n        tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n      }\n      const allExtras = [extra];\n      for (const attr2 of tag.node.attributes) {\n        if (attr2.value.extra) {\n          allExtras.push(attr2.value.extra);\n        }\n      }\n      const serializeReason = getDynamicSourcesForExtras(allExtras);\n      const shouldMark = nodeRef2 && (extra[kSerializeMarker] || extra[kSerializeMarker] === void 0 && !!serializeReason);\n      if (!openTagOnly && !selectArgs) {\n        writeTo(\n          tag,\n          isHTML && !shouldMark && (tagName === \"html\" || tagName === \"body\")\n        )`</${tag.node.name}>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(\n          import_compiler33.types.ifStatement(tag.node.name, consumeHTML(tag))\n        )[0].skip();\n      }\n      if (shouldMark) {\n        markNode(tag, nodeRef2);\n      }\n      exit2(tag);\n      tag.remove();\n    }\n  }\n};\nfunction getUsedAttrs(tagName, tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  let staticControllable;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler33.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n        staticControllable = getRelatedControllable(tagName, seen);\n        if (staticControllable && !staticControllable.attrs.every(Boolean)) {\n          for (const attr3 of staticControllable.attrs) {\n            if (attr3) {\n              spreadProps.push(toObjectProperty(attr3.name, attr3.value));\n              maybeStaticAttrs.delete(attr3);\n            }\n          }\n          staticControllable = void 0;\n        }\n      }\n      spreadProps.push(import_compiler33.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  if (!spreadProps) {\n    staticControllable = getRelatedControllable(tagName, seen);\n    if (staticControllable?.special === false && !staticControllable.attrs[1]) {\n      staticControllable = void 0;\n    }\n  }\n  if (staticControllable) {\n    for (const attr2 of staticControllable.attrs) {\n      if (attr2) {\n        maybeStaticAttrs.delete(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    if (staticControllable) {\n      for (const attr2 of staticControllable.attrs) {\n        if (attr2) {\n          (skipProps ||= []).push(\n            toObjectProperty(attr2.name, import_compiler33.types.numericLiteral(1))\n          );\n        }\n      }\n    }\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler33.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler33.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    staticControllable,\n    spreadExpression,\n    skipExpression\n  };\n}\nfunction isChangeHandler(propName) {\n  return /^(?:value|checked(?:Value)?|open)Change/.test(propName);\n}\nfunction buildUndefined() {\n  return import_compiler33.types.unaryExpression(\"void\", import_compiler33.types.numericLiteral(0));\n}\n\n// src/translator/util/is-only-child-in-parent.ts\nvar kOnlyChildInParent = Symbol(\"only child in parent\");\nvar kNodeRef = Symbol(\"potential only child node ref\");\nfunction isOnlyChildInParent(tag, branchSize = 1) {\n  const extra = tag.node.extra;\n  if (extra[kOnlyChildInParent] !== void 0) {\n    return extra[kOnlyChildInParent];\n  }\n  const parentTag = getParentTag(tag);\n  if (parentTag && (0, import_babel_utils18.getTagDef)(parentTag)?.html) {\n    return extra[kOnlyChildInParent] = tag.parent.body.length === branchSize;\n  }\n  return extra[kOnlyChildInParent] = false;\n}\nfunction getOptimizedOnlyChildNodeRef(tag, section, branchSize = 1) {\n  if (isOnlyChildInParent(tag, branchSize)) {\n    const parentTag = getParentTag(tag).node;\n    const parentTagName = parentTag.name?.value;\n    return (parentTag.extra ??= {})[kNativeTagBinding] ??= createBinding(\n      \"#\" + parentTagName,\n      0 /* dom */,\n      section\n    );\n  } else {\n    return (tag.node.extra ??= {})[kNodeRef] ??= createBinding(\n      \"#text\",\n      0 /* dom */,\n      section\n    );\n  }\n}\n\n// src/translator/core/for.ts\nvar for_default = {\n  analyze(tag) {\n    const tagExtra = tag.node.extra ??= {};\n    const isAttrTag = tag.node.body.attributeTags;\n    let allowAttrs;\n    (0, import_babel_utils19.assertNoVar)(tag);\n    (0, import_babel_utils19.assertNoArgs)(tag);\n    assertNoSpreadAttrs(tag);\n    switch (getForType(tag.node)) {\n      case \"of\":\n        allowAttrs = [\"of\"];\n        break;\n      case \"in\":\n        allowAttrs = [\"in\"];\n        break;\n      case \"to\":\n        allowAttrs = [\"to\", \"from\", \"step\"];\n        break;\n      default:\n        throw tag.buildCodeFrameError(\n          \"Invalid `for` tag, missing an `of=`, `in=`, `to=` attribute.\"\n        );\n    }\n    if (!isAttrTag) {\n      allowAttrs.push(\"by\");\n    }\n    (0, import_babel_utils19.assertAllowedAttributes)(tag, allowAttrs);\n    if (isAttrTag) return;\n    const tagBody = tag.get(\"body\");\n    const bodySection = startSection(tagBody);\n    if (!bodySection) {\n      dropReferences(getAllTagReferenceNodes(tag.node));\n      return;\n    }\n    const section = getOrCreateSection(tag);\n    trackParamsReferences(tagBody, 3 /* param */, void 0, tagExtra);\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n    bodySection.sectionAccessor = {\n      binding: getOptimizedOnlyChildNodeRef(tag, section),\n      prefix: getAccessorPrefix().LoopScopeMap\n    };\n    bodySection.upstreamExpression = tagExtra;\n    bodySection.isBranch = true;\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        if (!isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n        flushBefore(tag);\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const onlyChildInParentOptimization = isOnlyChildInParent(tag);\n        const nodeRef2 = getOptimizedOnlyChildNodeRef(tag, tagSection);\n        const forAttrs = getKnownAttrValues(node);\n        const forType = getForType(node);\n        const params = node.body.params;\n        const statements = [];\n        const bodyStatements = node.body.body;\n        const sectionSources = getDynamicSourcesForSection(bodySection);\n        const hasHoists = isSectionWithHoists(bodySection);\n        const serializeReason = hasHoists || sectionSources?.all;\n        const singleNodeOptimization = bodySection.content === null || bodySection.content.singleChild && bodySection.content.startType !== 4 /* Text */;\n        if (serializeReason && onlyChildInParentOptimization) {\n          getParentTag(tag).node.extra[kSerializeMarker] = false;\n        }\n        flushInto(tag);\n        writeHTMLResumeStatements(tagBody);\n        const forTagArgs = getBaseArgsInForTag(forType, forAttrs);\n        const forTagHTMLRuntime = serializeReason ? forTypeToHTMLResumeRuntime(forType, singleNodeOptimization) : forTypeToRuntime(forType);\n        forTagArgs.push(\n          import_compiler35.types.arrowFunctionExpression(params, import_compiler35.types.blockStatement(bodyStatements))\n        );\n        if (serializeReason) {\n          forTagArgs.push(\n            forAttrs.by || import_compiler35.types.numericLiteral(0),\n            getScopeIdIdentifier(tagSection),\n            getScopeAccessorLiteral(nodeRef2)\n          );\n          if (onlyChildInParentOptimization) {\n            forTagArgs.push(import_compiler35.types.numericLiteral(1));\n          }\n        }\n        statements.push(\n          import_compiler35.types.expressionStatement(callRuntime(forTagHTMLRuntime, ...forTagArgs))\n        );\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        if (!isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const { referencedBindings } = tagExtra;\n        const nodeRef2 = getOptimizedOnlyChildNodeRef(tag, tagSection);\n        setClosureSignalBuilder(tag, (closure, render) => {\n          return callRuntime(\n            \"loopClosure\",\n            getScopeAccessorLiteral(closure),\n            getScopeAccessorLiteral(nodeRef2),\n            render\n          );\n        });\n        const forType = getForType(node);\n        const signal = getSignal(tagSection, nodeRef2, \"for\");\n        signal.build = () => {\n          return callRuntime(\n            forTypeToDOMRuntime(forType),\n            getScopeAccessorLiteral(nodeRef2),\n            import_compiler35.types.identifier(bodySection.name)\n          );\n        };\n        const params = node.body.params;\n        signal.hasDownstreamIntersections = () => {\n          for (const param of params) {\n            const binding = param.extra?.binding;\n            if (binding) {\n              for (const {\n                referencedBindings: referencedBindings2\n              } of binding.downstreamExpressions) {\n                if (getSignal(\n                  bodySection,\n                  referencedBindings2\n                ).hasDownstreamIntersections()) {\n                  return true;\n                }\n              }\n            }\n          }\n          return false;\n        };\n        const forAttrs = getKnownAttrValues(node);\n        const loopArgs = getBaseArgsInForTag(forType, forAttrs);\n        if (forAttrs.by) {\n          loopArgs.push(forAttrs.by);\n        }\n        addValue(\n          tagSection,\n          referencedBindings,\n          signal,\n          import_compiler35.types.arrayExpression(loopArgs)\n        );\n        tag.remove();\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  attributes: {\n    of: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over a list of items.\"\n        }\n      ]\n    },\n    in: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over the keys and values of an object.\"\n        }\n      ]\n    },\n    to: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates up to the provided number (inclusive)\"\n        }\n      ]\n    },\n    from: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates starting from the provided number (inclusive)\"\n        }\n      ]\n    },\n    step: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"The amount to increment during each interation (with from/to)\"\n        }\n      ]\n    }\n  },\n  autocomplete: [\n    {\n      snippet: \"for|${1:value, index}| of=${3:array}\",\n      description: \"Use to iterate over lists, object properties, or between ranges.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-a-list\"\n    },\n    {\n      snippet: \"for|${1:name, value}| in=${3:object}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties\"\n    },\n    {\n      snippet: \"for|${1:index}| to=${2:number}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers\"\n    }\n  ]\n};\nfunction buildForRuntimeCall(type, attrs2, params, statements) {\n  return import_compiler35.types.expressionStatement(\n    callRuntime(\n      forTypeToRuntime(type),\n      ...getBaseArgsInForTag(type, attrs2),\n      import_compiler35.types.arrowFunctionExpression(params, import_compiler35.types.blockStatement(statements))\n    )\n  );\n}\nfunction getForType(tag) {\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      switch (attr2.name) {\n        case \"of\":\n        case \"in\":\n        case \"to\":\n          return attr2.name;\n      }\n    }\n  }\n}\nfunction forTypeToRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"forOf\";\n    case \"in\":\n      return \"forIn\";\n    case \"to\":\n      return \"forTo\";\n  }\n}\nfunction forTypeToHTMLResumeRuntime(type, singleNodeOptimization) {\n  if (singleNodeOptimization) {\n    switch (type) {\n      case \"of\":\n        return \"resumeSingleNodeForOf\";\n      case \"in\":\n        return \"resumeSingleNodeForIn\";\n      case \"to\":\n        return \"resumeSingleNodeForTo\";\n    }\n  } else {\n    switch (type) {\n      case \"of\":\n        return \"resumeForOf\";\n      case \"in\":\n        return \"resumeForIn\";\n      case \"to\":\n        return \"resumeForTo\";\n    }\n  }\n}\nfunction forTypeToDOMRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"loopOf\";\n    case \"in\":\n      return \"loopIn\";\n    case \"to\":\n      return \"loopTo\";\n  }\n}\nfunction getBaseArgsInForTag(type, attrs2) {\n  switch (type) {\n    case \"in\":\n      return [attrs2.in];\n    case \"of\":\n      return [attrs2.of];\n    case \"to\":\n      return [\n        attrs2.to,\n        attrs2.from || import_compiler35.types.numericLiteral(0),\n        attrs2.step || import_compiler35.types.numericLiteral(1)\n      ];\n  }\n}\n\n// src/translator/util/translate-attrs.ts\nvar contentProps = /* @__PURE__ */ new WeakSet();\nfunction translateAttrs(tag, templateExports, statements = [], contentKey = \"content\") {\n  const seen = /* @__PURE__ */ new Set();\n  const properties = [];\n  const attrTagLookup = tag.node.extra?.attributeTags;\n  if (attrTagLookup) {\n    for (const name2 in attrTagLookup) {\n      const attrTagMeta = attrTagLookup[name2];\n      if (usesExport(templateExports, attrTagMeta.name)) {\n        seen.add(attrTagMeta.name);\n        if (attrTagMeta.dynamic) {\n          statements.push(\n            import_compiler36.types.variableDeclaration(\"let\", [\n              import_compiler36.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta))\n            ])\n          );\n          properties.push(\n            toObjectProperty(\n              attrTagMeta.name,\n              getAttrTagIdentifier(attrTagMeta)\n            )\n          );\n        }\n      }\n    }\n    const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils20.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          if (attrTagMeta.dynamic) {\n            i = addDynamicAttrTagStatements(\n              attrTags2,\n              i,\n              attrTagLookup,\n              statements,\n              templateExports,\n              contentKey\n            );\n          } else {\n            const translatedAttrTag = translateAttrs(\n              child,\n              templateExports?.[attrTagMeta.name]?.props,\n              statements,\n              contentKey\n            );\n            if (attrTagMeta.repeated) {\n              const prevProp = findObjectProperty(attrTagMeta.name, properties);\n              if (prevProp) {\n                prevProp.value = callRuntime(\n                  \"attrTags\",\n                  prevProp.value,\n                  propsToExpression(translatedAttrTag.properties)\n                );\n              } else {\n                properties.push(\n                  toObjectProperty(\n                    attrTagMeta.name,\n                    callRuntime(\n                      \"attrTag\",\n                      propsToExpression(translatedAttrTag.properties)\n                    )\n                  )\n                );\n              }\n            } else {\n              properties.push(\n                toObjectProperty(\n                  attrTagMeta.name,\n                  callRuntime(\n                    \"attrTag\",\n                    propsToExpression(translatedAttrTag.properties)\n                  )\n                )\n              );\n            }\n          }\n        } else {\n          i = addDynamicAttrTagStatements(\n            attrTags2,\n            i,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        }\n      }\n    }\n  }\n  if (!seen.has(contentKey) && usesExport(templateExports, contentKey)) {\n    seen.add(contentKey);\n    const contentExpression = buildContent(tag.get(\"body\"));\n    if (contentExpression) {\n      const contentProp = import_compiler36.types.objectProperty(\n        import_compiler36.types.identifier(contentKey),\n        contentExpression\n      );\n      contentProps.add(contentProp);\n      properties.push(contentProp);\n    }\n  }\n  const { attributes } = tag.node;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler36.types.isMarkoSpreadAttribute(attr2)) {\n      properties.push(import_compiler36.types.spreadElement(value));\n    } else if (!seen.has(attr2.name) && usesExport(templateExports, attr2.name)) {\n      seen.add(attr2.name);\n      properties.push(toObjectProperty(attr2.name, value));\n    }\n  }\n  properties.reverse();\n  return { properties, statements };\n}\nfunction getTranslatedBodyContentProperty(props) {\n  for (const prop of props) {\n    if (contentProps.has(prop)) {\n      return prop;\n    }\n  }\n}\nfunction addDynamicAttrTagStatements(attrTags2, index, attrTagLookup, statements, templateExports, contentKey = \"content\") {\n  const tag = attrTags2[index];\n  if (tag.isMarkoTag()) {\n    if ((0, import_babel_utils20.isAttributeTag)(tag)) {\n      const attrTagMeta = attrTagLookup[getTagName(tag)];\n      if (usesExport(templateExports, attrTagMeta.name) && attrTagMeta.dynamic) {\n        const translatedAttrTag = translateAttrs(\n          tag,\n          templateExports?.[attrTagMeta.name]?.props,\n          statements,\n          contentKey\n        );\n        if (attrTagMeta.repeated) {\n          statements.push(\n            import_compiler36.types.expressionStatement(\n              import_compiler36.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTags\",\n                  getAttrTagIdentifier(attrTagMeta),\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        } else {\n          statements.push(\n            import_compiler36.types.expressionStatement(\n              import_compiler36.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTag\",\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        }\n      }\n    } else {\n      switch (getTagName(tag)) {\n        case \"if\":\n          return translateIfAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        case \"for\": {\n          return translateForAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        }\n      }\n    }\n  }\n  return index;\n}\nfunction propsToExpression(props) {\n  return props.length === 1 && import_compiler36.types.isSpreadElement(props[0]) ? props[0].argument : import_compiler36.types.objectExpression(props);\n}\nfunction translateForAttrTag(attrTags2, index, attrTagLookup, statements, templateExports, contentKey) {\n  const forTag = attrTags2[index];\n  const bodyStatements = [];\n  addAllAttrTagsAsDynamic(\n    forTag,\n    attrTagLookup,\n    bodyStatements,\n    templateExports,\n    contentKey\n  );\n  statements.push(\n    buildForRuntimeCall(\n      getForType(forTag.node),\n      getKnownAttrValues(forTag.node),\n      forTag.node.body.params,\n      bodyStatements\n    )\n  );\n  return index;\n}\nfunction translateIfAttrTag(attrTags2, index, attrTagLookup, statements, templateExports, contentKey) {\n  const ifTag = attrTags2[index];\n  const consequentStatements = [];\n  let ifStatement = import_compiler36.types.ifStatement(\n    getConditionTestValue(ifTag),\n    import_compiler36.types.blockStatement(consequentStatements)\n  );\n  statements.push(ifStatement);\n  addAllAttrTagsAsDynamic(\n    ifTag,\n    attrTagLookup,\n    consequentStatements,\n    templateExports,\n    contentKey\n  );\n  let nextIndex = index + 1;\n  while (nextIndex < attrTags2.length) {\n    const nextTag = attrTags2[nextIndex];\n    if (nextTag.isMarkoTag()) {\n      switch (getTagName(nextTag)) {\n        case \"else-if\":\n        case \"else\": {\n          const testValue = getConditionTestValue(nextTag);\n          const alternateStatements = [];\n          addAllAttrTagsAsDynamic(\n            nextTag,\n            attrTagLookup,\n            alternateStatements,\n            templateExports,\n            contentKey\n          );\n          if (testValue) {\n            ifStatement.alternate = ifStatement = import_compiler36.types.ifStatement(\n              testValue,\n              import_compiler36.types.blockStatement(alternateStatements)\n            );\n            nextIndex++;\n            continue;\n          } else {\n            ifStatement.alternate = import_compiler36.types.blockStatement(alternateStatements);\n            break;\n          }\n        }\n      }\n    }\n    break;\n  }\n  return nextIndex - 1;\n}\nfunction addAllAttrTagsAsDynamic(tag, attrTagLookup, statements, templateExports, contentKey) {\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  for (let i = 0; i < attrTags2.length; i++) {\n    i = addDynamicAttrTagStatements(\n      attrTags2,\n      i,\n      attrTagLookup,\n      statements,\n      templateExports,\n      contentKey\n    );\n  }\n}\nfunction usesExport(templateExports, name2) {\n  return !templateExports || !!templateExports[name2];\n}\nfunction findObjectProperty(name2, props) {\n  for (const prop of props) {\n    if (prop.type === \"ObjectProperty\") {\n      switch (prop.key.type) {\n        case \"StringLiteral\":\n          if (prop.key.value === name2) {\n            return prop;\n          }\n          break;\n        case \"Identifier\":\n          if (prop.key.name === name2) {\n            return prop;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\nfunction getConditionTestValue({\n  node: { attributes }\n}) {\n  return attributes.length === 1 ? attributes[0].value : void 0;\n}\nfunction buildContent(body) {\n  const bodySection = body.node.extra?.section;\n  if (bodySection) {\n    if (isOutputHTML()) {\n      const serialized = isSerializedSection(bodySection);\n      return callRuntime(\n        serialized ? \"registerContent\" : \"createContent\",\n        import_compiler36.types.stringLiteral(getResumeRegisterId(bodySection, \"renderer\")),\n        import_compiler36.types.arrowFunctionExpression(\n          body.node.params,\n          import_compiler36.types.blockStatement(body.node.body)\n        ),\n        serialized ? getScopeIdIdentifier(\n          getSection(\n            getNonAttributeTagParent(\n              body.parentPath\n            )\n          )\n        ) : void 0\n      );\n    } else {\n      return import_compiler36.types.callExpression(import_compiler36.types.identifier(bodySection.name), [\n        scopeIdentifier\n      ]);\n    }\n  }\n}\nfunction getNonAttributeTagParent(tag) {\n  let cur = tag;\n  while ((0, import_babel_utils20.isAttributeTag)(cur) || (0, import_babel_utils20.isTransparentTag)(cur)) {\n    cur = getParentTag(cur);\n  }\n  return cur;\n}\n\n// src/translator/core/define.ts\nvar define_default = {\n  analyze(tag) {\n    (0, import_babel_utils21.assertNoArgs)(tag);\n    if (!tag.node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `define` tag requires a tag variable.\");\n    }\n    const tagBody = tag.get(\"body\");\n    const bodySection = startSection(tagBody);\n    trackVarReferences(tag, 4 /* derived */);\n    if (bodySection) {\n      const varBinding = tag.node.var?.extra?.binding;\n      if (varBinding) {\n        bodySection.downstreamBinding = varBinding.propertyAliases.get(\"content\") || varBinding;\n      }\n    }\n    trackParamsReferences(tagBody, 3 /* param */);\n    analyzeAttributeTags(tag);\n    mergeReferences(\n      getOrCreateSection(tag),\n      tag.node,\n      getAllTagReferenceNodes(tag.node)\n    );\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const translatedAttrs = translateAttrs(tag);\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        tag.insertBefore(translatedAttrs.statements);\n        translateVar(tag, propsToExpression(translatedAttrs.properties));\n      } else {\n        const section = getSection(tag);\n        const referencedBindings = node.extra?.referencedBindings;\n        const derivation = initValue(tag.get(\"var\").node.extra.binding);\n        if (translatedAttrs.statements.length) {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            translatedAttrs.statements\n          );\n        }\n        addValue(\n          section,\n          referencedBindings,\n          derivation,\n          propsToExpression(translatedAttrs.properties)\n        );\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a constant object binding that can be rendered.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#define\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/define.d.marko\"\n};\n\n// src/translator/core/effect.ts\nvar import_compiler38 = require(\"@marko/compiler\");\nvar import_babel_utils22 = require(\"@marko/compiler/babel-utils\");\nvar effect_default = {\n  migrate: [\n    (tag) => {\n      (0, import_babel_utils22.assertNoArgs)(tag);\n      (0, import_babel_utils22.assertNoParams)(tag);\n      assertNoBodyContent(tag);\n      (0, import_babel_utils22.assertNoAttributeTags)(tag);\n      assertNoSpreadAttrs(tag);\n      (0, import_babel_utils22.assertAllowedAttributes)(tag, [\"value\"]);\n      (0, import_babel_utils22.diagnosticDeprecate)(tag, {\n        label: \"The 'effect' tag has been replaced by the 'script' tag.\",\n        fix() {\n          const { node } = tag;\n          tag.replaceWith(\n            import_compiler38.types.markoTag(\n              withPreviousLocation(import_compiler38.types.stringLiteral(\"script\"), node.name),\n              node.attributes,\n              node.body,\n              node.arguments,\n              node.var,\n              node.attributeTags\n            )\n          );\n        }\n      });\n    }\n  ],\n  attributes: {},\n  types: runtime_info_default.name + \"/tag-types/effect.d.marko\"\n};\n\n// src/translator/core/export.ts\nvar import_babel_utils23 = require(\"@marko/compiler/babel-utils\");\nvar export_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils23.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"export <value>\"\n    }\n  ]\n};\n\n// src/translator/core/html-comment.ts\nvar import_compiler39 = require(\"@marko/compiler\");\nvar import_babel_utils24 = require(\"@marko/compiler/babel-utils\");\nvar kCommentTagBinding = Symbol(\"comment tag binding\");\nvar kGetterId2 = Symbol(\"node getter id\");\nvar html_comment_default = {\n  analyze(tag) {\n    (0, import_babel_utils24.assertNoArgs)(tag);\n    (0, import_babel_utils24.assertNoParams)(tag);\n    (0, import_babel_utils24.assertNoAttributes)(tag);\n    const tagVar = tag.node.var;\n    let needsBinding = false;\n    let needsGetter = false;\n    if (tagVar) {\n      if (!import_compiler39.types.isIdentifier(tagVar)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"The `html-comment` tag variable cannot be destructured.\"\n        );\n      }\n      needsBinding = true;\n      for (const ref of tag.scope.getBinding(tagVar.name).referencePaths) {\n        if (!isInvokedFunction(ref)) {\n          needsGetter = true;\n          break;\n        }\n      }\n    }\n    const referenceNodes = [];\n    for (const child of tag.get(\"body\").get(\"body\")) {\n      if (child.isMarkoPlaceholder()) {\n        referenceNodes.push(child.node.value);\n        needsBinding = true;\n      } else if (!child.isMarkoText()) {\n        throw child.buildCodeFrameError(\n          \"Invalid child. Only text is allowed inside an html comment.\"\n        );\n      }\n    }\n    if (needsBinding) {\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      if (needsGetter) {\n        tagExtra[kGetterId2] = getRegisterUID(section, \"comment\");\n      }\n      tagExtra[kCommentTagBinding] = createBinding(\n        \"#comment\",\n        0 /* dom */,\n        section\n      );\n      mergeReferences(section, tag.node, referenceNodes);\n    }\n    tag.skip();\n  },\n  translate: {\n    enter(tag) {\n      const tagExtra = tag.node.extra;\n      const commentBinding = tagExtra[kCommentTagBinding];\n      const hasVar = !!tag.node.var;\n      if (hasVar) {\n        const getterId = tagExtra[kGetterId2];\n        if (isOutputHTML()) {\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(getSection(tag)),\n              getterId && import_compiler39.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);\n            (0, import_compiler39.getProgram)().node.body.push(\n              import_compiler39.types.variableDeclaration(\"const\", [\n                import_compiler39.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler39.types.stringLiteral(getterId),\n                    getScopeAccessorLiteral(commentBinding)\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (isInvokedFunction(reference)) {\n              reference.parentPath.replaceWith(\n                import_compiler39.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, commentBinding)\n                )\n              );\n            } else if (getterFnIdentifier) {\n              reference.replaceWith(\n                import_compiler39.types.callExpression(getterFnIdentifier, [\n                  getScopeExpression(referenceSection, getSection(tag))\n                ])\n              );\n            }\n          }\n        }\n      }\n      if (tagExtra[kCommentTagBinding]) {\n        visit(tag, 32 /* Get */);\n      }\n      enter2(tag);\n      writeTo(tag)`<!--`;\n    },\n    exit(tag) {\n      const tagExtra = tag.node.extra;\n      const commentBinding = tagExtra[kCommentTagBinding];\n      const write2 = writeTo(tag);\n      if (isOutputHTML()) {\n        for (const child of tag.node.body.body) {\n          if (import_compiler39.types.isMarkoText(child)) {\n            write2`${child.value}`;\n          } else if (import_compiler39.types.isMarkoPlaceholder(child)) {\n            write2`${callRuntime(\"escapeXML\", child.value)}`;\n          }\n        }\n      } else {\n        const templateQuasis = [];\n        const templateExpressions = [];\n        let currentQuasi = \"\";\n        for (const child of tag.node.body.body) {\n          if (import_compiler39.types.isMarkoText(child)) {\n            currentQuasi += child.value;\n          } else if (import_compiler39.types.isMarkoPlaceholder(child)) {\n            templateQuasis.push(import_compiler39.types.templateElement({ raw: currentQuasi }));\n            templateExpressions.push(child.value);\n            currentQuasi = \"\";\n          }\n        }\n        if (templateExpressions.length === 0) {\n          write2`${currentQuasi}`;\n        } else {\n          templateQuasis.push(import_compiler39.types.templateElement({ raw: currentQuasi }));\n          addStatement(\n            \"render\",\n            getSection(tag),\n            tagExtra.referencedBindings,\n            import_compiler39.types.expressionStatement(\n              callRuntime(\n                \"data\",\n                import_compiler39.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(commentBinding),\n                  true\n                ),\n                import_compiler39.types.templateLiteral(templateQuasis, templateExpressions)\n              )\n            )\n          );\n        }\n      }\n      exit2(tag);\n      write2`-->`;\n      if (commentBinding) {\n        markNode(tag, commentBinding);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    text: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an html comment that is not stripped from the output.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#html-comment\"\n    }\n  ]\n};\n\n// src/translator/core/html-script.ts\nvar import_compiler40 = require(\"@marko/compiler\");\nvar import_babel_utils25 = require(\"@marko/compiler/babel-utils\");\nvar kGetterId3 = Symbol(\"node getter id\");\nvar html_script_default = {\n  analyze(tag) {\n    (0, import_babel_utils25.assertNoArgs)(tag);\n    (0, import_babel_utils25.assertNoParams)(tag);\n    const { node } = tag;\n    if (node.var && !import_compiler40.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\n        \"Tag variables on native elements cannot be destructured.\"\n      );\n    }\n    const section = getOrCreateSection(tag);\n    let hasEventHandlers = false;\n    let hasDynamicAttributes = false;\n    const seen = {};\n    const { attributes } = tag.node;\n    let spreadReferenceNodes;\n    for (let i = attributes.length; i--; ) {\n      const attr2 = attributes[i];\n      if (import_compiler40.types.isMarkoAttribute(attr2)) {\n        if (seen[attr2.name]) {\n          dropReferences(attr2.value);\n          continue;\n        }\n        seen[attr2.name] = attr2;\n        if (isEventHandler(attr2.name)) {\n          (attr2.value.extra ??= {}).isEffect = true;\n          hasEventHandlers = true;\n        } else if (!evaluate(attr2.value).confident) {\n          hasDynamicAttributes = true;\n        }\n      } else if (import_compiler40.types.isMarkoSpreadAttribute(attr2)) {\n        hasEventHandlers = true;\n        hasDynamicAttributes = true;\n        (attr2.value.extra ??= {}).isEffect = true;\n      }\n      if (spreadReferenceNodes) {\n        spreadReferenceNodes.push(attr2.value);\n      } else if (import_compiler40.types.isMarkoSpreadAttribute(attr2)) {\n        spreadReferenceNodes = [attr2.value];\n      }\n    }\n    if (spreadReferenceNodes) {\n      mergeReferences(section, tag.node, spreadReferenceNodes);\n    }\n    const bodyPlaceholderNodes = [];\n    let hasBodyPlaceholders = false;\n    for (const child of tag.node.body.body) {\n      if (import_compiler40.types.isMarkoPlaceholder(child)) {\n        bodyPlaceholderNodes.push(child.value);\n        hasBodyPlaceholders = true;\n      } else if (!import_compiler40.types.isMarkoText(child)) {\n        throw tag.hub.buildError(\n          child,\n          \"Invalid child. Only text is allowed inside an html-script.\"\n        );\n      }\n    }\n    if (bodyPlaceholderNodes.length > 1) {\n      mergeReferences(\n        section,\n        bodyPlaceholderNodes[0],\n        bodyPlaceholderNodes.slice(1)\n      );\n    }\n    if (node.var || hasEventHandlers || hasDynamicAttributes || hasBodyPlaceholders) {\n      (0, import_compiler40.getProgram)().node.extra.isInteractive ||= hasEventHandlers;\n      const tagExtra = node.extra ??= {};\n      const bindingName = \"#script\";\n      tagExtra[kSerializeMarker] = hasEventHandlers || !!node.var;\n      tagExtra[kNativeTagBinding] = createBinding(\n        bindingName,\n        0 /* dom */,\n        section\n      );\n      if (node.var) {\n        for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n          if (!isInvokedFunction(ref)) {\n            tagExtra[kGetterId3] = getRegisterUID(section, bindingName);\n            break;\n          }\n        }\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagExtra = tag.node.extra;\n      const nodeRef2 = tagExtra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(tag);\n      const section = getSection(tag);\n      const hasVar = !!tag.node.var;\n      if (hasVar) {\n        const getterId = tagExtra[kGetterId3];\n        if (isHTML) {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          for (const reference of references) {\n            serializeOwners(getSection(reference), section);\n          }\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(section),\n              getterId && import_compiler40.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);\n            (0, import_compiler40.getProgram)().node.body.push(\n              import_compiler40.types.variableDeclaration(\"const\", [\n                import_compiler40.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler40.types.stringLiteral(getterId),\n                    getScopeAccessorLiteral(nodeRef2)\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (isInvokedFunction(reference)) {\n              reference.parentPath.replaceWith(\n                import_compiler40.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, nodeRef2)\n                )\n              );\n            } else if (getterFnIdentifier) {\n              reference.replaceWith(\n                import_compiler40.types.callExpression(getterFnIdentifier, [\n                  getScopeExpression(referenceSection, getSection(tag))\n                ])\n              );\n            }\n          }\n        }\n      }\n      let visitAccessor;\n      if (nodeRef2) {\n        visitAccessor = getScopeAccessorLiteral(nodeRef2);\n        visit(tag, 32 /* Get */);\n      }\n      write2`<script`;\n      const usedAttrs = getUsedAttrs2(tag.node);\n      const { staticAttrs, skipExpression, spreadExpression } = usedAttrs;\n      for (const attr2 of staticAttrs) {\n        const { name: name2, value } = attr2;\n        const { confident, computed } = value.extra || {};\n        const valueReferences = value.extra?.referencedBindings;\n        switch (name2) {\n          case \"class\":\n          case \"style\": {\n            const helper = `${name2}Attr`;\n            if (confident) {\n              write2`${getHTMLRuntime()[helper](computed)}`;\n            } else if (isHTML) {\n              write2`${callRuntime(helper, value)}`;\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler40.types.expressionStatement(\n                  callRuntime(\n                    helper,\n                    import_compiler40.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n          }\n          default:\n            if (confident) {\n              write2`${getHTMLRuntime().attr(name2, computed)}`;\n            } else if (isHTML) {\n              if (isEventHandler(name2)) {\n                addHTMLEffectCall(section, valueReferences);\n              } else {\n                write2`${callRuntime(\"attr\", import_compiler40.types.stringLiteral(name2), value)}`;\n              }\n            } else if (isEventHandler(name2)) {\n              addStatement(\n                \"effect\",\n                section,\n                valueReferences,\n                import_compiler40.types.expressionStatement(\n                  callRuntime(\n                    \"on\",\n                    import_compiler40.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler40.types.stringLiteral(getEventHandlerName(name2)),\n                    value\n                  )\n                )\n              );\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler40.types.expressionStatement(\n                  callRuntime(\n                    \"attr\",\n                    import_compiler40.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler40.types.stringLiteral(name2),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n        }\n      }\n      if (spreadExpression) {\n        if (isHTML) {\n          addHTMLEffectCall(section, tagExtra.referencedBindings);\n          if (skipExpression) {\n            write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler40.types.stringLiteral(\"script\"))}`;\n          } else {\n            write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler40.types.stringLiteral(\"script\"))}`;\n          }\n        } else {\n          if (skipExpression) {\n            addStatement(\n              \"render\",\n              section,\n              tagExtra.referencedBindings,\n              import_compiler40.types.expressionStatement(\n                callRuntime(\n                  \"partialAttrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression,\n                  skipExpression\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              tagExtra.referencedBindings,\n              import_compiler40.types.expressionStatement(\n                callRuntime(\n                  \"attrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression\n                )\n              )\n            );\n          }\n          addStatement(\n            \"effect\",\n            section,\n            tagExtra.referencedBindings,\n            import_compiler40.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            false\n          );\n        }\n      }\n      write2`>`;\n      enter2(tag);\n    },\n    exit(tag) {\n      const tagExtra = tag.node.extra;\n      const nodeRef2 = tagExtra[kNativeTagBinding];\n      const write2 = writeTo(tag);\n      const visitAccessor = nodeRef2 && getScopeAccessorLiteral(nodeRef2);\n      if (isOutputHTML()) {\n        for (const child of tag.node.body.body) {\n          if (import_compiler40.types.isMarkoText(child)) {\n            write2`${child.value}`;\n          } else if (import_compiler40.types.isMarkoPlaceholder(child)) {\n            write2`${callRuntime(\"escapeScript\", child.value)}`;\n          }\n        }\n      } else {\n        const templateQuasis = [];\n        const templateExpressions = [];\n        let currentQuasi = \"\";\n        let referencePlaceholder;\n        for (const child of tag.node.body.body) {\n          if (import_compiler40.types.isMarkoText(child)) {\n            currentQuasi += child.value;\n          } else if (import_compiler40.types.isMarkoPlaceholder(child)) {\n            referencePlaceholder ||= child;\n            templateQuasis.push(import_compiler40.types.templateElement({ raw: currentQuasi }));\n            templateExpressions.push(child.value);\n            currentQuasi = \"\";\n          }\n        }\n        if (!referencePlaceholder) {\n          write2`${currentQuasi}`;\n        } else {\n          templateQuasis.push(import_compiler40.types.templateElement({ raw: currentQuasi }));\n          addStatement(\n            \"render\",\n            getSection(tag),\n            referencePlaceholder.value.extra?.referencedBindings,\n            import_compiler40.types.expressionStatement(\n              callRuntime(\n                \"textContent\",\n                import_compiler40.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                import_compiler40.types.templateLiteral(templateQuasis, templateExpressions)\n              )\n            )\n          );\n        }\n      }\n      write2`</script>`;\n      if (nodeRef2) {\n        markNode(tag, nodeRef2);\n      }\n      exit2(tag);\n      tag.remove();\n    }\n  },\n  \"@async\": \"#html-async\",\n  \"@crossorigin\": \"#html-crossorigin\",\n  \"@defer\": \"#html-defer\",\n  \"@integrity\": \"#html-integrity\",\n  \"@nomodule\": \"#html-nomodule\",\n  \"@nonce\": \"#html-nonce\",\n  \"@referrerpolicy\": \"#html-referrerpolicy\",\n  \"@src\": \"#html-src\",\n  \"@type\": \"#html-type\",\n  \"attribute-groups\": [\"html-attributes\"],\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  }\n};\nfunction getUsedAttrs2(tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler40.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n      }\n      spreadProps.push(import_compiler40.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler40.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler40.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    spreadExpression,\n    skipExpression\n  };\n}\n\n// src/translator/core/html-style.ts\nvar import_compiler41 = require(\"@marko/compiler\");\nvar import_babel_utils26 = require(\"@marko/compiler/babel-utils\");\nvar kGetterId4 = Symbol(\"node getter id\");\nvar html_style_default = {\n  analyze(tag) {\n    (0, import_babel_utils26.assertNoArgs)(tag);\n    (0, import_babel_utils26.assertNoParams)(tag);\n    const { node } = tag;\n    if (node.var && !import_compiler41.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\n        \"Tag variables on native elements cannot be destructured.\"\n      );\n    }\n    const section = getOrCreateSection(tag);\n    let hasEventHandlers = false;\n    let hasDynamicAttributes = false;\n    const seen = {};\n    const { attributes } = tag.node;\n    let spreadReferenceNodes;\n    for (let i = attributes.length; i--; ) {\n      const attr2 = attributes[i];\n      if (import_compiler41.types.isMarkoAttribute(attr2)) {\n        if (seen[attr2.name]) {\n          dropReferences(attr2.value);\n          continue;\n        }\n        seen[attr2.name] = attr2;\n        if (isEventHandler(attr2.name)) {\n          (attr2.value.extra ??= {}).isEffect = true;\n          hasEventHandlers = true;\n        } else if (!evaluate(attr2.value).confident) {\n          hasDynamicAttributes = true;\n        }\n      } else if (import_compiler41.types.isMarkoSpreadAttribute(attr2)) {\n        hasEventHandlers = true;\n        hasDynamicAttributes = true;\n        (attr2.value.extra ??= {}).isEffect = true;\n      }\n      if (spreadReferenceNodes) {\n        spreadReferenceNodes.push(attr2.value);\n      } else if (import_compiler41.types.isMarkoSpreadAttribute(attr2)) {\n        spreadReferenceNodes = [attr2.value];\n      }\n    }\n    if (spreadReferenceNodes) {\n      mergeReferences(section, tag.node, spreadReferenceNodes);\n    }\n    const bodyPlaceholderNodes = [];\n    let hasBodyPlaceholders = false;\n    for (const child of tag.node.body.body) {\n      if (import_compiler41.types.isMarkoPlaceholder(child)) {\n        bodyPlaceholderNodes.push(child.value);\n        hasBodyPlaceholders = true;\n      } else if (!import_compiler41.types.isMarkoText(child)) {\n        throw tag.hub.buildError(\n          child,\n          \"Invalid child. Only text is allowed inside an html-style.\"\n        );\n      }\n    }\n    if (bodyPlaceholderNodes.length > 1) {\n      mergeReferences(\n        section,\n        bodyPlaceholderNodes[0],\n        bodyPlaceholderNodes.slice(1)\n      );\n    }\n    if (node.var || hasEventHandlers || hasDynamicAttributes || hasBodyPlaceholders) {\n      (0, import_compiler41.getProgram)().node.extra.isInteractive ||= hasEventHandlers;\n      const tagExtra = node.extra ??= {};\n      const bindingName = \"#style\";\n      tagExtra[kSerializeMarker] = hasEventHandlers || !!node.var;\n      tagExtra[kNativeTagBinding] = createBinding(\n        bindingName,\n        0 /* dom */,\n        section\n      );\n      if (node.var) {\n        for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n          if (!isInvokedFunction(ref)) {\n            tagExtra[kGetterId4] = getRegisterUID(section, bindingName);\n            break;\n          }\n        }\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagExtra = tag.node.extra;\n      const nodeRef2 = tagExtra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(tag);\n      const section = getSection(tag);\n      const hasVar = !!tag.node.var;\n      if (hasVar) {\n        const getterId = tagExtra[kGetterId4];\n        if (isHTML) {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          for (const reference of references) {\n            serializeOwners(getSection(reference), section);\n          }\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(section),\n              getterId && import_compiler41.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);\n            (0, import_compiler41.getProgram)().node.body.push(\n              import_compiler41.types.variableDeclaration(\"const\", [\n                import_compiler41.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler41.types.stringLiteral(getterId),\n                    getScopeAccessorLiteral(nodeRef2)\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (isInvokedFunction(reference)) {\n              reference.parentPath.replaceWith(\n                import_compiler41.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, nodeRef2)\n                )\n              );\n            } else if (getterFnIdentifier) {\n              reference.replaceWith(\n                import_compiler41.types.callExpression(getterFnIdentifier, [\n                  getScopeExpression(referenceSection, getSection(tag))\n                ])\n              );\n            }\n          }\n        }\n      }\n      let visitAccessor;\n      if (nodeRef2) {\n        visitAccessor = getScopeAccessorLiteral(nodeRef2);\n        visit(tag, 32 /* Get */);\n      }\n      write2`<style`;\n      const usedAttrs = getUsedAttrs3(tag.node);\n      const { staticAttrs, skipExpression, spreadExpression } = usedAttrs;\n      for (const attr2 of staticAttrs) {\n        const { name: name2, value } = attr2;\n        const { confident, computed } = value.extra || {};\n        const valueReferences = value.extra?.referencedBindings;\n        switch (name2) {\n          case \"class\":\n          case \"style\": {\n            const helper = `${name2}Attr`;\n            if (confident) {\n              write2`${getHTMLRuntime()[helper](computed)}`;\n            } else if (isHTML) {\n              write2`${callRuntime(helper, value)}`;\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler41.types.expressionStatement(\n                  callRuntime(\n                    helper,\n                    import_compiler41.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n          }\n          default:\n            if (confident) {\n              write2`${getHTMLRuntime().attr(name2, computed)}`;\n            } else if (isHTML) {\n              if (isEventHandler(name2)) {\n                addHTMLEffectCall(section, valueReferences);\n              } else {\n                write2`${callRuntime(\"attr\", import_compiler41.types.stringLiteral(name2), value)}`;\n              }\n            } else if (isEventHandler(name2)) {\n              addStatement(\n                \"effect\",\n                section,\n                valueReferences,\n                import_compiler41.types.expressionStatement(\n                  callRuntime(\n                    \"on\",\n                    import_compiler41.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler41.types.stringLiteral(getEventHandlerName(name2)),\n                    value\n                  )\n                )\n              );\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler41.types.expressionStatement(\n                  callRuntime(\n                    \"attr\",\n                    import_compiler41.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler41.types.stringLiteral(name2),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n        }\n      }\n      if (spreadExpression) {\n        if (isHTML) {\n          addHTMLEffectCall(section, tagExtra.referencedBindings);\n          if (skipExpression) {\n            write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler41.types.stringLiteral(\"style\"))}`;\n          } else {\n            write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler41.types.stringLiteral(\"style\"))}`;\n          }\n        } else {\n          if (skipExpression) {\n            addStatement(\n              \"render\",\n              section,\n              tagExtra.referencedBindings,\n              import_compiler41.types.expressionStatement(\n                callRuntime(\n                  \"partialAttrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression,\n                  skipExpression\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              tagExtra.referencedBindings,\n              import_compiler41.types.expressionStatement(\n                callRuntime(\n                  \"attrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression\n                )\n              )\n            );\n          }\n          addStatement(\n            \"effect\",\n            section,\n            tagExtra.referencedBindings,\n            import_compiler41.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            false\n          );\n        }\n      }\n    },\n    exit(tag) {\n      const tagExtra = tag.node.extra;\n      const nodeRef2 = tagExtra[kNativeTagBinding];\n      const write2 = writeTo(tag);\n      const visitAccessor = nodeRef2 && getScopeAccessorLiteral(nodeRef2);\n      write2`>`;\n      enter2(tag);\n      if (isOutputHTML()) {\n        for (const child of tag.node.body.body) {\n          if (import_compiler41.types.isMarkoText(child)) {\n            write2`${child.value}`;\n          } else if (import_compiler41.types.isMarkoPlaceholder(child)) {\n            write2`${callRuntime(\"escapeStyle\", child.value)}`;\n          }\n        }\n      } else {\n        const templateQuasis = [];\n        const templateExpressions = [];\n        let currentQuasi = \"\";\n        let referencePlaceholder;\n        for (const child of tag.node.body.body) {\n          if (import_compiler41.types.isMarkoText(child)) {\n            currentQuasi += child.value;\n          } else if (import_compiler41.types.isMarkoPlaceholder(child)) {\n            referencePlaceholder ||= child;\n            templateQuasis.push(import_compiler41.types.templateElement({ raw: currentQuasi }));\n            templateExpressions.push(child.value);\n            currentQuasi = \"\";\n          }\n        }\n        if (!referencePlaceholder) {\n          write2`${currentQuasi}`;\n        } else {\n          templateQuasis.push(import_compiler41.types.templateElement({ raw: currentQuasi }));\n          addStatement(\n            \"render\",\n            getSection(tag),\n            referencePlaceholder.value.extra?.referencedBindings,\n            import_compiler41.types.expressionStatement(\n              callRuntime(\n                \"textContent\",\n                import_compiler41.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                import_compiler41.types.templateLiteral(templateQuasis, templateExpressions)\n              )\n            )\n          );\n        }\n      }\n      write2`</style>`;\n      if (nodeRef2) {\n        markNode(tag, nodeRef2);\n      }\n      exit2(tag);\n      tag.remove();\n    }\n  },\n  \"@disabled\": \"#html-disabled\",\n  \"@media\": \"#html-media\",\n  \"@nonce\": \"#html-nonce\",\n  \"@type\": \"#html-type\",\n  \"attribute-groups\": [\"html-attributes\"],\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  }\n};\nfunction getUsedAttrs3(tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler41.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n      }\n      spreadProps.push(import_compiler41.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler41.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler41.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    spreadExpression,\n    skipExpression\n  };\n}\n\n// src/translator/core/id.ts\nvar import_compiler42 = require(\"@marko/compiler\");\nvar import_babel_utils27 = require(\"@marko/compiler/babel-utils\");\nvar id_default = {\n  analyze(tag) {\n    (0, import_babel_utils27.assertNoArgs)(tag);\n    (0, import_babel_utils27.assertNoParams)(tag);\n    (0, import_babel_utils27.assertNoAttributes)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils27.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `id` tag requires a tag variable.\");\n    }\n    if (!import_compiler42.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `id` tag cannot be destructured\");\n    }\n    trackVarReferences(tag, 4 /* derived */);\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const id = isOutputHTML() ? callRuntime(\"nextTagId\") : callRuntime(\"nextTagId\", scopeIdentifier);\n      if (isOutputHTML()) {\n        tag.replaceWith(\n          import_compiler42.types.variableDeclaration(\"const\", [import_compiler42.types.variableDeclarator(node.var, id)])\n        );\n      } else {\n        const source = initValue(node.var.extra.binding);\n        addValue(getSection(tag), void 0, source, id);\n        tag.remove();\n      }\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"id/<name>\",\n      description: \"Use to create a unique identifier.\",\n      snippet: \"id/${1:name}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#id\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/id.d.marko\"\n};\n\n// src/translator/core/if.ts\nvar import_compiler44 = require(\"@marko/compiler\");\nvar import_babel_utils28 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/to-first-statement-or-block.ts\nvar import_compiler43 = require(\"@marko/compiler\");\nfunction toFirstStatementOrBlock(body) {\n  if (Array.isArray(body)) {\n    if (body.length === 1) {\n      return body[0];\n    }\n    return import_compiler43.types.blockStatement(body);\n  }\n  return body;\n}\n\n// src/translator/core/if.ts\nvar BRANCHES_LOOKUP = /* @__PURE__ */ new WeakMap();\nvar IfTag = {\n  analyze(tag) {\n    assertValidCondition(tag);\n    if (tag.node.body.attributeTags) return;\n    const bodySection = startSection(tag.get(\"body\"));\n    const [isLast, branches] = getBranches(tag, bodySection);\n    if (isLast) {\n      const [rootTag] = branches[0];\n      const rootExtra = rootTag.node.extra ??= {};\n      const mergeReferenceNodes = [];\n      let singleNodeOptimization = true;\n      for (const [branchTag, branchBodySection] of branches) {\n        if (branchBodySection) {\n          branchBodySection.isBranch = true;\n          branchBodySection.upstreamExpression = rootExtra;\n          if (!(branchBodySection.content === null || branchBodySection.content?.singleChild && branchBodySection.content.startType !== 4 /* Text */)) {\n            singleNodeOptimization = false;\n          }\n        }\n        if (branchTag.node.attributes.length) {\n          mergeReferenceNodes.push(branchTag.node.attributes[0].value);\n        }\n      }\n      const section = getOrCreateSection(tag);\n      mergeReferences(section, rootTag.node, mergeReferenceNodes);\n      bodySection.sectionAccessor = {\n        binding: getOptimizedOnlyChildNodeRef(\n          rootTag,\n          section,\n          branches.length\n        ),\n        prefix: getAccessorPrefix().ConditionalScope\n      };\n      rootExtra.singleNodeOptimization = singleNodeOptimization;\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (isRoot(tag) && !isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n        flushBefore(tag);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const [isLast, branches] = getBranches(tag, bodySection);\n        const [rootTag] = branches[0];\n        const rootExtra = rootTag.node.extra;\n        const singleNodeOptimization = rootExtra.singleNodeOptimization;\n        const branchSources = getSourcesForBranches(branches);\n        const hasHoists = hasHoistsInBranches(branches);\n        const serializeReason = hasHoists || branchSources?.all;\n        if (bodySection) {\n          flushInto(tag);\n          writeHTMLResumeStatements(tagBody);\n        }\n        if (isLast) {\n          const nodeRef2 = getOptimizedOnlyChildNodeRef(rootTag, section);\n          const onlyChildInParentOptimization = isOnlyChildInParent(rootTag);\n          const nextTag = tag.getNextSibling();\n          let statement;\n          if (branchSources?.referenced && onlyChildInParentOptimization) {\n            getParentTag(rootTag).node.extra[kSerializeMarker] = false;\n          }\n          for (let i = branches.length; i--; ) {\n            const [branchTag] = branches[i];\n            const bodyStatements = branchTag.node.body.body;\n            if (serializeReason) {\n              bodyStatements.push(\n                import_compiler44.types.returnStatement(import_compiler44.types.numericLiteral(i))\n              );\n            }\n            const [testAttr] = branchTag.node.attributes;\n            const curStatement = toFirstStatementOrBlock(bodyStatements);\n            if (testAttr) {\n              statement = import_compiler44.types.ifStatement(\n                testAttr.value,\n                curStatement,\n                statement\n              );\n            } else {\n              statement = curStatement;\n            }\n            branchTag.remove();\n          }\n          if (serializeReason) {\n            const conditionSerializeReason = branchSources?.referenced;\n            const cbNode = import_compiler44.types.arrowFunctionExpression(\n              [],\n              import_compiler44.types.blockStatement([statement])\n            );\n            statement = import_compiler44.types.expressionStatement(\n              singleNodeOptimization ? callRuntime(\n                \"resumeSingleNodeConditional\",\n                cbNode,\n                getScopeIdIdentifier(section),\n                getScopeAccessorLiteral(nodeRef2),\n                conditionSerializeReason ? import_compiler44.types.numericLiteral(1) : onlyChildInParentOptimization ? import_compiler44.types.numericLiteral(0) : void 0,\n                onlyChildInParentOptimization && import_compiler44.types.numericLiteral(1)\n              ) : callRuntime(\n                \"resumeConditional\",\n                cbNode,\n                getScopeIdIdentifier(section),\n                getScopeAccessorLiteral(nodeRef2),\n                conditionSerializeReason ? import_compiler44.types.numericLiteral(1) : void 0\n              )\n            );\n          }\n          nextTag.insertBefore(statement);\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n        }\n        if (isRoot(tag) && !isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const [isLast, branches] = getBranches(\n          tag,\n          getSectionForBody(tag.get(\"body\"))\n        );\n        if (isLast) {\n          const [rootTag] = branches[0];\n          const section = getSection(rootTag);\n          const rootExtra = branches[0][0].node.extra;\n          const nodeRef2 = getOptimizedOnlyChildNodeRef(rootTag, section);\n          const rendererIdentifiers = [];\n          let expr = import_compiler44.types.numericLiteral(branches.length);\n          for (let i = branches.length; i--; ) {\n            const [branchTag, branchBodySection] = branches[i];\n            const [testAttr] = branchTag.node.attributes;\n            const consequent = import_compiler44.types.numericLiteral(branchBodySection ? i : -1);\n            if (branchBodySection) {\n              rendererIdentifiers.push(import_compiler44.types.identifier(branchBodySection.name));\n              setClosureSignalBuilder(branchTag, (closure, render) => {\n                return callRuntime(\n                  \"conditionalClosure\",\n                  getScopeAccessorLiteral(closure),\n                  getScopeAccessorLiteral(nodeRef2),\n                  import_compiler44.types.numericLiteral(i),\n                  render\n                );\n              });\n            }\n            branchTag.remove();\n            expr = testAttr ? import_compiler44.types.conditionalExpression(testAttr.value, consequent, expr) : consequent;\n          }\n          const signal = getSignal(section, nodeRef2, \"if\");\n          signal.build = () => {\n            return callRuntime(\n              \"conditional\",\n              getScopeAccessorLiteral(nodeRef2),\n              ...rendererIdentifiers.reverse()\n            );\n          };\n          addValue(section, rootExtra.referencedBindings, signal, expr);\n        }\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  autocomplete: [\n    {\n      snippet: \"if=${1:condition}\",\n      description: \"Use to display content only if the condition is met.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseIfTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      snippet: \"else-if=${1:condition}\",\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nfunction assertValidCondition(tag) {\n  (0, import_babel_utils28.assertNoVar)(tag);\n  (0, import_babel_utils28.assertNoArgs)(tag);\n  (0, import_babel_utils28.assertNoParams)(tag);\n  assertHasBody(tag);\n  assertNoSpreadAttrs(tag);\n  switch (getTagName(tag)) {\n    case \"if\":\n      assertHasValueAttribute(tag);\n      break;\n    case \"else-if\":\n      assertHasValueAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n    case \"else\":\n      assertOptionalIfAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n  }\n}\nfunction assertHasPrecedingCondition(tag) {\n  let prev = tag.getPrevSibling();\n  while (prev.node && prev.isMarkoComment()) prev = prev.getPrevSibling();\n  if (!isConditionTag(prev) || getTagName(prev) !== \"else\" && !prev.node.attributes.length) {\n    throw tag.buildCodeFrameError(\n      `The \\`<${getTagName(tag)}>\\` must have a preceding \\`<if=cond>\\`, \\`<else-if=cond>\\`, or \\`<else if=cond>\\`.`\n    );\n  }\n}\nfunction assertHasBody(tag) {\n  if (!(tag.node.body.body.length || tag.node.attributeTags.length)) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${getTagName(tag)}\\` tag requires body content.`\n    );\n  }\n}\nfunction assertHasValueAttribute(tag) {\n  const { node } = tag;\n  const [valueAttr] = node.attributes;\n  if (!import_compiler44.types.isMarkoAttribute(valueAttr) || !valueAttr.default) {\n    throw tag.get(\"name\").buildCodeFrameError(`The \\`${getTagName(tag)}\\` tag requires a value.`);\n  }\n  if (node.attributes.length > 1) {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports the \\`value\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction assertOptionalIfAttribute(tag) {\n  const { node } = tag;\n  const [ifAttr] = node.attributes;\n  if (node.attributes.length > 1 || ifAttr && ifAttr.name !== \"if\") {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports an \\`if=\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction getBranches(tag, bodySection) {\n  const branches = BRANCHES_LOOKUP.get(tag) ?? [];\n  let nextTag = tag.getNextSibling();\n  while (nextTag.isMarkoComment()) nextTag = nextTag.getNextSibling();\n  const isLast = !(isCoreTagName(nextTag, \"else\") || isCoreTagName(nextTag, \"else-if\"));\n  branches.push([tag, bodySection]);\n  if (!isLast) {\n    BRANCHES_LOOKUP.set(nextTag, branches);\n  }\n  return [isLast, branches];\n}\nfunction hasHoistsInBranches(branches) {\n  for (const [, section] of branches) {\n    if (section && isSectionWithHoists(section)) return true;\n  }\n}\nfunction getSourcesForBranches(branches) {\n  if (branches.length === 1) {\n    return getDynamicSourcesForSection(branches[0][1]);\n  }\n  const branchSections = [];\n  for (const [, branchSection] of branches) {\n    branchSections.push(branchSection);\n  }\n  return getDynamicSourcesForSections(branchSections);\n}\nfunction isRoot(tag) {\n  return isCoreTagName(tag, \"if\");\n}\n\n// src/translator/core/import.ts\nvar import_babel_utils29 = require(\"@marko/compiler/babel-utils\");\nvar import_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils29.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: 'import <scope> from \"<path>\"',\n      description: \"Use to import external modules, follows the same syntax as JavaScript imports.\",\n      snippet: 'import ${2} from \"${1:path}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#importing-external-files\"\n    }\n  ]\n};\n\n// src/translator/core/let.ts\nvar import_compiler45 = require(\"@marko/compiler\");\nvar import_babel_utils30 = require(\"@marko/compiler/babel-utils\");\nvar let_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    let valueAttr;\n    let valueChangeAttr;\n    for (const attr2 of node.attributes) {\n      if (import_compiler45.types.isMarkoAttribute(attr2)) {\n        if (attr2.name === \"value\") {\n          valueAttr = attr2;\n        } else if (attr2.name === \"valueChange\") {\n          valueChangeAttr = attr2;\n        } else {\n          const start = attr2.loc?.start;\n          const end = attr2.loc?.end;\n          const msg = \"The `let` tag only supports the `value` attribute and its change handler.\";\n          if (start == null || end == null) {\n            throw tag.get(\"name\").buildCodeFrameError(msg);\n          } else {\n            throw tag.hub.buildError(\n              { loc: { start, end } },\n              msg,\n              Error\n            );\n          }\n        }\n      }\n    }\n    (0, import_babel_utils30.assertNoArgs)(tag);\n    (0, import_babel_utils30.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    if (!tagVar) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `let` tag requires a tag variable.\");\n    }\n    if (!import_compiler45.types.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `let` tag variable cannot be destructured.\");\n    }\n    if (valueChangeAttr && (0, import_babel_utils30.computeNode)(valueChangeAttr.value)) {\n      throw tag.get(\"attributes\").find((attr2) => attr2.node === valueChangeAttr).get(\"value\").buildCodeFrameError(\n        \"The `let` tag `valueChange` attribute must be a function.\"\n      );\n    }\n    mergeReferences(getOrCreateSection(tag), tag.node, [\n      valueAttr?.value,\n      valueChangeAttr?.value\n    ]);\n    trackVarReferences(tag, 1 /* let */, void 0, tag.node.extra);\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const tagVar = node.var;\n      const valueAttr = node.attributes.find(\n        (attr2) => import_compiler45.types.isMarkoAttribute(attr2) && (attr2.default || attr2.name === \"value\")\n      ) ?? import_compiler45.types.markoAttribute(\"value\", import_compiler45.types.identifier(\"undefined\"));\n      const valueChangeAttr = node.attributes.find(\n        (attr2) => import_compiler45.types.isMarkoAttribute(attr2) && attr2.name === \"valueChange\"\n      );\n      const section = getSection(tag);\n      const binding = tagVar.extra.binding;\n      if (isOutputDOM()) {\n        const signal = initValue(binding, \"state\");\n        const referencedBindings = tag.node.extra.referencedBindings;\n        addValue(section, referencedBindings, signal, valueAttr.value);\n        if (valueChangeAttr) {\n          signal.extraArgs = [valueChangeAttr.value];\n        }\n        signal.buildAssignment = (valueSection, value) => {\n          const scope = getScopeExpression(valueSection, signal.section);\n          return import_compiler45.types.callExpression(signal.identifier, [scope, value]);\n        };\n      } else {\n        translateVar(tag, valueAttr.value, \"let\");\n        if (valueChangeAttr) {\n          setSerializedProperty(\n            section,\n            getAccessorPrefix().TagVariableChange + getScopeAccessor(binding),\n            valueChangeAttr.value,\n            true\n            // TODO: could be based on if there are actually assignments.\n          );\n        }\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a mutable binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#let\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/let.d.marko\"\n};\n\n// src/translator/core/lifecycle.ts\nvar import_compiler46 = require(\"@marko/compiler\");\nvar import_babel_utils31 = require(\"@marko/compiler/babel-utils\");\nvar kRef = Symbol(\"lifecycle attrs reference\");\nvar lifecycle_default = {\n  analyze(tag) {\n    (0, import_babel_utils31.assertNoArgs)(tag);\n    (0, import_babel_utils31.assertNoVar)(tag);\n    (0, import_babel_utils31.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const tagExtra = node.extra ??= {};\n    const section = getOrCreateSection(tag);\n    tagExtra[kRef] = createBinding(\n      generateUid(\"lifecycle\"),\n      4 /* derived */,\n      section,\n      void 0,\n      tagExtra\n    );\n    if (node.attributes.length === 0) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `lifecycle` tag requires at least one attribute.\"\n      );\n    }\n    for (const attr2 of node.attributes) {\n      if (import_compiler46.types.isMarkoSpreadAttribute(attr2)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The `lifecycle` tag does not support `...spread` attributes.\"\n        );\n      }\n      (attr2.value.extra ??= {}).isEffect = true;\n    }\n    ((0, import_compiler46.getProgram)().node.extra ??= {}).isInteractive = true;\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const section = getSection(tag);\n      const tagExtra = node.extra;\n      const { referencedBindings } = tagExtra;\n      const lifecycleAttrsRef = tagExtra[kRef];\n      if (isOutputDOM()) {\n        const translatedAttrs = translateAttrs(tag);\n        translatedAttrs.statements.push(\n          import_compiler46.types.expressionStatement(\n            callRuntime(\n              \"lifecycle\",\n              scopeIdentifier,\n              getScopeAccessorLiteral(lifecycleAttrsRef),\n              propsToExpression(translatedAttrs.properties)\n            )\n          )\n        );\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          translatedAttrs.statements\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/lifecycle.d.marko\"\n};\n\n// src/translator/core/log.ts\nvar import_compiler47 = require(\"@marko/compiler\");\nvar import_babel_utils32 = require(\"@marko/compiler/babel-utils\");\nvar log_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils32.assertNoArgs)(tag);\n    (0, import_babel_utils32.assertNoVar)(tag);\n    (0, import_babel_utils32.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `log` tag requires a value.\");\n    }\n    if (tag.node.attributes.length > 1 || !import_compiler47.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `log` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      const statement = import_compiler47.types.expressionStatement(\n        import_compiler47.types.callExpression(\n          import_compiler47.types.memberExpression(import_compiler47.types.identifier(\"console\"), import_compiler47.types.identifier(\"log\")),\n          [value]\n        )\n      );\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to log a value to the console.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#log\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/log.d.marko\"\n};\n\n// src/translator/core/script.ts\nvar import_compiler48 = require(\"@marko/compiler\");\nvar import_babel_utils33 = require(\"@marko/compiler/babel-utils\");\nvar htmlScriptTagAlternateMsg = \" For a native html `script` tag use the `html-script` core tag instead.\";\nvar script_default = {\n  parse(tag) {\n    const { node } = tag;\n    const { body } = node.body;\n    if (body.length) {\n      let code = \"\";\n      for (const child of body) {\n        if (child.type !== \"MarkoText\") {\n          throw tag.hub.file.hub.buildError(\n            child,\n            \"Unexpected content in `script` tag. Only javascript and typescript is supported.\" + htmlScriptTagAlternateMsg,\n            SyntaxError\n          );\n        }\n        code += child.value;\n      }\n      const start = body[0]?.start;\n      const end = body[body.length - 1]?.end;\n      const bodyStatements = (0, import_babel_utils33.parseStatements)(tag.hub.file, code, start, end);\n      const valueFn = import_compiler48.types.arrowFunctionExpression(\n        [],\n        import_compiler48.types.blockStatement(bodyStatements),\n        traverseContains(bodyStatements, isAwaitExpression)\n      );\n      node.attributes.push(import_compiler48.types.markoAttribute(\"value\", valueFn));\n      node.body.body = [];\n    }\n  },\n  analyze(tag) {\n    const { node } = tag;\n    (0, import_babel_utils33.assertNoArgs)(tag);\n    (0, import_babel_utils33.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils33.assertNoAttributeTags)(tag);\n    if (node.var) {\n      throw tag.hub.buildError(\n        node.var,\n        \"The `script` tag does not support a tag variable reference.\" + htmlScriptTagAlternateMsg\n      );\n    }\n    let seenValueAttr = false;\n    for (const attr2 of node.attributes) {\n      if (attr2.type === \"MarkoAttribute\" && attr2.name === \"value\") {\n        if (seenValueAttr) {\n          throw tag.hub.buildError(attr2, \"Invalid duplicate value attribute.\");\n        }\n        seenValueAttr = true;\n        (attr2.value.extra ??= {}).isEffect = true;\n        ((0, import_compiler48.getProgram)().node.extra ??= {}).isInteractive = true;\n      } else {\n        throw tag.hub.buildError(\n          attr2,\n          \"The `script` tag does not support html attributes.\" + htmlScriptTagAlternateMsg\n        );\n      }\n    }\n    if (!seenValueAttr) {\n      dropReferences(getAllTagReferenceNodes(node));\n    }\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      if (!valueAttr) {\n        tag.remove();\n        return;\n      }\n      const section = getSection(tag);\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      if (isOutputDOM()) {\n        const { value: value2 } = valueAttr;\n        const isFunction2 = import_compiler48.types.isFunctionExpression(value2) || import_compiler48.types.isArrowFunctionExpression(value2);\n        let inlineBody = null;\n        if (isFunction2 && !(value2.async || value2.generator)) {\n          if (import_compiler48.types.isBlockStatement(value2.body)) {\n            let hasDeclaration = false;\n            for (const child of value2.body.body) {\n              if (import_compiler48.types.isDeclaration(child)) {\n                hasDeclaration = true;\n                break;\n              }\n            }\n            inlineBody = hasDeclaration ? value2.body : value2.body.body;\n          } else {\n            inlineBody = import_compiler48.types.expressionStatement(value2.body);\n          }\n        }\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          inlineBody || import_compiler48.types.expressionStatement(\n            import_compiler48.types.callExpression(value2, isFunction2 ? [] : [scopeIdentifier])\n          )\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  html: false,\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#script\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/script.d.marko\"\n};\nfunction isAwaitExpression(node) {\n  switch (node.type) {\n    case \"ForOfStatement\":\n      return node.await;\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ObjectMethod\":\n    case \"ClassPrivateMethod\":\n      return skip;\n    case \"AwaitExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// src/translator/core/server.ts\nvar import_compiler49 = require(\"@marko/compiler\");\nvar import_babel_utils34 = require(\"@marko/compiler/babel-utils\");\nvar server_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^server\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils34.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler49.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler49.types.markoScriptlet(body, true, \"server\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"server <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the server.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#server-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/static.ts\nvar import_compiler50 = require(\"@marko/compiler\");\nvar import_babel_utils35 = require(\"@marko/compiler/babel-utils\");\nvar static_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^static\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils35.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler50.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler50.types.markoScriptlet(body, true));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"static <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#static-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/style.ts\nvar import_compiler51 = require(\"@marko/compiler\");\nvar import_babel_utils36 = require(\"@marko/compiler/babel-utils\");\nvar import_magic_string = __toESM(require(\"magic-string\"));\nvar import_path3 = __toESM(require(\"path\"));\nvar STYLE_EXT_REG = /^style((?:\\.[a-zA-Z0-9$_-]+)+)?/;\nvar htmlStyleTagAlternateMsg = \" For a native html `style` tag use the `html-style` core tag instead.\";\nvar style_default = {\n  analyze(tag) {\n    (0, import_babel_utils36.assertNoArgs)(tag);\n    (0, import_babel_utils36.assertNoParams)(tag);\n    (0, import_babel_utils36.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    const ext = STYLE_EXT_REG.exec(node.rawValue || \"\")?.[1]?.slice(1);\n    for (const attr2 of node.attributes) {\n      if (attr2.start == null && attr2.type === \"MarkoAttribute\" && attr2.name === \"class\" && attr2.value.type === \"StringLiteral\" && attr2.value.value === ext) {\n        continue;\n      }\n      throw tag.hub.buildError(\n        attr2.value,\n        \"The `style` does not support html attributes.\" + htmlStyleTagAlternateMsg\n      );\n    }\n    for (const child of node.body.body) {\n      if (child.type !== \"MarkoText\") {\n        throw tag.hub.buildError(\n          child,\n          \"The `style` tag currently only supports static content.\" + htmlStyleTagAlternateMsg\n        );\n      }\n    }\n    if (node.body.body.length > 1) {\n      throw tag.hub.buildError(\n        node.name,\n        \"The `style` tag currently only supports static content.\" + htmlStyleTagAlternateMsg\n      );\n    }\n  },\n  translate(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const { filename, sourceMaps } = file.opts;\n    let ext = STYLE_EXT_REG.exec(node.rawValue || \"\")?.[1] || \".css\";\n    if (node.var && !/\\.module\\./.test(ext)) {\n      ext = \".module\" + ext;\n    }\n    const markoText = node.body.body[0];\n    const { resolveVirtualDependency } = getMarkoOpts();\n    const start = (0, import_babel_utils36.getStart)(file, markoText);\n    const end = (0, import_babel_utils36.getEnd)(file, markoText);\n    let code = markoText.value;\n    let map2;\n    if (resolveVirtualDependency && sourceMaps && start !== null && end !== null) {\n      const magicString = new import_magic_string.default(file.code, { filename });\n      magicString.remove(0, start);\n      magicString.remove(end, file.code.length);\n      map2 = magicString.generateMap({\n        source: filename,\n        includeContent: true\n      });\n      if (sourceMaps === \"inline\" || sourceMaps === \"both\") {\n        code += `\n/*# sourceMappingURL=${map2.toUrl()}*/`;\n        if (sourceMaps === \"inline\") {\n          map2 = void 0;\n        }\n      }\n    }\n    const importPath = resolveVirtualDependency?.(filename, {\n      virtualPath: `./${import_path3.default.basename(filename) + ext}`,\n      code,\n      map: map2\n    });\n    if (importPath) {\n      if (!node.var) {\n        (0, import_compiler51.getProgram)().node.body.push(\n          import_compiler51.types.importDeclaration([], import_compiler51.types.stringLiteral(importPath))\n        );\n      } else if (import_compiler51.types.isIdentifier(node.var)) {\n        (0, import_compiler51.getProgram)().node.body.push(\n          import_compiler51.types.importDeclaration(\n            [import_compiler51.types.importDefaultSpecifier(node.var)],\n            import_compiler51.types.stringLiteral(importPath)\n          )\n        );\n      } else {\n        (0, import_compiler51.getProgram)().node.body.push(\n          import_compiler51.types.variableDeclaration(\"const\", [\n            import_compiler51.types.variableDeclarator(\n              node.var,\n              (0, import_babel_utils36.importDefault)(file, importPath, \"style\")\n            )\n          ])\n        );\n      }\n    }\n    tag.remove();\n  },\n  parseOptions: {\n    html: false,\n    text: true,\n    rawOpenTag: true,\n    preserveWhitespace: true\n  },\n  attributes: {}\n};\n\n// src/translator/core/try.ts\nvar import_compiler52 = require(\"@marko/compiler\");\nvar import_babel_utils37 = require(\"@marko/compiler/babel-utils\");\nvar kDOMBinding2 = Symbol(\"try tag dom binding\");\nvar try_default = {\n  analyze(tag) {\n    (0, import_babel_utils37.assertNoVar)(tag);\n    (0, import_babel_utils37.assertNoArgs)(tag);\n    (0, import_babel_utils37.assertNoParams)(tag);\n    (0, import_babel_utils37.assertNoAttributes)(tag);\n    assertNoSpreadAttrs(tag);\n    analyzeAttributeTags(tag);\n    const { node } = tag;\n    const section = getOrCreateSection(tag);\n    const tagExtra = tag.node.extra ??= {};\n    const tagBody = tag.get(\"body\");\n    tagExtra[kDOMBinding2] = createBinding(\n      \"#text\",\n      0 /* dom */,\n      section,\n      void 0,\n      tagExtra\n    );\n    if (!node.body.body.length) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `try` tag requires body content.\");\n    }\n    startSection(tagBody);\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (!getSectionForBody(tag.get(\"body\"))) {\n          tag.remove();\n          return;\n        }\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        setSectionParentIsOwner(bodySection, true);\n        flushBefore(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const section = getSection(tag);\n        const tagExtra = node.extra;\n        const tagBody = tag.get(\"body\");\n        const translatedAttrs = translateAttrs(tag);\n        const nodeRef2 = tagExtra[kDOMBinding2];\n        const contentProp = getTranslatedBodyContentProperty(\n          translatedAttrs.properties\n        );\n        if (contentProp) {\n          translatedAttrs.properties.splice(\n            translatedAttrs.properties.indexOf(contentProp),\n            1\n          );\n        }\n        flushInto(tag);\n        writeHTMLResumeStatements(tagBody);\n        tag.insertBefore(translatedAttrs.statements);\n        tag.replaceWith(\n          import_compiler52.types.expressionStatement(\n            callRuntime(\n              \"tryContent\",\n              getScopeIdIdentifier(section),\n              getScopeAccessorLiteral(nodeRef2),\n              contentProp?.value,\n              propsToExpression(translatedAttrs.properties)\n            )\n          )\n        )[0].skip();\n      }\n    },\n    dom: {\n      enter(tag) {\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        setSectionParentIsOwner(bodySection, true);\n        visit(tag, 37 /* Replace */);\n        enterShallow(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const nodeRef2 = tagExtra[kDOMBinding2];\n        const referencedBindings = tagExtra.referencedBindings;\n        const translatedAttrs = translateAttrs(tag);\n        const contentProp = getTranslatedBodyContentProperty(\n          translatedAttrs.properties\n        );\n        if (contentProp) {\n          translatedAttrs.properties.splice(\n            translatedAttrs.properties.indexOf(contentProp),\n            1\n          );\n        }\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tag.get(\"body\"));\n        const signal = getSignal(section, nodeRef2, \"try\");\n        signal.build = () => {\n          return callRuntime(\n            \"createTry\",\n            getScopeAccessorLiteral(nodeRef2),\n            import_compiler52.types.identifier(bodySection.name)\n          );\n        };\n        if (translatedAttrs.statements.length) {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            translatedAttrs.statements\n          );\n        }\n        (0, import_compiler52.getProgram)().node.body.push(\n          import_compiler52.types.expressionStatement(callRuntime(\"enableCatch\"))\n        );\n        addValue(\n          section,\n          referencedBindings,\n          signal,\n          propsToExpression(translatedAttrs.properties)\n        );\n        signal.hasDownstreamIntersections = () => true;\n        tag.remove();\n      }\n    }\n  }),\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Used to capture errors and display placeholders for nested content.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#try\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/try.d.marko\"\n};\n\n// src/translator/core/index.ts\nvar core_default = {\n  taglibId: runtime_info_default.taglibId,\n  \"<attrs>\": attrs_default,\n  \"<await>\": await_default,\n  \"<client>\": client_default,\n  \"<const>\": const_default,\n  \"<debug>\": debug_default,\n  \"<define>\": define_default,\n  \"<effect>\": effect_default,\n  \"<else-if>\": ElseIfTag,\n  \"<else>\": ElseTag,\n  \"<export>\": export_default,\n  \"<for>\": for_default,\n  \"<html-comment>\": html_comment_default,\n  \"<html-script>\": html_script_default,\n  \"<html-style>\": html_style_default,\n  \"<id>\": id_default,\n  \"<if>\": IfTag,\n  \"<import>\": import_default,\n  \"<let>\": let_default,\n  \"<lifecycle>\": lifecycle_default,\n  \"<log>\": log_default,\n  \"<return>\": return_default,\n  \"<script>\": script_default,\n  \"<server>\": server_default,\n  \"<static>\": static_default,\n  \"<style>\": style_default,\n  \"<try>\": try_default\n};\n\n// src/translator/visitors/cdata.ts\nvar cdata_default = {\n  translate: {\n    enter(cdata) {\n      throw cdata.buildCodeFrameError(\n        \"CDATA sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/translator/visitors/comment.ts\nvar comment_default = {\n  translate: {\n    exit(comment) {\n      comment.remove();\n    }\n  }\n};\n\n// src/translator/visitors/declaration.ts\nvar declaration_default = {\n  translate: {\n    enter(decl) {\n      throw decl.buildCodeFrameError(\n        \"XML declarations sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/translator/visitors/document-type.ts\nvar document_type_default = {\n  translate: {\n    exit(documentType) {\n      if (isOutputHTML()) {\n        writeTo(documentType)`<!${documentType.node.value}>`;\n      }\n      documentType.remove();\n    }\n  }\n};\n\n// src/translator/visitors/function.ts\nvar import_compiler53 = require(\"@marko/compiler\");\nvar import_babel_utils38 = require(\"@marko/compiler/babel-utils\");\nvar functionIdsBySection = /* @__PURE__ */ new WeakMap();\nvar function_default = {\n  analyze(fn) {\n    if (fn !== getFnRoot(fn)) {\n      return;\n    }\n    const markoRoot = getMarkoRoot(fn);\n    if (markoRoot && (markoRoot.isMarkoPlaceholder() || markoRoot.isMarkoScriptlet() && markoRoot.node.target === \"server\")) {\n      return;\n    }\n    if (isMarkoAttribute(markoRoot) && ((0, import_babel_utils38.isNativeTag)(markoRoot.parentPath) && /^on[A-Z-]/.test(markoRoot.node.name) || isCoreTagName(markoRoot.parentPath, \"script\") || isCoreTagName(markoRoot.parentPath, \"lifecycle\") || isCoreTagName(markoRoot.parentPath, \"for\"))) {\n      return;\n    }\n    const { node } = fn;\n    const extra = node.extra ??= {};\n    const name2 = extra.name = fn.node.id?.name || (isMarkoAttribute(markoRoot) ? markoRoot.node.default ? import_compiler53.types.toIdentifier(\n      markoRoot.parentPath.has(\"var\") ? markoRoot.parentPath.get(\"var\") : markoRoot.parentPath.get(\"name\")\n    ) : markoRoot.node.name : import_compiler53.types.isVariableDeclarator(fn.parent) && import_compiler53.types.isIdentifier(fn.parent.id) ? fn.parent.id.name : import_compiler53.types.isObjectMethod(node) && import_compiler53.types.isIdentifier(node.key) ? node.key.name : \"anonymous\");\n    const {\n      markoOpts,\n      opts: { filename }\n    } = (0, import_compiler53.getFile)();\n    const section = getSection(fn);\n    let functionNameCounts = functionIdsBySection.get(section);\n    if (!functionNameCounts) {\n      functionNameCounts = /* @__PURE__ */ new Map();\n      functionIdsBySection.set(section, functionNameCounts);\n    }\n    const index = functionNameCounts.get(name2);\n    let id = \"\";\n    if (index === void 0) {\n      functionNameCounts.set(name2, 0);\n    } else {\n      functionNameCounts.set(name2, index + 1);\n      id = `_${index}`;\n    }\n    extra.section = section;\n    extra.registerId = (0, import_babel_utils38.getTemplateId)(\n      markoOpts,\n      filename,\n      `${section.id}/${name2 + id}`\n    );\n  }\n};\nfunction isMarkoAttribute(path5) {\n  return path5 ? path5.isMarkoAttribute() : false;\n}\n\n// src/translator/visitors/import-declaration.ts\nvar import_babel_utils39 = require(\"@marko/compiler/babel-utils\");\nvar import_declaration_default = {\n  analyze(importDecl) {\n    const { node } = importDecl;\n    const { source } = node;\n    const { value } = source;\n    const tagImport = (0, import_babel_utils39.resolveTagImport)(importDecl, value);\n    if (tagImport) {\n      node.extra ??= {};\n      node.extra.tagImport = tagImport;\n      const tags = importDecl.hub.file.metadata.marko.tags;\n      if (!tags.includes(tagImport)) {\n        tags.push(tagImport);\n      }\n    }\n  },\n  translate: {\n    exit(importDecl) {\n      const { node } = importDecl;\n      const { extra } = node;\n      const tagImport = extra?.tagImport;\n      if (tagImport) {\n        node.source.value = tagImport;\n      }\n    }\n  }\n};\n\n// src/translator/visitors/placeholder.ts\nvar import_compiler55 = require(\"@marko/compiler\");\n\n// src/translator/util/is-non-html-text.ts\nvar import_compiler54 = require(\"@marko/compiler\");\nfunction isNonHTMLText(placeholder) {\n  const parentTag = placeholder.parentPath.isMarkoTagBody() && placeholder.parentPath.parentPath;\n  if (parentTag && isCoreTag(parentTag)) {\n    switch (parentTag.node.name.value) {\n      case \"html-comment\":\n      case \"html-script\":\n      case \"html-style\":\n        return true;\n    }\n  }\n  return false;\n}\n\n// src/translator/visitors/placeholder.ts\nvar kBinding = Symbol(\"placeholder node binding\");\nvar kSiblingText = Symbol(\"placeholder has sibling text\");\nvar placeholder_default = {\n  analyze(placeholder) {\n    if (isNonHTMLText(placeholder)) return;\n    const { node } = placeholder;\n    const { confident, computed } = evaluate(node.value);\n    if (!(confident && (node.escape || isVoid2(computed)))) {\n      (node.extra ??= {})[kBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        getOrCreateSection(placeholder),\n        void 0,\n        node.value.extra\n      );\n      analyzeSiblingText(placeholder);\n    }\n  },\n  translate: {\n    exit(placeholder) {\n      if (isNonHTMLText(placeholder)) return;\n      const { node } = placeholder;\n      const { value } = node;\n      const valueExtra = evaluate(value);\n      const { confident, computed } = valueExtra;\n      if (confident && isVoid2(computed)) {\n        placeholder.remove();\n        return;\n      }\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(placeholder);\n      const extra = node.extra || {};\n      const nodeBinding = extra[kBinding];\n      const canWriteHTML = isHTML || confident && node.escape;\n      const method = canWriteHTML ? node.escape ? \"escapeXML\" : \"toString\" : node.escape ? \"data\" : \"html\";\n      const serializeReason = getDynamicSourcesForExtra(valueExtra);\n      const siblingText = extra[kSiblingText];\n      if (confident && canWriteHTML) {\n        write2`${getHTMLRuntime()[method](computed)}`;\n      } else {\n        if (siblingText === 1 /* Before */) {\n          if (isHTML && serializeReason) {\n            write2`<!>`;\n          }\n          visit(placeholder, 37 /* Replace */);\n        } else if (siblingText === 2 /* After */) {\n          visit(placeholder, 37 /* Replace */);\n        } else {\n          if (!isHTML) write2` `;\n          visit(placeholder, 32 /* Get */);\n        }\n        if (isHTML) {\n          write2`${callRuntime(method, value)}`;\n          if (serializeReason) {\n            markNode(placeholder, nodeBinding);\n          }\n        } else {\n          addStatement(\n            \"render\",\n            getSection(placeholder),\n            valueExtra.referencedBindings,\n            import_compiler55.types.expressionStatement(\n              method === \"data\" ? callRuntime(\n                \"data\",\n                import_compiler55.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(nodeBinding),\n                  true\n                ),\n                value\n              ) : callRuntime(\n                \"html\",\n                scopeIdentifier,\n                value,\n                getScopeAccessorLiteral(nodeBinding)\n              )\n            )\n          );\n        }\n      }\n      enterShallow(placeholder);\n      placeholder.remove();\n    }\n  }\n};\nfunction analyzeSiblingText(placeholder) {\n  const placeholderExtra = placeholder.node.extra;\n  let prev = placeholder.getPrevSibling();\n  while (prev.node) {\n    const contentType = getNodeContentType(\n      prev,\n      \"endType\"\n    );\n    if (contentType === null) {\n      prev = prev.getPrevSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 1 /* Before */;\n    } else {\n      break;\n    }\n  }\n  if (!prev.node && import_compiler55.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 1 /* Before */;\n  }\n  let next = placeholder.getNextSibling();\n  while (next.node) {\n    const contentType = getNodeContentType(\n      next,\n      \"startType\"\n    );\n    if (contentType === null) {\n      next = next.getNextSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 2 /* After */;\n    } else {\n      break;\n    }\n  }\n  if (!next.node && import_compiler55.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 2 /* After */;\n  }\n  return placeholderExtra[kSiblingText] = 0 /* None */;\n}\nfunction isVoid2(value) {\n  return value == null || value === false;\n}\n\n// src/translator/visitors/referenced-identifier.ts\nvar import_compiler56 = require(\"@marko/compiler\");\nvar abortIdsByExpressionForSection = /* @__PURE__ */ new WeakMap();\nvar referenced_identifier_default = {\n  migrate(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    switch (name2) {\n      case \"out\":\n        if (import_compiler56.types.isMemberExpression(identifier.parent) && import_compiler56.types.isIdentifier(identifier.parent.property) && identifier.parent.property.name === \"global\") {\n          identifier.parentPath.replaceWith(import_compiler56.types.identifier(\"$global\"));\n        } else {\n          throw identifier.buildCodeFrameError(\n            \"Only `out.global` is supported for compatibility.\"\n          );\n        }\n        break;\n    }\n  },\n  analyze(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    if (name2 === \"$global\") {\n      setReferencesScope(identifier);\n    } else if (name2 === \"$signal\") {\n      const section = getOrCreateSection(identifier);\n      section.hasAbortSignal = true;\n      setReferencesScope(identifier);\n    }\n  },\n  translate(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    switch (name2) {\n      case \"$global\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler56.types.callExpression(importRuntime(\"$global\"), [])\n          );\n        } else {\n          identifier.replaceWith(\n            import_compiler56.types.memberExpression(scopeIdentifier, import_compiler56.types.identifier(\"$global\"))\n          );\n        }\n        break;\n      case \"$signal\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler56.types.callExpression(\n              import_compiler56.types.arrowFunctionExpression(\n                [],\n                import_compiler56.types.blockStatement([\n                  import_compiler56.types.throwStatement(\n                    import_compiler56.types.newExpression(import_compiler56.types.identifier(\"Error\"), [\n                      import_compiler56.types.stringLiteral(\"Cannot use $signal in a server render.\")\n                    ])\n                  )\n                ])\n              ),\n              []\n            )\n          );\n        } else {\n          const section = getSection(identifier);\n          const exprRoot = getExprRoot(identifier);\n          let abortIdsByExpression = abortIdsByExpressionForSection.get(section);\n          let exprId;\n          if (abortIdsByExpression) {\n            exprId = abortIdsByExpression.get(exprRoot);\n          } else {\n            abortIdsByExpression = /* @__PURE__ */ new Map();\n            abortIdsByExpressionForSection.set(section, abortIdsByExpression);\n          }\n          if (!exprId) {\n            exprId = abortIdsByExpression.size;\n            abortIdsByExpression.set(exprRoot, exprId);\n            addStatement(\n              \"render\",\n              section,\n              exprRoot.node.extra?.referencedBindings,\n              import_compiler56.types.expressionStatement(\n                import_compiler56.types.callExpression(importRuntime(\"resetAbortSignal\"), [\n                  scopeIdentifier,\n                  import_compiler56.types.numericLiteral(exprId)\n                ])\n              ),\n              false\n            );\n          }\n          identifier.replaceWith(\n            import_compiler56.types.callExpression(importRuntime(\"getAbortSignal\"), [\n              scopeIdentifier,\n              import_compiler56.types.numericLiteral(exprId)\n            ])\n          );\n        }\n    }\n  }\n};\n\n// src/translator/visitors/scriptlet.ts\nvar scriptlet_default = {\n  analyze(scriptlet) {\n    if (!scriptlet.node.static) {\n      throw scriptlet.buildCodeFrameError(\n        \"Scriptlets are not supported when using the tags api.\"\n      );\n    }\n    mergeReferences(\n      getOrCreateSection(scriptlet),\n      scriptlet.node,\n      scriptlet.node.body\n    );\n  },\n  translate: {\n    exit(scriptlet) {\n      const { node } = scriptlet;\n      const isHTML = isOutputHTML();\n      if (node.target && node.target !== (isHTML ? \"server\" : \"client\")) {\n        scriptlet.remove();\n        return;\n      }\n      if (isHTML) {\n      } else {\n        traverseReplace(node, \"body\", replaceRegisteredFunctionNode);\n        scriptlet.replaceWithMultiple(node.body);\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/index.ts\nvar import_compiler60 = require(\"@marko/compiler\");\nvar import_babel_utils43 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/visitors/tag/attribute-tag.ts\nvar import_compiler57 = require(\"@marko/compiler\");\nvar import_babel_utils40 = require(\"@marko/compiler/babel-utils\");\nvar attribute_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils40.assertNoVar)(tag);\n      (0, import_babel_utils40.assertNoArgs)(tag);\n      const body = tag.get(\"body\");\n      startSection(body);\n      trackParamsReferences(body, 3 /* param */);\n      if (!(0, import_babel_utils40.findParentTag)(tag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags must be nested within another tag.\");\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/custom-tag.ts\nvar import_compiler58 = require(\"@marko/compiler\");\nvar import_babel_utils41 = require(\"@marko/compiler/babel-utils\");\nvar import_path4 = __toESM(require(\"path\"));\nvar kChildScopeBinding = Symbol(\"custom tag child scope\");\nvar kChildOffsetScopeBinding = Symbol(\"custom tag scope offset\");\nvar kChildAttrExprs = Symbol(\"custom tag child attribute expressions\");\nvar custom_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils41.assertAttributesOrSingleArg)(tag);\n      analyzeAttributeTags(tag);\n      const templateFile = (0, import_babel_utils41.getTagTemplate)(tag);\n      if (!templateFile) {\n        const tagName = getTagName(tag);\n        if (tagName && tag.scope.hasBinding(tagName)) {\n          throw tag.get(\"name\").buildCodeFrameError(\n            `Local variables must be in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n          );\n        }\n        throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n      }\n      const section = getOrCreateSection(tag);\n      const tagBody = tag.get(\"body\");\n      const tagExtra = tag.node.extra ??= {};\n      tagExtra[kChildScopeBinding] = createBinding(\n        \"#childScope\",\n        0 /* dom */,\n        section,\n        void 0,\n        tagExtra\n      );\n      tagExtra[kChildAttrExprs] = /* @__PURE__ */ new Set([tagExtra]);\n      if (tag.has(\"var\")) {\n        trackVarReferences(tag, 4 /* derived */);\n        tag.node.var.extra.binding.scopeOffset = tagExtra[kChildOffsetScopeBinding] = createBinding(\n          \"#scopeOffset\",\n          0 /* dom */,\n          section,\n          void 0,\n          tagExtra\n        );\n      }\n      startSection(tagBody);\n      trackParamsReferences(tagBody, 3 /* param */);\n      const childFile = (0, import_babel_utils41.loadFileForTag)(tag);\n      if (childFile.opts.filename === tag.hub.file.opts.filename) {\n        mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n      } else {\n        const childProgramExtra = childFile.ast.program.extra;\n        analyzeAttrs(\n          tagExtra,\n          section,\n          tag,\n          childProgramExtra?.domExports.input\n        );\n        (0, import_compiler58.getProgram)().node.extra.hasInteractiveChild = childProgramExtra?.isInteractive || childProgramExtra?.hasInteractiveChild || false;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML(tag);\n      } else {\n        translateDOM(tag);\n      }\n    }\n  }\n};\nfunction translateHTML(tag) {\n  const tagBody = tag.get(\"body\");\n  const { node } = tag;\n  const tagExtra = node.extra;\n  let tagIdentifier;\n  flushInto(tag);\n  writeHTMLResumeStatements(tagBody);\n  if (import_compiler58.types.isStringLiteral(node.name)) {\n    const relativePath = getTagRelativePath(tag);\n    tagIdentifier = isCircularRequest(tag.hub.file, relativePath) ? import_compiler58.types.identifier(getTemplateContentName()) : (0, import_babel_utils41.importDefault)(tag.hub.file, relativePath, getTagName(tag));\n  } else {\n    tagIdentifier = node.name;\n  }\n  const tagVar = node.var;\n  const section = getSection(tag);\n  const inputExport = (0, import_babel_utils41.loadFileForTag)(tag)?.ast.program.extra?.domExports?.input;\n  const { properties, statements } = inputExport ? translateAttrs(tag, inputExport.props) : {\n    properties: [],\n    statements: []\n  };\n  const serializeReason = !!tagVar || getDynamicSourcesForExtras(tagExtra[kChildAttrExprs]);\n  if (serializeReason) {\n    const childScopeBinding = tagExtra[kChildScopeBinding];\n    const peekScopeId = generateUidIdentifier(childScopeBinding?.name);\n    tag.insertBefore(\n      import_compiler58.types.variableDeclaration(\"const\", [\n        import_compiler58.types.variableDeclarator(peekScopeId, callRuntime(\"peekNextScope\"))\n      ])\n    );\n    setSerializedProperty(\n      section,\n      getScopeAccessor(childScopeBinding),\n      callRuntime(\"writeExistingScope\", peekScopeId),\n      serializeReason\n    );\n    if (tagVar) {\n      statements.push(\n        import_compiler58.types.expressionStatement(\n          callRuntime(\n            \"setTagVar\",\n            getScopeIdIdentifier(section),\n            getScopeAccessorLiteral(tag.node.extra[kChildOffsetScopeBinding]),\n            peekScopeId,\n            import_compiler58.types.stringLiteral(\n              getResumeRegisterId(\n                section,\n                node.var.extra?.binding,\n                // TODO: node.var is not always an identifier.\n                \"var\"\n              )\n            )\n          )\n        )\n      );\n    }\n  }\n  if (node.extra.tagNameNullable) {\n    const contentProp = getTranslatedBodyContentProperty(properties);\n    let contentId = void 0;\n    if (contentProp) {\n      const contentExpression = contentProp.value;\n      contentProp.value = contentId = generateUidIdentifier(\"content\");\n      const [contentPath] = tag.insertBefore(\n        import_compiler58.types.variableDeclaration(\"const\", [\n          import_compiler58.types.variableDeclarator(\n            contentId,\n            // TODO: only register if needed (child template analysis)\n            contentExpression\n          )\n        ])\n      );\n      contentPath.skip();\n    }\n    let renderTagExpr = callExpression(\n      tagIdentifier,\n      propsToExpression(properties)\n    );\n    if (tagVar) {\n      translateVar(tag, import_compiler58.types.unaryExpression(\"void\", import_compiler58.types.numericLiteral(0)), \"let\");\n      renderTagExpr = import_compiler58.types.assignmentExpression(\"=\", tagVar, renderTagExpr);\n    }\n    statements.push(\n      import_compiler58.types.ifStatement(\n        tagIdentifier,\n        import_compiler58.types.expressionStatement(renderTagExpr),\n        contentId && callStatement(contentId)\n      )\n    );\n  } else if (tagVar) {\n    translateVar(\n      tag,\n      callExpression(tagIdentifier, propsToExpression(properties))\n    );\n    serializeSectionIfNeeded(section, true);\n  } else {\n    statements.push(\n      callStatement(tagIdentifier, propsToExpression(properties))\n    );\n  }\n  for (const replacement of tag.replaceWithMultiple(statements)) {\n    replacement.skip();\n  }\n}\nfunction translateDOM(tag) {\n  const tagSection = getSection(tag);\n  const { node } = tag;\n  const extra = node.extra;\n  const childScopeBinding = extra[kChildScopeBinding];\n  const write2 = writeTo(tag);\n  const { file } = tag.hub;\n  const tagName = import_compiler58.types.isIdentifier(node.name) ? node.name.name : import_compiler58.types.isStringLiteral(node.name) ? node.name.value : \"tag\";\n  const relativePath = getTagRelativePath(tag);\n  const childFile = (0, import_babel_utils41.loadFileForTag)(tag);\n  const childExports = childFile.ast.program.extra.domExports;\n  const tagIdentifier = importOrSelfReferenceName(\n    file,\n    relativePath,\n    childExports.setup,\n    tagName\n  );\n  const inputExport = childExports.input;\n  if (inputExport) {\n    writeAttrsToExports(tag, inputExport, `${getTagName(tag) || \"tag\"}_input`, {\n      circular: childFile.opts.filename === file.opts.filename,\n      tagSection,\n      relativePath,\n      childScopeBinding,\n      attrTagCallsByTag: void 0\n    });\n  }\n  write2`${(0, import_babel_utils41.importNamed)(file, relativePath, childExports.template, `${tagName}_template`)}`;\n  injectWalks(\n    tag,\n    (0, import_babel_utils41.importNamed)(file, relativePath, childExports.walks, `${tagName}_walks`)\n  );\n  if (node.var) {\n    const source = initValue(\n      // TODO: support destructuring\n      node.var.extra.binding\n    );\n    source.register = true;\n    source.buildAssignment = (valueSection, value) => {\n      return import_compiler58.types.callExpression(importRuntime(\"tagVarSignalChange\"), [\n        createScopeReadExpression(valueSection, childScopeBinding),\n        value\n      ]);\n    };\n    addStatement(\n      \"render\",\n      tagSection,\n      void 0,\n      import_compiler58.types.expressionStatement(\n        callRuntime(\n          \"setTagVar\",\n          scopeIdentifier,\n          getScopeAccessorLiteral(childScopeBinding),\n          source.identifier\n        )\n      )\n    );\n  }\n  addStatement(\n    \"render\",\n    tagSection,\n    void 0,\n    import_compiler58.types.expressionStatement(\n      import_compiler58.types.callExpression(tagIdentifier, [\n        createScopeReadExpression(tagSection, childScopeBinding)\n      ])\n    )\n  );\n  tag.remove();\n}\nfunction getTagRelativePath(tag) {\n  const {\n    node,\n    hub: { file }\n  } = tag;\n  let relativePath;\n  if (import_compiler58.types.isStringLiteral(node.name)) {\n    const template = (0, import_babel_utils41.getTagTemplate)(tag);\n    relativePath = template && (0, import_babel_utils41.resolveRelativePath)(file, template);\n  } else if (node.extra?.tagNameImported) {\n    relativePath = node.extra.tagNameImported;\n  }\n  if (!relativePath) {\n    const tagName = getTagName(tag);\n    if (tagName && tag.scope.hasBinding(tagName)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        `Local variables must be in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n      );\n    }\n    throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n  }\n  return relativePath;\n}\nfunction analyzeAttrs(rootTagExtra, section, tag, templateExport) {\n  if (!templateExport) {\n    dropReferences(getAllTagReferenceNodes(tag.node));\n    return;\n  }\n  if (!templateExport.props || tag.node.arguments?.length) {\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n    return;\n  }\n  const bodySection = getSectionForBody(tag.get(\"body\"));\n  if (bodySection) {\n    bodySection.downstreamBinding = (templateExport.props.content || templateExport.props).binding;\n  }\n  const attrTagLookup = analyzeAttributeTags(tag);\n  const seen = /* @__PURE__ */ new Set();\n  if (attrTagLookup) {\n    const nodeReferencesByGroup = /* @__PURE__ */ new Map();\n    const analyzeDynamicChildGroup = (group, child) => {\n      const referenceNodes = getAllTagReferenceNodes(child.node);\n      const groupReferences = nodeReferencesByGroup.get(group);\n      if (groupReferences) {\n        groupReferences.referenceNodes = groupReferences.referenceNodes.concat(referenceNodes);\n      } else {\n        nodeReferencesByGroup.set(group, {\n          firstTag: child,\n          referenceNodes\n        });\n      }\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n    for (const child of attrTags2) {\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils41.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExports = templateExport.props[attrTagMeta.name];\n          if (childAttrExports) {\n            if (childAttrExports.props && !attrTagMeta.dynamic) {\n              analyzeAttrs(rootTagExtra, section, child, childAttrExports);\n            } else {\n              analyzeDynamicChildGroup(attrTagMeta.group, child);\n            }\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        } else {\n          const group = child.node.extra.attributeTagGroup;\n          let childUsesGroupProp = false;\n          for (const name2 of group) {\n            if (templateExport.props[attrTagLookup[name2].name]) {\n              childUsesGroupProp = true;\n              break;\n            }\n          }\n          if (childUsesGroupProp) {\n            analyzeDynamicChildGroup(group, child);\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        }\n      }\n    }\n    for (const {\n      firstTag: { node },\n      referenceNodes\n    } of nodeReferencesByGroup.values()) {\n      mergeReferences(section, node, referenceNodes);\n      rootTagExtra[kChildAttrExprs].add(node.extra);\n    }\n  }\n  const { attributes } = tag.node;\n  let spreadReferenceNodes;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler58.types.isMarkoAttribute(attr2)) {\n      if (seen.has(attr2.name) || !templateExport.props[attr2.name]) {\n        dropReferences(attr2.value);\n        continue;\n      }\n      seen.add(attr2.name);\n    }\n    if (spreadReferenceNodes) {\n      spreadReferenceNodes.push(attr2.value);\n    } else if (import_compiler58.types.isMarkoSpreadAttribute(attr2)) {\n      spreadReferenceNodes = [attr2.value];\n    } else {\n      rootTagExtra[kChildAttrExprs].add(attr2.value.extra ??= {});\n    }\n  }\n  if (spreadReferenceNodes) {\n    mergeReferences(section, tag.node, spreadReferenceNodes);\n  }\n}\nfunction writeAttrsToExports(tag, templateExport, importAlias, info) {\n  if (tag.node.arguments?.length) {\n    const [arg] = tag.node.arguments;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    addValue(\n      info.tagSection,\n      // technically this should be `arg.extra?.referencedBindings`\n      // but we should probably ensure all other references are dropped in this case before we do that.\n      tag.node.extra?.referencedBindings,\n      identifierToSignal(tagInputIdentifier),\n      import_compiler58.types.isSpreadElement(arg) ? import_compiler58.types.memberExpression(arg.argument, import_compiler58.types.numericLiteral(0), true) : arg,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding)\n    );\n    return;\n  }\n  if (!templateExport.props || info.circular) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    const translatedAttrs = translateAttrs(tag);\n    if (translatedAttrs.statements.length) {\n      addStatement(\n        \"render\",\n        info.tagSection,\n        referencedBindings,\n        translatedAttrs.statements\n      );\n    }\n    let translatedProps = propsToExpression(translatedAttrs.properties);\n    if ((0, import_babel_utils41.isAttributeTag)(tag)) {\n      const attrTagName = getTagName(tag);\n      const parentTag = tag.parentPath;\n      const repeated = analyzeAttributeTags(parentTag)?.[attrTagName]?.repeated;\n      if (repeated) {\n        let attrTagCallsForTag = (info.attrTagCallsByTag ||= /* @__PURE__ */ new Map()).get(\n          parentTag\n        );\n        if (!attrTagCallsForTag) {\n          info.attrTagCallsByTag.set(\n            parentTag,\n            attrTagCallsForTag = /* @__PURE__ */ new Map()\n          );\n        }\n        const attrTagCall = attrTagCallsForTag.get(attrTagName);\n        if (attrTagCall) {\n          attrTagCall.expression = callRuntime(\n            \"attrTags\",\n            attrTagCall.expression,\n            translatedProps\n          );\n          return;\n        } else {\n          attrTagCallsForTag.set(\n            attrTagName,\n            translatedProps = import_compiler58.types.parenthesizedExpression(\n              callRuntime(\"attrTag\", translatedProps)\n            )\n          );\n        }\n      } else {\n        translatedProps = callRuntime(\"attrTag\", translatedProps);\n      }\n    }\n    addValue(\n      info.tagSection,\n      referencedBindings,\n      identifierToSignal(tagInputIdentifier),\n      translatedProps,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding)\n    );\n    return;\n  }\n  const seen = /* @__PURE__ */ new Set();\n  const attrTagLookup = analyzeAttributeTags(tag);\n  if (attrTagLookup) {\n    const attrTags2 = tag.get(\"attributeTags\");\n    const statementsByGroup = /* @__PURE__ */ new Map();\n    const translateDynamicAttrTagChildInGroup = (group, index) => {\n      const child = attrTags2[index];\n      let statements = statementsByGroup.get(group)?.statements;\n      if (!statements) {\n        statements = [];\n        statementsByGroup.set(group, {\n          referencedBindings: child.node.extra?.referencedBindings,\n          statements\n        });\n      }\n      return addDynamicAttrTagStatements(\n        attrTags2,\n        index,\n        attrTagLookup,\n        statements,\n        templateExport.props\n      );\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils41.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExport = templateExport.props[attrTagMeta.name];\n          if (childAttrExport) {\n            if (attrTagMeta.dynamic) {\n              i = translateDynamicAttrTagChildInGroup(attrTagMeta.group, i);\n            } else {\n              writeAttrsToExports(\n                child,\n                childAttrExport,\n                `${importAlias}_${attrTagMeta.name}`,\n                info\n              );\n            }\n          }\n        } else if (child.node.extra?.attributeTagGroup) {\n          i = translateDynamicAttrTagChildInGroup(\n            child.node.extra.attributeTagGroup,\n            i\n          );\n        }\n      }\n    }\n    for (const [\n      group,\n      { referencedBindings, statements }\n    ] of statementsByGroup) {\n      const decls = [];\n      for (const name2 of group) {\n        const attrTagMeta = attrTagLookup[name2];\n        const childAttrExports = templateExport.props[attrTagMeta.name];\n        if (!childAttrExports) continue;\n        const attrExportIdentifier = importOrSelfReferenceName(\n          tag.hub.file,\n          info.relativePath,\n          childAttrExports.id,\n          `${importAlias}_${attrTagMeta.name}`\n        );\n        decls.push(import_compiler58.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta)));\n        addValue(\n          info.tagSection,\n          referencedBindings,\n          identifierToSignal(attrExportIdentifier),\n          getAttrTagIdentifier(attrTagMeta),\n          createScopeReadExpression(info.tagSection, info.childScopeBinding)\n        );\n      }\n      addStatement(\"render\", info.tagSection, referencedBindings, [\n        import_compiler58.types.variableDeclaration(\"let\", decls),\n        ...statements\n      ]);\n    }\n  }\n  const bodySection = tag.node.body.extra?.section;\n  if (bodySection && !seen.has(\"content\")) {\n    seen.add(\"content\");\n    if (templateExport.props.content) {\n      const contentExportIdentifier = (0, import_babel_utils41.importNamed)(\n        tag.hub.file,\n        info.relativePath,\n        templateExport.props.content.id,\n        `${importAlias}_content`\n      );\n      addValue(\n        info.tagSection,\n        void 0,\n        // TODO: pretty sure content needs to have the reference group of it's param defaults.\n        identifierToSignal(contentExportIdentifier),\n        import_compiler58.types.callExpression(import_compiler58.types.identifier(bodySection.name), [scopeIdentifier]),\n        createScopeReadExpression(info.tagSection, info.childScopeBinding)\n      );\n    }\n  }\n  const { attributes } = tag.node;\n  const staticAttrs = [];\n  let spreadProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler58.types.isMarkoAttribute(attr2)) {\n      const childAttrExports = templateExport.props[attr2.name];\n      if (!childAttrExports || seen.has(attr2.name)) continue;\n      seen.add(attr2.name);\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n        continue;\n      }\n      staticAttrs.push(attr2);\n    } else if (spreadProps) {\n      spreadProps.push(import_compiler58.types.spreadElement(attr2.value));\n    } else {\n      spreadProps = [import_compiler58.types.spreadElement(attr2.value)];\n    }\n  }\n  for (const attr2 of staticAttrs.reverse()) {\n    const childAttrExports = templateExport.props[attr2.name];\n    const attrExportIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      childAttrExports.id,\n      `${importAlias}_${attr2.name}`\n    );\n    addValue(\n      info.tagSection,\n      attr2.value.extra?.referencedBindings,\n      identifierToSignal(attrExportIdentifier),\n      attr2.value,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding)\n    );\n  }\n  const missing = new Set(Object.keys(templateExport.props));\n  for (const name2 of seen) missing.delete(name2);\n  if (missing.size) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    let getMissingPropValue = buildUndefined2;\n    if (spreadProps) {\n      const spreadId = generateUidIdentifier(`${importAlias}_spread`);\n      spreadProps.reverse();\n      getMissingPropValue = (name2) => toMemberExpression(spreadId, name2);\n      addStatement(\"render\", info.tagSection, referencedBindings, [\n        import_compiler58.types.variableDeclaration(\"const\", [\n          import_compiler58.types.variableDeclarator(spreadId, propsToExpression(spreadProps))\n        ])\n      ]);\n    }\n    for (const name2 of missing) {\n      const childAttrExports = templateExport.props[name2];\n      const attrExportIdentifier = importOrSelfReferenceName(\n        tag.hub.file,\n        info.relativePath,\n        childAttrExports.id,\n        `${importAlias}_${name2}`\n      );\n      addValue(\n        info.tagSection,\n        referencedBindings,\n        identifierToSignal(attrExportIdentifier),\n        getMissingPropValue(name2),\n        createScopeReadExpression(info.tagSection, info.childScopeBinding)\n      );\n    }\n  }\n}\nfunction importOrSelfReferenceName(file, request, name2, nameHint) {\n  if (isCircularRequest(file, request)) {\n    return import_compiler58.types.identifier(name2);\n  }\n  return (0, import_babel_utils41.importNamed)(file, request, name2, nameHint);\n}\nfunction isCircularRequest(file, request) {\n  const { filename } = file.opts;\n  return request === filename || request[0] === \".\" && import_path4.default.resolve(filename, \"..\", request) === filename;\n}\nfunction callStatement(id, ...args) {\n  return import_compiler58.types.expressionStatement(callExpression(id, ...args));\n}\nfunction callExpression(id, ...args) {\n  return import_compiler58.types.callExpression(id, args.filter(Boolean));\n}\nfunction identifierToSignal(identifier) {\n  return {\n    identifier,\n    hasDownstreamIntersections: always\n  };\n}\nfunction buildUndefined2() {\n  return import_compiler58.types.unaryExpression(\"void\", import_compiler58.types.numericLiteral(0));\n}\nfunction always() {\n  return true;\n}\n\n// src/translator/visitors/tag/dynamic-tag.ts\nvar import_compiler59 = require(\"@marko/compiler\");\nvar import_babel_utils42 = require(\"@marko/compiler/babel-utils\");\nvar kDOMBinding3 = Symbol(\"dynamic tag dom binding\");\nvar kChildOffsetScopeBinding2 = Symbol(\"custom tag scope offset\");\nvar dynamic_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils42.assertAttributesOrArgs)(tag);\n      analyzeAttributeTags(tag);\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      const tagBody = tag.get(\"body\");\n      tagExtra[kDOMBinding3] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section,\n        void 0,\n        tagExtra\n      );\n      if (tag.has(\"var\")) {\n        trackVarReferences(tag, 4 /* derived */);\n        tag.node.var.extra.binding.scopeOffset = tagExtra[kChildOffsetScopeBinding2] = createBinding(\n          \"#scopeOffset\",\n          0 /* dom */,\n          section,\n          void 0,\n          tagExtra\n        );\n      }\n      startSection(tagBody);\n      trackParamsReferences(tagBody, 3 /* param */);\n      mergeReferences(section, tag.node, [\n        tag.node.name,\n        ...getAllTagReferenceNodes(tag.node)\n      ]);\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(\n        tag,\n        tag.node.var ? 49 /* DynamicTagWithVar */ : 37 /* Replace */\n      );\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const tagExtra = node.extra;\n      const nodeRef2 = tagExtra[kDOMBinding3];\n      const section = getSection(tag);\n      const isClassAPI = tagExtra.featureType === \"class\";\n      let tagExpression = node.name;\n      if (import_compiler59.types.isStringLiteral(tagExpression)) {\n        tagExpression = (0, import_babel_utils42.importDefault)(\n          tag.hub.file,\n          getTagRelativePath(tag),\n          tagExpression.value\n        );\n      }\n      if (isClassAPI) {\n        if (isOutputHTML()) {\n          (0, import_compiler59.getProgram)().node.body.push(\n            import_compiler59.types.markoScriptlet(\n              [\n                import_compiler59.types.expressionStatement(\n                  import_compiler59.types.callExpression(\n                    (0, import_babel_utils42.importNamed)(tag.hub.file, getCompatRuntimeFile(), \"s\"),\n                    [\n                      import_compiler59.types.identifier(tagExpression.name),\n                      import_compiler59.types.stringLiteral((0, import_babel_utils42.loadFileForTag)(tag).metadata.marko.id)\n                    ]\n                  )\n                )\n              ],\n              true\n            )\n          );\n        } else {\n          (0, import_compiler59.getProgram)().node.body.push(\n            import_compiler59.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                import_compiler59.types.stringLiteral((0, import_babel_utils42.loadFileForTag)(tag).metadata.marko.id),\n                import_compiler59.types.identifier(tagExpression.name)\n              )\n            )\n          );\n        }\n      }\n      const { properties, statements } = translateAttrs(\n        tag,\n        void 0,\n        void 0,\n        isClassAPI ? \"renderBody\" : \"content\"\n      );\n      const args = [];\n      let hasMultipleArgs = false;\n      if (node.arguments?.length) {\n        args.push(...node.arguments);\n        if (properties.length) {\n          hasMultipleArgs = true;\n          args.push(propsToExpression(properties));\n        } else {\n          hasMultipleArgs = node.arguments.length > 1 || import_compiler59.types.isSpreadElement(node.arguments[0]);\n        }\n      } else {\n        const contentProp = getTranslatedBodyContentProperty(properties);\n        if (contentProp) {\n          properties.splice(properties.indexOf(contentProp), 1);\n          args.push(propsToExpression(properties), contentProp.value);\n        } else {\n          args.push(propsToExpression(properties));\n        }\n      }\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        const serializeReason = isClassAPI || !!node.var || getDynamicSourcesForExtra(tagExtra);\n        const dynamicTagExpr = hasMultipleArgs ? callRuntime(\n          \"dynamicTag\",\n          getScopeIdIdentifier(section),\n          getScopeAccessorLiteral(nodeRef2),\n          tagExpression,\n          import_compiler59.types.arrayExpression(args),\n          import_compiler59.types.numericLiteral(0),\n          import_compiler59.types.numericLiteral(1),\n          serializeReason ? import_compiler59.types.numericLiteral(1) : void 0\n        ) : callRuntime(\n          \"dynamicTag\",\n          getScopeIdIdentifier(section),\n          getScopeAccessorLiteral(nodeRef2),\n          tagExpression,\n          args[0],\n          args[1] || (serializeReason ? import_compiler59.types.numericLiteral(0) : void 0),\n          serializeReason ? import_compiler59.types.numericLiteral(0) : void 0,\n          serializeReason ? import_compiler59.types.numericLiteral(1) : void 0\n        );\n        if (node.var) {\n          const dynamicScopeIdentifier = generateUidIdentifier(\"dynamicScope\");\n          statements.push(\n            import_compiler59.types.variableDeclaration(\"const\", [\n              import_compiler59.types.variableDeclarator(\n                dynamicScopeIdentifier,\n                callRuntime(\"peekNextScope\")\n              )\n            ])\n          );\n          statements.push(\n            import_compiler59.types.variableDeclaration(\"const\", [\n              import_compiler59.types.variableDeclarator(node.var, dynamicTagExpr)\n            ]),\n            import_compiler59.types.expressionStatement(\n              callRuntime(\n                \"setTagVar\",\n                getScopeIdIdentifier(section),\n                getScopeAccessorLiteral(\n                  tag.node.extra[kChildOffsetScopeBinding2]\n                ),\n                dynamicScopeIdentifier,\n                import_compiler59.types.stringLiteral(\n                  getResumeRegisterId(\n                    section,\n                    node.var.extra?.binding,\n                    // TODO: node.var is not always an identifier.\n                    \"var\"\n                  )\n                )\n              )\n            )\n          );\n        } else {\n          statements.push(import_compiler59.types.expressionStatement(dynamicTagExpr));\n        }\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      } else {\n        const section2 = getSection(tag);\n        const bodySection = getSectionForBody(tag.get(\"body\"));\n        const signal = getSignal(section2, nodeRef2, \"dynamicTag\");\n        let tagVarSignal;\n        if (tag.node.var) {\n          tagVarSignal = initValue(\n            // TODO: support destructuring\n            tag.node.var.extra.binding\n          );\n          tagVarSignal.register = true;\n          tagVarSignal.buildAssignment = (valueSection, value) => {\n            return import_compiler59.types.callExpression(importRuntime(\"tagVarSignalChange\"), [\n              import_compiler59.types.memberExpression(\n                getScopeExpression(tagVarSignal.section, valueSection),\n                import_compiler59.types.stringLiteral(\n                  getAccessorPrefix().ConditionalScope + getScopeAccessor(nodeRef2)\n                ),\n                true\n              ),\n              value\n            ]);\n          };\n        }\n        signal.build = () => {\n          return callRuntime(\n            \"dynamicTag\",\n            getScopeAccessorLiteral(nodeRef2),\n            bodySection && import_compiler59.types.identifier(bodySection.name),\n            tagVarSignal ? import_compiler59.types.arrowFunctionExpression([], tagVarSignal.identifier) : void 0,\n            hasMultipleArgs && import_compiler59.types.numericLiteral(1)\n          );\n        };\n        if (args.length) {\n          const argsOrInput = hasMultipleArgs ? import_compiler59.types.arrayExpression(args) : args[0];\n          if (!import_compiler59.types.isObjectExpression(argsOrInput) || argsOrInput.properties.length) {\n            signal.extraArgs = [\n              import_compiler59.types.arrowFunctionExpression(\n                [],\n                statements.length ? import_compiler59.types.blockStatement(\n                  statements.concat(import_compiler59.types.returnStatement(argsOrInput))\n                ) : argsOrInput\n              )\n            ];\n          }\n        }\n        signal.hasDownstreamIntersections = () => true;\n        addValue(section2, tagExtra.referencedBindings, signal, tagExpression);\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/index.ts\nvar TAG_NAME_IDENTIFIER_REG = /^[A-Z][a-zA-Z0-9_$]*$/;\nvar BINDING_CHANGE_HANDLER = /* @__PURE__ */ new WeakMap();\nvar tag_default = {\n  transform: {\n    enter(tag) {\n      const { node } = tag;\n      const { name: name2, attributes } = tag.node;\n      let crawl = false;\n      if (import_compiler60.types.isStringLiteral(name2)) {\n        const tagName = name2.value;\n        if (tag.scope.getBinding(tagName) && TAG_NAME_IDENTIFIER_REG.test(tagName)) {\n          node.name = withPreviousLocation(import_compiler60.types.identifier(tagName), name2);\n          crawl = true;\n        }\n      }\n      for (let i = 0; i < attributes.length; i++) {\n        const attr2 = attributes[i];\n        if (import_compiler60.types.isMarkoAttribute(attr2) && attr2.bound) {\n          attr2.bound = false;\n          attributes.splice(++i, 0, getChangeHandler(tag, attr2));\n          crawl = true;\n        }\n      }\n      if (crawl) {\n        tag.scope.crawl();\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils43.getTagDef)(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        enter(hook, tag);\n        return;\n      }\n      if (type === 0 /* NativeTag */) {\n        native_tag_default.analyze.enter(tag);\n        return;\n      }\n      switch (type) {\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.analyze.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.analyze.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const hook = (0, import_babel_utils43.getTagDef)(tag)?.analyzer?.hook;\n      if (hook) {\n        exit(hook, tag);\n        return;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils43.getTagDef)(tag);\n      const extra = tag.node.extra;\n      if (tagDef?.translator) {\n        if (tagDef.translator.path) {\n          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);\n        }\n        enter(tagDef.translator.hook, tag);\n        return;\n      }\n      for (const attr2 of tag.get(\"attributes\")) {\n        if (attr2.isMarkoAttribute()) {\n          if (attr2.node.arguments) {\n            throw attr2.buildCodeFrameError(\n              `Unsupported arguments on the \\`${attr2.node.name}\\` attribute.`\n            );\n          }\n          if (attr2.node.modifier) {\n            if ((0, import_babel_utils43.isNativeTag)(attr2.parentPath)) {\n              attr2.node.name += `:${attr2.node.modifier}`;\n            } else {\n              throw attr2.buildCodeFrameError(\n                `Unsupported modifier \\`${attr2.node.modifier}\\`.`\n              );\n            }\n          }\n        }\n      }\n      if (extra.tagNameDynamic && extra.tagNameNullable && !tag.get(\"name\").isIdentifier() && isOutputHTML()) {\n        const tagNameId = generateUidIdentifier(\"tagName\");\n        const [tagNameVarPath] = tag.insertBefore(\n          import_compiler60.types.variableDeclaration(\"const\", [\n            import_compiler60.types.variableDeclarator(tagNameId, tag.node.name)\n          ])\n        );\n        tagNameVarPath.skip();\n        tag.set(\"name\", tagNameId);\n      }\n      switch (extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const translator = (0, import_babel_utils43.getTagDef)(tag)?.translator;\n      if (translator) {\n        exit(translator.hook, tag);\n        return;\n      }\n      switch (tag.node.extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.exit(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.exit(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.exit(tag);\n          break;\n      }\n    }\n  }\n};\nfunction getChangeHandler(tag, attr2) {\n  const attrName = attr2.name;\n  const changeAttrName = attrName + \"Change\";\n  if (import_compiler60.types.isIdentifier(attr2.value)) {\n    const binding = tag.scope.getBinding(attr2.value.name);\n    if (!binding)\n      return import_compiler60.types.markoAttribute(\n        changeAttrName,\n        buildChangeHandlerFunction(attr2.value)\n      );\n    const existingChangedAttr = BINDING_CHANGE_HANDLER.get(binding.identifier);\n    if (!existingChangedAttr) {\n      const changeHandlerAttr = import_compiler60.types.markoAttribute(\n        changeAttrName,\n        buildChangeHandlerFunction(attr2.value)\n      );\n      BINDING_CHANGE_HANDLER.set(binding.identifier, changeHandlerAttr);\n      return changeHandlerAttr;\n    }\n    if (existingChangedAttr.type === \"Identifier\") {\n      return import_compiler60.types.markoAttribute(\n        changeAttrName,\n        withPreviousLocation(\n          import_compiler60.types.identifier(existingChangedAttr.name),\n          attr2.value\n        )\n      );\n    }\n    const markoRoot = isMarko(binding.path) ? binding.path : getMarkoRoot(binding.path);\n    if (!(markoRoot?.isMarkoTag() || markoRoot?.isMarkoTagBody())) {\n      throw tag.hub.buildError(attr2.value, \"Unable to bind to value.\");\n    }\n    const changeHandlerId = generateUid(changeAttrName);\n    const changeHandlerConst = import_compiler60.types.markoTag(\n      import_compiler60.types.stringLiteral(\"const\"),\n      [import_compiler60.types.markoAttribute(\"value\", existingChangedAttr.value, null, null, true)],\n      import_compiler60.types.markoTagBody([]),\n      null,\n      import_compiler60.types.identifier(changeHandlerId)\n    );\n    BINDING_CHANGE_HANDLER.set(\n      binding.identifier,\n      existingChangedAttr.value = import_compiler60.types.identifier(changeHandlerId)\n    );\n    if (markoRoot.isMarkoTag()) {\n      markoRoot.insertAfter(changeHandlerConst);\n    } else {\n      markoRoot.unshiftContainer(\"body\", changeHandlerConst);\n    }\n    return import_compiler60.types.markoAttribute(\n      changeAttrName,\n      withPreviousLocation(import_compiler60.types.identifier(changeHandlerId), attr2.value)\n    );\n  } else if (import_compiler60.types.isMemberExpression(attr2.value)) {\n    const prop = attr2.value.property;\n    if (!import_compiler60.types.isPrivateName(attr2.value.property)) {\n      return import_compiler60.types.markoAttribute(\n        changeAttrName,\n        import_compiler60.types.memberExpression(\n          import_compiler60.types.cloneNode(attr2.value.object),\n          prop.type === \"Identifier\" ? withPreviousLocation(import_compiler60.types.identifier(prop.name + \"Change\"), prop) : import_compiler60.types.binaryExpression(\n            \"+\",\n            import_compiler60.types.cloneNode(prop),\n            import_compiler60.types.stringLiteral(\"Change\")\n          ),\n          prop.type !== \"Identifier\"\n        )\n      );\n    }\n  }\n  throw tag.hub.buildError(\n    attr2.value,\n    \"Attributes may only be bound to identifiers or member expressions\"\n  );\n}\nfunction buildChangeHandlerFunction(id) {\n  const newId = \"_new_\" + id.name;\n  return import_compiler60.types.arrowFunctionExpression(\n    [withPreviousLocation(import_compiler60.types.identifier(newId), id)],\n    import_compiler60.types.blockStatement([\n      import_compiler60.types.expressionStatement(\n        import_compiler60.types.assignmentExpression(\n          \"=\",\n          withPreviousLocation(import_compiler60.types.identifier(id.name), id),\n          withPreviousLocation(import_compiler60.types.identifier(newId), id)\n        )\n      )\n    ])\n  );\n}\n\n// src/translator/visitors/text.ts\nvar import_compiler61 = require(\"@marko/compiler\");\nvar text_default = {\n  translate: {\n    exit(text) {\n      if (isNonHTMLText(text)) return;\n      writeTo(text)`${text.node.value}`;\n      enterShallow(text);\n      text.remove();\n    }\n  }\n};\n\n// src/translator/index.ts\nvar visitors = extractVisitors({\n  Program: program_default,\n  Function: function_default,\n  ReferencedIdentifier: referenced_identifier_default,\n  ImportDeclaration: import_declaration_default,\n  MarkoDocumentType: document_type_default,\n  MarkoDeclaration: declaration_default,\n  MarkoCDATA: cdata_default,\n  MarkoText: text_default,\n  MarkoTag: tag_default,\n  MarkoPlaceholder: placeholder_default,\n  MarkoScriptlet: scriptlet_default,\n  MarkoComment: comment_default\n});\nvar tagDiscoveryDirs = [\"tags\"];\nvar preferAPI = \"tags\";\nvar { transform, analyze, translate } = visitors;\nvar taglibs = [\n  [\n    __dirname,\n    {\n      ...core_default,\n      migrate: visitors.migrate\n    }\n  ]\n];\nfunction getRuntimeEntryFiles(output, optimize) {\n  return [\n    `${runtime_info_default.name}${optimize ? \"\" : \"/debug\"}/${output === \"html\" ? \"html\" : \"dom\"}`\n  ];\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  analyze,\n  getRuntimeEntryFiles,\n  internalEntryBuilder,\n  preferAPI,\n  tagDiscoveryDirs,\n  taglibs,\n  transform,\n  translate\n});\n"],"names":["mod","__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__copyProps","to","from","except","desc","key","call","get","enumerable","__toESM","isNodeMode","target","__esModule","value","index_exports","__export","all","name2","analyze","getRuntimeEntryFiles","internalEntryBuilder","entry_builder_default","preferAPI","tagDiscoveryDirs","taglibs","transform","translate","module","exports","runtime_info_default","name","require","taglibId","import_compiler","import_babel_utils","assertNoSpreadAttrs","tag","attr2","isMarkoSpreadAttribute","buildCodeFrameError","node","assertNoBodyContent","body","length","AccessorPrefix3","AccessorProp3","attrs_default","migrate","assertNoArgs","assertNoParams","assertNoAttributes","assertNoAttributeTags","diagnosticDeprecate","label","fix","tagVar","var","type","remove","constTag","types","markoTag","stringLiteral","markoAttribute","identifier","markoTagBody","replaceWith","attributes","autocomplete","displayText","description","snippet","import_compiler27","import_babel_utils12","AccessorPrefix","AccessorProp","import_babel_utils2","evaluate","extra","confident","computed","computeNode","import_compiler26","import_compiler6","import_babel_utils5","import_compiler3","import_compiler2","skip","Symbol","traverseReplace","container","enter3","Array","isArray","i","keys","VISITOR_KEYS","replacement","traverseContains","check","item","traverse","visit2","parent","grandParent","countsForFile","WeakMap","generateUid","file","getFile","counts","cache","markoOpts","filename","opts","cacheKey","isTranslate","Map","program","path","countName","match","exec","name3","count","set","Math","max","scope","globals","isBinding","getInitialCounts","replace","uniqueName","generateUidIdentifier","___compileStage","import_babel_utils3","getTagName","isCoreTag","isMarkoTag","tagDef","getTagDef","isCoreTagName","isConditionTag","Sorted","constructor","compare","this","add","data","addSorted","joinRepeatable","union","a","b","aLen","bLen","aIndex","bIndex","result","aValue","bValue","delta","push","unionSortedRepeatable","find","findSorted","findIndex","pos","mid","compareResult","isSuperset","superset","subset","subLen","supLen","supIndex","filter","cb","len","forEach","cur","next","import_compiler4","createProgramState","init","map2","state","getProgram","createSectionState","section","arrayOfSectionData","id","import_compiler5","import_babel_utils4","MARKO_FILE_REG","analyzeTagNameType","tagNameType","isStringLiteral","isNativeTag","tagNameNullable","isIdentifier","pending","path5","tagNameImported","nullable","pop","isConditionalExpression","alternate","isLogicalExpression","operator","isAssignmentExpression","isBinaryExpression","isTemplateLiteral","isNullLiteral","binding","getBinding","kind","decl","test","source","specifiers","some","it","isImportDefaultSpecifier","resolvedImport","resolveTagImport","bindingTag","bindingTagName","tagNameDynamic","analyzeExpressionTagName","expressions","childFile","loadFileForTag","ast","featureType","needsCompat","sectionUtil","startSection","parentSection","parentPath","getOrCreateSection","sectionNamePath","sectionName","isProgram","toString","programExtra","hub","sections","loc","depth","sectionAccessor","params","referencedClosures","referencedHoists","bindings","hoisted","isHoistThrough","assignments","content","getContentInfo","upstreamExpression","downstreamBinding","hasAbortSignal","isBranch","attributeTags","isNativeNode","getSectionForBody","getSection","currentPath","getScopeIdIdentifier","getSectionParentIsOwner","setSectionParentIsOwner","_getScopeIdentifier","forEachSection","fn","contentInfo","startType","endType","singleChild","endIndex","getNodeContentType","startIndex","extraMember","isAttributeTag","tagSection","isSerializedSection","serialize","isSectionWithHoists","isImmediateOwner","isDynamicClosure","closure","isDirectClosure","isSameOrChildSection","other","getDynamicSourcesForBinding","sources","every","isInputBinding","getDynamicSourcesForExtra","isReferencedExtra","getDynamicSourcesForReferences","referencedBindings","getDynamicSourcesForExtras","extras","allDynamicSources","dynamicSources","bindingUtil","getDynamicSourcesForSection","referenced","closures","getDirectClosures","newDynamicSources","mergeDynamicSources","forEachIdentifier","prop","properties","left","argument","el","elements","AccessorPrefix2","AccessorProp2","import_compiler8","isOutputHTML","getMarkoOpts","output","isOutputDOM","isOptimize","optimize","getAccessorPrefix","getMarkoRoot","curPath","isMarko","getExprRoot","getFnRoot","fnPath","isFunction","declare","isInvokedFunction","expr","callee","import_compiler25","import_compiler24","import_babel_utils11","import_path2","bindingHasDownstreamExpressions","downstreamExpressions","size","alias","aliases","propertyAliases","values","import_compiler10","import_babel_utils6","kState","build","entryFile","imports","map","importDeclaration","unshift","importSpecifier","expressionStatement","callExpression","visit","visitChild","analyzedTags","metadata","marko","resolveRelativePath","hasInteractiveChild","isInteractive","import_compiler12","import_babel_utils7","stringifyClassObject","stringifyStyleObject","toDelimitedString","val","delimiter","stringify","curDelimiter","v","part","isEventHandler","getEventHandlerName","slice","toLowerCase","unsafeXMLReg","replaceUnsafeXML","c","escapeXML","str","unsafeScriptReg","escapeScript","unsafeStyleReg","escapeStyle","kTouchedIterator","Generator","AsyncGenerator","async","toAccess","accessor","start","patchIteratorNext","proto","classAttr","stringAttr","classValue","styleAttr","styleValue","attr","isVoid","attrAssignment","RegExp","nonVoidAttr","KNOWN_SYMBOLS2","symbol","AggregateError","of","ArrayBuffer","isView","Atomics","and","compareExchange","exchange","isLockFree","load","notify","or","store","sub","wait","BigInt","asIntN","asUintN","BigInt64Array","BigUint64Array","Boolean","console","assert","clear","countReset","debug","dir","dirxml","error","group","groupCollapsed","groupEnd","info","log","table","time","timeEnd","timeLog","timeStamp","trace","warn","DataView","Date","now","parse","UTC","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","Error","EvalError","Float32Array","Float64Array","Function","globalThis","atob","btoa","clearImmediate","clearInterval","clearTimeout","crypto","getRandomValues","randomUUID","fetch","performance","queueMicrotask","setImmediate","setInterval","setTimeout","structuredClone","URL","URLSearchParams","WritableStream","Int16Array","Int32Array","Int8Array","Intl","Collator","DateTimeFormat","DisplayNames","getCanonicalLocales","ListFormat","Locale","NumberFormat","PluralRules","RelativeTimeFormat","Segmenter","supportedValuesOf","isFinite","isNaN","JSON","groupBy","abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","floor","fround","hypot","imul","log10","log1p","log2","min","pow","random","round","sign","sin","sinh","sqrt","tan","tanh","trunc","Number","isInteger","isSafeInteger","parseFloat","parseInt","assign","defineProperties","entries","freeze","fromEntries","getOwnPropertyDescriptors","getOwnPropertySymbols","is","isExtensible","isFrozen","isSealed","preventExtensions","seal","setPrototypeOf","Promise","Proxy","RangeError","ReferenceError","Reflect","apply","construct","deleteProperty","has","ownKeys","Set","String","fromCharCode","fromCodePoint","raw","for","SyntaxError","TypeError","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","URIError","WeakSet","singleQuoteAttrReplacements","doubleQuoteAttrReplacements","needsQuotedAttr","lastIndex","replaceUnsafeSingleQuoteAttrChar","escapeSingleQuotedAttrValue","replaceUnsafeDoubleQuoteAttrChar","escapeDoubleQuotedAttrValue","import_compiler11","isValidPropertyIdentifier","toPropertyName","numericLiteral","toObjectProperty","objectProperty","toMemberExpression","object","optional","optionalMemberExpression","memberExpression","pureDOMFunctions","importRuntime","importStar","getRuntimePath","callRuntime","args","callExpression2","filteredArgs","arg","unaryExpression","filterArguments","leadingComments","getHTMLRuntime","getCompatRuntimeFile","modules","import_compiler22","import_babel_utils10","import_path","regexpCharsReg","import_compiler21","import_babel_utils9","import_compiler17","import_babel_utils8","getKnownAttrValues","attrs2","getParentTag","import_compiler13","enter","modulePlugin","plugin","isModulePlugin","default","isFunctionPlugin","exit","translateByTarget","html","dom","import_compiler16","import_compiler14","normalizeStringExpression","parts","strs","exprs","curStr","nextIndex","exprLen","shiftItems","quasis","j","templateLiteral","templateElement","appendLiteral","arr","list","offset","getWalks","getWalkComment","getSteps","walkCodeToName","enter2","exit2","enterShallow","code","steps","walks","walkComment","walkString","walkCodes","step","lastIndexOf","current","walk","nCodeString","writeTo","number","toCharString","startCode","rangeSize","multiplier","getWalkString","prefix2","postfix","walkLiteral","join","getWrites","getTrailerWrites","trailer","exprsLen","writes","consumeHTML","trailers","writeResult","trailerResult","sequenceExpression","flushBefore","insertBefore","flushInto","getSectionMeta","writePrefix","writePostfix","setup","getSetup","markNode","getScopeAccessorLiteral","tagsWithReturn","getSectionReturnValueIdentifier","setReturnValueIdentifier","return_default","assertNoVar","assertAllowedAttributes","parentTag","isControlFlowTag","valueChange","setSerializedProperty","TagVariableChange","returnId","variableDeclaration","variableDeclarator","addValue","hasDownstreamIntersections","parseOptions","openTagOnly","descriptionMoreURL","import_compiler18","getDeclaredBindingExpression","declared","upstreamAlias","property","import_compiler19","simplifyFunction","functionExpression","generator","import_compiler20","toFirstExpressionOrBlock","stmts","isExpressionStatement","expression","toParenthesizedExpressionIfNeeded","blockStatement","parenthesizedExpression","getSignals","getClosureSignalBuilder","_setClosureSignalBuilder","setClosureSignalBuilder","builder","serializeSectionReason","setSerializeSectionReason","serializeSectionIfNeeded","reason","existingReason","getSerializedScopeProperties","getSectionWriteScopeBuilder","setSectionWriteScopeBuilder","addWriteScopeBuilder","prev","htmlDynamicClosureInstancesIdentifier","getHTMLSectionStatements","getHoistFunctionsIdsMap","getHoistFunctionIdentifier","hoistedBinding","idsMap","unimplementedBuild","getSignal","ref","generateSignalName","signals","signal","exportName","export","domExports","intersection","render","renderReferencedBindings","effect","effectReferencedBindings","subscribers","subscribe","scopeOffset","intersectionMeta","getSignalFn","arrowFunctionExpression","scopeIdentifier","getScopeExpression","initValue","runtimeHelper","isParamBinding","needsCache","needsMarks","hoists","valueAccessor","isIntersection","isValue","canUseCalleeDirectly","valueParam","index","end","aliasSignal","getTranslatedExtraArgs","dynamicClosureArgs","dynamicClosureSignalIdentifier","closureSections","closureSection","prependStatements","effectIdentifier","createScopeReadPattern","arguments","param","hasTranslatedExtraArgs","emptyExtraArgs","extraArgs","replaceRenderNode","provider","subscriber","p","providerSignal","replaceNullishAndEmptyFunctionsWith0","isArrowFunctionExpression","isBlockStatement","isUnaryExpression","isNumericLiteral","addStatement","targetSection","statement","usedReferences","statements","addEffectReferences","addRenderReferences","parentSignal","getResumeRegisterId","getTemplateId","usedRegisterIdsBySection","getRegisterUID","used","baseId","writeSignals","accessors","Getter","getScopeAccessor","currentSection","getSectionInstancesAccessorLiteral","hoistIdentifier","sort","sortSignals","value2","effectDeclarator","replaceEffectNode","referencesScope","isScopeIdentifier","isCallExpression","register","signalDeclarator","signalDeclaration","isFunctionExpression","functionDeclaration","isExpression","exportNamedDeclaration","signalStatements","toReturnedFunction","rawFn","returnStatement","aReferencedBindings","getReferencedBindings","bReferencedBindings","diff","reserve","getMappedId","reference","addHTMLEffectCall","writeHTMLResumeStatements","allSignals","scopeIdIdentifier","serializeOwnersUntilBinding","serializeOwners","serializeReason","closureSignal","newExpression","ClosureScopes","ClosureSignalIndex","getDynamicClosureIndex","sectionDynamicSubscribers","subscribersIdentifier","getSectionInstancesAccessor","signalRefs","serializedLookup","serializedProperties","delete","writeScopeBuilder","forceSerializeReason","shorthand","writeScopeArgs","objectExpression","debugVars","root","access","locExpr","line","column","arrayExpression","filenameRelative","additionalStatements","returnIdentifier","serialized","replaceAssignedNode","replaceBindingReadNode","replaceRegisteredFunctionNode","getReadReplacement","isAssignedBindingExtra","buildAssignment","assignment","binaryExpression","prefix","right","resultId","assignmentExpression","registeredFnsForProgram","getRegisteredFnExpression","classProperty","classPrivateProperty","isRegisteredFnExtra","referencedBindingsInFunction","registedFns","registerId","dom_default","templateIdentifier","template","walksIdentifier","setupIdentifier","inputBinding","programInputSignal","styleFile","fs","fileSystem","base","sep","leftDot","indexOf","rightDot","closeBracket","openBracket","getBase","styleMatch","file2","readdirSync","dirname","getStyleFile","importDefault","forEachSectionReverse","childSection","tagParamsSignal","walks2","writes2","setup2","renderer","registeredFns","registeredFn","assignmentPattern","writeRegisteredFns","exportDefaultDeclaration","import_compiler23","templateContentIdentifierForProgram","html_default","replaceNode","renderContent","child","isImportDeclaration","isExportDeclaration","isMarkoScriptlet","static","replaceWithMultiple","contentId","contentFn","exportDefault","read","replaceBindingReadNode2","getRegisteredFnExpression2","registeredFnDeclarations","registeredFnDeclarationsByBody","addRegisteredDeclarations","replaceRegisteredFunctionNode2","program_default","crawl","trackParamsReferences","input","getBindings","readsByExpression","getReadsByExpression","readsByFn","getReadsByFunction","mergedReferences","getMergedReferences","nodes","targetExtra","reads","isEffect","additionalReads","concat","intersectionsBySection","resolveReferencedBindings","pruneBinding","resolveBindingSources","section2","bindingReference","intersections","numReferences","binding1","binding2","sourceSection","intersectionIndex","bindings2","isOwnedBinding","lastBindingIndex","bindingIndex","at","getMaxOwnSourceOffset","finalizeReferences","buildTemplateExports","visitedFiles","resolved","loadFileForImport","req","resolveRelativeToEntry","compatFile","templateExport","props","rootDepth","rootPattern","objectPattern","nestedPatterns","propertyValue","propertyKey","isShorthand","pattern","relativeDepth","nestedPattern","createScopeReadExpression","propName","withPreviousLocation","newNode","originalNode","kIsInvoked","getNextBindingId","setNextBindingId","createBinding","excludeProperties","propBinding","trackVarReferences","canonicalUpstreamAlias","getCanonicalBinding","pruned","createBindingsAndTrackReferences","paramsBinding","trackHoistedReference","referencePath","referenceSection","hoistSection","ancestor","getCommonSection","createRead","trackReference","trackAssignment","setReferencesScope","fnRoot","lVal","babelBinding","referencePaths","constantViolations","isUpdateExpression","trackReferencesForBinding","patternBinding","element","propPath","isMemberExpression","getMemberExpressionPropString","isEventOrChangeHandler","exprRoot","exprExtra","addReadToExpression","fnExtra","mergeReferences","compareIntersections","lenDelta","derived","curBinding","dropReferences","getAllTagReferenceNodes","referenceNodes","includeId","shouldPrune","exprReference","resolveExpressionReference","readBinding","readProps","aliasProps","kDOMBinding","await_default","tagBody","valueAttr","tagExtra","isMarkoAttribute","isSpreadElement","bodySection","nodeRef2","import_compiler28","import_babel_utils13","client_default","rawValue","trim","parseStatements","markoScriptlet","rawOpenTag","import_compiler30","import_babel_utils14","import_compiler29","translateVar","initialValue","const_default","varBinding","derivation","import_compiler31","import_babel_utils15","debug_default","debuggerStatement","import_babel_utils21","import_compiler32","import_babel_utils16","attrTagToIdentifierLookup","getAttrTagIdentifier","meta","analyzeAttributeTags","attrTags2","lookup","attrTagNodesByName","sampleAttrTagsForControlFlow","createAttrTagMeta","isRepeated","isLoopTag","curGroup","crawlAttrTags","oldMeta","attrTagMeta","dynamic","repeated","controlFlowTag","sampleAttrName","attributeTagGroup","attrTagNodes","hasRepeatedDynamicAttrTags","attrTagNames","tagName","conditionRoot","seenBranches","attrTag2","curConditionRoot","getConditionRoot","getPrevSibling","import_compiler36","import_babel_utils20","import_compiler35","import_babel_utils19","import_babel_utils18","import_compiler33","import_babel_utils17","kNativeTagBinding","kSerializeMarker","kGetterId","htmlSelectArgs","getRelatedControllable","checked","checkedChange","special","helper","attrs","checkedValue","checkedValueChange","open","openChange","native_tag_default","escape","buildError","buildUndefined","hasEventHandlers","hasDynamicAttributes","seen","relatedControllable","spreadReferenceNodes","exclusiveGroups","assertExclusiveControllableGroups","tagName2","toIdentifier","bindingName","tagBinding","isHTML","write2","varName","getterId","hoist","getterFnIdentifier","visitAccessor","usedAttrs","maybeStaticAttrs","spreadExpression","skipExpression","spreadProps","skipProps","staticControllable","attr3","spreadElement","staticAttrs","reverse","propsToExpression","getUsedAttrs","writeAtStartOfBody","firstAttr","spreadIdentifier","valueReferences","htmlType","ifStatement","selectArgs","allExtras","shouldMark","kOnlyChildInParent","kNodeRef","isOnlyChildInParent","branchSize","getOptimizedOnlyChildNodeRef","parentTagName","for_default","isAttrTag","allowAttrs","getForType","LoopScopeMap","onlyChildInParentOptimization","forAttrs","forType","bodyStatements","sectionSources","singleNodeOptimization","forTagArgs","getBaseArgsInForTag","forTagHTMLRuntime","forTypeToHTMLResumeRuntime","forTypeToRuntime","by","forTypeToDOMRuntime","referencedBindings2","loopArgs","controlFlow","in","contentProps","translateAttrs","templateExports","contentKey","attrTagLookup","usesExport","addDynamicAttrTagStatements","translatedAttrTag","prevProp","findObjectProperty","contentExpression","isTransparentTag","getNonAttributeTagParent","buildContent","contentProp","getTranslatedBodyContentProperty","ifTag","consequentStatements","getConditionTestValue","addAllAttrTagsAsDynamic","nextTag","testValue","alternateStatements","translateIfAttrTag","forTag","buildForRuntimeCall","translateForAttrTag","define_default","translatedAttrs","import_compiler38","import_babel_utils22","effect_default","import_babel_utils23","export_default","import_compiler39","import_babel_utils24","kCommentTagBinding","kGetterId2","html_comment_default","needsBinding","needsGetter","isMarkoPlaceholder","isMarkoText","commentBinding","references","templateQuasis","templateExpressions","currentQuasi","text","import_compiler40","import_babel_utils25","kGetterId3","html_script_default","bodyPlaceholderNodes","hasBodyPlaceholders","getUsedAttrs2","referencePlaceholder","preserveWhitespace","import_compiler41","import_babel_utils26","kGetterId4","html_style_default","getUsedAttrs3","import_compiler42","import_babel_utils27","id_default","import_compiler44","import_babel_utils28","import_compiler43","BRANCHES_LOOKUP","IfTag","assertHasBody","assertHasValueAttribute","assertHasPrecedingCondition","ifAttr","msg","assertOptionalIfAttribute","assertValidCondition","isLast","branches","getBranches","rootTag","rootExtra","mergeReferenceNodes","branchTag","branchBodySection","ConditionalScope","isRoot","branchSources","branchSections","branchSection","first","merged","getDynamicSourcesForSections","getSourcesForBranches","hasHoists","hasHoistsInBranches","getNextSibling","testAttr","curStatement","conditionSerializeReason","cbNode","rendererIdentifiers","consequent","conditionalExpression","ElseIfTag","ElseTag","isMarkoComment","import_babel_utils29","import_default","import_compiler45","import_babel_utils30","let_default","valueChangeAttr","valueSection","import_compiler46","import_babel_utils31","kRef","lifecycle_default","lifecycleAttrsRef","import_compiler47","import_babel_utils32","log_default","import_compiler48","import_babel_utils33","htmlScriptTagAlternateMsg","script_default","valueFn","isAwaitExpression","seenValueAttr","isFunction2","inlineBody","hasDeclaration","isDeclaration","await","import_compiler49","import_babel_utils34","server_default","import_compiler50","import_babel_utils35","static_default","import_compiler51","import_babel_utils36","import_magic_string","import_path3","STYLE_EXT_REG","htmlStyleTagAlternateMsg","style_default","ext","sourceMaps","markoText","resolveVirtualDependency","getStart","getEnd","magicString","generateMap","includeContent","toUrl","importPath","virtualPath","basename","importDefaultSpecifier","import_compiler52","import_babel_utils37","kDOMBinding2","try_default","splice","core_default","cdata_default","cdata","comment_default","comment","declaration_default","document_type_default","documentType","import_compiler53","import_babel_utils38","functionIdsBySection","function_default","markoRoot","isVariableDeclarator","isObjectMethod","functionNameCounts","import_babel_utils39","import_declaration_default","importDecl","tagImport","tags","includes","import_compiler55","isNonHTMLText","placeholder","isMarkoTagBody","kBinding","kSiblingText","placeholder_default","isVoid2","placeholderExtra","contentType","analyzeSiblingText","valueExtra","nodeBinding","canWriteHTML","method","siblingText","import_compiler56","abortIdsByExpressionForSection","referenced_identifier_default","hasBinding","throwStatement","exprId","abortIdsByExpression","scriptlet_default","scriptlet","import_compiler60","import_babel_utils43","import_babel_utils40","attribute_tag_default","findParentTag","import_compiler58","import_babel_utils41","import_path4","kChildScopeBinding","kChildOffsetScopeBinding","kChildAttrExprs","custom_tag_default","assertAttributesOrSingleArg","getTagTemplate","charAt","toUpperCase","childProgramExtra","analyzeAttrs","tagIdentifier","relativePath","getTagRelativePath","isCircularRequest","getTemplateContentName","inputExport","childScopeBinding","peekScopeId","contentPath","renderTagExpr","callStatement","translateHTML","childExports","importOrSelfReferenceName","writeAttrsToExports","circular","attrTagCallsByTag","importNamed","injectWalks","translateDOM","rootTagExtra","nodeReferencesByGroup","analyzeDynamicChildGroup","groupReferences","firstTag","attrTagName","childAttrExports","childUsesGroupProp","importAlias","tagInputIdentifier","identifierToSignal","translatedProps","attrTagCallsForTag","attrTagCall","statementsByGroup","translateDynamicAttrTagChildInGroup","childAttrExport","decls","attrExportIdentifier","contentExportIdentifier","missing","getMissingPropValue","buildUndefined2","spreadId","request","nameHint","resolve","always","import_compiler59","import_babel_utils42","kDOMBinding3","kChildOffsetScopeBinding2","dynamic_tag_default","assertAttributesOrArgs","isClassAPI","tagExpression","hasMultipleArgs","dynamicTagExpr","dynamicScopeIdentifier","tagVarSignal","argsOrInput","isObjectExpression","TAG_NAME_IDENTIFIER_REG","BINDING_CHANGE_HANDLER","tag_default","bound","getChangeHandler","hook","analyzer","translator","watchFiles","modifier","tagNameId","tagNameVarPath","changeAttrName","buildChangeHandlerFunction","existingChangedAttr","changeHandlerAttr","changeHandlerId","changeHandlerConst","insertAfter","unshiftContainer","isPrivateName","cloneNode","newId","visitors","visitors2","_name","extractVisitors","Program","ReferencedIdentifier","ImportDeclaration","MarkoDocumentType","MarkoDeclaration","MarkoCDATA","MarkoText","MarkoTag","MarkoPlaceholder","MarkoScriptlet","MarkoComment"],"sourceRoot":""}