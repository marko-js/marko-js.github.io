{"version":3,"file":"420.43e24b47.js","mappings":"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","sources":["webpack:///../../node_modules/@marko/runtime-tags/dist/translator/index.js"],"sourcesContent":["\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name2 in all)\n    __defProp(target, name2, { get: all[name2], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/translator/index.ts\nvar translator_exports = {};\n__export(translator_exports, {\n  analyze: () => analyze,\n  getRuntimeEntryFiles: () => getRuntimeEntryFiles,\n  internalEntryBuilder: () => entry_builder_default,\n  preferAPI: () => preferAPI,\n  tagDiscoveryDirs: () => tagDiscoveryDirs,\n  taglibs: () => taglibs,\n  transform: () => transform,\n  translate: () => translate\n});\nmodule.exports = __toCommonJS(translator_exports);\n\n// src/translator/util/runtime-info.ts\nvar import_package = require(\"../../package.json\");\nvar runtime_info_default = {\n  name: import_package.name,\n  taglibId: \"marko-core\"\n};\n\n// src/translator/core/attrs.ts\nvar import_compiler = require(\"@marko/compiler\");\nvar import_babel_utils = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/assert.ts\nfunction assertNoSpreadAttrs(tag) {\n  for (const attr2 of tag.get(\"attributes\")) {\n    if (attr2.isMarkoSpreadAttribute()) {\n      throw attr2.buildCodeFrameError(\n        `The \\`${tag.get(\"name\").node.value}\\` tag does not support \\`...spread\\` attributes.`\n      );\n    }\n  }\n}\nfunction assertNoBodyContent(tag) {\n  if (tag.node.body.body.length) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${tag.get(\"name\").node.value}\\` tag does not support body content.`\n    );\n  }\n}\n\n// src/translator/core/attrs.ts\nvar attrs_default = {\n  migrate: [\n    (tag) => {\n      (0, import_babel_utils.assertNoArgs)(tag);\n      (0, import_babel_utils.assertNoParams)(tag);\n      (0, import_babel_utils.assertNoAttributes)(tag);\n      assertNoBodyContent(tag);\n      (0, import_babel_utils.assertNoAttributeTags)(tag);\n      (0, import_babel_utils.diagnosticDeprecate)(tag, {\n        label: \"The `attrs` tag is deprecated, prefer destructuring `input` via the `const` tag.\",\n        fix() {\n          const tagVar = tag.node.var;\n          if (tagVar && !(tagVar.type === \"Identifier\" && tagVar.name === \"input\")) {\n            const constTag = import_compiler.types.markoTag(\n              import_compiler.types.stringLiteral(\"const\"),\n              [import_compiler.types.markoAttribute(\"value\", import_compiler.types.identifier(\"input\"))],\n              import_compiler.types.markoTagBody([])\n            );\n            constTag.var = tagVar;\n            tag.replaceWith(constTag);\n          } else {\n            tag.remove();\n          }\n        }\n      });\n    }\n  ],\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"attrs/{ ... }\",\n      description: \"Use to receive the attributes passed into this template.\",\n      snippet: \"attrs/{ $1 }$2\"\n    }\n  ]\n};\n\n// src/translator/core/client.ts\nvar import_compiler2 = require(\"@marko/compiler\");\nvar import_babel_utils2 = require(\"@marko/compiler/babel-utils\");\nvar client_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^client\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils2.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler2.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler2.types.markoScriptlet(body, true, \"client\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"client <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the client.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#client-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/const.ts\nvar import_compiler24 = require(\"@marko/compiler\");\nvar import_babel_utils12 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/evaluate.ts\nvar import_babel_utils3 = require(\"@marko/compiler/babel-utils\");\nfunction evaluate(value) {\n  let { extra } = value;\n  if (!extra) {\n    extra = value.extra = {};\n  }\n  if (extra.confident === void 0) {\n    const computed = (0, import_babel_utils3.computeNode)(value);\n    if (computed) {\n      extra.computed = computed.value;\n      extra.confident = true;\n    } else {\n      extra.computed = void 0;\n      extra.confident = false;\n    }\n  }\n  return extra;\n}\n\n// src/translator/visitors/program/index.ts\nvar import_compiler22 = require(\"@marko/compiler\");\nvar import_babel_utils11 = require(\"@marko/compiler/babel-utils\");\nvar import_path = __toESM(require(\"path\"));\n\n// src/translator/util/binding-has-downstream-expressions.ts\nfunction bindingHasDownstreamExpressions(binding) {\n  if (binding.downstreamExpressions.size) return true;\n  for (const alias of binding.aliases) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  return false;\n}\n\n// src/translator/util/entry-builder.ts\nvar import_compiler3 = require(\"@marko/compiler\");\nvar import_babel_utils4 = require(\"@marko/compiler/babel-utils\");\nvar kState = Symbol();\nvar entry_builder_default = {\n  build(entryFile) {\n    const state = entryFile[kState];\n    if (!state) {\n      throw entryFile.path.buildCodeFrameError(\n        \"Unable to build hydrate code, no files were visited before finalizing the build\"\n      );\n    }\n    const body = state.imports.map(\n      (it) => import_compiler3.types.importDeclaration([], import_compiler3.types.stringLiteral(it))\n    );\n    if (state.init) {\n      body.unshift(\n        import_compiler3.types.importDeclaration(\n          [import_compiler3.types.importSpecifier(import_compiler3.types.identifier(\"init\"), import_compiler3.types.identifier(\"init\"))],\n          import_compiler3.types.stringLiteral(\n            `${runtime_info_default.name}/${entryFile.markoOpts.optimize ? \"\" : \"debug/\"}dom`\n          )\n        )\n      );\n      body.push(\n        import_compiler3.types.expressionStatement(import_compiler3.types.callExpression(import_compiler3.types.identifier(\"init\"), []))\n      );\n    }\n    return body;\n  },\n  visit(file, entryFile, visitChild) {\n    const state = entryFile[kState] ||= {\n      imports: [],\n      init: false\n    };\n    const { analyzedTags } = file.metadata.marko;\n    state.imports.push(\n      (0, import_babel_utils4.resolveRelativePath)(entryFile, file.opts.filename)\n    );\n    state.init ||= file.path.node.extra.hasInteractiveChild || file.path.node.extra.isInteractive || false;\n    for (const tag of analyzedTags || []) {\n      visitChild(tag);\n    }\n  }\n};\n\n// src/translator/util/references.ts\nvar import_compiler7 = require(\"@marko/compiler\");\n\n// src/translator/util/for-each-identifier.ts\nfunction forEachIdentifier(node, cb) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        switch (prop.type) {\n          case \"ObjectProperty\":\n            if (prop.value.type === \"AssignmentPattern\") {\n              forEachIdentifier(prop.value.left, cb);\n            } else {\n              forEachIdentifier(prop.value, cb);\n            }\n            break;\n          case \"RestElement\":\n            forEachIdentifier(prop.argument, cb);\n            break;\n        }\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const el of node.elements) {\n        if (el != null) {\n          switch (el.type) {\n            case \"RestElement\":\n              forEachIdentifier(el.argument, cb);\n              break;\n            case \"AssignmentPattern\":\n              forEachIdentifier(el.left, cb);\n              break;\n            default:\n              forEachIdentifier(el, cb);\n              break;\n          }\n        }\n      }\n      break;\n    case \"Identifier\":\n      cb(node);\n      break;\n  }\n}\n\n// src/translator/util/get-root.ts\nfunction getMarkoRoot(path4) {\n  let curPath = path4;\n  do\n    curPath = curPath.parentPath;\n  while (curPath && !isMarko(curPath));\n  return curPath;\n}\nfunction getExprRoot(path4) {\n  let curPath = path4;\n  while (!isMarko(curPath.parentPath)) {\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction getFnRoot(path4) {\n  let curPath = path4;\n  if (curPath.isProgram()) return;\n  while (!isFunctionExpression(curPath)) {\n    if (isMarko(curPath)) return;\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction isMarko(path4) {\n  switch (path4.type) {\n    case \"MarkoTag\":\n    case \"MarkoTagBody\":\n    case \"MarkoAttribute\":\n    case \"MarkoSpreadAttribute\":\n    case \"MarkoPlaceholder\":\n    case \"MarkoScriptlet\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isFunctionExpression(path4) {\n  switch (path4.type) {\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// src/translator/util/is-stateful.ts\nfunction isStatefulReferences(referencedBindings) {\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        if (isStatefulBinding(ref)) {\n          return true;\n        }\n      }\n    } else {\n      return isStatefulBinding(referencedBindings);\n    }\n  }\n  return false;\n}\nfunction isStatefulBinding(binding) {\n  switch (binding.type) {\n    case 1 /* let */:\n    case 2 /* input */:\n      return true;\n    default:\n      return !binding.upstreamExpression || isStatefulReferences(binding.upstreamExpression.referencedBindings);\n  }\n}\n\n// src/translator/util/optional.ts\nvar Sorted = class {\n  constructor(compare) {\n    this.compare = compare;\n  }\n  add(data, item) {\n    return data ? Array.isArray(data) ? addSorted(this.compare, data, item) : joinRepeatable(this.compare, data, item) : item;\n  }\n  union(a, b) {\n    if (a) {\n      if (Array.isArray(a)) {\n        if (b) {\n          if (Array.isArray(b)) {\n            return unionSortedRepeatable(this.compare, a, b);\n          } else {\n            return addSorted(this.compare, a, b);\n          }\n        }\n        return a;\n      }\n      if (b) {\n        if (Array.isArray(b)) {\n          return addSorted(this.compare, [...b], a);\n        }\n        return joinRepeatable(this.compare, b, a);\n      }\n      return a;\n    }\n    return b;\n  }\n  find(data, item) {\n    if (data) {\n      if (Array.isArray(data)) {\n        return findSorted(this.compare, data, item);\n      } else if (this.compare(data, item) === 0) {\n        return data;\n      }\n    }\n  }\n};\nfunction push(data, item) {\n  if (data) {\n    if (Array.isArray(data)) {\n      data.push(item);\n      return data;\n    }\n    return [data, item];\n  }\n  return item;\n}\nfunction concat(a, b) {\n  if (a) {\n    if (b) {\n      if (Array.isArray(a)) {\n        return a.concat(b);\n      } else if (Array.isArray(b)) {\n        return [a, ...b];\n      } else {\n        return [a, b];\n      }\n    }\n    return a;\n  }\n  return b;\n}\nfunction filter(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      const len = data.length;\n      let result;\n      let i = 0;\n      while (i < len) {\n        let item = data[i++];\n        if (cb(item)) {\n          result = item;\n          while (i < len) {\n            item = data[i++];\n            if (cb(item)) {\n              result = [result, item];\n              while (i < len) {\n                item = data[i++];\n                if (cb(item)) {\n                  result.push(item);\n                }\n              }\n              return result;\n            }\n          }\n          return result;\n        }\n      }\n      return result;\n    }\n    if (cb(data)) {\n      return data;\n    }\n  }\n  return void 0;\n}\nfunction forEach(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      let i = 0;\n      for (const item of data) {\n        cb(item, i++);\n      }\n    } else {\n      cb(data, 0);\n    }\n  }\n}\nfunction find(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      return data.find(cb);\n    }\n    if (cb(data, 0)) {\n      return data;\n    }\n  }\n}\nfunction map(data, cb) {\n  return data ? Array.isArray(data) ? data.map(cb) : [cb(data, 0)] : [];\n}\nfunction findSorted(compare, data, item) {\n  let max = data.length;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const cur = data[mid];\n    const compareResult = compare(cur, item);\n    if (compareResult === 0) return cur;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n}\nfunction addSorted(compare, data, item) {\n  const len = data.length;\n  let max = len;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(data[mid], item);\n    if (compareResult === 0) return data;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n  const result = new Array(len + 1);\n  for (let i = 0; i < pos; i++) {\n    result[i] = data[i];\n  }\n  let cur = item;\n  while (pos < len) {\n    const next = cur;\n    cur = data[pos];\n    result[pos++] = next;\n  }\n  result[len] = cur;\n  return result;\n}\nfunction unionSortedRepeatable(compare, a, b) {\n  const aLen = a.length;\n  const bLen = b.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  const result = [];\n  while (aIndex < aLen && bIndex < bLen) {\n    const aValue = a[aIndex];\n    const bValue = b[bIndex];\n    const delta = compare(aValue, bValue);\n    if (delta === 0) {\n      aIndex++;\n      bIndex++;\n      result.push(aValue);\n    } else if (delta < 0) {\n      aIndex++;\n      result.push(aValue);\n    } else {\n      bIndex++;\n      result.push(bValue);\n    }\n  }\n  if (aLen === bLen && aIndex === aLen) {\n    return a;\n  }\n  while (aIndex < aLen) {\n    result.push(a[aIndex++]);\n  }\n  while (bIndex < bLen) {\n    result.push(b[bIndex++]);\n  }\n  return result;\n}\nfunction joinRepeatable(compare, a, b) {\n  const compareResult = compare(a, b);\n  return compareResult === 0 ? a : compareResult < 0 ? [a, b] : [b, a];\n}\n\n// src/translator/util/sections.ts\nvar import_compiler5 = require(\"@marko/compiler\");\nvar import_babel_utils7 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/is-core-tag.ts\nvar import_babel_utils5 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-tag-name.ts\nfunction getTagName(tag) {\n  return tag.node.name.value;\n}\n\n// src/translator/util/is-core-tag.ts\nvar { taglibId } = runtime_info_default;\nvar htmlTaglibId = \"marko-html\";\nvar interopTaglibId = \"@marko/translator-interop-class-tags\";\nfunction isCoreTag(tag) {\n  if (tag.isMarkoTag()) {\n    const tagDef = (0, import_babel_utils5.getTagDef)(tag);\n    if (tagDef) {\n      switch (tagDef.taglibId) {\n        case taglibId:\n        case interopTaglibId:\n          return true;\n        case htmlTaglibId:\n          switch (tagDef.name) {\n            case \"script\":\n            case \"style\":\n              return true;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\nfunction isCoreTagName(tag, name2) {\n  return isCoreTag(tag) && getTagName(tag) === name2;\n}\nfunction isConditionTag(tag) {\n  if (isCoreTag(tag)) {\n    switch (getTagName(tag)) {\n      case \"if\":\n      case \"else-if\":\n      case \"else\":\n        return true;\n    }\n  }\n  return false;\n}\n\n// src/translator/util/state.ts\nvar createProgramState = (init) => {\n  const map2 = /* @__PURE__ */ new WeakMap();\n  return [\n    () => {\n      let state = map2.get(currentProgramPath);\n      if (!state) {\n        map2.set(currentProgramPath, state = init());\n      }\n      return state;\n    },\n    (value) => {\n      map2.set(currentProgramPath, value);\n    }\n  ];\n};\nfunction createSectionState(key, init) {\n  return [\n    (section) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      const sectionData = arrayOfSectionData[section.id] ??= init && init(section);\n      return sectionData;\n    },\n    (section, value) => {\n      const arrayOfSectionData = currentProgramPath.state[key] ??= {};\n      arrayOfSectionData[section.id] = value;\n    }\n  ];\n}\n\n// src/translator/util/tag-name-type.ts\nvar import_compiler4 = require(\"@marko/compiler\");\nvar import_babel_utils6 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/with-previous-location.ts\nfunction withPreviousLocation(newNode, originalNode) {\n  newNode.start = originalNode.start;\n  newNode.loc = originalNode.loc;\n  newNode.end = originalNode.end;\n  return newNode;\n}\n\n// src/translator/util/tag-name-type.ts\nvar MARKO_FILE_REG = /^<.*>$|\\.marko$/;\nvar TAG_NAME_IDENTIFIER_REG = /^[A-Z][a-zA-Z0-9_$]*$/;\nfunction analyzeTagNameType(tag) {\n  const extra = tag.node.extra ??= {};\n  if (extra.tagNameType === void 0) {\n    const name2 = tag.get(\"name\");\n    if (name2.isStringLiteral()) {\n      extra.tagNameType = name2.node.value[0] === \"@\" ? 3 /* AttributeTag */ : (0, import_babel_utils6.isNativeTag)(tag) ? 0 /* NativeTag */ : 1 /* CustomTag */;\n      if (extra.tagNameType === 1 /* CustomTag */) {\n        const bindingName = name2.node.value;\n        const bindingIdentifier = tag.scope.getBinding(bindingName)?.identifier;\n        if (bindingIdentifier && TAG_NAME_IDENTIFIER_REG.test(bindingIdentifier.name)) {\n          const tagIdentifier = withPreviousLocation(\n            import_compiler4.types.identifier(bindingName),\n            name2.node\n          );\n          tagIdentifier.extra = {\n            referencedBindings: bindingIdentifier.extra?.binding\n          };\n          analyzeExpressionTagName(name2.replaceWith(tagIdentifier)[0], extra);\n        }\n      }\n      extra.tagNameNullable = extra.tagNameNullable = false;\n    } else {\n      analyzeExpressionTagName(name2, extra);\n    }\n    if (extra.tagNameType === void 0) {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n    if (extra.tagNameType === 1 /* CustomTag */) {\n      const childFile = (0, import_babel_utils6.loadFileForTag)(tag);\n      if (!childFile) {\n        extra.tagNameType = 2 /* DynamicTag */;\n      } else if (childFile.ast.program.extra.featureType === \"class\") {\n        extra.tagNameType = 2 /* DynamicTag */;\n        extra.featureType = \"class\";\n        (currentProgramPath.node.extra ??= {}).needsCompat = true;\n      }\n    }\n  }\n  return extra.tagNameType;\n}\nfunction analyzeExpressionTagName(name2, extra) {\n  const pending = [name2];\n  let path4;\n  let type;\n  let nullable = false;\n  let tagNameImported;\n  while ((path4 = pending.pop()) && type !== 2 /* DynamicTag */) {\n    if (path4.isConditionalExpression()) {\n      pending.push(path4.get(\"consequent\"));\n      if (path4.node.alternate) {\n        pending.push(path4.get(\"alternate\"));\n      }\n    } else if (path4.isLogicalExpression()) {\n      if (path4.node.operator === \"||\") {\n        pending.push(path4.get(\"left\"));\n      } else {\n        nullable = true;\n      }\n      pending.push(path4.get(\"right\"));\n    } else if (path4.isAssignmentExpression()) {\n      pending.push(path4.get(\"right\"));\n    } else if (path4.isBinaryExpression()) {\n      type = path4.node.operator !== \"+\" || type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path4.isStringLiteral() || path4.isTemplateLiteral()) {\n      type = type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path4.isNullLiteral()) {\n      nullable = true;\n    } else if (path4.isIdentifier()) {\n      if (path4.node.name === \"undefined\") {\n        nullable = true;\n        continue;\n      }\n      const binding = path4.scope.getBinding(path4.node.name);\n      if (!binding) {\n        type = 2 /* DynamicTag */;\n        continue;\n      }\n      if (binding.kind === \"module\") {\n        const decl = binding.path.parent;\n        if (MARKO_FILE_REG.test(decl.source.value) && decl.specifiers.some((it) => import_compiler4.types.isImportDefaultSpecifier(it))) {\n          const resolvedImport = (0, import_babel_utils6.resolveTagImport)(name2, decl.source.value) || decl.source.value;\n          if (type === 0 /* NativeTag */ || tagNameImported && tagNameImported !== resolvedImport) {\n            type = 2 /* DynamicTag */;\n            tagNameImported = void 0;\n          } else {\n            type = 1 /* CustomTag */;\n            tagNameImported = resolvedImport;\n          }\n        } else {\n          type = 2 /* DynamicTag */;\n        }\n        continue;\n      }\n      const bindingTag = binding.path;\n      if (bindingTag.isMarkoTag() && binding.kind === \"local\") {\n        const bindingTagName = bindingTag.get(\"name\").node.value;\n        if (bindingTagName === \"const\") {\n          pending.push(\n            bindingTag.get(\"attributes\")[0].get(\"value\")\n          );\n          continue;\n        }\n        if (bindingTagName === \"let\") {\n          type = 2 /* DynamicTag */;\n          continue;\n        }\n        continue;\n      }\n      type = 2 /* DynamicTag */;\n    } else {\n      type = 2 /* DynamicTag */;\n    }\n  }\n  extra.tagNameType = type;\n  extra.tagNameNullable = nullable;\n  extra.tagNameDynamic = true;\n  if (type === 1 /* CustomTag */ && tagNameImported) {\n    extra.tagNameImported = tagNameImported;\n  }\n}\n\n// src/translator/util/sections.ts\nfunction startSection(path4) {\n  const extra = path4.node.extra ??= {};\n  let section = extra.section;\n  if (!section && (path4.type === \"Program\" || path4.get(\"body\").length)) {\n    const parentSection = path4.parentPath ? getOrCreateSection(path4.parentPath) : void 0;\n    const sectionNamePath = path4.parentPath?.get(\n      \"name\"\n    );\n    const sectionName = path4.isProgram() ? \"\" : currentProgramPath.scope.generateUid(\n      sectionNamePath.toString() + \"_content\"\n    );\n    const programExtra = path4.hub.file.path.node.extra ??= {};\n    const sections = programExtra.sections ??= [];\n    section = extra.section = {\n      id: sections.length,\n      name: sectionName,\n      depth: parentSection ? parentSection.depth + 1 : 0,\n      parent: parentSection,\n      params: void 0,\n      closures: void 0,\n      bindings: void 0,\n      content: getContentInfo(path4),\n      upstreamExpression: void 0,\n      hasCleanup: false\n    };\n    sections.push(section);\n  }\n  return section;\n}\nfunction getOrCreateSection(path4) {\n  let cur = path4;\n  while (true) {\n    if (cur.type === \"Program\" || cur.type === \"MarkoTagBody\" && !cur.node.attributeTags && analyzeTagNameType(cur.parentPath) !== 0 /* NativeTag */ && cur.parent.name.value !== \"html-comment\") {\n      return startSection(cur);\n    }\n    cur = cur.parentPath;\n  }\n}\nfunction getSectionForBody(body) {\n  return body.node.extra?.section;\n}\nfunction getSection(path4) {\n  let section;\n  let currentPath = path4;\n  while ((section = currentPath.node.extra?.section) === void 0) {\n    currentPath = currentPath.parentPath;\n  }\n  return section;\n}\nvar [getScopeIdIdentifier] = createSectionState(\n  \"scopeIdIdentifier\",\n  (section) => currentProgramPath.scope.generateUidIdentifier(`scope${section.id}_id`)\n);\nvar [getSectionParentIsOwner, setSectionParentIsOwner] = createSectionState(\"parentIsOwner\", () => false);\nvar [_getScopeIdentifier] = createSectionState(\n  \"scopeIdentifier\",\n  () => import_compiler5.types.identifier(\"undefined\")\n);\nvar getScopeIdentifier = (section, ignoreDefault) => {\n  const scopeId = _getScopeIdentifier(section);\n  if (!ignoreDefault && scopeId.name === \"undefined\") {\n    scopeId.name = currentProgramPath.scope.generateUid(`scope${section.id}_`);\n  }\n  return scopeId;\n};\nfunction forEachSection(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  sections?.forEach(fn);\n}\nfunction forEachSectionReverse(fn) {\n  const { sections } = currentProgramPath.node.extra;\n  for (let i = sections.length; i--; ) {\n    fn(sections[i]);\n  }\n}\nfunction getContentInfo(path4) {\n  const body = path4.get(\"body\");\n  const contentInfo = {\n    startType: null,\n    endType: null,\n    singleChild: true\n  };\n  for (let endIndex = body.length; endIndex--; ) {\n    const endType = getNodeContentType(body[endIndex], \"endType\", contentInfo);\n    if (endType !== null) {\n      contentInfo.endType = endType;\n      for (let startIndex = 0; startIndex < endIndex; startIndex++) {\n        const startType = getNodeContentType(body[startIndex], \"startType\");\n        if (startType !== null) {\n          contentInfo.startType = startType;\n          contentInfo.singleChild = false;\n          return contentInfo;\n        }\n      }\n      contentInfo.startType = getNodeContentType(body[endIndex], \"startType\");\n      return contentInfo;\n    }\n  }\n  return null;\n}\nfunction getNodeContentType(path4, extraMember, contentInfo) {\n  switch (path4.type) {\n    case \"MarkoText\":\n      return 4 /* Text */;\n    case \"MarkoPlaceholder\":\n      return 2 /* Placeholder */;\n    case \"MarkoScriptlet\":\n    case \"MarkoComment\":\n    case \"ImportDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportNamedDeclaration\":\n      return null;\n    case \"MarkoTag\": {\n      const tag = path4;\n      if (isCoreTag(tag)) {\n        switch (tag.node.name.value) {\n          case \"html-comment\":\n            return 0 /* Comment */;\n          case \"html-script\":\n          case \"html-style\":\n            return 3 /* Tag */;\n          case \"for\":\n          case \"if\":\n            return 1 /* Dynamic */;\n          default:\n            return null;\n        }\n      } else if ((0, import_babel_utils7.isNativeTag)(tag)) {\n        return 3 /* Tag */;\n      } else if ((0, import_babel_utils7.isAttributeTag)(tag)) {\n        return null;\n      } else if (import_compiler5.types.isStringLiteral(tag.node.name)) {\n        const tagSection = (0, import_babel_utils7.loadFileForTag)(tag)?.ast.program.extra.section;\n        if (tagSection) {\n          if (tagSection.content) {\n            if (contentInfo && !tagSection.content.singleChild) {\n              if (extraMember === \"endType\") {\n                contentInfo.startType = tagSection.content.startType;\n                contentInfo.singleChild = false;\n              }\n            }\n            return tagSection.content[extraMember];\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n  }\n  return 1 /* Dynamic */;\n}\nvar isStatefulSection = (section) => {\n  const upstreamExpression = section.upstreamExpression;\n  return !upstreamExpression || isStatefulReferences(upstreamExpression.referencedBindings);\n};\nvar checkStatefulClosures = (section, immediateOnly) => {\n  return !!find(\n    section.closures,\n    (closure) => (!immediateOnly || section.parent === closure.section) && isStatefulReferences(closure)\n  );\n};\n\n// src/translator/util/to-property-name.ts\nvar import_compiler6 = require(\"@marko/compiler\");\nfunction toPropertyName(name2) {\n  if (/^[a-z_$][a-z0-9_$]*$/i.test(name2)) {\n    return import_compiler6.types.identifier(name2);\n  } else if (/^(?:0|[1-9][0-9]*)$/.test(name2)) {\n    return import_compiler6.types.numericLiteral(parseInt(name2, 10));\n  }\n  return import_compiler6.types.stringLiteral(name2);\n}\nfunction toObjectProperty(name2, value) {\n  return import_compiler6.types.objectProperty(toPropertyName(name2), value);\n}\nfunction toMemberExpression(object, key, optional) {\n  const prop = toPropertyName(key);\n  const computed = prop.type !== \"Identifier\";\n  return optional ? import_compiler6.types.optionalMemberExpression(object, prop, computed, true) : import_compiler6.types.memberExpression(object, prop, computed);\n}\n\n// src/translator/util/references.ts\nvar [getBindings] = createProgramState(() => /* @__PURE__ */ new Set());\nvar [getNextBindingId, setNextBindingId] = createProgramState(() => 0);\nfunction createBinding(name2, type, section, upstreamAlias, upstreamExpression, property, declared = false) {\n  const id = getNextBindingId();\n  const binding = {\n    id,\n    name: name2,\n    type,\n    section,\n    property,\n    declared,\n    excludeProperties: void 0,\n    serialize: false,\n    aliases: /* @__PURE__ */ new Set(),\n    propertyAliases: /* @__PURE__ */ new Map(),\n    upstreamAlias,\n    upstreamExpression,\n    downstreamExpressions: /* @__PURE__ */ new Set(),\n    export: void 0,\n    nullable: !upstreamExpression?.confident || upstreamExpression.computed == null\n  };\n  if (property) {\n    if (declared) upstreamAlias.nullable = false;\n    const propBinding = upstreamAlias.propertyAliases.get(property);\n    if (propBinding) {\n      binding.property = void 0;\n      binding.upstreamAlias = propBinding;\n      propBinding.aliases.add(binding);\n    } else {\n      upstreamAlias.propertyAliases.set(property, binding);\n    }\n  } else if (upstreamAlias) {\n    upstreamAlias.aliases.add(binding);\n  }\n  setNextBindingId(id + 1);\n  getBindings().add(binding);\n  return binding;\n}\nfunction trackVarReferences(tag, type, upstreamAlias, upstreamExpression) {\n  const tagVar = tag.node.var;\n  if (tagVar) {\n    const section = getOrCreateSection(tag);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    if (upstreamAlias && upstreamExpression) upstreamExpression.pruned = true;\n    createBindingsAndTrackReferences(\n      tagVar,\n      type,\n      tag.scope,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0\n    );\n  }\n}\nfunction trackParamsReferences(body, type, upstreamAlias, upstreamExpression) {\n  const params = body.node.params;\n  if (body.node.body.length && params.length) {\n    if (upstreamAlias && upstreamExpression) upstreamExpression.pruned = true;\n    const section = getOrCreateSection(body);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    const paramsBinding = canonicalUpstreamAlias || ((body.node.extra ??= {}).binding = createBinding(\n      currentProgramPath.scope.generateUid(\"params_\"),\n      type,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0\n    ));\n    section.params = paramsBinding;\n    for (let i = 0; i < params.length; i++) {\n      createBindingsAndTrackReferences(\n        params[i],\n        type,\n        body.scope,\n        section,\n        paramsBinding,\n        void 0,\n        i + \"\"\n      );\n    }\n  }\n}\nfunction trackReferencesForBinding(babelBinding) {\n  const { identifier, referencePaths, constantViolations } = babelBinding;\n  const binding = identifier.extra.binding;\n  for (const referencePath of referencePaths) {\n    trackReference(referencePath, binding);\n  }\n  for (const ref of constantViolations) {\n    if (ref.isUpdateExpression()) {\n      trackAssignment(ref.get(\"argument\"), binding);\n    } else if (ref.isAssignmentExpression()) {\n      trackAssignment(ref.get(\"left\"), binding);\n      if (ref.node.operator !== \"=\") {\n        const left = ref.get(\"left\");\n        if (left.isIdentifier()) {\n          trackReference(left, binding);\n        }\n      }\n    }\n  }\n}\nfunction trackAssignment(assignment, binding) {\n  const section = getOrCreateSection(assignment);\n  setReferencesScope(assignment);\n  forEachIdentifier(assignment.node, (id) => {\n    if (id.name === binding.name) {\n      const extra = id.extra ??= {};\n      extra.assignment = binding;\n      extra.section = section;\n    }\n  });\n}\nfunction setReferencesScope(path4) {\n  let fnRoot = getFnRoot(path4);\n  while (fnRoot) {\n    (fnRoot.node.extra ??= {}).referencesScope = true;\n    fnRoot = getFnRoot(fnRoot.parentPath);\n  }\n}\nfunction createBindingsAndTrackReferences(lVal, type, scope, section, upstreamAlias, upstreamExpression, property) {\n  switch (lVal.type) {\n    case \"Identifier\":\n      (lVal.extra ??= {}).binding = createBinding(\n        lVal.name,\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property,\n        true\n      );\n      trackReferencesForBinding(scope.getBinding(lVal.name));\n      break;\n    case \"ObjectPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        currentProgramPath.scope.generateUid(\"pattern_\"),\n        type,\n        section,\n        upstreamAlias,\n        void 0,\n        property\n      ));\n      for (const prop of lVal.properties) {\n        if (prop.type === \"RestElement\") {\n          createBindingsAndTrackReferences(\n            prop.argument,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            property\n          );\n        } else {\n          let key;\n          if (prop.key.type === \"Identifier\") {\n            key = prop.key.name;\n          } else if (prop.key.type === \"StringLiteral\") {\n            key = prop.key.value;\n          } else {\n            throw new Error(\"computed keys not supported in object pattern\");\n          }\n          createBindingsAndTrackReferences(\n            prop.value,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            key\n          );\n        }\n      }\n      break;\n    }\n    case \"ArrayPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        currentProgramPath.scope.generateUid(\"pattern_\"),\n        type,\n        section,\n        upstreamAlias,\n        void 0,\n        property\n      ));\n      let i = -1;\n      for (const element of lVal.elements) {\n        i++;\n        if (element) {\n          if (element.type === \"RestElement\") {\n            createBindingsAndTrackReferences(\n              element.argument,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              property\n            );\n          } else {\n            createBindingsAndTrackReferences(\n              element,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              `${i}`\n            );\n          }\n        }\n      }\n      break;\n    }\n    case \"AssignmentPattern\":\n      createBindingsAndTrackReferences(\n        lVal.left,\n        type,\n        scope,\n        section,\n        upstreamAlias,\n        void 0,\n        property\n      );\n      break;\n  }\n}\nfunction trackReference(referencePath, binding) {\n  let root = referencePath;\n  let reference = binding;\n  let propPath = binding.name;\n  while (true) {\n    const { parent } = root;\n    if (!import_compiler7.types.isMemberExpression(parent)) break;\n    const prop = getMemberExpressionPropString(parent);\n    if (prop === void 0) break;\n    if (reference.propertyAliases.has(prop)) {\n      root = root.parentPath;\n      reference = reference.propertyAliases.get(prop);\n      propPath = reference.name;\n      continue;\n    }\n    if (root.parentPath.parentPath.isCallExpression() && !isEventOrChangeHandler(prop)) {\n      break;\n    }\n    root = root.parentPath;\n    reference = createBinding(\n      propPath += `_${prop.replace(/[^a-zA-Z0-9_$]/g, \"_\")}`,\n      reference.type,\n      reference.section,\n      reference,\n      void 0,\n      prop\n    );\n  }\n  const fnRoot = getFnRoot(root);\n  const exprRoot = getExprRoot(fnRoot || root);\n  const { section } = addReadToExpression(exprRoot, reference, root.node);\n  if (fnRoot) {\n    const readsByFn = getReadsByFunction();\n    const fnExtra = fnRoot.node.extra ??= {};\n    fnExtra.section = section;\n    readsByFn.set(\n      fnExtra,\n      push(readsByFn.get(fnExtra), {\n        binding: reference,\n        node: root.node\n      })\n    );\n  }\n}\nvar [getMergedReferences] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction mergeReferences(section, target, nodes) {\n  (target.extra ??= {}).section = section;\n  getMergedReferences().set(target, nodes);\n}\nfunction compareIntersections(a, b) {\n  const len = a.length;\n  const lenDelta = len - b.length;\n  if (lenDelta !== 0) {\n    return lenDelta;\n  }\n  for (let i = 0; i < len; i++) {\n    const compareResult = bindingUtil.compare(a[i], b[i]);\n    if (compareResult !== 0) {\n      return compareResult;\n    }\n  }\n  return 0;\n}\nfunction finalizeReferences() {\n  const bindings = getBindings();\n  const readsByExpression = getReadsByExpression();\n  const readsByFn = getReadsByFunction();\n  const mergedReferences = getMergedReferences();\n  if (mergedReferences.size) {\n    for (const [target, nodes] of mergedReferences) {\n      const targetExtra = target.extra;\n      let reads = readsByExpression.get(targetExtra);\n      let { isEffect } = targetExtra;\n      for (const node of nodes) {\n        const extra = node?.extra;\n        if (isReferencedExtra(extra)) {\n          isEffect ||= extra.isEffect;\n          const additionalReads = readsByExpression.get(extra);\n          if (additionalReads) {\n            reads = concat(reads, additionalReads);\n            readsByExpression.delete(extra);\n          }\n        }\n      }\n      readsByExpression.set(targetExtra, reads);\n      targetExtra.isEffect = isEffect;\n    }\n  }\n  const intersectionsBySection = /* @__PURE__ */ new Map();\n  for (const [expr, reads] of readsByExpression) {\n    if (isReferencedExtra(expr)) {\n      expr.referencedBindings = resolveReferencedBindings(\n        expr,\n        reads,\n        intersectionsBySection\n      );\n      forEach(expr.referencedBindings, (binding) => {\n        binding.downstreamExpressions.add(expr);\n      });\n    }\n  }\n  for (const [fn, reads] of readsByFn) {\n    fn.referencedBindingsInFunction = resolveReferencedBindings(\n      fn,\n      reads,\n      intersectionsBySection\n    );\n    forEach(fn.referencedBindingsInFunction, (binding) => {\n      binding.serialize = true;\n    });\n  }\n  for (const binding of bindings) {\n    if (binding.type !== 0 /* dom */ && !binding.upstreamAlias) {\n      pruneBinding(bindings, binding);\n    }\n  }\n  for (const binding of bindings) {\n    const { name: name2, section } = binding;\n    if (binding.type !== 0 /* dom */) {\n      if (find(section.bindings, ({ name: name3 }) => name3 === binding.name)) {\n        binding.name = currentProgramPath.scope.generateUid(name2);\n      }\n    }\n    section.bindings = bindingUtil.add(section.bindings, binding);\n    for (const {\n      referencedBindings,\n      isEffect,\n      section: section2\n    } of binding.downstreamExpressions) {\n      if (section2 !== binding.section) {\n        section2.closures = bindingUtil.add(section2.closures, binding);\n      }\n      if (isEffect) {\n        forEach(referencedBindings, (bindingReference) => {\n          bindingReference.serialize = true;\n        });\n      }\n    }\n  }\n  forEachSection((section) => {\n    const intersections = intersectionsBySection.get(section);\n    if (intersections) {\n      for (const intersection of intersections) {\n        const numReferences = intersection.length;\n        for (let i = 0; i < numReferences - 1; i++) {\n          for (let j = i + 1; j < numReferences; j++) {\n            const binding1 = intersection[i];\n            const binding2 = intersection[j];\n            const sources1 = getSourceBindings(binding1);\n            const sources2 = getSourceBindings(binding2);\n            if (!binding1.serialize && !isSuperset(sources1, sources2)) {\n              binding1.serialize = true;\n            }\n            if (!binding2.serialize && !isSuperset(sources2, sources1)) {\n              binding2.serialize = true;\n            }\n          }\n        }\n      }\n    }\n    forEach(section.closures, (binding) => {\n      if (!binding.serialize) {\n        let serialize = false;\n        const sourceSection = binding.section;\n        let currentSection = section;\n        while (currentSection !== sourceSection && !(serialize = !currentSection.upstreamExpression || isStatefulReferences(\n          currentSection.upstreamExpression.referencedBindings\n        ))) {\n          currentSection = currentSection.parent;\n        }\n        binding.serialize = serialize;\n      }\n    });\n  });\n  forEachSection(({ id, bindings: bindings2 }) => {\n    forEach(\n      filter(bindings2, ({ section }) => section.id === id),\n      (binding, i) => {\n        binding.id = i;\n      }\n    );\n  });\n  mergedReferences.clear();\n  readsByExpression.clear();\n  readsByFn.clear();\n}\nfunction isSuperset(set, subset) {\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getSourceBindings(binding) {\n  const derived = /* @__PURE__ */ new Set();\n  const sources = /* @__PURE__ */ new Set();\n  crawl(binding);\n  return sources;\n  function crawl(binding2) {\n    if (binding2.type === 4 /* derived */ || binding2.type === 3 /* param */) {\n      let alias;\n      let curBinding = binding2;\n      while (alias = curBinding.upstreamAlias) {\n        curBinding = alias;\n      }\n      if (curBinding.upstreamExpression) {\n        if (derived.has(curBinding)) return;\n        derived.add(curBinding);\n        forEach(curBinding.upstreamExpression.referencedBindings, crawl);\n      } else {\n        sources.add(curBinding);\n      }\n    } else {\n      sources.add(binding2);\n    }\n  }\n}\nvar bindingUtil = new Sorted(function compareBindings(a, b) {\n  return a.section.id - b.section.id || a.type !== b.type && (a.type === 0 /* dom */ || b.type === 0 /* dom */) ? a.type - b.type || a.id - b.id : a.id - b.id;\n});\nvar [getReadsByExpression] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nvar [getReadsByFunction] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction addReadToExpression(path4, binding, node) {\n  const exprExtra = path4.node.extra ??= {};\n  const readsByExpression = getReadsByExpression();\n  exprExtra.section = getOrCreateSection(path4);\n  readsByExpression.set(\n    exprExtra,\n    push(readsByExpression.get(exprExtra), { binding, node })\n  );\n  return exprExtra;\n}\nfunction dropReferences(node) {\n  if (Array.isArray(node)) {\n    for (const item of node) {\n      (item.extra ??= {}).pruned = true;\n    }\n  } else {\n    (node.extra ??= {}).pruned = true;\n  }\n}\nfunction getCanonicalBinding(binding) {\n  return binding && (binding.property ? binding : binding.upstreamAlias || binding);\n}\nfunction getAllTagReferenceNodes(tag, referenceNodes = []) {\n  if (tag.arguments) {\n    for (const arg of tag.arguments) {\n      referenceNodes.push(arg);\n    }\n  }\n  for (const attr2 of tag.attributes) {\n    referenceNodes.push(attr2.value);\n  }\n  for (const child of tag.body.attributeTags ? tag.body.body : tag.attributeTags) {\n    switch (child.type) {\n      case \"MarkoTag\":\n        getAllTagReferenceNodes(child, referenceNodes);\n        break;\n      case \"MarkoScriptlet\":\n        for (const statement of child.body) {\n          referenceNodes.push(statement);\n        }\n        break;\n    }\n  }\n  return referenceNodes;\n}\nfunction getScopeAccessorLiteral(binding) {\n  if (isOptimize()) {\n    return import_compiler7.types.numericLiteral(binding.id);\n  }\n  return import_compiler7.types.stringLiteral(\n    binding.name + (binding.type === 0 /* dom */ ? `/${binding.id}` : \"\")\n  );\n}\nfunction getReadReplacement(node) {\n  const { extra } = node;\n  if (!extra) return;\n  let { binding, read } = extra;\n  let replacement;\n  if (read) {\n    if (read.props === void 0) {\n      binding = read.binding;\n      read = void 0;\n    } else {\n      binding = void 0;\n    }\n  }\n  if (binding) {\n    if (node.type === \"Identifier\") {\n      if (binding.name !== node.name) {\n        node.name = binding.name;\n      }\n    } else {\n      replacement = import_compiler7.types.identifier(binding.name);\n    }\n  } else if (read) {\n    replacement = toMemberExpression(\n      import_compiler7.types.identifier(read.binding.name),\n      Array.isArray(read.props) ? read.props[0] : read.props\n    );\n    if (Array.isArray(read.props)) {\n      for (let i = 1; i < read.props.length; i++) {\n        replacement = toMemberExpression(replacement, read.props[i]);\n      }\n    }\n  }\n  return replacement && withPreviousLocation(replacement, node);\n}\nfunction pruneBinding(bindings, binding) {\n  let shouldPrune = !binding.downstreamExpressions.size;\n  for (const alias of binding.aliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.aliases.delete(alias);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  for (const [key, alias] of binding.propertyAliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.propertyAliases.delete(key);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  if (shouldPrune) {\n    bindings.delete(binding);\n  }\n  return shouldPrune;\n}\nfunction resolveReferencedBindings(expr, reads, intersectionsBySection) {\n  let referencedBindings;\n  if (Array.isArray(reads)) {\n    for (const read of reads) {\n      let { binding } = read;\n      if (read.node) {\n        const exprReference = (read.node.extra ??= {}).read ??= resolveExpressionReference(reads, binding, void 0);\n        ({ binding } = (read.node.extra ??= {}).read = exprReference);\n      }\n      referencedBindings = bindingUtil.add(referencedBindings, binding);\n    }\n  } else if (reads) {\n    if (reads.node) {\n      (reads.node.extra ??= {}).read = createRead(reads.binding, void 0);\n    }\n    referencedBindings = reads.binding;\n  }\n  if (Array.isArray(referencedBindings)) {\n    const intersections = intersectionsBySection.get(expr.section) || [];\n    const intersection = findSorted(\n      compareIntersections,\n      intersections,\n      referencedBindings\n    );\n    if (intersection) {\n      referencedBindings = intersection;\n    } else {\n      intersectionsBySection.set(\n        expr.section,\n        addSorted(compareIntersections, intersections, referencedBindings)\n      );\n    }\n  }\n  return referencedBindings;\n}\nfunction resolveExpressionReference(reads, readBinding, readProps) {\n  const { upstreamAlias } = readBinding;\n  if (upstreamAlias && Array.isArray(reads)) {\n    const prop = getCanonicalProperty(readBinding);\n    const aliasProps = prop === void 0 ? readProps : push(readProps, prop);\n    for (const { binding } of reads) {\n      if (binding !== readBinding) {\n        let alias = upstreamAlias;\n        while (alias) {\n          if (binding === alias) {\n            return resolveExpressionReference(reads, alias, aliasProps);\n          }\n          alias = alias.upstreamAlias;\n        }\n      }\n    }\n  }\n  return createRead(readBinding, readProps);\n}\nfunction getCanonicalProperty(binding) {\n  return binding.property ?? binding.upstreamAlias?.property;\n}\nfunction createRead(binding, props) {\n  return { binding, props };\n}\nfunction getMemberExpressionPropString(expr) {\n  switch (expr.property.type) {\n    case \"StringLiteral\":\n      return expr.property.value;\n    case \"NumericLiteral\":\n      return \"\" + expr.property.value;\n    case \"Identifier\":\n      return expr.property.name;\n  }\n}\nfunction isEventOrChangeHandler(prop) {\n  return /^on[-A-Z][a-zA-Z0-9_$]|[a-zA-Z_$][a-zA-Z0-9_$]*Change$/.test(prop);\n}\nfunction isReferencedExtra(extra) {\n  return !!(extra && !extra.pruned && extra.section);\n}\nfunction isAssignedBindingExtra(extra) {\n  return isReferencedExtra(extra) && extra.assignment !== void 0;\n}\nfunction isRegisteredFnExtra(extra) {\n  return isReferencedExtra(extra) && extra.registerId !== void 0;\n}\n\n// src/translator/util/runtime.ts\nvar import_compiler8 = require(\"@marko/compiler\");\nvar import_babel_utils8 = require(\"@marko/compiler/babel-utils\");\n\n// src/common/attr-tag.ts\nvar rest = false ? Symbol(\"Attribute Tag\") : Symbol();\n\n// src/common/helpers.ts\nfunction classValue(value) {\n  return toDelimitedString(value, \" \", stringifyClassObject);\n}\nfunction stringifyClassObject(name2, value) {\n  return value ? name2 : \"\";\n}\nfunction styleValue(value) {\n  return toDelimitedString(value, \";\", stringifyStyleObject);\n}\nvar NON_DIMENSIONAL = /^(--|ta|or|li|z)|n-c|i(do|nk|m|t)|w$|we/;\nfunction stringifyStyleObject(name2, value) {\n  return value || value === 0 ? `${name2}:${typeof value === \"number\" && value && !NON_DIMENSIONAL.test(name2) ? value + \"px\" : value}` : \"\";\n}\nfunction toDelimitedString(val, delimiter, stringify) {\n  switch (typeof val) {\n    case \"string\":\n      return val;\n    case \"object\":\n      if (val !== null) {\n        let result = \"\";\n        let curDelimiter = \"\";\n        if (Array.isArray(val)) {\n          for (const v of val) {\n            const part = toDelimitedString(v, delimiter, stringify);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        } else {\n          for (const name2 in val) {\n            const v = val[name2];\n            const part = stringify(name2, v);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        }\n        return result;\n      }\n  }\n  return \"\";\n}\nfunction isEventHandler(name2) {\n  return /^on[A-Z-]/.test(name2);\n}\nfunction getEventHandlerName(name2) {\n  return name2[2] === \"-\" ? name2.slice(3) : name2.slice(2).toLowerCase();\n}\nfunction isVoid(value) {\n  return value == null || value === false;\n}\n\n// src/html/content.ts\nfunction toString(val) {\n  return val ? val + \"\" : val === 0 ? \"0\" : \"\";\n}\nvar unsafeXMLReg = /[<&]/g;\nvar replaceUnsafeXML = (c) => c === \"&\" ? \"&amp;\" : \"&lt;\";\nvar escapeXMLStr = (str) => unsafeXMLReg.test(str) ? str.replace(unsafeXMLReg, replaceUnsafeXML) : str;\nfunction escapeXML(val) {\n  return val ? escapeXMLStr(val + \"\") : val === 0 ? \"0\" : \"&zwj;\";\n}\nvar unsafeScriptReg = /<\\/script/g;\nvar escapeScriptStr = (str) => unsafeScriptReg.test(str) ? str.replace(unsafeScriptReg, \"\\\\x3C/script\") : str;\nfunction escapeScript(val) {\n  return val ? escapeScriptStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\nvar unsafeStyleReg = /<\\/style/g;\nvar escapeStyleStr = (str) => unsafeStyleReg.test(str) ? str.replace(unsafeStyleReg, \"\\\\3C/style\") : str;\nfunction escapeStyle(val) {\n  return val ? escapeStyleStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\n\n// src/html/serializer.ts\nvar { hasOwnProperty } = {};\nvar Generator = function* () {\n}().constructor;\nvar AsyncGenerator = async function* () {\n}().constructor;\nvar KNOWN_SYMBOLS = (() => {\n  const KNOWN_SYMBOLS2 = /* @__PURE__ */ new Map();\n  for (const name2 of Object.getOwnPropertyNames(Symbol)) {\n    const symbol = Symbol[name2];\n    if (typeof symbol === \"symbol\") {\n      KNOWN_SYMBOLS2.set(symbol, \"Symbol.\" + name2);\n    }\n  }\n  return KNOWN_SYMBOLS2;\n})();\nvar KNOWN_FUNCTIONS = /* @__PURE__ */ new Map([\n  // This is by no means an exhaustive list,\n  // but it should cover most of the built-in functions.\n  [AggregateError, \"AggregateError\"],\n  [Array, \"Array\"],\n  [Array.from, \"Array.from\"],\n  [Array.isArray, \"Array.isArray\"],\n  [Array.of, \"Array.of\"],\n  [ArrayBuffer, \"ArrayBuffer\"],\n  [ArrayBuffer.isView, \"ArrayBuffer.isView\"],\n  [Atomics.add, \"Atomics.add\"],\n  [Atomics.and, \"Atomics.and\"],\n  [Atomics.compareExchange, \"Atomics.compareExchange\"],\n  [Atomics.exchange, \"Atomics.exchange\"],\n  [Atomics.isLockFree, \"Atomics.isLockFree\"],\n  [Atomics.load, \"Atomics.load\"],\n  [Atomics.notify, \"Atomics.notify\"],\n  [Atomics.or, \"Atomics.or\"],\n  [Atomics.store, \"Atomics.store\"],\n  [Atomics.sub, \"Atomics.sub\"],\n  [Atomics.wait, \"Atomics.wait\"],\n  [BigInt, \"BigInt\"],\n  [BigInt.asIntN, \"BigInt.asIntN\"],\n  [BigInt.asUintN, \"BigInt.asUintN\"],\n  [BigInt64Array, \"BigInt64Array\"],\n  [BigInt64Array.from, \"BigInt64Array.from\"],\n  [BigInt64Array.of, \"BigInt64Array.of\"],\n  [BigUint64Array, \"BigUint64Array\"],\n  [BigUint64Array.from, \"BigUint64Array.from\"],\n  [BigUint64Array.of, \"BigUint64Array.of\"],\n  [Boolean, \"Boolean\"],\n  [console.assert, \"console.assert\"],\n  [console.clear, \"console.clear\"],\n  [console.count, \"console.count\"],\n  [console.countReset, \"console.countReset\"],\n  [console.debug, \"console.debug\"],\n  [console.dir, \"console.dir\"],\n  [console.dirxml, \"console.dirxml\"],\n  [console.error, \"console.error\"],\n  [console.group, \"console.group\"],\n  [console.groupCollapsed, \"console.groupCollapsed\"],\n  [console.groupEnd, \"console.groupEnd\"],\n  [console.info, \"console.info\"],\n  [console.log, \"console.log\"],\n  [console.table, \"console.table\"],\n  [console.time, \"console.time\"],\n  [console.timeEnd, \"console.timeEnd\"],\n  [console.timeLog, \"console.timeLog\"],\n  [console.timeStamp, \"console.timeStamp\"],\n  [console.trace, \"console.trace\"],\n  [console.warn, \"console.warn\"],\n  [DataView, \"DataView\"],\n  [Date, \"Date\"],\n  [Date.now, \"Date.now\"],\n  [Date.parse, \"Date.parse\"],\n  [Date.UTC, \"Date.UTC\"],\n  [decodeURI, \"decodeURI\"],\n  [decodeURIComponent, \"decodeURIComponent\"],\n  [encodeURI, \"encodeURI\"],\n  [encodeURIComponent, \"encodeURIComponent\"],\n  [Error, \"Error\"],\n  [EvalError, \"EvalError\"],\n  [Float32Array, \"Float32Array\"],\n  [Float32Array.from, \"Float32Array.from\"],\n  [Float32Array.of, \"Float32Array.of\"],\n  [Float64Array, \"Float64Array\"],\n  [Float64Array.from, \"Float64Array.from\"],\n  [Float64Array.of, \"Float64Array.of\"],\n  [Function, \"Function\"],\n  [globalThis.atob, \"atob\"],\n  [globalThis.btoa, \"btoa\"],\n  [globalThis.clearImmediate, \"clearImmediate\"],\n  [globalThis.clearInterval, \"clearInterval\"],\n  [globalThis.clearTimeout, \"clearTimeout\"],\n  [globalThis.crypto?.getRandomValues, \"crypto.getRandomValues\"],\n  [globalThis.crypto?.randomUUID, \"crypto.randomUUID\"],\n  [globalThis.fetch, \"fetch\"],\n  [globalThis.performance?.now, \"performance.now\"],\n  [globalThis.queueMicrotask, \"queueMicrotask\"],\n  [globalThis.setImmediate, \"setImmediate\"],\n  [globalThis.setInterval, \"setInterval\"],\n  [globalThis.setTimeout, \"setTimeout\"],\n  [globalThis.structuredClone, \"structuredClone\"],\n  [globalThis.URL, \"URL\"],\n  [globalThis.URLSearchParams, \"URLSearchParams\"],\n  [globalThis.WritableStream, \"WritableStream\"],\n  [Int16Array, \"Int16Array\"],\n  [Int16Array.from, \"Int16Array.from\"],\n  [Int16Array.of, \"Int16Array.of\"],\n  [Int32Array, \"Int32Array\"],\n  [Int32Array.from, \"Int32Array.from\"],\n  [Int32Array.of, \"Int32Array.of\"],\n  [Int8Array, \"Int8Array\"],\n  [Int8Array.from, \"Int8Array.from\"],\n  [Int8Array.of, \"Int8Array.of\"],\n  [Intl.Collator, \"Intl.Collator\"],\n  [Intl.DateTimeFormat, \"Intl.DateTimeFormat\"],\n  [Intl.DisplayNames, \"Intl.DisplayNames\"],\n  [Intl.getCanonicalLocales, \"Intl.getCanonicalLocales\"],\n  [Intl.ListFormat, \"Intl.ListFormat\"],\n  [Intl.Locale, \"Intl.Locale\"],\n  [Intl.NumberFormat, \"Intl.NumberFormat\"],\n  [Intl.PluralRules, \"Intl.PluralRules\"],\n  [Intl.RelativeTimeFormat, \"Intl.RelativeTimeFormat\"],\n  [Intl.Segmenter, \"Intl.Segmenter\"],\n  [Intl.supportedValuesOf, \"Intl.supportedValuesOf\"],\n  [isFinite, \"isFinite\"],\n  [isNaN, \"isNaN\"],\n  [JSON.parse, \"JSON.parse\"],\n  [JSON.stringify, \"JSON.stringify\"],\n  [Map, \"Map\"],\n  [Map.groupBy, \"Map.groupBy\"],\n  [Math.abs, \"Math.abs\"],\n  [Math.acos, \"Math.acos\"],\n  [Math.acosh, \"Math.acosh\"],\n  [Math.asin, \"Math.asin\"],\n  [Math.asinh, \"Math.asinh\"],\n  [Math.atan, \"Math.atan\"],\n  [Math.atan2, \"Math.atan2\"],\n  [Math.atanh, \"Math.atanh\"],\n  [Math.cbrt, \"Math.cbrt\"],\n  [Math.ceil, \"Math.ceil\"],\n  [Math.clz32, \"Math.clz32\"],\n  [Math.cos, \"Math.cos\"],\n  [Math.cosh, \"Math.cosh\"],\n  [Math.exp, \"Math.exp\"],\n  [Math.expm1, \"Math.expm1\"],\n  [Math.floor, \"Math.floor\"],\n  [Math.fround, \"Math.fround\"],\n  [Math.hypot, \"Math.hypot\"],\n  [Math.imul, \"Math.imul\"],\n  [Math.log, \"Math.log\"],\n  [Math.log10, \"Math.log10\"],\n  [Math.log1p, \"Math.log1p\"],\n  [Math.log2, \"Math.log2\"],\n  [Math.max, \"Math.max\"],\n  [Math.min, \"Math.min\"],\n  [Math.pow, \"Math.pow\"],\n  [Math.random, \"Math.random\"],\n  [Math.round, \"Math.round\"],\n  [Math.sign, \"Math.sign\"],\n  [Math.sin, \"Math.sin\"],\n  [Math.sinh, \"Math.sinh\"],\n  [Math.sqrt, \"Math.sqrt\"],\n  [Math.tan, \"Math.tan\"],\n  [Math.tanh, \"Math.tanh\"],\n  [Math.trunc, \"Math.trunc\"],\n  [Number, \"Number\"],\n  [Number.isFinite, \"Number.isFinite\"],\n  [Number.isInteger, \"Number.isInteger\"],\n  [Number.isNaN, \"Number.isNaN\"],\n  [Number.isSafeInteger, \"Number.isSafeInteger\"],\n  [Number.parseFloat, \"Number.parseFloat\"],\n  [Number.parseInt, \"Number.parseInt\"],\n  [Object, \"Object\"],\n  [Object.assign, \"Object.assign\"],\n  [Object.create, \"Object.create\"],\n  [Object.defineProperties, \"Object.defineProperties\"],\n  [Object.defineProperty, \"Object.defineProperty\"],\n  [Object.entries, \"Object.entries\"],\n  [Object.freeze, \"Object.freeze\"],\n  [Object.fromEntries, \"Object.fromEntries\"],\n  [Object.getOwnPropertyDescriptor, \"Object.getOwnPropertyDescriptor\"],\n  [Object.getOwnPropertyDescriptors, \"Object.getOwnPropertyDescriptors\"],\n  [Object.getOwnPropertyNames, \"Object.getOwnPropertyNames\"],\n  [Object.getOwnPropertySymbols, \"Object.getOwnPropertySymbols\"],\n  [Object.getPrototypeOf, \"Object.getPrototypeOf\"],\n  [Object.is, \"Object.is\"],\n  [Object.isExtensible, \"Object.isExtensible\"],\n  [Object.isFrozen, \"Object.isFrozen\"],\n  [Object.isSealed, \"Object.isSealed\"],\n  [Object.keys, \"Object.keys\"],\n  [Object.preventExtensions, \"Object.preventExtensions\"],\n  [Object.seal, \"Object.seal\"],\n  [Object.setPrototypeOf, \"Object.setPrototypeOf\"],\n  [Object.values, \"Object.values\"],\n  [parseFloat, \"parseFloat\"],\n  [parseInt, \"parseInt\"],\n  [Promise, \"Promise\"],\n  [Proxy, \"Proxy\"],\n  [RangeError, \"RangeError\"],\n  [ReferenceError, \"ReferenceError\"],\n  [Reflect.apply, \"Reflect.apply\"],\n  [Reflect.construct, \"Reflect.construct\"],\n  [Reflect.defineProperty, \"Reflect.defineProperty\"],\n  [Reflect.deleteProperty, \"Reflect.deleteProperty\"],\n  [Reflect.get, \"Reflect.get\"],\n  [Reflect.getOwnPropertyDescriptor, \"Reflect.getOwnPropertyDescriptor\"],\n  [Reflect.getPrototypeOf, \"Reflect.getPrototypeOf\"],\n  [Reflect.has, \"Reflect.has\"],\n  [Reflect.isExtensible, \"Reflect.isExtensible\"],\n  [Reflect.ownKeys, \"Reflect.ownKeys\"],\n  [Reflect.preventExtensions, \"Reflect.preventExtensions\"],\n  [Reflect.set, \"Reflect.set\"],\n  [Reflect.setPrototypeOf, \"Reflect.setPrototypeOf\"],\n  [RegExp, \"RegExp\"],\n  [Set, \"Set\"],\n  [String, \"String\"],\n  [String.fromCharCode, \"String.fromCharCode\"],\n  [String.fromCodePoint, \"String.fromCodePoint\"],\n  [String.raw, \"String.raw\"],\n  [Symbol, \"Symbol\"],\n  [Symbol.for, \"Symbol.for\"],\n  [SyntaxError, \"SyntaxError\"],\n  [TypeError, \"TypeError\"],\n  [Uint16Array, \"Uint16Array\"],\n  [Uint16Array.from, \"Uint16Array.from\"],\n  [Uint16Array.of, \"Uint16Array.of\"],\n  [Uint32Array, \"Uint32Array\"],\n  [Uint32Array.from, \"Uint32Array.from\"],\n  [Uint32Array.of, \"Uint32Array.of\"],\n  [Uint8Array, \"Uint8Array\"],\n  [Uint8Array.from, \"Uint8Array.from\"],\n  [Uint8Array.of, \"Uint8Array.of\"],\n  [Uint8ClampedArray, \"Uint8ClampedArray\"],\n  [Uint8ClampedArray.from, \"Uint8ClampedArray.from\"],\n  [Uint8ClampedArray.of, \"Uint8ClampedArray.of\"],\n  [URIError, \"URIError\"],\n  [WeakMap, \"WeakMap\"],\n  [WeakSet, \"WeakSet\"]\n]);\nvar KNOWN_OBJECTS = /* @__PURE__ */ new Map([\n  [Atomics, \"Atomics\"],\n  [console, \"console\"],\n  [globalThis, \"globalThis\"],\n  [globalThis.crypto, \"crypto\"],\n  [Intl, \"Intl\"],\n  [JSON, \"JSON\"],\n  [Math, \"Math\"],\n  [Reflect, \"Reflect\"]\n]);\n\n// src/html/writer.ts\nvar K_SCOPE_ID = Symbol(\"Scope ID\");\nvar kPendingContexts = Symbol(\"Pending Contexts\");\nvar tick = globalThis.setImmediate || globalThis.setTimeout || globalThis.queueMicrotask || ((cb) => Promise.resolve().then(cb));\n\n// src/html/attrs.ts\nfunction classAttr(val) {\n  return stringAttr(\"class\", classValue(val));\n}\nfunction styleAttr(val) {\n  return stringAttr(\"style\", styleValue(val));\n}\nvar kSelectedValue = Symbol(\"selectedValue\");\nfunction attr(name2, val) {\n  return isVoid(val) ? \"\" : nonVoidAttr(name2, val);\n}\nfunction stringAttr(name2, val) {\n  return val && ` ${name2}=${escapeAttrValue(val)}`;\n}\nfunction nonVoidAttr(name2, val) {\n  switch (typeof val) {\n    case \"string\":\n      return ` ${name2 + attrAssignment(val)}`;\n    case \"boolean\":\n      return ` ${name2}`;\n    case \"number\":\n      return ` ${name2}=${val}`;\n    case \"object\":\n      if (val instanceof RegExp) {\n        return ` ${name2 + attrAssignment(val.source)}`;\n      }\n      break;\n  }\n  return ` ${name2 + attrAssignment(val + \"\")}`;\n}\nfunction attrAssignment(val) {\n  return val ? `=${escapeAttrValue(val)}` : \"\";\n}\nvar unsafeAttrChars = /[\"'>\\s]/g;\nfunction escapeAttrValue(str) {\n  if (unsafeAttrChars.test(str)) {\n    const c = str[unsafeAttrChars.lastIndex - 1];\n    unsafeAttrChars.lastIndex = 0;\n    return c === '\"' ? `'${str.replace(/'/g, \"&#39;\")}'` : `\"${str.replace(/\"/g, \"&#34;\")}\"`;\n  }\n  return str;\n}\n\n// src/common/compat-meta.ts\nvar prefix = false ? \"$compat_\" : \"$C_\";\nvar RENDERER_REGISTER_ID = prefix + (false ? \"renderer\" : \"r\");\nvar SET_SCOPE_REGISTER_ID = prefix + (false ? \"setScope\" : \"s\");\n\n// src/html/compat.ts\nvar K_TAGS_API_STATE = Symbol();\n\n// src/translator/util/runtime.ts\nvar pureFunctions = [\n  \"createTemplate\",\n  \"createRenderer\",\n  \"createRendererWithOwner\",\n  \"value\",\n  \"state\",\n  \"intersection\",\n  \"closure\",\n  \"dynamicClosure\",\n  \"loopOf\",\n  \"loopIn\",\n  \"loopTo\",\n  \"conditional\"\n];\nfunction importRuntime(name2) {\n  const { output } = getMarkoOpts();\n  return toMemberExpression(\n    (0, import_babel_utils8.importStar)(currentProgramPath.hub.file, getRuntimePath(output), \"$\"),\n    name2\n  );\n}\nfunction callRuntime(name2, ...args) {\n  const callExpression2 = import_compiler8.types.callExpression(\n    importRuntime(name2),\n    filterArguments(args)\n  );\n  if (pureFunctions.includes(name2)) {\n    callExpression2.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: ` @__PURE__ `\n      }\n    ];\n  }\n  return callExpression2;\n}\nfunction getHTMLRuntime() {\n  return {\n    escapeXML,\n    toString,\n    attr,\n    classAttr,\n    styleAttr,\n    escapeScript,\n    escapeStyle\n  };\n}\nfunction getRuntimePath(output) {\n  const { optimize } = getMarkoOpts();\n  return `${runtime_info_default.name}/${optimize ? \"\" : \"debug/\"}${output === \"html\" ? \"html\" : \"dom\"}`;\n}\nfunction filterArguments(args) {\n  const filteredArgs = [];\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (arg || filteredArgs.length) {\n      filteredArgs[i] = arg || import_compiler8.types.unaryExpression(\"void\", import_compiler8.types.numericLiteral(0));\n    }\n  }\n  return filteredArgs;\n}\nfunction getCompatRuntimeFile() {\n  const markoOpts = getMarkoOpts();\n  return `marko/src/runtime/helpers/tags-compat/${isOutputHTML() ? \"html\" : \"dom\"}${markoOpts.optimize ? \"\" : \"-debug\"}.${markoOpts.modules === \"esm\" ? \"mjs\" : \"js\"}`;\n}\n\n// src/translator/visitors/program/dom.ts\nvar import_compiler20 = require(\"@marko/compiler\");\n\n// src/translator/util/signals.ts\nvar import_compiler19 = require(\"@marko/compiler\");\nvar import_babel_utils10 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/core/return.ts\nvar import_compiler13 = require(\"@marko/compiler\");\nvar import_babel_utils9 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-known-attr-values.ts\nfunction getKnownAttrValues(tag) {\n  const attrs2 = {};\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      attrs2[attr2.name] = attr2.value;\n    }\n  }\n  return attrs2;\n}\n\n// src/translator/util/plugin-hooks.ts\nvar import_compiler9 = require(\"@marko/compiler\");\nfunction enter(modulePlugin, path4) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path4;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (isFunctionPlugin(plugin)) {\n    plugin(path4, import_compiler9.types);\n  } else if (plugin.enter) {\n    plugin.enter(path4, import_compiler9.types);\n  }\n  return node !== path4.node;\n}\nfunction exit(modulePlugin, path4) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path4;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (!isFunctionPlugin(plugin) && plugin.exit) {\n    plugin.exit(path4, import_compiler9.types);\n  }\n  return node !== path4.node;\n}\nfunction isModulePlugin(plugin) {\n  return Boolean(plugin.default);\n}\nfunction isFunctionPlugin(plugin) {\n  return typeof plugin === \"function\";\n}\n\n// src/translator/util/visitors.ts\nfunction extractVisitors(visitors2) {\n  const result = {\n    migrate: {},\n    transform: {},\n    analyze: {},\n    translate: {}\n  };\n  for (const _name in visitors2) {\n    const name2 = _name;\n    const value = visitors2[name2];\n    if (value.migrate) result.migrate[name2] = value.migrate;\n    if (value.transform) result.transform[name2] = value.transform;\n    if (value.analyze) result.analyze[name2] = value.analyze;\n    if (value.translate) result.translate[name2] = value.translate;\n  }\n  return result;\n}\nfunction translateByTarget({\n  html,\n  dom\n}) {\n  return {\n    enter(path4) {\n      enter(isOutputHTML() ? html : dom, path4);\n    },\n    exit(path4) {\n      exit(isOutputHTML() ? html : dom, path4);\n    }\n  };\n}\n\n// src/translator/util/writer.ts\nvar import_compiler12 = require(\"@marko/compiler\");\n\n// src/translator/util/normalize-string-expression.ts\nvar import_compiler10 = require(\"@marko/compiler\");\nfunction normalizeStringExpression(parts) {\n  const strs = [];\n  const exprs = [];\n  let curStr = parts[0];\n  for (let i = 1; i < parts.length; i++) {\n    let content = parts[i];\n    if (typeof content === \"object\") {\n      if (import_compiler10.types.isStringLiteral(content)) {\n        content = content.value;\n      } else if (import_compiler10.types.isTemplateLiteral(content)) {\n        let nextIndex = i + 1;\n        const exprLen = content.expressions.length;\n        shiftItems(parts, nextIndex, content.quasis.length + exprLen);\n        for (let j = 0; j < exprLen; j++) {\n          parts[nextIndex++] = content.quasis[j].value.raw;\n          parts[nextIndex++] = content.expressions[j];\n        }\n        parts[nextIndex] = content.quasis[exprLen].value.raw;\n        continue;\n      } else {\n        exprs.push(content);\n        strs.push(curStr);\n        curStr = \"\";\n        continue;\n      }\n    }\n    curStr += content;\n  }\n  if (exprs.length) {\n    if (exprs.length === 1 && !curStr && !strs[0]) {\n      return exprs[0];\n    }\n    strs.push(curStr);\n    return import_compiler10.types.templateLiteral(\n      strs.map((raw) => import_compiler10.types.templateElement({ raw })),\n      exprs\n    );\n  } else if (curStr) {\n    return import_compiler10.types.stringLiteral(curStr);\n  }\n}\nfunction appendLiteral(arr, str) {\n  arr[arr.length - 1] += str;\n}\nfunction shiftItems(list, start, offset) {\n  for (let i = list.length - 1; i >= start; i--) {\n    list[i + offset] = list[i];\n  }\n}\n\n// src/translator/util/walks.ts\nvar import_compiler11 = require(\"@marko/compiler\");\nvar [getWalks] = createSectionState(\n  \"walks\",\n  () => [\"\"]\n);\nvar [getWalkComment] = createSectionState(\n  \"walkComment\",\n  () => []\n);\nvar [getSteps] = createSectionState(\"steps\", () => []);\nvar walkCodeToName = {\n  [32 /* Get */]: \"get\",\n  [36 /* Inside */]: \"inside\",\n  [37 /* Replace */]: \"replace\",\n  [38 /* EndChild */]: \"endChild\",\n  [47 /* BeginChild */]: \"beginChild\",\n  [67 /* Next */]: \"next\",\n  [97 /* Over */]: \"over\",\n  [107 /* Out */]: \"out\",\n  [117 /* Multiplier */]: \"multiplier\",\n  [91 /* NextEnd */]: \"nextEnd\",\n  [106 /* OverEnd */]: \"overEnd\",\n  [116 /* OutEnd */]: \"outEnd\",\n  [126 /* MultiplierEnd */]: \"multiplierEnd\"\n};\nfunction enter2(path4) {\n  getSteps(getSection(path4)).push(0 /* Enter */);\n}\nfunction exit2(path4) {\n  getSteps(getSection(path4)).push(1 /* Exit */);\n}\nfunction enterShallow(path4) {\n  getSteps(getSection(path4)).push(0 /* Enter */, 1 /* Exit */);\n}\nfunction injectWalks(path4, expr) {\n  const walks = getWalks(getSection(path4));\n  const walkComment = getWalkComment(getSection(path4));\n  walkComment.push(\n    `${walkCodeToName[47 /* BeginChild */]}`,\n    expr.name,\n    walkCodeToName[38 /* EndChild */]\n  );\n  appendLiteral(walks, String.fromCharCode(47 /* BeginChild */));\n  walks.push(expr, String.fromCharCode(38 /* EndChild */));\n}\nfunction visit(path4, code) {\n  if (isOutputHTML()) {\n    return;\n  }\n  const section = getSection(path4);\n  const steps = getSteps(section);\n  const walks = getWalks(section);\n  const walkComment = getWalkComment(section);\n  let walkString = \"\";\n  if (steps.length) {\n    const walkCodes = [];\n    let depth = 0;\n    for (const step of steps) {\n      if (step === 0 /* Enter */) {\n        depth++;\n        walkCodes.push(67 /* Next */);\n      } else {\n        depth--;\n        if (depth >= 0) {\n          walkCodes.length = walkCodes.lastIndexOf(67 /* Next */);\n          walkCodes.push(97 /* Over */);\n        } else {\n          walkCodes.length = walkCodes.lastIndexOf(107 /* Out */) + 1;\n          walkCodes.push(107 /* Out */);\n          depth = 0;\n        }\n      }\n    }\n    let current = walkCodes[0];\n    let count = 0;\n    for (const walk of walkCodes) {\n      if (walk !== current) {\n        walkComment.push(`${walkCodeToName[current]}(${count})`);\n        walkString += nCodeString(current, count);\n        current = walk;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n    walkComment.push(`${walkCodeToName[current]}(${count})`);\n    walkString += nCodeString(current, count);\n    steps.length = 0;\n  }\n  if (code !== void 0) {\n    if (code !== 32 /* Get */) {\n      writeTo(path4)`<!>`;\n    }\n    walkComment.push(`${walkCodeToName[code]}`);\n    walkString += String.fromCharCode(code);\n  }\n  appendLiteral(walks, walkString);\n}\nfunction nCodeString(code, number) {\n  switch (code) {\n    case 67 /* Next */:\n      return toCharString(number, code, 20 /* Next */);\n    case 97 /* Over */:\n      return toCharString(number, code, 10 /* Over */);\n    case 107 /* Out */:\n      return toCharString(number, code, 10 /* Out */);\n    default:\n      throw new Error(`Unexpected walk code: ${code}`);\n  }\n}\nfunction toCharString(number, startCode, rangeSize) {\n  let result = \"\";\n  if (number >= rangeSize) {\n    const multiplier = Math.floor(number / rangeSize);\n    result += toCharString(\n      multiplier,\n      117 /* Multiplier */,\n      10 /* Multiplier */\n    );\n    number -= multiplier * rangeSize;\n  }\n  result += String.fromCharCode(startCode + number);\n  return result;\n}\nfunction getWalkString(section) {\n  const prefix2 = section.content?.startType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const postfix = section.content?.endType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const walks = getWalks(section);\n  const walkLiteral = normalizeStringExpression([prefix2, ...walks, postfix]) || import_compiler11.types.stringLiteral(\"\");\n  if (walkLiteral.value !== \"\") {\n    walkLiteral.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: \" \" + getWalkComment(section).join(\", \") + \" \"\n      }\n    ];\n  }\n  return walkLiteral;\n}\n\n// src/translator/util/writer.ts\nvar [getWrites] = createSectionState(\n  \"writes\",\n  () => [\"\"]\n);\nvar [getTrailerWrites] = createSectionState(\n  \"trailerWrites\",\n  () => [\"\"]\n);\nfunction writeTo(path4, trailer) {\n  const section = getSection(path4);\n  const get = trailer ? getTrailerWrites : getWrites;\n  return (strs, ...exprs) => {\n    const exprsLen = exprs.length;\n    const writes = get(section);\n    appendLiteral(writes, strs[0]);\n    for (let i = 0; i < exprsLen; i++) {\n      writes.push(exprs[i], strs[i + 1]);\n    }\n  };\n}\nfunction consumeHTML(path4) {\n  const section = getSection(path4);\n  const writes = getWrites(section);\n  const trailers = getTrailerWrites(section);\n  const writeResult = normalizeStringExpression(writes);\n  const trailerResult = normalizeStringExpression(trailers);\n  writes.length = 0;\n  writes[0] = \"\";\n  trailers.length = 0;\n  trailers[0] = \"\";\n  if (writeResult && trailerResult) {\n    return import_compiler12.types.expressionStatement(\n      import_compiler12.types.sequenceExpression([\n        callRuntime(\"write\", writeResult),\n        callRuntime(\"writeTrailers\", trailerResult)\n      ])\n    );\n  } else if (writeResult) {\n    return import_compiler12.types.expressionStatement(callRuntime(\"write\", writeResult));\n  } else if (trailerResult) {\n    return import_compiler12.types.expressionStatement(callRuntime(\"writeTrailers\", trailerResult));\n  }\n}\nfunction flushBefore(path4) {\n  const expr = consumeHTML(path4);\n  if (expr) {\n    path4.insertBefore(expr)[0].skip();\n  }\n}\nfunction flushInto(path4) {\n  const target = path4.isProgram() ? path4 : path4.get(\"body\");\n  const expr = consumeHTML(target);\n  if (expr) {\n    target.pushContainer(\"body\", expr)[0].skip();\n  }\n}\nfunction getSectionMeta(section) {\n  const writePrefix = section.content?.startType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writePostfix = section.content?.endType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writes = getWrites(section);\n  return {\n    setup: getSetup(section),\n    walks: getWalkString(section),\n    writes: normalizeStringExpression([writePrefix, ...writes, writePostfix]) || import_compiler12.types.stringLiteral(\"\")\n  };\n}\nfunction markNode(path4, binding) {\n  const section = getSection(path4);\n  if (binding.type !== 0 /* dom */) {\n    throw path4.buildCodeFrameError(\n      \"Tried to mark a node that was not determined to need a mark during analyze.\"\n    );\n  }\n  if (isOutputHTML()) {\n    writeTo(path4)`${callRuntime(\n      \"markResumeNode\",\n      getScopeIdIdentifier(section),\n      getScopeAccessorLiteral(binding)\n    )}`;\n  }\n}\n\n// src/translator/core/return.ts\nvar [returnId, _setReturnId] = createSectionState(\n  \"returnId\"\n);\nvar usedTag = /* @__PURE__ */ new WeakSet();\nvar return_default = {\n  analyze(tag) {\n    (0, import_babel_utils9.assertNoArgs)(tag);\n    (0, import_babel_utils9.assertNoVar)(tag);\n    (0, import_babel_utils9.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils9.assertAllowedAttributes)(tag, [\"value\", \"valueChange\"]);\n    if (usedTag.has(tag.hub)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `return` tag can only be used once per template.\"\n      );\n    }\n    usedTag.add(tag.hub);\n    if (!getKnownAttrValues(tag.node).value) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `return` tag requires a value.\");\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      exit(tag) {\n        const section = getSection(tag);\n        const attrs2 = getKnownAttrValues(tag.node);\n        flushBefore(tag);\n        if (attrs2.valueChange) {\n          getSerializedScopeProperties(section).set(\n            import_compiler13.types.stringLiteral(\"@\" /* TagVariableChange */),\n            attrs2.valueChange\n          );\n        }\n        if (attrs2.value) {\n          const returnId2 = currentProgramPath.scope.generateUidIdentifier(\"return\");\n          _setReturnId(section, returnId2);\n          tag.replaceWith(\n            import_compiler13.types.variableDeclaration(\"const\", [\n              import_compiler13.types.variableDeclarator(returnId2, attrs2.value)\n            ])\n          )[0].skip();\n        }\n      }\n    },\n    dom: {\n      exit(tag) {\n        const section = getSection(tag);\n        const attrs2 = getKnownAttrValues(tag.node);\n        if (attrs2.value) {\n          addValue(\n            section,\n            attrs2.value.extra?.referencedBindings,\n            {\n              identifier: importRuntime(\"tagVarSignal\"),\n              hasDownstreamIntersections: () => true\n            },\n            attrs2.value\n          );\n        }\n        if (attrs2.valueChange) {\n          addValue(\n            section,\n            attrs2.valueChange.extra?.referencedBindings,\n            {\n              identifier: importRuntime(\"setTagVarChange\"),\n              hasDownstreamIntersections: () => false\n            },\n            attrs2.valueChange\n          );\n        }\n        tag.remove();\n      }\n    }\n  }),\n  parseOptions: {\n    openTagOnly: true\n  },\n  autocomplete: [\n    {\n      displayText: \"return=<value>\",\n      description: \"Provides a value for use in a parent template.\",\n      snippet: \"return=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#return\"\n    }\n  ]\n};\n\n// src/translator/util/get-defined-binding-expression.ts\nvar import_compiler14 = require(\"@marko/compiler\");\nfunction getDeclaredBindingExpression(binding) {\n  if (binding.declared || !binding.upstreamAlias) {\n    return import_compiler14.types.identifier(binding.name);\n  } else if (binding.property !== void 0) {\n    return toMemberExpression(\n      getDeclaredBindingExpression(binding.upstreamAlias),\n      binding.property,\n      binding.upstreamAlias.nullable\n    );\n  } else {\n    return getDeclaredBindingExpression(binding.upstreamAlias);\n  }\n}\n\n// src/translator/util/scope-read.ts\nvar import_compiler15 = require(\"@marko/compiler\");\nfunction createScopeReadPattern(section, referencedBindings) {\n  const rootDepth = section.depth;\n  const rootPattern = import_compiler15.types.objectPattern([]);\n  let nestedPatterns;\n  forEach(referencedBindings, (ref) => {\n    if (ref.name.includes(\"#\")) return;\n    const propertyKey = getScopeAccessorLiteral(ref);\n    const propertyValue = import_compiler15.types.identifier(ref.name);\n    const isShorthand = propertyKey.value === propertyValue.name;\n    let pattern = rootPattern;\n    if (ref.section !== section) {\n      if (!nestedPatterns) nestedPatterns = [rootPattern];\n      const relativeDepth = rootDepth - ref.section.depth;\n      let i = nestedPatterns.length;\n      let prev = nestedPatterns[i - 1];\n      for (; i <= relativeDepth; i++) {\n        const nestedPattern = import_compiler15.types.objectPattern([]);\n        prev.properties.push(\n          import_compiler15.types.objectProperty(import_compiler15.types.identifier(\"_\"), nestedPattern)\n        );\n        nestedPatterns.push(nestedPattern);\n        prev = nestedPattern;\n      }\n      pattern = nestedPatterns[relativeDepth];\n    }\n    pattern.properties.push(\n      import_compiler15.types.objectProperty(\n        isShorthand ? propertyValue : propertyKey,\n        propertyValue,\n        false,\n        isShorthand\n      )\n    );\n  });\n  return rootPattern;\n}\nfunction getScopeExpression(section, targetSection) {\n  let scope = scopeIdentifier ?? import_compiler15.types.identifier(\"undefined\");\n  const diff = section.depth - targetSection.depth;\n  for (let i = 0; i < diff; i++) {\n    scope = import_compiler15.types.memberExpression(scope, import_compiler15.types.identifier(\"_\"));\n  }\n  if (diff < 0) {\n    throw new Error(\"Unable to find scope for reference.\");\n  }\n  return scope;\n}\nfunction createScopeReadExpression(section, reference) {\n  return import_compiler15.types.memberExpression(\n    getScopeExpression(section, reference.section),\n    getScopeAccessorLiteral(reference),\n    true\n  );\n}\n\n// src/translator/util/simplify-fn.ts\nvar import_compiler16 = require(\"@marko/compiler\");\nfunction simplifyFunction(fn) {\n  switch (fn.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return fn;\n    default:\n      return import_compiler16.types.functionExpression(\n        null,\n        fn.params,\n        fn.body,\n        fn.async,\n        fn.generator\n      );\n  }\n}\n\n// src/translator/util/to-first-expression-or-block.ts\nvar import_compiler17 = require(\"@marko/compiler\");\nfunction toFirstExpressionOrBlock(stmts) {\n  if (stmts.length === 1 && import_compiler17.types.isExpressionStatement(stmts[0])) {\n    const { expression } = stmts[0];\n    switch (expression.type) {\n      case \"ObjectExpression\":\n      case \"AssignmentExpression\":\n        return toParenthesizedExpressionIfNeeded(expression);\n      default:\n        return expression;\n    }\n  }\n  return import_compiler17.types.blockStatement(stmts);\n}\nfunction toParenthesizedExpressionIfNeeded(expr) {\n  switch (expr.type) {\n    case \"ObjectExpression\":\n    case \"AssignmentExpression\":\n      return import_compiler17.types.parenthesizedExpression(expr);\n    default:\n      return expr;\n  }\n}\n\n// src/translator/util/traverse.ts\nvar import_compiler18 = require(\"@marko/compiler\");\nvar skip = Symbol(\"skip\");\nfunction traverseReplace(container, key, enter3) {\n  const node = container[key];\n  if (node) {\n    if (Array.isArray(node)) {\n      for (let i = node.length; i--; ) {\n        traverseReplace(node, i, enter3);\n      }\n    } else {\n      const keys = import_compiler18.types.VISITOR_KEYS[node.type];\n      for (let i = keys.length; i--; ) {\n        traverseReplace(node, keys[i], enter3);\n      }\n      const replacement = enter3(node, container, key);\n      if (replacement) container[key] = replacement;\n    }\n  }\n}\nfunction traverseContains(node, check) {\n  if (node) {\n    if (Array.isArray(node)) {\n      for (const item of node) {\n        if (traverseContains(item, check)) {\n          return true;\n        }\n      }\n    } else {\n      switch (check(node)) {\n        case true:\n          return true;\n        case skip:\n          return false;\n      }\n      for (const key of import_compiler18.types.VISITOR_KEYS[node.type]) {\n        if (traverseContains(node[key], check)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n// src/translator/util/signals.ts\nvar [getSignals] = createSectionState(\n  \"signals\",\n  () => /* @__PURE__ */ new Map()\n);\nvar [getSubscribeBuilder, _setSubscribeBuilder] = createSectionState(\"queue\");\nfunction setSubscriberBuilder(tag, builder) {\n  _setSubscribeBuilder(getSectionForBody(tag.get(\"body\")), builder);\n}\nvar [forceResumeScope, _setForceResumeScope] = createSectionState(\"forceResumeScope\");\nfunction setForceResumeScope(section) {\n  _setForceResumeScope(section, true);\n}\nvar [getSerializedScopeProperties] = createSectionState(\"serializedScopeProperties\", () => /* @__PURE__ */ new Map());\nvar unimplementedBuild = () => {\n  return import_compiler19.types.stringLiteral(\"SIGNAL NOT INITIALIZED\");\n};\nfunction getSignal(section, referencedBindings, name2 = generateSignalName(referencedBindings)) {\n  const signals = getSignals(section);\n  let signal = signals.get(referencedBindings);\n  if (!signal) {\n    const exportName = referencedBindings ? !Array.isArray(referencedBindings) && referencedBindings.section === section && referencedBindings.export : !section.parent && currentProgramPath.node.extra.domExports?.setup;\n    signals.set(\n      referencedBindings,\n      signal = {\n        identifier: exportName ? import_compiler19.types.identifier(exportName) : currentProgramPath.scope.generateUidIdentifier(\n          name2 + section.name.replace(\"_\", \"$\")\n        ),\n        referencedBindings,\n        section,\n        values: [],\n        intersection: void 0,\n        render: [],\n        renderReferencedBindings: void 0,\n        effect: [],\n        effectReferencedBindings: void 0,\n        subscribers: [],\n        closures: /* @__PURE__ */ new Map(),\n        hasDownstreamIntersections: () => {\n          let hasDownstreamIntersections = !!(signal.intersection || signal.closures.size);\n          if (!hasDownstreamIntersections) {\n            for (const value of signal.values) {\n              if (value.signal.hasDownstreamIntersections()) {\n                hasDownstreamIntersections = true;\n                break;\n              }\n            }\n          }\n          if (!hasDownstreamIntersections) {\n            if (!Array.isArray(referencedBindings) && referencedBindings) {\n              for (const alias of referencedBindings.aliases) {\n                if (getSignal(section, alias).hasDownstreamIntersections()) {\n                  hasDownstreamIntersections = true;\n                  break;\n                }\n              }\n              if (!hasDownstreamIntersections) {\n                for (const [, alias] of referencedBindings.propertyAliases) {\n                  if (getSignal(section, alias).hasDownstreamIntersections()) {\n                    hasDownstreamIntersections = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          signal.hasDownstreamIntersections = () => hasDownstreamIntersections;\n          return hasDownstreamIntersections;\n        },\n        build: unimplementedBuild,\n        export: !!exportName\n      }\n    );\n    if (isOutputHTML()) {\n      return signal;\n    } else if (!referencedBindings) {\n      signal.build = () => getSignalFn(signal, [scopeIdentifier]);\n    } else if (Array.isArray(referencedBindings)) {\n      subscribe(referencedBindings, signal);\n      signal.build = () => {\n        return callRuntime(\n          \"intersection\",\n          import_compiler19.types.numericLiteral(referencedBindings.length),\n          getSignalFn(signal, [scopeIdentifier], referencedBindings),\n          buildSignalIntersections(signal)\n        );\n      };\n    } else if (referencedBindings.section !== section) {\n      getSignal(referencedBindings.section, referencedBindings).closures.set(\n        section,\n        signal\n      );\n      signal.build = () => {\n        const builder = getSubscribeBuilder(section);\n        const ownerScope = getScopeExpression(\n          section,\n          referencedBindings.section\n        );\n        const isImmediateOwner = ownerScope.object === scopeIdentifier;\n        const isDynamicClosure = signal.isDynamicClosure = !(isImmediateOwner && builder);\n        return callRuntime(\n          isDynamicClosure ? \"dynamicClosure\" : \"closure\",\n          getScopeAccessorLiteral(referencedBindings),\n          getSignalFn(signal, [\n            scopeIdentifier,\n            import_compiler19.types.identifier(referencedBindings.name)\n          ]),\n          isImmediateOwner ? null : import_compiler19.types.arrowFunctionExpression([scopeIdentifier], ownerScope),\n          buildSignalIntersections(signal)\n        );\n      };\n    }\n  }\n  return signal;\n}\nfunction initValue(binding, runtimeHelper = \"value\") {\n  const valueAccessor = getScopeAccessorLiteral(binding);\n  const section = binding.section;\n  const signal = getSignal(section, binding);\n  signal.build = () => {\n    const fn = getSignalFn(signal, [\n      scopeIdentifier,\n      import_compiler19.types.identifier(binding.name)\n    ]);\n    const intersections = buildSignalIntersections(signal);\n    const isParamBinding = !binding.upstreamAlias && (binding.type === 3 /* param */ || binding.type === 2 /* input */);\n    const isNakedAlias = binding.upstreamAlias && !binding.property;\n    const needsGuard = !isNakedAlias && (binding.downstreamExpressions.size || fn.body.body.length > 0);\n    const needsCache = needsGuard || intersections;\n    const needsMarks = isParamBinding || intersections;\n    if (needsCache || needsMarks) {\n      return callRuntime(runtimeHelper, valueAccessor, fn, intersections);\n    } else {\n      return fn;\n    }\n  };\n  signal.valueAccessor = valueAccessor;\n  for (const alias of binding.aliases) {\n    initValue(alias);\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    initValue(alias);\n  }\n  return signal;\n}\nfunction getSignalFn(signal, params, referencedBindings) {\n  const section = signal.section;\n  const binding = signal.referencedBindings;\n  if (binding && !Array.isArray(binding) && binding.section === section) {\n    const [scopeIdentifier2, valueIdentifier] = params;\n    for (const alias of binding.aliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler19.types.expressionStatement(\n          import_compiler19.types.callExpression(aliasSignal.identifier, [\n            scopeIdentifier2,\n            valueIdentifier,\n            ...getTranslatedExtraArgs(aliasSignal)\n          ])\n        )\n      );\n    }\n    for (const [key, alias] of binding.propertyAliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler19.types.expressionStatement(\n          import_compiler19.types.callExpression(aliasSignal.identifier, [\n            scopeIdentifier2,\n            toMemberExpression(valueIdentifier, key, binding.nullable),\n            ...getTranslatedExtraArgs(aliasSignal)\n          ])\n        )\n      );\n    }\n  }\n  for (const value of signal.values) {\n    signal.render.push(\n      import_compiler19.types.expressionStatement(\n        import_compiler19.types.callExpression(value.signal.identifier, [\n          value.scope,\n          value.value,\n          ...getTranslatedExtraArgs(value.signal)\n        ])\n      )\n    );\n  }\n  if (referencedBindings) {\n    signal.render.unshift(\n      import_compiler19.types.variableDeclaration(\"const\", [\n        import_compiler19.types.variableDeclarator(\n          createScopeReadPattern(section, referencedBindings),\n          scopeIdentifier\n        )\n      ])\n    );\n  }\n  return import_compiler19.types.arrowFunctionExpression(params, import_compiler19.types.blockStatement(signal.render));\n}\nvar hasTranslatedExtraArgs = /* @__PURE__ */ new WeakSet();\nvar emptyExtraArgs = [];\nfunction getTranslatedExtraArgs(signal) {\n  if (signal.extraArgs) {\n    if (!hasTranslatedExtraArgs.has(signal)) {\n      hasTranslatedExtraArgs.add(signal);\n      traverseReplace(signal, \"extraArgs\", replaceRenderNode);\n    }\n    return signal.extraArgs;\n  }\n  return emptyExtraArgs;\n}\nfunction buildSignalIntersections(signal) {\n  const section = signal.section;\n  let intersections = signal.intersection;\n  const binding = signal.referencedBindings;\n  if (binding && !Array.isArray(binding) && binding.section === signal.section) {\n    for (const alias of binding.aliases) {\n      const signal2 = getSignal(alias.section, alias);\n      if (signal2.hasDownstreamIntersections()) {\n        intersections = push(\n          intersections,\n          import_compiler19.types.identifier(signal2.identifier.name)\n        );\n      }\n    }\n    for (const [, alias] of binding.propertyAliases) {\n      const signal2 = getSignal(alias.section, alias);\n      if (signal2.hasDownstreamIntersections()) {\n        intersections = push(\n          intersections,\n          import_compiler19.types.identifier(signal2.identifier.name)\n        );\n      }\n    }\n  }\n  for (const value of signal.values) {\n    if (value.signal.hasDownstreamIntersections()) {\n      intersections = push(\n        intersections,\n        value.intersectionExpression ?? (import_compiler19.types.isMemberExpression(value.signal.identifier) ? value.signal.identifier : import_compiler19.types.identifier(value.signal.identifier.name))\n      );\n    }\n  }\n  const closureEntries = Array.from(signal.closures.entries()).sort(\n    ([a], [b]) => a.id - b.id\n  );\n  for (const [closureSection, closureSignal] of closureEntries) {\n    const builder = getSubscribeBuilder(closureSection);\n    const isImmediateOwner = closureSection.parent === section;\n    if (builder && isImmediateOwner) {\n      intersections = push(intersections, builder(closureSignal.identifier));\n    } else if (!signal.hasDynamicSubscribers) {\n      signal.hasDynamicSubscribers = true;\n    }\n  }\n  if (signal.hasDynamicSubscribers) {\n    signal.hasDynamicSubscribers = true;\n    intersections = push(\n      intersections,\n      callRuntime(\"dynamicSubscribers\", signal.valueAccessor)\n    );\n  }\n  return intersections && import_compiler19.types.arrowFunctionExpression(\n    [],\n    Array.isArray(intersections) ? callRuntime(\"intersections\", import_compiler19.types.arrayExpression(intersections)) : intersections\n  );\n}\nfunction subscribe(provider, subscriber) {\n  if (Array.isArray(provider)) {\n    provider.forEach((p) => subscribe(p, subscriber));\n    return;\n  }\n  const providerSignal = getSignal(subscriber.section, provider);\n  providerSignal.intersection = push(\n    providerSignal.intersection,\n    subscriber.identifier\n  );\n}\nfunction generateSignalName(referencedBindings) {\n  let name2;\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      name2 = \"expr\";\n      for (const ref of referencedBindings) {\n        name2 += `_${ref.name}`;\n      }\n    } else {\n      name2 = referencedBindings.name;\n    }\n  } else {\n    name2 = \"setup\";\n  }\n  return name2;\n}\nfunction finalizeSignalArgs(args) {\n  for (let i = args.length - 1; i >= 0; i--) {\n    const arg = args[i];\n    if (import_compiler19.types.isArrowFunctionExpression(arg) && import_compiler19.types.isBlockStatement(arg.body)) {\n      const body = arg.body.body;\n      if (body.length === 0) {\n        args[i] = import_compiler19.types.numericLiteral(0);\n      } else if (body.length === 1 && import_compiler19.types.isExpressionStatement(body[0])) {\n        arg.body = toParenthesizedExpressionIfNeeded(body[0].expression);\n      }\n    }\n  }\n  for (let i = args.length - 1; import_compiler19.types.isNullLiteral(args[i]); ) {\n    args.length = i--;\n  }\n}\nfunction addStatement(type, targetSection, referencedBindings, statement, usedReferences) {\n  const signal = getSignal(targetSection, referencedBindings);\n  const statements = signal[type] ??= [];\n  const add = type === \"effect\" ? addEffectReferences : addRenderReferences;\n  if (Array.isArray(statement)) {\n    statements.push(...statement);\n  } else {\n    statements.push(statement);\n  }\n  if (usedReferences !== false) {\n    if (usedReferences) {\n      for (const ref of usedReferences) {\n        add(signal, ref);\n      }\n    } else {\n      add(signal, referencedBindings);\n    }\n  }\n}\nfunction addEffectReferences(signal, referencedBindings) {\n  signal.effectReferencedBindings = bindingUtil.union(\n    signal.effectReferencedBindings,\n    referencedBindings\n  );\n}\nfunction addRenderReferences(signal, referencedBindings) {\n  signal.renderReferencedBindings = bindingUtil.union(\n    signal.renderReferencedBindings,\n    referencedBindings\n  );\n}\nfunction addValue(targetSection, referencedBindings, signal, value, scope = scopeIdentifier, intersectionExpression) {\n  getSignal(targetSection, referencedBindings).values.push({\n    signal,\n    value,\n    scope,\n    intersectionExpression\n  });\n}\nfunction getResumeRegisterId(section, referencedBindings, type) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let name2 = \"\";\n  if (referencedBindings) {\n    if (typeof referencedBindings === \"string\") {\n      name2 += `_${referencedBindings}`;\n    } else if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        name2 += `_${ref.name}`;\n      }\n    } else {\n      name2 += `_${referencedBindings.name}`;\n    }\n  }\n  return (0, import_babel_utils10.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}${name2}${type ? \"/\" + type : \"\"}`\n  );\n}\nvar usedRegisterIdsBySection = /* @__PURE__ */ new WeakMap();\nfunction getRegisterUID(section, name2) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = currentProgramPath.hub.file;\n  let used = usedRegisterIdsBySection.get(section);\n  if (!used) usedRegisterIdsBySection.set(section, used = /* @__PURE__ */ new Set());\n  const baseId = (0, import_babel_utils10.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}/${name2}`\n  );\n  let count = 0;\n  let id = baseId;\n  while (used.has(id)) {\n    id = baseId + \"_\" + ++count;\n  }\n  used.add(id);\n  return id;\n}\nfunction writeSignals(section) {\n  const signals = [...getSignals(section).values()].sort(sortSignals);\n  for (const signal of signals) {\n    traverseReplace(signal, \"render\", replaceRenderNode);\n    for (const value2 of signal.values) {\n      traverseReplace(value2, \"value\", replaceRenderNode);\n    }\n    let effectDeclarator;\n    if (signal.effect.length) {\n      traverseReplace(signal, \"effect\", replaceEffectNode);\n      const effectIdentifier = import_compiler19.types.identifier(`${signal.identifier.name}_effect`);\n      const referencedBindings = signal.effectReferencedBindings;\n      const referencesScope = traverseContains(\n        signal.effect,\n        isScopeIdentifier\n      );\n      effectDeclarator = import_compiler19.types.variableDeclarator(\n        effectIdentifier,\n        callRuntime(\n          \"effect\",\n          import_compiler19.types.stringLiteral(\n            getResumeRegisterId(section, signal.referencedBindings)\n          ),\n          import_compiler19.types.arrowFunctionExpression(\n            referencedBindings ? referencesScope ? [\n              scopeIdentifier,\n              createScopeReadPattern(section, referencedBindings)\n            ] : [createScopeReadPattern(section, referencedBindings)] : referencesScope ? [scopeIdentifier] : [],\n            toFirstExpressionOrBlock(signal.effect)\n          )\n        )\n      );\n      signal.render.push(\n        import_compiler19.types.expressionStatement(\n          import_compiler19.types.callExpression(effectIdentifier, [scopeIdentifier])\n        )\n      );\n    }\n    let value = signal.build();\n    if (import_compiler19.types.isCallExpression(value)) {\n      finalizeSignalArgs(value.arguments);\n    }\n    if (signal.register) {\n      value = callRuntime(\n        \"registerBoundSignal\",\n        import_compiler19.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings, \"var\")\n        ),\n        value\n      );\n    }\n    if (signal.isDynamicClosure && isStatefulReferences(signal.referencedBindings)) {\n      value = callRuntime(\n        \"registerSubscriber\",\n        import_compiler19.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings, \"subscriber\")\n        ),\n        value\n      );\n    }\n    const signalDeclarator = import_compiler19.types.variableDeclarator(signal.identifier, value);\n    let signalDeclaration = !section.parent && !signal.referencedBindings && (import_compiler19.types.isFunctionExpression(value) || import_compiler19.types.isArrowFunctionExpression(value)) ? import_compiler19.types.functionDeclaration(\n      signal.identifier,\n      value.params,\n      import_compiler19.types.isExpression(value.body) ? import_compiler19.types.blockStatement([import_compiler19.types.expressionStatement(value.body)]) : value.body\n    ) : import_compiler19.types.variableDeclaration(\"const\", [signalDeclarator]);\n    if (signal.export) {\n      signalDeclaration = import_compiler19.types.exportNamedDeclaration(signalDeclaration);\n    }\n    currentProgramPath.pushContainer(\n      \"body\",\n      effectDeclarator ? [\n        import_compiler19.types.variableDeclaration(\"const\", [effectDeclarator]),\n        signalDeclaration\n      ] : signalDeclaration\n    );\n  }\n}\nfunction writeRegisteredFns() {\n  const registeredFns = registeredFnsForProgram.get(currentProgramPath.node);\n  const statements = [];\n  if (registeredFns) {\n    for (const registeredFn of registeredFns) {\n      let fn;\n      const params = registeredFn.referencedBindings ? registeredFn.referencesScope ? [\n        scopeIdentifier,\n        import_compiler19.types.assignmentPattern(\n          createScopeReadPattern(\n            registeredFn.section,\n            registeredFn.referencedBindings\n          ),\n          scopeIdentifier\n        )\n      ] : [\n        createScopeReadPattern(\n          registeredFn.section,\n          registeredFn.referencedBindings\n        )\n      ] : registeredFn.referencesScope ? [scopeIdentifier] : void 0;\n      if (params) {\n        fn = import_compiler19.types.functionDeclaration(\n          import_compiler19.types.identifier(registeredFn.id),\n          params,\n          import_compiler19.types.blockStatement(toReturnedFunction(registeredFn.node))\n        );\n      } else if (registeredFn.node.type === \"FunctionDeclaration\" && registeredFn.node.id?.name === registeredFn.id) {\n        fn = registeredFn.node;\n      } else {\n        fn = import_compiler19.types.functionDeclaration(\n          import_compiler19.types.identifier(registeredFn.id),\n          registeredFn.node.params,\n          registeredFn.node.body.type === \"BlockStatement\" ? registeredFn.node.body : import_compiler19.types.blockStatement([import_compiler19.types.returnStatement(registeredFn.node.body)]),\n          registeredFn.node.generator,\n          registeredFn.node.async\n        );\n      }\n      statements.push(fn);\n    }\n    for (const registeredFn of registeredFns) {\n      statements.push(\n        import_compiler19.types.expressionStatement(\n          callRuntime(\n            \"register\",\n            import_compiler19.types.stringLiteral(registeredFn.registerId),\n            import_compiler19.types.identifier(registeredFn.id)\n          )\n        )\n      );\n    }\n    for (const stmt of currentProgramPath.pushContainer(\"body\", statements)) {\n      stmt.skip();\n    }\n  }\n}\nfunction toReturnedFunction(rawFn) {\n  const fn = simplifyFunction(rawFn);\n  return fn.type === \"FunctionDeclaration\" ? [fn, import_compiler19.types.returnStatement(fn.id)] : [import_compiler19.types.returnStatement(fn)];\n}\nfunction sortSignals(a, b) {\n  const aReferencedBindings = getReferencedBindings(a);\n  const bReferencedBindings = getReferencedBindings(b);\n  for (let i = Math.max(aReferencedBindings.length, bReferencedBindings.length) - 1; i >= 0; i--) {\n    const diff = (bReferencedBindings[i] ?? -1) - (aReferencedBindings[i] ?? -1);\n    if (diff !== 0) return diff;\n  }\n  return 0;\n}\nfunction getReferencedBindings({ referencedBindings: reserve }) {\n  if (!reserve) {\n    return [];\n  } else if (Array.isArray(reserve)) {\n    return reserve.map(getMappedId).sort();\n  } else {\n    return [getMappedId(reserve)];\n  }\n}\nfunction getMappedId(reference) {\n  return (reference.type === 0 /* dom */ ? 1 : 0) * 1e4 + reference.id;\n}\nfunction addHTMLEffectCall(section, referencedBindings) {\n  addStatement(\"effect\", section, referencedBindings, void 0, false);\n}\nfunction writeHTMLResumeStatements(path4, tagVarIdentifier) {\n  const section = getSectionForBody(path4);\n  if (!section) return;\n  const allSignals = Array.from(getSignals(section).values());\n  const scopeIdIdentifier = getScopeIdIdentifier(section);\n  forEach(section.closures, (closure) => {\n    if (isStatefulReferences(closure)) {\n      let currentSection = section;\n      while (currentSection !== closure.section) {\n        getSerializedScopeProperties(currentSection).set(\n          import_compiler19.types.stringLiteral(\"_\"),\n          callRuntime(\n            \"ensureScopeWithId\",\n            getScopeIdIdentifier(currentSection = currentSection.parent)\n          )\n        );\n      }\n      setForceResumeScope(closure.section);\n      const isImmediateOwner = section.parent?.id === closure.section.id;\n      const isDynamicClosure = !getSubscribeBuilder(section) || !isImmediateOwner;\n      if (isDynamicClosure) {\n        path4.pushContainer(\n          \"body\",\n          import_compiler19.types.expressionStatement(\n            callRuntime(\n              \"writeEffect\",\n              scopeIdIdentifier,\n              import_compiler19.types.stringLiteral(\n                getResumeRegisterId(section, closure, \"subscriber\")\n              )\n            )\n          )\n        );\n      }\n    }\n  });\n  for (let i = allSignals.length; i--; ) {\n    if (allSignals[i].effect.length) {\n      const signalRefs = allSignals[i].referencedBindings;\n      path4.pushContainer(\n        \"body\",\n        import_compiler19.types.expressionStatement(\n          callRuntime(\n            \"writeEffect\",\n            scopeIdIdentifier,\n            import_compiler19.types.stringLiteral(getResumeRegisterId(section, signalRefs))\n          )\n        )\n      );\n    }\n  }\n  const accessors = /* @__PURE__ */ new Set();\n  const additionalProperties = getSerializedScopeProperties(section);\n  const serializedProperties = [];\n  forEach(section.bindings, (binding) => {\n    if (binding.serialize && binding.type !== 0 /* dom */) {\n      const accessor = getScopeAccessorLiteral(binding);\n      serializedProperties.push(\n        import_compiler19.types.objectProperty(accessor, getDeclaredBindingExpression(binding))\n      );\n      accessors.add(accessor.value);\n    }\n  });\n  if (tagVarIdentifier && returnId(section) !== void 0) {\n    serializedProperties.push(\n      import_compiler19.types.objectProperty(\n        import_compiler19.types.stringLiteral(\"/\" /* TagVariable */),\n        tagVarIdentifier\n      )\n    );\n  }\n  for (const [key, value] of additionalProperties) {\n    if (!accessors.has(key.value)) {\n      serializedProperties.push(\n        import_compiler19.types.objectProperty(key, value, !import_compiler19.types.isLiteral(key))\n      );\n      accessors.add(key.value);\n    }\n  }\n  if (serializedProperties.length || forceResumeScope(section)) {\n    path4.pushContainer(\n      \"body\",\n      import_compiler19.types.expressionStatement(\n        callRuntime(\n          \"writeScope\",\n          scopeIdIdentifier,\n          import_compiler19.types.objectExpression(serializedProperties)\n        )\n      )\n    );\n  }\n  if (path4.get(\"body\").length) {\n    path4.unshiftContainer(\n      \"body\",\n      import_compiler19.types.variableDeclaration(\"const\", [\n        import_compiler19.types.variableDeclarator(scopeIdIdentifier, callRuntime(\"nextScopeId\"))\n      ])\n    );\n  }\n}\nfunction getSetup(section) {\n  return getSignals(section).get(void 0)?.identifier;\n}\nfunction replaceRenderNode(node) {\n  return replaceAssignedNode(node) || replaceBindingReadNode(node) || replaceRegisteredFunctionNode(node);\n}\nfunction replaceEffectNode(node) {\n  return replaceAssignedNode(node) || replaceBindingReadNode(node);\n}\nfunction replaceBindingReadNode(node) {\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\": {\n      return getReadReplacement(node);\n    }\n  }\n}\nfunction replaceAssignedNode(node) {\n  switch (node.type) {\n    case \"UpdateExpression\": {\n      const { extra } = node.argument;\n      if (isAssignedBindingExtra(extra)) {\n        const { buildAssignment } = getSignal(\n          extra.assignment.section,\n          extra.assignment\n        );\n        if (buildAssignment) {\n          const replacement = buildAssignment(\n            extra.section,\n            import_compiler19.types.binaryExpression(\n              node.operator === \"++\" ? \"+\" : \"-\",\n              node.argument,\n              import_compiler19.types.numericLiteral(1)\n            )\n          );\n          if (!node.prefix) {\n            return import_compiler19.types.sequenceExpression([replacement, node.argument]);\n          }\n          return replacement;\n        }\n      }\n      break;\n    }\n    case \"AssignmentExpression\":\n      switch (node.left.type) {\n        case \"Identifier\": {\n          const { extra } = node.left;\n          if (isAssignedBindingExtra(extra)) {\n            const { buildAssignment } = getSignal(\n              extra.assignment.section,\n              extra.assignment\n            );\n            if (buildAssignment) {\n              return buildAssignment(\n                extra.section,\n                node.operator === \"=\" ? node.right : import_compiler19.types.binaryExpression(\n                  node.operator.slice(\n                    0,\n                    -1\n                  ),\n                  node.left,\n                  node.right\n                )\n              );\n            }\n          }\n          break;\n        }\n        case \"ArrayPattern\":\n        case \"ObjectPattern\": {\n          let params;\n          let assignments;\n          forEachIdentifier(node.left, (id) => {\n            const { extra } = id;\n            if (isAssignedBindingExtra(extra)) {\n              const signal = getSignal(\n                extra.assignment.section,\n                extra.assignment\n              );\n              if (signal?.buildAssignment) {\n                id.name = currentProgramPath.scope.generateUid(id.name);\n                (params ||= []).push(import_compiler19.types.identifier(id.name));\n                (assignments ||= []).push(\n                  signal.buildAssignment(extra.section, import_compiler19.types.identifier(id.name))\n                );\n              }\n            }\n          });\n          if (params && assignments) {\n            const resultId = currentProgramPath.scope.generateUid(\"result\");\n            return import_compiler19.types.callExpression(\n              import_compiler19.types.arrowFunctionExpression(\n                [import_compiler19.types.identifier(resultId), ...params],\n                import_compiler19.types.sequenceExpression([\n                  import_compiler19.types.assignmentExpression(\n                    \"=\",\n                    node.left,\n                    import_compiler19.types.identifier(resultId)\n                  ),\n                  ...assignments,\n                  import_compiler19.types.identifier(resultId)\n                ])\n              ),\n              [node.right]\n            );\n          }\n          break;\n        }\n      }\n      break;\n  }\n}\nvar registeredFnsForProgram = /* @__PURE__ */ new WeakMap();\nfunction replaceRegisteredFunctionNode(node) {\n  switch (node.type) {\n    case \"ClassMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler19.types.classProperty(node.key, replacement);\n    }\n    case \"ClassPrivateMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler19.types.classPrivateProperty(node.key, replacement);\n    }\n    case \"ObjectMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler19.types.objectProperty(node.key, replacement);\n    }\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\": {\n      return getRegisteredFnExpression(node);\n    }\n    case \"FunctionDeclaration\": {\n      const replacement = getRegisteredFnExpression(node);\n      if (replacement) {\n        return import_compiler19.types.variableDeclaration(\"const\", [\n          import_compiler19.types.variableDeclarator(node.id, replacement)\n        ]);\n      }\n      break;\n    }\n  }\n}\nfunction getRegisteredFnExpression(node) {\n  const { extra } = node;\n  if (isRegisteredFnExtra(extra)) {\n    const id = currentProgramPath.scope.generateUid(extra.name);\n    const referencesScope = extra.referencesScope;\n    const referencedBindings = extra.referencedBindingsInFunction;\n    let registedFns = registeredFnsForProgram.get(currentProgramPath.node);\n    if (!registedFns) {\n      registeredFnsForProgram.set(currentProgramPath.node, registedFns = []);\n    }\n    registedFns.push({\n      id,\n      node,\n      registerId: extra.registerId,\n      section: extra.section,\n      referencesScope,\n      referencedBindings\n    });\n    if (referencesScope || referencedBindings) {\n      return import_compiler19.types.callExpression(import_compiler19.types.identifier(id), [scopeIdentifier]);\n    } else {\n      return import_compiler19.types.identifier(id);\n    }\n  }\n}\n\n// src/translator/visitors/program/dom.ts\nvar dom_default = {\n  translate: {\n    exit(program) {\n      visit(program);\n      const section = getSectionForBody(program);\n      const { walks, writes, setup } = getSectionMeta(section);\n      const domExports = program.node.extra.domExports;\n      const templateIdentifier = import_compiler20.types.identifier(domExports.template);\n      const walksIdentifier = import_compiler20.types.identifier(domExports.walks);\n      const setupIdentifier = import_compiler20.types.identifier(domExports.setup);\n      const closuresIdentifier = import_compiler20.types.identifier(domExports.closures);\n      const paramsBinding = program.node.extra.binding;\n      const programParamsSignal = paramsBinding && bindingHasDownstreamExpressions(paramsBinding) ? initValue(paramsBinding) : void 0;\n      forEachSectionReverse((childSection) => {\n        if (childSection !== section) {\n          const tagParamsSignal = childSection.params && initValue(childSection.params);\n          const { walks: walks2, writes: writes2, setup: setup2 } = getSectionMeta(childSection);\n          const closures2 = getSectionClosuresExpr(childSection);\n          const identifier = import_compiler20.types.identifier(childSection.name);\n          const renderer = callRuntime(\n            getSectionParentIsOwner(childSection) ? \"createRenderer\" : \"createRendererWithOwner\",\n            writes2,\n            walks2,\n            setup2,\n            closures2 && import_compiler20.types.arrowFunctionExpression([], closures2),\n            tagParamsSignal?.identifier && import_compiler20.types.arrowFunctionExpression([], tagParamsSignal.identifier)\n          );\n          writeSignals(childSection);\n          program.node.body.push(\n            import_compiler20.types.variableDeclaration(\"const\", [\n              import_compiler20.types.variableDeclarator(\n                identifier,\n                isStatefulSection(childSection) ? callRuntime(\n                  \"register\",\n                  import_compiler20.types.stringLiteral(\n                    getResumeRegisterId(childSection, \"renderer\")\n                  ),\n                  renderer\n                ) : renderer\n              )\n            ])\n          );\n        }\n      });\n      const closures = getSectionClosuresExpr(section);\n      writeSignals(section);\n      writeRegisteredFns();\n      if (!setup) {\n        program.node.body.unshift(\n          import_compiler20.types.exportNamedDeclaration(\n            import_compiler20.types.variableDeclaration(\"const\", [\n              import_compiler20.types.variableDeclarator(\n                setupIdentifier,\n                import_compiler20.types.arrowFunctionExpression([], import_compiler20.types.blockStatement([]))\n              )\n            ])\n          )\n        );\n      }\n      program.node.body.unshift(\n        import_compiler20.types.exportNamedDeclaration(\n          import_compiler20.types.variableDeclaration(\"const\", [\n            import_compiler20.types.variableDeclarator(\n              templateIdentifier,\n              writes || import_compiler20.types.stringLiteral(\"\")\n            )\n          ])\n        ),\n        import_compiler20.types.exportNamedDeclaration(\n          import_compiler20.types.variableDeclaration(\"const\", [\n            import_compiler20.types.variableDeclarator(walksIdentifier, walks || import_compiler20.types.stringLiteral(\"\"))\n          ])\n        )\n      );\n      if (closures) {\n        program.node.body.push(\n          import_compiler20.types.exportNamedDeclaration(\n            import_compiler20.types.variableDeclaration(\"const\", [\n              import_compiler20.types.variableDeclarator(closuresIdentifier, closures)\n            ])\n          )\n        );\n      }\n      program.node.body.push(\n        import_compiler20.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            import_compiler20.types.stringLiteral(program.hub.file.metadata.marko.id),\n            templateIdentifier,\n            walksIdentifier,\n            setupIdentifier,\n            closures && import_compiler20.types.arrowFunctionExpression([], closuresIdentifier),\n            programParamsSignal?.identifier && import_compiler20.types.arrowFunctionExpression([], programParamsSignal.identifier)\n          )\n        )\n      );\n    }\n  }\n};\nfunction getSectionClosuresExpr(section) {\n  if (section.closures) {\n    return import_compiler20.types.arrayExpression(\n      map(\n        section.closures,\n        (closure) => getSignal(section, closure).identifier\n      ).reverse()\n    );\n  }\n}\n\n// src/translator/visitors/program/html.ts\nvar import_compiler21 = require(\"@marko/compiler\");\n\n// src/translator/util/is-static.ts\nfunction isStatic(path4) {\n  return path4.isImportDeclaration() || path4.isExportDeclaration() || path4.isMarkoScriptlet({ static: true });\n}\n\n// src/translator/visitors/program/html.ts\nvar html_default = {\n  translate: {\n    exit(program) {\n      const section = getSectionForBody(program);\n      const tagVarIdentifier = program.scope.generateUidIdentifier(\"tagVar\");\n      flushInto(program);\n      writeHTMLResumeStatements(program, tagVarIdentifier);\n      traverseReplace(program.node, \"body\", replaceNode);\n      const returnIdentifier = returnId(section);\n      if (returnIdentifier !== void 0) {\n        program.pushContainer(\"body\", import_compiler21.types.returnStatement(returnIdentifier));\n      }\n      const renderContent = [];\n      for (const child of program.get(\"body\")) {\n        if (!isStatic(child)) {\n          renderContent.push(child.node);\n          child.remove();\n        } else if (child.isMarkoScriptlet()) {\n          if (child.node.target && child.node.target !== \"server\") {\n            child.remove();\n          } else {\n            child.replaceWithMultiple(child.node.body);\n          }\n        }\n      }\n      program.pushContainer(\"body\", [\n        import_compiler21.types.variableDeclaration(\"const\", [\n          import_compiler21.types.variableDeclarator(\n            htmlRendererIdentifier,\n            callRuntime(\n              \"createRenderer\",\n              import_compiler21.types.arrowFunctionExpression(\n                [import_compiler21.types.identifier(\"input\"), tagVarIdentifier],\n                import_compiler21.types.blockStatement(renderContent)\n              )\n            )\n          )\n        ]),\n        import_compiler21.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            import_compiler21.types.stringLiteral(program.hub.file.metadata.marko.id),\n            htmlRendererIdentifier\n          )\n        )\n      ]);\n    }\n  }\n};\nfunction replaceNode(node, container) {\n  return replaceBindingReadNode2(node) || replaceRegisteredFunctionNode2(node, container);\n}\nfunction replaceBindingReadNode2(node) {\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\": {\n      const { extra } = node;\n      if (extra && !(extra.read && !extra.read.binding.declared || extra.binding && !extra.binding.declared)) {\n        return getReadReplacement(node);\n      }\n    }\n  }\n}\nfunction replaceRegisteredFunctionNode2(node, container) {\n  switch (node.type) {\n    case \"ClassMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler21.types.classProperty(node.key, replacement);\n    }\n    case \"ClassPrivateMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler21.types.classPrivateProperty(node.key, replacement);\n    }\n    case \"ObjectMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler21.types.objectProperty(node.key, replacement);\n    }\n    case \"FunctionDeclaration\": {\n      const { extra } = node;\n      if (isRegisteredFnExtra(extra)) {\n        let registeredFnDeclarations = registeredFnDeclarationsByBody.get(\n          container\n        );\n        if (!registeredFnDeclarations) {\n          registeredFnDeclarationsByBody.set(\n            container,\n            registeredFnDeclarations = []\n          );\n        }\n        registeredFnDeclarations.push({\n          id: node.id.name,\n          registerId: extra.registerId\n        });\n      }\n      break;\n    }\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\": {\n      return getRegisteredFnExpression2(node);\n    }\n    case \"BlockStatement\":\n    case \"MarkoScriptlet\":\n      addRegisteredDeclarations(node.body);\n      break;\n  }\n}\nvar registeredFnDeclarationsByBody = /* @__PURE__ */ new WeakMap();\nfunction addRegisteredDeclarations(body) {\n  const registeredFnDeclarations = registeredFnDeclarationsByBody.get(body);\n  if (registeredFnDeclarations) {\n    for (const { id, registerId } of registeredFnDeclarations) {\n      body.push(\n        import_compiler21.types.expressionStatement(\n          callRuntime(\n            \"register\",\n            import_compiler21.types.identifier(id),\n            import_compiler21.types.stringLiteral(registerId)\n          )\n        )\n      );\n    }\n  }\n}\nfunction getRegisteredFnExpression2(node) {\n  const { extra } = node;\n  if (isRegisteredFnExtra(extra)) {\n    return callRuntime(\n      \"register\",\n      simplifyFunction(node),\n      import_compiler21.types.stringLiteral(extra.registerId),\n      (extra.referencedBindingsInFunction || extra.referencesScope) && getScopeIdIdentifier(extra.section)\n    );\n  }\n}\n\n// src/translator/visitors/program/index.ts\nvar currentProgramPath;\nvar cleanIdentifier;\nvar htmlRendererIdentifier;\nvar scopeIdentifier;\nfunction isScopeIdentifier(node) {\n  return node === scopeIdentifier;\n}\nvar previousProgramPath = /* @__PURE__ */ new WeakMap();\nvar program_default = {\n  migrate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      program.node.params = [import_compiler22.types.identifier(\"input\")];\n      currentProgramPath = program;\n    },\n    exit() {\n      currentProgramPath.scope.crawl();\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  analyze: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      startSection(program);\n      trackParamsReferences(program, 2 /* input */);\n      program.node.params[0].extra.binding.nullable = false;\n      const { scope } = program;\n      (program.node.extra ??= {}).domExports = {\n        template: scope.generateUid(\"template_\"),\n        walks: scope.generateUid(\"walks_\"),\n        setup: scope.generateUid(\"setup_\"),\n        params: void 0,\n        // TODO look into recursive components with fine grained params.\n        closures: scope.generateUid(\"closures_\")\n      };\n    },\n    exit(program) {\n      finalizeReferences();\n      const {\n        scope,\n        node: { extra }\n      } = program;\n      if (extra.binding && bindingHasDownstreamExpressions(extra.binding)) {\n        extra.domExports.params = buildTemplateExports(extra.binding, scope);\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  },\n  translate: {\n    enter(program) {\n      previousProgramPath.set(program, currentProgramPath);\n      currentProgramPath = program;\n      scopeIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"scope\") : null;\n      cleanIdentifier = isOutputDOM() ? program.scope.generateUidIdentifier(\"clean\") : null;\n      htmlRendererIdentifier = isOutputHTML() ? program.scope.generateUidIdentifier(\"renderer\") : null;\n      if (getMarkoOpts().output === \"hydrate\") {\n        const entryFile = program.hub.file;\n        const visitedFiles = /* @__PURE__ */ new Set([\n          (0, import_babel_utils11.resolveRelativePath)(entryFile, entryFile.opts.filename)\n        ]);\n        entry_builder_default.visit(entryFile, entryFile, function visitChild(resolved) {\n          if (!visitedFiles.has(resolved)) {\n            visitedFiles.add(resolved);\n            const file = (0, import_babel_utils11.loadFileForImport)(entryFile, resolved);\n            if (file) {\n              entry_builder_default.visit(\n                file,\n                entryFile,\n                (id) => visitChild(resolveRelativeToEntry(entryFile, file, id))\n              );\n            }\n          }\n        });\n        program.node.body = entry_builder_default.build(entryFile);\n        program.skip();\n        return;\n      }\n    },\n    exit(program) {\n      if (isOutputHTML()) {\n        html_default.translate.exit(program);\n      } else {\n        dom_default.translate.exit(program);\n      }\n      if (program.node.extra?.needsCompat) {\n        const compatFile = getCompatRuntimeFile();\n        const body = [void 0];\n        for (const child of program.node.body) {\n          if (child.type === \"ImportDeclaration\" && child.source.value === compatFile) {\n            body[0] = child;\n          } else {\n            body.push(child);\n          }\n        }\n        body[0] ??= import_compiler22.types.importDeclaration([], import_compiler22.types.stringLiteral(compatFile));\n        program.node.body = body;\n      }\n      currentProgramPath = previousProgramPath.get(currentProgramPath);\n    }\n  }\n};\nfunction resolveRelativeToEntry(entryFile, file, req) {\n  return file === entryFile ? (0, import_babel_utils11.resolveRelativePath)(file, req) : (0, import_babel_utils11.resolveRelativePath)(\n    entryFile,\n    req[0] === \".\" ? import_path.default.join(file.opts.filename, \"..\", req) : req\n  );\n}\nfunction buildTemplateExports(binding, scope) {\n  const templateExport = {\n    id: binding.export ??= scope.generateUid(binding.name + \"_\"),\n    props: void 0\n  };\n  const { aliases, propertyAliases, downstreamExpressions } = binding;\n  if (!downstreamExpressions.size) {\n    templateExport.props = {};\n    for (const [property, alias] of propertyAliases) {\n      templateExport.props[property] = buildTemplateExports(alias, scope);\n    }\n    for (const alias of aliases) {\n      const exports2 = buildTemplateExports(alias, scope);\n      if (exports2.props) {\n        templateExport.props = { ...templateExport.props, ...exports2.props };\n      } else {\n        templateExport.props = void 0;\n        return templateExport;\n      }\n    }\n  }\n  return templateExport;\n}\n\n// src/translator/util/marko-config.ts\nfunction isOutputHTML() {\n  return getMarkoOpts().output === \"html\";\n}\nfunction isOutputDOM() {\n  return !isOutputHTML();\n}\nfunction getMarkoOpts() {\n  return currentProgramPath.hub.file.markoOpts;\n}\nfunction isOptimize() {\n  return getMarkoOpts().optimize;\n}\n\n// src/translator/util/translate-var.ts\nvar import_compiler23 = require(\"@marko/compiler\");\nfunction translateVar(tag, initialValue, kind = \"const\") {\n  const {\n    node: { var: tagVar }\n  } = tag;\n  if (!tagVar) {\n    return;\n  }\n  tag.insertBefore(\n    import_compiler23.types.variableDeclaration(kind, [import_compiler23.types.variableDeclarator(tagVar, initialValue)])\n  );\n}\n\n// src/translator/core/const.ts\nvar const_default = {\n  analyze(tag) {\n    (0, import_babel_utils12.assertNoArgs)(tag);\n    (0, import_babel_utils12.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a tag variable.\");\n    }\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler24.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `const` tag only supports the `value` attribute.\"\n      );\n    }\n    const upstreamAlias = import_compiler24.types.isIdentifier(valueAttr.value) ? tag.scope.getBinding(valueAttr.value.name)?.identifier.extra?.binding : void 0;\n    trackVarReferences(\n      tag,\n      4 /* derived */,\n      upstreamAlias,\n      evaluate(valueAttr.value)\n      // TODO could perform a more extensive \"nullable\" check.\n    );\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      const { value } = valueAttr;\n      if (isOutputDOM()) {\n        const section = getSection(tag);\n        const varBinding = node.var.extra?.binding;\n        if (varBinding && !varBinding.upstreamAlias) {\n          const derivation = initValue(varBinding);\n          addValue(section, value.extra?.referencedBindings, derivation, value);\n        }\n      } else {\n        translateVar(tag, value);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an constant binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#const\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/const.d.marko\"\n};\n\n// src/translator/core/debug.ts\nvar import_compiler25 = require(\"@marko/compiler\");\nvar import_babel_utils13 = require(\"@marko/compiler/babel-utils\");\nvar debug_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils13.assertNoVar)(tag);\n    (0, import_babel_utils13.assertNoArgs)(tag);\n    (0, import_babel_utils13.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (tag.node.attributes.length > 1 || tag.node.attributes.length === 1 && (!import_compiler25.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\")) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `debug` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const referencedBindings = valueAttr?.value.extra?.referencedBindings;\n      const statement = withPreviousLocation(import_compiler25.types.debuggerStatement(), tag.node);\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Debug on value change.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#debug\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/debug.d.marko\"\n};\n\n// src/translator/core/define.ts\nvar import_compiler30 = require(\"@marko/compiler\");\nvar import_babel_utils18 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/translate-attrs.ts\nvar import_compiler29 = require(\"@marko/compiler\");\nvar import_babel_utils17 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/core/for.ts\nvar import_compiler27 = require(\"@marko/compiler\");\nvar import_babel_utils15 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-parent-tag.ts\nfunction getParentTag(tag) {\n  const parent = tag.parent.type === \"MarkoTagBody\" ? tag.parentPath.parentPath : tag.parentPath;\n  if (parent.type === \"MarkoTag\") {\n    return parent;\n  }\n}\n\n// src/translator/visitors/tag/native-tag.ts\nvar import_compiler26 = require(\"@marko/compiler\");\nvar import_babel_utils14 = require(\"@marko/compiler/babel-utils\");\nvar kNativeTagBinding = Symbol(\"native tag binding\");\nvar kSerializeMarker = Symbol(\"serialize marker\");\nvar kGetterId = Symbol(\"node getter id\");\nvar htmlSelectArgs = /* @__PURE__ */ new WeakMap();\nfunction assertExclusiveControllableGroups(tag, attrs2) {\n  const exclusiveGroups = [\n    attrs2.open || attrs2.openChange,\n    attrs2.checked || attrs2.checkedChange,\n    attrs2.checkedValue || attrs2.checkedValueChange,\n    attrs2.valueChange\n  ].filter(Boolean);\n  if (exclusiveGroups.length > 1) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The attributes ${exclusiveGroups.map((attr2) => `\"${attr2.name}\"`).join(\", \")} are mutually exclusive.`\n    );\n  }\n}\nfunction getRelatedControllable(tagName, attrs2) {\n  switch (tagName) {\n    case \"input\":\n      if (attrs2.checked || attrs2.checkedChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_checked\",\n          attrs: [attrs2.checked, attrs2.checkedChange]\n        };\n      }\n      if (attrs2.checkedValue || attrs2.checkedValueChange) {\n        return {\n          special: true,\n          helper: \"controllable_input_checkedValue\",\n          attrs: [attrs2.checkedValue, attrs2.checkedValueChange, attrs2.value]\n        };\n      }\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"select\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_select_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"textarea\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_textarea_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"details\":\n    case \"dialog\":\n      if (attrs2.open || attrs2.openChange) {\n        return {\n          special: false,\n          helper: \"controllable_detailsOrDialog_open\",\n          attrs: [attrs2.open, attrs2.openChange]\n        };\n      }\n      break;\n  }\n}\nvar native_tag_default = {\n  transform: {\n    enter(tag) {\n      const tagName = getTagName(tag);\n      if (tagName === \"textarea\" && tag.node.body.body.length) {\n        const parts = [];\n        for (const child of tag.node.body.body) {\n          if (child.type === \"MarkoText\" || child.type === \"MarkoPlaceholder\" && child.escape) {\n            parts.push(child.value);\n          } else {\n            throw tag.hub.file.hub.buildError(\n              child,\n              \"Unexpected content in textarea, only text and placeholders are supported.\",\n              SyntaxError\n            );\n          }\n        }\n        tag.node.attributes.push(\n          import_compiler26.types.markoAttribute(\n            \"value\",\n            normalizeStringExpression(parts) || buildUndefined()\n          )\n        );\n        tag.node.body.body = [];\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils14.assertNoArgs)(tag);\n      (0, import_babel_utils14.assertNoParams)(tag);\n      (0, import_babel_utils14.assertNoAttributeTags)(tag);\n      const { node } = tag;\n      if (node.var && !import_compiler26.types.isIdentifier(node.var)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"Tag variables on native elements cannot be destructured.\"\n        );\n      }\n      const tagName = getTagName(tag);\n      const section = getOrCreateSection(tag);\n      let hasEventHandlers = false;\n      let hasDynamicAttributes = false;\n      const seen = {};\n      const { attributes } = tag.node;\n      let relatedControllable;\n      let spreadReferenceNodes;\n      for (let i = attributes.length; i--; ) {\n        const attr2 = attributes[i];\n        if (import_compiler26.types.isMarkoAttribute(attr2)) {\n          if (seen[attr2.name]) {\n            dropReferences(attr2.value);\n            continue;\n          }\n          seen[attr2.name] = attr2;\n          if (isEventHandler(attr2.name) || isChangeHandler(attr2.name)) {\n            (attr2.value.extra ??= {}).isEffect = true;\n            hasEventHandlers = true;\n          } else if (!evaluate(attr2.value).confident) {\n            hasDynamicAttributes = true;\n          }\n        } else if (import_compiler26.types.isMarkoSpreadAttribute(attr2)) {\n          hasEventHandlers = true;\n          hasDynamicAttributes = true;\n          (attr2.value.extra ??= {}).isEffect = true;\n        }\n        if (spreadReferenceNodes) {\n          spreadReferenceNodes.push(attr2.value);\n        } else if (import_compiler26.types.isMarkoSpreadAttribute(attr2)) {\n          spreadReferenceNodes = [attr2.value];\n          relatedControllable = getRelatedControllable(tagName, seen);\n        }\n      }\n      assertExclusiveControllableGroups(tag, seen);\n      if (spreadReferenceNodes) {\n        if (relatedControllable && !relatedControllable.attrs.every(Boolean)) {\n          for (const attr2 of relatedControllable.attrs) {\n            if (attr2) {\n              spreadReferenceNodes.push(attr2.value);\n            }\n          }\n          relatedControllable = void 0;\n        }\n        mergeReferences(section, tag.node, spreadReferenceNodes);\n      } else {\n        relatedControllable = getRelatedControllable(tagName, seen);\n      }\n      if (relatedControllable) {\n        mergeReferences(\n          section,\n          relatedControllable.attrs.find(Boolean).value,\n          relatedControllable.attrs.map((it) => it?.value)\n        );\n      }\n      if (node.var || hasEventHandlers || hasDynamicAttributes) {\n        currentProgramPath.node.extra.isInteractive ||= hasEventHandlers;\n        const tagName2 = node.name.type === \"StringLiteral\" ? node.name.value : import_compiler26.types.toIdentifier(tag.get(\"name\"));\n        const tagExtra = node.extra ??= {};\n        const bindingName = \"#\" + tagName2;\n        tagExtra[kSerializeMarker] = hasEventHandlers || !!node.var;\n        tagExtra[kNativeTagBinding] = createBinding(\n          bindingName,\n          0 /* dom */,\n          section\n        );\n        if (node.var) {\n          for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n            setReferencesScope(ref);\n            if (!ref.parentPath?.isCallExpression()) {\n              tagExtra[kGetterId] = getRegisterUID(section, bindingName);\n              break;\n            }\n          }\n        }\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagName = getTagName(tag);\n      const extra = tag.node.extra;\n      const nodeRef2 = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const name2 = tag.get(\"name\");\n      const tagDef = (0, import_babel_utils14.getTagDef)(tag);\n      const write2 = writeTo(tag);\n      const section = getSection(tag);\n      if (isHTML && extra.tagNameNullable) {\n        flushBefore(tag);\n      }\n      if (tag.has(\"var\")) {\n        const getterId = extra[kGetterId];\n        if (isHTML) {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          for (const reference of references) {\n            let currentSection = getSection(reference);\n            while (currentSection !== section && currentSection.parent) {\n              getSerializedScopeProperties(currentSection).set(\n                import_compiler26.types.stringLiteral(\"_\"),\n                callRuntime(\n                  \"ensureScopeWithId\",\n                  getScopeIdIdentifier(\n                    currentSection = currentSection.parent\n                  )\n                )\n              );\n            }\n          }\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(section),\n              getterId && import_compiler26.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n              `get_${varName}`\n            );\n            currentProgramPath.pushContainer(\n              \"body\",\n              import_compiler26.types.variableDeclaration(\"const\", [\n                import_compiler26.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler26.types.stringLiteral(getterId),\n                    getScopeAccessorLiteral(nodeRef2)\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (reference.parentPath?.isCallExpression()) {\n              reference.parentPath.replaceWith(\n                import_compiler26.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, nodeRef2)\n                )\n              );\n            } else if (getterFnIdentifier) {\n              reference.replaceWith(\n                import_compiler26.types.callExpression(getterFnIdentifier, [\n                  getScopeExpression(referenceSection, getSection(tag))\n                ])\n              );\n            }\n          }\n        }\n      }\n      let visitAccessor;\n      if (nodeRef2) {\n        visitAccessor = getScopeAccessorLiteral(nodeRef2);\n        visit(tag, 32 /* Get */);\n      }\n      write2`<${name2.node}`;\n      const usedAttrs = getUsedAttrs(tagName, tag.node);\n      const { staticAttrs, staticControllable, skipExpression } = usedAttrs;\n      let { spreadExpression } = usedAttrs;\n      if (staticControllable) {\n        const { helper, attrs: attrs2 } = staticControllable;\n        const firstAttr = attrs2.find(Boolean);\n        const referencedBindings = firstAttr.value.extra?.referencedBindings;\n        const values = attrs2.map((attr2) => attr2?.value);\n        if (isHTML) {\n          if (tagName !== \"select\" && tagName !== \"textarea\") {\n            write2`${callRuntime(helper, getScopeIdIdentifier(section), visitAccessor, ...values)}`;\n          }\n          addHTMLEffectCall(section, void 0);\n        } else {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            import_compiler26.types.expressionStatement(\n              callRuntime(helper, scopeIdentifier, visitAccessor, ...values)\n            )\n          );\n          addStatement(\n            \"effect\",\n            section,\n            void 0,\n            import_compiler26.types.expressionStatement(\n              callRuntime(`${helper}_effect`, scopeIdentifier, visitAccessor)\n            )\n          );\n        }\n      }\n      let writeAtStartOfBody;\n      if (isHTML) {\n        if (tagName === \"select\") {\n          if (staticControllable) {\n            htmlSelectArgs.set(tag.node, {\n              value: staticControllable.attrs[0]?.value || buildUndefined(),\n              valueChange: staticControllable.attrs[1]?.value || buildUndefined()\n            });\n          } else if (spreadExpression) {\n            const spreadIdentifier = tag.scope.generateUidIdentifier(\"select_input\");\n            tag.insertBefore(\n              import_compiler26.types.variableDeclaration(\"const\", [\n                import_compiler26.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            htmlSelectArgs.set(tag.node, {\n              value: import_compiler26.types.memberExpression(\n                spreadIdentifier,\n                import_compiler26.types.identifier(\"value\")\n              ),\n              valueChange: import_compiler26.types.memberExpression(\n                spreadIdentifier,\n                import_compiler26.types.identifier(\"valueChange\")\n              )\n            });\n            spreadExpression = spreadIdentifier;\n          }\n        } else if (tagName === \"textarea\") {\n          let value;\n          let valueChange;\n          if (staticControllable) {\n            value = staticControllable.attrs[0]?.value;\n            valueChange = staticControllable.attrs[1]?.value;\n          } else if (spreadExpression) {\n            const spreadIdentifier = tag.scope.generateUidIdentifier(\"textarea_input\");\n            tag.insertBefore(\n              import_compiler26.types.variableDeclaration(\"const\", [\n                import_compiler26.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            value = import_compiler26.types.memberExpression(spreadIdentifier, import_compiler26.types.identifier(\"value\"));\n            valueChange = import_compiler26.types.memberExpression(\n              spreadIdentifier,\n              import_compiler26.types.identifier(\"valueChange\")\n            );\n            spreadExpression = spreadIdentifier;\n          }\n          if (value || valueChange) {\n            writeAtStartOfBody = callRuntime(\n              \"controllable_textarea_value\",\n              getScopeIdIdentifier(getSection(tag)),\n              getScopeAccessorLiteral(nodeRef2),\n              value,\n              valueChange\n            );\n          }\n        }\n      }\n      for (const attr2 of staticAttrs) {\n        const { name: name3, value } = attr2;\n        const { confident, computed } = value.extra || {};\n        const valueReferences = value.extra?.referencedBindings;\n        if (isHTML && tagName === \"option\" && name3 === \"value\") {\n          write2`${callRuntime(\"optionValueAttr\", value)}`;\n          continue;\n        }\n        switch (name3) {\n          case \"class\":\n          case \"style\": {\n            const helper = `${name3}Attr`;\n            if (confident) {\n              write2`${getHTMLRuntime()[helper](computed)}`;\n            } else if (isHTML) {\n              write2`${callRuntime(helper, value)}`;\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler26.types.expressionStatement(\n                  callRuntime(\n                    helper,\n                    import_compiler26.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n          }\n          default:\n            if (confident) {\n              write2`${getHTMLRuntime().attr(name3, computed)}`;\n            } else if (isHTML) {\n              if (isEventHandler(name3)) {\n                addHTMLEffectCall(section, valueReferences);\n              } else {\n                write2`${callRuntime(\"attr\", import_compiler26.types.stringLiteral(name3), value)}`;\n              }\n            } else if (isEventHandler(name3)) {\n              addStatement(\n                \"effect\",\n                section,\n                valueReferences,\n                import_compiler26.types.expressionStatement(\n                  callRuntime(\n                    \"on\",\n                    import_compiler26.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler26.types.stringLiteral(getEventHandlerName(name3)),\n                    value\n                  )\n                )\n              );\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler26.types.expressionStatement(\n                  callRuntime(\n                    \"attr\",\n                    import_compiler26.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler26.types.stringLiteral(name3),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n        }\n      }\n      if (spreadExpression) {\n        if (isHTML) {\n          addHTMLEffectCall(section, extra.referencedBindings);\n          if (skipExpression) {\n            write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(section), name2.node)}`;\n          } else {\n            write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(section), name2.node)}`;\n          }\n        } else {\n          if (skipExpression) {\n            addStatement(\n              \"render\",\n              section,\n              extra.referencedBindings,\n              import_compiler26.types.expressionStatement(\n                callRuntime(\n                  \"partialAttrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression,\n                  skipExpression\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              extra.referencedBindings,\n              import_compiler26.types.expressionStatement(\n                callRuntime(\n                  \"attrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression\n                )\n              )\n            );\n          }\n          addStatement(\n            \"effect\",\n            section,\n            extra.referencedBindings,\n            import_compiler26.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            false\n          );\n        }\n      }\n      if (tagDef && tagDef.parseOptions?.openTagOnly) {\n        switch (tagDef.htmlType) {\n          case \"svg\":\n          case \"math\":\n            write2`/>`;\n            break;\n          default:\n            write2`>`;\n            break;\n        }\n      } else {\n        write2`>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(import_compiler26.types.ifStatement(name2.node, consumeHTML(tag)))[0].skip();\n      }\n      if (writeAtStartOfBody) {\n        write2`${writeAtStartOfBody}`;\n      }\n      enter2(tag);\n    },\n    exit(tag) {\n      const extra = tag.node.extra;\n      const nodeRef2 = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const openTagOnly = (0, import_babel_utils14.getTagDef)(tag)?.parseOptions?.openTagOnly;\n      const selectArgs = isHTML && htmlSelectArgs.get(tag.node);\n      const tagName = getTagName(tag);\n      if (isHTML && extra.tagNameNullable) {\n        flushInto(tag);\n      }\n      if (selectArgs) {\n        writeTo(tag)`</${tag.node.name}>`;\n        flushInto(tag);\n        tag.insertBefore(\n          import_compiler26.types.expressionStatement(\n            callRuntime(\n              \"controllable_select_value\",\n              getScopeIdIdentifier(getSection(tag)),\n              getScopeAccessorLiteral(nodeRef2),\n              selectArgs.value,\n              selectArgs.valueChange,\n              import_compiler26.types.arrowFunctionExpression(\n                [],\n                import_compiler26.types.blockStatement(tag.node.body.body)\n              )\n            )\n          )\n        );\n      } else {\n        tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n      }\n      if (!openTagOnly && !selectArgs) {\n        writeTo(\n          tag,\n          isHTML && (tagName === \"html\" || tagName === \"body\")\n        )`</${tag.node.name}>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(\n          import_compiler26.types.ifStatement(tag.node.name, consumeHTML(tag))\n        )[0].skip();\n      }\n      if (nodeRef2 && (extra[kSerializeMarker] || isStatefulReferences(extra.referencedBindings) || tag.node.attributes.some(\n        (attr2) => isStatefulReferences(attr2.value.extra?.referencedBindings)\n      ))) {\n        markNode(tag, nodeRef2);\n      }\n      exit2(tag);\n      tag.remove();\n    }\n  }\n};\nfunction getUsedAttrs(tagName, tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  let staticControllable;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler26.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n        staticControllable = getRelatedControllable(tagName, seen);\n        if (staticControllable && !staticControllable.attrs.every(Boolean)) {\n          for (const attr3 of staticControllable.attrs) {\n            if (attr3) {\n              spreadProps.push(toObjectProperty(attr3.name, attr3.value));\n              maybeStaticAttrs.delete(attr3);\n            }\n          }\n          staticControllable = void 0;\n        }\n      }\n      spreadProps.push(import_compiler26.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  if (!spreadProps) {\n    staticControllable = getRelatedControllable(tagName, seen);\n    if (staticControllable?.special === false && !staticControllable.attrs[1]) {\n      staticControllable = void 0;\n    }\n  }\n  if (staticControllable) {\n    for (const attr2 of staticControllable.attrs) {\n      if (attr2) {\n        maybeStaticAttrs.delete(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    if (staticControllable) {\n      for (const attr2 of staticControllable.attrs) {\n        if (attr2) {\n          (skipProps ||= []).push(\n            toObjectProperty(attr2.name, import_compiler26.types.numericLiteral(1))\n          );\n        }\n      }\n    }\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler26.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler26.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    staticControllable,\n    spreadExpression,\n    skipExpression\n  };\n}\nfunction isChangeHandler(propName) {\n  return /^(?:value|checked(?:Value)?|open)Change/.test(propName);\n}\nfunction buildUndefined() {\n  return import_compiler26.types.unaryExpression(\"void\", import_compiler26.types.numericLiteral(0));\n}\n\n// src/translator/core/for.ts\nvar kForMarkerBinding = Symbol(\"for marker binding\");\nvar kForScopeStartIndex = Symbol(\"for scope start index\");\nvar kOnlyChildInParent = Symbol(\"only child in parent\");\nvar for_default = {\n  analyze(tag) {\n    const tagExtra = tag.node.extra ??= {};\n    const isAttrTag = tag.node.body.attributeTags;\n    let allowAttrs;\n    (0, import_babel_utils15.assertNoVar)(tag);\n    (0, import_babel_utils15.assertNoArgs)(tag);\n    assertNoSpreadAttrs(tag);\n    switch (getForType(tag.node)) {\n      case \"of\":\n        allowAttrs = [\"of\"];\n        break;\n      case \"in\":\n        allowAttrs = [\"in\"];\n        break;\n      case \"to\":\n        allowAttrs = [\"to\", \"from\", \"step\"];\n        break;\n      default:\n        throw tag.buildCodeFrameError(\n          \"Invalid `for` tag, missing an `of=`, `in=`, `to=` attribute.\"\n        );\n    }\n    if (!isAttrTag) {\n      allowAttrs.push(\"by\");\n    }\n    (0, import_babel_utils15.assertAllowedAttributes)(tag, allowAttrs);\n    if (isAttrTag) return;\n    const tagBody = tag.get(\"body\");\n    const bodySection = startSection(tagBody);\n    if (!bodySection) {\n      dropReferences(getAllTagReferenceNodes(tag.node));\n      return;\n    }\n    const section = getOrCreateSection(tag);\n    if (isOnlyChildInParent(tag)) {\n      const parentTag = getParentTag(tag).node;\n      const parentTagName = parentTag.name?.value;\n      (parentTag.extra ??= {})[kNativeTagBinding] ??= createBinding(\n        \"#\" + parentTagName,\n        0 /* dom */,\n        section\n      );\n    } else {\n      tagExtra[kForMarkerBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section\n      );\n    }\n    trackParamsReferences(tagBody, 3 /* param */, void 0, tagExtra);\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n    bodySection.upstreamExpression = tagExtra;\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        const tagExtra = tag.node.extra;\n        const isStateful = isStatefulReferences(tagExtra.referencedBindings);\n        setSectionParentIsOwner(bodySection, true);\n        if (!isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n        flushBefore(tag);\n        if (isStateful && !bodySection.content?.singleChild) {\n          tagExtra[kForScopeStartIndex] = tag.scope.generateUidIdentifier(\"k\");\n          writeTo(tagBody)`${callRuntime(\n            \"markResumeScopeStart\",\n            getScopeIdIdentifier(bodySection),\n            import_compiler27.types.updateExpression(\"++\", tagExtra[kForScopeStartIndex])\n          )}`;\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const isStateful = isStatefulReferences(tagExtra.referencedBindings);\n        const parentTag = getParentTag(tag);\n        const nodeRef2 = isOnlyChildInParent(tag) ? parentTag.node.extra[kNativeTagBinding] : tag.node.extra[kForMarkerBinding];\n        const forAttrs = getKnownAttrValues(node);\n        const forType = getForType(node);\n        const params = node.body.params;\n        const statements = [];\n        const bodyStatements = node.body.body;\n        const hasStatefulClosures = checkStatefulClosures(bodySection, true);\n        let keyExpression;\n        if (isStateful && isOnlyChildInParent(tag)) {\n          parentTag.node.extra[kSerializeMarker] = true;\n        }\n        if (tagExtra[kForScopeStartIndex]) {\n          statements.push(\n            import_compiler27.types.variableDeclaration(\"let\", [\n              import_compiler27.types.variableDeclarator(\n                tagExtra[kForScopeStartIndex],\n                import_compiler27.types.numericLiteral(0)\n              )\n            ])\n          );\n        }\n        if (isStateful || hasStatefulClosures) {\n          const singleNodeOptimization = bodySection.content === null || bodySection.content.singleChild;\n          const defaultParamNames = {\n            of: [\"list\", \"index\"],\n            in: [\"key\", \"value\"],\n            to: [\"value\"]\n          }[forType];\n          const defaultByParamIndex = forType === \"of\" ? 1 : 0;\n          const requiredParamsIndex = forAttrs.by ? defaultParamNames.length - 1 : defaultByParamIndex;\n          setForceResumeScope(bodySection);\n          for (let i = 0; i <= requiredParamsIndex; i++) {\n            const existingParam = params[i];\n            if (!existingParam || !import_compiler27.types.isIdentifier(existingParam)) {\n              const id = params[i] = currentProgramPath.scope.generateUidIdentifier(\n                defaultParamNames[i]\n              );\n              if (existingParam) {\n                bodyStatements.unshift(\n                  import_compiler27.types.variableDeclaration(\"let\", [\n                    import_compiler27.types.variableDeclarator(existingParam, id)\n                  ])\n                );\n              }\n            }\n          }\n          if (forAttrs.by) {\n            if (import_compiler27.types.isStringLiteral(forAttrs.by)) {\n              keyExpression = toMemberExpression(\n                params[0],\n                forAttrs.by.value\n              );\n            } else if (import_compiler27.types.isFunction(forAttrs.by)) {\n              const byIdentifier = currentProgramPath.scope.generateUidIdentifier(\"by\");\n              statements.push(\n                import_compiler27.types.variableDeclaration(\"const\", [\n                  import_compiler27.types.variableDeclarator(byIdentifier, forAttrs.by)\n                ])\n              );\n              keyExpression = import_compiler27.types.callExpression(\n                byIdentifier,\n                params\n              );\n            } else {\n              keyExpression = callRuntime(\n                forTypeToHTMLByRuntime(forType),\n                forAttrs.by,\n                ...params\n              );\n            }\n          } else {\n            keyExpression = params[defaultByParamIndex];\n          }\n          const write2 = writeTo(tag);\n          const forScopeIdsIdentifier = tag.scope.generateUidIdentifier(\"forScopeIds\");\n          const forScopesIdentifier = getScopeIdentifier(bodySection);\n          statements.push(\n            import_compiler27.types.variableDeclaration(\n              \"const\",\n              [\n                isStateful && singleNodeOptimization && import_compiler27.types.variableDeclarator(\n                  forScopeIdsIdentifier,\n                  import_compiler27.types.arrayExpression([])\n                ),\n                import_compiler27.types.variableDeclarator(\n                  forScopesIdentifier,\n                  import_compiler27.types.newExpression(import_compiler27.types.identifier(\"Map\"), [])\n                )\n              ].filter(Boolean)\n            )\n          );\n          if (isStateful) {\n            if (singleNodeOptimization) {\n              bodyStatements.push(\n                import_compiler27.types.expressionStatement(\n                  import_compiler27.types.callExpression(\n                    import_compiler27.types.memberExpression(\n                      forScopeIdsIdentifier,\n                      import_compiler27.types.identifier(\"push\")\n                    ),\n                    [getScopeIdIdentifier(bodySection)]\n                  )\n                )\n              );\n              write2`${callRuntime(\n                \"markResumeControlSingleNodeEnd\",\n                getScopeIdIdentifier(tagSection),\n                getScopeAccessorLiteral(nodeRef2),\n                forScopeIdsIdentifier\n              )}`;\n            } else {\n              write2`${callRuntime(\n                \"markResumeControlEnd\",\n                getScopeIdIdentifier(tagSection),\n                getScopeAccessorLiteral(nodeRef2)\n              )}`;\n            }\n          }\n          getSerializedScopeProperties(tagSection).set(\n            import_compiler27.types.stringLiteral(\n              getScopeAccessorLiteral(nodeRef2).value + \"(\" /* LoopScopeMap */\n            ),\n            import_compiler27.types.conditionalExpression(\n              import_compiler27.types.memberExpression(forScopesIdentifier, import_compiler27.types.identifier(\"size\")),\n              forScopesIdentifier,\n              import_compiler27.types.identifier(\"undefined\")\n            )\n          );\n        }\n        flushInto(tag);\n        setSubscriberBuilder(tag, () => {\n        });\n        writeHTMLResumeStatements(tagBody);\n        if (keyExpression && (isStateful || hasStatefulClosures)) {\n          bodyStatements.push(\n            import_compiler27.types.expressionStatement(\n              import_compiler27.types.callExpression(\n                import_compiler27.types.memberExpression(\n                  getScopeIdentifier(bodySection),\n                  import_compiler27.types.identifier(\"set\")\n                ),\n                [\n                  keyExpression,\n                  callRuntime(\n                    \"getScopeById\",\n                    getScopeIdIdentifier(bodySection)\n                  )\n                ]\n              )\n            )\n          );\n        }\n        statements.push(\n          buildForRuntimeCall(forType, forAttrs, params, bodyStatements)\n        );\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        if (!isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const { referencedBindings } = tagExtra;\n        const nodeRef2 = isOnlyChildInParent(tag) ? getParentTag(tag).node.extra[kNativeTagBinding] : tag.node.extra[kForMarkerBinding];\n        setSubscriberBuilder(tag, (signal2) => {\n          return callRuntime(\n            \"inLoopScope\",\n            signal2,\n            getScopeAccessorLiteral(nodeRef2)\n          );\n        });\n        const forType = getForType(node);\n        const signal = getSignal(tagSection, nodeRef2, \"for\");\n        signal.build = () => {\n          return callRuntime(\n            forTypeToDOMRuntime(forType),\n            getScopeAccessorLiteral(nodeRef2),\n            import_compiler27.types.identifier(bodySection.name)\n          );\n        };\n        const params = node.body.params;\n        signal.hasDownstreamIntersections = () => {\n          if (bodySection.closures) {\n            return true;\n          }\n          for (const param of params) {\n            const binding = param.extra?.binding;\n            if (binding) {\n              for (const {\n                referencedBindings: referencedBindings2\n              } of binding.downstreamExpressions) {\n                if (getSignal(\n                  bodySection,\n                  referencedBindings2\n                ).hasDownstreamIntersections()) {\n                  return true;\n                }\n              }\n            }\n          }\n          return false;\n        };\n        const forAttrs = getKnownAttrValues(node);\n        const loopArgs = getBaseArgsInForTag(forType, forAttrs);\n        if (forAttrs.by) {\n          loopArgs.push(forAttrs.by);\n        }\n        addValue(\n          tagSection,\n          referencedBindings,\n          signal,\n          import_compiler27.types.arrayExpression(loopArgs)\n        );\n        tag.remove();\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  attributes: {\n    of: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over a list of items.\"\n        }\n      ]\n    },\n    in: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over the keys and values of an object.\"\n        }\n      ]\n    },\n    to: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates up to the provided number (inclusive)\"\n        }\n      ]\n    },\n    from: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates starting from the provided number (inclusive)\"\n        }\n      ]\n    },\n    step: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"The amount to increment during each interation (with from/to)\"\n        }\n      ]\n    }\n  },\n  autocomplete: [\n    {\n      snippet: \"for|${1:value, index}| of=${3:array}\",\n      description: \"Use to iterate over lists, object properties, or between ranges.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-a-list\"\n    },\n    {\n      snippet: \"for|${1:name, value}| in=${3:object}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties\"\n    },\n    {\n      snippet: \"for|${1:index}| to=${2:number}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers\"\n    }\n  ]\n};\nfunction buildForRuntimeCall(type, attrs2, params, statements) {\n  return import_compiler27.types.expressionStatement(\n    callRuntime(\n      forTypeToRuntime(type),\n      ...getBaseArgsInForTag(type, attrs2),\n      import_compiler27.types.arrowFunctionExpression(params, import_compiler27.types.blockStatement(statements))\n    )\n  );\n}\nfunction getForType(tag) {\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      switch (attr2.name) {\n        case \"of\":\n        case \"in\":\n        case \"to\":\n          return attr2.name;\n      }\n    }\n  }\n}\nfunction forTypeToRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"forOf\";\n    case \"in\":\n      return \"forIn\";\n    case \"to\":\n      return \"forTo\";\n  }\n}\nfunction forTypeToDOMRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"loopOf\";\n    case \"in\":\n      return \"loopIn\";\n    case \"to\":\n      return \"loopTo\";\n  }\n}\nfunction forTypeToHTMLByRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"forOfBy\";\n    case \"in\":\n      return \"forInBy\";\n    case \"to\":\n      return \"forToBy\";\n  }\n}\nfunction getBaseArgsInForTag(type, attrs2) {\n  switch (type) {\n    case \"in\":\n      return [attrs2.in];\n    case \"of\":\n      return [attrs2.of];\n    case \"to\":\n      return [\n        attrs2.to,\n        attrs2.from || import_compiler27.types.numericLiteral(0),\n        attrs2.step || import_compiler27.types.numericLiteral(1)\n      ];\n  }\n}\nfunction isOnlyChildInParent(tag) {\n  const extra = tag.node.extra;\n  if (extra[kOnlyChildInParent] !== void 0) {\n    return extra[kOnlyChildInParent];\n  }\n  const parentTag = getParentTag(tag);\n  if (parentTag && (0, import_babel_utils15.getTagDef)(parentTag)?.html) {\n    return extra[kOnlyChildInParent] = tag.parent.body.length === 1;\n  }\n  return extra[kOnlyChildInParent] = false;\n}\n\n// src/translator/util/nested-attribute-tags.ts\nvar import_compiler28 = require(\"@marko/compiler\");\nvar import_babel_utils16 = require(\"@marko/compiler/babel-utils\");\nvar attrTagToIdentifierLookup = /* @__PURE__ */ new WeakMap();\nfunction getAttrTagIdentifier(meta) {\n  let name2 = attrTagToIdentifierLookup.get(meta);\n  if (!name2) {\n    name2 = currentProgramPath.scope.generateUid(meta.name);\n    attrTagToIdentifierLookup.set(meta, name2);\n  }\n  return import_compiler28.types.identifier(name2);\n}\nfunction analyzeAttributeTags(tag) {\n  if (tag.node.extra?.attributeTags) return tag.node.extra.attributeTags;\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  if (!attrTags2.length) return;\n  const tagExtra = tag.node.extra ??= {};\n  const lookup = tagExtra.attributeTags = {};\n  const attrTagNodesByName = {};\n  const sampleAttrTagsForControlFlow = /* @__PURE__ */ new Map();\n  for (const child of attrTags2) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils16.isAttributeTag)(child)) {\n        const name2 = getTagName(child);\n        lookup[name2] ||= createAttrTagMeta(name2, [name2]);\n        analyzeAttributeTags(child);\n      } else {\n        const isRepeated = (0, import_babel_utils16.isLoopTag)(child);\n        let curGroup;\n        for (const name2 of crawlAttrTags(child, attrTagNodesByName)) {\n          const oldMeta = lookup[name2];\n          if (oldMeta) {\n            if (!curGroup) {\n              curGroup = oldMeta.group;\n            } else if (curGroup !== oldMeta.group) {\n              for (const name3 of oldMeta.group) {\n                lookup[name3].group = curGroup;\n                curGroup.push(name3);\n              }\n            }\n          }\n          let attrTagMeta = lookup[name2];\n          if (!attrTagMeta) {\n            attrTagMeta = lookup[name2] = createAttrTagMeta(name2, []);\n            curGroup = attrTagMeta.group;\n            curGroup.push(name2);\n          }\n          attrTagMeta.dynamic = true;\n          if (isRepeated) {\n            attrTagMeta.repeated = true;\n          }\n          sampleAttrTagsForControlFlow.set(child, name2);\n        }\n      }\n    }\n  }\n  for (const [controlFlowTag, sampleAttrName] of sampleAttrTagsForControlFlow) {\n    (controlFlowTag.node.extra ??= {}).attributeTagGroup = lookup[sampleAttrName].group;\n  }\n  for (const name2 in attrTagNodesByName) {\n    const attrTagMeta = lookup[name2];\n    if (!attrTagMeta.repeated) {\n      const attrTagNodes = attrTagNodesByName[name2];\n      if (attrTagNodes.length > 1) {\n        attrTagMeta.repeated = !attrTagMeta.dynamic || hasRepeatedDynamicAttrTags(attrTagNodes);\n      }\n    }\n  }\n  return lookup;\n}\nfunction createAttrTagMeta(name2, group) {\n  return {\n    name: name2.slice(1),\n    dynamic: false,\n    repeated: false,\n    group\n  };\n}\nfunction crawlAttrTags(tag, attrTagNodesByName, attrTagNames = /* @__PURE__ */ new Set()) {\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  for (const child of attrTags2) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils16.isAttributeTag)(child)) {\n        const tagName = getTagName(child);\n        attrTagNames.add(tagName);\n        (attrTagNodesByName[tagName] ||= []).push(child);\n        analyzeAttributeTags(child);\n      } else {\n        crawlAttrTags(child, attrTagNodesByName, attrTagNames);\n      }\n    }\n  }\n  return attrTagNames;\n}\nfunction hasRepeatedDynamicAttrTags(attrTags2) {\n  let conditionRoot;\n  const seenBranches = /* @__PURE__ */ new Set();\n  for (const attrTag2 of attrTags2) {\n    const parentTag = getParentTag(attrTag2);\n    if (seenBranches.has(parentTag) || !isConditionTag(parentTag)) {\n      return true;\n    }\n    const curConditionRoot = getConditionRoot(parentTag);\n    if (curConditionRoot && curConditionRoot !== (conditionRoot ||= curConditionRoot)) {\n      return true;\n    }\n    seenBranches.add(parentTag);\n  }\n  return false;\n}\nfunction getConditionRoot(tag) {\n  if (getTagName(tag) === \"if\") return tag;\n  let prev = tag.getPrevSibling();\n  while (prev.node) {\n    if (prev.isMarkoTag() && getTagName(prev) === \"if\") {\n      return prev;\n    }\n    prev = prev.getPrevSibling();\n  }\n}\n\n// src/translator/util/translate-attrs.ts\nvar contentProps = /* @__PURE__ */ new WeakSet();\nfunction translateAttrs(tag, templateExports, statements = [], contentKey = \"content\") {\n  const seen = /* @__PURE__ */ new Set();\n  const properties = [];\n  const attrTagLookup = tag.node.extra?.attributeTags;\n  if (attrTagLookup) {\n    for (const name2 in attrTagLookup) {\n      const attrTagMeta = attrTagLookup[name2];\n      if (usesExport(templateExports, attrTagMeta.name)) {\n        seen.add(attrTagMeta.name);\n        if (attrTagMeta.dynamic) {\n          statements.push(\n            import_compiler29.types.variableDeclaration(\"let\", [\n              import_compiler29.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta))\n            ])\n          );\n          properties.push(\n            toObjectProperty(\n              attrTagMeta.name,\n              getAttrTagIdentifier(attrTagMeta)\n            )\n          );\n        }\n      }\n    }\n    const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils17.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          if (attrTagMeta.dynamic) {\n            i = addDynamicAttrTagStatements(\n              attrTags2,\n              i,\n              attrTagLookup,\n              statements,\n              templateExports,\n              contentKey\n            );\n          } else {\n            const translatedAttrTag = translateAttrs(\n              child,\n              templateExports?.[attrTagMeta.name]?.props,\n              statements,\n              contentKey\n            );\n            if (attrTagMeta.repeated) {\n              const prevProp = findObjectProperty(attrTagMeta.name, properties);\n              if (prevProp) {\n                prevProp.value = callRuntime(\n                  \"attrTags\",\n                  prevProp.value,\n                  propsToExpression(translatedAttrTag.properties)\n                );\n              } else {\n                properties.push(\n                  toObjectProperty(\n                    attrTagMeta.name,\n                    callRuntime(\n                      \"attrTag\",\n                      propsToExpression(translatedAttrTag.properties)\n                    )\n                  )\n                );\n              }\n            } else {\n              properties.push(\n                toObjectProperty(\n                  attrTagMeta.name,\n                  callRuntime(\n                    \"attrTag\",\n                    propsToExpression(translatedAttrTag.properties)\n                  )\n                )\n              );\n            }\n          }\n        } else {\n          i = addDynamicAttrTagStatements(\n            attrTags2,\n            i,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        }\n      }\n    }\n  }\n  if (!seen.has(contentKey) && usesExport(templateExports, contentKey)) {\n    seen.add(contentKey);\n    const contentExpression = buildContent(tag.get(\"body\"));\n    if (contentExpression) {\n      const contentProp = import_compiler29.types.objectProperty(\n        import_compiler29.types.identifier(contentKey),\n        contentExpression\n      );\n      contentProps.add(contentProp);\n      properties.push(contentProp);\n    }\n  }\n  const { attributes } = tag.node;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler29.types.isMarkoSpreadAttribute(attr2)) {\n      properties.push(import_compiler29.types.spreadElement(value));\n    } else if (!seen.has(attr2.name) && usesExport(templateExports, attr2.name)) {\n      seen.add(attr2.name);\n      properties.push(toObjectProperty(attr2.name, value));\n    }\n  }\n  properties.reverse();\n  return { properties, statements };\n}\nfunction getTranslatedBodyContentProperty(props) {\n  for (const prop of props) {\n    if (contentProps.has(prop)) {\n      return prop;\n    }\n  }\n}\nfunction addDynamicAttrTagStatements(attrTags2, index, attrTagLookup, statements, templateExports, contentKey = \"content\") {\n  const tag = attrTags2[index];\n  if (tag.isMarkoTag()) {\n    if ((0, import_babel_utils17.isAttributeTag)(tag)) {\n      const attrTagMeta = attrTagLookup[getTagName(tag)];\n      if (usesExport(templateExports, attrTagMeta.name) && attrTagMeta.dynamic) {\n        const translatedAttrTag = translateAttrs(\n          tag,\n          templateExports?.[attrTagMeta.name]?.props,\n          statements,\n          contentKey\n        );\n        if (attrTagMeta.repeated) {\n          statements.push(\n            import_compiler29.types.expressionStatement(\n              import_compiler29.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTags\",\n                  getAttrTagIdentifier(attrTagMeta),\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        } else {\n          statements.push(\n            import_compiler29.types.expressionStatement(\n              import_compiler29.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTag\",\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        }\n      }\n    } else {\n      switch (getTagName(tag)) {\n        case \"if\":\n          return translateIfAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        case \"for\": {\n          return translateForAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        }\n      }\n    }\n  }\n  return index;\n}\nfunction propsToExpression(props) {\n  return props.length === 1 && import_compiler29.types.isSpreadElement(props[0]) ? props[0].argument : import_compiler29.types.objectExpression(props);\n}\nfunction translateForAttrTag(attrTags2, index, attrTagLookup, statements, templateExports, contentKey) {\n  const forTag = attrTags2[index];\n  const bodyStatements = [];\n  addAllAttrTagsAsDynamic(\n    forTag,\n    attrTagLookup,\n    bodyStatements,\n    templateExports,\n    contentKey\n  );\n  statements.push(\n    buildForRuntimeCall(\n      getForType(forTag.node),\n      getKnownAttrValues(forTag.node),\n      forTag.node.body.params,\n      bodyStatements\n    )\n  );\n  return index;\n}\nfunction translateIfAttrTag(attrTags2, index, attrTagLookup, statements, templateExports, contentKey) {\n  const ifTag = attrTags2[index];\n  const consequentStatements = [];\n  let ifStatement = import_compiler29.types.ifStatement(\n    getConditionTestValue(ifTag),\n    import_compiler29.types.blockStatement(consequentStatements)\n  );\n  statements.push(ifStatement);\n  addAllAttrTagsAsDynamic(\n    ifTag,\n    attrTagLookup,\n    consequentStatements,\n    templateExports,\n    contentKey\n  );\n  let nextIndex = index + 1;\n  while (nextIndex < attrTags2.length) {\n    const nextTag = attrTags2[nextIndex];\n    if (nextTag.isMarkoTag()) {\n      switch (getTagName(nextTag)) {\n        case \"else-if\":\n        case \"else\": {\n          const testValue = getConditionTestValue(nextTag);\n          const alternateStatements = [];\n          addAllAttrTagsAsDynamic(\n            nextTag,\n            attrTagLookup,\n            alternateStatements,\n            templateExports,\n            contentKey\n          );\n          if (testValue) {\n            ifStatement.alternate = ifStatement = import_compiler29.types.ifStatement(\n              testValue,\n              import_compiler29.types.blockStatement(alternateStatements)\n            );\n            nextIndex++;\n            continue;\n          } else {\n            ifStatement.alternate = import_compiler29.types.blockStatement(alternateStatements);\n            break;\n          }\n        }\n      }\n    }\n    break;\n  }\n  return nextIndex - 1;\n}\nfunction addAllAttrTagsAsDynamic(tag, attrTagLookup, statements, templateExports, contentKey) {\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  for (let i = 0; i < attrTags2.length; i++) {\n    i = addDynamicAttrTagStatements(\n      attrTags2,\n      i,\n      attrTagLookup,\n      statements,\n      templateExports,\n      contentKey\n    );\n  }\n}\nfunction usesExport(templateExports, name2) {\n  return !templateExports || !!templateExports[name2];\n}\nfunction findObjectProperty(name2, props) {\n  for (const prop of props) {\n    if (prop.type === \"ObjectProperty\") {\n      switch (prop.key.type) {\n        case \"StringLiteral\":\n          if (prop.key.value === name2) {\n            return prop;\n          }\n          break;\n        case \"Identifier\":\n          if (prop.key.name === name2) {\n            return prop;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\nfunction getConditionTestValue({\n  node: { attributes }\n}) {\n  return attributes.length === 1 ? attributes[0].value : void 0;\n}\nfunction buildContent(body) {\n  const bodySection = body.node.extra?.section;\n  if (bodySection) {\n    if (isOutputHTML()) {\n      return callRuntime(\n        \"register\",\n        callRuntime(\n          \"createRenderer\",\n          import_compiler29.types.arrowFunctionExpression(\n            body.node.params,\n            import_compiler29.types.blockStatement(body.node.body)\n          )\n        ),\n        import_compiler29.types.stringLiteral(getResumeRegisterId(bodySection, \"renderer\")),\n        getScopeIdIdentifier(\n          getSection(\n            getNonAttributeTagParent(body.parentPath)\n          )\n        )\n      );\n    } else {\n      return import_compiler29.types.callExpression(import_compiler29.types.identifier(bodySection.name), [\n        scopeIdentifier\n      ]);\n    }\n  }\n}\nfunction getNonAttributeTagParent(tag) {\n  let cur = tag;\n  while ((0, import_babel_utils17.isAttributeTag)(cur) || (0, import_babel_utils17.isTransparentTag)(cur)) {\n    cur = getParentTag(cur);\n  }\n  return cur;\n}\n\n// src/translator/core/define.ts\nvar define_default = {\n  analyze(tag) {\n    (0, import_babel_utils18.assertNoArgs)(tag);\n    if (!tag.node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `define` tag requires a tag variable.\");\n    }\n    const tagBody = tag.get(\"body\");\n    startSection(tagBody);\n    trackVarReferences(tag, 4 /* derived */);\n    trackParamsReferences(tagBody, 3 /* param */);\n    mergeReferences(\n      getOrCreateSection(tag),\n      tag.node,\n      getAllTagReferenceNodes(tag.node)\n    );\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const translatedAttrs = translateAttrs(tag);\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        tag.insertBefore(translatedAttrs.statements);\n        translateVar(tag, propsToExpression(translatedAttrs.properties));\n      } else {\n        const section = getSection(tag);\n        const referencedBindings = node.extra?.referencedBindings;\n        const derivation = initValue(tag.get(\"var\").node.extra.binding);\n        if (translatedAttrs.statements.length) {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            translatedAttrs.statements\n          );\n        }\n        addValue(\n          section,\n          referencedBindings,\n          derivation,\n          propsToExpression(translatedAttrs.properties)\n        );\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a constant object binding that can be rendered.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#define\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/define.d.marko\"\n};\n\n// src/translator/core/effect.ts\nvar import_compiler31 = require(\"@marko/compiler\");\nvar import_babel_utils19 = require(\"@marko/compiler/babel-utils\");\nvar effect_default = {\n  migrate: [\n    (tag) => {\n      (0, import_babel_utils19.assertNoArgs)(tag);\n      (0, import_babel_utils19.assertNoParams)(tag);\n      assertNoBodyContent(tag);\n      (0, import_babel_utils19.assertNoAttributeTags)(tag);\n      assertNoSpreadAttrs(tag);\n      (0, import_babel_utils19.assertAllowedAttributes)(tag, [\"value\"]);\n      (0, import_babel_utils19.diagnosticDeprecate)(tag, {\n        label: \"The 'effect' tag has been replaced by the 'script' tag.\",\n        fix() {\n          const { node } = tag;\n          tag.replaceWith(\n            import_compiler31.types.markoTag(\n              withPreviousLocation(import_compiler31.types.stringLiteral(\"script\"), node.name),\n              node.attributes,\n              node.body,\n              node.arguments,\n              node.var,\n              node.attributeTags\n            )\n          );\n        }\n      });\n    }\n  ],\n  attributes: {},\n  types: runtime_info_default.name + \"/tag-types/effect.d.marko\"\n};\n\n// src/translator/core/export.ts\nvar import_babel_utils20 = require(\"@marko/compiler/babel-utils\");\nvar export_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils20.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"export <value>\"\n    }\n  ]\n};\n\n// src/translator/core/html-comment.ts\nvar import_compiler32 = require(\"@marko/compiler\");\nvar import_babel_utils21 = require(\"@marko/compiler/babel-utils\");\nvar kCommentTagBinding = Symbol(\"comment tag binding\");\nvar kGetterId2 = Symbol(\"node getter id\");\nvar html_comment_default = {\n  analyze(tag) {\n    (0, import_babel_utils21.assertNoArgs)(tag);\n    (0, import_babel_utils21.assertNoParams)(tag);\n    (0, import_babel_utils21.assertNoAttributes)(tag);\n    const tagVar = tag.node.var;\n    let needsBinding = false;\n    let needsGetter = false;\n    if (tagVar) {\n      if (!import_compiler32.types.isIdentifier(tagVar)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"The `html-comment` tag variable cannot be destructured.\"\n        );\n      }\n      needsBinding = true;\n      for (const ref of tag.scope.getBinding(tagVar.name).referencePaths) {\n        if (!ref.parentPath?.isCallExpression()) {\n          needsGetter = true;\n          break;\n        }\n      }\n    }\n    const referenceNodes = [];\n    for (const child of tag.get(\"body\").get(\"body\")) {\n      if (child.isMarkoPlaceholder()) {\n        referenceNodes.push(child.node.value);\n        needsBinding = true;\n      } else if (!child.isMarkoText()) {\n        throw child.buildCodeFrameError(\n          \"Invalid child. Only text is allowed inside an html comment.\"\n        );\n      }\n    }\n    if (needsBinding) {\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      if (needsGetter) {\n        tagExtra[kGetterId2] = getRegisterUID(section, \"comment\");\n      }\n      tagExtra[kCommentTagBinding] = createBinding(\n        \"#comment\",\n        0 /* dom */,\n        section\n      );\n      mergeReferences(section, tag.node, referenceNodes);\n    }\n    tag.skip();\n  },\n  translate(tag) {\n    const tagExtra = tag.node.extra;\n    const commentBinding = tagExtra[kCommentTagBinding];\n    const hasVar = !!tag.node.var;\n    if (hasVar) {\n      const getterId = tagExtra[kGetterId2];\n      if (isOutputHTML()) {\n        translateVar(\n          tag,\n          callRuntime(\n            \"nodeRef\",\n            getterId && getScopeIdIdentifier(getSection(tag)),\n            getterId && import_compiler32.types.stringLiteral(getterId)\n          )\n        );\n      } else {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        let getterFnIdentifier;\n        if (getterId) {\n          getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n            `get_${varName}`\n          );\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler32.types.variableDeclaration(\"const\", [\n              import_compiler32.types.variableDeclarator(\n                getterFnIdentifier,\n                callRuntime(\n                  \"nodeRef\",\n                  import_compiler32.types.stringLiteral(getterId),\n                  getScopeAccessorLiteral(commentBinding)\n                )\n              )\n            ])\n          );\n        }\n        for (const reference of references) {\n          const referenceSection = getSection(reference);\n          if (reference.parentPath?.isCallExpression()) {\n            reference.parentPath.replaceWith(\n              import_compiler32.types.expressionStatement(\n                createScopeReadExpression(referenceSection, commentBinding)\n              )\n            );\n          } else if (getterFnIdentifier) {\n            reference.replaceWith(\n              import_compiler32.types.callExpression(getterFnIdentifier, [\n                getScopeExpression(referenceSection, getSection(tag))\n              ])\n            );\n          }\n        }\n      }\n    }\n    if (tagExtra[kCommentTagBinding]) {\n      visit(tag, 32 /* Get */);\n    }\n    const write2 = writeTo(tag);\n    enter2(tag);\n    write2`<!--`;\n    if (isOutputHTML()) {\n      for (const child of tag.node.body.body) {\n        if (import_compiler32.types.isMarkoText(child)) {\n          write2`${child.value}`;\n        } else if (import_compiler32.types.isMarkoPlaceholder(child)) {\n          write2`${callRuntime(\"escapeXML\", child.value)}`;\n        }\n      }\n    } else {\n      const templateQuasis = [];\n      const templateExpressions = [];\n      let currentQuasi = \"\";\n      for (const child of tag.node.body.body) {\n        if (import_compiler32.types.isMarkoText(child)) {\n          currentQuasi += child.value;\n        } else if (import_compiler32.types.isMarkoPlaceholder(child)) {\n          templateQuasis.push(import_compiler32.types.templateElement({ raw: currentQuasi }));\n          templateExpressions.push(child.value);\n          currentQuasi = \"\";\n        }\n      }\n      if (templateExpressions.length === 0) {\n        write2`${currentQuasi}`;\n      } else {\n        templateQuasis.push(import_compiler32.types.templateElement({ raw: currentQuasi }));\n        addStatement(\n          \"render\",\n          getSection(tag),\n          tagExtra.referencedBindings,\n          import_compiler32.types.expressionStatement(\n            callRuntime(\n              \"data\",\n              import_compiler32.types.memberExpression(\n                scopeIdentifier,\n                getScopeAccessorLiteral(commentBinding),\n                true\n              ),\n              import_compiler32.types.templateLiteral(templateQuasis, templateExpressions)\n            )\n          )\n        );\n      }\n    }\n    exit2(tag);\n    write2`-->`;\n    if (commentBinding) {\n      markNode(tag, commentBinding);\n    }\n    tag.remove();\n  },\n  parseOptions: {\n    text: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an html comment that is not stripped from the output.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#html-comment\"\n    }\n  ]\n};\n\n// src/translator/core/html-script.ts\nvar import_compiler33 = require(\"@marko/compiler\");\nvar import_babel_utils22 = require(\"@marko/compiler/babel-utils\");\nvar kGetterId3 = Symbol(\"node getter id\");\nvar html_script_default = {\n  analyze(tag) {\n    (0, import_babel_utils22.assertNoArgs)(tag);\n    (0, import_babel_utils22.assertNoParams)(tag);\n    const { node } = tag;\n    if (node.var && !import_compiler33.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\n        \"Tag variables on native elements cannot be destructured.\"\n      );\n    }\n    const section = getOrCreateSection(tag);\n    let hasEventHandlers = false;\n    let hasDynamicAttributes = false;\n    const seen = {};\n    const { attributes } = tag.node;\n    let spreadReferenceNodes;\n    for (let i = attributes.length; i--; ) {\n      const attr2 = attributes[i];\n      if (import_compiler33.types.isMarkoAttribute(attr2)) {\n        if (seen[attr2.name]) {\n          dropReferences(attr2.value);\n          continue;\n        }\n        seen[attr2.name] = attr2;\n        if (isEventHandler(attr2.name)) {\n          (attr2.value.extra ??= {}).isEffect = true;\n          hasEventHandlers = true;\n        } else if (!evaluate(attr2.value).confident) {\n          hasDynamicAttributes = true;\n        }\n      } else if (import_compiler33.types.isMarkoSpreadAttribute(attr2)) {\n        hasEventHandlers = true;\n        hasDynamicAttributes = true;\n        (attr2.value.extra ??= {}).isEffect = true;\n      }\n      if (spreadReferenceNodes) {\n        spreadReferenceNodes.push(attr2.value);\n      } else if (import_compiler33.types.isMarkoSpreadAttribute(attr2)) {\n        spreadReferenceNodes = [attr2.value];\n      }\n    }\n    if (spreadReferenceNodes) {\n      mergeReferences(section, tag.node, spreadReferenceNodes);\n    }\n    const bodyPlaceholderNodes = [];\n    let hasBodyPlaceholders = false;\n    for (const child of tag.node.body.body) {\n      if (import_compiler33.types.isMarkoPlaceholder(child)) {\n        bodyPlaceholderNodes.push(child.value);\n        hasBodyPlaceholders = true;\n      } else if (!import_compiler33.types.isMarkoText(child)) {\n        throw tag.hub.buildError(\n          child,\n          \"Invalid child. Only text is allowed inside an html-script.\"\n        );\n      }\n    }\n    if (bodyPlaceholderNodes.length > 1) {\n      mergeReferences(\n        section,\n        bodyPlaceholderNodes[0],\n        bodyPlaceholderNodes.slice(1)\n      );\n    }\n    if (node.var || hasEventHandlers || hasDynamicAttributes || hasBodyPlaceholders) {\n      currentProgramPath.node.extra.isInteractive ||= hasEventHandlers;\n      const tagExtra = node.extra ??= {};\n      const bindingName = \"#script\";\n      tagExtra[kSerializeMarker] = hasEventHandlers || !!node.var;\n      tagExtra[kNativeTagBinding] = createBinding(\n        bindingName,\n        0 /* dom */,\n        section\n      );\n      if (node.var) {\n        for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n          if (!ref.parentPath?.isCallExpression()) {\n            tagExtra[kGetterId3] = getRegisterUID(section, bindingName);\n            break;\n          }\n        }\n      }\n    }\n  },\n  translate(tag) {\n    const tagExtra = tag.node.extra;\n    const nodeRef2 = tagExtra[kNativeTagBinding];\n    const isHTML = isOutputHTML();\n    const write2 = writeTo(tag);\n    const section = getSection(tag);\n    const hasVar = !!tag.node.var;\n    if (hasVar) {\n      const getterId = tagExtra[kGetterId3];\n      if (isHTML) {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        for (const reference of references) {\n          let currentSection = getSection(reference);\n          while (currentSection !== section && currentSection.parent) {\n            getSerializedScopeProperties(currentSection).set(\n              import_compiler33.types.stringLiteral(\"_\"),\n              callRuntime(\n                \"ensureScopeWithId\",\n                getScopeIdIdentifier(currentSection = currentSection.parent)\n              )\n            );\n          }\n        }\n        translateVar(\n          tag,\n          callRuntime(\n            \"nodeRef\",\n            getterId && getScopeIdIdentifier(section),\n            getterId && import_compiler33.types.stringLiteral(getterId)\n          )\n        );\n      } else {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        let getterFnIdentifier;\n        if (getterId) {\n          getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n            `get_${varName}`\n          );\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler33.types.variableDeclaration(\"const\", [\n              import_compiler33.types.variableDeclarator(\n                getterFnIdentifier,\n                callRuntime(\n                  \"nodeRef\",\n                  import_compiler33.types.stringLiteral(getterId),\n                  getScopeAccessorLiteral(nodeRef2)\n                )\n              )\n            ])\n          );\n        }\n        for (const reference of references) {\n          const referenceSection = getSection(reference);\n          if (reference.parentPath?.isCallExpression()) {\n            reference.parentPath.replaceWith(\n              import_compiler33.types.expressionStatement(\n                createScopeReadExpression(referenceSection, nodeRef2)\n              )\n            );\n          } else if (getterFnIdentifier) {\n            reference.replaceWith(\n              import_compiler33.types.callExpression(getterFnIdentifier, [\n                getScopeExpression(referenceSection, getSection(tag))\n              ])\n            );\n          }\n        }\n      }\n    }\n    let visitAccessor;\n    if (nodeRef2) {\n      visitAccessor = getScopeAccessorLiteral(nodeRef2);\n      visit(tag, 32 /* Get */);\n    }\n    write2`<script`;\n    const usedAttrs = getUsedAttrs2(tag.node);\n    const { staticAttrs, skipExpression, spreadExpression } = usedAttrs;\n    for (const attr2 of staticAttrs) {\n      const { name: name2, value } = attr2;\n      const { confident, computed } = value.extra || {};\n      const valueReferences = value.extra?.referencedBindings;\n      switch (name2) {\n        case \"class\":\n        case \"style\": {\n          const helper = `${name2}Attr`;\n          if (confident) {\n            write2`${getHTMLRuntime()[helper](computed)}`;\n          } else if (isHTML) {\n            write2`${callRuntime(helper, value)}`;\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              valueReferences,\n              import_compiler33.types.expressionStatement(\n                callRuntime(\n                  helper,\n                  import_compiler33.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  value\n                )\n              )\n            );\n          }\n          break;\n        }\n        default:\n          if (confident) {\n            write2`${getHTMLRuntime().attr(name2, computed)}`;\n          } else if (isHTML) {\n            if (isEventHandler(name2)) {\n              addHTMLEffectCall(section, valueReferences);\n            } else {\n              write2`${callRuntime(\"attr\", import_compiler33.types.stringLiteral(name2), value)}`;\n            }\n          } else if (isEventHandler(name2)) {\n            addStatement(\n              \"effect\",\n              section,\n              valueReferences,\n              import_compiler33.types.expressionStatement(\n                callRuntime(\n                  \"on\",\n                  import_compiler33.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  import_compiler33.types.stringLiteral(getEventHandlerName(name2)),\n                  value\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              valueReferences,\n              import_compiler33.types.expressionStatement(\n                callRuntime(\n                  \"attr\",\n                  import_compiler33.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  import_compiler33.types.stringLiteral(name2),\n                  value\n                )\n              )\n            );\n          }\n          break;\n      }\n    }\n    if (spreadExpression) {\n      if (isHTML) {\n        addHTMLEffectCall(section, tagExtra.referencedBindings);\n        if (skipExpression) {\n          write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler33.types.stringLiteral(\"script\"))}`;\n        } else {\n          write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler33.types.stringLiteral(\"script\"))}`;\n        }\n      } else {\n        if (skipExpression) {\n          addStatement(\n            \"render\",\n            section,\n            tagExtra.referencedBindings,\n            import_compiler33.types.expressionStatement(\n              callRuntime(\n                \"partialAttrs\",\n                scopeIdentifier,\n                visitAccessor,\n                spreadExpression,\n                skipExpression\n              )\n            )\n          );\n        } else {\n          addStatement(\n            \"render\",\n            section,\n            tagExtra.referencedBindings,\n            import_compiler33.types.expressionStatement(\n              callRuntime(\n                \"attrs\",\n                scopeIdentifier,\n                visitAccessor,\n                spreadExpression\n              )\n            )\n          );\n        }\n        addStatement(\n          \"effect\",\n          section,\n          tagExtra.referencedBindings,\n          import_compiler33.types.expressionStatement(\n            callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n          ),\n          false\n        );\n      }\n    }\n    write2`>`;\n    enter2(tag);\n    if (isOutputHTML()) {\n      for (const child of tag.node.body.body) {\n        if (import_compiler33.types.isMarkoText(child)) {\n          write2`${child.value}`;\n        } else if (import_compiler33.types.isMarkoPlaceholder(child)) {\n          write2`${callRuntime(\"escapeScript\", child.value)}`;\n        }\n      }\n    } else {\n      const templateQuasis = [];\n      const templateExpressions = [];\n      let currentQuasi = \"\";\n      let referencePlaceholder;\n      for (const child of tag.node.body.body) {\n        if (import_compiler33.types.isMarkoText(child)) {\n          currentQuasi += child.value;\n        } else if (import_compiler33.types.isMarkoPlaceholder(child)) {\n          referencePlaceholder ||= child;\n          templateQuasis.push(import_compiler33.types.templateElement({ raw: currentQuasi }));\n          templateExpressions.push(child.value);\n          currentQuasi = \"\";\n        }\n      }\n      if (!referencePlaceholder) {\n        write2`${currentQuasi}`;\n      } else {\n        templateQuasis.push(import_compiler33.types.templateElement({ raw: currentQuasi }));\n        addStatement(\n          \"render\",\n          getSection(tag),\n          referencePlaceholder.value.extra?.referencedBindings,\n          import_compiler33.types.expressionStatement(\n            callRuntime(\n              \"textContent\",\n              import_compiler33.types.memberExpression(scopeIdentifier, visitAccessor, true),\n              import_compiler33.types.templateLiteral(templateQuasis, templateExpressions)\n            )\n          )\n        );\n      }\n    }\n    write2`</script>`;\n    if (nodeRef2) {\n      markNode(tag, nodeRef2);\n    }\n    exit2(tag);\n    tag.remove();\n  },\n  \"@async\": \"#html-async\",\n  \"@crossorigin\": \"#html-crossorigin\",\n  \"@defer\": \"#html-defer\",\n  \"@integrity\": \"#html-integrity\",\n  \"@nomodule\": \"#html-nomodule\",\n  \"@nonce\": \"#html-nonce\",\n  \"@referrerpolicy\": \"#html-referrerpolicy\",\n  \"@src\": \"#html-src\",\n  \"@type\": \"#html-type\",\n  \"attribute-groups\": [\"html-attributes\"],\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  }\n};\nfunction getUsedAttrs2(tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler33.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n      }\n      spreadProps.push(import_compiler33.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler33.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler33.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    spreadExpression,\n    skipExpression\n  };\n}\n\n// src/translator/core/html-style.ts\nvar import_compiler34 = require(\"@marko/compiler\");\nvar import_babel_utils23 = require(\"@marko/compiler/babel-utils\");\nvar kGetterId4 = Symbol(\"node getter id\");\nvar html_style_default = {\n  analyze(tag) {\n    (0, import_babel_utils23.assertNoArgs)(tag);\n    (0, import_babel_utils23.assertNoParams)(tag);\n    const { node } = tag;\n    if (node.var && !import_compiler34.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\n        \"Tag variables on native elements cannot be destructured.\"\n      );\n    }\n    const section = getOrCreateSection(tag);\n    let hasEventHandlers = false;\n    let hasDynamicAttributes = false;\n    const seen = {};\n    const { attributes } = tag.node;\n    let spreadReferenceNodes;\n    for (let i = attributes.length; i--; ) {\n      const attr2 = attributes[i];\n      if (import_compiler34.types.isMarkoAttribute(attr2)) {\n        if (seen[attr2.name]) {\n          dropReferences(attr2.value);\n          continue;\n        }\n        seen[attr2.name] = attr2;\n        if (isEventHandler(attr2.name)) {\n          (attr2.value.extra ??= {}).isEffect = true;\n          hasEventHandlers = true;\n        } else if (!evaluate(attr2.value).confident) {\n          hasDynamicAttributes = true;\n        }\n      } else if (import_compiler34.types.isMarkoSpreadAttribute(attr2)) {\n        hasEventHandlers = true;\n        hasDynamicAttributes = true;\n        (attr2.value.extra ??= {}).isEffect = true;\n      }\n      if (spreadReferenceNodes) {\n        spreadReferenceNodes.push(attr2.value);\n      } else if (import_compiler34.types.isMarkoSpreadAttribute(attr2)) {\n        spreadReferenceNodes = [attr2.value];\n      }\n    }\n    if (spreadReferenceNodes) {\n      mergeReferences(section, tag.node, spreadReferenceNodes);\n    }\n    const bodyPlaceholderNodes = [];\n    let hasBodyPlaceholders = false;\n    for (const child of tag.node.body.body) {\n      if (import_compiler34.types.isMarkoPlaceholder(child)) {\n        bodyPlaceholderNodes.push(child.value);\n        hasBodyPlaceholders = true;\n      } else if (!import_compiler34.types.isMarkoText(child)) {\n        throw tag.hub.buildError(\n          child,\n          \"Invalid child. Only text is allowed inside an html-style.\"\n        );\n      }\n    }\n    if (bodyPlaceholderNodes.length > 1) {\n      mergeReferences(\n        section,\n        bodyPlaceholderNodes[0],\n        bodyPlaceholderNodes.slice(1)\n      );\n    }\n    if (node.var || hasEventHandlers || hasDynamicAttributes || hasBodyPlaceholders) {\n      currentProgramPath.node.extra.isInteractive ||= hasEventHandlers;\n      const tagExtra = node.extra ??= {};\n      const bindingName = \"#style\";\n      tagExtra[kSerializeMarker] = hasEventHandlers || !!node.var;\n      tagExtra[kNativeTagBinding] = createBinding(\n        bindingName,\n        0 /* dom */,\n        section\n      );\n      if (node.var) {\n        for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n          if (!ref.parentPath?.isCallExpression()) {\n            tagExtra[kGetterId4] = getRegisterUID(section, bindingName);\n            break;\n          }\n        }\n      }\n    }\n  },\n  translate(tag) {\n    const tagExtra = tag.node.extra;\n    const nodeRef2 = tagExtra[kNativeTagBinding];\n    const isHTML = isOutputHTML();\n    const write2 = writeTo(tag);\n    const section = getSection(tag);\n    const hasVar = !!tag.node.var;\n    if (hasVar) {\n      const getterId = tagExtra[kGetterId4];\n      if (isHTML) {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        for (const reference of references) {\n          let currentSection = getSection(reference);\n          while (currentSection !== section && currentSection.parent) {\n            getSerializedScopeProperties(currentSection).set(\n              import_compiler34.types.stringLiteral(\"_\"),\n              callRuntime(\n                \"ensureScopeWithId\",\n                getScopeIdIdentifier(currentSection = currentSection.parent)\n              )\n            );\n          }\n        }\n        translateVar(\n          tag,\n          callRuntime(\n            \"nodeRef\",\n            getterId && getScopeIdIdentifier(section),\n            getterId && import_compiler34.types.stringLiteral(getterId)\n          )\n        );\n      } else {\n        const varName = tag.node.var.name;\n        const references = tag.scope.getBinding(varName).referencePaths;\n        let getterFnIdentifier;\n        if (getterId) {\n          getterFnIdentifier = currentProgramPath.scope.generateUidIdentifier(\n            `get_${varName}`\n          );\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler34.types.variableDeclaration(\"const\", [\n              import_compiler34.types.variableDeclarator(\n                getterFnIdentifier,\n                callRuntime(\n                  \"nodeRef\",\n                  import_compiler34.types.stringLiteral(getterId),\n                  getScopeAccessorLiteral(nodeRef2)\n                )\n              )\n            ])\n          );\n        }\n        for (const reference of references) {\n          const referenceSection = getSection(reference);\n          if (reference.parentPath?.isCallExpression()) {\n            reference.parentPath.replaceWith(\n              import_compiler34.types.expressionStatement(\n                createScopeReadExpression(referenceSection, nodeRef2)\n              )\n            );\n          } else if (getterFnIdentifier) {\n            reference.replaceWith(\n              import_compiler34.types.callExpression(getterFnIdentifier, [\n                getScopeExpression(referenceSection, getSection(tag))\n              ])\n            );\n          }\n        }\n      }\n    }\n    let visitAccessor;\n    if (nodeRef2) {\n      visitAccessor = getScopeAccessorLiteral(nodeRef2);\n      visit(tag, 32 /* Get */);\n    }\n    write2`<style`;\n    const usedAttrs = getUsedAttrs3(tag.node);\n    const { staticAttrs, skipExpression, spreadExpression } = usedAttrs;\n    for (const attr2 of staticAttrs) {\n      const { name: name2, value } = attr2;\n      const { confident, computed } = value.extra || {};\n      const valueReferences = value.extra?.referencedBindings;\n      switch (name2) {\n        case \"class\":\n        case \"style\": {\n          const helper = `${name2}Attr`;\n          if (confident) {\n            write2`${getHTMLRuntime()[helper](computed)}`;\n          } else if (isHTML) {\n            write2`${callRuntime(helper, value)}`;\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              valueReferences,\n              import_compiler34.types.expressionStatement(\n                callRuntime(\n                  helper,\n                  import_compiler34.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  value\n                )\n              )\n            );\n          }\n          break;\n        }\n        default:\n          if (confident) {\n            write2`${getHTMLRuntime().attr(name2, computed)}`;\n          } else if (isHTML) {\n            if (isEventHandler(name2)) {\n              addHTMLEffectCall(section, valueReferences);\n            } else {\n              write2`${callRuntime(\"attr\", import_compiler34.types.stringLiteral(name2), value)}`;\n            }\n          } else if (isEventHandler(name2)) {\n            addStatement(\n              \"effect\",\n              section,\n              valueReferences,\n              import_compiler34.types.expressionStatement(\n                callRuntime(\n                  \"on\",\n                  import_compiler34.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  import_compiler34.types.stringLiteral(getEventHandlerName(name2)),\n                  value\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              valueReferences,\n              import_compiler34.types.expressionStatement(\n                callRuntime(\n                  \"attr\",\n                  import_compiler34.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                  import_compiler34.types.stringLiteral(name2),\n                  value\n                )\n              )\n            );\n          }\n          break;\n      }\n    }\n    if (spreadExpression) {\n      if (isHTML) {\n        addHTMLEffectCall(section, tagExtra.referencedBindings);\n        if (skipExpression) {\n          write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler34.types.stringLiteral(\"style\"))}`;\n        } else {\n          write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler34.types.stringLiteral(\"style\"))}`;\n        }\n      } else {\n        if (skipExpression) {\n          addStatement(\n            \"render\",\n            section,\n            tagExtra.referencedBindings,\n            import_compiler34.types.expressionStatement(\n              callRuntime(\n                \"partialAttrs\",\n                scopeIdentifier,\n                visitAccessor,\n                spreadExpression,\n                skipExpression\n              )\n            )\n          );\n        } else {\n          addStatement(\n            \"render\",\n            section,\n            tagExtra.referencedBindings,\n            import_compiler34.types.expressionStatement(\n              callRuntime(\n                \"attrs\",\n                scopeIdentifier,\n                visitAccessor,\n                spreadExpression\n              )\n            )\n          );\n        }\n        addStatement(\n          \"effect\",\n          section,\n          tagExtra.referencedBindings,\n          import_compiler34.types.expressionStatement(\n            callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n          ),\n          false\n        );\n      }\n    }\n    write2`>`;\n    enter2(tag);\n    if (isOutputHTML()) {\n      for (const child of tag.node.body.body) {\n        if (import_compiler34.types.isMarkoText(child)) {\n          write2`${child.value}`;\n        } else if (import_compiler34.types.isMarkoPlaceholder(child)) {\n          write2`${callRuntime(\"escapeStyle\", child.value)}`;\n        }\n      }\n    } else {\n      const templateQuasis = [];\n      const templateExpressions = [];\n      let currentQuasi = \"\";\n      let referencePlaceholder;\n      for (const child of tag.node.body.body) {\n        if (import_compiler34.types.isMarkoText(child)) {\n          currentQuasi += child.value;\n        } else if (import_compiler34.types.isMarkoPlaceholder(child)) {\n          referencePlaceholder ||= child;\n          templateQuasis.push(import_compiler34.types.templateElement({ raw: currentQuasi }));\n          templateExpressions.push(child.value);\n          currentQuasi = \"\";\n        }\n      }\n      if (!referencePlaceholder) {\n        write2`${currentQuasi}`;\n      } else {\n        templateQuasis.push(import_compiler34.types.templateElement({ raw: currentQuasi }));\n        addStatement(\n          \"render\",\n          getSection(tag),\n          referencePlaceholder.value.extra?.referencedBindings,\n          import_compiler34.types.expressionStatement(\n            callRuntime(\n              \"textContent\",\n              import_compiler34.types.memberExpression(scopeIdentifier, visitAccessor, true),\n              import_compiler34.types.templateLiteral(templateQuasis, templateExpressions)\n            )\n          )\n        );\n      }\n    }\n    write2`</style>`;\n    if (nodeRef2) {\n      markNode(tag, nodeRef2);\n    }\n    exit2(tag);\n    tag.remove();\n  },\n  \"@disabled\": \"#html-disabled\",\n  \"@media\": \"#html-media\",\n  \"@nonce\": \"#html-nonce\",\n  \"@type\": \"#html-type\",\n  \"attribute-groups\": [\"html-attributes\"],\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  }\n};\nfunction getUsedAttrs3(tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler34.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n      }\n      spreadProps.push(import_compiler34.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler34.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler34.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    spreadExpression,\n    skipExpression\n  };\n}\n\n// src/translator/core/id.ts\nvar import_compiler35 = require(\"@marko/compiler\");\nvar import_babel_utils24 = require(\"@marko/compiler/babel-utils\");\nvar id_default = {\n  analyze(tag) {\n    (0, import_babel_utils24.assertNoArgs)(tag);\n    (0, import_babel_utils24.assertNoParams)(tag);\n    (0, import_babel_utils24.assertNoAttributes)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils24.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `id` tag requires a tag variable.\");\n    }\n    if (!import_compiler35.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `id` tag cannot be destructured\");\n    }\n    trackVarReferences(tag, 4 /* derived */);\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const id = isOutputHTML() ? callRuntime(\"nextTagId\") : callRuntime(\"nextTagId\", scopeIdentifier);\n      if (isOutputHTML()) {\n        tag.replaceWith(\n          import_compiler35.types.variableDeclaration(\"const\", [import_compiler35.types.variableDeclarator(node.var, id)])\n        );\n      } else {\n        const source = initValue(node.var.extra.binding);\n        addValue(getSection(tag), void 0, source, id);\n        tag.remove();\n      }\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"id/<name>\",\n      description: \"Use to create a unique identifier.\",\n      snippet: \"id/${1:name}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#id\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/id.d.marko\"\n};\n\n// src/translator/core/if.ts\nvar import_compiler37 = require(\"@marko/compiler\");\nvar import_babel_utils25 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/to-first-statement-or-block.ts\nvar import_compiler36 = require(\"@marko/compiler\");\nfunction toFirstStatementOrBlock(body) {\n  if (Array.isArray(body)) {\n    if (body.length === 1) {\n      return body[0];\n    }\n    return import_compiler36.types.blockStatement(body);\n  }\n  return body;\n}\n\n// src/translator/core/if.ts\nvar kBinding = Symbol(\"if node binding\");\nvar BRANCHES_LOOKUP = /* @__PURE__ */ new WeakMap();\nvar IfTag = {\n  analyze(tag) {\n    assertValidCondition(tag);\n    if (tag.node.body.attributeTags) return;\n    const [isLast, branches] = getBranches(tag, startSection(tag.get(\"body\")));\n    if (isLast) {\n      const [rootTag] = branches[0];\n      const rootExtra = rootTag.node.extra ??= {};\n      const mergeReferenceNodes = [];\n      let singleNodeOptimization = true;\n      for (const [branchTag, branchBodySection] of branches) {\n        if (branchBodySection) {\n          branchBodySection.upstreamExpression = rootExtra;\n          if (!(branchBodySection.content === null || branchBodySection.content?.singleChild)) {\n            singleNodeOptimization = false;\n          }\n        }\n        if (branchTag.node.attributes.length) {\n          mergeReferenceNodes.push(branchTag.node.attributes[0].value);\n        }\n      }\n      const section = getOrCreateSection(tag);\n      rootExtra[kBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section,\n        void 0,\n        rootExtra\n      );\n      rootExtra.singleNodeOptimization = singleNodeOptimization;\n      mergeReferences(section, rootTag.node, mergeReferenceNodes);\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        const rootExtra = getRoot(tag).node.extra;\n        const isStateful = isStatefulReferences(rootExtra.referencedBindings);\n        const singleNodeOptimization = rootExtra.singleNodeOptimization;\n        if (isRoot(tag)) {\n          visit(tag, 37 /* Replace */);\n        }\n        enterShallow(tag);\n        flushBefore(tag);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n          if (isStateful && !singleNodeOptimization) {\n            writeTo(tagBody)`${callRuntime(\n              \"markResumeScopeStart\",\n              getScopeIdIdentifier(bodySection)\n            )}`;\n          }\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const [isLast, branches] = getBranches(tag, bodySection);\n        const rootExtra = branches[0][0].node.extra;\n        const nodeRef2 = rootExtra[kBinding];\n        const isStateful = isStatefulReferences(rootExtra.referencedBindings);\n        const singleNodeOptimization = rootExtra.singleNodeOptimization;\n        const hasStatefulClosures = bodySection && checkStatefulClosures(bodySection, true);\n        if (bodySection) {\n          if (isStateful || hasStatefulClosures) {\n            setForceResumeScope(bodySection);\n          }\n          flushInto(tag);\n          setSubscriberBuilder(tag, () => {\n          });\n          writeHTMLResumeStatements(tagBody);\n        }\n        if (isLast) {\n          const write2 = writeTo(tag);\n          const nextTag = tag.getNextSibling();\n          const ifScopeIdIdentifier = tag.scope.generateUidIdentifier(\"ifScopeId\");\n          const ifRendererIdentifier = tag.scope.generateUidIdentifier(\"ifRenderer\");\n          let statement;\n          for (let i = branches.length; i--; ) {\n            const [branchTag, branchBodySection] = branches[i];\n            const bodyStatements = branchTag.node.body.body;\n            if (branchBodySection) {\n              const branchHasStatefulClosures = checkStatefulClosures(\n                branchBodySection,\n                true\n              );\n              if (isStateful) {\n                bodyStatements.push(\n                  import_compiler37.types.expressionStatement(\n                    callRuntime(\n                      \"register\",\n                      import_compiler37.types.assignmentExpression(\n                        \"=\",\n                        ifRendererIdentifier,\n                        callRuntime(\n                          \"createRenderer\",\n                          import_compiler37.types.arrowFunctionExpression([], import_compiler37.types.blockStatement([]))\n                        )\n                      ),\n                      import_compiler37.types.stringLiteral(\n                        getResumeRegisterId(branchBodySection, \"renderer\")\n                      )\n                    )\n                  )\n                );\n              }\n              if (isStateful || branchHasStatefulClosures) {\n                bodyStatements.push(\n                  import_compiler37.types.expressionStatement(\n                    import_compiler37.types.assignmentExpression(\n                      \"=\",\n                      ifScopeIdIdentifier,\n                      getScopeIdIdentifier(branchBodySection)\n                    )\n                  )\n                );\n              }\n            }\n            const [testAttr] = branchTag.node.attributes;\n            const curStatement = toFirstStatementOrBlock(bodyStatements);\n            if (testAttr) {\n              statement = import_compiler37.types.ifStatement(\n                testAttr.value,\n                curStatement,\n                statement\n              );\n            } else {\n              statement = curStatement;\n            }\n            branchTag.remove();\n          }\n          if (!(isStateful || hasStatefulClosures)) {\n            nextTag.insertBefore(statement);\n          } else {\n            nextTag.insertBefore([\n              import_compiler37.types.variableDeclaration(\n                \"let\",\n                [\n                  import_compiler37.types.variableDeclarator(ifScopeIdIdentifier),\n                  isStateful && import_compiler37.types.variableDeclarator(ifRendererIdentifier)\n                ].filter(Boolean)\n              ),\n              statement\n            ]);\n            if (isStateful) {\n              if (singleNodeOptimization) {\n                write2`${callRuntime(\n                  \"markResumeControlSingleNodeEnd\",\n                  getScopeIdIdentifier(section),\n                  getScopeAccessorLiteral(nodeRef2),\n                  ifScopeIdIdentifier\n                )}`;\n              } else {\n                write2`${callRuntime(\n                  \"markResumeControlEnd\",\n                  getScopeIdIdentifier(section),\n                  getScopeAccessorLiteral(nodeRef2)\n                )}`;\n              }\n              getSerializedScopeProperties(section).set(\n                import_compiler37.types.stringLiteral(\n                  getScopeAccessorLiteral(nodeRef2).value + \"(\" /* ConditionalRenderer */\n                ),\n                ifRendererIdentifier\n              );\n            }\n            getSerializedScopeProperties(section).set(\n              import_compiler37.types.stringLiteral(\n                getScopeAccessorLiteral(nodeRef2).value + \"!\" /* ConditionalScope */\n              ),\n              callRuntime(\"getScopeById\", ifScopeIdIdentifier)\n            );\n          }\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n        }\n        if (isRoot(tag)) {\n          visit(tag, 37 /* Replace */);\n        }\n        enterShallow(tag);\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const [isLast, branches] = getBranches(\n          tag,\n          getSectionForBody(tag.get(\"body\"))\n        );\n        if (isLast) {\n          const section = getSection(tag);\n          const rootExtra = branches[0][0].node.extra;\n          const nodeRef2 = rootExtra[kBinding];\n          let expr = import_compiler37.types.nullLiteral();\n          for (let i = branches.length; i--; ) {\n            const [branchTag, branchBodySection] = branches[i];\n            const [testAttr] = branchTag.node.attributes;\n            const consequent = branchBodySection ? import_compiler37.types.identifier(branchBodySection.name) : import_compiler37.types.numericLiteral(0);\n            setSubscriberBuilder(branchTag, (subscriber) => {\n              return callRuntime(\n                \"inConditionalScope\",\n                subscriber,\n                getScopeAccessorLiteral(nodeRef2)\n                /*t.identifier(section.name)*/\n              );\n            });\n            branchTag.remove();\n            expr = testAttr ? import_compiler37.types.conditionalExpression(testAttr.value, consequent, expr) : consequent;\n          }\n          const signal = getSignal(section, nodeRef2, \"if\");\n          signal.build = () => {\n            return callRuntime(\n              \"conditional\",\n              getScopeAccessorLiteral(nodeRef2),\n              getSignalFn(signal, [scopeIdentifier])\n            );\n          };\n          signal.hasDownstreamIntersections = () => branches.some(([, bodySection]) => bodySection?.closures);\n          addValue(section, rootExtra.referencedBindings, signal, expr);\n        }\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  autocomplete: [\n    {\n      snippet: \"if=${1:condition}\",\n      description: \"Use to display content only if the condition is met.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseIfTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      snippet: \"else-if=${1:condition}\",\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nfunction assertValidCondition(tag) {\n  (0, import_babel_utils25.assertNoVar)(tag);\n  (0, import_babel_utils25.assertNoArgs)(tag);\n  (0, import_babel_utils25.assertNoParams)(tag);\n  assertHasBody(tag);\n  assertNoSpreadAttrs(tag);\n  switch (getTagName(tag)) {\n    case \"if\":\n      assertHasValueAttribute(tag);\n      break;\n    case \"else-if\":\n      assertHasValueAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n    case \"else\":\n      assertOptionalIfAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n  }\n}\nfunction assertHasPrecedingCondition(tag) {\n  let prev = tag.getPrevSibling();\n  while (prev.node && prev.isMarkoComment()) prev = prev.getPrevSibling();\n  if (!isConditionTag(prev) || getTagName(prev) !== \"else\" && !prev.node.attributes.length) {\n    throw tag.buildCodeFrameError(\n      `The \\`<${getTagName(tag)}>\\` must have a preceding \\`<if=cond>\\`, \\`<else-if=cond>\\`, or \\`<else if=cond>\\`.`\n    );\n  }\n}\nfunction assertHasBody(tag) {\n  if (!(tag.node.body.body.length || tag.node.attributeTags.length)) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${getTagName(tag)}\\` tag requires body content.`\n    );\n  }\n}\nfunction assertHasValueAttribute(tag) {\n  const { node } = tag;\n  const [valueAttr] = node.attributes;\n  if (!import_compiler37.types.isMarkoAttribute(valueAttr) || !valueAttr.default) {\n    throw tag.get(\"name\").buildCodeFrameError(`The \\`${getTagName(tag)}\\` tag requires a value.`);\n  }\n  if (node.attributes.length > 1) {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports the \\`value\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction assertOptionalIfAttribute(tag) {\n  const { node } = tag;\n  const [ifAttr] = node.attributes;\n  if (node.attributes.length > 1 || ifAttr && ifAttr.name !== \"if\") {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports an \\`if=\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction getBranches(tag, bodySection) {\n  const branches = BRANCHES_LOOKUP.get(tag) ?? [];\n  let nextTag = tag.getNextSibling();\n  while (nextTag.isMarkoComment()) nextTag = nextTag.getNextSibling();\n  const isLast = !(isCoreTagName(nextTag, \"else\") || isCoreTagName(nextTag, \"else-if\"));\n  branches.push([tag, bodySection]);\n  if (!isLast) {\n    BRANCHES_LOOKUP.set(nextTag, branches);\n  }\n  return [isLast, branches];\n}\nfunction getRoot(tag) {\n  return isRoot(tag) ? tag : BRANCHES_LOOKUP.get(tag)[0][0];\n}\nfunction isRoot(tag) {\n  return isCoreTagName(tag, \"if\");\n}\n\n// src/translator/core/import.ts\nvar import_babel_utils26 = require(\"@marko/compiler/babel-utils\");\nvar import_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils26.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: 'import <scope> from \"<path>\"',\n      description: \"Use to import external modules, follows the same syntax as JavaScript imports.\",\n      snippet: 'import ${2} from \"${1:path}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#importing-external-files\"\n    }\n  ]\n};\n\n// src/translator/core/let.ts\nvar import_compiler38 = require(\"@marko/compiler\");\nvar import_babel_utils27 = require(\"@marko/compiler/babel-utils\");\nvar let_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    let valueAttr;\n    let valueChangeAttr;\n    for (const attr2 of node.attributes) {\n      if (import_compiler38.types.isMarkoAttribute(attr2)) {\n        if (attr2.name === \"value\") {\n          valueAttr = attr2;\n        } else if (attr2.name === \"valueChange\") {\n          valueChangeAttr = attr2;\n        } else {\n          const start = attr2.loc?.start;\n          const end = attr2.loc?.end;\n          const msg = \"The `let` tag only supports the `value` attribute and its change handler.\";\n          if (start == null || end == null) {\n            throw tag.get(\"name\").buildCodeFrameError(msg);\n          } else {\n            throw tag.hub.buildError(\n              { loc: { start, end } },\n              msg,\n              Error\n            );\n          }\n        }\n      }\n    }\n    (0, import_babel_utils27.assertNoArgs)(tag);\n    (0, import_babel_utils27.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    if (!tagVar) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `let` tag requires a tag variable.\");\n    }\n    if (!import_compiler38.types.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `let` tag variable cannot be destructured.\");\n    }\n    if (valueChangeAttr && (0, import_babel_utils27.computeNode)(valueChangeAttr.value)) {\n      throw tag.get(\"attributes\").find((attr2) => attr2.node === valueChangeAttr).get(\"value\").buildCodeFrameError(\n        \"The `let` tag `valueChange` attribute must be a function.\"\n      );\n    }\n    mergeReferences(getOrCreateSection(tag), tag.node, [\n      valueAttr?.value,\n      valueChangeAttr?.value\n    ]);\n    trackVarReferences(tag, 1 /* let */, void 0, tag.node.extra);\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const tagVar = node.var;\n      const valueAttr = node.attributes.find(\n        (attr2) => import_compiler38.types.isMarkoAttribute(attr2) && (attr2.default || attr2.name === \"value\")\n      ) ?? import_compiler38.types.markoAttribute(\"value\", import_compiler38.types.identifier(\"undefined\"));\n      const valueChangeAttr = node.attributes.find(\n        (attr2) => import_compiler38.types.isMarkoAttribute(attr2) && attr2.name === \"valueChange\"\n      );\n      const section = getSection(tag);\n      const binding = tagVar.extra.binding;\n      if (isOutputDOM()) {\n        const signal = initValue(binding, \"state\");\n        const referencedBindings = tag.node.extra.referencedBindings;\n        addValue(section, referencedBindings, signal, valueAttr.value);\n        if (valueChangeAttr) {\n          signal.extraArgs = [valueChangeAttr.value];\n        }\n        signal.buildAssignment = (valueSection, value) => {\n          const scope = getScopeExpression(valueSection, signal.section);\n          return import_compiler38.types.callExpression(signal.identifier, [scope, value]);\n        };\n      } else {\n        translateVar(tag, valueAttr.value);\n        if (valueChangeAttr) {\n          getSerializedScopeProperties(section).set(\n            import_compiler38.types.stringLiteral(\n              getScopeAccessorLiteral(binding).value + \"@\" /* TagVariableChange */\n            ),\n            valueChangeAttr.value\n          );\n        }\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a mutable binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#let\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/let.d.marko\"\n};\n\n// src/translator/core/lifecycle.ts\nvar import_compiler39 = require(\"@marko/compiler\");\nvar import_babel_utils28 = require(\"@marko/compiler/babel-utils\");\nvar kRef = Symbol(\"lifecycle attrs reference\");\nvar lifecycle_default = {\n  analyze(tag) {\n    (0, import_babel_utils28.assertNoArgs)(tag);\n    (0, import_babel_utils28.assertNoVar)(tag);\n    (0, import_babel_utils28.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const tagExtra = node.extra ??= {};\n    const section = getOrCreateSection(tag);\n    tagExtra[kRef] = createBinding(\n      currentProgramPath.scope.generateUid(\"lifecycle\"),\n      4 /* derived */,\n      section,\n      void 0,\n      tagExtra\n    );\n    if (node.attributes.length === 0) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `lifecycle` tag requires at least one attribute.\"\n      );\n    }\n    for (const attr2 of node.attributes) {\n      if (import_compiler39.types.isMarkoSpreadAttribute(attr2)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The `lifecycle` tag does not support `...spread` attributes.\"\n        );\n      }\n      (attr2.value.extra ??= {}).isEffect = true;\n    }\n    (currentProgramPath.node.extra ??= {}).isInteractive = true;\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const section = getSection(tag);\n      const tagExtra = node.extra;\n      const { referencedBindings } = tagExtra;\n      const lifecycleAttrsRef = tagExtra[kRef];\n      if (isOutputDOM()) {\n        const translatedAttrs = translateAttrs(tag);\n        translatedAttrs.statements.push(\n          import_compiler39.types.expressionStatement(\n            callRuntime(\n              \"lifecycle\",\n              scopeIdentifier,\n              getScopeAccessorLiteral(lifecycleAttrsRef),\n              propsToExpression(translatedAttrs.properties)\n            )\n          )\n        );\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          translatedAttrs.statements\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/lifecycle.d.marko\"\n};\n\n// src/translator/core/log.ts\nvar import_compiler40 = require(\"@marko/compiler\");\nvar import_babel_utils29 = require(\"@marko/compiler/babel-utils\");\nvar log_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils29.assertNoArgs)(tag);\n    (0, import_babel_utils29.assertNoVar)(tag);\n    (0, import_babel_utils29.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `log` tag requires a value.\");\n    }\n    if (tag.node.attributes.length > 1 || !import_compiler40.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `log` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      const statement = import_compiler40.types.expressionStatement(\n        import_compiler40.types.callExpression(\n          import_compiler40.types.memberExpression(import_compiler40.types.identifier(\"console\"), import_compiler40.types.identifier(\"log\")),\n          [value]\n        )\n      );\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to log a value to the console.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#log\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/log.d.marko\"\n};\n\n// src/translator/core/script.ts\nvar import_compiler41 = require(\"@marko/compiler\");\nvar import_babel_utils30 = require(\"@marko/compiler/babel-utils\");\nvar htmlScriptTagAlternateMsg = \" For a native html `script` tag use the `html-script` core tag instead.\";\nvar script_default = {\n  parse(tag) {\n    const { node } = tag;\n    const { body } = node.body;\n    if (body.length) {\n      let code = \"\";\n      for (const child of body) {\n        if (child.type !== \"MarkoText\") {\n          throw tag.hub.file.hub.buildError(\n            child,\n            \"Unexpected content in `script` tag. Only javascript and typescript is supported.\" + htmlScriptTagAlternateMsg,\n            SyntaxError\n          );\n        }\n        code += child.value;\n      }\n      const start = body[0]?.start;\n      const end = body[body.length - 1]?.end;\n      const bodyStatements = (0, import_babel_utils30.parseStatements)(tag.hub.file, code, start, end);\n      const valueFn = import_compiler41.types.arrowFunctionExpression(\n        [],\n        import_compiler41.types.blockStatement(bodyStatements),\n        traverseContains(bodyStatements, isAwaitExpression)\n      );\n      node.attributes.push(import_compiler41.types.markoAttribute(\"value\", valueFn));\n      node.body.body = [];\n    }\n  },\n  analyze(tag) {\n    const { node } = tag;\n    (0, import_babel_utils30.assertNoArgs)(tag);\n    (0, import_babel_utils30.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils30.assertNoAttributeTags)(tag);\n    if (node.var) {\n      throw tag.hub.buildError(\n        node.var,\n        \"The `script` tag does not support a tag variable reference.\" + htmlScriptTagAlternateMsg\n      );\n    }\n    let seenValueAttr = false;\n    for (const attr2 of node.attributes) {\n      if (attr2.type === \"MarkoAttribute\" && attr2.name === \"value\") {\n        if (seenValueAttr) {\n          throw tag.hub.buildError(attr2, \"Invalid duplicate value attribute.\");\n        }\n        seenValueAttr = true;\n        (attr2.value.extra ??= {}).isEffect = true;\n        (currentProgramPath.node.extra ??= {}).isInteractive = true;\n      } else {\n        throw tag.hub.buildError(\n          attr2,\n          \"The `script` tag does not support html attributes.\" + htmlScriptTagAlternateMsg\n        );\n      }\n    }\n    if (!seenValueAttr) {\n      dropReferences(getAllTagReferenceNodes(node));\n    }\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      if (!valueAttr) {\n        tag.remove();\n        return;\n      }\n      const section = getSection(tag);\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      if (isOutputDOM()) {\n        const { value: value2 } = valueAttr;\n        const isFunction2 = import_compiler41.types.isFunctionExpression(value2) || import_compiler41.types.isArrowFunctionExpression(value2);\n        let inlineBody = null;\n        if (isFunction2 && !(value2.async || value2.generator)) {\n          if (import_compiler41.types.isBlockStatement(value2.body)) {\n            let hasDeclaration = false;\n            for (const child of value2.body.body) {\n              if (import_compiler41.types.isDeclaration(child)) {\n                hasDeclaration = true;\n                break;\n              }\n            }\n            inlineBody = hasDeclaration ? value2.body : value2.body.body;\n          } else {\n            inlineBody = import_compiler41.types.expressionStatement(value2.body);\n          }\n        }\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          inlineBody || import_compiler41.types.expressionStatement(\n            import_compiler41.types.callExpression(value2, isFunction2 ? [] : [scopeIdentifier])\n          )\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  html: false,\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#script\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/script.d.marko\"\n};\nfunction isAwaitExpression(node) {\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ObjectMethod\":\n    case \"ClassPrivateMethod\":\n      return skip;\n    case \"AwaitExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// src/translator/core/server.ts\nvar import_compiler42 = require(\"@marko/compiler\");\nvar import_babel_utils31 = require(\"@marko/compiler/babel-utils\");\nvar server_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^server\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils31.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler42.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler42.types.markoScriptlet(body, true, \"server\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"server <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the server.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#server-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/static.ts\nvar import_compiler43 = require(\"@marko/compiler\");\nvar import_babel_utils32 = require(\"@marko/compiler/babel-utils\");\nvar static_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^static\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils32.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler43.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler43.types.markoScriptlet(body, true));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"static <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#static-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/style.ts\nvar import_compiler44 = require(\"@marko/compiler\");\nvar import_babel_utils33 = require(\"@marko/compiler/babel-utils\");\nvar import_magic_string = __toESM(require(\"magic-string\"));\nvar import_path2 = __toESM(require(\"path\"));\nvar STYLE_EXT_REG = /^style((?:\\.[a-zA-Z0-9$_-]+)+)?/;\nvar htmlStyleTagAlternateMsg = \" For a native html `style` tag use the `html-style` core tag instead.\";\nvar style_default = {\n  analyze(tag) {\n    (0, import_babel_utils33.assertNoArgs)(tag);\n    (0, import_babel_utils33.assertNoParams)(tag);\n    (0, import_babel_utils33.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    const ext = STYLE_EXT_REG.exec(node.rawValue || \"\")?.[1]?.slice(1);\n    for (const attr2 of node.attributes) {\n      if (attr2.start == null && attr2.type === \"MarkoAttribute\" && attr2.name === \"class\" && attr2.value.type === \"StringLiteral\" && attr2.value.value === ext) {\n        continue;\n      }\n      throw tag.hub.buildError(\n        attr2.value,\n        \"The `style` does not support html attributes.\" + htmlStyleTagAlternateMsg\n      );\n    }\n    for (const child of node.body.body) {\n      if (child.type !== \"MarkoText\") {\n        throw tag.hub.buildError(\n          child,\n          \"The `style` tag currently only supports static content.\" + htmlStyleTagAlternateMsg\n        );\n      }\n    }\n    if (node.body.body.length > 1) {\n      throw tag.hub.buildError(\n        node.name,\n        \"The `style` tag currently only supports static content.\" + htmlStyleTagAlternateMsg\n      );\n    }\n  },\n  translate(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const { filename, sourceMaps } = file.opts;\n    let ext = STYLE_EXT_REG.exec(node.rawValue || \"\")?.[1] || \".css\";\n    if (node.var && !/\\.module\\./.test(ext)) {\n      ext = \".module\" + ext;\n    }\n    const markoText = node.body.body[0];\n    const { resolveVirtualDependency } = getMarkoOpts();\n    const start = (0, import_babel_utils33.getStart)(file, markoText);\n    const end = (0, import_babel_utils33.getEnd)(file, markoText);\n    let code = markoText.value;\n    let map2;\n    if (resolveVirtualDependency && sourceMaps && start !== null && end !== null) {\n      const magicString = new import_magic_string.default(file.code, { filename });\n      magicString.remove(0, start);\n      magicString.remove(end, file.code.length);\n      map2 = magicString.generateMap({\n        source: filename,\n        includeContent: true\n      });\n      if (sourceMaps === \"inline\" || sourceMaps === \"both\") {\n        code += `\n/*# sourceMappingURL=${map2.toUrl()}*/`;\n        if (sourceMaps === \"inline\") {\n          map2 = void 0;\n        }\n      }\n    }\n    const importPath = resolveVirtualDependency?.(filename, {\n      virtualPath: `./${import_path2.default.basename(filename) + ext}`,\n      code,\n      map: map2\n    });\n    if (importPath) {\n      if (!node.var) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler44.types.importDeclaration([], import_compiler44.types.stringLiteral(importPath))\n        );\n      } else if (import_compiler44.types.isIdentifier(node.var)) {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler44.types.importDeclaration(\n            [import_compiler44.types.importDefaultSpecifier(node.var)],\n            import_compiler44.types.stringLiteral(importPath)\n          )\n        );\n      } else {\n        currentProgramPath.pushContainer(\n          \"body\",\n          import_compiler44.types.variableDeclaration(\"const\", [\n            import_compiler44.types.variableDeclarator(\n              node.var,\n              (0, import_babel_utils33.importDefault)(file, importPath, \"style\")\n            )\n          ])\n        );\n      }\n    }\n    tag.remove();\n  },\n  parseOptions: {\n    html: false,\n    text: true,\n    rawOpenTag: true,\n    preserveWhitespace: true\n  },\n  attributes: {}\n};\n\n// src/translator/core/index.ts\nvar core_default = {\n  taglibId: runtime_info_default.taglibId,\n  \"<attrs>\": attrs_default,\n  \"<client>\": client_default,\n  \"<const>\": const_default,\n  \"<debug>\": debug_default,\n  \"<define>\": define_default,\n  \"<effect>\": effect_default,\n  \"<else-if>\": ElseIfTag,\n  \"<else>\": ElseTag,\n  \"<export>\": export_default,\n  \"<for>\": for_default,\n  \"<html-comment>\": html_comment_default,\n  \"<html-script>\": html_script_default,\n  \"<html-style>\": html_style_default,\n  \"<id>\": id_default,\n  \"<if>\": IfTag,\n  \"<import>\": import_default,\n  \"<let>\": let_default,\n  \"<lifecycle>\": lifecycle_default,\n  \"<log>\": log_default,\n  \"<return>\": return_default,\n  \"<script>\": script_default,\n  \"<server>\": server_default,\n  \"<static>\": static_default,\n  \"<style>\": style_default\n};\n\n// src/translator/visitors/cdata.ts\nvar cdata_default = {\n  translate: {\n    enter(cdata) {\n      throw cdata.buildCodeFrameError(\n        \"CDATA sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/translator/visitors/comment.ts\nvar comment_default = {\n  translate: {\n    exit(comment) {\n      comment.remove();\n    }\n  }\n};\n\n// src/translator/visitors/declaration.ts\nvar declaration_default = {\n  translate: {\n    enter(decl) {\n      throw decl.buildCodeFrameError(\n        \"XML declarations sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/translator/visitors/document-type.ts\nvar document_type_default = {\n  translate: {\n    exit(documentType) {\n      if (isOutputHTML()) {\n        writeTo(documentType)`<!${documentType.node.value}>`;\n      }\n      documentType.remove();\n    }\n  }\n};\n\n// src/translator/visitors/function.ts\nvar import_compiler45 = require(\"@marko/compiler\");\nvar import_babel_utils34 = require(\"@marko/compiler/babel-utils\");\nvar functionIdsBySection = /* @__PURE__ */ new WeakMap();\nvar function_default = {\n  analyze(fn) {\n    const fnRoot = getFnRoot(fn.parentPath);\n    const markoRoot = getMarkoRoot(fnRoot || fn);\n    const isStatic2 = !markoRoot || markoRoot.isMarkoScriptlet({ static: true });\n    if (fnRoot || !isFunction(fn, isStatic2)) return;\n    if (markoRoot && (markoRoot.isMarkoPlaceholder() || markoRoot.isMarkoScriptlet() && markoRoot.node.target === \"server\")) {\n      return;\n    }\n    const { node } = fn;\n    const extra = node.extra ??= {};\n    const name2 = extra.name = fn.node.id?.name || (isMarkoAttribute(markoRoot) ? markoRoot.node.default ? import_compiler45.types.toIdentifier(\n      markoRoot.parentPath.has(\"var\") ? markoRoot.parentPath.get(\"var\") : markoRoot.parentPath.get(\"name\")\n    ) : markoRoot.node.name : import_compiler45.types.isVariableDeclarator(fn.parent) && import_compiler45.types.isIdentifier(fn.parent.id) ? fn.parent.id.name : \"anonymous\");\n    if (isMarkoAttribute(markoRoot) && ((0, import_babel_utils34.isNativeTag)(markoRoot.parentPath) && /^on[A-Z-]/.test(markoRoot.node.name) || isCoreTagName(markoRoot.parentPath, \"script\") || isCoreTagName(markoRoot.parentPath, \"lifecycle\") || isCoreTagName(markoRoot.parentPath, \"for\"))) {\n      return;\n    }\n    const {\n      markoOpts,\n      opts: { filename }\n    } = currentProgramPath.hub.file;\n    const section = getSection(fn);\n    let functionNameCounts = functionIdsBySection.get(section);\n    if (!functionNameCounts) {\n      functionNameCounts = /* @__PURE__ */ new Map();\n      functionIdsBySection.set(section, functionNameCounts);\n    }\n    const index = functionNameCounts.get(name2);\n    let id = \"\";\n    if (index === void 0) {\n      functionNameCounts.set(name2, 0);\n    } else {\n      id = `_${index}`;\n    }\n    extra.section = section;\n    extra.registerId = (0, import_babel_utils34.getTemplateId)(\n      markoOpts,\n      filename,\n      `${section.id}/${name2 + id}`\n    );\n  }\n};\nfunction isFunction(fn, isStatic2) {\n  switch (fn.node.type) {\n    case \"FunctionDeclaration\":\n      return isStatic2 && !fn.node.declare;\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isMarkoAttribute(path4) {\n  return path4 ? path4.isMarkoAttribute() : false;\n}\n\n// src/translator/visitors/import-declaration.ts\nvar import_babel_utils35 = require(\"@marko/compiler/babel-utils\");\nvar import_declaration_default = {\n  analyze(importDecl) {\n    const { node } = importDecl;\n    const { source } = node;\n    const { value } = source;\n    const tagImport = (0, import_babel_utils35.resolveTagImport)(importDecl, value);\n    if (tagImport) {\n      node.extra ??= {};\n      node.extra.tagImport = tagImport;\n      const tags = importDecl.hub.file.metadata.marko.tags;\n      if (!tags.includes(tagImport)) {\n        tags.push(tagImport);\n      }\n    }\n  },\n  translate: {\n    exit(importDecl) {\n      const { node } = importDecl;\n      const { extra } = node;\n      const tagImport = extra?.tagImport;\n      if (tagImport) {\n        node.source.value = tagImport;\n      }\n    }\n  }\n};\n\n// src/translator/visitors/placeholder.ts\nvar import_compiler46 = require(\"@marko/compiler\");\nvar kBinding2 = Symbol(\"placeholder node binding\");\nvar kSiblingText = Symbol(\"placeholder has sibling text\");\nvar placeholder_default = {\n  analyze(placeholder) {\n    const { node } = placeholder;\n    const { confident, computed } = evaluate(node.value);\n    if (!(confident && (node.escape || isVoid2(computed)))) {\n      (node.extra ??= {})[kBinding2] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        getOrCreateSection(placeholder),\n        void 0,\n        node.value.extra\n      );\n      analyzeSiblingText(placeholder);\n    }\n  },\n  translate: {\n    exit(placeholder) {\n      const { node } = placeholder;\n      const { value } = node;\n      const { confident, computed, referencedBindings } = evaluate(value);\n      if (confident && isVoid2(computed)) {\n        placeholder.remove();\n        return;\n      }\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(placeholder);\n      const extra = node.extra || {};\n      const nodeBinding = extra[kBinding2];\n      const canWriteHTML = isHTML || confident && node.escape;\n      const method = canWriteHTML ? node.escape ? \"escapeXML\" : \"toString\" : node.escape ? \"data\" : \"html\";\n      const isStateful = isStatefulReferences(referencedBindings);\n      const siblingText = extra[kSiblingText];\n      if (confident && canWriteHTML) {\n        write2`${getHTMLRuntime()[method](computed)}`;\n      } else {\n        if (siblingText === 1 /* Before */) {\n          if (isHTML && isStateful) {\n            write2`<!>`;\n          }\n          visit(placeholder, 37 /* Replace */);\n        } else if (siblingText === 2 /* After */) {\n          visit(placeholder, 37 /* Replace */);\n        } else {\n          if (!isHTML) write2` `;\n          visit(placeholder, 32 /* Get */);\n        }\n        if (isHTML) {\n          write2`${callRuntime(method, value)}`;\n          if (isStateful) {\n            markNode(placeholder, nodeBinding);\n          }\n        } else {\n          addStatement(\n            \"render\",\n            getSection(placeholder),\n            value.extra?.referencedBindings,\n            import_compiler46.types.expressionStatement(\n              method === \"data\" ? callRuntime(\n                \"data\",\n                import_compiler46.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(nodeBinding),\n                  true\n                ),\n                value\n              ) : callRuntime(\n                \"html\",\n                scopeIdentifier,\n                value,\n                getScopeAccessorLiteral(nodeBinding)\n              )\n            )\n          );\n        }\n      }\n      enterShallow(placeholder);\n      placeholder.remove();\n    }\n  }\n};\nfunction analyzeSiblingText(placeholder) {\n  const placeholderExtra = placeholder.node.extra;\n  let prev = placeholder.getPrevSibling();\n  while (prev.node) {\n    const contentType = getNodeContentType(\n      prev,\n      \"endType\"\n    );\n    if (contentType === null) {\n      prev = prev.getPrevSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 1 /* Before */;\n    } else {\n      break;\n    }\n  }\n  if (!prev.node && import_compiler46.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 1 /* Before */;\n  }\n  let next = placeholder.getNextSibling();\n  while (next.node) {\n    const contentType = getNodeContentType(\n      next,\n      \"startType\"\n    );\n    if (contentType === null) {\n      next = next.getNextSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 2 /* After */;\n    } else {\n      break;\n    }\n  }\n  if (!next.node && import_compiler46.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 2 /* After */;\n  }\n  return placeholderExtra[kSiblingText] = 0 /* None */;\n}\nfunction isVoid2(value) {\n  return value == null || value === false;\n}\n\n// src/translator/visitors/referenced-identifier.ts\nvar import_compiler47 = require(\"@marko/compiler\");\nvar abortIdsByExpressionForSection = /* @__PURE__ */ new WeakMap();\nvar referenced_identifier_default = {\n  migrate(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    switch (name2) {\n      case \"out\":\n        if (import_compiler47.types.isMemberExpression(identifier.parent) && import_compiler47.types.isIdentifier(identifier.parent.property) && identifier.parent.property.name === \"global\") {\n          identifier.parentPath.replaceWith(import_compiler47.types.identifier(\"$global\"));\n        } else {\n          throw identifier.buildCodeFrameError(\n            \"Only `out.global` is supported for compatibility.\"\n          );\n        }\n        break;\n    }\n  },\n  analyze(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    if (name2 === \"$global\" || name2 === \"$signal\") {\n      setReferencesScope(identifier);\n    }\n  },\n  translate(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    switch (name2) {\n      case \"$global\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler47.types.callExpression(importRuntime(\"$global\"), [])\n          );\n        } else {\n          identifier.replaceWith(\n            import_compiler47.types.memberExpression(scopeIdentifier, import_compiler47.types.identifier(\"$global\"))\n          );\n        }\n        break;\n      case \"$signal\":\n        if (isOutputHTML()) {\n          const section = getSection(identifier);\n          if (!section.hasCleanup) {\n            section.hasCleanup = true;\n            const exprRoot = getExprRoot(identifier);\n            const write2 = writeTo(exprRoot);\n            write2`${callRuntime(\"markResumeCleanup\", getScopeIdIdentifier(section))}`;\n          }\n          identifier.replaceWith(\n            import_compiler47.types.callExpression(\n              import_compiler47.types.arrowFunctionExpression(\n                [],\n                import_compiler47.types.blockStatement([\n                  import_compiler47.types.throwStatement(\n                    import_compiler47.types.newExpression(import_compiler47.types.identifier(\"Error\"), [\n                      import_compiler47.types.stringLiteral(\"Cannot use $signal in a server render.\")\n                    ])\n                  )\n                ])\n              ),\n              []\n            )\n          );\n        } else {\n          const section = getSection(identifier);\n          const exprRoot = getExprRoot(identifier);\n          let abortIdsByExpression = abortIdsByExpressionForSection.get(section);\n          let exprId;\n          if (abortIdsByExpression) {\n            exprId = abortIdsByExpression.get(exprRoot);\n          } else {\n            abortIdsByExpression = /* @__PURE__ */ new Map();\n            abortIdsByExpressionForSection.set(section, abortIdsByExpression);\n          }\n          if (!exprId) {\n            exprId = abortIdsByExpression.size;\n            abortIdsByExpression.set(exprRoot, exprId);\n            addStatement(\n              \"render\",\n              section,\n              exprRoot.node.extra?.referencedBindings,\n              import_compiler47.types.expressionStatement(\n                import_compiler47.types.callExpression(importRuntime(\"resetAbortSignal\"), [\n                  scopeIdentifier,\n                  import_compiler47.types.numericLiteral(exprId)\n                ])\n              )\n            );\n          }\n          identifier.replaceWith(\n            import_compiler47.types.callExpression(importRuntime(\"getAbortSignal\"), [\n              scopeIdentifier,\n              import_compiler47.types.numericLiteral(exprId)\n            ])\n          );\n        }\n    }\n  }\n};\n\n// src/translator/visitors/scriptlet.ts\nvar scriptlet_default = {\n  analyze(scriptlet) {\n    if (!scriptlet.node.static) {\n      throw scriptlet.buildCodeFrameError(\n        \"Scriptlets are not supported when using the tags api.\"\n      );\n    }\n    mergeReferences(\n      getOrCreateSection(scriptlet),\n      scriptlet.node,\n      scriptlet.node.body\n    );\n  },\n  translate: {\n    exit(scriptlet) {\n      const { node } = scriptlet;\n      const isHTML = isOutputHTML();\n      if (node.target && node.target !== (isHTML ? \"server\" : \"client\")) {\n        scriptlet.remove();\n        return;\n      }\n      if (isHTML) {\n      } else {\n        traverseReplace(node, \"body\", replaceRegisteredFunctionNode);\n        scriptlet.replaceWithMultiple(node.body);\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/index.ts\nvar import_compiler51 = require(\"@marko/compiler\");\nvar import_babel_utils39 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/visitors/tag/attribute-tag.ts\nvar import_compiler48 = require(\"@marko/compiler\");\nvar import_babel_utils36 = require(\"@marko/compiler/babel-utils\");\nvar attribute_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils36.assertNoVar)(tag);\n      (0, import_babel_utils36.assertNoArgs)(tag);\n      const body = tag.get(\"body\");\n      startSection(body);\n      trackParamsReferences(body, 3 /* param */);\n      if (!(0, import_babel_utils36.findParentTag)(tag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags must be nested within another tag.\");\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/custom-tag.ts\nvar import_compiler49 = require(\"@marko/compiler\");\nvar import_babel_utils37 = require(\"@marko/compiler/babel-utils\");\nvar import_path3 = __toESM(require(\"path\"));\nvar kChildScopeBinding = Symbol(\"custom tag child scope\");\nvar custom_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils37.assertAttributesOrSingleArg)(tag);\n      analyzeAttributeTags(tag);\n      const templateFile = (0, import_babel_utils37.getTagTemplate)(tag);\n      if (!templateFile) {\n        const tagName = getTagName(tag);\n        if (tagName && tag.scope.hasBinding(tagName)) {\n          throw tag.get(\"name\").buildCodeFrameError(\n            `Local variables must be in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n          );\n        }\n        throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n      }\n      const section = getOrCreateSection(tag);\n      const tagBody = tag.get(\"body\");\n      const tagExtra = tag.node.extra ??= {};\n      startSection(tagBody);\n      trackVarReferences(tag, 4 /* derived */);\n      trackParamsReferences(tagBody, 3 /* param */);\n      tagExtra[kChildScopeBinding] = createBinding(\n        \"#childScope\",\n        0 /* dom */,\n        section,\n        void 0,\n        tagExtra\n      );\n      const childFile = (0, import_babel_utils37.loadFileForTag)(tag);\n      if (childFile.opts.filename === tag.hub.file.opts.filename) {\n        mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n      } else {\n        const childProgramExtra = childFile.ast.program.extra;\n        analyzeAttrs(\n          section,\n          tag,\n          childProgramExtra?.domExports.params?.props?.[0]\n        );\n        currentProgramPath.node.extra.hasInteractiveChild = childProgramExtra?.isInteractive || childProgramExtra?.hasInteractiveChild || false;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML(tag);\n      } else {\n        translateDOM(tag);\n      }\n    }\n  }\n};\nfunction translateHTML(tag) {\n  const tagBody = tag.get(\"body\");\n  const { node } = tag;\n  let tagIdentifier;\n  flushInto(tag);\n  writeHTMLResumeStatements(tagBody);\n  if (import_compiler49.types.isStringLiteral(node.name)) {\n    const relativePath = getTagRelativePath(tag);\n    tagIdentifier = isCircularRequest(tag.hub.file, relativePath) ? htmlRendererIdentifier : (0, import_babel_utils37.importDefault)(tag.hub.file, relativePath, getTagName(tag));\n  } else {\n    tagIdentifier = node.name;\n  }\n  const tagVar = node.var;\n  const section = getSection(tag);\n  const childScopeBinding = node.extra[kChildScopeBinding];\n  const peekScopeId = tag.scope.generateUidIdentifier(childScopeBinding?.name);\n  tag.insertBefore(\n    import_compiler49.types.variableDeclaration(\"const\", [\n      import_compiler49.types.variableDeclarator(peekScopeId, callRuntime(\"peekNextScope\"))\n    ])\n  );\n  getSerializedScopeProperties(section).set(\n    getScopeAccessorLiteral(childScopeBinding),\n    callRuntime(\"writeExistingScope\", peekScopeId)\n  );\n  const inputExport = (0, import_babel_utils37.loadFileForTag)(tag)?.ast.program.extra?.domExports?.params?.props?.[0];\n  const { properties, statements } = inputExport ? translateAttrs(tag, inputExport.props) : {\n    properties: [],\n    statements: []\n  };\n  if (node.extra.tagNameNullable) {\n    const contentProp = getTranslatedBodyContentProperty(properties);\n    let contentId = void 0;\n    if (contentProp) {\n      const contentExpression = contentProp.value;\n      contentProp.value = contentId = tag.scope.generateUidIdentifier(\"content\");\n      const [contentPath] = tag.insertBefore(\n        import_compiler49.types.variableDeclaration(\"const\", [\n          import_compiler49.types.variableDeclarator(\n            contentId,\n            // TODO: only register if needed (child template analysis)\n            contentExpression\n          )\n        ])\n      );\n      contentPath.skip();\n    }\n    let renderTagExpr = callExpression(\n      tagIdentifier,\n      propsToExpression(properties)\n    );\n    if (tagVar) {\n      translateVar(tag, import_compiler49.types.unaryExpression(\"void\", import_compiler49.types.numericLiteral(0)), \"let\");\n      renderTagExpr = import_compiler49.types.assignmentExpression(\"=\", tagVar, renderTagExpr);\n    }\n    statements.push(\n      import_compiler49.types.ifStatement(\n        tagIdentifier,\n        import_compiler49.types.expressionStatement(renderTagExpr),\n        contentId && callStatement(contentId)\n      )\n    );\n  } else if (tagVar) {\n    translateVar(\n      tag,\n      callExpression(\n        tagIdentifier,\n        propsToExpression(properties),\n        callRuntime(\n          \"register\",\n          import_compiler49.types.arrowFunctionExpression([], import_compiler49.types.blockStatement([])),\n          import_compiler49.types.stringLiteral(\n            getResumeRegisterId(\n              section,\n              node.var.extra?.binding,\n              // TODO: node.var is not always an identifier.\n              \"var\"\n            )\n          ),\n          getScopeIdIdentifier(section)\n        )\n      )\n    );\n    setForceResumeScope(section);\n  } else {\n    statements.push(\n      callStatement(tagIdentifier, propsToExpression(properties))\n    );\n  }\n  for (const replacement of tag.replaceWithMultiple(statements)) {\n    replacement.skip();\n  }\n}\nfunction translateDOM(tag) {\n  const tagSection = getSection(tag);\n  const { node } = tag;\n  const extra = node.extra;\n  const childScopeBinding = extra[kChildScopeBinding];\n  const write2 = writeTo(tag);\n  const { file } = tag.hub;\n  const tagName = import_compiler49.types.isIdentifier(node.name) ? node.name.name : import_compiler49.types.isStringLiteral(node.name) ? node.name.value : \"tag\";\n  const relativePath = getTagRelativePath(tag);\n  const childFile = (0, import_babel_utils37.loadFileForTag)(tag);\n  const childExports = childFile.ast.program.extra.domExports;\n  const tagIdentifier = importOrSelfReferenceName(\n    file,\n    relativePath,\n    childExports.setup,\n    tagName\n  );\n  const inputExport = childExports.params?.props?.[0];\n  if (inputExport) {\n    writeAttrsToExports(tag, inputExport, `${getTagName(tag) || \"tag\"}_input`, {\n      circular: childFile.opts.filename === file.opts.filename,\n      tagSection,\n      relativePath,\n      childScopeBinding\n    });\n  }\n  write2`${(0, import_babel_utils37.importNamed)(file, relativePath, childExports.template, `${tagName}_template`)}`;\n  injectWalks(\n    tag,\n    (0, import_babel_utils37.importNamed)(file, relativePath, childExports.walks, `${tagName}_walks`)\n  );\n  if (node.var) {\n    const source = initValue(\n      // TODO: support destructuring\n      node.var.extra.binding\n    );\n    source.register = true;\n    source.buildAssignment = (_valueSection, value) => {\n      return import_compiler49.types.callExpression(importRuntime(\"tagVarSignalChange\"), [\n        createScopeReadExpression(source.section, childScopeBinding),\n        value\n      ]);\n    };\n    addStatement(\n      \"render\",\n      tagSection,\n      void 0,\n      import_compiler49.types.expressionStatement(\n        callRuntime(\n          \"setTagVar\",\n          scopeIdentifier,\n          getScopeAccessorLiteral(childScopeBinding),\n          source.identifier\n        )\n      )\n    );\n  }\n  addStatement(\n    \"render\",\n    tagSection,\n    void 0,\n    import_compiler49.types.expressionStatement(\n      import_compiler49.types.callExpression(tagIdentifier, [\n        createScopeReadExpression(tagSection, childScopeBinding)\n      ])\n    )\n  );\n  tag.remove();\n}\nfunction getTagRelativePath(tag) {\n  const {\n    node,\n    hub: { file }\n  } = tag;\n  let relativePath;\n  if (import_compiler49.types.isStringLiteral(node.name)) {\n    const template = (0, import_babel_utils37.getTagTemplate)(tag);\n    relativePath = template && (0, import_babel_utils37.resolveRelativePath)(file, template);\n  } else if (node.extra?.tagNameImported) {\n    relativePath = node.extra.tagNameImported;\n  }\n  if (!relativePath) {\n    const tagName = getTagName(tag);\n    if (tagName && tag.scope.hasBinding(tagName)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        `Local variables must be in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n      );\n    }\n    throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n  }\n  return relativePath;\n}\nfunction analyzeAttrs(section, tag, templateExport) {\n  if (!templateExport) {\n    dropReferences(getAllTagReferenceNodes(tag.node));\n    return;\n  }\n  if (!templateExport.props || tag.node.arguments?.length) {\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n    return;\n  }\n  const attrTagLookup = analyzeAttributeTags(tag);\n  const seen = /* @__PURE__ */ new Set();\n  if (attrTagLookup) {\n    const nodeReferencesByGroup = /* @__PURE__ */ new Map();\n    const analyzeDynamicChildGroup = (group, child) => {\n      const referenceNodes = getAllTagReferenceNodes(child.node);\n      const groupReferences = nodeReferencesByGroup.get(group);\n      if (groupReferences) {\n        groupReferences.referenceNodes = groupReferences.referenceNodes.concat(referenceNodes);\n      } else {\n        nodeReferencesByGroup.set(group, {\n          firstTag: child,\n          referenceNodes\n        });\n      }\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n    for (const child of attrTags2) {\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils37.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExports = templateExport.props[attrTagMeta.name];\n          if (childAttrExports) {\n            if (childAttrExports.props && !attrTagMeta.dynamic) {\n              analyzeAttrs(section, child, childAttrExports);\n            } else {\n              analyzeDynamicChildGroup(attrTagMeta.group, child);\n            }\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        } else {\n          const group = child.node.extra.attributeTagGroup;\n          let childUsesGroupProp = false;\n          for (const name2 of group) {\n            if (templateExport.props[attrTagLookup[name2].name]) {\n              childUsesGroupProp = true;\n              break;\n            }\n          }\n          if (childUsesGroupProp) {\n            analyzeDynamicChildGroup(group, child);\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        }\n      }\n    }\n    for (const { firstTag, referenceNodes } of nodeReferencesByGroup.values()) {\n      mergeReferences(section, firstTag.node, referenceNodes);\n    }\n  }\n  const { attributes } = tag.node;\n  let spreadReferenceNodes;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler49.types.isMarkoAttribute(attr2)) {\n      if (seen.has(attr2.name) || !templateExport.props[attr2.name]) {\n        dropReferences(attr2.value);\n        continue;\n      }\n      seen.add(attr2.name);\n    }\n    if (spreadReferenceNodes) {\n      spreadReferenceNodes.push(attr2.value);\n    } else if (import_compiler49.types.isMarkoSpreadAttribute(attr2)) {\n      spreadReferenceNodes = [attr2.value];\n    }\n  }\n  if (spreadReferenceNodes) {\n    mergeReferences(section, tag.node, spreadReferenceNodes);\n  }\n}\nfunction writeAttrsToExports(tag, templateExport, importAlias, info) {\n  if (tag.node.arguments?.length) {\n    const [arg] = tag.node.arguments;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    addValue(\n      info.tagSection,\n      // technically this should be `arg.extra?.referencedBindings`\n      // but we should probably ensure all other references are dropped in this case before we do that.\n      tag.node.extra?.referencedBindings,\n      identifierToSignal(tagInputIdentifier),\n      import_compiler49.types.isSpreadElement(arg) ? import_compiler49.types.memberExpression(arg.argument, import_compiler49.types.numericLiteral(0), true) : arg,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding),\n      callRuntime(\n        \"inChild\",\n        getScopeAccessorLiteral(info.childScopeBinding),\n        import_compiler49.types.identifier(tagInputIdentifier.name)\n      )\n    );\n    return;\n  }\n  if (!templateExport.props || info.circular) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    const translatedAttrs = translateAttrs(tag);\n    if (translatedAttrs.statements.length) {\n      addStatement(\n        \"render\",\n        info.tagSection,\n        referencedBindings,\n        translatedAttrs.statements\n      );\n    }\n    let translatedProps = propsToExpression(translatedAttrs.properties);\n    if ((0, import_babel_utils37.isAttributeTag)(tag)) {\n      translatedProps = callRuntime(\"attrTag\", translatedProps);\n    }\n    addValue(\n      info.tagSection,\n      referencedBindings,\n      identifierToSignal(tagInputIdentifier),\n      translatedProps,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding),\n      callRuntime(\n        \"inChild\",\n        getScopeAccessorLiteral(info.childScopeBinding),\n        import_compiler49.types.identifier(tagInputIdentifier.name)\n      )\n    );\n    return;\n  }\n  const seen = /* @__PURE__ */ new Set();\n  const attrTagLookup = analyzeAttributeTags(tag);\n  if (attrTagLookup) {\n    const attrTags2 = tag.get(\"attributeTags\");\n    const statementsByGroup = /* @__PURE__ */ new Map();\n    const translateDynamicAttrTagChildInGroup = (group, index) => {\n      const child = attrTags2[index];\n      let statements = statementsByGroup.get(group)?.statements;\n      if (!statements) {\n        statements = [];\n        statementsByGroup.set(group, {\n          referencedBindings: child.node.extra?.referencedBindings,\n          statements\n        });\n      }\n      return addDynamicAttrTagStatements(\n        attrTags2,\n        index,\n        attrTagLookup,\n        statements,\n        templateExport.props\n      );\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils37.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExport = templateExport.props[attrTagMeta.name];\n          if (childAttrExport) {\n            if (attrTagMeta.dynamic) {\n              i = translateDynamicAttrTagChildInGroup(attrTagMeta.group, i);\n            } else {\n              writeAttrsToExports(\n                child,\n                childAttrExport,\n                `${importAlias}_${attrTagMeta.name}`,\n                info\n              );\n            }\n          }\n        } else if (child.node.extra?.attributeTagGroup) {\n          i = translateDynamicAttrTagChildInGroup(\n            child.node.extra.attributeTagGroup,\n            i\n          );\n        }\n      }\n    }\n    for (const [\n      group,\n      { referencedBindings, statements }\n    ] of statementsByGroup) {\n      const decls = [];\n      for (const name2 of group) {\n        const attrTagMeta = attrTagLookup[name2];\n        const childAttrExports = templateExport.props[attrTagMeta.name];\n        if (!childAttrExports) continue;\n        const attrExportIdentifier = importOrSelfReferenceName(\n          tag.hub.file,\n          info.relativePath,\n          childAttrExports.id,\n          `${importAlias}_${attrTagMeta.name}`\n        );\n        decls.push(import_compiler49.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta)));\n        addValue(\n          info.tagSection,\n          referencedBindings,\n          identifierToSignal(attrExportIdentifier),\n          getAttrTagIdentifier(attrTagMeta),\n          createScopeReadExpression(info.tagSection, info.childScopeBinding),\n          callRuntime(\n            \"inChild\",\n            getScopeAccessorLiteral(info.childScopeBinding),\n            import_compiler49.types.identifier(attrExportIdentifier.name)\n          )\n        );\n      }\n      addStatement(\"render\", info.tagSection, referencedBindings, [\n        import_compiler49.types.variableDeclaration(\"let\", decls),\n        ...statements\n      ]);\n    }\n  }\n  const bodySection = tag.node.body.extra?.section;\n  if (bodySection && !seen.has(\"content\")) {\n    seen.add(\"content\");\n    if (templateExport.props.content) {\n      const contentExportIdentifier = (0, import_babel_utils37.importNamed)(\n        tag.hub.file,\n        info.relativePath,\n        templateExport.props.content.id,\n        `${importAlias}_content`\n      );\n      addValue(\n        info.tagSection,\n        void 0,\n        // TODO: pretty sure content needs to have the reference group of it's param defaults.\n        identifierToSignal(contentExportIdentifier),\n        import_compiler49.types.callExpression(import_compiler49.types.identifier(bodySection.name), [scopeIdentifier]),\n        createScopeReadExpression(info.tagSection, info.childScopeBinding),\n        callRuntime(\n          \"inChild\",\n          getScopeAccessorLiteral(info.childScopeBinding),\n          import_compiler49.types.identifier(contentExportIdentifier.name)\n        )\n      );\n    }\n  }\n  const { attributes } = tag.node;\n  const staticAttrs = [];\n  let spreadProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler49.types.isMarkoAttribute(attr2)) {\n      const childAttrExports = templateExport.props[attr2.name];\n      if (!childAttrExports || seen.has(attr2.name)) continue;\n      seen.add(attr2.name);\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n        continue;\n      }\n      staticAttrs.push(attr2);\n    } else if (spreadProps) {\n      spreadProps.push(import_compiler49.types.spreadElement(attr2.value));\n    } else {\n      spreadProps = [import_compiler49.types.spreadElement(attr2.value)];\n    }\n  }\n  for (const attr2 of staticAttrs.reverse()) {\n    const childAttrExports = templateExport.props[attr2.name];\n    const attrExportIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      childAttrExports.id,\n      `${importAlias}_${attr2.name}`\n    );\n    addValue(\n      info.tagSection,\n      attr2.value.extra?.referencedBindings,\n      identifierToSignal(attrExportIdentifier),\n      attr2.value,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding),\n      callRuntime(\n        \"inChild\",\n        getScopeAccessorLiteral(info.childScopeBinding),\n        import_compiler49.types.identifier(attrExportIdentifier.name)\n      )\n    );\n  }\n  const missing = new Set(Object.keys(templateExport.props));\n  for (const name2 of seen) missing.delete(name2);\n  if (missing.size) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    let getMissingPropValue = buildUndefined2;\n    if (spreadProps) {\n      const spreadId = tag.scope.generateUidIdentifier(`${importAlias}_spread`);\n      spreadProps.reverse();\n      getMissingPropValue = (name2) => toMemberExpression(spreadId, name2);\n      addStatement(\"render\", info.tagSection, referencedBindings, [\n        import_compiler49.types.variableDeclaration(\"const\", [\n          import_compiler49.types.variableDeclarator(spreadId, propsToExpression(spreadProps))\n        ])\n      ]);\n    }\n    for (const name2 of missing) {\n      const childAttrExports = templateExport.props[name2];\n      const attrExportIdentifier = importOrSelfReferenceName(\n        tag.hub.file,\n        info.relativePath,\n        childAttrExports.id,\n        `${importAlias}_${name2}`\n      );\n      addValue(\n        info.tagSection,\n        referencedBindings,\n        identifierToSignal(attrExportIdentifier),\n        getMissingPropValue(name2),\n        createScopeReadExpression(info.tagSection, info.childScopeBinding),\n        callRuntime(\n          \"inChild\",\n          getScopeAccessorLiteral(info.childScopeBinding),\n          import_compiler49.types.identifier(attrExportIdentifier.name)\n        )\n      );\n    }\n  }\n}\nfunction importOrSelfReferenceName(file, request, name2, nameHint) {\n  if (isCircularRequest(file, request)) {\n    return import_compiler49.types.identifier(name2);\n  }\n  return (0, import_babel_utils37.importNamed)(file, request, name2, nameHint);\n}\nfunction isCircularRequest(file, request) {\n  const { filename } = file.opts;\n  return request === filename || request[0] === \".\" && import_path3.default.resolve(filename, \"..\", request) === filename;\n}\nfunction callStatement(id, ...args) {\n  return import_compiler49.types.expressionStatement(callExpression(id, ...args));\n}\nfunction callExpression(id, ...args) {\n  return import_compiler49.types.callExpression(id, args.filter(Boolean));\n}\nfunction identifierToSignal(identifier) {\n  return {\n    identifier,\n    hasDownstreamIntersections: always\n  };\n}\nfunction buildUndefined2() {\n  return import_compiler49.types.unaryExpression(\"void\", import_compiler49.types.numericLiteral(0));\n}\nfunction always() {\n  return true;\n}\n\n// src/translator/visitors/tag/dynamic-tag.ts\nvar import_compiler50 = require(\"@marko/compiler\");\nvar import_babel_utils38 = require(\"@marko/compiler/babel-utils\");\nvar kDOMBinding = Symbol(\"dynamic tag dom binding\");\nvar dynamic_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils38.assertAttributesOrArgs)(tag);\n      analyzeAttributeTags(tag);\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      const tagBody = tag.get(\"body\");\n      const domBinding = tagExtra[kDOMBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section,\n        void 0,\n        tagExtra\n      );\n      startSection(tagBody);\n      trackVarReferences(tag, 4 /* derived */);\n      trackParamsReferences(tagBody, 3 /* param */);\n      mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n      addReadToExpression(tag, domBinding);\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag, 37 /* Replace */);\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const extra = node.extra;\n      const nodeRef2 = extra[kDOMBinding];\n      const section = getSection(tag);\n      const isClassAPI = extra.featureType === \"class\";\n      let tagExpression = node.name;\n      if (import_compiler50.types.isStringLiteral(tagExpression)) {\n        tagExpression = (0, import_babel_utils38.importDefault)(\n          tag.hub.file,\n          getTagRelativePath(tag),\n          tagExpression.value\n        );\n      }\n      if (isClassAPI) {\n        if (isOutputHTML()) {\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler50.types.expressionStatement(\n              import_compiler50.types.callExpression(\n                (0, import_babel_utils38.importNamed)(tag.hub.file, getCompatRuntimeFile(), \"s\"),\n                [\n                  import_compiler50.types.identifier(tagExpression.name),\n                  import_compiler50.types.stringLiteral((0, import_babel_utils38.loadFileForTag)(tag).metadata.marko.id)\n                ]\n              )\n            )\n          );\n        } else {\n          currentProgramPath.pushContainer(\n            \"body\",\n            import_compiler50.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                import_compiler50.types.stringLiteral((0, import_babel_utils38.loadFileForTag)(tag).metadata.marko.id),\n                import_compiler50.types.identifier(tagExpression.name)\n              )\n            )\n          );\n        }\n      }\n      const { properties, statements } = translateAttrs(\n        tag,\n        void 0,\n        void 0,\n        isClassAPI ? \"renderBody\" : \"content\"\n      );\n      const args = [];\n      let hasMultipleArgs = false;\n      if (node.arguments?.length) {\n        args.push(...node.arguments);\n        if (properties.length) {\n          hasMultipleArgs = true;\n          args.push(propsToExpression(properties));\n        } else {\n          hasMultipleArgs = node.arguments.length > 1 || import_compiler50.types.isSpreadElement(node.arguments[0]);\n        }\n      } else {\n        const contentProp = getTranslatedBodyContentProperty(properties);\n        if (contentProp) {\n          properties.splice(properties.indexOf(contentProp), 1);\n          args.push(propsToExpression(properties), contentProp.value);\n        } else {\n          args.push(propsToExpression(properties));\n        }\n      }\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        const write2 = writeTo(tag);\n        if (node.var) {\n          if (!hasMultipleArgs && args.length === 1) {\n            args.push(import_compiler50.types.unaryExpression(\"void\", import_compiler50.types.numericLiteral(0)));\n          }\n          args.push(\n            callRuntime(\n              \"register\",\n              import_compiler50.types.arrowFunctionExpression([], import_compiler50.types.blockStatement([])),\n              import_compiler50.types.stringLiteral(\n                getResumeRegisterId(\n                  section,\n                  node.var.extra?.binding,\n                  // TODO: node.var is not always an identifier.\n                  \"var\"\n                )\n              ),\n              getScopeIdIdentifier(section)\n            )\n          );\n        }\n        const dynamicScopeIdentifier = currentProgramPath.scope.generateUidIdentifier(\"dynamicScope\");\n        const dynamicTagExpr = hasMultipleArgs ? callRuntime(\n          \"dynamicTagArgs\",\n          dynamicScopeIdentifier,\n          tagExpression,\n          import_compiler50.types.arrayExpression(args)\n        ) : callRuntime(\n          \"dynamicTagInput\",\n          dynamicScopeIdentifier,\n          tagExpression,\n          ...args\n        );\n        statements.push(\n          import_compiler50.types.variableDeclaration(\"const\", [\n            import_compiler50.types.variableDeclarator(\n              dynamicScopeIdentifier,\n              callRuntime(\"peekNextScope\")\n            )\n          ])\n        );\n        statements.push(\n          node.var ? import_compiler50.types.variableDeclaration(\"const\", [\n            import_compiler50.types.variableDeclarator(node.var, dynamicTagExpr)\n          ]) : import_compiler50.types.expressionStatement(dynamicTagExpr)\n        );\n        write2`${callRuntime(\n          \"markResumeControlEnd\",\n          getScopeIdIdentifier(section),\n          getScopeAccessorLiteral(nodeRef2)\n        )}`;\n        getSerializedScopeProperties(section).set(\n          import_compiler50.types.stringLiteral(\n            getScopeAccessorLiteral(nodeRef2).value + \"!\" /* ConditionalScope */\n          ),\n          callRuntime(\"writeExistingScope\", dynamicScopeIdentifier)\n        );\n        getSerializedScopeProperties(section).set(\n          import_compiler50.types.stringLiteral(\n            getScopeAccessorLiteral(nodeRef2).value + \"(\" /* ConditionalRenderer */\n          ),\n          callRuntime(\n            \"normalizeDynamicRenderer\",\n            import_compiler50.types.isIdentifier(tagExpression) ? import_compiler50.types.identifier(tagExpression.name) : tagExpression\n          )\n        );\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      } else {\n        const section2 = getSection(tag);\n        const bodySection = getSectionForBody(tag.get(\"body\"));\n        const signal = getSignal(section2, nodeRef2, \"dynamicTagName\");\n        signal.build = () => {\n          return callRuntime(\n            \"conditional\",\n            getScopeAccessorLiteral(nodeRef2),\n            getSignalFn(signal, [scopeIdentifier]),\n            buildSignalIntersections(signal)\n          );\n        };\n        signal.hasDownstreamIntersections = () => true;\n        addValue(\n          section2,\n          node.name.extra?.referencedBindings,\n          signal,\n          bodySection ? import_compiler50.types.logicalExpression(\n            \"||\",\n            tagExpression,\n            import_compiler50.types.callExpression(import_compiler50.types.identifier(bodySection.name), [\n              scopeIdentifier\n            ])\n          ) : tagExpression\n        );\n        if (tag.node.var) {\n          const childScopeLiteral = import_compiler50.types.stringLiteral(\n            getScopeAccessorLiteral(extra[kDOMBinding]).value + \"!\" /* ConditionalScope */\n          );\n          const source = initValue(\n            // TODO: support destructuring\n            tag.node.var.extra.binding\n          );\n          source.register = true;\n          source.buildAssignment = (valueSection, value) => {\n            return import_compiler50.types.callExpression(importRuntime(\"tagVarSignalChange\"), [\n              import_compiler50.types.memberExpression(\n                getScopeExpression(source.section, valueSection),\n                childScopeLiteral,\n                true\n              ),\n              value\n            ]);\n          };\n          addStatement(\n            \"render\",\n            section2,\n            nodeRef2,\n            import_compiler50.types.expressionStatement(\n              callRuntime(\n                \"setTagVar\",\n                scopeIdentifier,\n                childScopeLiteral,\n                source.identifier\n              )\n            )\n          );\n        }\n        if (args.length) {\n          const argsOrInput = hasMultipleArgs ? import_compiler50.types.arrayExpression(args) : args[0];\n          const attrsGetter = import_compiler50.types.arrowFunctionExpression(\n            [],\n            statements.length ? import_compiler50.types.blockStatement(\n              statements.concat(import_compiler50.types.returnStatement(argsOrInput))\n            ) : argsOrInput\n          );\n          const id = currentProgramPath.scope.generateUidIdentifier(\n            tag.get(\"name\").toString() + \"_input\"\n          );\n          let added = false;\n          addValue(\n            section2,\n            node.extra?.referencedBindings,\n            {\n              get identifier() {\n                if (!added) {\n                  currentProgramPath.pushContainer(\n                    \"body\",\n                    import_compiler50.types.variableDeclaration(\"const\", [\n                      import_compiler50.types.variableDeclarator(\n                        id,\n                        callRuntime(\n                          \"dynamicTagAttrs\",\n                          getScopeAccessorLiteral(nodeRef2),\n                          bodySection && import_compiler50.types.identifier(bodySection.name),\n                          hasMultipleArgs && import_compiler50.types.numericLiteral(1)\n                        )\n                      )\n                    ])\n                  );\n                  added = true;\n                }\n                return id;\n              },\n              hasDownstreamIntersections: () => true\n            },\n            attrsGetter\n          );\n        }\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/index.ts\nvar tag_default = {\n  transform: {\n    enter(tag) {\n      const attrs2 = tag.get(\"attributes\");\n      for (let i = 0; i < attrs2.length; i++) {\n        const attr2 = attrs2[i];\n        if (import_compiler51.types.isMarkoAttribute(attr2.node) && attr2.node.bound) {\n          attr2.node.bound = false;\n          const changeValue = getChangeHandler(tag, attr2);\n          if (changeValue === null) {\n            throw attr2.buildCodeFrameError(\n              \"Attributes may only be bound to identifiers or member expressions\"\n            );\n          }\n          tag.node.attributes.splice(\n            ++i,\n            0,\n            import_compiler51.types.markoAttribute(attr2.node.name + \"Change\", changeValue)\n          );\n          tag.scope.crawl();\n        }\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils39.getTagDef)(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        enter(hook, tag);\n        return;\n      }\n      if (type === 0 /* NativeTag */) {\n        native_tag_default.analyze.enter(tag);\n        return;\n      }\n      switch (type) {\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.analyze.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.analyze.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const hook = (0, import_babel_utils39.getTagDef)(tag)?.analyzer?.hook;\n      if (hook) {\n        exit(hook, tag);\n        return;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils39.getTagDef)(tag);\n      const extra = tag.node.extra;\n      if (tagDef?.translator) {\n        if (tagDef.translator.path) {\n          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);\n        }\n        enter(tagDef.translator.hook, tag);\n        return;\n      }\n      for (const attr2 of tag.get(\"attributes\")) {\n        if (attr2.isMarkoAttribute()) {\n          if (attr2.node.arguments) {\n            throw attr2.buildCodeFrameError(\n              `Unsupported arguments on the \\`${attr2.node.name}\\` attribute.`\n            );\n          }\n          if (attr2.node.modifier) {\n            if ((0, import_babel_utils39.isNativeTag)(attr2.parentPath)) {\n              attr2.node.name += `:${attr2.node.modifier}`;\n            } else {\n              throw attr2.buildCodeFrameError(\n                `Unsupported modifier \\`${attr2.node.modifier}\\`.`\n              );\n            }\n          }\n        }\n      }\n      if (extra.tagNameDynamic && extra.tagNameNullable && !tag.get(\"name\").isIdentifier() && isOutputHTML()) {\n        const tagNameId = tag.scope.generateUidIdentifier(\"tagName\");\n        const [tagNameVarPath] = tag.insertBefore(\n          import_compiler51.types.variableDeclaration(\"const\", [\n            import_compiler51.types.variableDeclarator(tagNameId, tag.node.name)\n          ])\n        );\n        tagNameVarPath.skip();\n        tag.set(\"name\", tagNameId);\n      }\n      switch (extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const translator = (0, import_babel_utils39.getTagDef)(tag)?.translator;\n      if (translator) {\n        exit(translator.hook, tag);\n        return;\n      }\n      switch (tag.node.extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.exit(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.exit(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.exit(tag);\n          break;\n      }\n    }\n  }\n};\nfunction getChangeHandler(tag, attr2) {\n  if (import_compiler51.types.isIdentifier(attr2.node.value)) {\n    const valueId = tag.scope.generateUidIdentifier(\n      \"new_\" + attr2.node.value.name\n    );\n    return import_compiler51.types.arrowFunctionExpression(\n      [valueId],\n      import_compiler51.types.blockStatement([\n        import_compiler51.types.expressionStatement(\n          import_compiler51.types.assignmentExpression(\"=\", import_compiler51.types.cloneNode(attr2.node.value), valueId)\n        )\n      ])\n    );\n  } else if (import_compiler51.types.isMemberExpression(attr2.node.value)) {\n    const prop = attr2.node.value.property;\n    if (import_compiler51.types.isPrivateName(prop)) return null;\n    if (import_compiler51.types.isIdentifier(prop)) {\n      return import_compiler51.types.memberExpression(\n        import_compiler51.types.cloneNode(attr2.node.value.object),\n        import_compiler51.types.identifier(prop.name + \"Change\")\n      );\n    } else {\n      return import_compiler51.types.memberExpression(\n        import_compiler51.types.cloneNode(attr2.node.value.object),\n        import_compiler51.types.binaryExpression(\"+\", import_compiler51.types.cloneNode(prop), import_compiler51.types.stringLiteral(\"Change\")),\n        true\n      );\n    }\n  }\n  return null;\n}\n\n// src/translator/visitors/text.ts\nvar import_compiler52 = require(\"@marko/compiler\");\nvar text_default = {\n  translate: {\n    exit(text) {\n      writeTo(text)`${text.node.value}`;\n      enterShallow(text);\n      text.remove();\n    }\n  }\n};\n\n// src/translator/index.ts\nvar visitors = extractVisitors({\n  Program: program_default,\n  Function: function_default,\n  ReferencedIdentifier: referenced_identifier_default,\n  ImportDeclaration: import_declaration_default,\n  MarkoDocumentType: document_type_default,\n  MarkoDeclaration: declaration_default,\n  MarkoCDATA: cdata_default,\n  MarkoText: text_default,\n  MarkoTag: tag_default,\n  MarkoPlaceholder: placeholder_default,\n  MarkoScriptlet: scriptlet_default,\n  MarkoComment: comment_default\n});\nvar tagDiscoveryDirs = [\"tags\"];\nvar preferAPI = \"tags\";\nvar { transform, analyze, translate } = visitors;\nvar taglibs = [\n  [\n    __dirname,\n    {\n      ...core_default,\n      migrate: visitors.migrate\n    }\n  ]\n];\nfunction getRuntimeEntryFiles(output, optimize) {\n  return [\n    `${runtime_info_default.name}${optimize ? \"\" : \"/debug\"}/${output === \"html\" ? \"html\" : \"dom\"}`\n  ];\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  analyze,\n  getRuntimeEntryFiles,\n  internalEntryBuilder,\n  preferAPI,\n  tagDiscoveryDirs,\n  taglibs,\n  transform,\n  translate\n});\n"],"names":["mod","__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__copyProps","to","from","except","desc","key","call","get","enumerable","__toESM","isNodeMode","target","__esModule","value","translator_exports","__export","all","name2","analyze","getRuntimeEntryFiles","internalEntryBuilder","entry_builder_default","preferAPI","tagDiscoveryDirs","taglibs","transform","translate","module","exports","runtime_info_default","name","require","taglibId","import_compiler","import_babel_utils","assertNoSpreadAttrs","tag","attr2","isMarkoSpreadAttribute","buildCodeFrameError","node","assertNoBodyContent","body","length","attrs_default","migrate","assertNoArgs","assertNoParams","assertNoAttributes","assertNoAttributeTags","diagnosticDeprecate","label","fix","tagVar","var","type","remove","constTag","types","markoTag","stringLiteral","markoAttribute","identifier","markoTagBody","replaceWith","attributes","autocomplete","displayText","description","snippet","import_compiler2","import_babel_utils2","client_default","parse","hub","file","rawValue","code","replace","trim","start","parseStatements","isBlockStatement","markoScriptlet","parseOptions","statement","rawOpenTag","descriptionMoreURL","import_compiler24","import_babel_utils12","import_babel_utils3","evaluate","extra","confident","computed","computeNode","import_compiler22","import_babel_utils11","import_path","bindingHasDownstreamExpressions","binding","downstreamExpressions","size","alias","aliases","propertyAliases","values","import_compiler3","import_babel_utils4","kState","Symbol","build","entryFile","state","path","imports","map","it","importDeclaration","init","unshift","importSpecifier","markoOpts","optimize","push","expressionStatement","callExpression","visit","visitChild","analyzedTags","metadata","marko","resolveRelativePath","opts","filename","hasInteractiveChild","isInteractive","import_compiler7","forEachIdentifier","cb","prop","properties","left","argument","el","elements","getExprRoot","path4","curPath","isMarko","parentPath","getFnRoot","isProgram","isFunctionExpression","isStatefulReferences","referencedBindings","Array","isArray","isStatefulBinding","ref","upstreamExpression","data","item","forEach","i","find","findSorted","compare","max","pos","mid","cur","compareResult","addSorted","len","result","next","joinRepeatable","a","b","import_compiler5","import_babel_utils7","import_babel_utils5","getTagName","isCoreTag","isMarkoTag","tagDef","getTagDef","isCoreTagName","isConditionTag","createProgramState","map2","WeakMap","currentProgramPath","set","createSectionState","section","arrayOfSectionData","id","import_compiler4","import_babel_utils6","withPreviousLocation","newNode","originalNode","loc","end","MARKO_FILE_REG","TAG_NAME_IDENTIFIER_REG","analyzeTagNameType","tagNameType","isStringLiteral","isNativeTag","bindingName","bindingIdentifier","scope","getBinding","test","tagIdentifier","analyzeExpressionTagName","tagNameNullable","childFile","loadFileForTag","ast","program","featureType","needsCompat","pending","tagNameImported","nullable","pop","isConditionalExpression","alternate","isLogicalExpression","operator","isAssignmentExpression","isBinaryExpression","isTemplateLiteral","isNullLiteral","isIdentifier","kind","decl","parent","source","specifiers","some","isImportDefaultSpecifier","resolvedImport","resolveTagImport","bindingTag","bindingTagName","tagNameDynamic","startSection","parentSection","getOrCreateSection","sectionNamePath","sectionName","generateUid","toString","programExtra","sections","depth","params","closures","bindings","content","getContentInfo","hasCleanup","attributeTags","getSectionForBody","getSection","currentPath","getScopeIdIdentifier","generateUidIdentifier","getSectionParentIsOwner","setSectionParentIsOwner","_getScopeIdentifier","getScopeIdentifier","ignoreDefault","scopeId","forEachSection","fn","contentInfo","startType","endType","singleChild","endIndex","getNodeContentType","startIndex","extraMember","isAttributeTag","tagSection","isStatefulSection","checkStatefulClosures","immediateOnly","closure","import_compiler6","toPropertyName","numericLiteral","parseInt","toObjectProperty","objectProperty","toMemberExpression","object","optional","optionalMemberExpression","memberExpression","getBindings","Set","getNextBindingId","setNextBindingId","createBinding","upstreamAlias","property","declared","excludeProperties","serialize","Map","export","propBinding","add","trackVarReferences","canonicalUpstreamAlias","getCanonicalBinding","pruned","createBindingsAndTrackReferences","trackParamsReferences","paramsBinding","trackAssignment","assignment","setReferencesScope","fnRoot","referencesScope","lVal","babelBinding","referencePaths","constantViolations","referencePath","trackReference","isUpdateExpression","trackReferencesForBinding","patternBinding","Error","element","root","reference","propPath","isMemberExpression","getMemberExpressionPropString","has","isCallExpression","isEventOrChangeHandler","exprRoot","addReadToExpression","readsByFn","getReadsByFunction","fnExtra","getMergedReferences","mergeReferences","nodes","compareIntersections","lenDelta","bindingUtil","isSuperset","subset","elem","getSourceBindings","derived","sources","crawl","binding2","curBinding","constructor","this","union","aLen","bLen","aIndex","bIndex","aValue","bValue","delta","unionSortedRepeatable","getReadsByExpression","exprExtra","readsByExpression","dropReferences","getAllTagReferenceNodes","referenceNodes","arguments","arg","child","getScopeAccessorLiteral","getMarkoOpts","getReadReplacement","replacement","read","props","pruneBinding","shouldPrune","delete","resolveReferencedBindings","expr","reads","intersectionsBySection","exprReference","resolveExpressionReference","createRead","intersections","intersection","readBinding","readProps","aliasProps","isReferencedExtra","isAssignedBindingExtra","isRegisteredFnExtra","registerId","import_compiler8","import_babel_utils8","stringifyClassObject","NON_DIMENSIONAL","stringifyStyleObject","toDelimitedString","val","delimiter","stringify","curDelimiter","v","part","isEventHandler","getEventHandlerName","slice","toLowerCase","unsafeXMLReg","replaceUnsafeXML","c","escapeXML","str","unsafeScriptReg","escapeScript","unsafeStyleReg","escapeStyle","classAttr","stringAttr","styleAttr","attr","attrAssignment","RegExp","nonVoidAttr","escapeAttrValue","async","KNOWN_SYMBOLS2","symbol","AggregateError","of","ArrayBuffer","isView","Atomics","and","compareExchange","exchange","isLockFree","load","notify","or","store","sub","wait","BigInt","asIntN","asUintN","BigInt64Array","BigUint64Array","Boolean","console","assert","clear","count","countReset","debug","dir","dirxml","error","group","groupCollapsed","groupEnd","info","log","table","time","timeEnd","timeLog","timeStamp","trace","warn","DataView","Date","now","UTC","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","EvalError","Float32Array","Float64Array","Function","globalThis","atob","btoa","clearImmediate","clearInterval","clearTimeout","crypto","getRandomValues","randomUUID","fetch","performance","queueMicrotask","setImmediate","setInterval","setTimeout","structuredClone","URL","URLSearchParams","WritableStream","Int16Array","Int32Array","Int8Array","Intl","Collator","DateTimeFormat","DisplayNames","getCanonicalLocales","ListFormat","Locale","NumberFormat","PluralRules","RelativeTimeFormat","Segmenter","supportedValuesOf","isFinite","isNaN","JSON","groupBy","Math","abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","floor","fround","hypot","imul","log10","log1p","log2","min","pow","random","round","sign","sin","sinh","sqrt","tan","tanh","trunc","Number","isInteger","isSafeInteger","parseFloat","assign","defineProperties","entries","freeze","fromEntries","getOwnPropertyDescriptors","getOwnPropertySymbols","is","isExtensible","isFrozen","isSealed","keys","preventExtensions","seal","setPrototypeOf","Promise","Proxy","RangeError","ReferenceError","Reflect","apply","construct","deleteProperty","ownKeys","String","fromCharCode","fromCodePoint","raw","for","SyntaxError","TypeError","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","URIError","WeakSet","unsafeAttrChars","lastIndex","pureFunctions","importRuntime","output","importStar","getRuntimePath","callRuntime","args","callExpression2","filteredArgs","unaryExpression","filterArguments","includes","leadingComments","getHTMLRuntime","getCompatRuntimeFile","isOutputHTML","modules","import_compiler20","import_compiler19","import_babel_utils10","import_compiler13","import_babel_utils9","getKnownAttrValues","attrs2","import_compiler9","enter","modulePlugin","plugin","isModulePlugin","default","isFunctionPlugin","exit","translateByTarget","html","dom","import_compiler12","import_compiler10","normalizeStringExpression","parts","strs","exprs","curStr","nextIndex","exprLen","expressions","shiftItems","quasis","j","templateLiteral","templateElement","appendLiteral","arr","list","offset","import_compiler11","getWalks","getWalkComment","getSteps","walkCodeToName","enter2","exit2","enterShallow","steps","walks","walkComment","walkString","walkCodes","step","lastIndexOf","current","walk","nCodeString","writeTo","number","toCharString","startCode","rangeSize","multiplier","getWalkString","prefix2","postfix","walkLiteral","join","getWrites","getTrailerWrites","trailer","exprsLen","writes","consumeHTML","trailers","writeResult","trailerResult","sequenceExpression","flushBefore","insertBefore","skip","flushInto","pushContainer","getSectionMeta","writePrefix","writePostfix","setup","getSetup","markNode","returnId","_setReturnId","usedTag","return_default","assertNoVar","assertAllowedAttributes","valueChange","getSerializedScopeProperties","returnId2","variableDeclaration","variableDeclarator","addValue","hasDownstreamIntersections","openTagOnly","import_compiler14","getDeclaredBindingExpression","import_compiler15","createScopeReadPattern","rootDepth","rootPattern","objectPattern","nestedPatterns","propertyKey","propertyValue","isShorthand","pattern","relativeDepth","prev","nestedPattern","getScopeExpression","targetSection","scopeIdentifier","diff","createScopeReadExpression","import_compiler16","simplifyFunction","functionExpression","generator","import_compiler17","toFirstExpressionOrBlock","stmts","isExpressionStatement","expression","toParenthesizedExpressionIfNeeded","blockStatement","parenthesizedExpression","import_compiler18","traverseReplace","container","enter3","VISITOR_KEYS","traverseContains","check","getSignals","getSubscribeBuilder","_setSubscribeBuilder","setSubscriberBuilder","builder","forceResumeScope","_setForceResumeScope","setForceResumeScope","unimplementedBuild","getSignal","generateSignalName","signals","signal","exportName","domExports","render","renderReferencedBindings","effect","effectReferencedBindings","subscribers","subscribe","getSignalFn","buildSignalIntersections","ownerScope","isImmediateOwner","isDynamicClosure","arrowFunctionExpression","initValue","runtimeHelper","valueAccessor","isParamBinding","scopeIdentifier2","valueIdentifier","aliasSignal","getTranslatedExtraArgs","hasTranslatedExtraArgs","emptyExtraArgs","extraArgs","replaceRenderNode","signal2","intersectionExpression","closureEntries","sort","closureSection","closureSignal","hasDynamicSubscribers","arrayExpression","provider","subscriber","p","providerSignal","finalizeSignalArgs","isArrowFunctionExpression","addStatement","usedReferences","statements","addEffectReferences","addRenderReferences","getResumeRegisterId","getTemplateId","usedRegisterIdsBySection","getRegisterUID","used","baseId","writeSignals","sortSignals","value2","effectDeclarator","replaceEffectNode","effectIdentifier","isScopeIdentifier","register","signalDeclarator","signalDeclaration","functionDeclaration","isExpression","exportNamedDeclaration","toReturnedFunction","rawFn","returnStatement","aReferencedBindings","getReferencedBindings","bReferencedBindings","reserve","getMappedId","addHTMLEffectCall","writeHTMLResumeStatements","tagVarIdentifier","allSignals","scopeIdIdentifier","currentSection","signalRefs","accessors","additionalProperties","serializedProperties","accessor","isLiteral","objectExpression","unshiftContainer","replaceAssignedNode","replaceBindingReadNode","replaceRegisteredFunctionNode","buildAssignment","binaryExpression","prefix","right","assignments","resultId","assignmentExpression","registeredFnsForProgram","getRegisteredFnExpression","classProperty","classPrivateProperty","referencedBindingsInFunction","registedFns","dom_default","templateIdentifier","template","walksIdentifier","setupIdentifier","closuresIdentifier","programParamsSignal","forEachSectionReverse","childSection","tagParamsSignal","walks2","writes2","setup2","closures2","getSectionClosuresExpr","renderer","registeredFns","registeredFn","assignmentPattern","stmt","writeRegisteredFns","exportDefaultDeclaration","reverse","import_compiler21","html_default","replaceNode","returnIdentifier","renderContent","isImportDeclaration","isExportDeclaration","isMarkoScriptlet","static","replaceWithMultiple","htmlRendererIdentifier","replaceBindingReadNode2","getRegisteredFnExpression2","registeredFnDeclarations","registeredFnDeclarationsByBody","addRegisteredDeclarations","replaceRegisteredFunctionNode2","previousProgramPath","program_default","mergedReferences","targetExtra","isEffect","additionalReads","concat","name3","section2","bindingReference","numReferences","binding1","sources1","sources2","sourceSection","bindings2","filter","finalizeReferences","buildTemplateExports","isOutputDOM","visitedFiles","resolved","loadFileForImport","req","resolveRelativeToEntry","compatFile","templateExport","exports2","import_compiler23","translateVar","initialValue","const_default","valueAttr","isMarkoAttribute","varBinding","derivation","import_compiler25","import_babel_utils13","debug_default","debuggerStatement","import_babel_utils18","import_compiler29","import_babel_utils17","import_compiler27","import_babel_utils15","getParentTag","import_compiler26","import_babel_utils14","kNativeTagBinding","kSerializeMarker","kGetterId","htmlSelectArgs","getRelatedControllable","tagName","checked","checkedChange","special","helper","attrs","checkedValue","checkedValueChange","open","openChange","native_tag_default","escape","buildError","buildUndefined","hasEventHandlers","hasDynamicAttributes","seen","relatedControllable","spreadReferenceNodes","propName","exclusiveGroups","assertExclusiveControllableGroups","every","tagName2","toIdentifier","tagExtra","nodeRef2","isHTML","write2","getterId","varName","references","getterFnIdentifier","referenceSection","visitAccessor","usedAttrs","maybeStaticAttrs","spreadExpression","skipExpression","spreadProps","skipProps","staticControllable","attr3","spreadElement","staticAttrs","propsToExpression","getUsedAttrs","writeAtStartOfBody","firstAttr","spreadIdentifier","valueReferences","htmlType","ifStatement","selectArgs","kForMarkerBinding","kForScopeStartIndex","kOnlyChildInParent","for_default","isAttrTag","allowAttrs","getForType","tagBody","bodySection","isOnlyChildInParent","parentTag","parentTagName","isStateful","updateExpression","forAttrs","forType","bodyStatements","hasStatefulClosures","keyExpression","singleNodeOptimization","defaultParamNames","in","defaultByParamIndex","requiredParamsIndex","by","existingParam","isFunction","byIdentifier","forTypeToHTMLByRuntime","forScopeIdsIdentifier","forScopesIdentifier","newExpression","conditionalExpression","buildForRuntimeCall","forTypeToDOMRuntime","param","referencedBindings2","loopArgs","getBaseArgsInForTag","controlFlow","forTypeToRuntime","import_compiler28","import_babel_utils16","attrTagToIdentifierLookup","getAttrTagIdentifier","meta","analyzeAttributeTags","attrTags2","lookup","attrTagNodesByName","sampleAttrTagsForControlFlow","createAttrTagMeta","isRepeated","isLoopTag","curGroup","crawlAttrTags","oldMeta","attrTagMeta","dynamic","repeated","controlFlowTag","sampleAttrName","attributeTagGroup","attrTagNodes","hasRepeatedDynamicAttrTags","attrTagNames","conditionRoot","seenBranches","attrTag2","curConditionRoot","getConditionRoot","getPrevSibling","contentProps","translateAttrs","templateExports","contentKey","attrTagLookup","usesExport","addDynamicAttrTagStatements","translatedAttrTag","prevProp","findObjectProperty","contentExpression","isTransparentTag","getNonAttributeTagParent","buildContent","contentProp","getTranslatedBodyContentProperty","index","ifTag","consequentStatements","getConditionTestValue","addAllAttrTagsAsDynamic","nextTag","testValue","alternateStatements","translateIfAttrTag","forTag","translateForAttrTag","isSpreadElement","define_default","translatedAttrs","import_compiler31","import_babel_utils19","effect_default","import_babel_utils20","export_default","import_compiler32","import_babel_utils21","kCommentTagBinding","kGetterId2","html_comment_default","needsBinding","needsGetter","isMarkoPlaceholder","isMarkoText","commentBinding","templateQuasis","templateExpressions","currentQuasi","text","import_compiler33","import_babel_utils22","kGetterId3","html_script_default","bodyPlaceholderNodes","hasBodyPlaceholders","getUsedAttrs2","referencePlaceholder","preserveWhitespace","import_compiler34","import_babel_utils23","kGetterId4","html_style_default","getUsedAttrs3","import_compiler35","import_babel_utils24","id_default","import_compiler37","import_babel_utils25","import_compiler36","kBinding","BRANCHES_LOOKUP","IfTag","assertHasBody","assertHasValueAttribute","assertHasPrecedingCondition","ifAttr","msg","assertOptionalIfAttribute","assertValidCondition","isLast","branches","getBranches","rootTag","rootExtra","mergeReferenceNodes","branchTag","branchBodySection","isRoot","getRoot","getNextSibling","ifScopeIdIdentifier","ifRendererIdentifier","branchHasStatefulClosures","testAttr","curStatement","nullLiteral","consequent","ElseIfTag","ElseTag","isMarkoComment","import_babel_utils26","import_default","import_compiler38","import_babel_utils27","let_default","valueChangeAttr","valueSection","import_compiler39","import_babel_utils28","kRef","lifecycle_default","lifecycleAttrsRef","import_compiler40","import_babel_utils29","log_default","import_compiler41","import_babel_utils30","htmlScriptTagAlternateMsg","script_default","valueFn","isAwaitExpression","seenValueAttr","isFunction2","inlineBody","hasDeclaration","isDeclaration","import_compiler42","import_babel_utils31","server_default","import_compiler43","import_babel_utils32","static_default","import_compiler44","import_babel_utils33","import_magic_string","import_path2","STYLE_EXT_REG","htmlStyleTagAlternateMsg","style_default","ext","exec","sourceMaps","markoText","resolveVirtualDependency","getStart","getEnd","magicString","generateMap","includeContent","toUrl","importPath","virtualPath","basename","importDefaultSpecifier","importDefault","core_default","cdata_default","cdata","comment_default","comment","declaration_default","document_type_default","documentType","import_compiler45","import_babel_utils34","functionIdsBySection","function_default","markoRoot","getMarkoRoot","isStatic2","declare","isVariableDeclarator","functionNameCounts","import_babel_utils35","import_declaration_default","importDecl","tagImport","tags","import_compiler46","kBinding2","kSiblingText","placeholder_default","placeholder","isVoid2","placeholderExtra","contentType","analyzeSiblingText","nodeBinding","canWriteHTML","method","siblingText","import_compiler47","abortIdsByExpressionForSection","referenced_identifier_default","hasBinding","throwStatement","exprId","abortIdsByExpression","scriptlet_default","scriptlet","import_compiler51","import_babel_utils39","import_babel_utils36","attribute_tag_default","findParentTag","import_compiler49","import_babel_utils37","import_path3","kChildScopeBinding","custom_tag_default","assertAttributesOrSingleArg","getTagTemplate","charAt","toUpperCase","childProgramExtra","analyzeAttrs","relativePath","getTagRelativePath","isCircularRequest","childScopeBinding","peekScopeId","inputExport","contentId","contentPath","renderTagExpr","callStatement","translateHTML","childExports","importOrSelfReferenceName","writeAttrsToExports","circular","importNamed","injectWalks","_valueSection","translateDOM","nodeReferencesByGroup","analyzeDynamicChildGroup","groupReferences","firstTag","attrTagName","childAttrExports","childUsesGroupProp","importAlias","tagInputIdentifier","identifierToSignal","translatedProps","statementsByGroup","translateDynamicAttrTagChildInGroup","childAttrExport","decls","attrExportIdentifier","contentExportIdentifier","missing","getMissingPropValue","buildUndefined2","spreadId","request","nameHint","resolve","always","import_compiler50","import_babel_utils38","kDOMBinding","dynamic_tag_default","assertAttributesOrArgs","domBinding","isClassAPI","tagExpression","hasMultipleArgs","splice","indexOf","dynamicScopeIdentifier","dynamicTagExpr","logicalExpression","childScopeLiteral","argsOrInput","attrsGetter","added","tag_default","bound","changeValue","getChangeHandler","hook","analyzer","translator","watchFiles","modifier","tagNameId","tagNameVarPath","valueId","cloneNode","isPrivateName","visitors","visitors2","_name","extractVisitors","Program","ReferencedIdentifier","ImportDeclaration","MarkoDocumentType","MarkoDeclaration","MarkoCDATA","MarkoText","MarkoTag","MarkoPlaceholder","MarkoScriptlet","MarkoComment"],"sourceRoot":""}