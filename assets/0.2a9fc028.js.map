{"version":3,"sources":["webpack:////home/dpiercey/dev/github/marko/website/node_modules/events-light/src/index.js","webpack:////home/dpiercey/dev/github/marko/website/node_modules/events/events.js","webpack:////home/dpiercey/dev/github/marko/website/node_modules/listener-tracker/lib/listener-tracker.js","webpack:////home/dpiercey/dev/github/marko/website/node_modules/marko/components-browser.marko","webpack:///../../src/runtime/RenderResult.js","webpack:///../../../src/runtime/components/Component.js","webpack:///../../../src/runtime/components/ComponentDef.js","webpack:///../../../src/runtime/components/ComponentsContext.js","webpack:///../../../src/runtime/components/GlobalComponentsContext.js","webpack:///../../../src/runtime/components/KeySequence.js","webpack:///../../../src/runtime/components/State.js","webpack:///../../../src/runtime/components/defineComponent.js","webpack:///../../../src/runtime/components/dom-data.js","webpack:///../../../src/runtime/components/event-delegation.js","webpack:///../../../src/runtime/components/index-browser.js","webpack:///../../../src/runtime/components/init-components-browser.js","webpack:///../../../src/runtime/components/registry-browser.js","webpack:///../../../src/runtime/components/update-manager.js","webpack:///../../../src/runtime/components/util-browser.js","webpack:///../../src/runtime/createOut.js","webpack:///../../src/runtime/dom-insert.js","webpack:///../../../src/runtime/helpers/_weak-map.js","webpack:///../../src/runtime/setImmediate.js","webpack:///../../../src/runtime/vdom/VComponent.js","webpack:///../../../src/runtime/vdom/VDocumentFragment.js","webpack:///../../../src/runtime/vdom/VElement.js","webpack:///../../../src/runtime/vdom/VFragment.js","webpack:///../../../src/runtime/vdom/VNode.js","webpack:///../../../src/runtime/vdom/VText.js","webpack:///../../../../src/runtime/vdom/morphdom/fragment.js","webpack:///../../../../src/runtime/vdom/morphdom/helpers.js","webpack:///../../../../src/runtime/vdom/morphdom/index.js","webpack:///../../../../src/runtime/vdom/morphdom/specialElHandlers.js","webpack:///../../../src/runtime/vdom/parse-html.js","webpack:///../../../src/runtime/vdom/vdom.js","webpack:////home/dpiercey/dev/github/marko/website/node_modules/raptor-util/copyProps.js","webpack:////home/dpiercey/dev/github/marko/website/node_modules/raptor-util/extend.js","webpack:////home/dpiercey/dev/github/marko/website/node_modules/raptor-util/inherit.js","webpack:////home/dpiercey/dev/github/marko/website/node_modules/warp10/constants.js","webpack:////home/dpiercey/dev/github/marko/website/node_modules/warp10/finalize.js","webpack:////home/dpiercey/dev/github/marko/website/node_modules/warp10/src/constants.js","webpack:////home/dpiercey/dev/github/marko/website/node_modules/warp10/src/finalize.js","webpack:///(webpack)/buildin/global.js"],"names":["slice","Array","prototype","isFunction","arg","checkListener","listener","TypeError","invokeListener","ee","args","length","call","apply","addListener","eventEmitter","type","prepend","events","$e","listeners","unshift","push","EventEmitter","this","emit","arguments","error","Error","context","i","len","on","prependListener","once","g","removeListener","splice","removeAllListeners","listenerCount","module","exports","ReflectOwnKeys","R","Reflect","ReflectApply","target","receiver","Function","ownKeys","Object","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","value","init","emitter","name","Promise","resolve","reject","eventListener","undefined","errorListener","err","_events","_eventsCount","_maxListeners","defaultMaxListeners","_getMaxListeners","that","_addListener","m","existing","warning","create","newListener","warned","w","String","count","console","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","unwrapListeners","arrayClone","n","copy","defineProperty","enumerable","get","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","message","handler","prependOnceListener","list","position","originalListener","shift","index","pop","spliceOne","off","key","keys","rawListeners","eventNames","isNonEventEmitter","EventEmitterWrapper","$__target","$__listeners","$__subscribeTo","EventEmitterAdapter","SubscriptionTracker","$__subscribeToList","$__remove","test","testWrapped","filter","curListener","curEvent","curListenerFunc","curWrappedListenerFunc","subscribeTo","self","subscribeToList","cur","event","wrappedListener","listenerFunc","addEventListener","onceListener","removeEventListener","options","wrapper","nonEE","addDestroyListener","wrap","targetEventEmitter","createTracker","domInsert","require","RenderResult","out","proto","getComponent","getComponents","componentDefs","result","getComponentDefs","components","component","componentDef","selector","afterInsert","componentsContext","getNode","getOutput","toString","document","renderResult","referenceEl","isShadow","ShadowRoot","componentProto","defaultCreateOut","getComponentsContext","componentsUtil","componentLookup","destroyNodeRecursive","inherit","updateManager","morphdom","eventDelegation","domData","componentsByDOMNode","keyedElementsByComponentId","hasOwnProperty","NON_COMPONENT_SUBSCRIBE_TO_OPTIONS","removeEventListenerHandle","handleCustomEventWithMethodListener","extraArgs","targetComponent","targetMethod","targetMethodName","resolveKeyHelper","Component","id","ssrKeyedElements","subscriptions","subscribeToOptions","COMPONENT_SUBSCRIBE_TO_OPTIONS","customEvents","isOnce","getElId","resolveComponentIdHelper","getEl","getEls","els","el","rootNode","lookup","destroy","root","nodes","node","isDestroyed","newState","setState","setStateDirty","replaceState","onInput","oldInput","updatedInput","newInput","existingComponent","oldKeys","newKeys","checkInputChanged","forceUpdate","update","input","stateChanges","oldState","handlerMethod","handlers","propName","propertyName","newValue","oldValue","processUpdateHandlers","shouldUpdate","doc","globalData","renderer","globalComponentsContext","targetNode","eventListenerHandles","finalCustomEvents","eventType","customEvent","fragment","walkFragments","onCreate","onRender","w10Noop","attachBubblingEvent","addDelegatedEventHandler","extend","KeySequence","EMPTY_OBJECT","ComponentDef","componentId","elId","nestedId","d","handlerMethodName","o","typeName","types","extra","componentProps","flags","registry","global","undefinedPropNames","scope","GlobalComponentsContext","ComponentsContext","parentComponentsContext","nestedContextsForParent","nextComponentIdProvider","State","rawState","ensure","forcedDirtyState","toJSON","BaseState","BaseComponent","def","ComponentClass","WeakMap","runtimeId","getMarkoPropsFromEl","listenersAttachedKey","delegatedEvents","getEventFromEl","eventName","eventInfo","parseInt","delegateEvent","targetComponentId","targetFunc","noop","body","propagationStopped","oldStopPropagation","curNode","addDelegatedEventHandlerToDoc","initComponents","window","warp10Finalize","win","defaultDocument","createFragmentNode","addComponentRootToKeyedElements","serverComponentRootNodes","serverRenderedMeta","indexServerComponentBoundaries","stack","runtimeLength","nextSibling","commentValue","firstChar","endNode","startNode","parts","ownerId","keyedElements","ownerComponent","markoKey","markoProps","separatorIndex","addDOMEventListeners","addEventListenerHelper","method","invokeComponentEventHandler","handles","initComponent","domEvents","domEventArgs","eventEl","hydrateComponentAndGetMount","trackComponent","tryInvoke","fn","initServerRendered","renderedComponents","globalKey","fakeArray","r","isFromSerializedGlobals","prefix","meta","isLast","mount","deferredDefs","defineComponent","registered","loaded","componentTypes","getComponentClass","load","updatesScheduled","batchStack","unbatchedQueue","setImmediate","updateUnbatchedComponents","updateComponents","queue","batchStackLen","batch","func","keysByDOMNode","vElementsByDOMNode","vPropsByDOMNode","markoUID","destroyComponentForNode","componentToDestroy","nextComponentId","vElement","curChild","virtualProps","JSON","repeatedElementsForKey","parentId","actualCreateOut","createOut","createOutFunc","helpers","insertBefore","insertAfter","removeChild","resolveEl","beforeRemove","appendTo","prependTo","replace","replaceChildrenOf","counter","seed","Math","ref","msg","ev","callbacks","VNode","VComponent","preserve","VDocumentFragmentClone","other","VDocumentFragment","vElementByDOMNode","xmlnsRegExp","NS_XLINK","NS_HTML","DEFAULT_NS","svg","math","convertAttrValue","assign","a","b","setAttribute","namespaceURI","removeAttribute","VElementClone","VElement","constId","props","attrs","e","child","childCount","tagName","attributes","attrValue","attrName","forEach","virtualizeChildNodes","attrCount","attr","vdomEl","removePreservedAttributes","fromFlags","vFromEl","toFlags","toEl","fromEl","oldAttrs","VFragment","firstChild","parentNode","childValue","lastChild","VText","fragmentPrototype","nodeType","current","actualReference","referenceNode","insertInto","remove","nextNode","isRoot","detachedContainer","next","specialElHandlers","existingComponentLookup","normalizeComponentKey","virtualizeElement","morphAttrs","componentByDOMNode","detachedByDOMNode","beginFragmentNode","isAutoKey","compareNodeNames","caseInsensitiveCompare","fromNode","toNode","isHydrate","keySequences","realNode","vNode","parentEl","morphChildren","onNodeAdded","parentComponent","morphComponent","detachedNodes","curFromNodeChild","curToNodeChild","outer","toNextSibling","curToNodeType","curToNodeKey","curVFromNodeChild","curFromNodeKey","curToNodeKeyOriginal","referenceComponent","fromNextSibling","morphEl","detachNode","insertVirtualNodeBefore","matchingFromEl","depth","nodeValue","fromComponent","destroyComponent","curFromNodeType","isCompatible","matchingFromComponent","insertVirtualComponentBefore","fragmentBoundary","nodeName","specialElHandler","detachedFromComponent","syncBooleanAttrProp","SpecialElHandlers","option","button","textarea","select","selected","forEachOption","parseHTML","container","specialHtmlRegexp","vdomParent","virtualize","vdomDocFragment","virtualizeHTML","html","vdomFragment","Node_prototype","vdomNode","from","to","descriptor","getOwnPropertyDescriptor","source","copyProps","ctor","superCtor","shouldCopyProps","oldProto","newProto","constructor","writable","configurable","$super","_inherit","NOOP","$W10NOOP","constants","isArray","object","path","resolveType","info","Date","assignments","$$","rhsValue","assignment","rhs","lhs","l","lhsLast"],"mappings":"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","file":"0.2a9fc028.js","sourcesContent":["/* jshint newcap:false */\nvar slice = Array.prototype.slice;\n\nfunction isFunction(arg) {\n    return typeof arg === 'function';\n}\n\nfunction checkListener(listener) {\n    if (!isFunction(listener)) {\n        throw TypeError('Invalid listener');\n    }\n}\n\nfunction invokeListener(ee, listener, args) {\n    switch (args.length) {\n        // fast cases\n        case 1:\n            listener.call(ee);\n            break;\n        case 2:\n            listener.call(ee, args[1]);\n            break;\n        case 3:\n            listener.call(ee, args[1], args[2]);\n            break;\n            // slower\n        default:\n            listener.apply(ee, slice.call(args, 1));\n    }\n}\n\nfunction addListener(eventEmitter, type, listener, prepend) {\n    checkListener(listener);\n\n    var events = eventEmitter.$e || (eventEmitter.$e = {});\n\n    var listeners = events[type];\n    if (listeners) {\n        if (isFunction(listeners)) {\n            events[type] = prepend ? [listener, listeners] : [listeners, listener];\n        } else {\n            if (prepend) {\n                listeners.unshift(listener);\n            } else {\n                listeners.push(listener);\n            }\n        }\n\n    } else {\n        events[type] = listener;\n    }\n    return eventEmitter;\n}\n\nfunction EventEmitter() {\n    this.$e = this.$e || {};\n}\n\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype = {\n    $e: null,\n\n    emit: function(type) {\n        var args = arguments;\n\n        var events = this.$e;\n        if (!events) {\n            return;\n        }\n\n        var listeners = events && events[type];\n        if (!listeners) {\n            // If there is no 'error' event listener then throw.\n            if (type === 'error') {\n                var error = args[1];\n                if (!(error instanceof Error)) {\n                    var context = error;\n                    error = new Error('Error: ' + context);\n                    error.context = context;\n                }\n\n                throw error; // Unhandled 'error' event\n            }\n\n            return false;\n        }\n\n        if (isFunction(listeners)) {\n            invokeListener(this, listeners, args);\n        } else {\n            listeners = slice.call(listeners);\n\n            for (var i=0, len=listeners.length; i<len; i++) {\n                var listener = listeners[i];\n                invokeListener(this, listener, args);\n            }\n        }\n\n        return true;\n    },\n\n    on: function(type, listener) {\n        return addListener(this, type, listener, false);\n    },\n\n    prependListener: function(type, listener) {\n        return addListener(this, type, listener, true);\n    },\n\n    once: function(type, listener) {\n        checkListener(listener);\n\n        function g() {\n            this.removeListener(type, g);\n\n            if (listener) {\n                listener.apply(this, arguments);\n                listener = null;\n            }\n        }\n\n        this.on(type, g);\n\n        return this;\n    },\n\n    // emits a 'removeListener' event iff the listener was removed\n    removeListener: function(type, listener) {\n        checkListener(listener);\n\n        var events = this.$e;\n        var listeners;\n\n        if (events && (listeners = events[type])) {\n            if (isFunction(listeners)) {\n                if (listeners === listener) {\n                    delete events[type];\n                }\n            } else {\n                for (var i=listeners.length-1; i>=0; i--) {\n                    if (listeners[i] === listener) {\n                        listeners.splice(i, 1);\n                    }\n                }\n            }\n        }\n\n        return this;\n    },\n\n    removeAllListeners: function(type) {\n        var events = this.$e;\n        if (events) {\n            delete events[type];\n        }\n    },\n\n    listenerCount: function(type) {\n        var events = this.$e;\n        var listeners = events && events[type];\n        return listeners ? (isFunction(listeners) ? 1 : listeners.length) : 0;\n    }\n};\n\nmodule.exports = EventEmitter;","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function eventListener() {\n      if (errorListener !== undefined) {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n    var errorListener;\n\n    // Adding an error listener is not optional because\n    // if an error is thrown on an event emitter we cannot\n    // guarantee that the actual event we are waiting will\n    // be fired. The result could be a silent way to create\n    // memory or file descriptor leaks, which is something\n    // we should avoid.\n    if (name !== 'error') {\n      errorListener = function errorListener(err) {\n        emitter.removeListener(name, eventListener);\n        reject(err);\n      };\n\n      emitter.once('error', errorListener);\n    }\n\n    emitter.once(name, eventListener);\n  });\n}\n","var INDEX_EVENT = 0;\nvar INDEX_USER_LISTENER = 1;\nvar INDEX_WRAPPED_LISTENER = 2;\nvar DESTROY = \"destroy\";\n\nfunction isNonEventEmitter(target) {\n  return !target.once;\n}\n\nfunction EventEmitterWrapper(target) {\n    this.$__target = target;\n    this.$__listeners = [];\n    this.$__subscribeTo = null;\n}\n\nEventEmitterWrapper.prototype = {\n    $__remove: function(test, testWrapped) {\n        var target = this.$__target;\n        var listeners = this.$__listeners;\n\n        this.$__listeners = listeners.filter(function(curListener) {\n            var curEvent = curListener[INDEX_EVENT];\n            var curListenerFunc = curListener[INDEX_USER_LISTENER];\n            var curWrappedListenerFunc = curListener[INDEX_WRAPPED_LISTENER];\n\n            if (testWrapped) {\n                // If the user used `once` to attach an event listener then we had to\n                // wrap their listener function with a new function that does some extra\n                // cleanup to avoid a memory leak. If the `testWrapped` flag is set to true\n                // then we are attempting to remove based on a function that we had to\n                // wrap (not the user listener function)\n                if (curWrappedListenerFunc && test(curEvent, curWrappedListenerFunc)) {\n                    target.removeListener(curEvent, curWrappedListenerFunc);\n\n                    return false;\n                }\n            } else if (test(curEvent, curListenerFunc)) {\n                // If the listener function was wrapped due to it being a `once` listener\n                // then we should remove from the target EventEmitter using wrapped\n                // listener function. Otherwise, we remove the listener using the user-provided\n                // listener function.\n                target.removeListener(curEvent, curWrappedListenerFunc || curListenerFunc);\n\n                return false;\n            }\n\n            return true;\n        });\n\n        // Fixes https://github.com/raptorjs/listener-tracker/issues/2\n        // If all of the listeners stored with a wrapped EventEmitter\n        // have been removed then we should unregister the wrapped\n        // EventEmitter in the parent SubscriptionTracker\n        var subscribeTo = this.$__subscribeTo;\n\n        if (!this.$__listeners.length && subscribeTo) {\n            var self = this;\n            var subscribeToList = subscribeTo.$__subscribeToList;\n            subscribeTo.$__subscribeToList = subscribeToList.filter(function(cur) {\n                return cur !== self;\n            });\n        }\n    },\n\n    on: function(event, listener) {\n        this.$__target.on(event, listener);\n        this.$__listeners.push([event, listener]);\n        return this;\n    },\n\n    once: function(event, listener) {\n        var self = this;\n\n        // Handling a `once` event listener is a little tricky since we need to also\n        // do our own cleanup if the `once` event is emitted. Therefore, we need\n        // to wrap the user's listener function with our own listener function.\n        var wrappedListener = function() {\n            self.$__remove(function(event, listenerFunc) {\n                return wrappedListener === listenerFunc;\n            }, true /* We are removing the wrapped listener */);\n\n            listener.apply(this, arguments);\n        };\n\n        this.$__target.once(event, wrappedListener);\n        this.$__listeners.push([event, listener, wrappedListener]);\n        return this;\n    },\n\n    removeListener: function(event, listener) {\n        if (typeof event === 'function') {\n            listener = event;\n            event = null;\n        }\n\n        if (listener && event) {\n            this.$__remove(function(curEvent, curListener) {\n                return event === curEvent && listener === curListener;\n            });\n        } else if (listener) {\n            this.$__remove(function(curEvent, curListener) {\n                return listener === curListener;\n            });\n        } else if (event) {\n            this.removeAllListeners(event);\n        }\n\n        return this;\n    },\n\n    removeAllListeners: function(event) {\n\n        var listeners = this.$__listeners;\n        var target = this.$__target;\n\n        if (event) {\n            this.$__remove(function(curEvent, curListener) {\n                return event === curEvent;\n            });\n        } else {\n            for (var i = listeners.length - 1; i >= 0; i--) {\n                var cur = listeners[i];\n                target.removeListener(cur[INDEX_EVENT], cur[INDEX_USER_LISTENER]);\n            }\n            this.$__listeners.length = 0;\n        }\n\n        return this;\n    }\n};\n\nfunction EventEmitterAdapter(target) {\n    this.$__target = target;\n}\n\nEventEmitterAdapter.prototype = {\n    on: function(event, listener) {\n        this.$__target.addEventListener(event, listener);\n        return this;\n    },\n\n    once: function(event, listener) {\n        var self = this;\n\n        // need to save this so we can remove it below\n        var onceListener = function() {\n          self.$__target.removeEventListener(event, onceListener);\n          listener();\n        };\n        this.$__target.addEventListener(event, onceListener);\n        return this;\n    },\n\n    removeListener: function(event, listener) {\n        this.$__target.removeEventListener(event, listener);\n        return this;\n    }\n};\n\nfunction SubscriptionTracker() {\n    this.$__subscribeToList = [];\n}\n\nSubscriptionTracker.prototype = {\n\n    subscribeTo: function(target, options) {\n        var addDestroyListener = !options || options.addDestroyListener !== false;\n        var wrapper;\n        var nonEE;\n        var subscribeToList = this.$__subscribeToList;\n\n        for (var i=0, len=subscribeToList.length; i<len; i++) {\n            var cur = subscribeToList[i];\n            if (cur.$__target === target) {\n                wrapper = cur;\n                break;\n            }\n        }\n\n        if (!wrapper) {\n            if (isNonEventEmitter(target)) {\n              nonEE = new EventEmitterAdapter(target);\n            }\n\n            wrapper = new EventEmitterWrapper(nonEE || target);\n            if (addDestroyListener && !nonEE) {\n                wrapper.once(DESTROY, function() {\n                    wrapper.removeAllListeners();\n\n                    for (var i = subscribeToList.length - 1; i >= 0; i--) {\n                        if (subscribeToList[i].$__target === target) {\n                            subscribeToList.splice(i, 1);\n                            break;\n                        }\n                    }\n                });\n            }\n\n            // Store a reference to the parent SubscriptionTracker so that we can do cleanup\n            // if the EventEmitterWrapper instance becomes empty (i.e., no active listeners)\n            wrapper.$__subscribeTo = this;\n            subscribeToList.push(wrapper);\n        }\n\n        return wrapper;\n    },\n\n    removeAllListeners: function(target, event) {\n        var subscribeToList = this.$__subscribeToList;\n        var i;\n\n        if (target) {\n            for (i = subscribeToList.length - 1; i >= 0; i--) {\n                var cur = subscribeToList[i];\n                if (cur.$__target === target) {\n                    cur.removeAllListeners(event);\n\n                    if (!cur.$__listeners.length) {\n                        // Do some cleanup if we removed all\n                        // listeners for the target event emitter\n                        subscribeToList.splice(i, 1);\n                    }\n\n                    break;\n                }\n            }\n        } else {\n            for (i = subscribeToList.length - 1; i >= 0; i--) {\n                subscribeToList[i].removeAllListeners();\n            }\n            subscribeToList.length = 0;\n        }\n    }\n};\n\nexports = module.exports = SubscriptionTracker;\n\nexports.wrap = function(targetEventEmitter) {\n    var nonEE;\n    var wrapper;\n\n    if (isNonEventEmitter(targetEventEmitter)) {\n      nonEE = new EventEmitterAdapter(targetEventEmitter);\n    }\n\n    wrapper = new EventEmitterWrapper(nonEE || targetEventEmitter);\n    if (!nonEE) {\n      // we don't set this for non EE types\n      targetEventEmitter.once(DESTROY, function() {\n          wrapper.$__listeners.length = 0;\n      });\n    }\n\n    return wrapper;\n};\n\nexports.createTracker = function() {\n    return new SubscriptionTracker();\n};\n","<module-code(function(require, opts) {\n    var isDebug = require('./env').isDebug;\n    var file = `\"./${isDebug ? 'src' : 'dist'}/runtime/components\"`;\n\n    if (opts.module === \"cjs\") {\n        return `module.exports = require(${file});\\n`;\n    } else {\n        return `export * from ${file};\\n`;\n    }\n})/>\n\n// What's going on here? We are using Marko to do JavaScript code generation\n// during the module bundling phase to conditionally export either the\n// \"src\" or the \"dist\" folder based on whether or not we are doing a\n// debug or non-debug build. We are using Marko since we know the Marko compiler\n// is enabled already (no extra babel transform required).\n","var domInsert = require(\"./dom-insert\");\nvar complain = \"MARKO_DEBUG\" && require(\"complain\");\n\nfunction getComponentDefs(result) {\n  var componentDefs = result.___components;\n\n  if (!componentDefs) {\n    throw Error(\"No component\");\n  }\n  return componentDefs;\n}\n\nfunction RenderResult(out) {\n  this.out = this.___out = out;\n  this.___components = undefined;\n}\n\nmodule.exports = RenderResult;\n\nvar proto = (RenderResult.prototype = {\n  getComponent: function() {\n    return this.getComponents()[0];\n  },\n  getComponents: function(selector) {\n    if (this.___components === undefined) {\n      throw Error(\"Not added to DOM\");\n    }\n\n    var componentDefs = getComponentDefs(this);\n\n    var components = [];\n\n    componentDefs.forEach(function(componentDef) {\n      var component = componentDef.___component;\n      if (!selector || selector(component)) {\n        components.push(component);\n      }\n    });\n\n    return components;\n  },\n\n  afterInsert: function(doc) {\n    var out = this.___out;\n    var componentsContext = out.___components;\n    if (componentsContext) {\n      this.___components = componentsContext.___initComponents(doc);\n    } else {\n      this.___components = null;\n    }\n\n    return this;\n  },\n  getNode: function(doc) {\n    return this.___out.___getNode(doc);\n  },\n  getOutput: function() {\n    return this.___out.___getOutput();\n  },\n  toString: function() {\n    return this.___out.toString();\n  },\n  document: typeof document != \"undefined\" && document\n});\n\nObject.defineProperty(proto, \"html\", {\n  get: function() {\n    // eslint-disable-next-line no-constant-condition\n    if (\"MARKO_DEBUG\") {\n      complain(\n        'The \"html\" property is deprecated. Please use \"toString\" instead.'\n      );\n    }\n    return this.toString();\n  }\n});\n\nObject.defineProperty(proto, \"context\", {\n  get: function() {\n    // eslint-disable-next-line no-constant-condition\n    if (\"MARKO_DEBUG\") {\n      complain(\n        'The \"context\" property is deprecated. Please use \"out\" instead.'\n      );\n    }\n    return this.___out;\n  }\n});\n\n// Add all of the following DOM methods to Component.prototype:\n// - appendTo(referenceEl)\n// - replace(referenceEl)\n// - replaceChildrenOf(referenceEl)\n// - insertBefore(referenceEl)\n// - insertAfter(referenceEl)\n// - prependTo(referenceEl)\ndomInsert(\n  proto,\n  function getEl(renderResult, referenceEl) {\n    return renderResult.getNode(referenceEl.ownerDocument);\n  },\n  function afterInsert(renderResult, referenceEl) {\n    var isShadow =\n      typeof ShadowRoot === \"function\" && referenceEl instanceof ShadowRoot;\n    return renderResult.afterInsert(\n      isShadow ? referenceEl : referenceEl.ownerDocument\n    );\n  }\n);\n","\"use strict\";\n/* jshint newcap:false */\n\nvar complain = \"MARKO_DEBUG\" && require(\"complain\");\n\nvar domInsert = require(\"../dom-insert\");\nvar defaultCreateOut = require(\"../createOut\");\nvar getComponentsContext = require(\"./ComponentsContext\")\n  .___getComponentsContext;\nvar componentsUtil = require(\"./util\");\nvar componentLookup = componentsUtil.___componentLookup;\nvar destroyNodeRecursive = componentsUtil.___destroyNodeRecursive;\nvar EventEmitter = require(\"events-light\");\nvar RenderResult = require(\"../RenderResult\");\nvar SubscriptionTracker = require(\"listener-tracker\");\nvar inherit = require(\"raptor-util/inherit\");\nvar updateManager = require(\"./update-manager\");\nvar morphdom = require(\"../vdom/morphdom\");\nvar eventDelegation = require(\"./event-delegation\");\nvar domData = require(\"./dom-data\");\nvar componentsByDOMNode = domData.___componentByDOMNode;\nvar keyedElementsByComponentId = domData.___ssrKeyedElementsByComponentId;\nvar CONTEXT_KEY = \"__subtree_context__\";\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar slice = Array.prototype.slice;\n\nvar COMPONENT_SUBSCRIBE_TO_OPTIONS;\nvar NON_COMPONENT_SUBSCRIBE_TO_OPTIONS = {\n  addDestroyListener: false\n};\n\nvar emit = EventEmitter.prototype.emit;\nvar ELEMENT_NODE = 1;\n\nfunction removeListener(removeEventListenerHandle) {\n  removeEventListenerHandle();\n}\n\nfunction walkFragments(fragment) {\n  var node;\n\n  while (fragment) {\n    node = fragment.firstChild;\n\n    if (!node) {\n      break;\n    }\n\n    fragment = node.fragment;\n  }\n\n  return node;\n}\n\nfunction handleCustomEventWithMethodListener(\n  component,\n  targetMethodName,\n  args,\n  extraArgs\n) {\n  // Remove the \"eventType\" argument\n  args.push(component);\n\n  if (extraArgs) {\n    args = extraArgs.concat(args);\n  }\n\n  var targetComponent = componentLookup[component.___scope];\n  var targetMethod =\n    typeof targetMethodName === \"function\"\n      ? targetMethodName\n      : targetComponent[targetMethodName];\n  if (!targetMethod) {\n    throw Error(\"Method not found: \" + targetMethodName);\n  }\n\n  targetMethod.apply(targetComponent, args);\n}\n\nfunction resolveKeyHelper(key, index) {\n  return index ? key + \"_\" + index : key;\n}\n\nfunction resolveComponentIdHelper(component, key, index) {\n  return component.id + \"-\" + resolveKeyHelper(key, index);\n}\n\n/**\n * This method is used to process \"update_<stateName>\" handler functions.\n * If all of the modified state properties have a user provided update handler\n * then a rerender will be bypassed and, instead, the DOM will be updated\n * looping over and invoking the custom update handlers.\n * @return {boolean} Returns true if if the DOM was updated. False, otherwise.\n */\nfunction processUpdateHandlers(component, stateChanges, oldState) {\n  var handlerMethod;\n  var handlers;\n\n  for (var propName in stateChanges) {\n    if (hasOwnProperty.call(stateChanges, propName)) {\n      var handlerMethodName = \"update_\" + propName;\n\n      handlerMethod = component[handlerMethodName];\n      if (handlerMethod) {\n        (handlers || (handlers = [])).push([propName, handlerMethod]);\n      } else {\n        // This state change does not have a state handler so return false\n        // to force a rerender\n        return;\n      }\n    }\n  }\n\n  // If we got here then all of the changed state properties have\n  // an update handler or there are no state properties that actually\n  // changed.\n  if (handlers) {\n    // Otherwise, there are handlers for all of the changed properties\n    // so apply the updates using those handlers\n\n    handlers.forEach(function(handler) {\n      var propertyName = handler[0];\n      handlerMethod = handler[1];\n\n      var newValue = stateChanges[propertyName];\n      var oldValue = oldState[propertyName];\n      handlerMethod.call(component, newValue, oldValue);\n    });\n\n    component.___emitUpdate();\n    component.___reset();\n  }\n\n  return true;\n}\n\nfunction checkInputChanged(existingComponent, oldInput, newInput) {\n  if (oldInput != newInput) {\n    if (oldInput == null || newInput == null) {\n      return true;\n    }\n\n    var oldKeys = Object.keys(oldInput);\n    var newKeys = Object.keys(newInput);\n    var len = oldKeys.length;\n    if (len !== newKeys.length) {\n      return true;\n    }\n\n    for (var i = len; i--; ) {\n      var key = oldKeys[i];\n      if (!(key in newInput && oldInput[key] === newInput[key])) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nvar componentProto;\n\n/**\n * Base component type.\n *\n * NOTE: Any methods that are prefixed with an underscore should be considered private!\n */\nfunction Component(id) {\n  EventEmitter.call(this);\n  this.id = id;\n  this.___state = null;\n  this.___rootNode = null;\n  this.___subscriptions = null;\n  this.___domEventListenerHandles = null;\n  this.___bubblingDomEvents = null; // Used to keep track of bubbling DOM events for components rendered on the server\n  this.___customEvents = null;\n  this.___scope = null;\n  this.___renderInput = null;\n  this.___input = undefined;\n  this.___mounted = false;\n  this.___global = undefined;\n  this.___destroyed = false;\n  this.___updateQueued = false;\n  this.___dirty = false;\n  this.___settingInput = false;\n  this.___document = undefined;\n\n  var ssrKeyedElements = keyedElementsByComponentId[id];\n\n  if (ssrKeyedElements) {\n    this.___keyedElements = ssrKeyedElements;\n    delete keyedElementsByComponentId[id];\n  } else {\n    this.___keyedElements = {};\n  }\n}\n\nComponent.prototype = componentProto = {\n  ___isComponent: true,\n\n  subscribeTo: function(target) {\n    if (!target) {\n      throw TypeError();\n    }\n\n    var subscriptions =\n      this.___subscriptions ||\n      (this.___subscriptions = new SubscriptionTracker());\n\n    var subscribeToOptions = target.___isComponent\n      ? COMPONENT_SUBSCRIBE_TO_OPTIONS\n      : NON_COMPONENT_SUBSCRIBE_TO_OPTIONS;\n\n    return subscriptions.subscribeTo(target, subscribeToOptions);\n  },\n\n  emit: function(eventType) {\n    var customEvents = this.___customEvents;\n    var target;\n\n    if (customEvents && (target = customEvents[eventType])) {\n      var targetMethodName = target[0];\n      var isOnce = target[1];\n      var extraArgs = target[2];\n      var args = slice.call(arguments, 1);\n\n      handleCustomEventWithMethodListener(\n        this,\n        targetMethodName,\n        args,\n        extraArgs\n      );\n\n      if (isOnce) {\n        delete customEvents[eventType];\n      }\n    }\n\n    return emit.apply(this, arguments);\n  },\n  getElId: function(key, index) {\n    if (!key) {\n      return this.id;\n    }\n    return resolveComponentIdHelper(this, key, index);\n  },\n  getEl: function(key, index) {\n    if (key) {\n      var keyedElement = this.___keyedElements[\n        \"@\" + resolveKeyHelper(key, index)\n      ];\n\n      // eslint-disable-next-line no-constant-condition\n      if (\"MARKO_DEBUG\") {\n        if (\n          keyedElement &&\n          keyedElement.nodeType !== 1 /* Node.ELEMENT_NODE */\n        ) {\n          throw new Error(\n            \"Using 'getEl(key)' to get a component instance is not supported, did you mean 'getComponent(key)'?\"\n          );\n        }\n      }\n\n      return keyedElement;\n    } else {\n      return this.el;\n    }\n  },\n  getEls: function(key) {\n    key = key + \"[]\";\n\n    var els = [];\n    var i = 0;\n    var el;\n    while ((el = this.getEl(key, i))) {\n      els.push(el);\n      i++;\n    }\n    return els;\n  },\n  getComponent: function(key, index) {\n    var rootNode = this.___keyedElements[\"@\" + resolveKeyHelper(key, index)];\n    // eslint-disable-next-line no-constant-condition\n    if (\"MARKO_DEBUG\") {\n      if (/\\[\\]$/.test(key)) {\n        throw new Error(\n          \"A repeated key[] was passed to getComponent. Use a non-repeating key if there is only one of these components.\"\n        );\n      }\n    }\n\n    return rootNode && componentsByDOMNode.get(rootNode);\n  },\n  getComponents: function(key) {\n    var lookup = this.___keyedElements[\"@\" + key + \"[]\"];\n    return lookup\n      ? Object.keys(lookup)\n          .map(function(key) {\n            return componentsByDOMNode.get(lookup[key]);\n          })\n          .filter(Boolean)\n      : [];\n  },\n  destroy: function() {\n    if (this.___destroyed) {\n      return;\n    }\n\n    var root = this.___rootNode;\n\n    this.___destroyShallow();\n\n    var nodes = root.nodes;\n\n    nodes.forEach(function(node) {\n      destroyNodeRecursive(node);\n\n      if (eventDelegation.___handleNodeDetach(node) !== false) {\n        node.parentNode.removeChild(node);\n      }\n    });\n\n    root.detached = true;\n\n    delete componentLookup[this.id];\n    this.___keyedElements = {};\n  },\n\n  ___destroyShallow: function() {\n    if (this.___destroyed) {\n      return;\n    }\n\n    this.___emitDestroy();\n    this.___destroyed = true;\n\n    componentsByDOMNode.set(this.___rootNode, undefined);\n\n    this.___rootNode = null;\n\n    // Unsubscribe from all DOM events\n    this.___removeDOMEventListeners();\n\n    var subscriptions = this.___subscriptions;\n    if (subscriptions) {\n      subscriptions.removeAllListeners();\n      this.___subscriptions = null;\n    }\n  },\n\n  isDestroyed: function() {\n    return this.___destroyed;\n  },\n  get state() {\n    return this.___state;\n  },\n  set state(newState) {\n    var state = this.___state;\n    if (!state && !newState) {\n      return;\n    }\n\n    if (!state) {\n      state = this.___state = new this.___State(this);\n    }\n\n    state.___replace(newState || {});\n\n    if (state.___dirty) {\n      this.___queueUpdate();\n    }\n\n    if (!newState) {\n      this.___state = null;\n    }\n  },\n  setState: function(name, value) {\n    var state = this.___state;\n\n    if (!state) {\n      state = this.___state = new this.___State(this);\n    }\n    if (typeof name == \"object\") {\n      // Merge in the new state with the old state\n      var newState = name;\n      for (var k in newState) {\n        if (hasOwnProperty.call(newState, k)) {\n          state.___set(k, newState[k], true /* ensure:true */);\n        }\n      }\n    } else {\n      state.___set(name, value, true /* ensure:true */);\n    }\n  },\n\n  setStateDirty: function(name, value) {\n    var state = this.___state;\n\n    if (arguments.length == 1) {\n      value = state[name];\n    }\n\n    state.___set(\n      name,\n      value,\n      true /* ensure:true */,\n      true /* forceDirty:true */\n    );\n  },\n\n  replaceState: function(newState) {\n    this.___state.___replace(newState);\n  },\n\n  get input() {\n    return this.___input;\n  },\n  set input(newInput) {\n    if (this.___settingInput) {\n      this.___input = newInput;\n    } else {\n      this.___setInput(newInput);\n    }\n  },\n\n  ___setInput: function(newInput, onInput, out) {\n    onInput = onInput || this.onInput;\n    var updatedInput;\n\n    var oldInput = this.___input;\n    this.___input = undefined;\n    this.___context = (out && out[CONTEXT_KEY]) || this.___context;\n\n    if (onInput) {\n      // We need to set a flag to preview `this.input = foo` inside\n      // onInput causing infinite recursion\n      this.___settingInput = true;\n      updatedInput = onInput.call(this, newInput || {}, out);\n      this.___settingInput = false;\n    }\n\n    newInput = this.___renderInput = updatedInput || newInput;\n\n    if ((this.___dirty = checkInputChanged(this, oldInput, newInput))) {\n      this.___queueUpdate();\n    }\n\n    if (this.___input === undefined) {\n      this.___input = newInput;\n      if (newInput && newInput.$global) {\n        this.___global = newInput.$global;\n      }\n    }\n\n    return newInput;\n  },\n\n  forceUpdate: function() {\n    this.___dirty = true;\n    this.___queueUpdate();\n  },\n\n  ___queueUpdate: function() {\n    if (!this.___updateQueued) {\n      this.___updateQueued = true;\n      updateManager.___queueComponentUpdate(this);\n    }\n  },\n\n  update: function() {\n    if (this.___destroyed === true || this.___isDirty === false) {\n      return;\n    }\n\n    var input = this.___input;\n    var state = this.___state;\n\n    if (this.___dirty === false && state !== null && state.___dirty === true) {\n      if (processUpdateHandlers(this, state.___changes, state.___old, state)) {\n        state.___dirty = false;\n      }\n    }\n\n    if (this.___isDirty === true) {\n      // The UI component is still dirty after process state handlers\n      // then we should rerender\n\n      if (this.shouldUpdate(input, state) !== false) {\n        this.___scheduleRerender();\n      }\n    }\n\n    this.___reset();\n  },\n\n  get ___isDirty() {\n    return (\n      this.___dirty === true ||\n      (this.___state !== null && this.___state.___dirty === true)\n    );\n  },\n\n  ___reset: function() {\n    this.___dirty = false;\n    this.___updateQueued = false;\n    this.___renderInput = null;\n    var state = this.___state;\n    if (state) {\n      state.___reset();\n    }\n  },\n\n  shouldUpdate: function() {\n    return true;\n  },\n\n  ___scheduleRerender: function() {\n    var self = this;\n    var renderer = self.___renderer;\n\n    if (!renderer) {\n      throw TypeError();\n    }\n\n    var input = this.___renderInput || this.___input;\n\n    updateManager.___batchUpdate(function() {\n      self.___rerender(input, false).afterInsert(self.___document);\n    });\n\n    this.___reset();\n  },\n\n  ___rerender: function(input, isHydrate) {\n    var doc = this.___document;\n    var globalData = this.___global;\n    var rootNode = this.___rootNode;\n    var renderer = this.___renderer;\n    var createOut = renderer.createOut || defaultCreateOut;\n    var out = createOut(globalData);\n    out.sync();\n    out.___document = this.___document;\n    out[CONTEXT_KEY] = this.___context;\n\n    var componentsContext = getComponentsContext(out);\n    var globalComponentsContext = componentsContext.___globalContext;\n    globalComponentsContext.___rerenderComponent = this;\n    globalComponentsContext.___isHydrate = isHydrate;\n\n    renderer(input, out);\n\n    var result = new RenderResult(out);\n\n    var targetNode = out.___getOutput().___firstChild;\n\n    morphdom(rootNode, targetNode, doc, componentsContext);\n\n    return result;\n  },\n\n  ___detach: function() {\n    var root = this.___rootNode;\n    root.remove();\n    return root;\n  },\n\n  ___removeDOMEventListeners: function() {\n    var eventListenerHandles = this.___domEventListenerHandles;\n    if (eventListenerHandles) {\n      eventListenerHandles.forEach(removeListener);\n      this.___domEventListenerHandles = null;\n    }\n  },\n\n  get ___rawState() {\n    var state = this.___state;\n    return state && state.___raw;\n  },\n\n  ___setCustomEvents: function(customEvents, scope) {\n    var finalCustomEvents = (this.___customEvents = {});\n    this.___scope = scope;\n\n    customEvents.forEach(function(customEvent) {\n      var eventType = customEvent[0];\n      var targetMethodName = customEvent[1];\n      var isOnce = customEvent[2];\n      var extraArgs = customEvent[3];\n\n      finalCustomEvents[eventType] = [targetMethodName, isOnce, extraArgs];\n    });\n  },\n\n  get el() {\n    return walkFragments(this.___rootNode);\n  },\n\n  get els() {\n    // eslint-disable-next-line no-constant-condition\n    if (\"MARKO_DEBUG\") {\n      complain(\n        'The \"this.els\" attribute is deprecated. Please use \"this.getEls(key)\" instead.'\n      );\n    }\n    return (this.___rootNode ? this.___rootNode.nodes : []).filter(function(\n      el\n    ) {\n      return el.nodeType === ELEMENT_NODE;\n    });\n  },\n\n  ___emit: emit,\n  ___emitCreate(input, out) {\n    this.onCreate && this.onCreate(input, out);\n    this.___emit(\"create\", input, out);\n  },\n\n  ___emitRender(out) {\n    this.onRender && this.onRender(out);\n    this.___emit(\"render\", out);\n  },\n\n  ___emitUpdate() {\n    this.onUpdate && this.onUpdate();\n    this.___emit(\"update\");\n  },\n\n  ___emitMount() {\n    this.onMount && this.onMount();\n    this.___emit(\"mount\");\n  },\n\n  ___emitDestroy() {\n    this.onDestroy && this.onDestroy();\n    this.___emit(\"destroy\");\n  }\n};\n\ncomponentProto.elId = componentProto.getElId;\ncomponentProto.___update = componentProto.update;\ncomponentProto.___destroy = componentProto.destroy;\n\n// Add all of the following DOM methods to Component.prototype:\n// - appendTo(referenceEl)\n// - replace(referenceEl)\n// - replaceChildrenOf(referenceEl)\n// - insertBefore(referenceEl)\n// - insertAfter(referenceEl)\n// - prependTo(referenceEl)\ndomInsert(\n  componentProto,\n  function getEl(component) {\n    return component.___detach();\n  },\n  function afterInsert(component) {\n    return component;\n  }\n);\n\ninherit(Component, EventEmitter);\n\nmodule.exports = Component;\n","\"use strict\";\nvar complain = \"MARKO_DEBUG\" && require(\"complain\");\nvar w10Noop = require(\"warp10/constants\").NOOP;\nvar componentUtil = require(\"./util\");\nvar attachBubblingEvent = componentUtil.___attachBubblingEvent;\nvar addDelegatedEventHandler = require(\"./event-delegation\")\n  .___addDelegatedEventHandler;\nvar extend = require(\"raptor-util/extend\");\nvar KeySequence = require(\"./KeySequence\");\nvar EMPTY_OBJECT = {};\n\nvar FLAG_WILL_RERENDER_IN_BROWSER = 1;\nvar FLAG_HAS_RENDER_BODY = 2;\n\n/**\n * A ComponentDef is used to hold the metadata collected at runtime for\n * a single component and this information is used to instantiate the component\n * later (after the rendered HTML has been added to the DOM)\n */\nfunction ComponentDef(component, componentId, componentsContext) {\n  this.___componentsContext = componentsContext; // The AsyncWriter that this component is associated with\n  this.___component = component;\n  this.id = componentId;\n\n  this.___domEvents = undefined; // An array of DOM events that need to be added (in sets of three)\n\n  this.___isExisting = false;\n\n  this.___renderBoundary = false;\n  this.___flags = 0;\n\n  this.___nextIdIndex = 0; // The unique integer to use for the next scoped ID\n  this.___keySequence = null;\n}\n\nComponentDef.prototype = {\n  ___nextKey: function(key) {\n    return (\n      this.___keySequence || (this.___keySequence = new KeySequence())\n    ).___nextKey(key);\n  },\n\n  /**\n   * This helper method generates a unique and fully qualified DOM element ID\n   * that is unique within the scope of the current component.\n   */\n  elId: function(nestedId) {\n    var id = this.id;\n\n    if (nestedId == null) {\n      return id;\n    } else {\n      if (typeof nestedId !== \"string\") {\n        // eslint-disable-next-line no-constant-condition\n        if (\"MARKO_DEBUG\") {\n          complain(\"Using non strings as keys is deprecated.\");\n        }\n\n        nestedId = String(nestedId);\n      }\n\n      if (nestedId.indexOf(\"#\") === 0) {\n        id = \"#\" + id;\n        nestedId = nestedId.substring(1);\n      }\n\n      return id + \"-\" + nestedId;\n    }\n  },\n  /**\n   * Returns the next auto generated unique ID for a nested DOM element or nested DOM component\n   */\n  ___nextComponentId: function() {\n    return this.id + \"-c\" + this.___nextIdIndex++;\n  },\n\n  d: function(eventName, handlerMethodName, isOnce, extraArgs) {\n    addDelegatedEventHandler(eventName);\n    return attachBubblingEvent(this, handlerMethodName, isOnce, extraArgs);\n  },\n\n  get ___type() {\n    return this.___component.___type;\n  }\n};\n\nComponentDef.prototype.nk = ComponentDef.prototype.___nextKey;\n\nComponentDef.___deserialize = function(o, types, global, registry) {\n  var id = o[0];\n  var typeName = types[o[1]];\n  var input = o[2] || null;\n  var extra = o[3] || EMPTY_OBJECT;\n\n  var state = extra.s;\n  var componentProps = extra.w;\n  var flags = extra.f;\n  var component = registry.___createComponent(typeName, id);\n\n  // Prevent newly created component from being queued for update since we area\n  // just building it from the server info\n  component.___updateQueued = true;\n\n  if (flags & FLAG_HAS_RENDER_BODY) {\n    (input || (input = {})).renderBody = w10Noop;\n  }\n\n  if (flags & FLAG_WILL_RERENDER_IN_BROWSER) {\n    if (component.onCreate) {\n      component.onCreate(input, { global: global });\n    }\n    if (component.onInput) {\n      input = component.onInput(input, { global: global }) || input;\n    }\n  } else {\n    if (state) {\n      var undefinedPropNames = extra.u;\n      if (undefinedPropNames) {\n        undefinedPropNames.forEach(function(undefinedPropName) {\n          state[undefinedPropName] = undefined;\n        });\n      }\n      // We go through the setter here so that we convert the state object\n      // to an instance of `State`\n      component.state = state;\n    }\n\n    if (componentProps) {\n      extend(component, componentProps);\n    }\n  }\n\n  component.___input = input;\n\n  if (extra.b) {\n    component.___bubblingDomEvents = extra.b;\n  }\n\n  var scope = extra.p;\n  var customEvents = extra.e;\n  if (customEvents) {\n    component.___setCustomEvents(customEvents, scope);\n  }\n\n  component.___global = global;\n\n  return {\n    id: id,\n    ___component: component,\n    ___domEvents: extra.d,\n    ___flags: extra.f || 0\n  };\n};\n\nmodule.exports = ComponentDef;\n","\"use strict\";\nvar GlobalComponentsContext = require(\"./GlobalComponentsContext\");\n\nfunction ComponentsContext(out, parentComponentsContext) {\n  var globalComponentsContext;\n  var componentDef;\n\n  if (parentComponentsContext) {\n    globalComponentsContext = parentComponentsContext.___globalContext;\n    componentDef = parentComponentsContext.___componentDef;\n\n    var nestedContextsForParent;\n    if (\n      !(nestedContextsForParent = parentComponentsContext.___nestedContexts)\n    ) {\n      nestedContextsForParent = parentComponentsContext.___nestedContexts = [];\n    }\n\n    nestedContextsForParent.push(this);\n  } else {\n    globalComponentsContext = out.global.___components;\n    if (globalComponentsContext === undefined) {\n      out.global.___components = globalComponentsContext = new GlobalComponentsContext(\n        out\n      );\n    }\n  }\n\n  this.___globalContext = globalComponentsContext;\n  this.___components = [];\n  this.___out = out;\n  this.___componentDef = componentDef;\n  this.___nestedContexts = undefined;\n  this.___isPreserved =\n    parentComponentsContext && parentComponentsContext.___isPreserved;\n}\n\nComponentsContext.prototype = {\n  ___initComponents: function(doc) {\n    var componentDefs = this.___components;\n\n    ComponentsContext.___initClientRendered(componentDefs, doc);\n\n    this.___out.emit(\"___componentsInitialized\");\n\n    // Reset things stored in global since global is retained for\n    // future renders\n    this.___out.global.___components = undefined;\n\n    return componentDefs;\n  }\n};\n\nfunction getComponentsContext(out) {\n  return out.___components || (out.___components = new ComponentsContext(out));\n}\n\nmodule.exports = exports = ComponentsContext;\n\nexports.___getComponentsContext = getComponentsContext;\n","var nextComponentIdProvider = require(\"./util\").___nextComponentIdProvider;\n\nfunction GlobalComponentsContext(out) {\n  this.___renderedComponentsById = {};\n  this.___rerenderComponent = undefined;\n  this.___nextComponentId = nextComponentIdProvider(out);\n}\n\nmodule.exports = GlobalComponentsContext;\n","function KeySequence() {\n  this.___lookup = Object.create(null);\n}\n\nKeySequence.prototype.___nextKey = function(key) {\n  var lookup = this.___lookup;\n\n  if (lookup[key]) {\n    return key + \"_\" + lookup[key]++;\n  }\n\n  lookup[key] = 1;\n  return key;\n};\n\nmodule.exports = KeySequence;\n","var extend = require(\"raptor-util/extend\");\n\nfunction ensure(state, propertyName) {\n  var proto = state.constructor.prototype;\n  if (!(propertyName in proto)) {\n    Object.defineProperty(proto, propertyName, {\n      get: function() {\n        return this.___raw[propertyName];\n      },\n      set: function(value) {\n        this.___set(propertyName, value, false /* ensure:false */);\n      }\n    });\n  }\n}\n\nfunction State(component) {\n  this.___component = component;\n  this.___raw = {};\n\n  this.___dirty = false;\n  this.___old = null;\n  this.___changes = null;\n  this.___forced = null; // An object that we use to keep tracking of state properties that were forced to be dirty\n\n  Object.seal(this);\n}\n\nState.prototype = {\n  ___reset: function() {\n    var self = this;\n\n    self.___dirty = false;\n    self.___old = null;\n    self.___changes = null;\n    self.___forced = null;\n  },\n\n  ___replace: function(newState) {\n    var state = this;\n    var key;\n\n    var rawState = this.___raw;\n\n    for (key in rawState) {\n      if (!(key in newState)) {\n        state.___set(\n          key,\n          undefined,\n          false /* ensure:false */,\n          false /* forceDirty:false */\n        );\n      }\n    }\n\n    for (key in newState) {\n      state.___set(\n        key,\n        newState[key],\n        true /* ensure:true */,\n        false /* forceDirty:false */\n      );\n    }\n  },\n  ___set: function(name, value, shouldEnsure, forceDirty) {\n    var rawState = this.___raw;\n\n    if (shouldEnsure) {\n      ensure(this, name);\n    }\n\n    if (forceDirty) {\n      var forcedDirtyState = this.___forced || (this.___forced = {});\n      forcedDirtyState[name] = true;\n    } else if (rawState[name] === value) {\n      return;\n    }\n\n    if (!this.___dirty) {\n      // This is the first time we are modifying the component state\n      // so introduce some properties to do some tracking of\n      // changes to the state\n      this.___dirty = true; // Mark the component state as dirty (i.e. modified)\n      this.___old = rawState;\n      this.___raw = rawState = extend({}, rawState);\n      this.___changes = {};\n      this.___component.___queueUpdate();\n    }\n\n    this.___changes[name] = value;\n\n    if (value === undefined) {\n      // Don't store state properties with an undefined or null value\n      delete rawState[name];\n    } else {\n      // Otherwise, store the new value in the component state\n      rawState[name] = value;\n    }\n  },\n  toJSON: function() {\n    return this.___raw;\n  }\n};\n\nmodule.exports = State;\n","\"use strict\";\n/* jshint newcap:false */\n\nvar BaseState = require(\"./State\");\nvar BaseComponent = require(\"./Component\");\nvar inherit = require(\"raptor-util/inherit\");\n\nmodule.exports = function defineComponent(def, renderer) {\n  if (def.___isComponent) {\n    return def;\n  }\n\n  var ComponentClass = function() {};\n  var proto;\n\n  var type = typeof def;\n\n  if (type == \"function\") {\n    proto = def.prototype;\n  } else if (type == \"object\") {\n    proto = def;\n  } else {\n    throw TypeError();\n  }\n\n  ComponentClass.prototype = proto;\n\n  // We don't use the constructor provided by the user\n  // since we don't invoke their constructor until\n  // we have had a chance to do our own initialization.\n  // Instead, we store their constructor in the \"initComponent\"\n  // property and that method gets called later inside\n  // init-components-browser.js\n  function Component(id) {\n    BaseComponent.call(this, id);\n  }\n\n  if (!proto.___isComponent) {\n    // Inherit from Component if they didn't already\n    inherit(ComponentClass, BaseComponent);\n  }\n\n  // The same prototype will be used by our constructor after\n  // we he have set up the prototype chain using the inherit function\n  proto = Component.prototype = ComponentClass.prototype;\n\n  // proto.constructor = def.constructor = Component;\n\n  // Set a flag on the constructor function to make it clear this is\n  // a component so that we can short-circuit this work later\n  Component.___isComponent = true;\n\n  function State(component) {\n    BaseState.call(this, component);\n  }\n  inherit(State, BaseState);\n  proto.___State = State;\n  proto.___renderer = renderer;\n\n  return Component;\n};\n","var WeakMap = require(\"../helpers/_weak-map\");\n\nmodule.exports = {\n  ___vPropsByDOMNode: new WeakMap(),\n  ___vElementByDOMNode: new WeakMap(),\n  ___componentByDOMNode: new WeakMap(),\n  ___detachedByDOMNode: new WeakMap(),\n  ___keyByDOMNode: new WeakMap(),\n  ___ssrKeyedElementsByComponentId: {}\n};\n","var componentsUtil = require(\"./util\");\nvar runtimeId = componentsUtil.___runtimeId;\nvar componentLookup = componentsUtil.___componentLookup;\nvar getMarkoPropsFromEl = componentsUtil.___getMarkoPropsFromEl;\n\n// We make our best effort to allow multiple marko runtimes to be loaded in the\n// same window. Each marko runtime will get its own unique runtime ID.\nvar listenersAttachedKey = \"$MDE\" + runtimeId;\nvar delegatedEvents = {};\n\nfunction getEventFromEl(el, eventName) {\n  var virtualProps = getMarkoPropsFromEl(el);\n  var eventInfo = virtualProps[eventName];\n\n  if (typeof eventInfo === \"string\") {\n    eventInfo = eventInfo.split(\" \");\n    if (eventInfo[2]) {\n      eventInfo[2] = eventInfo[2] === \"true\";\n    }\n    if (eventInfo.length == 4) {\n      eventInfo[3] = parseInt(eventInfo[3], 10);\n    }\n  }\n\n  return eventInfo;\n}\n\nfunction delegateEvent(node, eventName, target, event) {\n  var targetMethod = target[0];\n  var targetComponentId = target[1];\n  var isOnce = target[2];\n  var extraArgs = target[3];\n\n  if (isOnce) {\n    var virtualProps = getMarkoPropsFromEl(node);\n    delete virtualProps[eventName];\n  }\n\n  var targetComponent = componentLookup[targetComponentId];\n\n  if (!targetComponent) {\n    return;\n  }\n\n  var targetFunc =\n    typeof targetMethod === \"function\"\n      ? targetMethod\n      : targetComponent[targetMethod];\n  if (!targetFunc) {\n    throw Error(\"Method not found: \" + targetMethod);\n  }\n\n  if (extraArgs != null) {\n    if (typeof extraArgs === \"number\") {\n      extraArgs = targetComponent.___bubblingDomEvents[extraArgs];\n    }\n  }\n\n  // Invoke the component method\n  if (extraArgs) {\n    targetFunc.apply(targetComponent, extraArgs.concat(event, node));\n  } else {\n    targetFunc.call(targetComponent, event, node);\n  }\n}\n\nfunction addDelegatedEventHandler(eventType) {\n  if (!delegatedEvents[eventType]) {\n    delegatedEvents[eventType] = true;\n  }\n}\n\nfunction addDelegatedEventHandlerToDoc(eventType, doc) {\n  var body = doc.body || doc;\n  var listeners = (doc[listenersAttachedKey] = doc[listenersAttachedKey] || {});\n  if (!listeners[eventType]) {\n    body.addEventListener(\n      eventType,\n      (listeners[eventType] = function(event) {\n        var propagationStopped = false;\n\n        // Monkey-patch to fix #97\n        var oldStopPropagation = event.stopPropagation;\n\n        event.stopPropagation = function() {\n          oldStopPropagation.call(event);\n          propagationStopped = true;\n        };\n\n        var curNode = event.target;\n        if (!curNode) {\n          return;\n        }\n\n        // event.target of an SVGElementInstance does not have a\n        // `getAttribute` function in IE 11.\n        // See https://github.com/marko-js/marko/issues/796\n        curNode = curNode.correspondingUseElement || curNode;\n\n        // Search up the tree looking DOM events mapped to target\n        // component methods\n        var propName = \"on\" + eventType;\n        var target;\n\n        // Attributes will have the following form:\n        // on<event_type>(\"<target_method>|<component_id>\")\n\n        do {\n          if ((target = getEventFromEl(curNode, propName))) {\n            delegateEvent(curNode, propName, target, event);\n\n            if (propagationStopped) {\n              break;\n            }\n          }\n        } while ((curNode = curNode.parentNode) && curNode.getAttribute);\n      }),\n      true\n    );\n  }\n}\n\nfunction noop() {}\n\nexports.___handleNodeAttach = noop;\nexports.___handleNodeDetach = noop;\nexports.___delegateEvent = delegateEvent;\nexports.___getEventFromEl = getEventFromEl;\nexports.___addDelegatedEventHandler = addDelegatedEventHandler;\nexports.___init = function(doc) {\n  Object.keys(delegatedEvents).forEach(function(eventType) {\n    addDelegatedEventHandlerToDoc(eventType, doc);\n  });\n};\n","var componentsUtil = require(\"./util\");\nvar initComponents = require(\"./init-components\");\nvar registry = require(\"./registry\");\n\nrequire(\"./ComponentsContext\").___initClientRendered =\n  initComponents.___initClientRendered;\n\nexports.getComponentForEl = componentsUtil.___getComponentForEl;\nexports.init = window.$initComponents = initComponents.___initServerRendered;\n\nexports.register = function(id, component) {\n  registry.r(id, function() {\n    return component;\n  });\n};\n","\"use strict\";\nvar complain = \"MARKO_DEBUG\" && require(\"complain\");\nvar warp10Finalize = require(\"warp10/finalize\");\nvar eventDelegation = require(\"./event-delegation\");\nvar win = window;\nvar defaultDocument = document;\nvar createFragmentNode = require(\"../vdom/morphdom/fragment\")\n  .___createFragmentNode;\nvar componentsUtil = require(\"./util-browser\");\nvar componentLookup = componentsUtil.___componentLookup;\nvar addComponentRootToKeyedElements =\n  componentsUtil.___addComponentRootToKeyedElements;\nvar ComponentDef = require(\"./ComponentDef\");\nvar registry = require(\"./registry\");\nvar domData = require(\"./dom-data\");\nvar keyedElementsByComponentId = domData.___ssrKeyedElementsByComponentId;\nvar componentsByDOMNode = domData.___componentByDOMNode;\nvar serverComponentRootNodes = {};\nvar serverRenderedMeta = {};\n\nvar DEFAULT_RUNTIME_ID = \"M\";\nvar FLAG_WILL_RERENDER_IN_BROWSER = 1;\n// var FLAG_HAS_RENDER_BODY = 2;\n\nfunction indexServerComponentBoundaries(node, runtimeId, stack) {\n  var componentId;\n  var ownerId;\n  var ownerComponent;\n  var keyedElements;\n  var nextSibling;\n  var runtimeLength = runtimeId.length;\n  stack = stack || [];\n\n  node = node.firstChild;\n  while (node) {\n    nextSibling = node.nextSibling;\n    if (node.nodeType === 8) {\n      // Comment node\n      var commentValue = node.nodeValue;\n      if (commentValue.slice(0, runtimeLength) === runtimeId) {\n        var firstChar = commentValue[runtimeLength];\n\n        if (firstChar === \"^\" || firstChar === \"#\") {\n          stack.push(node);\n        } else if (firstChar === \"/\") {\n          var endNode = node;\n          var startNode = stack.pop();\n          var rootNode;\n\n          if (startNode.parentNode === endNode.parentNode) {\n            rootNode = createFragmentNode(startNode.nextSibling, endNode);\n          } else {\n            rootNode = createFragmentNode(\n              endNode.parentNode.firstChild,\n              endNode\n            );\n          }\n\n          componentId = startNode.nodeValue.substring(runtimeLength + 1);\n          firstChar = startNode.nodeValue[runtimeLength];\n\n          if (firstChar === \"^\") {\n            var parts = componentId.split(/ /g);\n            var key = parts[2];\n            ownerId = parts[1];\n            componentId = parts[0];\n            if ((ownerComponent = componentLookup[ownerId])) {\n              keyedElements = ownerComponent.___keyedElements;\n            } else {\n              keyedElements =\n                keyedElementsByComponentId[ownerId] ||\n                (keyedElementsByComponentId[ownerId] = {});\n            }\n            addComponentRootToKeyedElements(\n              keyedElements,\n              key,\n              rootNode,\n              componentId\n            );\n          }\n\n          serverComponentRootNodes[componentId] = rootNode;\n\n          startNode.parentNode.removeChild(startNode);\n          endNode.parentNode.removeChild(endNode);\n        }\n      }\n    } else if (node.nodeType === 1) {\n      // HTML element node\n      var markoKey = node.getAttribute(\"data-marko-key\");\n      var markoProps = componentsUtil.___getMarkoPropsFromEl(node);\n      if (markoKey) {\n        var separatorIndex = markoKey.indexOf(\" \");\n        ownerId = markoKey.substring(separatorIndex + 1);\n        markoKey = markoKey.substring(0, separatorIndex);\n        if ((ownerComponent = componentLookup[ownerId])) {\n          keyedElements = ownerComponent.___keyedElements;\n        } else {\n          keyedElements =\n            keyedElementsByComponentId[ownerId] ||\n            (keyedElementsByComponentId[ownerId] = {});\n        }\n        keyedElements[markoKey] = node;\n      }\n      if (markoProps) {\n        Object.keys(markoProps).forEach(function(key) {\n          if (key.slice(0, 2) === \"on\") {\n            eventDelegation.___addDelegatedEventHandler(key.slice(2));\n          }\n        });\n      }\n      indexServerComponentBoundaries(node, runtimeId, stack);\n    }\n\n    node = nextSibling;\n  }\n}\n\nfunction invokeComponentEventHandler(component, targetMethodName, args) {\n  var method = component[targetMethodName];\n  if (!method) {\n    throw Error(\"Method not found: \" + targetMethodName);\n  }\n\n  method.apply(component, args);\n}\n\nfunction addEventListenerHelper(el, eventType, isOnce, listener) {\n  var eventListener = listener;\n  if (isOnce) {\n    eventListener = function(event) {\n      listener(event);\n      el.removeEventListener(eventType, eventListener);\n    };\n  }\n\n  el.addEventListener(eventType, eventListener, false);\n\n  return function remove() {\n    el.removeEventListener(eventType, eventListener);\n  };\n}\n\nfunction addDOMEventListeners(\n  component,\n  el,\n  eventType,\n  targetMethodName,\n  isOnce,\n  extraArgs,\n  handles\n) {\n  var removeListener = addEventListenerHelper(el, eventType, isOnce, function(\n    event\n  ) {\n    var args = [event, el];\n    if (extraArgs) {\n      args = extraArgs.concat(args);\n    }\n\n    invokeComponentEventHandler(component, targetMethodName, args);\n  });\n  handles.push(removeListener);\n}\n\nfunction initComponent(componentDef, doc) {\n  var component = componentDef.___component;\n\n  component.___reset();\n  component.___document = doc;\n\n  var isExisting = componentDef.___isExisting;\n\n  if (isExisting) {\n    component.___removeDOMEventListeners();\n  }\n\n  var domEvents = componentDef.___domEvents;\n  if (domEvents) {\n    var eventListenerHandles = [];\n\n    domEvents.forEach(function(domEventArgs) {\n      // The event mapping is for a direct DOM event (not a custom event and not for bubblign dom events)\n\n      var eventType = domEventArgs[0];\n      var targetMethodName = domEventArgs[1];\n      var eventEl = component.___keyedElements[domEventArgs[2]];\n      var isOnce = domEventArgs[3];\n      var extraArgs = domEventArgs[4];\n\n      addDOMEventListeners(\n        component,\n        eventEl,\n        eventType,\n        targetMethodName,\n        isOnce,\n        extraArgs,\n        eventListenerHandles\n      );\n    });\n\n    if (eventListenerHandles.length) {\n      component.___domEventListenerHandles = eventListenerHandles;\n    }\n  }\n\n  if (component.___mounted) {\n    component.___emitUpdate();\n  } else {\n    component.___mounted = true;\n    component.___emitMount();\n  }\n}\n\n/**\n * This method is used to initialized components associated with UI components\n * rendered in the browser. While rendering UI components a \"components context\"\n * is added to the rendering context to keep up with which components are rendered.\n * When ready, the components can then be initialized by walking the component tree\n * in the components context (nested components are initialized before ancestor components).\n * @param  {Array<marko-components/lib/ComponentDef>} componentDefs An array of ComponentDef instances\n */\nfunction initClientRendered(componentDefs, doc) {\n  // Ensure that event handlers to handle delegating events are\n  // always attached before initializing any components\n  eventDelegation.___init(doc);\n\n  doc = doc || defaultDocument;\n  var len = componentDefs.length;\n  var componentDef;\n  var i;\n\n  for (i = len; i--; ) {\n    componentDef = componentDefs[i];\n    trackComponent(componentDef);\n  }\n\n  for (i = len; i--; ) {\n    componentDef = componentDefs[i];\n    initComponent(componentDef, doc);\n  }\n}\n\n/**\n * This method initializes all components that were rendered on the server by iterating over all\n * of the component IDs.\n */\nfunction initServerRendered(renderedComponents, doc) {\n  var type = typeof renderedComponents;\n  var globalKey = \"$\";\n  var runtimeId;\n\n  if (type !== \"object\") {\n    if (type === \"string\") {\n      runtimeId = renderedComponents;\n      globalKey += runtimeId + \"_C\";\n    } else {\n      globalKey += (runtimeId = DEFAULT_RUNTIME_ID) + \"C\";\n    }\n\n    renderedComponents = win[globalKey];\n\n    var fakeArray = (win[globalKey] = {\n      r: runtimeId,\n      concat: initServerRendered\n    });\n\n    if (renderedComponents && renderedComponents.forEach) {\n      renderedComponents.forEach(function(renderedComponent) {\n        fakeArray.concat(renderedComponent);\n      });\n    }\n\n    return fakeArray;\n  }\n\n  var isFromSerializedGlobals = this.concat === initServerRendered;\n  renderedComponents = warp10Finalize(renderedComponents);\n\n  if (isFromSerializedGlobals) {\n    runtimeId = this.r;\n    doc = defaultDocument;\n  } else {\n    runtimeId = renderedComponents.r || DEFAULT_RUNTIME_ID;\n    doc = doc || defaultDocument;\n\n    // eslint-disable-next-line no-constant-condition\n    if (\"MARKO_DEBUG\") {\n      complain(\n        \"Passing serialized data to `require('marko/components).init` is deprecated. Instead set '$global.runtimeId' and provide the 'runtimeId' option to your Marko bundler plugin.\"\n      );\n    }\n  }\n\n  // eslint-disable-next-line no-constant-condition\n  if (\"MARKO_DEBUG\") {\n    if (doc !== defaultDocument) {\n      complain(\n        \"Passing a document other than the current document to `require('marko/components).init` is deprecated.\"\n      );\n    }\n  }\n\n  var prefix = renderedComponents.p || \"\";\n  var meta = serverRenderedMeta[prefix];\n  var isLast = renderedComponents.l;\n\n  if (meta) {\n    if (isLast) {\n      delete serverRenderedMeta[prefix];\n    }\n  } else {\n    meta = {};\n\n    if (!isLast) {\n      serverRenderedMeta[prefix] = meta;\n    }\n  }\n\n  // Ensure that event handlers to handle delegating events are\n  // always attached before initializing any components\n  indexServerComponentBoundaries(doc, runtimeId);\n  eventDelegation.___init(doc);\n\n  if (renderedComponents.g) {\n    meta.___globals = renderedComponents.g;\n  }\n\n  if (renderedComponents.t) {\n    meta.___types = meta.___types\n      ? meta.___types.concat(renderedComponents.t)\n      : renderedComponents.t;\n  }\n\n  // hydrate components top down (leaf nodes last)\n  // and return an array of functions to mount these components\n  var deferredDefs;\n  (renderedComponents.w || [])\n    .map(function(componentDef) {\n      componentDef = ComponentDef.___deserialize(\n        componentDef,\n        meta.___types,\n        meta.___globals,\n        registry\n      );\n\n      var mount = hydrateComponentAndGetMount(componentDef, doc);\n\n      if (!mount) {\n        // hydrateComponentAndGetMount will return false if there is not rootNode\n        // for the component.  If this is the case, we'll wait until the\n        // DOM has fully loaded to attempt to init the component again.\n        if (deferredDefs) {\n          deferredDefs.push(componentDef);\n        } else {\n          deferredDefs = [componentDef];\n          doc.addEventListener(\"DOMContentLoaded\", function() {\n            indexServerComponentBoundaries(doc, runtimeId);\n            deferredDefs\n              .map(function(componentDef) {\n                return hydrateComponentAndGetMount(componentDef, doc);\n              })\n              .reverse()\n              .forEach(tryInvoke);\n          });\n        }\n      }\n\n      return mount;\n    })\n    .reverse()\n    .forEach(tryInvoke);\n\n  return this;\n}\n\nfunction hydrateComponentAndGetMount(componentDef, doc) {\n  var componentId = componentDef.id;\n  var component = componentDef.___component;\n  var rootNode = serverComponentRootNodes[componentId];\n  var renderResult;\n\n  if (rootNode) {\n    delete serverComponentRootNodes[componentId];\n\n    component.___rootNode = rootNode;\n    componentsByDOMNode.set(rootNode, component);\n\n    if (componentDef.___flags & FLAG_WILL_RERENDER_IN_BROWSER) {\n      component.___document = doc;\n      renderResult = component.___rerender(component.___input, true);\n      trackComponent(componentDef);\n      return function mount() {\n        renderResult.afterInsert(doc);\n      };\n    } else {\n      trackComponent(componentDef);\n    }\n\n    return function mount() {\n      initComponent(componentDef, doc);\n    };\n  }\n}\n\nfunction trackComponent(componentDef) {\n  var component = componentDef.___component;\n  if (component) {\n    componentLookup[component.id] = component;\n  }\n}\n\nfunction tryInvoke(fn) {\n  if (fn) fn();\n}\n\nexports.___initClientRendered = initClientRendered;\nexports.___initServerRendered = initServerRendered;\n","var defineComponent = require(\"./defineComponent\");\nrequire(\".\");\n\nvar registered = {};\nvar loaded = {};\nvar componentTypes = {};\n\nfunction register(componentId, def) {\n  registered[componentId] = def;\n  delete loaded[componentId];\n  delete componentTypes[componentId];\n  return componentId;\n}\n\nfunction load(typeName) {\n  var target = loaded[typeName];\n  if (!target) {\n    target = registered[typeName];\n\n    if (target) {\n      target = target();\n    }\n\n    if (!target) {\n      throw Error(\"Component not found: \" + typeName);\n    }\n\n    loaded[typeName] = target;\n  }\n\n  return target;\n}\n\nfunction getComponentClass(typeName) {\n  var ComponentClass = componentTypes[typeName];\n\n  if (ComponentClass) {\n    return ComponentClass;\n  }\n\n  ComponentClass = load(typeName);\n\n  ComponentClass = ComponentClass.Component || ComponentClass;\n\n  if (!ComponentClass.___isComponent) {\n    ComponentClass = defineComponent(ComponentClass, ComponentClass.renderer);\n  }\n\n  // Make the component \"type\" accessible on each component instance\n  ComponentClass.prototype.___type = typeName;\n\n  // eslint-disable-next-line no-constant-condition\n  if (\"MARKO_DEBUG\") {\n    var classNameMatch = /\\/([^/]+?)(?:\\/index|\\/template|)(?:\\.marko|\\.component(?:-browser)?|)$/.exec(\n      typeName\n    );\n    var className = classNameMatch ? classNameMatch[1] : \"AnonymousComponent\";\n    className = className.replace(/-(.)/g, function(g) {\n      return g[1].toUpperCase();\n    });\n    className = className\n      .replace(/\\$\\d+\\.\\d+\\.\\d+$/, \"\")\n      .replace(/^[^a-z$_]/i, \"_$&\")\n      .replace(/[^0-9a-z$_]+/gi, \"_\");\n    className = className[0].toUpperCase() + className.slice(1);\n    // eslint-disable-next-line no-unused-vars\n    try {\n      var OldComponentClass = ComponentClass;\n      eval(\n        \"ComponentClass = function \" +\n          className +\n          \"(id, doc) { OldComponentClass.call(this, id, doc); }\"\n      );\n      ComponentClass.prototype = OldComponentClass.prototype;\n    } catch (e) {\n      /** ignore error */\n    }\n  }\n\n  componentTypes[typeName] = ComponentClass;\n\n  return ComponentClass;\n}\n\nfunction createComponent(typeName, id) {\n  var ComponentClass = getComponentClass(typeName);\n  return new ComponentClass(id);\n}\n\nexports.r = register;\nexports.___createComponent = createComponent;\n","\"use strict\";\n\nvar updatesScheduled = false;\nvar batchStack = []; // A stack of batched updates\nvar unbatchedQueue = []; // Used for scheduled batched updates\n\nvar setImmediate = require(\"../setImmediate\");\n\n/**\n * This function is called when we schedule the update of \"unbatched\"\n * updates to components.\n */\nfunction updateUnbatchedComponents() {\n  if (unbatchedQueue.length) {\n    try {\n      updateComponents(unbatchedQueue);\n    } finally {\n      // Reset the flag now that this scheduled batch update\n      // is complete so that we can later schedule another\n      // batched update if needed\n      updatesScheduled = false;\n    }\n  }\n}\n\nfunction scheduleUpdates() {\n  if (updatesScheduled) {\n    // We have already scheduled a batched update for the\n    // nextTick so nothing to do\n    return;\n  }\n\n  updatesScheduled = true;\n\n  setImmediate(updateUnbatchedComponents);\n}\n\nfunction updateComponents(queue) {\n  // Loop over the components in the queue and update them.\n  // NOTE: It is okay if the queue grows during the iteration\n  //       since we will still get to them at the end\n  for (var i = 0; i < queue.length; i++) {\n    var component = queue[i];\n    component.___update(); // Do the actual component update\n  }\n\n  // Clear out the queue by setting the length to zero\n  queue.length = 0;\n}\n\nfunction batchUpdate(func) {\n  // If the batched update stack is empty then this\n  // is the outer batched update. After the outer\n  // batched update completes we invoke the \"afterUpdate\"\n  // event listeners.\n  var batch = {\n    ___queue: null\n  };\n\n  batchStack.push(batch);\n\n  try {\n    func();\n  } finally {\n    try {\n      // Update all of the components that where queued up\n      // in this batch (if any)\n      if (batch.___queue) {\n        updateComponents(batch.___queue);\n      }\n    } finally {\n      // Now that we have completed the update of all the components\n      // in this batch we need to remove it off the top of the stack\n      batchStack.length--;\n    }\n  }\n}\n\nfunction queueComponentUpdate(component) {\n  var batchStackLen = batchStack.length;\n\n  if (batchStackLen) {\n    // When a batch update is started we push a new batch on to a stack.\n    // If the stack has a non-zero length then we know that a batch has\n    // been started so we can just queue the component on the top batch. When\n    // the batch is ended this component will be updated.\n    var batch = batchStack[batchStackLen - 1];\n\n    // We default the batch queue to null to avoid creating an Array instance\n    // unnecessarily. If it is null then we create a new Array, otherwise\n    // we push it onto the existing Array queue\n    if (batch.___queue) {\n      batch.___queue.push(component);\n    } else {\n      batch.___queue = [component];\n    }\n  } else {\n    // We are not within a batched update. We need to schedule a batch update\n    // for the nextTick (if that hasn't been done already) and we will\n    // add the component to the unbatched queued\n    scheduleUpdates();\n    unbatchedQueue.push(component);\n  }\n}\n\nexports.___queueComponentUpdate = queueComponentUpdate;\nexports.___batchUpdate = batchUpdate;\n","var domData = require(\"./dom-data\");\nvar componentsByDOMNode = domData.___componentByDOMNode;\nvar keysByDOMNode = domData.___keyByDOMNode;\nvar vElementsByDOMNode = domData.___vElementByDOMNode;\nvar vPropsByDOMNode = domData.___vPropsByDOMNode;\nvar markoUID = window.$MUID || (window.$MUID = { i: 0 });\nvar runtimeId = markoUID.i++;\n\nvar componentLookup = {};\n\nvar defaultDocument = document;\nvar EMPTY_OBJECT = {};\n\nfunction getComponentForEl(el, doc) {\n  var node =\n    typeof el == \"string\" ? (doc || defaultDocument).getElementById(el) : el;\n  var component;\n  var vElement;\n\n  while (node) {\n    if (node.fragment) {\n      if (node.fragment.endNode === node) {\n        node = node.fragment.startNode;\n      } else {\n        node = node.fragment;\n        component = componentsByDOMNode.get(node);\n      }\n    } else if ((vElement = vElementsByDOMNode.get(node))) {\n      component = vElement.___ownerComponent;\n    }\n\n    if (component) {\n      return component;\n    }\n\n    node = node.previousSibling || node.parentNode;\n  }\n}\n\nfunction destroyComponentForNode(node) {\n  var componentToDestroy = componentsByDOMNode.get(node.fragment || node);\n  if (componentToDestroy) {\n    componentToDestroy.___destroyShallow();\n    delete componentLookup[componentToDestroy.id];\n  }\n}\nfunction destroyNodeRecursive(node, component) {\n  destroyComponentForNode(node);\n  if (node.nodeType === 1 || node.nodeType === 12) {\n    var key;\n\n    if (component && (key = keysByDOMNode.get(node))) {\n      if (node === component.___keyedElements[key]) {\n        if (componentsByDOMNode.get(node) && /\\[\\]$/.test(key)) {\n          delete component.___keyedElements[key][\n            componentsByDOMNode.get(node).id\n          ];\n        } else {\n          delete component.___keyedElements[key];\n        }\n      }\n    }\n\n    var curChild = node.firstChild;\n    while (curChild && curChild !== node.endNode) {\n      destroyNodeRecursive(curChild, component);\n      curChild = curChild.nextSibling;\n    }\n  }\n}\n\nfunction nextComponentId() {\n  // Each component will get an ID that is unique across all loaded\n  // marko runtimes. This allows multiple instances of marko to be\n  // loaded in the same window and they should all place nice\n  // together\n  return \"c\" + markoUID.i++;\n}\n\nfunction nextComponentIdProvider() {\n  return nextComponentId;\n}\n\nfunction attachBubblingEvent(\n  componentDef,\n  handlerMethodName,\n  isOnce,\n  extraArgs\n) {\n  if (handlerMethodName) {\n    var componentId = componentDef.id;\n    if (extraArgs) {\n      return [handlerMethodName, componentId, isOnce, extraArgs];\n    } else {\n      return [handlerMethodName, componentId, isOnce];\n    }\n  }\n}\n\nfunction getMarkoPropsFromEl(el) {\n  var vElement = vElementsByDOMNode.get(el);\n  var virtualProps;\n\n  if (vElement) {\n    virtualProps = vElement.___properties;\n  } else {\n    virtualProps = vPropsByDOMNode.get(el);\n    if (!virtualProps) {\n      virtualProps = el.getAttribute(\"data-marko\");\n      vPropsByDOMNode.set(\n        el,\n        (virtualProps = virtualProps ? JSON.parse(virtualProps) : EMPTY_OBJECT)\n      );\n    }\n  }\n\n  return virtualProps;\n}\n\nfunction normalizeComponentKey(key, parentId) {\n  if (key[0] === \"#\") {\n    key = key.replace(\"#\" + parentId + \"-\", \"\");\n  }\n  return key;\n}\n\nfunction addComponentRootToKeyedElements(\n  keyedElements,\n  key,\n  rootNode,\n  componentId\n) {\n  if (/\\[\\]$/.test(key)) {\n    var repeatedElementsForKey = (keyedElements[key] =\n      keyedElements[key] || {});\n    repeatedElementsForKey[componentId] = rootNode;\n  } else {\n    keyedElements[key] = rootNode;\n  }\n}\n\n// eslint-disable-next-line no-constant-condition\nif (\"MARKO_DEBUG\") {\n  var warnNodeRemoved = function(event) {\n    var fragment = event.target.fragment;\n    if (fragment) {\n      var baseError = new Error(\n        \"Fragment boundary marker removed.  This will cause an error when the fragment is updated.\"\n      );\n      fragment.___markersRemovedError = function(message) {\n        var error = new Error(message + \" Boundary markers missing.\");\n\n        baseError.stack = baseError.stack.replace(/.*warnNodeRemoved.*\\n/, \"\");\n\n        // eslint-disable-next-line no-console\n        console.warn(baseError);\n        return error;\n      };\n    }\n  };\n  exports.___startDOMManipulationWarning = function() {\n    document.addEventListener(\"DOMNodeRemoved\", warnNodeRemoved);\n  };\n  exports.___stopDOMManipulationWarning = function() {\n    document.removeEventListener(\"DOMNodeRemoved\", warnNodeRemoved);\n  };\n}\n\nexports.___runtimeId = runtimeId;\nexports.___componentLookup = componentLookup;\nexports.___getComponentForEl = getComponentForEl;\nexports.___destroyComponentForNode = destroyComponentForNode;\nexports.___destroyNodeRecursive = destroyNodeRecursive;\nexports.___nextComponentIdProvider = nextComponentIdProvider;\nexports.___attachBubblingEvent = attachBubblingEvent;\nexports.___getMarkoPropsFromEl = getMarkoPropsFromEl;\nexports.___addComponentRootToKeyedElements = addComponentRootToKeyedElements;\nexports.___normalizeComponentKey = normalizeComponentKey;\n","var actualCreateOut;\n\nfunction setCreateOut(createOutFunc) {\n  actualCreateOut = createOutFunc;\n}\n\nfunction createOut(globalData) {\n  return actualCreateOut(globalData);\n}\n\ncreateOut.___setCreateOut = setCreateOut;\n\nmodule.exports = createOut;\n","var extend = require(\"raptor-util/extend\");\nvar componentsUtil = require(\"./components/util\");\nvar destroyComponentForNode = componentsUtil.___destroyComponentForNode;\nvar destroyNodeRecursive = componentsUtil.___destroyNodeRecursive;\nvar helpers = require(\"./vdom/morphdom/helpers\");\n\nvar insertBefore = helpers.___insertBefore;\nvar insertAfter = helpers.___insertAfter;\nvar removeChild = helpers.___removeChild;\n\nfunction resolveEl(el) {\n  if (typeof el == \"string\") {\n    var elId = el;\n    el = document.getElementById(elId);\n    if (!el) {\n      throw Error(\"Not found: \" + elId);\n    }\n  }\n  return el;\n}\n\nfunction beforeRemove(referenceEl) {\n  destroyNodeRecursive(referenceEl);\n  destroyComponentForNode(referenceEl);\n}\n\nmodule.exports = function(target, getEl, afterInsert) {\n  extend(target, {\n    appendTo: function(referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n      insertBefore(el, null, referenceEl);\n      return afterInsert(this, referenceEl);\n    },\n    prependTo: function(referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n      insertBefore(el, referenceEl.firstChild || null, referenceEl);\n      return afterInsert(this, referenceEl);\n    },\n    replace: function(referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n      beforeRemove(referenceEl);\n      insertBefore(el, referenceEl, referenceEl.parentNode);\n      removeChild(referenceEl);\n      return afterInsert(this, referenceEl);\n    },\n    replaceChildrenOf: function(referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n\n      var curChild = referenceEl.firstChild;\n      while (curChild) {\n        var nextSibling = curChild.nextSibling; // Just in case the DOM changes while removing\n        beforeRemove(curChild);\n        curChild = nextSibling;\n      }\n\n      referenceEl.innerHTML = \"\";\n      insertBefore(el, null, referenceEl);\n      return afterInsert(this, referenceEl);\n    },\n    insertBefore: function(referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n      insertBefore(el, referenceEl, referenceEl.parentNode);\n      return afterInsert(this, referenceEl);\n    },\n    insertAfter: function(referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n      insertAfter(el, referenceEl, referenceEl.parentNode);\n      return afterInsert(this, referenceEl);\n    }\n  });\n};\n","var counter = 0;\nvar seed = \"M\" + Math.random().toFixed(5);\nmodule.exports =\n  global.WeakMap ||\n  function WeakMap() {\n    var id = seed + counter++;\n    return {\n      get: function(ref) {\n        return ref[id];\n      },\n      set: function(ref, value) {\n        ref[id] = value;\n      }\n    };\n  };\n","module.exports =\n  global.setImmediate ||\n  (function() {\n    var queue = [];\n    var win = window;\n    var msg = \"\" + Math.random();\n    win.addEventListener(\"message\", function(ev) {\n      if (ev.data === msg) {\n        var callbacks = queue;\n        queue = [];\n        for (var i = 0; i < callbacks.length; i++) {\n          callbacks[i]();\n        }\n      }\n    });\n    return function(callback) {\n      if (queue.push(callback) === 1) {\n        win.postMessage(msg, \"*\");\n      }\n    };\n  })();\n","var VNode = require(\"./VNode\");\nvar inherit = require(\"raptor-util/inherit\");\n\nfunction VComponent(component, key, ownerComponent, preserve) {\n  this.___VNode(null /* childCount */, ownerComponent);\n  this.___key = key;\n  this.___component = component;\n  this.___preserve = preserve;\n}\n\nVComponent.prototype = {\n  ___nodeType: 2\n};\n\ninherit(VComponent, VNode);\n\nmodule.exports = VComponent;\n","var VNode = require(\"./VNode\");\nvar inherit = require(\"raptor-util/inherit\");\nvar extend = require(\"raptor-util/extend\");\n\nfunction VDocumentFragmentClone(other) {\n  extend(this, other);\n  this.___parentNode = null;\n  this.___nextSiblingInternal = null;\n}\n\nfunction VDocumentFragment(out) {\n  this.___VNode(null /* childCount */);\n  this.___out = out;\n}\n\nVDocumentFragment.prototype = {\n  ___nodeType: 11,\n\n  ___DocumentFragment: true,\n\n  ___cloneNode: function() {\n    return new VDocumentFragmentClone(this);\n  },\n\n  ___actualize: function(doc) {\n    return doc.createDocumentFragment();\n  }\n};\n\ninherit(VDocumentFragment, VNode);\n\nVDocumentFragmentClone.prototype = VDocumentFragment.prototype;\n\nmodule.exports = VDocumentFragment;\n","/* jshint newcap:false */\n\nvar domData = require(\"../components/dom-data\");\nvar componentsUtil = require(\"../components/util\");\nvar vElementByDOMNode = domData.___vElementByDOMNode;\nvar VNode = require(\"./VNode\");\nvar inherit = require(\"raptor-util/inherit\");\nvar ATTR_XLINK_HREF = \"xlink:href\";\nvar xmlnsRegExp = /^xmlns(:|$)/;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar NS_XLINK = \"http://www.w3.org/1999/xlink\";\nvar NS_HTML = \"http://www.w3.org/1999/xhtml\";\nvar NS_MATH = \"http://www.w3.org/1998/Math/MathML\";\nvar NS_SVG = \"http://www.w3.org/2000/svg\";\nvar DEFAULT_NS = {\n  svg: NS_SVG,\n  math: NS_MATH\n};\n\nvar FLAG_SIMPLE_ATTRS = 1;\nvar FLAG_CUSTOM_ELEMENT = 2;\nvar FLAG_SPREAD_ATTRS = 4;\n\nvar defineProperty = Object.defineProperty;\n\nvar ATTR_HREF = \"href\";\nvar EMPTY_OBJECT = Object.freeze({});\n\nfunction convertAttrValue(type, value) {\n  if (value === true) {\n    return \"\";\n  } else if (type == \"object\") {\n    if (value instanceof RegExp) {\n      return value.source;\n    }\n  }\n\n  return value + \"\";\n}\n\nfunction assign(a, b) {\n  for (var key in b) {\n    if (hasOwnProperty.call(b, key)) {\n      a[key] = b[key];\n    }\n  }\n}\n\nfunction setAttribute(el, namespaceURI, name, value) {\n  if (namespaceURI === null) {\n    el.setAttribute(name, value);\n  } else {\n    el.setAttributeNS(namespaceURI, name, value);\n  }\n}\n\nfunction removeAttribute(el, namespaceURI, name) {\n  if (namespaceURI === null) {\n    el.removeAttribute(name);\n  } else {\n    el.removeAttributeNS(namespaceURI, name);\n  }\n}\n\nfunction VElementClone(other) {\n  this.___firstChildInternal = other.___firstChildInternal;\n  this.___parentNode = null;\n  this.___nextSiblingInternal = null;\n\n  this.___key = other.___key;\n  this.___attributes = other.___attributes;\n  this.___properties = other.___properties;\n  this.___nodeName = other.___nodeName;\n  this.___flags = other.___flags;\n  this.___valueInternal = other.___valueInternal;\n  this.___constId = other.___constId;\n}\n\nfunction VElement(\n  tagName,\n  attrs,\n  key,\n  ownerComponent,\n  childCount,\n  flags,\n  props\n) {\n  this.___VNode(childCount, ownerComponent);\n\n  var constId;\n\n  if (props) {\n    constId = props.i;\n  }\n\n  this.___key = key;\n  this.___flags = flags || 0;\n  this.___attributes = attrs || EMPTY_OBJECT;\n  this.___properties = props || EMPTY_OBJECT;\n  this.___nodeName = tagName;\n  this.___valueInternal = null;\n  this.___constId = constId;\n  this.___preserve = false;\n  this.___preserveBody = false;\n}\n\nVElement.prototype = {\n  ___nodeType: 1,\n\n  ___cloneNode: function() {\n    return new VElementClone(this);\n  },\n\n  /**\n   * Shorthand method for creating and appending an HTML element\n   *\n   * @param  {String} tagName    The tag name (e.g. \"div\")\n   * @param  {int|null} attrCount  The number of attributes (or `null` if not known)\n   * @param  {int|null} childCount The number of child nodes (or `null` if not known)\n   */\n  e: function(tagName, attrs, key, ownerComponent, childCount, flags, props) {\n    var child = this.___appendChild(\n      new VElement(\n        tagName,\n        attrs,\n        key,\n        ownerComponent,\n        childCount,\n        flags,\n        props\n      )\n    );\n\n    if (childCount === 0) {\n      return this.___finishChild();\n    } else {\n      return child;\n    }\n  },\n\n  /**\n   * Shorthand method for creating and appending a static node. The provided node is automatically cloned\n   * using a shallow clone since it will be mutated as a result of setting `nextSibling` and `parentNode`.\n   *\n   * @param  {String} value The value for the new Comment node\n   */\n  n: function(node, ownerComponent) {\n    node = node.___cloneNode();\n    node.___ownerComponent = ownerComponent;\n    this.___appendChild(node);\n    return this.___finishChild();\n  },\n\n  ___actualize: function(doc, parentNamespaceURI) {\n    var tagName = this.___nodeName;\n    var attributes = this.___attributes;\n    var namespaceURI = DEFAULT_NS[tagName] || parentNamespaceURI || NS_HTML;\n\n    var flags = this.___flags;\n    var el = doc.createElementNS(namespaceURI, tagName);\n\n    if (flags & FLAG_CUSTOM_ELEMENT) {\n      assign(el, attributes);\n    } else {\n      for (var attrName in attributes) {\n        var attrValue = attributes[attrName];\n\n        if (attrValue !== false && attrValue != null) {\n          var type = typeof attrValue;\n\n          if (type !== \"string\") {\n            // Special attributes aren't copied to the real DOM. They are only\n            // kept in the virtual attributes map\n            attrValue = convertAttrValue(type, attrValue);\n          }\n\n          if (attrName == ATTR_XLINK_HREF) {\n            setAttribute(el, NS_XLINK, ATTR_HREF, attrValue);\n          } else {\n            el.setAttribute(attrName, attrValue);\n          }\n        }\n      }\n\n      if (tagName === \"textarea\") {\n        el.defaultValue = el.value = this.___value;\n      }\n    }\n\n    vElementByDOMNode.set(el, this);\n\n    return el;\n  },\n\n  ___hasAttribute: function(name) {\n    // We don't care about the namespaces since the there\n    // is no chance that attributes with the same name will have\n    // different namespaces\n    var value = this.___attributes[name];\n    return value != null && value !== false;\n  }\n};\n\ninherit(VElement, VNode);\n\nvar proto = (VElementClone.prototype = VElement.prototype);\n\n[\"checked\", \"selected\", \"disabled\"].forEach(function(name) {\n  defineProperty(proto, name, {\n    get: function() {\n      var value = this.___attributes[name];\n      return value !== false && value != null;\n    }\n  });\n});\n\ndefineProperty(proto, \"___value\", {\n  get: function() {\n    var value = this.___valueInternal;\n    if (value == null) {\n      value = this.___attributes.value;\n    }\n    return value != null && value !== false\n      ? value + \"\"\n      : this.___attributes.type === \"checkbox\" ||\n        this.___attributes.type === \"radio\"\n      ? \"on\"\n      : \"\";\n  }\n});\n\nVElement.___removePreservedAttributes = function(attrs) {\n  // By default this static method is a no-op, but if there are any\n  // compiled components that have \"no-update\" attributes then\n  // `preserve-attrs.js` will be imported and this method will be replaced\n  // with a method that actually does something\n  return attrs;\n};\n\nfunction virtualizeElement(node, virtualizeChildNodes, ownerComponent) {\n  var attributes = node.attributes;\n  var attrCount = attributes.length;\n\n  var attrs = null;\n  var props = null;\n\n  if (attrCount) {\n    attrs = {};\n    for (var i = 0; i < attrCount; i++) {\n      var attr = attributes[i];\n      var attrName = attr.name;\n      if (!xmlnsRegExp.test(attrName)) {\n        if (attrName === \"data-marko\") {\n          props = componentsUtil.___getMarkoPropsFromEl(node);\n        } else if (attr.namespaceURI === NS_XLINK) {\n          attrs[ATTR_XLINK_HREF] = attr.value;\n        } else {\n          attrs[attrName] = attr.value;\n        }\n      }\n    }\n  }\n\n  var tagName = node.nodeName;\n\n  if (node.namespaceURI === NS_HTML) {\n    tagName = tagName.toLowerCase();\n  }\n\n  var vdomEl = new VElement(\n    tagName,\n    attrs,\n    null /*key*/,\n    ownerComponent,\n    0 /*child count*/,\n    0 /*flags*/,\n    props\n  );\n\n  if (vdomEl.___nodeName === \"textarea\") {\n    vdomEl.___valueInternal = node.value;\n  } else if (virtualizeChildNodes) {\n    virtualizeChildNodes(node, vdomEl, ownerComponent);\n  }\n\n  return vdomEl;\n}\n\nVElement.___virtualize = virtualizeElement;\n\nVElement.___morphAttrs = function(fromEl, vFromEl, toEl) {\n  var removePreservedAttributes = VElement.___removePreservedAttributes;\n\n  var fromFlags = vFromEl.___flags;\n  var toFlags = toEl.___flags;\n\n  vElementByDOMNode.set(fromEl, toEl);\n\n  var attrs = toEl.___attributes;\n  var props = toEl.___properties;\n\n  if (toFlags & FLAG_CUSTOM_ELEMENT) {\n    return assign(fromEl, attrs);\n  }\n\n  var attrName;\n\n  // We use expando properties to associate the previous HTML\n  // attributes provided as part of the VDOM node with the\n  // real VElement DOM node. When diffing attributes,\n  // we only use our internal representation of the attributes.\n  // When diffing for the first time it's possible that the\n  // real VElement node will not have the expando property\n  // so we build the attribute map from the expando property\n\n  var oldAttrs = vFromEl.___attributes;\n\n  if (oldAttrs) {\n    if (oldAttrs === attrs) {\n      // For constant attributes the same object will be provided\n      // every render and we can use that to our advantage to\n      // not waste time diffing a constant, immutable attribute\n      // map.\n      return;\n    } else {\n      oldAttrs = removePreservedAttributes(oldAttrs, props);\n    }\n  }\n\n  var attrValue;\n\n  if (toFlags & FLAG_SIMPLE_ATTRS && fromFlags & FLAG_SIMPLE_ATTRS) {\n    if (oldAttrs[\"class\"] !== (attrValue = attrs[\"class\"])) {\n      fromEl.className = attrValue;\n    }\n    if (oldAttrs.id !== (attrValue = attrs.id)) {\n      fromEl.id = attrValue;\n    }\n    if (oldAttrs.style !== (attrValue = attrs.style)) {\n      fromEl.style.cssText = attrValue;\n    }\n    return;\n  }\n\n  // In some cases we only want to set an attribute value for the first\n  // render or we don't want certain attributes to be touched. To support\n  // that use case we delete out all of the preserved attributes\n  // so it's as if they never existed.\n  attrs = removePreservedAttributes(attrs, props, true);\n\n  var namespaceURI;\n\n  // Loop over all of the attributes in the attribute map and compare\n  // them to the value in the old map. However, if the value is\n  // null/undefined/false then we want to remove the attribute\n  for (attrName in attrs) {\n    attrValue = attrs[attrName];\n    namespaceURI = null;\n\n    if (attrName === ATTR_XLINK_HREF) {\n      namespaceURI = NS_XLINK;\n      attrName = ATTR_HREF;\n    }\n\n    if (attrValue == null || attrValue === false) {\n      removeAttribute(fromEl, namespaceURI, attrName);\n    } else if (oldAttrs[attrName] !== attrValue) {\n      var type = typeof attrValue;\n\n      if (type !== \"string\") {\n        attrValue = convertAttrValue(type, attrValue);\n      }\n\n      setAttribute(fromEl, namespaceURI, attrName, attrValue);\n    }\n  }\n\n  // If there are any old attributes that are not in the new set of attributes\n  // then we need to remove those attributes from the target node\n  //\n  // NOTE: We can skip this if the the element is keyed and didn't have spread attributes\n  //       because we know we already processed all of the attributes for\n  //       both the target and original element since target VElement nodes will\n  //       have all attributes declared. However, we can only skip if the node\n  //       was not a virtualized node (i.e., a node that was not rendered by a\n  //       Marko template, but rather a node that was created from an HTML\n  //       string or a real DOM node).\n  if (toEl.___key === null || fromFlags & FLAG_SPREAD_ATTRS) {\n    for (attrName in oldAttrs) {\n      if (!(attrName in attrs)) {\n        if (attrName === ATTR_XLINK_HREF) {\n          fromEl.removeAttributeNS(ATTR_XLINK_HREF, ATTR_HREF);\n        } else {\n          fromEl.removeAttribute(attrName);\n        }\n      }\n    }\n  }\n};\n\nmodule.exports = VElement;\n","var domData = require(\"../components/dom-data\");\nvar keysByDOMNode = domData.___keyByDOMNode;\nvar vElementByDOMNode = domData.___vElementByDOMNode;\nvar VNode = require(\"./VNode\");\nvar inherit = require(\"raptor-util/inherit\");\nvar createFragmentNode = require(\"./morphdom/fragment\").___createFragmentNode;\n\nfunction VFragment(key, ownerComponent, preserve) {\n  this.___VNode(null /* childCount */, ownerComponent);\n  this.___key = key;\n  this.___preserve = preserve;\n}\n\nVFragment.prototype = {\n  ___nodeType: 12,\n  ___actualize: function() {\n    var fragment = createFragmentNode();\n    keysByDOMNode.set(fragment, this.___key);\n    vElementByDOMNode.set(fragment, this);\n    return fragment;\n  }\n};\n\ninherit(VFragment, VNode);\n\nmodule.exports = VFragment;\n","/* jshint newcap:false */\nfunction VNode() {}\n\nVNode.prototype = {\n  ___VNode: function(finalChildCount, ownerComponent) {\n    this.___finalChildCount = finalChildCount;\n    this.___childCount = 0;\n    this.___firstChildInternal = null;\n    this.___lastChild = null;\n    this.___parentNode = null;\n    this.___nextSiblingInternal = null;\n    this.___ownerComponent = ownerComponent;\n  },\n\n  get ___firstChild() {\n    var firstChild = this.___firstChildInternal;\n\n    if (firstChild && firstChild.___DocumentFragment) {\n      var nestedFirstChild = firstChild.___firstChild;\n      // The first child is a DocumentFragment node.\n      // If the DocumentFragment node has a first child then we will return that.\n      // Otherwise, the DocumentFragment node is not *really* the first child and\n      // we need to skip to its next sibling\n      return nestedFirstChild || firstChild.___nextSibling;\n    }\n\n    return firstChild;\n  },\n\n  get ___nextSibling() {\n    var nextSibling = this.___nextSiblingInternal;\n\n    if (nextSibling) {\n      if (nextSibling.___DocumentFragment) {\n        var firstChild = nextSibling.___firstChild;\n        return firstChild || nextSibling.___nextSibling;\n      }\n    } else {\n      var parentNode = this.___parentNode;\n      if (parentNode && parentNode.___DocumentFragment) {\n        return parentNode.___nextSibling;\n      }\n    }\n\n    return nextSibling;\n  },\n\n  ___appendChild: function(child) {\n    this.___childCount++;\n\n    if (this.___nodeName === \"textarea\") {\n      if (child.___Text) {\n        var childValue = child.___nodeValue;\n        this.___valueInternal = (this.___valueInternal || \"\") + childValue;\n      } else if (child.___preserve || child.___preserveBody) {\n        this.___preserveTextAreaValue = true;\n      } else {\n        throw TypeError();\n      }\n    } else {\n      var lastChild = this.___lastChild;\n\n      child.___parentNode = this;\n\n      if (lastChild) {\n        lastChild.___nextSiblingInternal = child;\n      } else {\n        this.___firstChildInternal = child;\n      }\n\n      this.___lastChild = child;\n    }\n\n    return child;\n  },\n\n  ___finishChild: function finishChild() {\n    if (this.___childCount === this.___finalChildCount && this.___parentNode) {\n      return this.___parentNode.___finishChild();\n    } else {\n      return this;\n    }\n  }\n\n  // ,toJSON: function() {\n  //     var clone = Object.assign({\n  //         nodeType: this.nodeType\n  //     }, this);\n  //\n  //     for (var k in clone) {\n  //         if (k.startsWith('_')) {\n  //             delete clone[k];\n  //         }\n  //     }\n  //     delete clone._nextSibling;\n  //     delete clone._lastChild;\n  //     delete clone.parentNode;\n  //     return clone;\n  // }\n};\n\nmodule.exports = VNode;\n","var VNode = require(\"./VNode\");\nvar inherit = require(\"raptor-util/inherit\");\n\nfunction VText(value, ownerComponent) {\n  this.___VNode(-1 /* no children */, ownerComponent);\n  this.___nodeValue = value;\n}\n\nVText.prototype = {\n  ___Text: true,\n\n  ___nodeType: 3,\n\n  ___actualize: function(doc) {\n    return doc.createTextNode(this.___nodeValue);\n  },\n\n  ___cloneNode: function() {\n    return new VText(this.___nodeValue);\n  }\n};\n\ninherit(VText, VNode);\n\nmodule.exports = VText;\n","var helpers = require(\"./helpers\");\nvar insertBefore = helpers.___insertBefore;\n\nvar fragmentPrototype = {\n  nodeType: 12,\n  get firstChild() {\n    var firstChild = this.startNode.nextSibling;\n    return firstChild === this.endNode ? undefined : firstChild;\n  },\n  get lastChild() {\n    var lastChild = this.endNode.previousSibling;\n    return lastChild === this.startNode ? undefined : lastChild;\n  },\n  get parentNode() {\n    var parentNode = this.startNode.parentNode;\n    return parentNode === this.detachedContainer ? undefined : parentNode;\n  },\n  get namespaceURI() {\n    return this.startNode.parentNode.namespaceURI;\n  },\n  get nextSibling() {\n    return this.endNode.nextSibling;\n  },\n  get nodes() {\n    // eslint-disable-next-line no-constant-condition\n    if (\"MARKO_DEBUG\") {\n      if (this.___markersRemovedError) {\n        throw this.___markersRemovedError(\"Cannot get fragment nodes.\");\n      }\n    }\n    var nodes = [];\n    var current = this.startNode;\n    while (current !== this.endNode) {\n      nodes.push(current);\n      current = current.nextSibling;\n    }\n    nodes.push(current);\n    return nodes;\n  },\n  insertBefore: function(newChildNode, referenceNode) {\n    var actualReference = referenceNode == null ? this.endNode : referenceNode;\n    return insertBefore(\n      newChildNode,\n      actualReference,\n      this.startNode.parentNode\n    );\n  },\n  insertInto: function(newParentNode, referenceNode) {\n    this.nodes.forEach(function(node) {\n      insertBefore(node, referenceNode, newParentNode);\n    }, this);\n    return this;\n  },\n  remove: function() {\n    this.nodes.forEach(function(node) {\n      this.detachedContainer.appendChild(node);\n    }, this);\n  }\n};\n\nfunction createFragmentNode(startNode, nextNode, parentNode) {\n  var fragment = Object.create(fragmentPrototype);\n  var isRoot = startNode && startNode.ownerDocument === startNode.parentNode;\n  fragment.startNode = isRoot\n    ? document.createComment(\"\")\n    : document.createTextNode(\"\");\n  fragment.endNode = isRoot\n    ? document.createComment(\"\")\n    : document.createTextNode(\"\");\n  fragment.startNode.fragment = fragment;\n  fragment.endNode.fragment = fragment;\n  var detachedContainer = (fragment.detachedContainer = document.createDocumentFragment());\n  parentNode =\n    parentNode || (startNode && startNode.parentNode) || detachedContainer;\n  insertBefore(fragment.startNode, startNode, parentNode);\n  insertBefore(fragment.endNode, nextNode, parentNode);\n  return fragment;\n}\n\nfunction beginFragmentNode(startNode, parentNode) {\n  var fragment = createFragmentNode(startNode, null, parentNode);\n  fragment.___finishFragment = function(nextNode) {\n    fragment.___finishFragment = null;\n    insertBefore(\n      fragment.endNode,\n      nextNode,\n      parentNode || startNode.parentNode\n    );\n  };\n  return fragment;\n}\n\nexports.___createFragmentNode = createFragmentNode;\nexports.___beginFragmentNode = beginFragmentNode;\n","function insertBefore(node, referenceNode, parentNode) {\n  if (node.insertInto) {\n    return node.insertInto(parentNode, referenceNode);\n  }\n  return parentNode.insertBefore(\n    node,\n    (referenceNode && referenceNode.startNode) || referenceNode\n  );\n}\n\nfunction insertAfter(node, referenceNode, parentNode) {\n  return insertBefore(\n    node,\n    referenceNode && referenceNode.nextSibling,\n    parentNode\n  );\n}\n\nfunction nextSibling(node) {\n  var next = node.nextSibling;\n  var fragment = next && next.fragment;\n  if (fragment) {\n    return next === fragment.startNode ? fragment : null;\n  }\n  return next;\n}\n\nfunction firstChild(node) {\n  var next = node.firstChild;\n  return (next && next.fragment) || next;\n}\n\nfunction removeChild(node) {\n  if (node.remove) node.remove();\n  else node.parentNode.removeChild(node);\n}\n\nexports.___insertBefore = insertBefore;\nexports.___insertAfter = insertAfter;\nexports.___nextSibling = nextSibling;\nexports.___firstChild = firstChild;\nexports.___removeChild = removeChild;\n","\"use strict\";\nvar specialElHandlers = require(\"./specialElHandlers\");\nvar KeySequence = require(\"../../components/KeySequence\");\nvar componentsUtil = require(\"../../components/util\");\nvar existingComponentLookup = componentsUtil.___componentLookup;\nvar destroyNodeRecursive = componentsUtil.___destroyNodeRecursive;\nvar addComponentRootToKeyedElements =\n  componentsUtil.___addComponentRootToKeyedElements;\nvar normalizeComponentKey = componentsUtil.___normalizeComponentKey;\nvar VElement = require(\"../vdom\").___VElement;\nvar virtualizeElement = VElement.___virtualize;\nvar morphAttrs = VElement.___morphAttrs;\nvar eventDelegation = require(\"../../components/event-delegation\");\nvar fragment = require(\"./fragment\");\nvar helpers = require(\"./helpers\");\nvar domData = require(\"../../components/dom-data\");\nvar keysByDOMNode = domData.___keyByDOMNode;\nvar componentByDOMNode = domData.___componentByDOMNode;\nvar vElementByDOMNode = domData.___vElementByDOMNode;\nvar detachedByDOMNode = domData.___detachedByDOMNode;\n\nvar insertBefore = helpers.___insertBefore;\nvar insertAfter = helpers.___insertAfter;\nvar nextSibling = helpers.___nextSibling;\nvar firstChild = helpers.___firstChild;\nvar removeChild = helpers.___removeChild;\nvar createFragmentNode = fragment.___createFragmentNode;\nvar beginFragmentNode = fragment.___beginFragmentNode;\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar COMPONENT_NODE = 2;\nvar FRAGMENT_NODE = 12;\nvar DOCTYPE_NODE = 10;\n\n// var FLAG_SIMPLE_ATTRS = 1;\n// var FLAG_CUSTOM_ELEMENT = 2;\n// var FLAG_SPREAD_ATTRS = 4;\n\nfunction isAutoKey(key) {\n  return key[0] !== \"@\";\n}\n\nfunction compareNodeNames(fromEl, toEl) {\n  return fromEl.___nodeName === toEl.___nodeName;\n}\n\nfunction caseInsensitiveCompare(a, b) {\n  return a.toLowerCase() === b.toLowerCase();\n}\n\nfunction onNodeAdded(node, componentsContext) {\n  if (node.nodeType === ELEMENT_NODE) {\n    eventDelegation.___handleNodeAttach(node, componentsContext);\n  }\n}\n\nfunction morphdom(fromNode, toNode, doc, componentsContext) {\n  var globalComponentsContext;\n  var isHydrate = false;\n  var keySequences = Object.create(null);\n\n  if (componentsContext) {\n    globalComponentsContext = componentsContext.___globalContext;\n    isHydrate = globalComponentsContext.___isHydrate;\n  }\n\n  function insertVirtualNodeBefore(\n    vNode,\n    key,\n    referenceEl,\n    parentEl,\n    ownerComponent,\n    parentComponent\n  ) {\n    var realNode = vNode.___actualize(doc, parentEl.namespaceURI);\n    insertBefore(realNode, referenceEl, parentEl);\n\n    if (\n      vNode.___nodeType === ELEMENT_NODE ||\n      vNode.___nodeType === FRAGMENT_NODE\n    ) {\n      if (key) {\n        keysByDOMNode.set(realNode, key);\n        (isAutoKey(key) ? parentComponent : ownerComponent).___keyedElements[\n          key\n        ] = realNode;\n      }\n\n      if (vNode.___nodeName !== \"textarea\") {\n        morphChildren(realNode, vNode, parentComponent);\n      }\n\n      onNodeAdded(realNode, componentsContext);\n    }\n  }\n\n  function insertVirtualComponentBefore(\n    vComponent,\n    referenceNode,\n    referenceNodeParentEl,\n    component,\n    key,\n    ownerComponent,\n    parentComponent\n  ) {\n    var rootNode = (component.___rootNode = insertBefore(\n      createFragmentNode(),\n      referenceNode,\n      referenceNodeParentEl\n    ));\n    componentByDOMNode.set(rootNode, component);\n\n    if (key && ownerComponent) {\n      key = normalizeComponentKey(key, parentComponent.id);\n      addComponentRootToKeyedElements(\n        ownerComponent.___keyedElements,\n        key,\n        rootNode,\n        component.id\n      );\n      keysByDOMNode.set(rootNode, key);\n    }\n\n    morphComponent(component, vComponent);\n  }\n\n  function morphComponent(component, vComponent) {\n    morphChildren(component.___rootNode, vComponent, component);\n  }\n\n  var detachedNodes = [];\n\n  function detachNode(node, parentNode, ownerComponent) {\n    if (node.nodeType === ELEMENT_NODE || node.nodeType === FRAGMENT_NODE) {\n      detachedNodes.push(node);\n      detachedByDOMNode.set(node, ownerComponent || true);\n    } else {\n      destroyNodeRecursive(node);\n      removeChild(node);\n    }\n  }\n\n  function destroyComponent(component) {\n    component.destroy();\n  }\n\n  function morphChildren(fromNode, toNode, parentComponent) {\n    var curFromNodeChild = firstChild(fromNode);\n    var curToNodeChild = toNode.___firstChild;\n\n    var curToNodeKey;\n    var curFromNodeKey;\n    var curToNodeType;\n\n    var fromNextSibling;\n    var toNextSibling;\n    var matchingFromEl;\n    var matchingFromComponent;\n    var curVFromNodeChild;\n    var fromComponent;\n\n    outer: while (curToNodeChild) {\n      toNextSibling = curToNodeChild.___nextSibling;\n      curToNodeType = curToNodeChild.___nodeType;\n      curToNodeKey = curToNodeChild.___key;\n\n      // Skip <!doctype>\n      if (curFromNodeChild && curFromNodeChild.nodeType === DOCTYPE_NODE) {\n        curFromNodeChild = nextSibling(curFromNodeChild);\n      }\n\n      var ownerComponent = curToNodeChild.___ownerComponent || parentComponent;\n      var referenceComponent;\n\n      if (curToNodeType === COMPONENT_NODE) {\n        var component = curToNodeChild.___component;\n        if (\n          (matchingFromComponent = existingComponentLookup[component.id]) ===\n          undefined\n        ) {\n          if (isHydrate === true) {\n            var rootNode = beginFragmentNode(curFromNodeChild, fromNode);\n            component.___rootNode = rootNode;\n            componentByDOMNode.set(rootNode, component);\n\n            if (ownerComponent && curToNodeKey) {\n              curToNodeKey = normalizeComponentKey(\n                curToNodeKey,\n                parentComponent.id\n              );\n              addComponentRootToKeyedElements(\n                ownerComponent.___keyedElements,\n                curToNodeKey,\n                rootNode,\n                component.id\n              );\n\n              keysByDOMNode.set(rootNode, curToNodeKey);\n            }\n\n            morphComponent(component, curToNodeChild);\n\n            curFromNodeChild = nextSibling(rootNode);\n          } else {\n            insertVirtualComponentBefore(\n              curToNodeChild,\n              curFromNodeChild,\n              fromNode,\n              component,\n              curToNodeKey,\n              ownerComponent,\n              parentComponent\n            );\n          }\n        } else {\n          if (matchingFromComponent.___rootNode !== curFromNodeChild) {\n            if (\n              curFromNodeChild &&\n              (fromComponent = componentByDOMNode.get(curFromNodeChild)) &&\n              globalComponentsContext.___renderedComponentsById[\n                fromComponent.id\n              ] === undefined\n            ) {\n              // The component associated with the current real DOM node was not rendered\n              // so we should just remove it out of the real DOM by destroying it\n              curFromNodeChild = nextSibling(fromComponent.___rootNode);\n              destroyComponent(fromComponent);\n              continue;\n            }\n\n            // We need to move the existing component into\n            // the correct location\n            insertBefore(\n              matchingFromComponent.___rootNode,\n              curFromNodeChild,\n              fromNode\n            );\n          } else {\n            curFromNodeChild =\n              curFromNodeChild && nextSibling(curFromNodeChild);\n          }\n\n          if (!curToNodeChild.___preserve) {\n            morphComponent(component, curToNodeChild);\n          }\n        }\n\n        curToNodeChild = toNextSibling;\n        continue;\n      } else if (curToNodeKey) {\n        curVFromNodeChild = undefined;\n        curFromNodeKey = undefined;\n        var curToNodeKeyOriginal = curToNodeKey;\n\n        if (isAutoKey(curToNodeKey)) {\n          if (ownerComponent !== parentComponent) {\n            curToNodeKey += \":\" + ownerComponent.id;\n          }\n          referenceComponent = parentComponent;\n        } else {\n          referenceComponent = ownerComponent;\n        }\n\n        // We have a keyed element. This is the fast path for matching\n        // up elements\n        curToNodeKey = (\n          keySequences[referenceComponent.id] ||\n          (keySequences[referenceComponent.id] = new KeySequence())\n        ).___nextKey(curToNodeKey);\n\n        if (curFromNodeChild) {\n          curFromNodeKey = keysByDOMNode.get(curFromNodeChild);\n          curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);\n          fromNextSibling = nextSibling(curFromNodeChild);\n        }\n\n        if (curFromNodeKey === curToNodeKey) {\n          // Elements line up. Now we just have to make sure they are compatible\n          if (!curToNodeChild.___preserve) {\n            // We just skip over the fromNode if it is preserved\n\n            if (compareNodeNames(curToNodeChild, curVFromNodeChild)) {\n              morphEl(\n                curFromNodeChild,\n                curVFromNodeChild,\n                curToNodeChild,\n                parentComponent\n              );\n            } else {\n              // Remove the old node\n              detachNode(curFromNodeChild, fromNode, ownerComponent);\n\n              // Incompatible nodes. Just move the target VNode into the DOM at this position\n              insertVirtualNodeBefore(\n                curToNodeChild,\n                curToNodeKey,\n                curFromNodeChild,\n                fromNode,\n                ownerComponent,\n                parentComponent\n              );\n            }\n          }\n        } else {\n          matchingFromEl = referenceComponent.___keyedElements[curToNodeKey];\n          if (\n            matchingFromEl === undefined ||\n            matchingFromEl === curFromNodeChild\n          ) {\n            if (isHydrate === true && curFromNodeChild) {\n              if (\n                curFromNodeChild.nodeType === ELEMENT_NODE &&\n                (curToNodeChild.___preserve ||\n                  caseInsensitiveCompare(\n                    curFromNodeChild.nodeName,\n                    curToNodeChild.___nodeName || \"\"\n                  ))\n              ) {\n                curVFromNodeChild = virtualizeElement(curFromNodeChild);\n                curVFromNodeChild.___nodeName = curToNodeChild.___nodeName;\n                keysByDOMNode.set(curFromNodeChild, curToNodeKey);\n                referenceComponent.___keyedElements[\n                  curToNodeKey\n                ] = curFromNodeChild;\n\n                if (curToNodeChild.___preserve) {\n                  vElementByDOMNode.set(curFromNodeChild, curVFromNodeChild);\n                } else {\n                  morphEl(\n                    curFromNodeChild,\n                    curVFromNodeChild,\n                    curToNodeChild,\n                    parentComponent\n                  );\n                }\n\n                curToNodeChild = toNextSibling;\n                curFromNodeChild = fromNextSibling;\n                continue;\n              } else if (\n                curToNodeChild.___nodeType === FRAGMENT_NODE &&\n                curFromNodeChild.nodeType === COMMENT_NODE\n              ) {\n                var content = curFromNodeChild.nodeValue;\n                if (content == \"F#\" + curToNodeKeyOriginal) {\n                  var endNode = curFromNodeChild.nextSibling;\n                  var depth = 0;\n                  var nodeValue;\n\n                  // eslint-disable-next-line no-constant-condition\n                  while (true) {\n                    if (endNode.nodeType === COMMENT_NODE) {\n                      nodeValue = endNode.nodeValue;\n                      if (nodeValue === \"F/\") {\n                        if (depth === 0) {\n                          break;\n                        } else {\n                          depth--;\n                        }\n                      } else if (nodeValue.indexOf(\"F#\") === 0) {\n                        depth++;\n                      }\n                    }\n                    endNode = endNode.nextSibling;\n                  }\n\n                  var fragment = createFragmentNode(\n                    curFromNodeChild,\n                    endNode.nextSibling,\n                    fromNode\n                  );\n                  keysByDOMNode.set(fragment, curToNodeKey);\n                  vElementByDOMNode.set(fragment, curToNodeChild);\n                  referenceComponent.___keyedElements[curToNodeKey] = fragment;\n                  removeChild(curFromNodeChild);\n                  removeChild(endNode);\n\n                  if (!curToNodeChild.___preserve) {\n                    morphChildren(fragment, curToNodeChild, parentComponent);\n                  }\n\n                  curToNodeChild = toNextSibling;\n                  curFromNodeChild = fragment.nextSibling;\n                  continue;\n                }\n              }\n            }\n\n            insertVirtualNodeBefore(\n              curToNodeChild,\n              curToNodeKey,\n              curFromNodeChild,\n              fromNode,\n              ownerComponent,\n              parentComponent\n            );\n            fromNextSibling = curFromNodeChild;\n          } else {\n            if (detachedByDOMNode.get(matchingFromEl) !== undefined) {\n              detachedByDOMNode.set(matchingFromEl, undefined);\n            }\n\n            if (!curToNodeChild.___preserve) {\n              curVFromNodeChild = vElementByDOMNode.get(matchingFromEl);\n\n              if (compareNodeNames(curVFromNodeChild, curToNodeChild)) {\n                if (fromNextSibling === matchingFromEl) {\n                  // Single element removal:\n                  // A <-> A\n                  // B <-> C <-- We are here\n                  // C     D\n                  // D\n                  //\n                  // Single element swap:\n                  // A <-> A\n                  // B <-> C <-- We are here\n                  // C     B\n\n                  if (\n                    toNextSibling &&\n                    toNextSibling.___key === curFromNodeKey\n                  ) {\n                    // Single element swap\n\n                    // We want to stay on the current real DOM node\n                    fromNextSibling = curFromNodeChild;\n\n                    // But move the matching element into place\n                    insertBefore(matchingFromEl, curFromNodeChild, fromNode);\n                  } else {\n                    // Single element removal\n\n                    // We need to remove the current real DOM node\n                    // and the matching real DOM node will fall into\n                    // place. We will continue diffing with next sibling\n                    // after the real DOM node that just fell into place\n                    fromNextSibling = nextSibling(fromNextSibling);\n\n                    if (curFromNodeChild) {\n                      detachNode(curFromNodeChild, fromNode, ownerComponent);\n                    }\n                  }\n                } else {\n                  // A <-> A\n                  // B <-> D <-- We are here\n                  // C\n                  // D\n\n                  // We need to move the matching node into place\n                  insertAfter(matchingFromEl, curFromNodeChild, fromNode);\n\n                  if (curFromNodeChild) {\n                    detachNode(curFromNodeChild, fromNode, ownerComponent);\n                  }\n                }\n\n                morphEl(\n                  matchingFromEl,\n                  curVFromNodeChild,\n                  curToNodeChild,\n                  parentComponent\n                );\n              } else {\n                insertVirtualNodeBefore(\n                  curToNodeChild,\n                  curToNodeKey,\n                  curFromNodeChild,\n                  fromNode,\n                  ownerComponent,\n                  parentComponent\n                );\n                detachNode(matchingFromEl, fromNode, ownerComponent);\n              }\n            } else {\n              // preserve the node\n              // but still we need to diff the current from node\n              insertBefore(matchingFromEl, curFromNodeChild, fromNode);\n              fromNextSibling = curFromNodeChild;\n            }\n          }\n        }\n\n        curToNodeChild = toNextSibling;\n        curFromNodeChild = fromNextSibling;\n        continue;\n      }\n\n      // The know the target node is not a VComponent node and we know\n      // it is also not a preserve node. Let's now match up the HTML\n      // element, text node, comment, etc.\n      while (curFromNodeChild) {\n        fromNextSibling = nextSibling(curFromNodeChild);\n\n        if ((fromComponent = componentByDOMNode.get(curFromNodeChild))) {\n          // The current \"to\" element is not associated with a component,\n          // but the current \"from\" element is associated with a component\n\n          // Even if we destroy the current component in the original\n          // DOM or not, we still need to skip over it since it is\n          // not compatible with the current \"to\" node\n          curFromNodeChild = fromNextSibling;\n\n          if (\n            !globalComponentsContext.___renderedComponentsById[fromComponent.id]\n          ) {\n            destroyComponent(fromComponent);\n          }\n\n          continue; // Move to the next \"from\" node\n        }\n\n        var curFromNodeType = curFromNodeChild.nodeType;\n\n        var isCompatible = undefined;\n\n        if (curFromNodeType === curToNodeType) {\n          if (curFromNodeType === ELEMENT_NODE) {\n            // Both nodes being compared are Element nodes\n            curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);\n            if (curVFromNodeChild === undefined) {\n              if (isHydrate === true) {\n                curVFromNodeChild = virtualizeElement(curFromNodeChild);\n\n                if (\n                  caseInsensitiveCompare(\n                    curVFromNodeChild.___nodeName,\n                    curToNodeChild.___nodeName\n                  )\n                ) {\n                  curVFromNodeChild.___nodeName = curToNodeChild.___nodeName;\n                }\n              } else {\n                // Skip over nodes that don't look like ours...\n                curFromNodeChild = fromNextSibling;\n                continue;\n              }\n            } else if ((curFromNodeKey = curVFromNodeChild.___key)) {\n              // We have a keyed element here but our target VDOM node\n              // is not keyed so this not doesn't belong\n              isCompatible = false;\n            }\n\n            isCompatible =\n              isCompatible !== false &&\n              compareNodeNames(curVFromNodeChild, curToNodeChild) === true;\n\n            if (isCompatible === true) {\n              // We found compatible DOM elements so transform\n              // the current \"from\" node to match the current\n              // target DOM node.\n              morphEl(\n                curFromNodeChild,\n                curVFromNodeChild,\n                curToNodeChild,\n                parentComponent\n              );\n            }\n          } else if (\n            curFromNodeType === TEXT_NODE ||\n            curFromNodeType === COMMENT_NODE\n          ) {\n            // Both nodes being compared are Text or Comment nodes\n            isCompatible = true;\n            // Simply update nodeValue on the original node to\n            // change the text value\n            if (curFromNodeChild.nodeValue !== curToNodeChild.___nodeValue) {\n              curFromNodeChild.nodeValue = curToNodeChild.___nodeValue;\n            }\n          }\n        }\n\n        if (isCompatible === true) {\n          // Advance both the \"to\" child and the \"from\" child since we found a match\n          curToNodeChild = toNextSibling;\n          curFromNodeChild = fromNextSibling;\n          continue outer;\n        }\n\n        detachNode(curFromNodeChild, fromNode, ownerComponent);\n        curFromNodeChild = fromNextSibling;\n      } // END: while (curFromNodeChild)\n\n      // If we got this far then we did not find a candidate match for\n      // our \"to node\" and we exhausted all of the children \"from\"\n      // nodes. Therefore, we will just append the current \"to\" node\n      // to the end\n      insertVirtualNodeBefore(\n        curToNodeChild,\n        curToNodeKey,\n        curFromNodeChild,\n        fromNode,\n        ownerComponent,\n        parentComponent\n      );\n\n      curToNodeChild = toNextSibling;\n      curFromNodeChild = fromNextSibling;\n    }\n\n    // We have processed all of the \"to nodes\".\n    if (fromNode.___finishFragment) {\n      // If we are in an unfinished fragment, we have reached the end of the nodes\n      // we were matching up and need to end the fragment\n      fromNode.___finishFragment(curFromNodeChild);\n    } else {\n      // If curFromNodeChild is non-null then we still have some from nodes\n      // left over that need to be removed\n      var fragmentBoundary =\n        fromNode.nodeType === FRAGMENT_NODE ? fromNode.endNode : null;\n\n      while (curFromNodeChild && curFromNodeChild !== fragmentBoundary) {\n        fromNextSibling = nextSibling(curFromNodeChild);\n\n        if ((fromComponent = componentByDOMNode.get(curFromNodeChild))) {\n          curFromNodeChild = fromNextSibling;\n          if (\n            !globalComponentsContext.___renderedComponentsById[fromComponent.id]\n          ) {\n            destroyComponent(fromComponent);\n          }\n          continue;\n        }\n\n        curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);\n        curFromNodeKey = keysByDOMNode.get(fromNode);\n\n        // For transcluded content, we need to check if the element belongs to a different component\n        // context than the current component and ensure it gets removed from its key index.\n        if (!curFromNodeKey || isAutoKey(curFromNodeKey)) {\n          referenceComponent = parentComponent;\n        } else {\n          referenceComponent =\n            curVFromNodeChild && curVFromNodeChild.___ownerComponent;\n        }\n\n        detachNode(curFromNodeChild, fromNode, referenceComponent);\n\n        curFromNodeChild = fromNextSibling;\n      }\n    }\n  }\n\n  function morphEl(fromEl, vFromEl, toEl, parentComponent) {\n    var nodeName = toEl.___nodeName;\n\n    var constId = toEl.___constId;\n    if (constId !== undefined && vFromEl.___constId === constId) {\n      return;\n    }\n\n    morphAttrs(fromEl, vFromEl, toEl);\n\n    if (toEl.___preserveBody) {\n      return;\n    }\n\n    if (nodeName !== \"textarea\") {\n      morphChildren(fromEl, toEl, parentComponent);\n    }\n\n    var specialElHandler = specialElHandlers[nodeName];\n    if (specialElHandler !== undefined) {\n      specialElHandler(fromEl, toEl);\n    }\n  } // END: morphEl(...)\n\n  // eslint-disable-next-line no-constant-condition\n  if (\"MARKO_DEBUG\") {\n    componentsUtil.___stopDOMManipulationWarning();\n  }\n\n  morphChildren(fromNode, toNode, toNode.___component);\n\n  detachedNodes.forEach(function(node) {\n    var detachedFromComponent = detachedByDOMNode.get(node);\n\n    if (detachedFromComponent !== undefined) {\n      detachedByDOMNode.set(node, undefined);\n\n      var componentToDestroy = componentByDOMNode.get(node);\n      if (componentToDestroy) {\n        componentToDestroy.destroy();\n      } else if (node.parentNode) {\n        destroyNodeRecursive(\n          node,\n          detachedFromComponent !== true && detachedFromComponent\n        );\n\n        if (eventDelegation.___handleNodeDetach(node) != false) {\n          removeChild(node);\n        }\n      }\n    }\n  });\n\n  // eslint-disable-next-line no-constant-condition\n  if (\"MARKO_DEBUG\") {\n    componentsUtil.___startDOMManipulationWarning();\n  }\n}\n\nmodule.exports = morphdom;\n","function syncBooleanAttrProp(fromEl, toEl, name) {\n  if (fromEl[name] !== toEl[name]) {\n    fromEl[name] = toEl[name];\n    if (fromEl[name]) {\n      fromEl.setAttribute(name, \"\");\n    } else {\n      fromEl.removeAttribute(name, \"\");\n    }\n  }\n}\n\nfunction forEachOption(el, fn, i) {\n  var curChild = el.___firstChild;\n\n  while (curChild) {\n    if (curChild.___nodeName === \"option\") {\n      fn(curChild, ++i);\n    } else {\n      i = forEachOption(curChild, fn, i);\n    }\n\n    curChild = curChild.___nextSibling;\n  }\n\n  return i;\n}\n\n// We use a JavaScript class to benefit from fast property lookup\nfunction SpecialElHandlers() {}\nSpecialElHandlers.prototype = {\n  /**\n   * Needed for IE. Apparently IE doesn't think that \"selected\" is an\n   * attribute when reading over the attributes using selectEl.attributes\n   */\n  option: function(fromEl, toEl) {\n    syncBooleanAttrProp(fromEl, toEl, \"selected\");\n  },\n  button: function(fromEl, toEl) {\n    syncBooleanAttrProp(fromEl, toEl, \"disabled\");\n  },\n  /**\n   * The \"value\" attribute is special for the <input> element since it sets\n   * the initial value. Changing the \"value\" attribute without changing the\n   * \"value\" property will have no effect since it is only used to the set the\n   * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n   */\n  input: function(fromEl, toEl) {\n    syncBooleanAttrProp(fromEl, toEl, \"checked\");\n    syncBooleanAttrProp(fromEl, toEl, \"disabled\");\n\n    if (fromEl.value != toEl.___value) {\n      fromEl.value = toEl.___value;\n    }\n\n    if (fromEl.hasAttribute(\"value\") && !toEl.___hasAttribute(\"value\")) {\n      fromEl.removeAttribute(\"value\");\n    }\n  },\n\n  textarea: function(fromEl, toEl) {\n    if (toEl.___preserveTextAreaValue) {\n      return;\n    }\n\n    var newValue = toEl.___value;\n    if (fromEl.value != newValue) {\n      fromEl.value = newValue;\n    }\n\n    var firstChild = fromEl.firstChild;\n    if (firstChild) {\n      // Needed for IE. Apparently IE sets the placeholder as the\n      // node value and vise versa. This ignores an empty update.\n      var oldValue = firstChild.nodeValue;\n\n      if (\n        oldValue == newValue ||\n        (!newValue && oldValue == fromEl.placeholder)\n      ) {\n        return;\n      }\n\n      firstChild.nodeValue = newValue;\n    }\n  },\n  select: function(fromEl, toEl) {\n    if (!toEl.___hasAttribute(\"multiple\")) {\n      var selected = 0;\n      forEachOption(\n        toEl,\n        function(option, i) {\n          if (option.___hasAttribute(\"selected\")) {\n            selected = i;\n          }\n        },\n        -1\n      );\n\n      if (fromEl.selectedIndex !== selected) {\n        fromEl.selectedIndex = selected;\n      }\n    }\n  }\n};\n\nmodule.exports = new SpecialElHandlers();\n","var parseHTML = function(html) {\n  var container = document.createElement(\"template\");\n  parseHTML = container.content\n    ? function(html) {\n        container.innerHTML = html;\n        return container.content;\n      }\n    : function(html) {\n        container.innerHTML = html;\n        return container;\n      };\n\n  return parseHTML(html);\n};\n\nmodule.exports = function(html) {\n  return parseHTML(html).firstChild;\n};\n","var VNode = require(\"./VNode\");\nvar VDocumentFragment = require(\"./VDocumentFragment\");\nvar VElement = require(\"./VElement\");\nvar VText = require(\"./VText\");\nvar VComponent = require(\"./VComponent\");\nvar VFragment = require(\"./VFragment\");\nvar parseHTML = require(\"./parse-html\");\n\nvar defaultDocument = typeof document != \"undefined\" && document;\nvar specialHtmlRegexp = /[&<]/;\n\nfunction virtualizeChildNodes(node, vdomParent, ownerComponent) {\n  var curChild = node.firstChild;\n  while (curChild) {\n    vdomParent.___appendChild(virtualize(curChild, ownerComponent));\n    curChild = curChild.nextSibling;\n  }\n}\n\nfunction virtualize(node, ownerComponent) {\n  switch (node.nodeType) {\n    case 1:\n      return VElement.___virtualize(node, virtualizeChildNodes, ownerComponent);\n    case 3:\n      return new VText(node.nodeValue, ownerComponent);\n    case 11:\n      var vdomDocFragment = new VDocumentFragment();\n      virtualizeChildNodes(node, vdomDocFragment, ownerComponent);\n      return vdomDocFragment;\n  }\n}\n\nfunction virtualizeHTML(html, doc, ownerComponent) {\n  if (!specialHtmlRegexp.test(html)) {\n    return new VText(html, ownerComponent);\n  }\n\n  var vdomFragment = new VDocumentFragment();\n  var curChild = parseHTML(html);\n\n  while (curChild) {\n    vdomFragment.___appendChild(virtualize(curChild, ownerComponent));\n    curChild = curChild.nextSibling;\n  }\n\n  return vdomFragment;\n}\n\nvar Node_prototype = VNode.prototype;\n\n/**\n * Shorthand method for creating and appending a Text node with a given value\n * @param  {String} value The text value for the new Text node\n */\nNode_prototype.t = function(value) {\n  var type = typeof value;\n  var vdomNode;\n\n  if (type !== \"string\") {\n    if (value == null) {\n      value = \"\";\n    } else if (type === \"object\") {\n      if (value.toHTML) {\n        vdomNode = virtualizeHTML(value.toHTML(), document);\n      }\n    }\n  }\n\n  this.___appendChild(vdomNode || new VText(value.toString()));\n  return this.___finishChild();\n};\n\nNode_prototype.___appendDocumentFragment = function() {\n  return this.___appendChild(new VDocumentFragment());\n};\n\nexports.___VDocumentFragment = VDocumentFragment;\nexports.___VElement = VElement;\nexports.___VText = VText;\nexports.___VComponent = VComponent;\nexports.___VFragment = VFragment;\nexports.___virtualize = virtualize;\nexports.___virtualizeHTML = virtualizeHTML;\nexports.___defaultDocument = defaultDocument;\n","module.exports = function copyProps(from, to) {\n    Object.getOwnPropertyNames(from).forEach(function(name) {\n        var descriptor = Object.getOwnPropertyDescriptor(from, name);\n        Object.defineProperty(to, name, descriptor);\n    });\n};","module.exports = function extend(target, source) { //A simple function to copy properties from one object to another\n    if (!target) { //Check if a target was provided, otherwise create a new empty object to return\n        target = {};\n    }\n\n    if (source) {\n        for (var propName in source) {\n            if (source.hasOwnProperty(propName)) { //Only look at source properties that are not inherited\n                target[propName] = source[propName]; //Copy the property\n            }\n        }\n    }\n\n    return target;\n};","var copyProps = require('./copyProps');\n\nfunction inherit(ctor, superCtor, shouldCopyProps) {\n    var oldProto = ctor.prototype;\n    var newProto = ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n            value: ctor,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (oldProto && shouldCopyProps !== false) {\n        copyProps(oldProto, newProto);\n    }\n    ctor.$super = superCtor;\n    ctor.prototype = newProto;\n    return ctor;\n}\n\n\nmodule.exports = inherit;\ninherit._inherit = inherit;\n","module.exports = require(\"./src/constants\");","module.exports = require('./src/finalize');","var win = typeof window !== \"undefined\" ? window : global;\nexports.NOOP = win.$W10NOOP = win.$W10NOOP || function () {};","var constants = require(\"./constants\");\nvar isArray = Array.isArray;\n\nfunction resolve(object, path, len) {\n    var current = object;\n    for (var i=0; i<len; i++) {\n        current = current[path[i]];\n    }\n\n    return current;\n}\n\nfunction resolveType(info) {\n    if (info.type === 'Date') {\n        return new Date(info.value);\n    } else if (info.type === 'NOOP') {\n        return constants.NOOP;\n    } else {\n        throw new Error('Bad type');\n    }\n}\n\nmodule.exports = function finalize(outer) {\n    if (!outer) {\n        return outer;\n    }\n\n    var assignments = outer.$$;\n    if (assignments) {\n        var object = outer.o;\n        var len;\n\n        if (assignments && (len=assignments.length)) {\n            for (var i=0; i<len; i++) {\n                var assignment = assignments[i];\n\n                var rhs = assignment.r;\n                var rhsValue;\n\n                if (isArray(rhs)) {\n                    rhsValue = resolve(object, rhs, rhs.length);\n                } else {\n                    rhsValue = resolveType(rhs);\n                }\n\n                var lhs = assignment.l;\n                var lhsLast = lhs.length-1;\n\n                if (lhsLast === -1) {\n                    object = outer.o = rhsValue;\n                    break;\n                } else {\n                    var lhsParent = resolve(object, lhs, lhsLast);\n                    lhsParent[lhs[lhsLast]] = rhsValue;\n                }\n            }\n        }\n\n        assignments.length = 0; // Assignments have been applied, do not reapply\n\n        return object == null ? null : object;\n    } else {\n        return outer;\n    }\n\n};","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n"],"sourceRoot":""}