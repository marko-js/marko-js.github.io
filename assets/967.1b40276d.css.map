{"version":3,"file":"967.1b40276d.css","mappings":"AAmBA,iDAIA,cACA,gBAGA,kBADA,gBAJA,kBAGA,UAGA,CAEA,eACA,YACA,CACA,oCACA,aACA,CAEA,8EAEA,YACA,CAEA,kBACA,kBACA,CAEA,gBAEA,SADA,SAEA,CAEA,+BAEA,eACA,CACA,kCAKA,wCAHA,+CAEA,eADA,gBAIA,iBADA,iBALA,SAOA,CAEA,2BACA,mBACA,cAMA,iBACA,gBACA,kBAPA,kBACA,gBAEA,oBACA,kBAFA,eAMA,CAEA,iBACA,cACA,eACA,CAEA,mBAEA,cADA,UAEA,CAEA,qBAEA,kBADA,iBAEA","sources":["webpack:///../components/repl/components/preview.marko"],"sourcesContent":["import path from \"path\"\nimport { format } from \"prettier/standalone\"\nimport prettierBabel from \"prettier/plugins/babel\"\nimport prettierEstree from \"prettier/plugins/estree\"\nimport highlight from \"../../../utils/highlight\"\nimport { bundle, compile } from \"../../../utils/compiler\"\nimport { vol } from \"memfs\"\n\nstatic const SYNTAX_ERROR_REG = /(.+?)(?:\\((\\d+),(\\d+)\\)|:(\\d+)): (.*(?=\\s+\\d+ | ))/;\n\n<attrs/{ type, files, selectedFile, getCompilerOptions, debounce, onSelectError, onSyntaxError }/>\n<id/examplePath/>\n<const/selectedPath = path.join(\"/\", examplePath, selectedFile.path)/>\n<const/defaultPath = path.join(\"/\", examplePath, files[0].path)/>\n\n<let/error = null/>\n<let/result = null/>\n\n<style>\n  .preview-error,\n  .preview-output,\n  .preview-compiled {\n    position: relative;\n    display: block;\n    min-height: 100%;\n    width: 100%;\n    padding-top: 8px;\n    padding-left: 16px;\n  }\n\n  .preview-error {\n    display:none;\n  }\n  .preview-error.preview-error-active {\n    display:block;\n  }\n  \n  .preview-error-active ~ .preview-output,\n  .preview-error-active ~ .preview-compiled {\n    display: none;\n  }\n\n  .preview-compiled {\n    background: #202134;\n  }\n\n  .preview-output {\n    padding: 0;\n    border: 0;\n  }\n\n  .preview-output,\n  .preview-error {\n    background: #fff;\n  }\n  .preview-compiled pre.highlighted {\n    padding: 0;\n    font-family: Menlo, Monaco, \"Courier New\", monospace;\n    font-weight: normal;\n    font-size: 12px;\n    font-feature-settings: \"liga\" 0, \"calt\" 0;\n    line-height: 18px;\n    letter-spacing: 0px;\n  }\n\n  .preview-error .error-name {\n    background: #f92672;\n    color: #f8f8f0;\n    margin-left: -16px;\n    margin-top: -8px;\n    padding-top: 8px;\n    padding-bottom: 12px;\n    padding-left: 16px;\n    font-size: 1.2rem;\n    font-weight: bold;\n    margin-bottom: 8px;\n  }\n\n  .preview-error a {\n    color: #66d9ef;\n    font-weight: normal;\n  }\n\n  .preview-error pre {\n    width: 100%;\n    overflow: auto;\n  }\n\n  .preview-error small {\n    font-style: italic;\n    font-size: 0.75 rem;\n  }\n</style>\n\n\n<div.preview-error class=error && \"preview-error-active\">\n  <if=error>\n    <h1.error-name>\n      ${error.name}\n      <if=error.file>\n        &nbsp;:&nbsp;\n        <a onClick() { onSelectError(error) }>\n          ${error.file.slice(1)}(${error.line},${error.column})\n        </a>\n      </if>\n    </h1>\n    <pre><code>${error.message.replaceAll(examplePath, \"\")}</code></pre>\n    <if=(selectedPath !== error.file)>\n      <if=error.codeFrame>\n        <pre><code>${error.codeFrame}</code></pre>\n      </if>\n      <else>\n        <small>Open the dev tools to view the full error.</small>\n      </else>\n    </if>\n  </if>\n</div>\n<if=(type === \"preview\")>\n  <iframe-swap/outputEl class=\"preview-output\"/>\n</if>\n<else>\n  <div.preview-compiled>$!{result}</div>\n</else>\n\n<effect() {\n  let syncTimeout, errorTimeout;\n\n  if (debounce) {\n    syncTimeout = setTimeout(showPreview, 100);\n  } else {\n    showPreview();\n  }\n\n  async function showPreview() {\n    for (const file of files) {\n      const filePath = path.join(\"/\", examplePath, file.path);\n      vol.mkdirSync(path.dirname(filePath), { recursive: true });\n      vol.writeFileSync(filePath, file.content);\n    }\n    \n    try {\n      if (type === \"preview\" || type === \"html\") {\n        const bundleResult = await bundle({\n          entry: defaultPath,\n          markoOptions: { \n            output: \"vdom\",\n            ...getCompilerOptions?.()\n          }\n        });\n\n        if (outputEl) {\n          const { contentWindow, contentDocument } = outputEl.next();\n          contentWindow.__INTERNAL_MODULES__ = window.__INTERNAL_MODULES__;\n          const template = (0, contentWindow.eval)(bundleResult.js);\n          const style = contentDocument.createElement(\"style\");\n          style.innerHTML = bundleResult.css;\n          contentDocument.head.appendChild(style);\n\n          if (getCompilerOptions?.()?.translator) {\n            // new api\n            template.default.mount({}, contentDocument.body);\n          } else {\n            const renderResult = await template.render({});\n            renderResult.appendTo(contentDocument.body);\n          }\n          outputEl.swap();\n        }\n        // else {\n        //   const template = (0, eval)(bundleResult.js);\n        //   const renderResult = await template.render({});\n        //   result = highlight(\n        //     \"html\",\n        //     format(String(renderResult), {\n        //       parser: \"html\",\n        //       plugins: [prettierHTML]\n        //     })\n        //   );\n        // }\n      } else {\n        const output = type.startsWith(\"compiled-html\") ? \"html\" : \"vdom\";\n        const code = await compile({\n          entry: selectedPath,\n          markoOptions: { \n            output,\n            ...getCompilerOptions?.()\n          }\n        });\n        result = highlight(\n          \"javascript\",\n          await format(\n            code.replaceAll(`${examplePath}/`, \"\"),\n            {\n              parser: \"babel\",\n              plugins: [prettierBabel, prettierEstree]\n            }\n          )\n        );\n      }\n\n      error = null;\n    } catch (err) {\n      if (debounce) {\n        errorTimeout = setTimeout(showError, 1000);\n      } else {\n        showError();\n      }\n\n      function showError() {\n        const errorWithLocationMatch =\n          err.name === \"SyntaxError\" && SYNTAX_ERROR_REG.exec(err.message);\n        if (errorWithLocationMatch) {\n          let [match, file, line, column, lineOnly, message] = errorWithLocationMatch;\n          if (lineOnly) {\n            line = lineOnly;\n            column = 0;\n          }\n\n          file = path.resolve(file);\n          line = parseInt(line, 10);\n          column = parseInt(column, 10) + 1;\n          const codeFrame = err.message.slice(match.length);\n          const errorData = error = {\n            name: err.name,\n            file,\n            message,\n            line,\n            column,\n            codeFrame\n          };\n\n          if (file === selectedPath && onSyntaxError) {\n            onSyntaxError(errorData);\n          }\n        } else {\n          error = err;\n          console.error(err);\n        }\n      }\n    }\n  }\n  \n  return () => {\n    clearTimeout(syncTimeout);\n    clearTimeout(errorTimeout);\n    try {\n      vol.rmdirSync(examplePath, { recursive: true });\n    } catch (e) {}\n  }\n}/>"],"names":[],"sourceRoot":""}