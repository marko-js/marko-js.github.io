{"version":3,"file":"420.ccd65e3a.js","mappings":"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","sources":["webpack:///../../node_modules/@marko/runtime-tags/dist/translator/index.js"],"sourcesContent":["\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name2 in all)\n    __defProp(target, name2, { get: all[name2], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/translator/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  analyze: () => analyze,\n  getRuntimeEntryFiles: () => getRuntimeEntryFiles,\n  internalEntryBuilder: () => entry_builder_default,\n  preferAPI: () => preferAPI,\n  tagDiscoveryDirs: () => tagDiscoveryDirs,\n  taglibs: () => taglibs,\n  transform: () => transform,\n  translate: () => translate\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// src/translator/util/runtime-info.ts\nvar import_package = require(\"../../package.json\");\nvar runtime_info_default = {\n  name: import_package.name,\n  taglibId: \"marko-core\"\n};\n\n// src/translator/core/attrs.ts\nvar import_compiler = require(\"@marko/compiler\");\nvar import_babel_utils = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/assert.ts\nfunction assertNoSpreadAttrs(tag) {\n  for (const attr2 of tag.get(\"attributes\")) {\n    if (attr2.isMarkoSpreadAttribute()) {\n      throw attr2.buildCodeFrameError(\n        `The \\`${tag.get(\"name\").node.value}\\` tag does not support \\`...spread\\` attributes.`\n      );\n    }\n  }\n}\nfunction assertNoBodyContent(tag) {\n  if (tag.node.body.body.length) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${tag.get(\"name\").node.value}\\` tag does not support body content.`\n    );\n  }\n}\n\n// src/translator/core/attrs.ts\nvar attrs_default = {\n  migrate: [\n    (tag) => {\n      (0, import_babel_utils.assertNoArgs)(tag);\n      (0, import_babel_utils.assertNoParams)(tag);\n      (0, import_babel_utils.assertNoAttributes)(tag);\n      assertNoBodyContent(tag);\n      (0, import_babel_utils.assertNoAttributeTags)(tag);\n      (0, import_babel_utils.diagnosticDeprecate)(tag, {\n        label: \"The `attrs` tag is deprecated, prefer destructuring `input` via the `const` tag.\",\n        fix() {\n          const tagVar = tag.node.var;\n          if (tagVar && !(tagVar.type === \"Identifier\" && tagVar.name === \"input\")) {\n            const constTag = import_compiler.types.markoTag(\n              import_compiler.types.stringLiteral(\"const\"),\n              [import_compiler.types.markoAttribute(\"value\", import_compiler.types.identifier(\"input\"))],\n              import_compiler.types.markoTagBody([])\n            );\n            constTag.var = tagVar;\n            tag.replaceWith(constTag);\n          } else {\n            tag.remove();\n          }\n        }\n      });\n    }\n  ],\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"attrs/{ ... }\",\n      description: \"Use to receive the attributes passed into this template.\",\n      snippet: \"attrs/{ $1 }$2\"\n    }\n  ]\n};\n\n// src/translator/core/await.ts\nvar import_compiler25 = require(\"@marko/compiler\");\nvar import_babel_utils16 = require(\"@marko/compiler/babel-utils\");\n\n// src/common/accessor.debug.ts\nvar AccessorPrefix = /* @__PURE__ */ ((AccessorPrefix3) => {\n  AccessorPrefix3[\"ClosureScopes\"] = \"ClosureScopes:\";\n  AccessorPrefix3[\"ClosureSignalIndex\"] = \"ClosureSignalIndex:\";\n  AccessorPrefix3[\"ConditionalRenderer\"] = \"ConditionalRenderer:\";\n  AccessorPrefix3[\"ConditionalScope\"] = \"ConditionalScope:\";\n  AccessorPrefix3[\"ControlledHandler\"] = \"ControlledHandler:\";\n  AccessorPrefix3[\"ControlledType\"] = \"ControlledType:\";\n  AccessorPrefix3[\"ControlledValue\"] = \"ControlledValue:\";\n  AccessorPrefix3[\"DynamicPlaceholderLastChild\"] = \"DynamicPlaceholderLastChild:\";\n  AccessorPrefix3[\"EventAttributes\"] = \"EventAttributes:\";\n  AccessorPrefix3[\"Getter\"] = \"Getter:\";\n  AccessorPrefix3[\"LifecycleAbortController\"] = \"LifecycleAbortController:\";\n  AccessorPrefix3[\"LoopScopeArray\"] = \"LoopScopeArray:\";\n  AccessorPrefix3[\"LoopScopeMap\"] = \"LoopScopeMap:\";\n  AccessorPrefix3[\"Promise\"] = \"Promise:\";\n  AccessorPrefix3[\"TagVariableChange\"] = \"TagVariableChange:\";\n  return AccessorPrefix3;\n})(AccessorPrefix || {});\nvar AccessorProp = /* @__PURE__ */ ((AccessorProp3) => {\n  AccessorProp3[\"BranchAccessor\"] = \"#BranchAccessor\";\n  AccessorProp3[\"CatchContent\"] = \"#CatchContent\";\n  AccessorProp3[\"PlaceholderBranch\"] = \"#PlaceholderBranch\";\n  AccessorProp3[\"PlaceholderContent\"] = \"#PlaceholderContent\";\n  AccessorProp3[\"TagVariable\"] = \"#TagVariable\";\n  AccessorProp3[\"TagVariableChange\"] = \"#TagVariableChange\";\n  AccessorProp3[\"ClosestBranchId\"] = \"#ClosestBranchId\";\n  return AccessorProp3;\n})(AccessorProp || {});\n\n// src/translator/util/evaluate.ts\nvar import_babel_utils2 = require(\"@marko/compiler/babel-utils\");\nfunction evaluate(value) {\n  let { extra } = value;\n  if (!extra) {\n    extra = value.extra = {};\n  }\n  if (extra.confident === void 0) {\n    const computed = (0, import_babel_utils2.computeNode)(value);\n    if (computed) {\n      extra.computed = computed.value;\n      extra.confident = true;\n    } else {\n      extra.computed = void 0;\n      extra.confident = false;\n    }\n  }\n  return extra;\n}\n\n// src/translator/util/references.ts\nvar import_compiler24 = require(\"@marko/compiler\");\n\n// src/translator/util/dynamic-sources.ts\nvar import_compiler6 = require(\"@marko/compiler\");\n\n// src/translator/util/sections.ts\nvar import_compiler5 = require(\"@marko/compiler\");\nvar import_babel_utils7 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/generate-uid.ts\nvar import_compiler3 = require(\"@marko/compiler\");\nvar import_babel_utils3 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/traverse.ts\nvar import_compiler2 = require(\"@marko/compiler\");\nvar skip = Symbol(\"skip\");\nfunction traverseReplace(container, key, enter3) {\n  const node = container[key];\n  if (node) {\n    if (Array.isArray(node)) {\n      for (let i = node.length; i--; ) {\n        traverseReplace(node, i, enter3);\n      }\n    } else {\n      const keys = import_compiler2.types.VISITOR_KEYS[node.type];\n      for (let i = keys.length; i--; ) {\n        traverseReplace(node, keys[i], enter3);\n      }\n      const replacement = enter3(node, container, key);\n      if (replacement) container[key] = replacement;\n    }\n  }\n}\nfunction traverseContains(node, check) {\n  if (node) {\n    if (Array.isArray(node)) {\n      for (const item of node) {\n        if (traverseContains(item, check)) {\n          return true;\n        }\n      }\n    } else {\n      switch (check(node)) {\n        case true:\n          return true;\n        case skip:\n          return false;\n      }\n      for (const key of import_compiler2.types.VISITOR_KEYS[node.type]) {\n        if (traverseContains(node[key], check)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction traverse(visit2, node, parent, grandParent) {\n  if (node) {\n    if (Array.isArray(node)) {\n      for (const item of node) {\n        traverse(visit2, item, parent, grandParent);\n      }\n    } else if (visit2(node, parent, grandParent) !== skip) {\n      for (const key of import_compiler2.types.VISITOR_KEYS[node.type]) {\n        traverse(visit2, node[key], node, parent);\n      }\n    }\n  }\n}\n\n// src/translator/util/generate-uid.ts\nvar countsForFile = /* @__PURE__ */ new WeakMap();\nfunction generateUid(name2 = \"\") {\n  const file = (0, import_babel_utils3.getFile)();\n  let counts = countsForFile.get(file);\n  if (!counts) {\n    const { cache } = file.markoOpts;\n    const { filename } = file.opts;\n    const cacheKey = `uid-counts:${filename}`;\n    counts = cache.get(cacheKey);\n    if (counts) {\n      if (isTranslate(file)) {\n        counts = new Map(counts);\n      }\n    } else {\n      counts = getInitialCounts(file);\n      if (!isTranslate(file)) {\n        cache.set(cacheKey, counts);\n      }\n    }\n    countsForFile.set(file, counts);\n  }\n  name2 = name2.replace(/^[^a-z$_]|[^a-z$_0-9]/gi, \"\") || \"temp\";\n  name2 = /^\\$?(.*?)\\d*$/.exec(name2)?.[1] || name2;\n  const i = (counts.get(name2) || 0) + 1;\n  const uniqueName = `$${i > 1 ? name2 + i : name2}`;\n  counts.set(name2, i);\n  return uniqueName;\n}\nfunction generateUidIdentifier(name2) {\n  return import_compiler3.types.identifier(generateUid(name2));\n}\nfunction getInitialCounts(file) {\n  const counts = /* @__PURE__ */ new Map();\n  const program = file.path;\n  const countName = (name2) => {\n    const match = /^$(.*?)([1-9]\\d*)?$/.exec(name2);\n    if (match) {\n      const name3 = match[1];\n      const count = match[2] ? +match[2] + 1 : 1;\n      counts.set(name3, Math.max(counts.get(name3) || 0, count));\n    }\n  };\n  for (const name2 in program.scope.globals) {\n    countName(name2);\n  }\n  traverse((node, parent, grandParent) => {\n    if (node.type === \"Identifier\" && import_compiler3.types.isBinding(node, parent, grandParent)) {\n      countName(node.name);\n    }\n  }, program.node);\n  return counts;\n}\nfunction isTranslate(file) {\n  return file.___compileStage === \"translate\";\n}\n\n// src/translator/util/is-core-tag.ts\nvar import_babel_utils4 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-tag-name.ts\nfunction getTagName(tag) {\n  return tag.node.name.value;\n}\n\n// src/translator/util/is-core-tag.ts\nvar { taglibId } = runtime_info_default;\nvar htmlTaglibId = \"marko-html\";\nvar interopTaglibId = \"@marko/translator-interop-class-tags\";\nfunction isCoreTag(tag) {\n  if (tag.isMarkoTag()) {\n    const tagDef = (0, import_babel_utils4.getTagDef)(tag);\n    if (tagDef) {\n      switch (tagDef.taglibId) {\n        case taglibId:\n        case interopTaglibId:\n          return true;\n        case htmlTaglibId:\n          switch (tagDef.name) {\n            case \"script\":\n            case \"style\":\n              return true;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\nfunction isCoreTagName(tag, name2) {\n  return isCoreTag(tag) && getTagName(tag) === name2;\n}\nfunction isConditionTag(tag) {\n  if (isCoreTag(tag)) {\n    switch (getTagName(tag)) {\n      case \"if\":\n      case \"else-if\":\n      case \"else\":\n        return true;\n    }\n  }\n  return false;\n}\nfunction isControlFlowTag(tag) {\n  if (isCoreTag(tag)) {\n    switch (getTagName(tag)) {\n      case \"if\":\n      case \"else-if\":\n      case \"else\":\n      case \"for\":\n      case \"await\":\n      case \"try\":\n        return true;\n    }\n  }\n  return false;\n}\n\n// src/translator/util/optional.ts\nvar Sorted = class {\n  constructor(compare) {\n    this.compare = compare;\n  }\n  add(data, item) {\n    return data ? Array.isArray(data) ? addSorted(this.compare, data, item) : joinRepeatable(this.compare, data, item) : item;\n  }\n  union(a, b) {\n    if (a) {\n      if (Array.isArray(a)) {\n        if (b) {\n          if (Array.isArray(b)) {\n            return unionSortedRepeatable(this.compare, a, b);\n          } else {\n            return addSorted(this.compare, a, b);\n          }\n        }\n        return a;\n      }\n      if (b) {\n        if (Array.isArray(b)) {\n          return addSorted(this.compare, [...b], a);\n        }\n        return joinRepeatable(this.compare, b, a);\n      }\n      return a;\n    }\n    return b;\n  }\n  find(data, item) {\n    if (data) {\n      if (Array.isArray(data)) {\n        return findSorted(this.compare, data, item);\n      } else if (this.compare(data, item) === 0) {\n        return data;\n      }\n    }\n  }\n  findIndex(data, item) {\n    if (data) {\n      if (Array.isArray(data)) {\n        let max = data.length;\n        let pos = 0;\n        while (pos < max) {\n          const mid = pos + max >>> 1;\n          const compareResult = this.compare(data[mid], item);\n          if (compareResult === 0) return mid;\n          if (compareResult > 0) max = mid;\n          else pos = mid + 1;\n        }\n        return -1;\n      }\n      if (this.compare(data, item) === 0) {\n        return 0;\n      }\n    }\n    return -1;\n  }\n  isSuperset(superset, subset) {\n    if (!subset) {\n      return true;\n    }\n    if (!Array.isArray(subset)) {\n      return this.findIndex(superset, subset) !== -1;\n    }\n    if (!Array.isArray(superset)) {\n      return false;\n    }\n    const subLen = subset.length;\n    const supLen = superset.length;\n    if (subLen > supLen) {\n      return false;\n    }\n    for (let i = subLen; i--; ) {\n      const supIndex = this.findIndex(superset, subset[i]);\n      if (supIndex === -1 || supLen - supIndex <= i) return false;\n    }\n    return true;\n  }\n};\nfunction push(data, item) {\n  if (data) {\n    if (Array.isArray(data)) {\n      data.push(item);\n      return data;\n    }\n    return [data, item];\n  }\n  return item;\n}\nfunction concat(a, b) {\n  if (a) {\n    if (b) {\n      if (Array.isArray(a)) {\n        return a.concat(b);\n      } else if (Array.isArray(b)) {\n        return [a, ...b];\n      } else {\n        return [a, b];\n      }\n    }\n    return a;\n  }\n  return b;\n}\nfunction filter(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      const len = data.length;\n      let result;\n      let i = 0;\n      while (i < len) {\n        let item = data[i++];\n        if (cb(item)) {\n          result = item;\n          while (i < len) {\n            item = data[i++];\n            if (cb(item)) {\n              result = [result, item];\n              while (i < len) {\n                item = data[i++];\n                if (cb(item)) {\n                  result.push(item);\n                }\n              }\n              return result;\n            }\n          }\n          return result;\n        }\n      }\n      return result;\n    }\n    if (cb(data)) {\n      return data;\n    }\n  }\n  return void 0;\n}\nfunction forEach(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      let i = 0;\n      for (const item of data) {\n        cb(item, i++);\n      }\n    } else {\n      cb(data, 0);\n    }\n  }\n}\nfunction find(data, cb) {\n  if (data) {\n    if (Array.isArray(data)) {\n      return data.find(cb);\n    }\n    if (cb(data, 0)) {\n      return data;\n    }\n  }\n}\nfunction map(data, cb) {\n  return data ? Array.isArray(data) ? data.map(cb) : [cb(data, 0)] : [];\n}\nfunction findSorted(compare, data, item) {\n  let max = data.length;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const cur = data[mid];\n    const compareResult = compare(cur, item);\n    if (compareResult === 0) return cur;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n}\nfunction addSorted(compare, data, item) {\n  const len = data.length;\n  let max = len;\n  let pos = 0;\n  while (pos < max) {\n    const mid = pos + max >>> 1;\n    const compareResult = compare(data[mid], item);\n    if (compareResult === 0) return data;\n    if (compareResult > 0) max = mid;\n    else pos = mid + 1;\n  }\n  const result = new Array(len + 1);\n  for (let i = 0; i < pos; i++) {\n    result[i] = data[i];\n  }\n  let cur = item;\n  while (pos < len) {\n    const next = cur;\n    cur = data[pos];\n    result[pos++] = next;\n  }\n  result[len] = cur;\n  return result;\n}\nfunction unionSortedRepeatable(compare, a, b) {\n  const aLen = a.length;\n  const bLen = b.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  const result = [];\n  while (aIndex < aLen && bIndex < bLen) {\n    const aValue = a[aIndex];\n    const bValue = b[bIndex];\n    const delta = compare(aValue, bValue);\n    if (delta === 0) {\n      aIndex++;\n      bIndex++;\n      result.push(aValue);\n    } else if (delta < 0) {\n      aIndex++;\n      result.push(aValue);\n    } else {\n      bIndex++;\n      result.push(bValue);\n    }\n  }\n  if (aLen === bLen && aIndex === aLen) {\n    return a;\n  }\n  while (aIndex < aLen) {\n    result.push(a[aIndex++]);\n  }\n  while (bIndex < bLen) {\n    result.push(b[bIndex++]);\n  }\n  return result;\n}\nfunction joinRepeatable(compare, a, b) {\n  const compareResult = compare(a, b);\n  return compareResult === 0 ? a : compareResult < 0 ? [a, b] : [b, a];\n}\n\n// src/translator/util/state.ts\nvar import_babel_utils5 = require(\"@marko/compiler/babel-utils\");\nvar createProgramState = (init) => {\n  const map2 = /* @__PURE__ */ new WeakMap();\n  return [\n    () => {\n      let state = map2.get((0, import_babel_utils5.getProgram)());\n      if (!state) {\n        map2.set((0, import_babel_utils5.getProgram)(), state = init());\n      }\n      return state;\n    },\n    (value) => {\n      map2.set((0, import_babel_utils5.getProgram)(), value);\n    }\n  ];\n};\nfunction createSectionState(key, init) {\n  return [\n    (section) => {\n      const arrayOfSectionData = (0, import_babel_utils5.getProgram)().state[key] ??= {};\n      const sectionData = arrayOfSectionData[section.id] ??= init && init(section);\n      return sectionData;\n    },\n    (section, value) => {\n      const arrayOfSectionData = (0, import_babel_utils5.getProgram)().state[key] ??= {};\n      arrayOfSectionData[section.id] = value;\n    }\n  ];\n}\n\n// src/translator/util/tag-name-type.ts\nvar import_compiler4 = require(\"@marko/compiler\");\nvar import_babel_utils6 = require(\"@marko/compiler/babel-utils\");\nvar MARKO_FILE_REG = /^<.*>$|\\.marko$/;\nfunction analyzeTagNameType(tag) {\n  const extra = tag.node.extra ??= {};\n  if (extra.tagNameType === void 0) {\n    const name2 = tag.get(\"name\");\n    if (name2.isStringLiteral()) {\n      extra.tagNameType = name2.node.value[0] === \"@\" ? 3 /* AttributeTag */ : (0, import_babel_utils6.isNativeTag)(tag) ? 0 /* NativeTag */ : 1 /* CustomTag */;\n      extra.tagNameNullable = extra.tagNameNullable = false;\n    } else if (name2.isIdentifier()) {\n      analyzeExpressionTagName(name2, extra);\n      if (extra.tagNameType === 0 /* NativeTag */) {\n        extra.tagNameType = 2 /* DynamicTag */;\n      }\n    } else if (name2.isTemplateLiteral() && !name2.node.expressions.length) {\n      extra.tagNameType = 0 /* NativeTag */;\n    } else {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n    if (extra.tagNameType === void 0) {\n      extra.tagNameType = 2 /* DynamicTag */;\n    }\n    if (extra.tagNameType === 1 /* CustomTag */) {\n      const childFile = (0, import_babel_utils6.loadFileForTag)(tag);\n      if (!childFile) {\n        extra.tagNameType = 2 /* DynamicTag */;\n      } else if (childFile.ast.program.extra.featureType === \"class\") {\n        extra.tagNameType = 2 /* DynamicTag */;\n        extra.featureType = \"class\";\n        ((0, import_babel_utils6.getProgram)().node.extra ??= {}).needsCompat = true;\n      }\n    }\n  }\n  return extra.tagNameType;\n}\nfunction analyzeExpressionTagName(name2, extra) {\n  const pending = [name2];\n  let path5;\n  let type;\n  let nullable = false;\n  let tagNameImported;\n  while ((path5 = pending.pop()) && type !== 2 /* DynamicTag */) {\n    if (path5.isConditionalExpression()) {\n      pending.push(path5.get(\"consequent\"));\n      if (path5.node.alternate) {\n        pending.push(path5.get(\"alternate\"));\n      }\n    } else if (path5.isLogicalExpression()) {\n      if (path5.node.operator === \"||\") {\n        pending.push(path5.get(\"left\"));\n      } else {\n        nullable = true;\n      }\n      pending.push(path5.get(\"right\"));\n    } else if (path5.isAssignmentExpression()) {\n      pending.push(path5.get(\"right\"));\n    } else if (path5.isBinaryExpression()) {\n      type = path5.node.operator !== \"+\" || type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path5.isStringLiteral() || path5.isTemplateLiteral()) {\n      type = type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;\n    } else if (path5.isNullLiteral()) {\n      nullable = true;\n    } else if (path5.isIdentifier()) {\n      if (path5.node.name === \"undefined\") {\n        nullable = true;\n        continue;\n      }\n      const binding = path5.scope.getBinding(path5.node.name);\n      if (!binding) {\n        type = 2 /* DynamicTag */;\n        continue;\n      }\n      if (binding.kind === \"module\") {\n        const decl = binding.path.parent;\n        if (MARKO_FILE_REG.test(decl.source.value) && decl.specifiers.some((it) => import_compiler4.types.isImportDefaultSpecifier(it))) {\n          const resolvedImport = (0, import_babel_utils6.resolveTagImport)(name2, decl.source.value) || decl.source.value;\n          if (type === 0 /* NativeTag */ || tagNameImported && tagNameImported !== resolvedImport) {\n            type = 2 /* DynamicTag */;\n            tagNameImported = void 0;\n          } else {\n            type = 1 /* CustomTag */;\n            tagNameImported = resolvedImport;\n          }\n        } else {\n          type = 2 /* DynamicTag */;\n        }\n        continue;\n      }\n      const bindingTag = binding.path;\n      if (bindingTag.isMarkoTag() && binding.kind === \"local\") {\n        const bindingTagName = bindingTag.get(\"name\").node.value;\n        if (bindingTagName === \"const\") {\n          pending.push(\n            bindingTag.get(\"attributes\")[0].get(\"value\")\n          );\n          continue;\n        }\n        if (bindingTagName === \"let\") {\n          type = 2 /* DynamicTag */;\n          continue;\n        }\n        continue;\n      }\n      type = 2 /* DynamicTag */;\n    } else {\n      type = 2 /* DynamicTag */;\n    }\n  }\n  extra.tagNameType = type;\n  extra.tagNameNullable = nullable;\n  extra.tagNameDynamic = true;\n  if (type === 1 /* CustomTag */ && tagNameImported) {\n    extra.tagNameImported = tagNameImported;\n  }\n}\n\n// src/translator/util/sections.ts\nvar sectionUtil = new Sorted(function compareSections(a, b) {\n  return a.id - b.id;\n});\nfunction startSection(path5) {\n  const extra = path5.node.extra ??= {};\n  let section = extra.section;\n  if (!section && (path5.type === \"Program\" || path5.get(\"body\").length)) {\n    const parentSection = path5.parentPath ? getOrCreateSection(path5.parentPath) : void 0;\n    const sectionNamePath = path5.parentPath?.get(\n      \"name\"\n    );\n    const sectionName = path5.isProgram() ? \"\" : generateUid(sectionNamePath.toString() + \"_content\");\n    const programExtra = path5.hub.file.path.node.extra ??= {};\n    const sections = programExtra.sections ??= [];\n    section = extra.section = {\n      id: sections.length,\n      name: sectionName,\n      loc: sectionNamePath?.node.loc || void 0,\n      depth: parentSection ? parentSection.depth + 1 : 0,\n      parent: parentSection,\n      sectionAccessor: void 0,\n      params: void 0,\n      referencedClosures: void 0,\n      referencedHoists: void 0,\n      bindings: void 0,\n      hoisted: void 0,\n      isHoistThrough: void 0,\n      assignments: void 0,\n      content: getContentInfo(path5),\n      upstreamExpression: void 0,\n      downstreamBinding: void 0,\n      hasAbortSignal: false,\n      isBranch: false\n    };\n    sections.push(section);\n  }\n  return section;\n}\nfunction getOrCreateSection(path5) {\n  let cur = path5;\n  while (true) {\n    if (cur.type === \"Program\" || cur.type === \"MarkoTagBody\" && !cur.node.attributeTags && !isNativeNode(cur.parentPath)) {\n      return startSection(cur);\n    }\n    cur = cur.parentPath;\n  }\n}\nfunction getSectionForBody(body) {\n  return body.node.extra?.section;\n}\nfunction getSection(path5) {\n  let section;\n  let currentPath = path5;\n  while ((section = currentPath.node.extra?.section) === void 0) {\n    currentPath = currentPath.parentPath;\n  }\n  return section;\n}\nvar [getScopeIdIdentifier] = createSectionState(\n  \"scopeIdIdentifier\",\n  (section) => generateUidIdentifier(`scope${section.id}_id`)\n);\nvar [getSectionParentIsOwner, setSectionParentIsOwner] = createSectionState(\"parentIsOwner\", () => false);\nvar [_getScopeIdentifier] = createSectionState(\n  \"scopeIdentifier\",\n  () => import_compiler5.types.identifier(\"undefined\")\n);\nfunction forEachSection(fn) {\n  const { sections } = (0, import_babel_utils7.getProgram)().node.extra;\n  sections?.forEach(fn);\n}\nfunction forEachSectionReverse(fn) {\n  const { sections } = (0, import_babel_utils7.getProgram)().node.extra;\n  for (let i = sections.length; i--; ) {\n    fn(sections[i]);\n  }\n}\nfunction getContentInfo(path5) {\n  const body = path5.get(\"body\");\n  const contentInfo = {\n    startType: null,\n    endType: null,\n    singleChild: true\n  };\n  for (let endIndex = body.length; endIndex--; ) {\n    const endType = getNodeContentType(body[endIndex], \"endType\", contentInfo);\n    if (endType !== null) {\n      contentInfo.endType = endType;\n      if (endType === 1 /* Dynamic */) {\n        contentInfo.singleChild = false;\n      }\n      for (let startIndex = 0; startIndex < endIndex; startIndex++) {\n        const startType = getNodeContentType(body[startIndex], \"startType\");\n        if (startType !== null) {\n          contentInfo.startType = startType;\n          contentInfo.singleChild = false;\n          return contentInfo;\n        }\n      }\n      contentInfo.startType = getNodeContentType(body[endIndex], \"startType\");\n      return contentInfo;\n    }\n  }\n  return null;\n}\nfunction getNodeContentType(path5, extraMember, contentInfo) {\n  switch (path5.type) {\n    case \"MarkoText\":\n      return 4 /* Text */;\n    case \"MarkoPlaceholder\":\n      return 2 /* Placeholder */;\n    case \"MarkoScriptlet\":\n    case \"MarkoComment\":\n    case \"ImportDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportNamedDeclaration\":\n      return null;\n    case \"MarkoTag\": {\n      const tag = path5;\n      if (isCoreTag(tag)) {\n        switch (tag.node.name.value) {\n          case \"html-comment\":\n            return 0 /* Comment */;\n          case \"html-script\":\n          case \"html-style\":\n            return 3 /* Tag */;\n          case \"for\":\n          case \"if\":\n          case \"await\":\n          case \"try\":\n            return 1 /* Dynamic */;\n          default:\n            return null;\n        }\n      } else if ((0, import_babel_utils7.isNativeTag)(tag)) {\n        return 3 /* Tag */;\n      } else if ((0, import_babel_utils7.isAttributeTag)(tag)) {\n        return null;\n      } else if (import_compiler5.types.isStringLiteral(tag.node.name)) {\n        const tagSection = (0, import_babel_utils7.loadFileForTag)(tag)?.ast.program.extra.section;\n        if (tagSection) {\n          if (tagSection.content) {\n            if (contentInfo && !tagSection.content.singleChild) {\n              if (extraMember === \"endType\") {\n                contentInfo.startType = tagSection.content.startType;\n                contentInfo.singleChild = false;\n              }\n            }\n            return tagSection.content[extraMember];\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n  }\n  return 1 /* Dynamic */;\n}\nvar isSerializedSection = (section) => {\n  return !(section.isBranch || section.downstreamBinding?.serialize === false);\n};\nfunction isSectionWithHoists(section) {\n  if (section.hoisted || section.isHoistThrough || section.referencedHoists)\n    return true;\n}\nfunction isImmediateOwner(section, binding) {\n  return section.parent?.id === binding.section.id;\n}\nfunction isDirectClosure(section, closure) {\n  return section.isBranch && isImmediateOwner(section, closure);\n}\nfunction isDynamicClosure(section, closure) {\n  return !isDirectClosure(section, closure);\n}\nfunction getDirectClosures(section) {\n  if (section.isBranch) {\n    return filter(\n      section.referencedClosures,\n      (closure) => isImmediateOwner(section, closure)\n    );\n  }\n}\nfunction isSameOrChildSection(section, other) {\n  do {\n    if (other === section) {\n      return true;\n    }\n  } while (other = other.parent);\n  return false;\n}\nfunction getCommonSection(section, other) {\n  let ancestor = section;\n  if (other.depth < section.depth) {\n    ancestor = other;\n    other = section;\n  }\n  while (ancestor) {\n    if (other === ancestor || !other.parent) {\n      return ancestor;\n    }\n    other = other.parent;\n    if (other.depth < ancestor.depth) {\n      ancestor = ancestor.parent;\n    }\n  }\n  throw new Error(\"No common section\");\n}\nfunction isNativeNode(tag) {\n  if (isCoreTag(tag)) {\n    switch (tag.node.name.value) {\n      case \"html-comment\":\n      case \"html-script\":\n      case \"html-style\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  return analyzeTagNameType(tag) === 0 /* NativeTag */;\n}\n\n// src/translator/util/dynamic-sources.ts\nfunction getDynamicSourcesForBinding(binding) {\n  if (binding.sources) {\n    if (Array.isArray(binding.sources) ? binding.sources.every(isInputBinding) : isInputBinding(binding.sources)) {\n      return binding.sources;\n    }\n    return true;\n  }\n}\nfunction getDynamicSourcesForExtra(extra) {\n  if (isReferencedExtra(extra)) {\n    return getDynamicSourcesForReferences(extra.referencedBindings);\n  }\n}\nfunction getDynamicSourcesForExtras(extras) {\n  let allDynamicSources;\n  for (const extra of extras) {\n    const dynamicSources = getDynamicSourcesForExtra(extra);\n    if (dynamicSources === true) return true;\n    allDynamicSources = bindingUtil.union(allDynamicSources, dynamicSources);\n  }\n  return allDynamicSources;\n}\nfunction getDynamicSourcesForSection(section) {\n  const referenced = getDynamicSourcesForReferences(\n    section.upstreamExpression?.referencedBindings\n  );\n  const closures = getDynamicSourcesForReferences(getDirectClosures(section));\n  if (referenced || closures) {\n    return {\n      referenced,\n      closures,\n      all: referenced === true || closures === true ? true : bindingUtil.union(referenced, closures)\n    };\n  }\n}\nfunction getDynamicSourcesForSections(sections) {\n  let first;\n  let merged;\n  for (const section of sections) {\n    const sources = section && getDynamicSourcesForSection(section);\n    if (sources) {\n      if (merged) {\n        merged.referenced = mergeDynamicSources(\n          merged.referenced,\n          sources.referenced\n        );\n        merged.closures = mergeDynamicSources(\n          merged.closures,\n          sources.closures\n        );\n        merged.all = mergeDynamicSources(merged.all, sources.all);\n      } else if (first) {\n        merged = {\n          referenced: mergeDynamicSources(first.referenced, sources.referenced),\n          closures: mergeDynamicSources(first.closures, sources.closures),\n          all: mergeDynamicSources(first.all, sources.all)\n        };\n      } else {\n        first = sources;\n      }\n    }\n  }\n  return merged || first;\n}\nfunction getDynamicSourcesForReferences(referencedBindings) {\n  if (referencedBindings) {\n    let dynamicSources;\n    if (Array.isArray(referencedBindings)) {\n      for (const binding of referencedBindings) {\n        const newDynamicSources = getDynamicSourcesForBinding(binding);\n        if (newDynamicSources === true) return true;\n        dynamicSources = bindingUtil.union(dynamicSources, newDynamicSources);\n      }\n      return dynamicSources;\n    } else {\n      return getDynamicSourcesForBinding(referencedBindings);\n    }\n  }\n}\nfunction mergeDynamicSources(a, b) {\n  if (a === true || b === true) return true;\n  return bindingUtil.union(a, b);\n}\nfunction isInputBinding(binding) {\n  return binding.type === 2 /* input */;\n}\n\n// src/translator/util/for-each-identifier.ts\nfunction forEachIdentifier(node, cb) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (const prop of node.properties) {\n        switch (prop.type) {\n          case \"ObjectProperty\":\n            if (prop.value.type === \"AssignmentPattern\") {\n              forEachIdentifier(prop.value.left, cb);\n            } else {\n              forEachIdentifier(prop.value, cb);\n            }\n            break;\n          case \"RestElement\":\n            forEachIdentifier(prop.argument, cb);\n            break;\n        }\n      }\n      break;\n    case \"ArrayPattern\":\n      for (const el of node.elements) {\n        if (el != null) {\n          switch (el.type) {\n            case \"RestElement\":\n              forEachIdentifier(el.argument, cb);\n              break;\n            case \"AssignmentPattern\":\n              forEachIdentifier(el.left, cb);\n              break;\n            default:\n              forEachIdentifier(el, cb);\n              break;\n          }\n        }\n      }\n      break;\n    case \"Identifier\":\n      cb(node);\n      break;\n  }\n}\n\n// src/common/accessor.ts\nvar AccessorPrefix2 = /* @__PURE__ */ ((AccessorPrefix3) => {\n  AccessorPrefix3[\"ClosureScopes\"] = \"a\";\n  AccessorPrefix3[\"ClosureSignalIndex\"] = \"b\";\n  AccessorPrefix3[\"ConditionalRenderer\"] = \"c\";\n  AccessorPrefix3[\"ConditionalScope\"] = \"d\";\n  AccessorPrefix3[\"ControlledHandler\"] = \"e\";\n  AccessorPrefix3[\"ControlledType\"] = \"f\";\n  AccessorPrefix3[\"ControlledValue\"] = \"g\";\n  AccessorPrefix3[\"DynamicPlaceholderLastChild\"] = \"h\";\n  AccessorPrefix3[\"EventAttributes\"] = \"i\";\n  AccessorPrefix3[\"Getter\"] = \"j\";\n  AccessorPrefix3[\"LifecycleAbortController\"] = \"k\";\n  AccessorPrefix3[\"LoopScopeArray\"] = \"l\";\n  AccessorPrefix3[\"LoopScopeMap\"] = \"m\";\n  AccessorPrefix3[\"Promise\"] = \"n\";\n  AccessorPrefix3[\"TagVariableChange\"] = \"o\";\n  return AccessorPrefix3;\n})(AccessorPrefix2 || {});\nvar AccessorProp2 = /* @__PURE__ */ ((AccessorProp3) => {\n  AccessorProp3[\"BranchAccessor\"] = \"a\";\n  AccessorProp3[\"CatchContent\"] = \"b\";\n  AccessorProp3[\"PlaceholderBranch\"] = \"c\";\n  AccessorProp3[\"PlaceholderContent\"] = \"d\";\n  AccessorProp3[\"TagVariable\"] = \"e\";\n  AccessorProp3[\"TagVariableChange\"] = \"f\";\n  AccessorProp3[\"ClosestBranchId\"] = \"g\";\n  return AccessorProp3;\n})(AccessorProp2 || {});\n\n// src/translator/util/marko-config.ts\nvar import_babel_utils8 = require(\"@marko/compiler/babel-utils\");\nfunction isOutputHTML() {\n  return getMarkoOpts().output === \"html\";\n}\nfunction isOutputDOM() {\n  return !isOutputHTML();\n}\nfunction getMarkoOpts() {\n  return (0, import_babel_utils8.getFile)().markoOpts;\n}\nfunction isOptimize() {\n  return getMarkoOpts().optimize;\n}\n\n// src/translator/util/get-accessor-char.ts\nfunction getAccessorPrefix() {\n  return isOptimize() ? AccessorPrefix2 : AccessorPrefix;\n}\nfunction getAccessorProp() {\n  return isOptimize() ? AccessorProp2 : AccessorProp;\n}\n\n// src/translator/util/get-root.ts\nfunction getMarkoRoot(path5) {\n  let curPath = path5;\n  do\n    curPath = curPath.parentPath;\n  while (curPath && !isMarko(curPath));\n  return curPath;\n}\nfunction getExprRoot(path5) {\n  let curPath = path5;\n  while (!isMarko(curPath.parentPath)) {\n    curPath = curPath.parentPath;\n  }\n  return curPath;\n}\nfunction getFnRoot(path5) {\n  let curPath = path5;\n  let fnPath;\n  if (curPath.isProgram()) return;\n  while (!isMarko(curPath)) {\n    if (isFunction(curPath)) {\n      fnPath = curPath;\n    } else {\n      switch (curPath.type) {\n        case \"CallExpression\":\n        case \"NewExpression\":\n          fnPath = void 0;\n          break;\n      }\n    }\n    curPath = curPath.parentPath;\n  }\n  return fnPath;\n}\nfunction isMarko(path5) {\n  switch (path5.type) {\n    case \"MarkoTag\":\n    case \"MarkoTagBody\":\n    case \"MarkoAttribute\":\n    case \"MarkoSpreadAttribute\":\n    case \"MarkoPlaceholder\":\n    case \"MarkoScriptlet\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isFunction(path5) {\n  switch (path5.type) {\n    case \"FunctionDeclaration\":\n      return !path5.node.declare;\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ObjectMethod\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// src/translator/util/is-invoked-function.ts\nvar import_compiler7 = require(\"@marko/compiler\");\nfunction isInvokedFunction(expr) {\n  let curPath = expr;\n  while (curPath) {\n    const { parent, node } = curPath;\n    switch (parent.type) {\n      case \"CallExpression\":\n        return parent.callee === node;\n      case \"TSNonNullExpression\":\n        curPath = curPath.parentPath;\n        break;\n      default:\n        return false;\n    }\n  }\n  return false;\n}\n\n// src/translator/util/scope-read.ts\nvar import_compiler23 = require(\"@marko/compiler\");\n\n// src/translator/visitors/program/index.ts\nvar import_compiler22 = require(\"@marko/compiler\");\nvar import_babel_utils15 = require(\"@marko/compiler/babel-utils\");\nvar import_path2 = __toESM(require(\"path\"));\n\n// src/translator/util/binding-has-downstream-expressions.ts\nfunction bindingHasDownstreamExpressions(binding) {\n  if (binding.downstreamExpressions.size) return true;\n  for (const alias of binding.aliases) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    if (bindingHasDownstreamExpressions(alias)) return true;\n  }\n  return false;\n}\n\n// src/translator/util/entry-builder.ts\nvar import_compiler8 = require(\"@marko/compiler\");\nvar import_babel_utils9 = require(\"@marko/compiler/babel-utils\");\nvar kState = Symbol();\nvar entry_builder_default = {\n  build(entryFile) {\n    const state = entryFile[kState];\n    if (!state) {\n      throw entryFile.path.buildCodeFrameError(\n        \"Unable to build hydrate code, no files were visited before finalizing the build\"\n      );\n    }\n    const body = state.imports.map(\n      (it) => import_compiler8.types.importDeclaration([], import_compiler8.types.stringLiteral(it))\n    );\n    if (state.init) {\n      body.unshift(\n        import_compiler8.types.importDeclaration(\n          [import_compiler8.types.importSpecifier(import_compiler8.types.identifier(\"init\"), import_compiler8.types.identifier(\"init\"))],\n          import_compiler8.types.stringLiteral(\n            `${runtime_info_default.name}/${entryFile.markoOpts.optimize ? \"\" : \"debug/\"}dom`\n          )\n        )\n      );\n      body.push(\n        import_compiler8.types.expressionStatement(import_compiler8.types.callExpression(import_compiler8.types.identifier(\"init\"), []))\n      );\n    }\n    return body;\n  },\n  visit(file, entryFile, visitChild) {\n    const state = entryFile[kState] ||= {\n      imports: [],\n      init: false\n    };\n    const { analyzedTags } = file.metadata.marko;\n    state.imports.push(\n      (0, import_babel_utils9.resolveRelativePath)(entryFile, file.opts.filename)\n    );\n    state.init ||= file.path.node.extra.hasInteractiveChild || file.path.node.extra.isInteractive || false;\n    for (const tag of analyzedTags || []) {\n      visitChild(tag);\n    }\n  }\n};\n\n// src/translator/util/runtime.ts\nvar import_compiler10 = require(\"@marko/compiler\");\nvar import_babel_utils10 = require(\"@marko/compiler/babel-utils\");\n\n// src/common/attr-tag.ts\nvar rest = false ? Symbol(\"Attribute Tag\") : Symbol();\n\n// src/common/helpers.ts\nfunction classValue(value) {\n  return toDelimitedString(value, \" \", stringifyClassObject);\n}\nfunction stringifyClassObject(name2, value) {\n  return value ? name2 : \"\";\n}\nfunction styleValue(value) {\n  return toDelimitedString(value, \";\", stringifyStyleObject);\n}\nfunction stringifyStyleObject(name2, value) {\n  return value || value === 0 ? `${name2}:${typeof value === \"number\" && value && !/^(--|ta|or|li|z)|cou|nk|it|ag|we|do|w$/.test(name2) ? value + \"px\" : value}` : \"\";\n}\nfunction toDelimitedString(val, delimiter, stringify) {\n  switch (typeof val) {\n    case \"string\":\n      return val;\n    case \"object\":\n      if (val !== null) {\n        let result = \"\";\n        let curDelimiter = \"\";\n        if (Array.isArray(val)) {\n          for (const v of val) {\n            const part = toDelimitedString(v, delimiter, stringify);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        } else {\n          for (const name2 in val) {\n            const v = val[name2];\n            const part = stringify(name2, v);\n            if (part !== \"\") {\n              result += curDelimiter + part;\n              curDelimiter = delimiter;\n            }\n          }\n        }\n        return result;\n      }\n  }\n  return \"\";\n}\nfunction isEventHandler(name2) {\n  return /^on[A-Z-]/.test(name2);\n}\nfunction getEventHandlerName(name2) {\n  return name2[2] === \"-\" ? name2.slice(3) : name2.slice(2).toLowerCase();\n}\nfunction isVoid(value) {\n  return value == null || value === false;\n}\n\n// src/html/content.ts\nfunction toString(val) {\n  return val ? val + \"\" : val === 0 ? \"0\" : \"\";\n}\nvar unsafeXMLReg = /[<&]/g;\nvar replaceUnsafeXML = (c) => c === \"&\" ? \"&amp;\" : \"&lt;\";\nvar escapeXMLStr = (str) => unsafeXMLReg.test(str) ? str.replace(unsafeXMLReg, replaceUnsafeXML) : str;\nfunction escapeXML(val) {\n  return val ? escapeXMLStr(val + \"\") : val === 0 ? \"0\" : \"&zwj;\";\n}\nvar unsafeScriptReg = /<\\/script/g;\nvar escapeScriptStr = (str) => unsafeScriptReg.test(str) ? str.replace(unsafeScriptReg, \"\\\\x3C/script\") : str;\nfunction escapeScript(val) {\n  return val ? escapeScriptStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\nvar unsafeStyleReg = /<\\/style/g;\nvar escapeStyleStr = (str) => unsafeStyleReg.test(str) ? str.replace(unsafeStyleReg, \"\\\\3C/style\") : str;\nfunction escapeStyle(val) {\n  return val ? escapeStyleStr(val + \"\") : val === 0 ? \"0\" : \"\";\n}\n\n// src/html/serializer.ts\nvar kTouchedIterator = Symbol();\nvar { hasOwnProperty } = {};\nvar Generator = function* () {\n}().constructor;\nvar AsyncGenerator = async function* () {\n}().constructor;\npatchIteratorNext(Generator.prototype);\npatchIteratorNext(AsyncGenerator.prototype);\nvar KNOWN_SYMBOLS = (() => {\n  const KNOWN_SYMBOLS2 = /* @__PURE__ */ new Map();\n  for (const name2 of Object.getOwnPropertyNames(Symbol)) {\n    const symbol = Symbol[name2];\n    if (typeof symbol === \"symbol\") {\n      KNOWN_SYMBOLS2.set(symbol, \"Symbol.\" + name2);\n    }\n  }\n  return KNOWN_SYMBOLS2;\n})();\nvar KNOWN_FUNCTIONS = /* @__PURE__ */ new Map([\n  // This is by no means an exhaustive list,\n  // but it should cover most of the built-in functions.\n  [AggregateError, \"AggregateError\"],\n  [Array, \"Array\"],\n  [Array.from, \"Array.from\"],\n  [Array.isArray, \"Array.isArray\"],\n  [Array.of, \"Array.of\"],\n  [ArrayBuffer, \"ArrayBuffer\"],\n  [ArrayBuffer.isView, \"ArrayBuffer.isView\"],\n  [Atomics.add, \"Atomics.add\"],\n  [Atomics.and, \"Atomics.and\"],\n  [Atomics.compareExchange, \"Atomics.compareExchange\"],\n  [Atomics.exchange, \"Atomics.exchange\"],\n  [Atomics.isLockFree, \"Atomics.isLockFree\"],\n  [Atomics.load, \"Atomics.load\"],\n  [Atomics.notify, \"Atomics.notify\"],\n  [Atomics.or, \"Atomics.or\"],\n  [Atomics.store, \"Atomics.store\"],\n  [Atomics.sub, \"Atomics.sub\"],\n  [Atomics.wait, \"Atomics.wait\"],\n  [BigInt, \"BigInt\"],\n  [BigInt.asIntN, \"BigInt.asIntN\"],\n  [BigInt.asUintN, \"BigInt.asUintN\"],\n  [BigInt64Array, \"BigInt64Array\"],\n  [BigInt64Array.from, \"BigInt64Array.from\"],\n  [BigInt64Array.of, \"BigInt64Array.of\"],\n  [BigUint64Array, \"BigUint64Array\"],\n  [BigUint64Array.from, \"BigUint64Array.from\"],\n  [BigUint64Array.of, \"BigUint64Array.of\"],\n  [Boolean, \"Boolean\"],\n  [console.assert, \"console.assert\"],\n  [console.clear, \"console.clear\"],\n  [console.count, \"console.count\"],\n  [console.countReset, \"console.countReset\"],\n  [console.debug, \"console.debug\"],\n  [console.dir, \"console.dir\"],\n  [console.dirxml, \"console.dirxml\"],\n  [console.error, \"console.error\"],\n  [console.group, \"console.group\"],\n  [console.groupCollapsed, \"console.groupCollapsed\"],\n  [console.groupEnd, \"console.groupEnd\"],\n  [console.info, \"console.info\"],\n  [console.log, \"console.log\"],\n  [console.table, \"console.table\"],\n  [console.time, \"console.time\"],\n  [console.timeEnd, \"console.timeEnd\"],\n  [console.timeLog, \"console.timeLog\"],\n  [console.timeStamp, \"console.timeStamp\"],\n  [console.trace, \"console.trace\"],\n  [console.warn, \"console.warn\"],\n  [DataView, \"DataView\"],\n  [Date, \"Date\"],\n  [Date.now, \"Date.now\"],\n  [Date.parse, \"Date.parse\"],\n  [Date.UTC, \"Date.UTC\"],\n  [decodeURI, \"decodeURI\"],\n  [decodeURIComponent, \"decodeURIComponent\"],\n  [encodeURI, \"encodeURI\"],\n  [encodeURIComponent, \"encodeURIComponent\"],\n  [Error, \"Error\"],\n  [EvalError, \"EvalError\"],\n  [Float32Array, \"Float32Array\"],\n  [Float32Array.from, \"Float32Array.from\"],\n  [Float32Array.of, \"Float32Array.of\"],\n  [Float64Array, \"Float64Array\"],\n  [Float64Array.from, \"Float64Array.from\"],\n  [Float64Array.of, \"Float64Array.of\"],\n  [Function, \"Function\"],\n  [globalThis.atob, \"atob\"],\n  [globalThis.btoa, \"btoa\"],\n  [globalThis.clearImmediate, \"clearImmediate\"],\n  [globalThis.clearInterval, \"clearInterval\"],\n  [globalThis.clearTimeout, \"clearTimeout\"],\n  [globalThis.crypto?.getRandomValues, \"crypto.getRandomValues\"],\n  [globalThis.crypto?.randomUUID, \"crypto.randomUUID\"],\n  [globalThis.fetch, \"fetch\"],\n  [globalThis.performance?.now, \"performance.now\"],\n  [globalThis.queueMicrotask, \"queueMicrotask\"],\n  [globalThis.setImmediate, \"setImmediate\"],\n  [globalThis.setInterval, \"setInterval\"],\n  [globalThis.setTimeout, \"setTimeout\"],\n  [globalThis.structuredClone, \"structuredClone\"],\n  [globalThis.URL, \"URL\"],\n  [globalThis.URLSearchParams, \"URLSearchParams\"],\n  [globalThis.WritableStream, \"WritableStream\"],\n  [Int16Array, \"Int16Array\"],\n  [Int16Array.from, \"Int16Array.from\"],\n  [Int16Array.of, \"Int16Array.of\"],\n  [Int32Array, \"Int32Array\"],\n  [Int32Array.from, \"Int32Array.from\"],\n  [Int32Array.of, \"Int32Array.of\"],\n  [Int8Array, \"Int8Array\"],\n  [Int8Array.from, \"Int8Array.from\"],\n  [Int8Array.of, \"Int8Array.of\"],\n  [Intl.Collator, \"Intl.Collator\"],\n  [Intl.DateTimeFormat, \"Intl.DateTimeFormat\"],\n  [Intl.DisplayNames, \"Intl.DisplayNames\"],\n  [Intl.getCanonicalLocales, \"Intl.getCanonicalLocales\"],\n  [Intl.ListFormat, \"Intl.ListFormat\"],\n  [Intl.Locale, \"Intl.Locale\"],\n  [Intl.NumberFormat, \"Intl.NumberFormat\"],\n  [Intl.PluralRules, \"Intl.PluralRules\"],\n  [Intl.RelativeTimeFormat, \"Intl.RelativeTimeFormat\"],\n  [Intl.Segmenter, \"Intl.Segmenter\"],\n  [Intl.supportedValuesOf, \"Intl.supportedValuesOf\"],\n  [isFinite, \"isFinite\"],\n  [isNaN, \"isNaN\"],\n  [JSON.parse, \"JSON.parse\"],\n  [JSON.stringify, \"JSON.stringify\"],\n  [Map, \"Map\"],\n  [Map.groupBy, \"Map.groupBy\"],\n  [Math.abs, \"Math.abs\"],\n  [Math.acos, \"Math.acos\"],\n  [Math.acosh, \"Math.acosh\"],\n  [Math.asin, \"Math.asin\"],\n  [Math.asinh, \"Math.asinh\"],\n  [Math.atan, \"Math.atan\"],\n  [Math.atan2, \"Math.atan2\"],\n  [Math.atanh, \"Math.atanh\"],\n  [Math.cbrt, \"Math.cbrt\"],\n  [Math.ceil, \"Math.ceil\"],\n  [Math.clz32, \"Math.clz32\"],\n  [Math.cos, \"Math.cos\"],\n  [Math.cosh, \"Math.cosh\"],\n  [Math.exp, \"Math.exp\"],\n  [Math.expm1, \"Math.expm1\"],\n  [Math.floor, \"Math.floor\"],\n  [Math.fround, \"Math.fround\"],\n  [Math.hypot, \"Math.hypot\"],\n  [Math.imul, \"Math.imul\"],\n  [Math.log, \"Math.log\"],\n  [Math.log10, \"Math.log10\"],\n  [Math.log1p, \"Math.log1p\"],\n  [Math.log2, \"Math.log2\"],\n  [Math.max, \"Math.max\"],\n  [Math.min, \"Math.min\"],\n  [Math.pow, \"Math.pow\"],\n  [Math.random, \"Math.random\"],\n  [Math.round, \"Math.round\"],\n  [Math.sign, \"Math.sign\"],\n  [Math.sin, \"Math.sin\"],\n  [Math.sinh, \"Math.sinh\"],\n  [Math.sqrt, \"Math.sqrt\"],\n  [Math.tan, \"Math.tan\"],\n  [Math.tanh, \"Math.tanh\"],\n  [Math.trunc, \"Math.trunc\"],\n  [Number, \"Number\"],\n  [Number.isFinite, \"Number.isFinite\"],\n  [Number.isInteger, \"Number.isInteger\"],\n  [Number.isNaN, \"Number.isNaN\"],\n  [Number.isSafeInteger, \"Number.isSafeInteger\"],\n  [Number.parseFloat, \"Number.parseFloat\"],\n  [Number.parseInt, \"Number.parseInt\"],\n  [Object, \"Object\"],\n  [Object.assign, \"Object.assign\"],\n  [Object.create, \"Object.create\"],\n  [Object.defineProperties, \"Object.defineProperties\"],\n  [Object.defineProperty, \"Object.defineProperty\"],\n  [Object.entries, \"Object.entries\"],\n  [Object.freeze, \"Object.freeze\"],\n  [Object.fromEntries, \"Object.fromEntries\"],\n  [Object.getOwnPropertyDescriptor, \"Object.getOwnPropertyDescriptor\"],\n  [Object.getOwnPropertyDescriptors, \"Object.getOwnPropertyDescriptors\"],\n  [Object.getOwnPropertyNames, \"Object.getOwnPropertyNames\"],\n  [Object.getOwnPropertySymbols, \"Object.getOwnPropertySymbols\"],\n  [Object.getPrototypeOf, \"Object.getPrototypeOf\"],\n  [Object.is, \"Object.is\"],\n  [Object.isExtensible, \"Object.isExtensible\"],\n  [Object.isFrozen, \"Object.isFrozen\"],\n  [Object.isSealed, \"Object.isSealed\"],\n  [Object.keys, \"Object.keys\"],\n  [Object.preventExtensions, \"Object.preventExtensions\"],\n  [Object.seal, \"Object.seal\"],\n  [Object.setPrototypeOf, \"Object.setPrototypeOf\"],\n  [Object.values, \"Object.values\"],\n  [parseFloat, \"parseFloat\"],\n  [parseInt, \"parseInt\"],\n  [Promise, \"Promise\"],\n  [Proxy, \"Proxy\"],\n  [RangeError, \"RangeError\"],\n  [ReferenceError, \"ReferenceError\"],\n  [Reflect.apply, \"Reflect.apply\"],\n  [Reflect.construct, \"Reflect.construct\"],\n  [Reflect.defineProperty, \"Reflect.defineProperty\"],\n  [Reflect.deleteProperty, \"Reflect.deleteProperty\"],\n  [Reflect.get, \"Reflect.get\"],\n  [Reflect.getOwnPropertyDescriptor, \"Reflect.getOwnPropertyDescriptor\"],\n  [Reflect.getPrototypeOf, \"Reflect.getPrototypeOf\"],\n  [Reflect.has, \"Reflect.has\"],\n  [Reflect.isExtensible, \"Reflect.isExtensible\"],\n  [Reflect.ownKeys, \"Reflect.ownKeys\"],\n  [Reflect.preventExtensions, \"Reflect.preventExtensions\"],\n  [Reflect.set, \"Reflect.set\"],\n  [Reflect.setPrototypeOf, \"Reflect.setPrototypeOf\"],\n  [RegExp, \"RegExp\"],\n  [Set, \"Set\"],\n  [String, \"String\"],\n  [String.fromCharCode, \"String.fromCharCode\"],\n  [String.fromCodePoint, \"String.fromCodePoint\"],\n  [String.raw, \"String.raw\"],\n  [Symbol, \"Symbol\"],\n  [Symbol.for, \"Symbol.for\"],\n  [SyntaxError, \"SyntaxError\"],\n  [TypeError, \"TypeError\"],\n  [Uint16Array, \"Uint16Array\"],\n  [Uint16Array.from, \"Uint16Array.from\"],\n  [Uint16Array.of, \"Uint16Array.of\"],\n  [Uint32Array, \"Uint32Array\"],\n  [Uint32Array.from, \"Uint32Array.from\"],\n  [Uint32Array.of, \"Uint32Array.of\"],\n  [Uint8Array, \"Uint8Array\"],\n  [Uint8Array.from, \"Uint8Array.from\"],\n  [Uint8Array.of, \"Uint8Array.of\"],\n  [Uint8ClampedArray, \"Uint8ClampedArray\"],\n  [Uint8ClampedArray.from, \"Uint8ClampedArray.from\"],\n  [Uint8ClampedArray.of, \"Uint8ClampedArray.of\"],\n  [URIError, \"URIError\"],\n  [WeakMap, \"WeakMap\"],\n  [WeakSet, \"WeakSet\"]\n]);\nvar KNOWN_OBJECTS = /* @__PURE__ */ new Map([\n  [Atomics, \"Atomics\"],\n  [console, \"console\"],\n  [globalThis, \"globalThis\"],\n  [globalThis.crypto, \"crypto\"],\n  [Intl, \"Intl\"],\n  [JSON, \"JSON\"],\n  [Math, \"Math\"],\n  [Reflect, \"Reflect\"]\n]);\nfunction toAccess(accessor) {\n  const start = accessor[0];\n  return start === '\"' || start >= \"0\" && start <= \"9\" ? \"[\" + accessor + \"]\" : \".\" + accessor;\n}\nfunction patchIteratorNext(proto) {\n  const { next } = proto;\n  proto.next = function(value) {\n    this[kTouchedIterator] = 1;\n    return next.call(this, value);\n  };\n}\n\n// src/html/writer.ts\nvar K_SCOPE_ID = Symbol(\"Scope ID\");\nvar kPendingContexts = Symbol(\"Pending Contexts\");\nvar branchIdKey = Symbol();\nif (false) {\n  writeScope = /* @__PURE__ */ ((writeScope2) => (scopeId, partialScope, file, loc, vars) => {\n    const scope = writeScope2(scopeId, partialScope);\n    if (file && loc !== void 0) {\n      setDebugInfo(scope, file, loc, vars);\n    }\n    return scope;\n  })(writeScope);\n}\nvar tick = globalThis.setImmediate || globalThis.setTimeout || globalThis.queueMicrotask || ((cb) => Promise.resolve().then(cb));\n\n// src/html/attrs.ts\nfunction classAttr(value) {\n  return stringAttr(\"class\", classValue(value));\n}\nfunction styleAttr(value) {\n  return stringAttr(\"style\", styleValue(value));\n}\nvar kSelectedValue = Symbol(\"selectedValue\");\nfunction attr(name2, value) {\n  return isVoid(value) ? \"\" : nonVoidAttr(name2, value);\n}\nfunction stringAttr(name2, value) {\n  return value && \" \" + name2 + attrAssignment(value);\n}\nfunction nonVoidAttr(name2, value) {\n  switch (typeof value) {\n    case \"string\":\n      return \" \" + name2 + attrAssignment(value);\n    case \"boolean\":\n      return \" \" + name2;\n    case \"number\":\n      return \" \" + name2 + \"=\" + value;\n    case \"object\":\n      if (value instanceof RegExp) {\n        return \" \" + name2 + attrAssignment(value.source);\n      }\n      break;\n  }\n  return \" \" + name2 + attrAssignment(value + \"\");\n}\nvar singleQuoteAttrReplacements = /'|&(?=#?\\w+;)/g;\nvar doubleQuoteAttrReplacements = /\"|&(?=#?\\w+;)/g;\nvar needsQuotedAttr = /[\"'>\\s]|&#?\\w+;|\\/$/g;\nfunction attrAssignment(value) {\n  return value ? needsQuotedAttr.test(value) ? value[needsQuotedAttr.lastIndex - 1] === (needsQuotedAttr.lastIndex = 0, '\"') ? \"='\" + escapeSingleQuotedAttrValue(value) + \"'\" : '=\"' + escapeDoubleQuotedAttrValue(value) + '\"' : \"=\" + value : \"\";\n}\nfunction escapeSingleQuotedAttrValue(value) {\n  return singleQuoteAttrReplacements.test(value) ? value.replace(\n    singleQuoteAttrReplacements,\n    replaceUnsafeSingleQuoteAttrChar\n  ) : value;\n}\nfunction replaceUnsafeSingleQuoteAttrChar(match) {\n  return match === \"'\" ? \"&#39;\" : \"&amp;\";\n}\nfunction escapeDoubleQuotedAttrValue(value) {\n  return doubleQuoteAttrReplacements.test(value) ? value.replace(\n    doubleQuoteAttrReplacements,\n    replaceUnsafeDoubleQuoteAttrChar\n  ) : value;\n}\nfunction replaceUnsafeDoubleQuoteAttrChar(match) {\n  return match === '\"' ? \"&#34;\" : \"&amp;\";\n}\n\n// src/common/compat-meta.ts\nvar prefix = false ? \"$compat_\" : \"$C_\";\nvar RENDERER_REGISTER_ID = prefix + (false ? \"renderer\" : \"r\");\nvar SET_SCOPE_REGISTER_ID = prefix + (false ? \"setScope\" : \"s\");\nvar RENDER_BODY_ID = prefix + (false ? \"renderBody\" : \"b\");\n\n// src/html/compat.ts\nvar K_TAGS_API_STATE = Symbol();\n\n// src/translator/util/to-property-name.ts\nvar import_compiler9 = require(\"@marko/compiler\");\nfunction isValidPropertyIdentifier(name2) {\n  return /^[a-z_$][a-z0-9_$]*$/i.test(name2);\n}\nfunction toPropertyName(name2) {\n  if (isValidPropertyIdentifier(name2)) {\n    return import_compiler9.types.identifier(name2);\n  } else if (/^(?:0|[1-9][0-9]*)$/.test(name2)) {\n    return import_compiler9.types.numericLiteral(parseInt(name2, 10));\n  }\n  return import_compiler9.types.stringLiteral(name2);\n}\nfunction toObjectProperty(name2, value) {\n  return import_compiler9.types.objectProperty(toPropertyName(name2), value);\n}\nfunction toMemberExpression(object, key, optional) {\n  const prop = toPropertyName(key);\n  const computed = prop.type !== \"Identifier\";\n  return optional ? import_compiler9.types.optionalMemberExpression(object, prop, computed, true) : import_compiler9.types.memberExpression(object, prop, computed);\n}\n\n// src/translator/util/runtime.ts\nvar pureDOMFunctions = /* @__PURE__ */ new Set([\n  \"awaitTag\",\n  \"conditional\",\n  \"conditionalClosure\",\n  \"createTry\",\n  \"dynamicTag\",\n  \"createRenderer\",\n  \"createContent\",\n  \"createTemplate\",\n  \"dynamicClosure\",\n  \"dynamicClosureRead\",\n  \"intersection\",\n  \"loopClosure\",\n  \"loopIn\",\n  \"loopOf\",\n  \"loopTo\",\n  \"state\",\n  \"value\"\n]);\nfunction importRuntime(name2) {\n  const { output } = getMarkoOpts();\n  return toMemberExpression(\n    (0, import_babel_utils10.importStar)((0, import_babel_utils10.getFile)(), getRuntimePath(output), \"$\"),\n    name2\n  );\n}\nfunction callRuntime(name2, ...args) {\n  const callExpression2 = import_compiler10.types.callExpression(\n    importRuntime(name2),\n    filterArguments(args)\n  );\n  if (isOutputDOM() && pureDOMFunctions.has(name2)) {\n    callExpression2.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: ` @__PURE__ `\n      }\n    ];\n  }\n  return callExpression2;\n}\nfunction getHTMLRuntime() {\n  return {\n    escapeXML,\n    toString,\n    attr,\n    classAttr,\n    styleAttr,\n    escapeScript,\n    escapeStyle\n  };\n}\nfunction getRuntimePath(output) {\n  const { optimize } = getMarkoOpts();\n  return `${runtime_info_default.name}/${optimize ? \"\" : \"debug/\"}${output === \"html\" ? \"html\" : \"dom\"}`;\n}\nfunction filterArguments(args) {\n  const filteredArgs = [];\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (arg || filteredArgs.length) {\n      filteredArgs[i] = arg || import_compiler10.types.unaryExpression(\"void\", import_compiler10.types.numericLiteral(0));\n    }\n  }\n  return filteredArgs;\n}\nfunction getCompatRuntimeFile() {\n  const markoOpts = getMarkoOpts();\n  return `marko/src/runtime/helpers/tags-compat/${isOutputHTML() ? \"html\" : \"dom\"}${markoOpts.optimize ? \"\" : \"-debug\"}.${markoOpts.modules === \"esm\" ? \"mjs\" : \"js\"}`;\n}\n\n// src/translator/visitors/program/dom.ts\nvar import_compiler20 = require(\"@marko/compiler\");\nvar import_babel_utils13 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-style-file.ts\nvar import_path = __toESM(require(\"path\"));\nfunction getStyleFile(file) {\n  const { filename } = file.opts;\n  const fs = file.markoOpts.fileSystem;\n  const base = getBase(filename);\n  const styleMatch = new RegExp(\n    `^(${escapeRegExp(base)}\\\\.${\"index\" === base ? \"|\" : \"\"})style\\\\.\\\\w+$`\n  );\n  for (const file2 of fs.readdirSync(import_path.default.dirname(filename)).sort()) {\n    if (styleMatch.test(file2)) {\n      return `./${file2}`;\n    }\n  }\n}\nfunction getBase(filename) {\n  const start = filename.lastIndexOf(import_path.default.sep) + 1;\n  const leftDot = filename.indexOf(\".\", start);\n  if (leftDot === -1) {\n    return filename.slice(start);\n  }\n  const rightDot = filename.lastIndexOf(\".\");\n  const closeBracket = leftDot - 1;\n  if (filename[closeBracket] === \"]\") {\n    const openBracket = filename.lastIndexOf(\"[\", closeBracket);\n    if (openBracket > start) {\n      return filename.slice(start, openBracket) + filename.slice(leftDot, rightDot);\n    }\n  }\n  return filename.slice(start, rightDot);\n}\nvar regexpCharsReg = /[\\\\^$.*+?()[\\]{}|]/g;\nfunction escapeRegExp(str) {\n  return str.replace(regexpCharsReg, \"\\\\$&\");\n}\n\n// src/translator/util/signals.ts\nvar import_compiler19 = require(\"@marko/compiler\");\nvar import_babel_utils12 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/core/return.ts\nvar import_compiler15 = require(\"@marko/compiler\");\nvar import_babel_utils11 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/get-known-attr-values.ts\nfunction getKnownAttrValues(tag) {\n  const attrs2 = {};\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      attrs2[attr2.name] = attr2.value;\n    }\n  }\n  return attrs2;\n}\n\n// src/translator/util/get-parent-tag.ts\nfunction getParentTag(tag) {\n  const parent = tag.parent.type === \"MarkoTagBody\" ? tag.parentPath.parentPath : tag.parentPath;\n  if (parent.type === \"MarkoTag\") {\n    return parent;\n  }\n}\n\n// src/translator/util/plugin-hooks.ts\nvar import_compiler11 = require(\"@marko/compiler\");\nfunction enter(modulePlugin, path5) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path5;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (isFunctionPlugin(plugin)) {\n    plugin(path5, import_compiler11.types);\n  } else if (plugin.enter) {\n    plugin.enter(path5, import_compiler11.types);\n  }\n  return node !== path5.node;\n}\nfunction exit(modulePlugin, path5) {\n  if (!modulePlugin) {\n    return false;\n  }\n  const { node } = path5;\n  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;\n  if (!isFunctionPlugin(plugin) && plugin.exit) {\n    plugin.exit(path5, import_compiler11.types);\n  }\n  return node !== path5.node;\n}\nfunction isModulePlugin(plugin) {\n  return Boolean(plugin.default);\n}\nfunction isFunctionPlugin(plugin) {\n  return typeof plugin === \"function\";\n}\n\n// src/translator/util/visitors.ts\nfunction extractVisitors(visitors2) {\n  const result = {\n    migrate: {},\n    transform: {},\n    analyze: {},\n    translate: {}\n  };\n  for (const _name in visitors2) {\n    const name2 = _name;\n    const value = visitors2[name2];\n    if (value.migrate) result.migrate[name2] = value.migrate;\n    if (value.transform) result.transform[name2] = value.transform;\n    if (value.analyze) result.analyze[name2] = value.analyze;\n    if (value.translate) result.translate[name2] = value.translate;\n  }\n  return result;\n}\nfunction translateByTarget({\n  html,\n  dom\n}) {\n  return {\n    enter(path5) {\n      enter(isOutputHTML() ? html : dom, path5);\n    },\n    exit(path5) {\n      exit(isOutputHTML() ? html : dom, path5);\n    }\n  };\n}\n\n// src/translator/util/writer.ts\nvar import_compiler14 = require(\"@marko/compiler\");\n\n// src/translator/util/normalize-string-expression.ts\nvar import_compiler12 = require(\"@marko/compiler\");\nfunction normalizeStringExpression(parts) {\n  const strs = [];\n  const exprs = [];\n  let curStr = parts[0];\n  for (let i = 1; i < parts.length; i++) {\n    let content = parts[i];\n    if (typeof content === \"object\") {\n      if (import_compiler12.types.isStringLiteral(content)) {\n        content = content.value;\n      } else if (import_compiler12.types.isTemplateLiteral(content)) {\n        let nextIndex = i + 1;\n        const exprLen = content.expressions.length;\n        shiftItems(parts, nextIndex, content.quasis.length + exprLen);\n        for (let j = 0; j < exprLen; j++) {\n          parts[nextIndex++] = content.quasis[j].value.raw;\n          parts[nextIndex++] = content.expressions[j];\n        }\n        parts[nextIndex] = content.quasis[exprLen].value.raw;\n        continue;\n      } else {\n        exprs.push(content);\n        strs.push(curStr);\n        curStr = \"\";\n        continue;\n      }\n    }\n    curStr += content;\n  }\n  if (exprs.length) {\n    if (exprs.length === 1 && !curStr && !strs[0]) {\n      return exprs[0];\n    }\n    strs.push(curStr);\n    return import_compiler12.types.templateLiteral(\n      strs.map((raw) => import_compiler12.types.templateElement({ raw })),\n      exprs\n    );\n  } else if (curStr) {\n    return import_compiler12.types.stringLiteral(curStr);\n  }\n}\nfunction appendLiteral(arr, str) {\n  arr[arr.length - 1] += str;\n}\nfunction shiftItems(list, start, offset) {\n  for (let i = list.length - 1; i >= start; i--) {\n    list[i + offset] = list[i];\n  }\n}\n\n// src/translator/util/walks.ts\nvar import_compiler13 = require(\"@marko/compiler\");\nvar [getWalks] = createSectionState(\n  \"walks\",\n  () => [\"\"]\n);\nvar [getWalkComment] = createSectionState(\n  \"walkComment\",\n  () => []\n);\nvar [getSteps] = createSectionState(\"steps\", () => []);\nvar walkCodeToName = {\n  [32 /* Get */]: \"get\",\n  [36 /* Inside */]: \"inside\",\n  [37 /* Replace */]: \"replace\",\n  [38 /* EndChild */]: \"endChild\",\n  [47 /* BeginChild */]: \"beginChild\",\n  [48 /* BeginChildWithVar */]: \"beginChildWithVar\",\n  [49 /* DynamicTagWithVar */]: \"dynamicTagWithVar\",\n  [67 /* Next */]: \"next\",\n  [97 /* Over */]: \"over\",\n  [107 /* Out */]: \"out\",\n  [117 /* Multiplier */]: \"multiplier\",\n  [91 /* NextEnd */]: \"nextEnd\",\n  [106 /* OverEnd */]: \"overEnd\",\n  [116 /* OutEnd */]: \"outEnd\",\n  [126 /* MultiplierEnd */]: \"multiplierEnd\"\n};\nfunction enter2(path5) {\n  getSteps(getSection(path5)).push(0 /* Enter */);\n}\nfunction exit2(path5) {\n  getSteps(getSection(path5)).push(1 /* Exit */);\n}\nfunction enterShallow(path5) {\n  getSteps(getSection(path5)).push(0 /* Enter */, 1 /* Exit */);\n}\nfunction injectWalks(tag, expr) {\n  const walks = getWalks(getSection(tag));\n  const walkComment = getWalkComment(getSection(tag));\n  walkComment.push(\n    `${walkCodeToName[tag.node.var ? 48 /* BeginChildWithVar */ : 47 /* BeginChild */]}`,\n    expr.name,\n    walkCodeToName[38 /* EndChild */]\n  );\n  appendLiteral(\n    walks,\n    String.fromCharCode(\n      tag.node.var ? 48 /* BeginChildWithVar */ : 47 /* BeginChild */\n    )\n  );\n  walks.push(expr, String.fromCharCode(38 /* EndChild */));\n}\nfunction visit(path5, code) {\n  if (isOutputHTML()) {\n    return;\n  }\n  const section = getSection(path5);\n  const steps = getSteps(section);\n  const walks = getWalks(section);\n  const walkComment = getWalkComment(section);\n  let walkString = \"\";\n  if (steps.length) {\n    const walkCodes = [];\n    let depth = 0;\n    for (const step of steps) {\n      if (step === 0 /* Enter */) {\n        depth++;\n        walkCodes.push(67 /* Next */);\n      } else {\n        depth--;\n        if (depth >= 0) {\n          walkCodes.length = walkCodes.lastIndexOf(67 /* Next */);\n          walkCodes.push(97 /* Over */);\n        } else {\n          walkCodes.length = walkCodes.lastIndexOf(107 /* Out */) + 1;\n          walkCodes.push(107 /* Out */);\n          depth = 0;\n        }\n      }\n    }\n    let current = walkCodes[0];\n    let count = 0;\n    for (const walk of walkCodes) {\n      if (walk !== current) {\n        walkComment.push(`${walkCodeToName[current]}(${count})`);\n        walkString += nCodeString(current, count);\n        current = walk;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n    walkComment.push(`${walkCodeToName[current]}(${count})`);\n    walkString += nCodeString(current, count);\n    steps.length = 0;\n  }\n  if (code !== void 0) {\n    if (code !== 32 /* Get */) {\n      writeTo(path5)`<!>`;\n    }\n    walkComment.push(`${walkCodeToName[code]}`);\n    walkString += String.fromCharCode(code);\n  }\n  appendLiteral(walks, walkString);\n}\nfunction nCodeString(code, number) {\n  switch (code) {\n    case 67 /* Next */:\n      return toCharString(number, code, 20 /* Next */);\n    case 97 /* Over */:\n      return toCharString(number, code, 10 /* Over */);\n    case 107 /* Out */:\n      return toCharString(number, code, 10 /* Out */);\n    default:\n      throw new Error(`Unexpected walk code: ${code}`);\n  }\n}\nfunction toCharString(number, startCode, rangeSize) {\n  let result = \"\";\n  if (number >= rangeSize) {\n    const multiplier = Math.floor(number / rangeSize);\n    result += toCharString(\n      multiplier,\n      117 /* Multiplier */,\n      10 /* Multiplier */\n    );\n    number -= multiplier * rangeSize;\n  }\n  result += String.fromCharCode(startCode + number);\n  return result;\n}\nfunction getWalkString(section) {\n  const prefix2 = section.content?.startType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const postfix = section.content?.endType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : \"\";\n  const walks = getWalks(section);\n  const walkLiteral = normalizeStringExpression([prefix2, ...walks, postfix]);\n  if (walkLiteral && walkLiteral.value !== \"\") {\n    walkLiteral.leadingComments = [\n      {\n        type: \"CommentBlock\",\n        value: \" \" + getWalkComment(section).join(\", \") + \" \"\n      }\n    ];\n  }\n  return walkLiteral;\n}\n\n// src/translator/util/writer.ts\nvar [getWrites] = createSectionState(\n  \"writes\",\n  () => [\"\"]\n);\nvar [getTrailerWrites] = createSectionState(\n  \"trailerWrites\",\n  () => [\"\"]\n);\nfunction writeTo(path5, trailer) {\n  const section = getSection(path5);\n  const get = trailer ? getTrailerWrites : getWrites;\n  return (strs, ...exprs) => {\n    const exprsLen = exprs.length;\n    const writes = get(section);\n    appendLiteral(writes, strs[0]);\n    for (let i = 0; i < exprsLen; i++) {\n      writes.push(exprs[i], strs[i + 1]);\n    }\n  };\n}\nfunction consumeHTML(path5) {\n  const section = getSection(path5);\n  const writes = getWrites(section);\n  const trailers = getTrailerWrites(section);\n  const writeResult = normalizeStringExpression(writes);\n  const trailerResult = normalizeStringExpression(trailers);\n  writes.length = 0;\n  writes[0] = \"\";\n  trailers.length = 0;\n  trailers[0] = \"\";\n  if (writeResult && trailerResult) {\n    return import_compiler14.types.expressionStatement(\n      import_compiler14.types.sequenceExpression([\n        callRuntime(\"write\", writeResult),\n        callRuntime(\"writeTrailers\", trailerResult)\n      ])\n    );\n  } else if (writeResult) {\n    return import_compiler14.types.expressionStatement(callRuntime(\"write\", writeResult));\n  } else if (trailerResult) {\n    return import_compiler14.types.expressionStatement(callRuntime(\"writeTrailers\", trailerResult));\n  }\n}\nfunction flushBefore(path5) {\n  const expr = consumeHTML(path5);\n  if (expr) {\n    path5.insertBefore(expr)[0].skip();\n  }\n}\nfunction flushInto(path5) {\n  const target = path5.isProgram() ? path5 : path5.get(\"body\");\n  const expr = consumeHTML(target);\n  if (expr) {\n    target.node.body.push(expr);\n  }\n}\nfunction getSectionMeta(section) {\n  const writePrefix = section.content?.startType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writePostfix = section.content?.endType === 1 /* Dynamic */ ? \"<!>\" : \"\";\n  const writes = getWrites(section);\n  return {\n    setup: getSetup(section),\n    walks: getWalkString(section),\n    writes: normalizeStringExpression([writePrefix, ...writes, writePostfix])\n  };\n}\nfunction markNode(path5, binding) {\n  const section = getSection(path5);\n  if (binding.type !== 0 /* dom */) {\n    throw path5.buildCodeFrameError(\n      \"Tried to mark a node that was not determined to need a mark during analyze.\"\n    );\n  }\n  if (isOutputHTML()) {\n    writeTo(path5)`${callRuntime(\n      \"markResumeNode\",\n      getScopeIdIdentifier(section),\n      getScopeAccessorLiteral(binding)\n    )}`;\n  }\n}\n\n// src/translator/core/return.ts\nvar tagsWithReturn = /* @__PURE__ */ new WeakSet();\nvar [getSectionReturnValueIdentifier, setReturnValueIdentifier] = createSectionState(\"returnValue\");\nvar return_default = {\n  analyze(tag) {\n    (0, import_babel_utils11.assertNoArgs)(tag);\n    (0, import_babel_utils11.assertNoVar)(tag);\n    (0, import_babel_utils11.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils11.assertAllowedAttributes)(tag, [\"value\", \"valueChange\"]);\n    const parentTag = getParentTag(tag);\n    if (parentTag) {\n      if ((0, import_babel_utils11.isNativeTag)(parentTag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The `return` tag can not be used in a native tag.\"\n        );\n      } else if (isControlFlowTag(parentTag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          `The \\`return\\` tag can not be used under an \\`${parentTag.get(\"name\").toString()}\\` tag.`\n        );\n      }\n    }\n    if (tagsWithReturn.has(tag.parentPath)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        `Cannot have multiple \\`return\\` tags ${tag.parent.type === \"Program\" ? \"for the template\" : \"within a tag's body content\"}.`\n      );\n    } else {\n      tagsWithReturn.add(tag.parentPath);\n    }\n    if (!getKnownAttrValues(tag.node).value) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `return` tag requires a value.\");\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      exit(tag) {\n        const section = getSection(tag);\n        const attrs2 = getKnownAttrValues(tag.node);\n        flushBefore(tag);\n        if (attrs2.valueChange) {\n          setSerializedProperty(\n            section,\n            getAccessorProp().TagVariableChange,\n            attrs2.valueChange,\n            true\n            // TODO: this should be based on the child actually mutating the tag variable.\n          );\n        }\n        if (attrs2.value) {\n          const returnId = generateUidIdentifier(\"return\");\n          setReturnValueIdentifier(section, returnId);\n          tag.replaceWith(\n            import_compiler15.types.variableDeclaration(\"const\", [\n              import_compiler15.types.variableDeclarator(returnId, attrs2.value)\n            ])\n          )[0].skip();\n        }\n      }\n    },\n    dom: {\n      exit(tag) {\n        const section = getSection(tag);\n        const attrs2 = getKnownAttrValues(tag.node);\n        if (attrs2.value) {\n          addValue(\n            section,\n            attrs2.value.extra?.referencedBindings,\n            {\n              identifier: importRuntime(\"tagVarSignal\"),\n              hasDownstreamIntersections: () => true\n            },\n            attrs2.value\n          );\n        }\n        if (attrs2.valueChange) {\n          addValue(\n            section,\n            attrs2.valueChange.extra?.referencedBindings,\n            {\n              identifier: importRuntime(\"setTagVarChange\"),\n              hasDownstreamIntersections: () => false\n            },\n            attrs2.valueChange\n          );\n        }\n        tag.remove();\n      }\n    }\n  }),\n  parseOptions: {\n    openTagOnly: true\n  },\n  autocomplete: [\n    {\n      displayText: \"return=<value>\",\n      description: \"Provides a value for use in a parent template.\",\n      snippet: \"return=${1:value}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#return\"\n    }\n  ]\n};\n\n// src/translator/util/get-defined-binding-expression.ts\nvar import_compiler16 = require(\"@marko/compiler\");\nfunction getDeclaredBindingExpression(binding) {\n  if (binding.declared || !binding.upstreamAlias) {\n    return import_compiler16.types.identifier(binding.name);\n  } else if (binding.property !== void 0) {\n    return toMemberExpression(\n      getDeclaredBindingExpression(binding.upstreamAlias),\n      binding.property,\n      binding.upstreamAlias.nullable\n    );\n  } else {\n    return getDeclaredBindingExpression(binding.upstreamAlias);\n  }\n}\n\n// src/translator/util/simplify-fn.ts\nvar import_compiler17 = require(\"@marko/compiler\");\nfunction simplifyFunction(fn) {\n  switch (fn.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      return fn;\n    default:\n      return import_compiler17.types.functionExpression(\n        null,\n        fn.params,\n        fn.body,\n        fn.async,\n        fn.generator\n      );\n  }\n}\n\n// src/translator/util/to-first-expression-or-block.ts\nvar import_compiler18 = require(\"@marko/compiler\");\nfunction toFirstExpressionOrBlock(stmts) {\n  if (stmts.length === 1 && import_compiler18.types.isExpressionStatement(stmts[0])) {\n    const { expression } = stmts[0];\n    switch (expression.type) {\n      case \"ObjectExpression\":\n      case \"AssignmentExpression\":\n        return toParenthesizedExpressionIfNeeded(expression);\n      default:\n        return expression;\n    }\n  }\n  return import_compiler18.types.blockStatement(stmts);\n}\nfunction toParenthesizedExpressionIfNeeded(expr) {\n  switch (expr.type) {\n    case \"ObjectExpression\":\n    case \"AssignmentExpression\":\n      return import_compiler18.types.parenthesizedExpression(expr);\n    default:\n      return expr;\n  }\n}\n\n// src/translator/util/signals.ts\nvar [getSignals] = createSectionState(\n  \"signals\",\n  () => /* @__PURE__ */ new Map()\n);\nvar [getClosureSignalBuilder, _setClosureSignalBuilder] = createSectionState(\"queue\");\nfunction setClosureSignalBuilder(tag, builder) {\n  _setClosureSignalBuilder(getSectionForBody(tag.get(\"body\")), builder);\n}\nvar [serializeSectionReason, setSerializeSectionReason] = createSectionState(\"serializeSectionSources\");\nfunction serializeSectionIfNeeded(section, reason) {\n  if (reason) {\n    const existingReason = serializeSectionReason(section);\n    if (existingReason === true) return;\n    if (!existingReason || reason === true) {\n      setSerializeSectionReason(section, reason);\n    } else {\n      setSerializeSectionReason(\n        section,\n        bindingUtil.union(existingReason, reason)\n      );\n    }\n  }\n}\nvar [getSerializedScopeProperties] = createSectionState(\"serializedScopeProperties\", () => /* @__PURE__ */ new Map());\nfunction setSerializedProperty(section, key, expression, reason) {\n  if (reason) {\n    getSerializedScopeProperties(section).set(key, { expression, reason });\n  }\n}\nvar [getSectionWriteScopeBuilder, setSectionWriteScopeBuilder] = createSectionState(\n  \"sectionWriteScopeBuilder\"\n);\nfunction addWriteScopeBuilder(section, builder) {\n  const prev = getSectionWriteScopeBuilder(section);\n  setSectionWriteScopeBuilder(\n    section,\n    prev ? (expr) => builder(prev(expr)) : builder\n  );\n}\nvar htmlDynamicClosureInstancesIdentifier = /* @__PURE__ */ new WeakMap();\nvar [getHTMLSectionStatements] = createSectionState(\n  \"htmlScopeStatements\",\n  () => []\n);\nvar [getHoistFunctionsIdsMap] = createSectionState(\"hoistFunctionsIdsMap\", () => /* @__PURE__ */ new Map());\nfunction getHoistFunctionIdentifier(hoistedBinding) {\n  const idsMap = getHoistFunctionsIdsMap(hoistedBinding.section);\n  let identifier = idsMap.get(hoistedBinding);\n  if (!identifier) {\n    idsMap.set(\n      hoistedBinding,\n      identifier = generateUidIdentifier(`get${hoistedBinding.name}`)\n    );\n  }\n  return identifier;\n}\nvar unimplementedBuild = () => {\n  return import_compiler19.types.stringLiteral(\"SIGNAL NOT INITIALIZED\");\n};\nfunction getSignal(section, referencedBindings, name2 = generateSignalName(referencedBindings)) {\n  const signals = getSignals(section);\n  let signal = signals.get(referencedBindings);\n  if (!signal) {\n    const exportName = referencedBindings ? !Array.isArray(referencedBindings) && referencedBindings.section === section && referencedBindings.export : !section.parent && (0, import_babel_utils12.getProgram)().node.extra.domExports?.setup;\n    signals.set(\n      referencedBindings,\n      signal = {\n        identifier: exportName ? import_compiler19.types.identifier(exportName) : generateUidIdentifier(name2 + section.name.replace(\"_\", \"$\")),\n        referencedBindings,\n        section,\n        values: [],\n        intersection: void 0,\n        render: [],\n        renderReferencedBindings: void 0,\n        effect: [],\n        effectReferencedBindings: void 0,\n        subscribers: [],\n        hasDownstreamIntersections: () => {\n          let hasDownstreamIntersections = !!signal.intersection;\n          if (!hasDownstreamIntersections) {\n            for (const value of signal.values) {\n              if (value.signal.hasDownstreamIntersections()) {\n                hasDownstreamIntersections = true;\n                break;\n              }\n            }\n          }\n          if (!hasDownstreamIntersections) {\n            if (!Array.isArray(referencedBindings) && referencedBindings) {\n              for (const alias of referencedBindings.aliases) {\n                if (getSignal(section, alias).hasDownstreamIntersections()) {\n                  hasDownstreamIntersections = true;\n                  break;\n                }\n              }\n              if (!hasDownstreamIntersections) {\n                for (const [, alias] of referencedBindings.propertyAliases) {\n                  if (getSignal(section, alias).hasDownstreamIntersections()) {\n                    hasDownstreamIntersections = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          signal.hasDownstreamIntersections = () => hasDownstreamIntersections;\n          return hasDownstreamIntersections;\n        },\n        build: unimplementedBuild,\n        export: !!exportName\n      }\n    );\n    if (isOutputHTML()) {\n      return signal;\n    } else if (!referencedBindings) {\n      signal.build = () => getSignalFn(signal);\n    } else if (Array.isArray(referencedBindings)) {\n      subscribe(referencedBindings, signal);\n      signal.build = () => {\n        const { id, scopeOffset } = intersectionMeta.get(referencedBindings);\n        return callRuntime(\n          \"intersection\",\n          import_compiler19.types.numericLiteral(id),\n          getSignalFn(signal),\n          scopeOffset || referencedBindings.length > 2 ? import_compiler19.types.numericLiteral(referencedBindings.length - 1) : void 0,\n          scopeOffset && getScopeAccessorLiteral(scopeOffset)\n        );\n      };\n    } else if (referencedBindings.section !== section && bindingUtil.find(section.referencedClosures, referencedBindings)) {\n      signal.build = () => {\n        const render = getSignalFn(signal);\n        const closureSignalBuilder = getClosureSignalBuilder(section);\n        return !closureSignalBuilder || isDynamicClosure(section, referencedBindings) ? callRuntime(\n          \"dynamicClosureRead\",\n          getScopeAccessorLiteral(referencedBindings),\n          render,\n          isImmediateOwner(section, referencedBindings) ? void 0 : import_compiler19.types.arrowFunctionExpression(\n            [scopeIdentifier],\n            getScopeExpression(section, referencedBindings.section)\n          )\n        ) : getClosureSignalBuilder(section)(referencedBindings, render);\n      };\n    }\n  }\n  return signal;\n}\nfunction initValue(binding, runtimeHelper = \"value\") {\n  const section = binding.section;\n  const signal = getSignal(section, binding);\n  signal.build = () => {\n    const fn = getSignalFn(signal);\n    const isParamBinding = !binding.upstreamAlias && (binding.type === 3 /* param */ || binding.type === 2 /* input */);\n    const isNakedAlias = binding.upstreamAlias && !binding.property;\n    const needsGuard = !isNakedAlias && (binding.downstreamExpressions.size || fn.type === \"ArrowFunctionExpression\" && fn.body.body.length > 0);\n    const needsCache = needsGuard || signal.intersection;\n    const needsMarks = isParamBinding || signal.intersection;\n    if (needsCache || needsMarks || binding.hoists.size) {\n      return callRuntime(\n        runtimeHelper,\n        getScopeAccessorLiteral(binding, runtimeHelper === \"state\"),\n        fn\n      );\n    } else {\n      return fn;\n    }\n  };\n  signal.valueAccessor = getScopeAccessorLiteral(binding);\n  for (const alias of binding.aliases) {\n    initValue(alias);\n  }\n  for (const alias of binding.propertyAliases.values()) {\n    initValue(alias);\n  }\n  return signal;\n}\nfunction getSignalFn(signal) {\n  const section = signal.section;\n  const binding = signal.referencedBindings;\n  const params = [scopeIdentifier];\n  const isIntersection = Array.isArray(binding);\n  const isBinding = binding && !isIntersection;\n  const isValue = isBinding && binding.section === section;\n  let canUseCalleeDirectly = !signal.render.length;\n  if (isBinding && (signal.renderReferencedBindings || binding.aliases.size || binding.propertyAliases.size)) {\n    const valueParam = import_compiler19.types.identifier(binding.name);\n    if (binding.loc) {\n      valueParam.loc = binding.loc;\n      valueParam.start = binding.loc.start.index;\n      valueParam.end = binding.loc.end.index;\n    }\n    params.push(valueParam);\n  }\n  if (isValue) {\n    for (const alias of binding.aliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler19.types.expressionStatement(\n          import_compiler19.types.callExpression(aliasSignal.identifier, [\n            scopeIdentifier,\n            import_compiler19.types.identifier(binding.name),\n            ...getTranslatedExtraArgs(aliasSignal)\n          ])\n        )\n      );\n    }\n    for (const [key, alias] of binding.propertyAliases) {\n      const aliasSignal = getSignal(alias.section, alias);\n      signal.render.push(\n        import_compiler19.types.expressionStatement(\n          import_compiler19.types.callExpression(aliasSignal.identifier, [\n            scopeIdentifier,\n            toMemberExpression(\n              import_compiler19.types.identifier(binding.name),\n              key,\n              binding.nullable\n            ),\n            ...getTranslatedExtraArgs(aliasSignal)\n          ])\n        )\n      );\n    }\n  }\n  for (const value of signal.values) {\n    signal.render.push(\n      import_compiler19.types.expressionStatement(\n        import_compiler19.types.callExpression(value.signal.identifier, [\n          value.scope,\n          value.value,\n          ...getTranslatedExtraArgs(value.signal)\n        ])\n      )\n    );\n  }\n  forEach(signal.intersection, (intersection) => {\n    signal.render.push(\n      import_compiler19.types.expressionStatement(import_compiler19.types.callExpression(intersection, [scopeIdentifier]))\n    );\n  });\n  if (isValue) {\n    let dynamicClosureArgs;\n    let dynamicClosureSignalIdentifier;\n    forEach(binding.closureSections, (closureSection) => {\n      if (binding.sources) {\n        if (isDynamicClosure(closureSection, binding)) {\n          if (!dynamicClosureArgs) {\n            dynamicClosureArgs = [];\n            dynamicClosureSignalIdentifier = generateUidIdentifier(\n              signal.identifier.name + \"_closure\"\n            );\n            signal.render.push(\n              import_compiler19.types.expressionStatement(\n                import_compiler19.types.callExpression(dynamicClosureSignalIdentifier, [\n                  scopeIdentifier\n                ])\n              )\n            );\n          }\n          dynamicClosureArgs.push(\n            getSignal(closureSection, binding).identifier\n          );\n        } else {\n          signal.render.push(\n            import_compiler19.types.expressionStatement(\n              import_compiler19.types.callExpression(getSignal(closureSection, binding).identifier, [\n                scopeIdentifier\n              ])\n            )\n          );\n        }\n      }\n    });\n    if (dynamicClosureSignalIdentifier) {\n      (signal.prependStatements ||= []).push(\n        import_compiler19.types.variableDeclaration(\"const\", [\n          import_compiler19.types.variableDeclarator(\n            dynamicClosureSignalIdentifier,\n            callRuntime(\"dynamicClosure\", ...dynamicClosureArgs)\n          )\n        ])\n      );\n    }\n  }\n  if (signal.effect.length) {\n    const effectIdentifier = import_compiler19.types.identifier(`${signal.identifier.name}_effect`);\n    signal.render.push(\n      import_compiler19.types.expressionStatement(\n        import_compiler19.types.callExpression(effectIdentifier, [scopeIdentifier])\n      )\n    );\n  }\n  if (isIntersection && signal.renderReferencedBindings) {\n    signal.render.unshift(\n      import_compiler19.types.variableDeclaration(\"const\", [\n        import_compiler19.types.variableDeclarator(\n          createScopeReadPattern(section, signal.renderReferencedBindings),\n          scopeIdentifier\n        )\n      ])\n    );\n  }\n  if (canUseCalleeDirectly && signal.render.length === 1) {\n    const render = signal.render[0];\n    if (render.type === \"ExpressionStatement\") {\n      const { expression } = render;\n      if (expression.type === \"CallExpression\") {\n        const args = expression.arguments;\n        if (params.length >= args.length) {\n          for (let i = args.length; i--; ) {\n            const param = params[i];\n            const arg = args[i];\n            if (arg.type !== \"Identifier\" || param.name !== arg.name) {\n              canUseCalleeDirectly = false;\n              break;\n            }\n          }\n          if (canUseCalleeDirectly) {\n            return expression.callee;\n          }\n        }\n      }\n    }\n  }\n  return import_compiler19.types.arrowFunctionExpression(params, import_compiler19.types.blockStatement(signal.render));\n}\nvar hasTranslatedExtraArgs = /* @__PURE__ */ new WeakSet();\nvar emptyExtraArgs = [];\nfunction getTranslatedExtraArgs(signal) {\n  if (signal.extraArgs) {\n    if (!hasTranslatedExtraArgs.has(signal)) {\n      hasTranslatedExtraArgs.add(signal);\n      traverseReplace(signal, \"extraArgs\", replaceRenderNode);\n    }\n    return signal.extraArgs;\n  }\n  return emptyExtraArgs;\n}\nfunction subscribe(provider, subscriber) {\n  if (Array.isArray(provider)) {\n    provider.forEach((p) => subscribe(p, subscriber));\n    return;\n  }\n  const providerSignal = getSignal(subscriber.section, provider);\n  providerSignal.intersection = push(\n    providerSignal.intersection,\n    subscriber.identifier\n  );\n}\nfunction generateSignalName(referencedBindings) {\n  let name2;\n  if (referencedBindings) {\n    if (Array.isArray(referencedBindings)) {\n      name2 = \"expr\";\n      for (const ref of referencedBindings) {\n        name2 += `_${ref.name}`;\n      }\n    } else {\n      name2 = referencedBindings.name;\n    }\n  } else {\n    name2 = \"setup\";\n  }\n  return name2;\n}\nfunction replaceNullishAndEmptyFunctionsWith0(args) {\n  for (let i = args.length; i--; ) {\n    const arg = args[i];\n    if (!arg) {\n      args[i] = import_compiler19.types.numericLiteral(0);\n    } else if (import_compiler19.types.isArrowFunctionExpression(arg) && import_compiler19.types.isBlockStatement(arg.body)) {\n      const body = arg.body.body;\n      if (body.length === 0) {\n        args[i] = import_compiler19.types.numericLiteral(0);\n      } else if (body.length === 1 && import_compiler19.types.isExpressionStatement(body[0])) {\n        arg.body = toParenthesizedExpressionIfNeeded(body[0].expression);\n      }\n    } else if (import_compiler19.types.isNullLiteral(arg) || import_compiler19.types.isUnaryExpression(arg) && arg.operator === \"void\") {\n      args[i] = import_compiler19.types.numericLiteral(0);\n    }\n  }\n  for (let i = args.length - 1; import_compiler19.types.isNumericLiteral(args[i]) && args[i].value === 0; ) {\n    args.length = i--;\n  }\n  return args;\n}\nfunction addStatement(type, targetSection, referencedBindings, statement, usedReferences) {\n  const signal = getSignal(targetSection, referencedBindings);\n  const statements = signal[type] ??= [];\n  const add = type === \"effect\" ? addEffectReferences : addRenderReferences;\n  if (Array.isArray(statement)) {\n    statements.push(...statement);\n  } else {\n    statements.push(statement);\n  }\n  if (usedReferences !== false) {\n    if (usedReferences) {\n      for (const ref of usedReferences) {\n        add(signal, ref);\n      }\n    } else {\n      add(signal, referencedBindings);\n    }\n  }\n}\nfunction addEffectReferences(signal, referencedBindings) {\n  signal.effectReferencedBindings = bindingUtil.union(\n    signal.effectReferencedBindings,\n    referencedBindings\n  );\n}\nfunction addRenderReferences(signal, referencedBindings) {\n  signal.renderReferencedBindings = bindingUtil.union(\n    signal.renderReferencedBindings,\n    referencedBindings\n  );\n}\nfunction addValue(targetSection, referencedBindings, signal, value, scope = scopeIdentifier) {\n  const parentSignal = getSignal(targetSection, referencedBindings);\n  addRenderReferences(parentSignal, referencedBindings);\n  parentSignal.values.push({\n    signal,\n    value,\n    scope\n  });\n}\nfunction getResumeRegisterId(section, referencedBindings, type) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = (0, import_babel_utils12.getFile)();\n  let name2 = \"\";\n  if (referencedBindings) {\n    if (typeof referencedBindings === \"string\") {\n      name2 += `_${referencedBindings}`;\n    } else if (Array.isArray(referencedBindings)) {\n      for (const ref of referencedBindings) {\n        name2 += `_${ref.name}`;\n      }\n    } else {\n      name2 += `_${referencedBindings.name}`;\n    }\n  }\n  return (0, import_babel_utils12.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}${name2}${type ? \"/\" + type : \"\"}`\n  );\n}\nvar usedRegisterIdsBySection = /* @__PURE__ */ new WeakMap();\nfunction getRegisterUID(section, name2) {\n  const {\n    markoOpts,\n    opts: { filename }\n  } = (0, import_babel_utils12.getFile)();\n  let used = usedRegisterIdsBySection.get(section);\n  if (!used) usedRegisterIdsBySection.set(section, used = /* @__PURE__ */ new Set());\n  const baseId = (0, import_babel_utils12.getTemplateId)(\n    markoOpts,\n    filename,\n    `${section.id}/${name2}`\n  );\n  let count = 0;\n  let id = baseId;\n  while (used.has(id)) {\n    id = baseId + \"_\" + ++count;\n  }\n  used.add(id);\n  return id;\n}\nfunction writeSignals(section) {\n  forEach(section.hoisted, (binding) => {\n    for (const hoistedBinding of binding.hoists.values()) {\n      const accessors = [\n        binding.type === 0 /* dom */ ? import_compiler19.types.stringLiteral(\n          getAccessorPrefix().Getter + getScopeAccessor(binding)\n        ) : getScopeAccessorLiteral(binding)\n      ];\n      let currentSection = section;\n      while (currentSection && currentSection !== hoistedBinding.section) {\n        const parentSection = currentSection.parent;\n        if (parentSection) {\n          accessors.push(getSectionInstancesAccessorLiteral(currentSection));\n        }\n        currentSection = parentSection;\n      }\n      const hoistIdentifier = getHoistFunctionIdentifier(hoistedBinding);\n      (0, import_babel_utils12.getProgram)().node.body.push(\n        import_compiler19.types.variableDeclaration(\"const\", [\n          import_compiler19.types.variableDeclarator(\n            hoistIdentifier,\n            hoistedBinding.downstreamExpressions.size ? callRuntime(\n              \"register\",\n              import_compiler19.types.stringLiteral(\n                getResumeRegisterId(\n                  hoistedBinding.section,\n                  hoistedBinding,\n                  \"hoist\"\n                )\n              ),\n              callRuntime(\"hoist\", ...accessors)\n            ) : callRuntime(\"hoist\", ...accessors)\n          )\n        ])\n      );\n      if (hoistedBinding.downstreamExpressions.size) {\n        addValue(\n          hoistedBinding.section,\n          void 0,\n          initValue(hoistedBinding),\n          import_compiler19.types.callExpression(hoistIdentifier, [scopeIdentifier])\n        );\n      }\n    }\n  });\n  const signals = [...getSignals(section).values()].sort(sortSignals);\n  for (const signal of signals) {\n    traverseReplace(signal, \"render\", replaceRenderNode);\n    for (const value2 of signal.values) {\n      traverseReplace(value2, \"value\", replaceRenderNode);\n    }\n    let effectDeclarator;\n    if (signal.effect.length) {\n      traverseReplace(signal, \"effect\", replaceEffectNode);\n      const effectIdentifier = import_compiler19.types.identifier(`${signal.identifier.name}_effect`);\n      const referencedBindings = signal.effectReferencedBindings;\n      const referencesScope = traverseContains(\n        signal.effect,\n        isScopeIdentifier\n      );\n      effectDeclarator = import_compiler19.types.variableDeclarator(\n        effectIdentifier,\n        callRuntime(\n          \"effect\",\n          import_compiler19.types.stringLiteral(\n            getResumeRegisterId(section, signal.referencedBindings)\n          ),\n          import_compiler19.types.arrowFunctionExpression(\n            referencedBindings ? referencesScope ? [\n              scopeIdentifier,\n              createScopeReadPattern(section, referencedBindings)\n            ] : [createScopeReadPattern(section, referencedBindings)] : referencesScope ? [scopeIdentifier] : [],\n            toFirstExpressionOrBlock(signal.effect)\n          )\n        )\n      );\n    }\n    let value = signal.build();\n    if (import_compiler19.types.isCallExpression(value)) {\n      replaceNullishAndEmptyFunctionsWith0(value.arguments);\n    }\n    if (signal.register) {\n      value = callRuntime(\n        \"registerBoundSignal\",\n        import_compiler19.types.stringLiteral(\n          getResumeRegisterId(section, signal.referencedBindings, \"var\")\n        ),\n        value\n      );\n    }\n    const signalDeclarator = import_compiler19.types.variableDeclarator(signal.identifier, value);\n    let signalDeclaration = !section.parent && !signal.referencedBindings && (import_compiler19.types.isFunctionExpression(value) || import_compiler19.types.isArrowFunctionExpression(value)) ? import_compiler19.types.functionDeclaration(\n      signal.identifier,\n      value.params,\n      import_compiler19.types.isExpression(value.body) ? import_compiler19.types.blockStatement([import_compiler19.types.expressionStatement(value.body)]) : value.body\n    ) : import_compiler19.types.variableDeclaration(\"const\", [signalDeclarator]);\n    if (signal.export) {\n      signalDeclaration = import_compiler19.types.exportNamedDeclaration(signalDeclaration);\n    }\n    const signalStatements = signal.prependStatements || [];\n    if (effectDeclarator) {\n      signalStatements.push(import_compiler19.types.variableDeclaration(\"const\", [effectDeclarator]));\n    }\n    signalStatements.push(signalDeclaration);\n    (0, import_babel_utils12.getProgram)().node.body.push(...signalStatements);\n  }\n}\nfunction writeRegisteredFns() {\n  const registeredFns = registeredFnsForProgram.get((0, import_babel_utils12.getProgram)().node);\n  const statements = [];\n  if (registeredFns) {\n    for (const registeredFn of registeredFns) {\n      let fn;\n      const params = registeredFn.referencedBindings ? registeredFn.referencesScope ? [\n        scopeIdentifier,\n        import_compiler19.types.assignmentPattern(\n          createScopeReadPattern(\n            registeredFn.section,\n            registeredFn.referencedBindings\n          ),\n          scopeIdentifier\n        )\n      ] : [\n        createScopeReadPattern(\n          registeredFn.section,\n          registeredFn.referencedBindings\n        )\n      ] : registeredFn.referencesScope ? [scopeIdentifier] : void 0;\n      if (params) {\n        fn = import_compiler19.types.functionDeclaration(\n          import_compiler19.types.identifier(registeredFn.id),\n          params,\n          import_compiler19.types.blockStatement(toReturnedFunction(registeredFn.node))\n        );\n      } else if (registeredFn.node.type === \"FunctionDeclaration\" && registeredFn.node.id?.name === registeredFn.id) {\n        fn = registeredFn.node;\n      } else {\n        fn = import_compiler19.types.functionDeclaration(\n          import_compiler19.types.identifier(registeredFn.id),\n          registeredFn.node.params,\n          registeredFn.node.body.type === \"BlockStatement\" ? registeredFn.node.body : import_compiler19.types.blockStatement([import_compiler19.types.returnStatement(registeredFn.node.body)]),\n          registeredFn.node.generator,\n          registeredFn.node.async\n        );\n      }\n      statements.push(fn);\n    }\n    for (const registeredFn of registeredFns) {\n      statements.push(\n        import_compiler19.types.expressionStatement(\n          callRuntime(\n            \"register\",\n            import_compiler19.types.stringLiteral(registeredFn.registerId),\n            import_compiler19.types.identifier(registeredFn.id)\n          )\n        )\n      );\n    }\n    (0, import_babel_utils12.getProgram)().node.body.push(...statements);\n  }\n}\nfunction toReturnedFunction(rawFn) {\n  const fn = simplifyFunction(rawFn);\n  return fn.type === \"FunctionDeclaration\" ? [fn, import_compiler19.types.returnStatement(fn.id)] : [import_compiler19.types.returnStatement(fn)];\n}\nfunction sortSignals(a, b) {\n  const aReferencedBindings = getReferencedBindings(a);\n  const bReferencedBindings = getReferencedBindings(b);\n  for (let i = Math.max(aReferencedBindings.length, bReferencedBindings.length) - 1; i >= 0; i--) {\n    const diff = (bReferencedBindings[i] ?? -1) - (aReferencedBindings[i] ?? -1);\n    if (diff !== 0) return diff;\n  }\n  return 0;\n}\nfunction getReferencedBindings({ referencedBindings: reserve }) {\n  if (!reserve) {\n    return [];\n  } else if (Array.isArray(reserve)) {\n    return reserve.map(getMappedId).sort();\n  } else {\n    return [getMappedId(reserve)];\n  }\n}\nfunction getMappedId(reference) {\n  return (reference.type === 0 /* dom */ ? 1 : 0) * 1e4 + reference.id;\n}\nfunction addHTMLEffectCall(section, referencedBindings) {\n  addStatement(\"effect\", section, referencedBindings, void 0, false);\n}\nfunction writeHTMLResumeStatements(path5) {\n  const section = getSectionForBody(path5);\n  if (!section) return;\n  const body = path5.node.body;\n  const allSignals = Array.from(getSignals(section).values());\n  const scopeIdIdentifier = getScopeIdIdentifier(section);\n  const serializeOwnersUntilBinding = (binding) => serializeOwners(section, binding.section);\n  forEach(section.assignments, serializeOwnersUntilBinding);\n  forEach(section.referencedHoists, serializeOwnersUntilBinding);\n  forEach(section.referencedClosures, (closure) => {\n    if (closure.sources) {\n      const serializeReason = getDynamicSourcesForBinding(closure);\n      serializeOwnersUntilBinding(closure);\n      serializeSectionIfNeeded(closure.section, serializeReason);\n      if (isDynamicClosure(section, closure)) {\n        const closureSignal = getSignal(closure.section, closure);\n        let identifier = htmlDynamicClosureInstancesIdentifier.get(closureSignal);\n        if (!identifier) {\n          htmlDynamicClosureInstancesIdentifier.set(\n            closureSignal,\n            identifier = generateUidIdentifier(\n              closureSignal.identifier.name + \"_closures\"\n            )\n          );\n          getHTMLSectionStatements(closure.section).push(\n            import_compiler19.types.variableDeclaration(\"const\", [\n              import_compiler19.types.variableDeclarator(\n                identifier,\n                import_compiler19.types.newExpression(import_compiler19.types.identifier(\"Set\"), [])\n              )\n            ])\n          );\n          setSerializedProperty(\n            closure.section,\n            getAccessorPrefix().ClosureScopes + getScopeAccessor(closure),\n            identifier,\n            serializeReason\n          );\n        }\n        setSerializedProperty(\n          section,\n          getAccessorPrefix().ClosureSignalIndex + getScopeAccessor(closure),\n          import_compiler19.types.numericLiteral(getDynamicClosureIndex(closure, section)),\n          serializeReason\n        );\n        addWriteScopeBuilder(\n          section,\n          (expr) => callRuntime(\"writeSubscribe\", identifier, expr)\n        );\n      }\n    }\n  });\n  const sectionDynamicSubscribers = /* @__PURE__ */ new Set();\n  forEach(section.hoisted, (binding) => {\n    for (const hoistedBinding of binding.hoists.values()) {\n      if (hoistedBinding.downstreamExpressions.size) {\n        getHTMLSectionStatements(hoistedBinding.section).push(\n          import_compiler19.types.variableDeclaration(\"const\", [\n            import_compiler19.types.variableDeclarator(\n              import_compiler19.types.identifier(hoistedBinding.name),\n              callRuntime(\n                \"hoist\",\n                getScopeIdIdentifier(hoistedBinding.section),\n                import_compiler19.types.stringLiteral(\n                  getResumeRegisterId(\n                    hoistedBinding.section,\n                    hoistedBinding,\n                    \"hoist\"\n                  )\n                )\n              )\n            )\n          ])\n        );\n      }\n      let currentSection = section;\n      while (currentSection && currentSection !== hoistedBinding.section) {\n        const parentSection = currentSection.parent;\n        if (!currentSection.sectionAccessor && !sectionDynamicSubscribers.has(currentSection)) {\n          const subscribersIdentifier = generateUidIdentifier(\n            `${currentSection.name}_subscribers`\n          );\n          sectionDynamicSubscribers.add(currentSection);\n          getHTMLSectionStatements(parentSection).push(\n            import_compiler19.types.variableDeclaration(\"const\", [\n              import_compiler19.types.variableDeclarator(\n                subscribersIdentifier,\n                import_compiler19.types.newExpression(import_compiler19.types.identifier(\"Set\"), [])\n              )\n            ])\n          );\n          addWriteScopeBuilder(\n            currentSection,\n            (expr) => callRuntime(\"writeSubscribe\", subscribersIdentifier, expr)\n          );\n          setSerializedProperty(\n            parentSection,\n            getSectionInstancesAccessor(currentSection),\n            subscribersIdentifier,\n            true\n          );\n        }\n        currentSection = parentSection;\n      }\n    }\n    if (binding.hoists.size && binding.type !== 0 /* dom */) {\n      setSerializedProperty(\n        section,\n        getScopeAccessor(binding),\n        getDeclaredBindingExpression(binding),\n        true\n      );\n    }\n  });\n  for (let i = allSignals.length; i--; ) {\n    if (allSignals[i].effect.length) {\n      const signalRefs = allSignals[i].referencedBindings;\n      body.push(\n        import_compiler19.types.expressionStatement(\n          callRuntime(\n            \"writeEffect\",\n            scopeIdIdentifier,\n            import_compiler19.types.stringLiteral(getResumeRegisterId(section, signalRefs))\n          )\n        )\n      );\n    }\n  }\n  const serializedLookup = getSerializedScopeProperties(section);\n  const serializedProperties = [];\n  forEach(section.bindings, (binding) => {\n    if (binding.serialize && binding.type !== 0 /* dom */) {\n      const accessor = getScopeAccessor(binding);\n      serializedLookup.delete(accessor);\n      serializedProperties.push(\n        toObjectProperty(accessor, getDeclaredBindingExpression(binding))\n      );\n    }\n  });\n  for (const [key, { expression }] of serializedLookup) {\n    serializedProperties.push(toObjectProperty(key, expression));\n  }\n  const writeScopeBuilder = getSectionWriteScopeBuilder(section);\n  const forceSerializeReason = serializeSectionReason(section);\n  if (writeScopeBuilder || serializedProperties.length || forceSerializeReason) {\n    for (const prop of serializedProperties) {\n      if (prop.key.type === \"Identifier\" && prop.value.type === \"Identifier\" && prop.key.name === prop.value.name) {\n        prop.shorthand = true;\n      }\n    }\n    const writeScopeArgs = [\n      scopeIdIdentifier,\n      import_compiler19.types.objectExpression(serializedProperties)\n    ];\n    if (!isOptimize()) {\n      let debugVars;\n      forEach(section.bindings, (binding) => {\n        if (!binding.serialize || binding.type === 0 /* dom */) return;\n        let root = binding;\n        let access = \"\";\n        while (!(root.loc || root.declared) && root.upstreamAlias) {\n          if (root.property !== void 0) {\n            access = toAccess(root.property) + access;\n          }\n          root = root.upstreamAlias;\n        }\n        const locExpr = root.loc && import_compiler19.types.stringLiteral(\n          `${root.loc.start.line}:${root.loc.start.column + 1}`\n        );\n        (debugVars ||= []).push(\n          toObjectProperty(\n            getScopeAccessor(binding),\n            root !== binding ? import_compiler19.types.arrayExpression(\n              locExpr ? [import_compiler19.types.stringLiteral(root.name + access), locExpr] : [import_compiler19.types.stringLiteral(root.name + access)]\n            ) : locExpr || import_compiler19.types.numericLiteral(0)\n          )\n        );\n      });\n      writeScopeArgs.push(\n        import_compiler19.types.stringLiteral(path5.hub.file.opts.filenameRelative),\n        section.loc && section.loc.start.line != null ? import_compiler19.types.stringLiteral(\n          `${section.loc.start.line}:${section.loc.start.column + 1}`\n        ) : import_compiler19.types.numericLiteral(0)\n      );\n      if (debugVars) {\n        writeScopeArgs.push(import_compiler19.types.objectExpression(debugVars));\n      }\n    }\n    body.push(\n      import_compiler19.types.expressionStatement(\n        writeScopeBuilder ? writeScopeBuilder(callRuntime(\"writeScope\", ...writeScopeArgs)) : callRuntime(\"writeScope\", ...writeScopeArgs)\n      )\n    );\n  }\n  const resumeClosestBranch2 = !section.isBranch && (section.hasAbortSignal || !!section.referencedClosures || !!find(section.bindings, (binding) => binding.type === 1 /* let */));\n  if (resumeClosestBranch2) {\n    body.push(\n      import_compiler19.types.expressionStatement(\n        callRuntime(\"resumeClosestBranch\", scopeIdIdentifier)\n      )\n    );\n  }\n  const additionalStatements = getHTMLSectionStatements(section);\n  if (body.length || additionalStatements.length) {\n    body.unshift(\n      import_compiler19.types.variableDeclaration(\"const\", [\n        import_compiler19.types.variableDeclarator(scopeIdIdentifier, callRuntime(\"nextScopeId\"))\n      ]),\n      ...additionalStatements\n    );\n  }\n  const returnIdentifier = getSectionReturnValueIdentifier(section);\n  if (returnIdentifier !== void 0) {\n    body.push(import_compiler19.types.returnStatement(returnIdentifier));\n  }\n}\nfunction serializeOwners(from, to) {\n  let cur = from;\n  while (cur !== to) {\n    const parent = cur.parent;\n    if (!parent) break;\n    const serialized = getSerializedScopeProperties(cur);\n    cur = parent;\n    if (!serialized.has(\"_\")) {\n      serialized.set(\"_\", {\n        expression: callRuntime(\"ensureScopeWithId\", getScopeIdIdentifier(cur)),\n        reason: true\n      });\n    }\n  }\n}\nfunction getSetup(section) {\n  return getSignals(section).get(void 0)?.identifier;\n}\nfunction replaceRenderNode(node) {\n  return replaceAssignedNode(node) || replaceBindingReadNode(node) || replaceRegisteredFunctionNode(node);\n}\nfunction replaceEffectNode(node) {\n  return replaceAssignedNode(node) || replaceBindingReadNode(node);\n}\nfunction replaceBindingReadNode(node) {\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\": {\n      return getReadReplacement(node);\n    }\n  }\n}\nfunction replaceAssignedNode(node) {\n  switch (node.type) {\n    case \"UpdateExpression\": {\n      const { extra } = node.argument;\n      if (isAssignedBindingExtra(extra)) {\n        const { buildAssignment } = getSignal(\n          extra.assignment.section,\n          extra.assignment\n        );\n        if (buildAssignment) {\n          const replacement = buildAssignment(\n            extra.section,\n            import_compiler19.types.binaryExpression(\n              node.operator === \"++\" ? \"+\" : \"-\",\n              node.argument,\n              import_compiler19.types.numericLiteral(1)\n            )\n          );\n          if (!node.prefix) {\n            return import_compiler19.types.sequenceExpression([replacement, node.argument]);\n          }\n          return replacement;\n        }\n      }\n      break;\n    }\n    case \"AssignmentExpression\":\n      switch (node.left.type) {\n        case \"Identifier\": {\n          const { extra } = node.left;\n          if (isAssignedBindingExtra(extra)) {\n            const { buildAssignment } = getSignal(\n              extra.assignment.section,\n              extra.assignment\n            );\n            if (buildAssignment) {\n              return buildAssignment(\n                extra.section,\n                node.operator === \"=\" ? node.right : import_compiler19.types.binaryExpression(\n                  node.operator.slice(\n                    0,\n                    -1\n                  ),\n                  node.left,\n                  node.right\n                )\n              );\n            }\n          }\n          break;\n        }\n        case \"ArrayPattern\":\n        case \"ObjectPattern\": {\n          let params;\n          let assignments;\n          forEachIdentifier(node.left, (id) => {\n            const { extra } = id;\n            if (isAssignedBindingExtra(extra)) {\n              const signal = getSignal(\n                extra.assignment.section,\n                extra.assignment\n              );\n              if (signal?.buildAssignment) {\n                id.name = generateUid(id.name);\n                (params ||= []).push(import_compiler19.types.identifier(id.name));\n                (assignments ||= []).push(\n                  signal.buildAssignment(extra.section, import_compiler19.types.identifier(id.name))\n                );\n              }\n            }\n          });\n          if (params && assignments) {\n            const resultId = generateUid(\"result\");\n            return import_compiler19.types.callExpression(\n              import_compiler19.types.arrowFunctionExpression(\n                [import_compiler19.types.identifier(resultId), ...params],\n                import_compiler19.types.sequenceExpression([\n                  import_compiler19.types.assignmentExpression(\n                    \"=\",\n                    node.left,\n                    import_compiler19.types.identifier(resultId)\n                  ),\n                  ...assignments,\n                  import_compiler19.types.identifier(resultId)\n                ])\n              ),\n              [node.right]\n            );\n          }\n          break;\n        }\n      }\n      break;\n  }\n}\nvar registeredFnsForProgram = /* @__PURE__ */ new WeakMap();\nfunction replaceRegisteredFunctionNode(node) {\n  switch (node.type) {\n    case \"ClassMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler19.types.classProperty(node.key, replacement);\n    }\n    case \"ClassPrivateMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler19.types.classPrivateProperty(node.key, replacement);\n    }\n    case \"ObjectMethod\": {\n      const replacement = getRegisteredFnExpression(node);\n      return replacement && import_compiler19.types.objectProperty(node.key, replacement);\n    }\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\": {\n      return getRegisteredFnExpression(node);\n    }\n    case \"FunctionDeclaration\": {\n      const replacement = getRegisteredFnExpression(node);\n      if (replacement) {\n        return import_compiler19.types.variableDeclaration(\"const\", [\n          import_compiler19.types.variableDeclarator(node.id, replacement)\n        ]);\n      }\n      break;\n    }\n  }\n}\nfunction getRegisteredFnExpression(node) {\n  const { extra } = node;\n  if (isRegisteredFnExtra(extra)) {\n    const id = extra.name;\n    const referencesScope = extra.referencesScope;\n    const referencedBindings = extra.referencedBindingsInFunction;\n    let registedFns = registeredFnsForProgram.get((0, import_babel_utils12.getProgram)().node);\n    if (!registedFns) {\n      registeredFnsForProgram.set((0, import_babel_utils12.getProgram)().node, registedFns = []);\n    }\n    registedFns.push({\n      id,\n      node,\n      registerId: extra.registerId,\n      section: extra.section,\n      referencesScope,\n      referencedBindings\n    });\n    if (referencesScope || referencedBindings) {\n      return import_compiler19.types.callExpression(import_compiler19.types.identifier(id), [scopeIdentifier]);\n    } else {\n      return import_compiler19.types.identifier(id);\n    }\n  }\n}\nfunction getDynamicClosureIndex(closure, closureSection) {\n  let index = 0;\n  find(closure.closureSections, (section) => {\n    if (section === closureSection) return true;\n    if (isDynamicClosure(section, closure)) {\n      index++;\n    }\n    return false;\n  });\n  return index;\n}\n\n// src/translator/visitors/program/dom.ts\nvar dom_default = {\n  translate: {\n    exit(program) {\n      visit(program);\n      const section = getSectionForBody(program);\n      const { walks, writes, setup } = getSectionMeta(section);\n      const domExports = program.node.extra.domExports;\n      const templateIdentifier = import_compiler20.types.identifier(domExports.template);\n      const walksIdentifier = import_compiler20.types.identifier(domExports.walks);\n      const setupIdentifier = import_compiler20.types.identifier(domExports.setup);\n      const inputBinding = program.node.params[0].extra?.binding;\n      const programInputSignal = inputBinding && bindingHasDownstreamExpressions(inputBinding) ? initValue(inputBinding) : void 0;\n      const styleFile = getStyleFile(program.hub.file);\n      if (styleFile) {\n        (0, import_babel_utils13.importDefault)(program.hub.file, styleFile);\n      }\n      forEachSectionReverse((childSection) => {\n        if (childSection !== section) {\n          const tagParamsSignal = childSection.params && initValue(childSection.params);\n          const { walks: walks2, writes: writes2, setup: setup2 } = getSectionMeta(childSection);\n          const identifier = import_compiler20.types.identifier(childSection.name);\n          const referencedClosures = childSection.referencedClosures ? import_compiler20.types.arrowFunctionExpression(\n            [scopeIdentifier],\n            toFirstExpressionOrBlock(\n              map(childSection.referencedClosures, (closure) => {\n                const closureSignal = getSignal(childSection, closure);\n                return import_compiler20.types.expressionStatement(\n                  import_compiler20.types.callExpression(\n                    isDynamicClosure(childSection, closure) ? closureSignal.identifier : import_compiler20.types.memberExpression(\n                      closureSignal.identifier,\n                      import_compiler20.types.identifier(\"_\")\n                    ),\n                    [scopeIdentifier]\n                  )\n                );\n              })\n            )\n          ) : void 0;\n          const renderer = getSectionParentIsOwner(childSection) ? callRuntime(\n            \"createRenderer\",\n            ...replaceNullishAndEmptyFunctionsWith0([\n              writes2,\n              walks2,\n              setup2,\n              tagParamsSignal?.identifier,\n              referencedClosures\n            ])\n          ) : callRuntime(\n            isSerializedSection(childSection) ? \"registerContent\" : \"createContent\",\n            import_compiler20.types.stringLiteral(getResumeRegisterId(childSection, \"renderer\")),\n            ...replaceNullishAndEmptyFunctionsWith0([\n              writes2,\n              walks2,\n              setup2,\n              tagParamsSignal?.identifier,\n              referencedClosures,\n              childSection.hoisted || childSection.isHoistThrough ? getSectionInstancesAccessorLiteral(childSection) : void 0\n            ])\n          );\n          writeSignals(childSection);\n          program.node.body.push(\n            import_compiler20.types.variableDeclaration(\"const\", [\n              import_compiler20.types.variableDeclarator(identifier, renderer)\n            ])\n          );\n        }\n      });\n      writeSignals(section);\n      writeRegisteredFns();\n      if (!setup) {\n        program.node.body.unshift(\n          import_compiler20.types.exportNamedDeclaration(\n            import_compiler20.types.variableDeclaration(\"const\", [\n              import_compiler20.types.variableDeclarator(\n                setupIdentifier,\n                import_compiler20.types.arrowFunctionExpression([], import_compiler20.types.blockStatement([]))\n              )\n            ])\n          )\n        );\n      }\n      program.node.body.unshift(\n        import_compiler20.types.exportNamedDeclaration(\n          import_compiler20.types.variableDeclaration(\"const\", [\n            import_compiler20.types.variableDeclarator(\n              templateIdentifier,\n              writes || import_compiler20.types.stringLiteral(\"\")\n            )\n          ])\n        ),\n        import_compiler20.types.exportNamedDeclaration(\n          import_compiler20.types.variableDeclaration(\"const\", [\n            import_compiler20.types.variableDeclarator(walksIdentifier, walks || import_compiler20.types.stringLiteral(\"\"))\n          ])\n        )\n      );\n      program.node.body.push(\n        import_compiler20.types.exportDefaultDeclaration(\n          callRuntime(\n            \"createTemplate\",\n            import_compiler20.types.stringLiteral(program.hub.file.metadata.marko.id),\n            templateIdentifier,\n            walksIdentifier,\n            setupIdentifier,\n            programInputSignal?.identifier\n          )\n        )\n      );\n    }\n  }\n};\n\n// src/translator/visitors/program/html.ts\nvar import_compiler21 = require(\"@marko/compiler\");\nvar import_babel_utils14 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/is-static.ts\nfunction isStatic(path5) {\n  return path5.isImportDeclaration() || path5.isExportDeclaration() || path5.isMarkoScriptlet({ static: true });\n}\n\n// src/translator/visitors/program/html.ts\nvar templateContentIdentifierForProgram = /* @__PURE__ */ new WeakMap();\nfunction getTemplateContentName() {\n  let name2 = templateContentIdentifierForProgram.get((0, import_babel_utils14.getProgram)());\n  if (!name2) {\n    templateContentIdentifierForProgram.set(\n      (0, import_babel_utils14.getProgram)(),\n      name2 = generateUid(\"content\")\n    );\n  }\n  return name2;\n}\nvar html_default = {\n  translate: {\n    exit(program) {\n      flushInto(program);\n      writeHTMLResumeStatements(program);\n      traverseReplace(program.node, \"body\", replaceNode);\n      const renderContent = [];\n      for (const child of program.get(\"body\")) {\n        if (!isStatic(child)) {\n          renderContent.push(child.node);\n          child.remove();\n        } else if (child.isMarkoScriptlet()) {\n          if (child.node.target && child.node.target !== \"server\") {\n            child.remove();\n          } else {\n            child.replaceWithMultiple(child.node.body);\n          }\n        }\n      }\n      const contentId = templateContentIdentifierForProgram.get(program);\n      const contentFn = import_compiler21.types.arrowFunctionExpression(\n        [import_compiler21.types.identifier(\"input\")],\n        import_compiler21.types.blockStatement(renderContent)\n      );\n      const exportDefault = import_compiler21.types.exportDefaultDeclaration(\n        callRuntime(\n          \"createTemplate\",\n          import_compiler21.types.stringLiteral(program.hub.file.metadata.marko.id),\n          contentId ? import_compiler21.types.identifier(contentId) : contentFn\n        )\n      );\n      if (contentId) {\n        program.node.body.push(\n          import_compiler21.types.variableDeclaration(\"const\", [\n            import_compiler21.types.variableDeclarator(import_compiler21.types.identifier(contentId), contentFn)\n          ]),\n          exportDefault\n        );\n      } else {\n        program.node.body.push(exportDefault);\n      }\n    }\n  }\n};\nfunction replaceNode(node, container) {\n  return replaceBindingReadNode2(node) || replaceRegisteredFunctionNode2(node, container);\n}\nfunction replaceBindingReadNode2(node) {\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\": {\n      const { extra } = node;\n      if (extra && !(extra.read && !extra.read.binding.declared || extra.binding && !extra.binding.declared)) {\n        return getReadReplacement(node);\n      }\n    }\n  }\n}\nfunction replaceRegisteredFunctionNode2(node, container) {\n  switch (node.type) {\n    case \"ClassMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler21.types.classProperty(node.key, replacement);\n    }\n    case \"ClassPrivateMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler21.types.classPrivateProperty(node.key, replacement);\n    }\n    case \"ObjectMethod\": {\n      const replacement = getRegisteredFnExpression2(node);\n      return replacement && import_compiler21.types.objectProperty(node.key, replacement);\n    }\n    case \"FunctionDeclaration\": {\n      const { extra } = node;\n      if (isRegisteredFnExtra(extra)) {\n        let registeredFnDeclarations = registeredFnDeclarationsByBody.get(\n          container\n        );\n        if (!registeredFnDeclarations) {\n          registeredFnDeclarationsByBody.set(\n            container,\n            registeredFnDeclarations = []\n          );\n        }\n        registeredFnDeclarations.push({\n          id: node.id.name,\n          registerId: extra.registerId\n        });\n      }\n      break;\n    }\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\": {\n      return getRegisteredFnExpression2(node);\n    }\n    case \"BlockStatement\":\n    case \"MarkoScriptlet\":\n      addRegisteredDeclarations(node.body);\n      break;\n  }\n}\nvar registeredFnDeclarationsByBody = /* @__PURE__ */ new WeakMap();\nfunction addRegisteredDeclarations(body) {\n  const registeredFnDeclarations = registeredFnDeclarationsByBody.get(body);\n  if (registeredFnDeclarations) {\n    for (const { id, registerId } of registeredFnDeclarations) {\n      body.push(\n        import_compiler21.types.expressionStatement(\n          callRuntime(\n            \"register\",\n            import_compiler21.types.identifier(id),\n            import_compiler21.types.stringLiteral(registerId)\n          )\n        )\n      );\n    }\n  }\n}\nfunction getRegisteredFnExpression2(node) {\n  const { extra } = node;\n  if (isRegisteredFnExtra(extra)) {\n    return callRuntime(\n      \"register\",\n      simplifyFunction(node),\n      import_compiler21.types.stringLiteral(extra.registerId),\n      (extra.referencedBindingsInFunction || extra.referencesScope) && getScopeIdIdentifier(extra.section)\n    );\n  }\n}\n\n// src/translator/visitors/program/index.ts\nvar cleanIdentifier;\nvar scopeIdentifier;\nfunction isScopeIdentifier(node) {\n  return node === scopeIdentifier;\n}\nvar program_default = {\n  migrate: {\n    enter(program) {\n      program.node.params = [import_compiler22.types.identifier(\"input\")];\n    },\n    exit(program) {\n      program.scope.crawl();\n    }\n  },\n  analyze: {\n    enter(program) {\n      startSection(program);\n      trackParamsReferences(program, 2 /* input */);\n      const inputBinding = program.node.params[0].extra?.binding;\n      if (inputBinding) {\n        inputBinding.nullable = false;\n      }\n      (program.node.extra ??= {}).domExports = {\n        template: generateUid(\"template\"),\n        walks: generateUid(\"walks\"),\n        setup: generateUid(\"setup\"),\n        input: void 0,\n        // TODO look into recursive components with fine grained params.\n        closures: generateUid(\"closures\")\n      };\n    },\n    exit(program) {\n      finalizeReferences();\n      const programExtra = program.node.extra;\n      const inputBinding = program.node.params[0].extra?.binding;\n      if (inputBinding && bindingHasDownstreamExpressions(inputBinding)) {\n        programExtra.domExports.input = buildTemplateExports(\n          inputBinding,\n          program\n        );\n      }\n    }\n  },\n  translate: {\n    enter(program) {\n      scopeIdentifier = isOutputDOM() ? generateUidIdentifier(\"scope\") : null;\n      cleanIdentifier = isOutputDOM() ? generateUidIdentifier(\"clean\") : null;\n      if (getMarkoOpts().output === \"hydrate\") {\n        const entryFile = program.hub.file;\n        const visitedFiles = /* @__PURE__ */ new Set([\n          (0, import_babel_utils15.resolveRelativePath)(entryFile, entryFile.opts.filename)\n        ]);\n        entry_builder_default.visit(entryFile, entryFile, function visitChild(resolved) {\n          if (!visitedFiles.has(resolved)) {\n            visitedFiles.add(resolved);\n            const file = (0, import_babel_utils15.loadFileForImport)(entryFile, resolved);\n            if (file) {\n              entry_builder_default.visit(\n                file,\n                entryFile,\n                (id) => visitChild(resolveRelativeToEntry(entryFile, file, id))\n              );\n            }\n          }\n        });\n        program.node.body = entry_builder_default.build(entryFile);\n        program.skip();\n        return;\n      }\n    },\n    exit(program) {\n      if (isOutputHTML()) {\n        html_default.translate.exit(program);\n      } else {\n        dom_default.translate.exit(program);\n      }\n      if (program.node.extra?.needsCompat) {\n        const compatFile = getCompatRuntimeFile();\n        const body = [void 0];\n        for (const child of program.node.body) {\n          if (child.type === \"ImportDeclaration\" && child.source.value === compatFile) {\n            body[0] = child;\n          } else {\n            body.push(child);\n          }\n        }\n        body[0] ??= import_compiler22.types.importDeclaration([], import_compiler22.types.stringLiteral(compatFile));\n        program.node.body = body;\n      }\n    }\n  }\n};\nfunction resolveRelativeToEntry(entryFile, file, req) {\n  return file === entryFile ? (0, import_babel_utils15.resolveRelativePath)(file, req) : (0, import_babel_utils15.resolveRelativePath)(\n    entryFile,\n    req[0] === \".\" ? import_path2.default.join(file.opts.filename, \"..\", req) : req\n  );\n}\nfunction buildTemplateExports(binding, program) {\n  const templateExport = {\n    id: binding.export ??= generateUid(binding.name),\n    binding,\n    props: void 0\n  };\n  if (!(binding.aliases.size || binding.downstreamExpressions.size)) {\n    templateExport.props = {};\n    for (const [property, alias] of binding.propertyAliases) {\n      templateExport.props[property] = buildTemplateExports(alias, program);\n    }\n  }\n  return templateExport;\n}\n\n// src/translator/util/scope-read.ts\nfunction createScopeReadPattern(section, referencedBindings) {\n  const rootDepth = section.depth;\n  const rootPattern = import_compiler23.types.objectPattern([]);\n  let nestedPatterns;\n  forEach(referencedBindings, (ref) => {\n    const propertyValue = ref.name;\n    if (!isValidPropertyIdentifier(propertyValue)) return;\n    const propertyKey = getScopeAccessor(ref);\n    const isShorthand = propertyKey === propertyValue;\n    let pattern = rootPattern;\n    if (ref.section !== section) {\n      if (!nestedPatterns) nestedPatterns = [rootPattern];\n      const relativeDepth = rootDepth - ref.section.depth;\n      let i = nestedPatterns.length;\n      let prev = nestedPatterns[i - 1];\n      for (; i <= relativeDepth; i++) {\n        const nestedPattern = import_compiler23.types.objectPattern([]);\n        prev.properties.push(\n          import_compiler23.types.objectProperty(import_compiler23.types.identifier(\"_\"), nestedPattern)\n        );\n        nestedPatterns.push(nestedPattern);\n        prev = nestedPattern;\n      }\n      pattern = nestedPatterns[relativeDepth];\n    }\n    pattern.properties.push(\n      import_compiler23.types.objectProperty(\n        toPropertyName(propertyKey),\n        import_compiler23.types.identifier(propertyValue),\n        false,\n        isShorthand\n      )\n    );\n  });\n  return rootPattern;\n}\nfunction getScopeExpression(section, targetSection) {\n  let scope = scopeIdentifier ?? import_compiler23.types.identifier(\"undefined\");\n  const diff = section.depth - targetSection.depth;\n  for (let i = 0; i < diff; i++) {\n    scope = import_compiler23.types.memberExpression(scope, import_compiler23.types.identifier(\"_\"));\n  }\n  if (diff < 0) {\n    throw new Error(\"Unable to find scope for reference.\");\n  }\n  return scope;\n}\nfunction createScopeReadExpression(section, reference) {\n  const propName = toPropertyName(getScopeAccessor(reference));\n  return import_compiler23.types.memberExpression(\n    getScopeExpression(section, reference.section),\n    propName,\n    propName.type !== \"Identifier\"\n  );\n}\n\n// src/translator/util/with-previous-location.ts\nfunction withPreviousLocation(newNode, originalNode) {\n  newNode.start = originalNode.start;\n  newNode.loc = originalNode.loc;\n  newNode.end = originalNode.end;\n  return newNode;\n}\n\n// src/translator/util/references.ts\nvar kIsInvoked = Symbol(\"hoist is invoked\");\nvar [getBindings] = createProgramState(() => /* @__PURE__ */ new Set());\nvar [getNextBindingId, setNextBindingId] = createProgramState(() => 0);\nfunction createBinding(name2, type, section, upstreamAlias, upstreamExpression, property, loc = null, declared = false) {\n  const id = getNextBindingId();\n  const binding = {\n    id,\n    name: name2,\n    type,\n    loc,\n    section,\n    property,\n    declared,\n    closureSections: void 0,\n    excludeProperties: void 0,\n    serialize: false,\n    sources: void 0,\n    aliases: /* @__PURE__ */ new Set(),\n    hoists: /* @__PURE__ */ new Map(),\n    propertyAliases: /* @__PURE__ */ new Map(),\n    upstreamAlias,\n    upstreamExpression,\n    downstreamExpressions: /* @__PURE__ */ new Set(),\n    scopeOffset: void 0,\n    export: void 0,\n    nullable: !upstreamExpression?.confident || upstreamExpression.computed == null\n  };\n  if (property) {\n    if (declared) upstreamAlias.nullable = false;\n    const propBinding = upstreamAlias.propertyAliases.get(property);\n    if (propBinding) {\n      binding.property = void 0;\n      binding.upstreamAlias = propBinding;\n      propBinding.aliases.add(binding);\n    } else {\n      upstreamAlias.propertyAliases.set(property, binding);\n    }\n  } else if (upstreamAlias) {\n    upstreamAlias.aliases.add(binding);\n  }\n  setNextBindingId(id + 1);\n  getBindings().add(binding);\n  return binding;\n}\nfunction trackVarReferences(tag, type, upstreamAlias, upstreamExpression) {\n  const tagVar = tag.node.var;\n  if (tagVar) {\n    const section = getOrCreateSection(tag);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    if (upstreamAlias && upstreamExpression) upstreamExpression.pruned = true;\n    createBindingsAndTrackReferences(\n      tagVar,\n      type,\n      tag.scope,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0\n    );\n  }\n}\nfunction trackParamsReferences(body, type, upstreamAlias, upstreamExpression) {\n  const params = body.node.params;\n  if (body.node.body.length && params.length) {\n    if (upstreamAlias && upstreamExpression) upstreamExpression.pruned = true;\n    const section = getOrCreateSection(body);\n    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);\n    const paramsBinding = canonicalUpstreamAlias || ((body.node.extra ??= {}).binding = createBinding(\n      generateUid(\"params\"),\n      type,\n      section,\n      canonicalUpstreamAlias,\n      upstreamExpression,\n      void 0\n    ));\n    section.params = paramsBinding;\n    for (let i = 0; i < params.length; i++) {\n      createBindingsAndTrackReferences(\n        params[i],\n        type,\n        body.scope,\n        section,\n        paramsBinding,\n        upstreamExpression,\n        i + \"\"\n      );\n    }\n  }\n}\nfunction trackHoistedReference(referencePath, binding) {\n  const section = binding.section;\n  const referenceSection = getOrCreateSection(referencePath);\n  const hoistSection = getCommonSection(referenceSection, section);\n  const extra = referencePath.node.extra ??= {};\n  let hoistedBinding = binding.hoists.get(hoistSection);\n  if (!hoistedBinding) {\n    binding.hoists.set(\n      hoistSection,\n      hoistedBinding = createBinding(\n        generateUid(\"hoisted_\" + referencePath.node.name),\n        5 /* hoist */,\n        hoistSection,\n        void 0,\n        void 0,\n        void 0,\n        binding.loc,\n        true\n      )\n    );\n    section.hoisted = bindingUtil.add(section.hoisted, binding);\n    let currentSection = section.parent;\n    while (currentSection && currentSection !== hoistSection) {\n      currentSection.isHoistThrough = true;\n      currentSection = currentSection.parent;\n    }\n  }\n  extra.hoistedBinding = hoistedBinding;\n  if (isInvokedFunction(referencePath)) {\n    extra.read = createRead(hoistedBinding, void 0);\n    extra.section = referenceSection;\n    extra[kIsInvoked] = true;\n  } else {\n    trackReference(referencePath, hoistedBinding);\n  }\n  referenceSection.referencedHoists = bindingUtil.add(\n    referenceSection.referencedHoists,\n    hoistedBinding\n  );\n}\nfunction trackReferencesForBinding(babelBinding) {\n  const { identifier, referencePaths, constantViolations } = babelBinding;\n  const binding = identifier.extra.binding;\n  for (const referencePath of referencePaths) {\n    const referenceSection = getOrCreateSection(referencePath);\n    if (isSameOrChildSection(binding.section, referenceSection)) {\n      trackReference(referencePath, binding);\n    } else {\n      trackHoistedReference(referencePath, binding);\n    }\n  }\n  for (const ref of constantViolations) {\n    if (ref.isUpdateExpression()) {\n      trackAssignment(ref.get(\"argument\"), binding);\n    } else if (ref.isAssignmentExpression()) {\n      trackAssignment(ref.get(\"left\"), binding);\n      if (ref.node.operator !== \"=\") {\n        const left = ref.get(\"left\");\n        if (left.isIdentifier()) {\n          trackReference(left, binding);\n        }\n      }\n    }\n  }\n}\nfunction trackAssignment(assignment, binding) {\n  const section = getOrCreateSection(assignment);\n  setReferencesScope(assignment);\n  forEachIdentifier(assignment.node, (id) => {\n    if (id.name === binding.name) {\n      const extra = id.extra ??= {};\n      section.assignments = bindingUtil.add(section.assignments, binding);\n      extra.assignment = binding;\n      extra.section = section;\n    }\n  });\n}\nfunction setReferencesScope(path5) {\n  const fnRoot = getFnRoot(path5);\n  if (fnRoot) {\n    (fnRoot.node.extra ??= {}).referencesScope = true;\n  }\n}\nfunction createBindingsAndTrackReferences(lVal, type, scope, section, upstreamAlias, upstreamExpression, property) {\n  switch (lVal.type) {\n    case \"Identifier\":\n      (lVal.extra ??= {}).binding = createBinding(\n        lVal.name,\n        type,\n        section,\n        upstreamAlias,\n        upstreamExpression,\n        property,\n        lVal.loc,\n        true\n      );\n      trackReferencesForBinding(scope.getBinding(lVal.name));\n      break;\n    case \"ObjectPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        generateUid(property || \"pattern\"),\n        type,\n        section,\n        upstreamAlias,\n        void 0,\n        property,\n        lVal.loc\n      ));\n      for (const prop of lVal.properties) {\n        if (prop.type === \"RestElement\") {\n          createBindingsAndTrackReferences(\n            prop.argument,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            property\n          );\n        } else {\n          let key;\n          if (prop.key.type === \"Identifier\") {\n            key = prop.key.name;\n          } else if (prop.key.type === \"StringLiteral\") {\n            key = prop.key.value;\n          } else {\n            throw new Error(\"computed keys not supported in object pattern\");\n          }\n          createBindingsAndTrackReferences(\n            prop.value,\n            type,\n            scope,\n            section,\n            patternBinding,\n            void 0,\n            key\n          );\n        }\n      }\n      break;\n    }\n    case \"ArrayPattern\": {\n      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(\n        generateUid(property || \"pattern\"),\n        type,\n        section,\n        upstreamAlias,\n        void 0,\n        property,\n        lVal.loc\n      ));\n      let i = -1;\n      for (const element of lVal.elements) {\n        i++;\n        if (element) {\n          if (element.type === \"RestElement\") {\n            createBindingsAndTrackReferences(\n              element.argument,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              property\n            );\n          } else {\n            createBindingsAndTrackReferences(\n              element,\n              type,\n              scope,\n              section,\n              patternBinding,\n              void 0,\n              `${i}`\n            );\n          }\n        }\n      }\n      break;\n    }\n    case \"AssignmentPattern\":\n      createBindingsAndTrackReferences(\n        lVal.left,\n        type,\n        scope,\n        section,\n        upstreamAlias,\n        void 0,\n        property\n      );\n      break;\n  }\n}\nfunction trackReference(referencePath, binding) {\n  let root = referencePath;\n  let reference = binding;\n  let propPath = binding.name;\n  while (true) {\n    const { parent } = root;\n    if (!import_compiler24.types.isMemberExpression(parent)) break;\n    const prop = getMemberExpressionPropString(parent);\n    if (prop === void 0) break;\n    if (reference.propertyAliases.has(prop)) {\n      root = root.parentPath;\n      reference = reference.propertyAliases.get(prop);\n      propPath = reference.name;\n      continue;\n    }\n    if (isInvokedFunction(root.parentPath) && !isEventOrChangeHandler(prop)) {\n      break;\n    }\n    root = root.parentPath;\n    reference = createBinding(\n      propPath += `_${prop.replace(/[^a-zA-Z0-9_$]/g, \"_\")}`,\n      reference.type,\n      reference.section,\n      reference,\n      void 0,\n      prop\n    );\n  }\n  const fnRoot = getFnRoot(root);\n  const exprRoot = getExprRoot(fnRoot || root);\n  const { section } = addReadToExpression(exprRoot, reference, root.node);\n  if (fnRoot) {\n    const readsByFn = getReadsByFunction();\n    const fnExtra = fnRoot.node.extra ??= {};\n    fnExtra.section = section;\n    readsByFn.set(\n      fnExtra,\n      push(readsByFn.get(fnExtra), {\n        binding: reference,\n        node: root.node\n      })\n    );\n  }\n}\nvar [getMergedReferences] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction mergeReferences(section, target, nodes) {\n  (target.extra ??= {}).section = section;\n  getMergedReferences().set(target, nodes);\n}\nfunction compareIntersections(a, b) {\n  const len = a.length;\n  const lenDelta = len - b.length;\n  if (lenDelta !== 0) {\n    return lenDelta;\n  }\n  for (let i = 0; i < len; i++) {\n    const compareResult = bindingUtil.compare(a[i], b[i]);\n    if (compareResult !== 0) {\n      return compareResult;\n    }\n  }\n  return 0;\n}\nfunction finalizeReferences() {\n  const bindings = getBindings();\n  const readsByExpression = getReadsByExpression();\n  const readsByFn = getReadsByFunction();\n  const mergedReferences = getMergedReferences();\n  if (mergedReferences.size) {\n    for (const [target, nodes] of mergedReferences) {\n      const targetExtra = target.extra;\n      let reads = readsByExpression.get(targetExtra);\n      let { isEffect } = targetExtra;\n      for (const node of nodes) {\n        const extra = node?.extra;\n        if (isReferencedExtra(extra)) {\n          isEffect ||= extra.isEffect;\n          const additionalReads = readsByExpression.get(extra);\n          if (additionalReads) {\n            reads = concat(reads, additionalReads);\n            readsByExpression.delete(extra);\n          }\n        }\n      }\n      readsByExpression.set(targetExtra, reads);\n      targetExtra.isEffect = isEffect;\n    }\n  }\n  const intersectionsBySection = /* @__PURE__ */ new Map();\n  for (const [expr, reads] of readsByExpression) {\n    if (isReferencedExtra(expr)) {\n      expr.referencedBindings = resolveReferencedBindings(\n        expr,\n        reads,\n        intersectionsBySection\n      );\n      forEach(expr.referencedBindings, (binding) => {\n        binding.downstreamExpressions.add(expr);\n      });\n    }\n  }\n  for (const [fn, reads] of readsByFn) {\n    fn.referencedBindingsInFunction = resolveReferencedBindings(\n      fn,\n      reads,\n      intersectionsBySection\n    );\n    forEach(fn.referencedBindingsInFunction, (binding) => {\n      binding.serialize = true;\n    });\n  }\n  for (const binding of bindings) {\n    if (binding.type !== 0 /* dom */ && !binding.upstreamAlias) {\n      pruneBinding(bindings, binding);\n    }\n  }\n  for (const binding of bindings) {\n    const { name: name2, section } = binding;\n    if (binding.type !== 0 /* dom */) {\n      resolveBindingSources(binding);\n      if (find(section.bindings, ({ name: name3 }) => name3 === binding.name)) {\n        binding.name = generateUid(name2);\n      }\n    }\n    section.bindings = bindingUtil.add(section.bindings, binding);\n    for (const {\n      referencedBindings,\n      isEffect,\n      section: section2\n    } of binding.downstreamExpressions) {\n      if (section2 !== binding.section) {\n        binding.closureSections = sectionUtil.add(\n          binding.closureSections,\n          section2\n        );\n        section2.referencedClosures = bindingUtil.add(\n          section2.referencedClosures,\n          binding\n        );\n      }\n      if (isEffect) {\n        forEach(referencedBindings, (bindingReference) => {\n          bindingReference.serialize = true;\n        });\n      }\n    }\n  }\n  forEachSection((section) => {\n    const intersections = intersectionsBySection.get(section);\n    if (intersections) {\n      for (const intersection of intersections) {\n        const numReferences = intersection.length;\n        for (let i = 0; i < numReferences - 1; i++) {\n          for (let j = i + 1; j < numReferences; j++) {\n            const binding1 = intersection[i];\n            const binding2 = intersection[j];\n            if (!binding1.serialize && !bindingUtil.isSuperset(binding1.sources, binding2.sources)) {\n              binding1.serialize = true;\n            }\n            if (!binding2.serialize && !bindingUtil.isSuperset(binding2.sources, binding1.sources)) {\n              binding2.serialize = true;\n            }\n          }\n        }\n      }\n    }\n    forEach(section.referencedClosures, (binding) => {\n      if (!binding.serialize) {\n        let serialize = false;\n        const sourceSection = binding.section;\n        let currentSection = section;\n        while (currentSection !== sourceSection && !(serialize = !currentSection.upstreamExpression || !!getDynamicSourcesForExtra(currentSection.upstreamExpression))) {\n          currentSection = currentSection.parent;\n        }\n        binding.serialize = serialize;\n      }\n    });\n  });\n  forEachSection((section) => {\n    let intersectionIndex = 0;\n    const intersections = intersectionsBySection.get(section) || [];\n    const { id, bindings: bindings2 } = section;\n    const isOwnedBinding = ({ section: section2 }) => section2.id === id;\n    let lastBindingIndex = 0;\n    let intersection;\n    forEach(filter(bindings2, isOwnedBinding), (binding, bindingIndex) => {\n      binding.id = (lastBindingIndex = bindingIndex) + intersectionIndex;\n      while (intersectionIndex < intersections.length && (intersection = intersections[intersectionIndex]).filter(isOwnedBinding).at(-1) === binding) {\n        intersectionMeta.set(intersection, {\n          id: bindingIndex + ++intersectionIndex,\n          scopeOffset: getMaxOwnSourceOffset(intersection, section)\n        });\n      }\n    });\n    while (intersectionIndex < intersections.length) {\n      intersection = intersections[intersectionIndex];\n      intersectionMeta.set(intersection, {\n        id: lastBindingIndex + ++intersectionIndex,\n        scopeOffset: getMaxOwnSourceOffset(intersection, section)\n      });\n    }\n  });\n  mergedReferences.clear();\n  readsByExpression.clear();\n  readsByFn.clear();\n}\nfunction getMaxOwnSourceOffset(intersection, section) {\n  let scopeOffset;\n  for (const binding of intersection) {\n    if (binding.section === section) {\n      forEach(binding.sources, (source) => {\n        if (source.scopeOffset && (!scopeOffset || scopeOffset.id < source.scopeOffset.id)) {\n          scopeOffset = source.scopeOffset;\n        }\n      });\n    }\n  }\n  return scopeOffset;\n}\nvar intersectionMeta = /* @__PURE__ */ new WeakMap();\nfunction resolveBindingSources(binding) {\n  const derived = /* @__PURE__ */ new Set();\n  let sources;\n  crawl(binding);\n  binding.sources = sources;\n  function crawl(binding2) {\n    if (binding2.type === 4 /* derived */ || binding2.type === 3 /* param */) {\n      let alias;\n      let curBinding = binding2;\n      while (alias = curBinding.upstreamAlias) {\n        curBinding = alias;\n      }\n      if (curBinding.upstreamExpression) {\n        if (derived.has(curBinding)) return;\n        derived.add(curBinding);\n        forEach(curBinding.upstreamExpression.referencedBindings, crawl);\n      } else if (curBinding.type === 2 /* input */) {\n        sources = bindingUtil.add(sources, binding2);\n      } else {\n        sources = bindingUtil.add(sources, curBinding);\n      }\n    } else {\n      sources = bindingUtil.add(sources, binding2);\n    }\n  }\n}\nvar bindingUtil = new Sorted(function compareBindings(a, b) {\n  return a.section.id - b.section.id || a.type !== b.type && (a.type === 0 /* dom */ || b.type === 0 /* dom */) ? a.type - b.type || a.id - b.id : a.id - b.id;\n});\nvar [getReadsByExpression] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nvar [getReadsByFunction] = createProgramState(\n  () => /* @__PURE__ */ new Map()\n);\nfunction addReadToExpression(path5, binding, node) {\n  const exprExtra = path5.node.extra ??= {};\n  const readsByExpression = getReadsByExpression();\n  exprExtra.section = getOrCreateSection(path5);\n  readsByExpression.set(\n    exprExtra,\n    push(readsByExpression.get(exprExtra), { binding, node })\n  );\n  return exprExtra;\n}\nfunction dropReferences(node) {\n  if (Array.isArray(node)) {\n    for (const item of node) {\n      (item.extra ??= {}).pruned = true;\n    }\n  } else {\n    (node.extra ??= {}).pruned = true;\n  }\n}\nfunction getCanonicalBinding(binding) {\n  return binding && (binding.property ? binding : binding.upstreamAlias || binding);\n}\nfunction getAllTagReferenceNodes(tag, referenceNodes = []) {\n  if (tag.arguments) {\n    for (const arg of tag.arguments) {\n      referenceNodes.push(arg);\n    }\n  }\n  for (const attr2 of tag.attributes) {\n    referenceNodes.push(attr2.value);\n  }\n  for (const child of tag.body.attributeTags ? tag.body.body : tag.attributeTags) {\n    switch (child.type) {\n      case \"MarkoTag\":\n        getAllTagReferenceNodes(child, referenceNodes);\n        break;\n      case \"MarkoScriptlet\":\n        for (const statement of child.body) {\n          referenceNodes.push(statement);\n        }\n        break;\n    }\n  }\n  return referenceNodes;\n}\nfunction getScopeAccessorLiteral(binding, includeId) {\n  if (isOptimize()) {\n    return import_compiler24.types.numericLiteral(binding.id);\n  }\n  return import_compiler24.types.stringLiteral(\n    binding.name + (includeId || binding.type === 0 /* dom */ ? `/${binding.id}` : \"\")\n  );\n}\nfunction getScopeAccessor(binding, includeId) {\n  if (isOptimize()) {\n    return binding.id + \"\";\n  }\n  return binding.name + (includeId || binding.type === 0 /* dom */ ? `/${binding.id}` : \"\");\n}\nfunction getSectionInstancesAccessor(section) {\n  return section.sectionAccessor ? section.sectionAccessor.prefix + getScopeAccessor(section.sectionAccessor.binding) : getAccessorPrefix().ClosureScopes + section.id;\n}\nfunction getSectionInstancesAccessorLiteral(section) {\n  const accessor = getSectionInstancesAccessor(section);\n  return accessor ? typeof accessor === \"number\" ? import_compiler24.types.numericLiteral(accessor) : import_compiler24.types.stringLiteral(accessor) : void 0;\n}\nfunction getReadReplacement(node) {\n  const { extra } = node;\n  if (!extra) return;\n  let { binding, read } = extra;\n  let replacement;\n  if (read) {\n    if (read.props === void 0) {\n      binding = read.binding;\n      read = void 0;\n    } else {\n      binding = void 0;\n    }\n  }\n  if (binding) {\n    if (node.type === \"Identifier\") {\n      if (binding.type === 5 /* hoist */) {\n        replacement = node.extra?.[kIsInvoked] ? import_compiler24.types.callExpression(getHoistFunctionIdentifier(binding), [\n          getScopeExpression(node.extra.section, binding.section)\n        ]) : import_compiler24.types.identifier(getScopeAccessor(binding));\n      } else if (binding.name !== node.name) {\n        node.name = binding.name;\n      }\n    } else {\n      replacement = import_compiler24.types.identifier(binding.name);\n    }\n  } else if (read) {\n    replacement = toMemberExpression(\n      import_compiler24.types.identifier(read.binding.name),\n      Array.isArray(read.props) ? read.props[0] : read.props\n    );\n    if (Array.isArray(read.props)) {\n      for (let i = 1; i < read.props.length; i++) {\n        replacement = toMemberExpression(replacement, read.props[i]);\n      }\n    }\n  }\n  return replacement && withPreviousLocation(replacement, node);\n}\nfunction pruneBinding(bindings, binding) {\n  let shouldPrune = !binding.downstreamExpressions.size;\n  for (const alias of binding.aliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.aliases.delete(alias);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  for (const [key, alias] of binding.propertyAliases) {\n    if (pruneBinding(bindings, alias)) {\n      binding.propertyAliases.delete(key);\n    } else {\n      shouldPrune = false;\n    }\n  }\n  if (shouldPrune) {\n    bindings.delete(binding);\n  }\n  return shouldPrune;\n}\nfunction resolveReferencedBindings(expr, reads, intersectionsBySection) {\n  let referencedBindings;\n  if (Array.isArray(reads)) {\n    for (const read of reads) {\n      let { binding } = read;\n      if (read.node) {\n        const exprReference = (read.node.extra ??= {}).read ??= resolveExpressionReference(reads, binding, void 0);\n        ({ binding } = (read.node.extra ??= {}).read = exprReference);\n      }\n      referencedBindings = bindingUtil.add(referencedBindings, binding);\n    }\n  } else if (reads) {\n    if (reads.node) {\n      (reads.node.extra ??= {}).read = createRead(reads.binding, void 0);\n    }\n    referencedBindings = reads.binding;\n  }\n  if (Array.isArray(referencedBindings)) {\n    const intersections = intersectionsBySection.get(expr.section) || [];\n    const intersection = findSorted(\n      compareIntersections,\n      intersections,\n      referencedBindings\n    );\n    if (intersection) {\n      referencedBindings = intersection;\n    } else {\n      intersectionsBySection.set(\n        expr.section,\n        addSorted(compareIntersections, intersections, referencedBindings)\n      );\n    }\n  }\n  return referencedBindings;\n}\nfunction resolveExpressionReference(reads, readBinding, readProps) {\n  const { upstreamAlias } = readBinding;\n  if (upstreamAlias && Array.isArray(reads)) {\n    const prop = getCanonicalProperty(readBinding);\n    const aliasProps = prop === void 0 ? readProps : push(readProps, prop);\n    for (const { binding } of reads) {\n      if (binding !== readBinding) {\n        let alias = upstreamAlias;\n        while (alias) {\n          if (binding === alias) {\n            return resolveExpressionReference(reads, alias, aliasProps);\n          }\n          alias = alias.upstreamAlias;\n        }\n      }\n    }\n  }\n  return createRead(readBinding, readProps);\n}\nfunction getCanonicalProperty(binding) {\n  return binding.property ?? binding.upstreamAlias?.property;\n}\nfunction createRead(binding, props) {\n  return { binding, props };\n}\nfunction getMemberExpressionPropString(expr) {\n  switch (expr.property.type) {\n    case \"StringLiteral\":\n      return expr.property.value;\n    case \"NumericLiteral\":\n      return \"\" + expr.property.value;\n    case \"Identifier\":\n      if (expr.computed) return;\n      return expr.property.name;\n  }\n}\nfunction isEventOrChangeHandler(prop) {\n  return /^on[-A-Z][a-zA-Z0-9_$]|[a-zA-Z_$][a-zA-Z0-9_$]*Change$/.test(prop);\n}\nfunction isReferencedExtra(extra) {\n  return !!(extra && !extra.pruned && extra.section);\n}\nfunction isAssignedBindingExtra(extra) {\n  return isReferencedExtra(extra) && extra.assignment !== void 0;\n}\nfunction isRegisteredFnExtra(extra) {\n  return isReferencedExtra(extra) && extra.registerId !== void 0;\n}\n\n// src/translator/core/await.ts\nvar kDOMBinding = Symbol(\"await tag dom binding\");\nvar await_default = {\n  analyze(tag) {\n    (0, import_babel_utils16.assertNoVar)(tag);\n    (0, import_babel_utils16.assertNoArgs)(tag);\n    assertNoSpreadAttrs(tag);\n    (0, import_babel_utils16.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    const tagBody = tag.get(\"body\");\n    const section = getOrCreateSection(tag);\n    const [valueAttr] = node.attributes;\n    const tagExtra = tag.node.extra ??= {};\n    tagExtra[kDOMBinding] = createBinding(\n      \"#text\",\n      0 /* dom */,\n      section,\n      void 0,\n      tagExtra\n    );\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `await` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler25.types.isMarkoAttribute(valueAttr) || valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `await` tag only supports the `value` attribute.\"\n      );\n    }\n    if (!node.body.body.length) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `await` tag requires body content.\");\n    }\n    if (node.body.params.length && (node.body.params.length > 1 || import_compiler25.types.isSpreadElement(node.body.params[0]))) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `await` tag only supports a single parameter.\"\n      );\n    }\n    const bodySection = startSection(tagBody);\n    getOrCreateSection(tag);\n    trackParamsReferences(\n      tagBody,\n      3 /* param */,\n      void 0,\n      evaluate(valueAttr.value)\n    );\n    bodySection.upstreamExpression = valueAttr.value.extra;\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        flushBefore(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const [valueAttr] = node.attributes;\n        const tagExtra = node.extra;\n        const nodeRef2 = tagExtra[kDOMBinding];\n        const tagBody = tag.get(\"body\");\n        const section = getSection(tag);\n        flushInto(tag);\n        writeHTMLResumeStatements(tagBody);\n        tag.replaceWith(\n          import_compiler25.types.expressionStatement(\n            callRuntime(\n              \"fork\",\n              getScopeIdIdentifier(section),\n              getScopeAccessorLiteral(nodeRef2),\n              valueAttr.value,\n              import_compiler25.types.arrowFunctionExpression(\n                node.body.params,\n                toFirstExpressionOrBlock(node.body.body)\n              )\n            )\n          )\n        )[0].skip();\n      }\n    },\n    dom: {\n      enter(tag) {\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        visit(tag, 37 /* Replace */);\n        enterShallow(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const nodeRef2 = tagExtra[kDOMBinding];\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tag.get(\"body\"));\n        const signal = getSignal(section, nodeRef2, \"await\");\n        signal.build = () => {\n          return callRuntime(\n            \"awaitTag\",\n            getScopeAccessorLiteral(nodeRef2),\n            import_compiler25.types.identifier(bodySection.name)\n          );\n        };\n        addValue(\n          section,\n          bodySection.upstreamExpression?.referencedBindings,\n          signal,\n          tag.node.attributes[0].value\n        );\n        tag.remove();\n      }\n    }\n  }),\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to consume asynchronous an data.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#await\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/await.d.marko\"\n};\n\n// src/translator/core/client.ts\nvar import_compiler26 = require(\"@marko/compiler\");\nvar import_babel_utils17 = require(\"@marko/compiler/babel-utils\");\nvar client_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^client\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils17.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler26.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler26.types.markoScriptlet(body, true, \"client\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"client <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the client.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#client-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/const.ts\nvar import_compiler28 = require(\"@marko/compiler\");\nvar import_babel_utils18 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/translate-var.ts\nvar import_compiler27 = require(\"@marko/compiler\");\nfunction translateVar(tag, initialValue, kind = \"const\") {\n  const {\n    node: { var: tagVar }\n  } = tag;\n  if (!tagVar) {\n    return;\n  }\n  tag.insertBefore(\n    import_compiler27.types.variableDeclaration(kind, [import_compiler27.types.variableDeclarator(tagVar, initialValue)])\n  );\n}\n\n// src/translator/core/const.ts\nvar const_default = {\n  analyze(tag) {\n    (0, import_babel_utils18.assertNoArgs)(tag);\n    (0, import_babel_utils18.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const [valueAttr] = node.attributes;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a tag variable.\");\n    }\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `const` tag requires a value.\");\n    }\n    if (node.attributes.length > 1 || !import_compiler28.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `const` tag only supports the `value` attribute.\"\n      );\n    }\n    const upstreamAlias = import_compiler28.types.isIdentifier(valueAttr.value) ? tag.scope.getBinding(valueAttr.value.name)?.identifier.extra?.binding : void 0;\n    trackVarReferences(\n      tag,\n      4 /* derived */,\n      upstreamAlias,\n      evaluate(valueAttr.value)\n      // TODO could perform a more extensive \"nullable\" check.\n    );\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      const { value } = valueAttr;\n      if (isOutputDOM()) {\n        const section = getSection(tag);\n        const varBinding = node.var.extra?.binding;\n        if (varBinding && !varBinding.upstreamAlias) {\n          const derivation = initValue(varBinding);\n          addValue(section, value.extra?.referencedBindings, derivation, value);\n        }\n      } else {\n        translateVar(tag, value);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an constant binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#const\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/const.d.marko\"\n};\n\n// src/translator/core/debug.ts\nvar import_compiler29 = require(\"@marko/compiler\");\nvar import_babel_utils19 = require(\"@marko/compiler/babel-utils\");\nvar debug_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils19.assertNoVar)(tag);\n    (0, import_babel_utils19.assertNoArgs)(tag);\n    (0, import_babel_utils19.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (tag.node.attributes.length > 1 || tag.node.attributes.length === 1 && (!import_compiler29.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\")) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `debug` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const referencedBindings = valueAttr?.value.extra?.referencedBindings;\n      const statement = withPreviousLocation(import_compiler29.types.debuggerStatement(), tag.node);\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Debug on value change.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#debug\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/debug.d.marko\"\n};\n\n// src/translator/core/define.ts\nvar import_compiler35 = require(\"@marko/compiler\");\nvar import_babel_utils25 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/nested-attribute-tags.ts\nvar import_compiler30 = require(\"@marko/compiler\");\nvar import_babel_utils20 = require(\"@marko/compiler/babel-utils\");\nvar attrTagToIdentifierLookup = /* @__PURE__ */ new WeakMap();\nfunction getAttrTagIdentifier(meta) {\n  let name2 = attrTagToIdentifierLookup.get(meta);\n  if (!name2) {\n    name2 = generateUid(meta.name);\n    attrTagToIdentifierLookup.set(meta, name2);\n  }\n  return import_compiler30.types.identifier(name2);\n}\nfunction analyzeAttributeTags(tag) {\n  if (tag.node.extra?.attributeTags) return tag.node.extra.attributeTags;\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  if (!attrTags2.length) return;\n  const tagExtra = tag.node.extra ??= {};\n  const lookup = tagExtra.attributeTags = {};\n  const attrTagNodesByName = {};\n  const sampleAttrTagsForControlFlow = /* @__PURE__ */ new Map();\n  for (const child of attrTags2) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils20.isAttributeTag)(child)) {\n        const name2 = getTagName(child);\n        lookup[name2] ||= createAttrTagMeta(name2, [name2]);\n        (attrTagNodesByName[name2] ||= []).push(child);\n        analyzeAttributeTags(child);\n      } else {\n        const isRepeated = (0, import_babel_utils20.isLoopTag)(child);\n        let curGroup;\n        for (const name2 of crawlAttrTags(child, attrTagNodesByName)) {\n          const oldMeta = lookup[name2];\n          if (oldMeta) {\n            if (!curGroup) {\n              curGroup = oldMeta.group;\n            } else if (curGroup !== oldMeta.group) {\n              for (const name3 of oldMeta.group) {\n                lookup[name3].group = curGroup;\n                curGroup.push(name3);\n              }\n            }\n          }\n          let attrTagMeta = lookup[name2];\n          if (!attrTagMeta) {\n            attrTagMeta = lookup[name2] = createAttrTagMeta(name2, []);\n            curGroup = attrTagMeta.group;\n            curGroup.push(name2);\n          }\n          attrTagMeta.dynamic = true;\n          if (isRepeated) {\n            attrTagMeta.repeated = true;\n          }\n          sampleAttrTagsForControlFlow.set(child, name2);\n        }\n      }\n    }\n  }\n  for (const [controlFlowTag, sampleAttrName] of sampleAttrTagsForControlFlow) {\n    (controlFlowTag.node.extra ??= {}).attributeTagGroup = lookup[sampleAttrName].group;\n  }\n  for (const name2 in attrTagNodesByName) {\n    const attrTagMeta = lookup[name2];\n    if (!attrTagMeta.repeated) {\n      const attrTagNodes = attrTagNodesByName[name2];\n      if (attrTagNodes.length > 1) {\n        attrTagMeta.repeated = !attrTagMeta.dynamic || hasRepeatedDynamicAttrTags(attrTagNodes);\n      }\n    }\n  }\n  return lookup;\n}\nfunction createAttrTagMeta(name2, group) {\n  return {\n    name: name2.slice(1),\n    dynamic: false,\n    repeated: false,\n    group\n  };\n}\nfunction crawlAttrTags(tag, attrTagNodesByName, attrTagNames = /* @__PURE__ */ new Set()) {\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  for (const child of attrTags2) {\n    if (child.isMarkoTag()) {\n      if ((0, import_babel_utils20.isAttributeTag)(child)) {\n        const tagName = getTagName(child);\n        attrTagNames.add(tagName);\n        (attrTagNodesByName[tagName] ||= []).push(child);\n        analyzeAttributeTags(child);\n      } else {\n        crawlAttrTags(child, attrTagNodesByName, attrTagNames);\n      }\n    }\n  }\n  return attrTagNames;\n}\nfunction hasRepeatedDynamicAttrTags(attrTags2) {\n  let conditionRoot;\n  const seenBranches = /* @__PURE__ */ new Set();\n  for (const attrTag2 of attrTags2) {\n    const parentTag = getParentTag(attrTag2);\n    if (seenBranches.has(parentTag) || !isConditionTag(parentTag)) {\n      return true;\n    }\n    const curConditionRoot = getConditionRoot(parentTag);\n    if (curConditionRoot && curConditionRoot !== (conditionRoot ||= curConditionRoot)) {\n      return true;\n    }\n    seenBranches.add(parentTag);\n  }\n  return false;\n}\nfunction getConditionRoot(tag) {\n  if (getTagName(tag) === \"if\") return tag;\n  let prev = tag.getPrevSibling();\n  while (prev.node) {\n    if (prev.isMarkoTag() && getTagName(prev) === \"if\") {\n      return prev;\n    }\n    prev = prev.getPrevSibling();\n  }\n}\n\n// src/translator/util/translate-attrs.ts\nvar import_compiler34 = require(\"@marko/compiler\");\nvar import_babel_utils24 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/core/for.ts\nvar import_compiler33 = require(\"@marko/compiler\");\nvar import_babel_utils23 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/is-only-child-in-parent.ts\nvar import_compiler32 = require(\"@marko/compiler\");\nvar import_babel_utils22 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/visitors/tag/native-tag.ts\nvar import_compiler31 = require(\"@marko/compiler\");\nvar import_babel_utils21 = require(\"@marko/compiler/babel-utils\");\nvar kNativeTagBinding = Symbol(\"native tag binding\");\nvar kSerializeMarker = Symbol(\"serialize marker\");\nvar kGetterId = Symbol(\"node getter id\");\nvar htmlSelectArgs = /* @__PURE__ */ new WeakMap();\nfunction assertExclusiveControllableGroups(tag, attrs2) {\n  const exclusiveGroups = [\n    attrs2.open || attrs2.openChange,\n    attrs2.checked || attrs2.checkedChange,\n    attrs2.checkedValue || attrs2.checkedValueChange,\n    attrs2.valueChange\n  ].filter(Boolean);\n  if (exclusiveGroups.length > 1) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The attributes ${exclusiveGroups.map((attr2) => `\"${attr2.name}\"`).join(\", \")} are mutually exclusive.`\n    );\n  }\n}\nfunction getRelatedControllable(tagName, attrs2) {\n  switch (tagName) {\n    case \"input\":\n      if (attrs2.checked || attrs2.checkedChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_checked\",\n          attrs: [attrs2.checked, attrs2.checkedChange]\n        };\n      }\n      if (attrs2.checkedValue || attrs2.checkedValueChange) {\n        return {\n          special: true,\n          helper: \"controllable_input_checkedValue\",\n          attrs: [attrs2.checkedValue, attrs2.checkedValueChange, attrs2.value]\n        };\n      }\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: false,\n          helper: \"controllable_input_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"select\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_select_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"textarea\":\n      if (attrs2.value || attrs2.valueChange) {\n        return {\n          special: true,\n          helper: \"controllable_textarea_value\",\n          attrs: [attrs2.value, attrs2.valueChange]\n        };\n      }\n      break;\n    case \"details\":\n    case \"dialog\":\n      if (attrs2.open || attrs2.openChange) {\n        return {\n          special: false,\n          helper: \"controllable_detailsOrDialog_open\",\n          attrs: [attrs2.open, attrs2.openChange]\n        };\n      }\n      break;\n  }\n}\nvar native_tag_default = {\n  transform: {\n    enter(tag) {\n      const tagName = getTagName(tag);\n      if (tagName === \"textarea\" && tag.node.body.body.length) {\n        const parts = [];\n        for (const child of tag.node.body.body) {\n          if (child.type === \"MarkoText\" || child.type === \"MarkoPlaceholder\" && child.escape) {\n            parts.push(child.value);\n          } else {\n            throw tag.hub.file.hub.buildError(\n              child,\n              \"Unexpected content in textarea, only text and placeholders are supported.\",\n              SyntaxError\n            );\n          }\n        }\n        tag.node.attributes.push(\n          import_compiler31.types.markoAttribute(\n            \"value\",\n            normalizeStringExpression(parts) || buildUndefined()\n          )\n        );\n        tag.node.body.body = [];\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils21.assertNoArgs)(tag);\n      (0, import_babel_utils21.assertNoParams)(tag);\n      (0, import_babel_utils21.assertNoAttributeTags)(tag);\n      const { node } = tag;\n      if (node.var && !import_compiler31.types.isIdentifier(node.var)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"Tag variables on native elements cannot be destructured.\"\n        );\n      }\n      const tagName = getTagName(tag);\n      const section = getOrCreateSection(tag);\n      let hasEventHandlers = false;\n      let hasDynamicAttributes = false;\n      const seen = {};\n      const { attributes } = tag.node;\n      let relatedControllable;\n      let spreadReferenceNodes;\n      for (let i = attributes.length; i--; ) {\n        const attr2 = attributes[i];\n        if (import_compiler31.types.isMarkoAttribute(attr2)) {\n          if (seen[attr2.name]) {\n            dropReferences(attr2.value);\n            continue;\n          }\n          seen[attr2.name] = attr2;\n          if (isEventHandler(attr2.name) || isChangeHandler(attr2.name)) {\n            (attr2.value.extra ??= {}).isEffect = true;\n            hasEventHandlers = true;\n          } else if (!evaluate(attr2.value).confident) {\n            hasDynamicAttributes = true;\n          }\n        } else if (import_compiler31.types.isMarkoSpreadAttribute(attr2)) {\n          hasEventHandlers = true;\n          hasDynamicAttributes = true;\n          (attr2.value.extra ??= {}).isEffect = true;\n        }\n        if (spreadReferenceNodes) {\n          spreadReferenceNodes.push(attr2.value);\n        } else if (import_compiler31.types.isMarkoSpreadAttribute(attr2)) {\n          spreadReferenceNodes = [attr2.value];\n          relatedControllable = getRelatedControllable(tagName, seen);\n        }\n      }\n      assertExclusiveControllableGroups(tag, seen);\n      if (spreadReferenceNodes) {\n        if (relatedControllable && !relatedControllable.attrs.every(Boolean)) {\n          for (const attr2 of relatedControllable.attrs) {\n            if (attr2) {\n              spreadReferenceNodes.push(attr2.value);\n            }\n          }\n          relatedControllable = void 0;\n        }\n        mergeReferences(section, tag.node, spreadReferenceNodes);\n      } else {\n        relatedControllable = getRelatedControllable(tagName, seen);\n      }\n      if (relatedControllable) {\n        mergeReferences(\n          section,\n          relatedControllable.attrs.find(Boolean).value,\n          relatedControllable.attrs.map((it) => it?.value)\n        );\n      }\n      if (node.var || hasEventHandlers || hasDynamicAttributes) {\n        (0, import_babel_utils21.getProgram)().node.extra.isInteractive ||= hasEventHandlers;\n        const tagName2 = node.name.type === \"StringLiteral\" ? node.name.value : import_compiler31.types.toIdentifier(tag.get(\"name\"));\n        const tagExtra = node.extra ??= {};\n        const bindingName = \"#\" + tagName2;\n        if (hasEventHandlers || node.var) {\n          tagExtra[kSerializeMarker] = true;\n        }\n        const tagBinding = tagExtra[kNativeTagBinding] = createBinding(\n          bindingName,\n          0 /* dom */,\n          section\n        );\n        if (node.var) {\n          const varBinding = tag.scope.getBinding(node.var.name);\n          for (const referencePath of varBinding.referencePaths) {\n            const referenceSection = getSection(referencePath);\n            setReferencesScope(referencePath);\n            if (!isSameOrChildSection(section, referenceSection)) {\n              trackHoistedReference(\n                referencePath,\n                tagBinding\n              );\n            } else if (!isInvokedFunction(referencePath)) {\n              tagExtra[kGetterId] ||= getRegisterUID(section, bindingName);\n            }\n          }\n        }\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagName = getTagName(tag);\n      const extra = tag.node.extra;\n      const nodeRef2 = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const name2 = tag.get(\"name\");\n      const tagDef = (0, import_babel_utils21.getTagDef)(tag);\n      const write2 = writeTo(tag);\n      const section = getSection(tag);\n      if (isHTML && extra.tagNameNullable) {\n        flushBefore(tag);\n      }\n      if (tag.has(\"var\")) {\n        const varName = tag.node.var.name;\n        const varBinding = tag.scope.getBinding(varName);\n        const getterId = extra[kGetterId];\n        if (isHTML) {\n          for (const reference of varBinding.referencePaths) {\n            const referenceSection = getSection(reference);\n            if (!reference.node.extra?.hoist) {\n              serializeOwners(referenceSection, section);\n            }\n          }\n          serializeSectionIfNeeded(section, true);\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(section),\n              getterId && import_compiler31.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);\n            (0, import_babel_utils21.getProgram)().node.body.push(\n              import_compiler31.types.variableDeclaration(\"const\", [\n                import_compiler31.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler31.types.stringLiteral(getterId),\n                    import_compiler31.types.stringLiteral(\n                      getAccessorPrefix().Getter + getScopeAccessorLiteral(nodeRef2).value\n                    )\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of varBinding.referencePaths) {\n            if (!reference.node.extra?.hoistedBinding) {\n              const referenceSection = getSection(reference);\n              if (isInvokedFunction(reference)) {\n                reference.parentPath.replaceWith(\n                  import_compiler31.types.expressionStatement(\n                    createScopeReadExpression(referenceSection, nodeRef2)\n                  )\n                );\n              } else if (getterFnIdentifier) {\n                reference.replaceWith(\n                  import_compiler31.types.callExpression(getterFnIdentifier, [\n                    getScopeExpression(referenceSection, getSection(tag))\n                  ])\n                );\n              } else {\n                reference.replaceWith(\n                  import_compiler31.types.expressionStatement(\n                    import_compiler31.types.memberExpression(\n                      getScopeExpression(section, referenceSection),\n                      import_compiler31.types.stringLiteral(\n                        getAccessorPrefix().Getter + getScopeAccessorLiteral(nodeRef2).value\n                      ),\n                      true\n                    )\n                  )\n                );\n              }\n            }\n          }\n        }\n      }\n      let visitAccessor;\n      if (nodeRef2) {\n        visitAccessor = getScopeAccessorLiteral(nodeRef2);\n        visit(tag, 32 /* Get */);\n      }\n      write2`<${name2.node}`;\n      const usedAttrs = getUsedAttrs(tagName, tag.node);\n      const { staticAttrs, staticControllable, skipExpression } = usedAttrs;\n      let { spreadExpression } = usedAttrs;\n      if (staticControllable) {\n        const { helper, attrs: attrs2 } = staticControllable;\n        const firstAttr = attrs2.find(Boolean);\n        const referencedBindings = firstAttr.value.extra?.referencedBindings;\n        const values = attrs2.map((attr2) => attr2?.value);\n        if (isHTML) {\n          if (tagName !== \"select\" && tagName !== \"textarea\") {\n            write2`${callRuntime(helper, getScopeIdIdentifier(section), visitAccessor, ...values)}`;\n          }\n          addHTMLEffectCall(section, void 0);\n        } else {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            import_compiler31.types.expressionStatement(\n              callRuntime(helper, scopeIdentifier, visitAccessor, ...values)\n            )\n          );\n          addStatement(\n            \"effect\",\n            section,\n            void 0,\n            import_compiler31.types.expressionStatement(\n              callRuntime(`${helper}_effect`, scopeIdentifier, visitAccessor)\n            )\n          );\n        }\n      }\n      let writeAtStartOfBody;\n      if (isHTML) {\n        if (tagName === \"select\") {\n          if (staticControllable) {\n            htmlSelectArgs.set(tag.node, {\n              value: staticControllable.attrs[0]?.value || buildUndefined(),\n              valueChange: staticControllable.attrs[1]?.value || buildUndefined()\n            });\n          } else if (spreadExpression) {\n            const spreadIdentifier = generateUidIdentifier(\"select_input\");\n            tag.insertBefore(\n              import_compiler31.types.variableDeclaration(\"const\", [\n                import_compiler31.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            htmlSelectArgs.set(tag.node, {\n              value: import_compiler31.types.memberExpression(\n                spreadIdentifier,\n                import_compiler31.types.identifier(\"value\")\n              ),\n              valueChange: import_compiler31.types.memberExpression(\n                spreadIdentifier,\n                import_compiler31.types.identifier(\"valueChange\")\n              )\n            });\n            spreadExpression = spreadIdentifier;\n          }\n        } else if (tagName === \"textarea\") {\n          let value;\n          let valueChange;\n          if (staticControllable) {\n            value = staticControllable.attrs[0]?.value;\n            valueChange = staticControllable.attrs[1]?.value;\n          } else if (spreadExpression) {\n            const spreadIdentifier = generateUidIdentifier(\"textarea_input\");\n            tag.insertBefore(\n              import_compiler31.types.variableDeclaration(\"const\", [\n                import_compiler31.types.variableDeclarator(spreadIdentifier, spreadExpression)\n              ])\n            );\n            value = import_compiler31.types.memberExpression(spreadIdentifier, import_compiler31.types.identifier(\"value\"));\n            valueChange = import_compiler31.types.memberExpression(\n              spreadIdentifier,\n              import_compiler31.types.identifier(\"valueChange\")\n            );\n            spreadExpression = spreadIdentifier;\n          }\n          if (value || valueChange) {\n            writeAtStartOfBody = callRuntime(\n              \"controllable_textarea_value\",\n              getScopeIdIdentifier(getSection(tag)),\n              getScopeAccessorLiteral(nodeRef2),\n              value,\n              valueChange\n            );\n          }\n        }\n      }\n      for (const attr2 of staticAttrs) {\n        const { name: name3, value } = attr2;\n        const { confident, computed } = value.extra || {};\n        const valueReferences = value.extra?.referencedBindings;\n        if (isHTML && tagName === \"option\" && name3 === \"value\") {\n          write2`${callRuntime(\"optionValueAttr\", value)}`;\n          continue;\n        }\n        switch (name3) {\n          case \"class\":\n          case \"style\": {\n            const helper = `${name3}Attr`;\n            if (confident) {\n              write2`${getHTMLRuntime()[helper](computed)}`;\n            } else if (isHTML) {\n              write2`${callRuntime(helper, value)}`;\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler31.types.expressionStatement(\n                  callRuntime(\n                    helper,\n                    import_compiler31.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n          }\n          default:\n            if (confident) {\n              write2`${getHTMLRuntime().attr(name3, computed)}`;\n            } else if (isHTML) {\n              if (isEventHandler(name3)) {\n                addHTMLEffectCall(section, valueReferences);\n              } else {\n                write2`${callRuntime(\"attr\", import_compiler31.types.stringLiteral(name3), value)}`;\n              }\n            } else if (isEventHandler(name3)) {\n              addStatement(\n                \"effect\",\n                section,\n                valueReferences,\n                import_compiler31.types.expressionStatement(\n                  callRuntime(\n                    \"on\",\n                    import_compiler31.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler31.types.stringLiteral(getEventHandlerName(name3)),\n                    value\n                  )\n                )\n              );\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler31.types.expressionStatement(\n                  callRuntime(\n                    \"attr\",\n                    import_compiler31.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler31.types.stringLiteral(name3),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n        }\n      }\n      if (spreadExpression) {\n        if (isHTML) {\n          addHTMLEffectCall(section, extra.referencedBindings);\n          if (skipExpression) {\n            write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(section), name2.node)}`;\n          } else {\n            write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(section), name2.node)}`;\n          }\n        } else {\n          if (skipExpression) {\n            addStatement(\n              \"render\",\n              section,\n              extra.referencedBindings,\n              import_compiler31.types.expressionStatement(\n                callRuntime(\n                  \"partialAttrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression,\n                  skipExpression\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              extra.referencedBindings,\n              import_compiler31.types.expressionStatement(\n                callRuntime(\n                  \"attrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression\n                )\n              )\n            );\n          }\n          addStatement(\n            \"effect\",\n            section,\n            extra.referencedBindings,\n            import_compiler31.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            false\n          );\n        }\n      }\n      if (tagDef && tagDef.parseOptions?.openTagOnly) {\n        switch (tagDef.htmlType) {\n          case \"svg\":\n          case \"math\":\n            write2`/>`;\n            break;\n          default:\n            write2`>`;\n            break;\n        }\n      } else {\n        write2`>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(import_compiler31.types.ifStatement(name2.node, consumeHTML(tag)))[0].skip();\n      }\n      if (writeAtStartOfBody) {\n        write2`${writeAtStartOfBody}`;\n      }\n      enter2(tag);\n    },\n    exit(tag) {\n      const extra = tag.node.extra;\n      const nodeRef2 = extra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const openTagOnly = (0, import_babel_utils21.getTagDef)(tag)?.parseOptions?.openTagOnly;\n      const selectArgs = isHTML && htmlSelectArgs.get(tag.node);\n      const tagName = getTagName(tag);\n      if (isHTML && extra.tagNameNullable) {\n        flushInto(tag);\n      }\n      if (selectArgs) {\n        writeTo(tag)`</${tag.node.name}>`;\n        flushInto(tag);\n        tag.insertBefore(\n          import_compiler31.types.expressionStatement(\n            callRuntime(\n              \"controllable_select_value\",\n              getScopeIdIdentifier(getSection(tag)),\n              getScopeAccessorLiteral(nodeRef2),\n              selectArgs.value,\n              selectArgs.valueChange,\n              import_compiler31.types.arrowFunctionExpression(\n                [],\n                import_compiler31.types.blockStatement(tag.node.body.body)\n              )\n            )\n          )\n        );\n      } else {\n        tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());\n      }\n      const allExtras = [extra];\n      for (const attr2 of tag.node.attributes) {\n        if (attr2.value.extra) {\n          allExtras.push(attr2.value.extra);\n        }\n      }\n      const serializeReason = getDynamicSourcesForExtras(allExtras);\n      const shouldMark = nodeRef2 && (extra[kSerializeMarker] || extra[kSerializeMarker] === void 0 && !!serializeReason);\n      if (!openTagOnly && !selectArgs) {\n        writeTo(\n          tag,\n          isHTML && !shouldMark && (tagName === \"html\" || tagName === \"body\")\n        )`</${tag.node.name}>`;\n      }\n      if (isHTML && extra.tagNameNullable) {\n        tag.insertBefore(\n          import_compiler31.types.ifStatement(tag.node.name, consumeHTML(tag))\n        )[0].skip();\n      }\n      if (shouldMark) {\n        markNode(tag, nodeRef2);\n      }\n      exit2(tag);\n      tag.remove();\n    }\n  }\n};\nfunction getUsedAttrs(tagName, tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  let staticControllable;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler31.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n        staticControllable = getRelatedControllable(tagName, seen);\n        if (staticControllable && !staticControllable.attrs.every(Boolean)) {\n          for (const attr3 of staticControllable.attrs) {\n            if (attr3) {\n              spreadProps.push(toObjectProperty(attr3.name, attr3.value));\n              maybeStaticAttrs.delete(attr3);\n            }\n          }\n          staticControllable = void 0;\n        }\n      }\n      spreadProps.push(import_compiler31.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  if (!spreadProps) {\n    staticControllable = getRelatedControllable(tagName, seen);\n    if (staticControllable?.special === false && !staticControllable.attrs[1]) {\n      staticControllable = void 0;\n    }\n  }\n  if (staticControllable) {\n    for (const attr2 of staticControllable.attrs) {\n      if (attr2) {\n        maybeStaticAttrs.delete(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    if (staticControllable) {\n      for (const attr2 of staticControllable.attrs) {\n        if (attr2) {\n          (skipProps ||= []).push(\n            toObjectProperty(attr2.name, import_compiler31.types.numericLiteral(1))\n          );\n        }\n      }\n    }\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler31.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler31.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    staticControllable,\n    spreadExpression,\n    skipExpression\n  };\n}\nfunction isChangeHandler(propName) {\n  return /^(?:value|checked(?:Value)?|open)Change/.test(propName);\n}\nfunction buildUndefined() {\n  return import_compiler31.types.unaryExpression(\"void\", import_compiler31.types.numericLiteral(0));\n}\n\n// src/translator/util/is-only-child-in-parent.ts\nvar kOnlyChildInParent = Symbol(\"only child in parent\");\nvar kNodeRef = Symbol(\"potential only child node ref\");\nfunction isOnlyChildInParent(tag, branchSize = 1) {\n  const extra = tag.node.extra;\n  if (extra[kOnlyChildInParent] !== void 0) {\n    return extra[kOnlyChildInParent];\n  }\n  const parentTag = getParentTag(tag);\n  if (parentTag && (0, import_babel_utils22.getTagDef)(parentTag)?.html) {\n    return extra[kOnlyChildInParent] = tag.parent.body.length === branchSize;\n  }\n  return extra[kOnlyChildInParent] = false;\n}\nfunction getOptimizedOnlyChildNodeRef(tag, section, branchSize = 1) {\n  if (isOnlyChildInParent(tag, branchSize)) {\n    const parentTag = getParentTag(tag).node;\n    const parentTagName = parentTag.name?.value;\n    return (parentTag.extra ??= {})[kNativeTagBinding] ??= createBinding(\n      \"#\" + parentTagName,\n      0 /* dom */,\n      section\n    );\n  } else {\n    return (tag.node.extra ??= {})[kNodeRef] ??= createBinding(\n      \"#text\",\n      0 /* dom */,\n      section\n    );\n  }\n}\n\n// src/translator/core/for.ts\nvar for_default = {\n  analyze(tag) {\n    const tagExtra = tag.node.extra ??= {};\n    const isAttrTag = tag.node.body.attributeTags;\n    let allowAttrs;\n    (0, import_babel_utils23.assertNoVar)(tag);\n    (0, import_babel_utils23.assertNoArgs)(tag);\n    assertNoSpreadAttrs(tag);\n    switch (getForType(tag.node)) {\n      case \"of\":\n        allowAttrs = [\"of\"];\n        break;\n      case \"in\":\n        allowAttrs = [\"in\"];\n        break;\n      case \"to\":\n        allowAttrs = [\"to\", \"from\", \"step\"];\n        break;\n      default:\n        throw tag.buildCodeFrameError(\n          \"Invalid `for` tag, missing an `of=`, `in=`, `to=` attribute.\"\n        );\n    }\n    if (!isAttrTag) {\n      allowAttrs.push(\"by\");\n    }\n    (0, import_babel_utils23.assertAllowedAttributes)(tag, allowAttrs);\n    if (isAttrTag) return;\n    const tagBody = tag.get(\"body\");\n    const bodySection = startSection(tagBody);\n    if (!bodySection) {\n      dropReferences(getAllTagReferenceNodes(tag.node));\n      return;\n    }\n    const section = getOrCreateSection(tag);\n    trackParamsReferences(tagBody, 3 /* param */, void 0, tagExtra);\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n    bodySection.sectionAccessor = {\n      binding: getOptimizedOnlyChildNodeRef(tag, section),\n      prefix: getAccessorPrefix().LoopScopeMap\n    };\n    bodySection.upstreamExpression = tagExtra;\n    bodySection.isBranch = true;\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        if (!isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n        flushBefore(tag);\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const onlyChildInParentOptimization = isOnlyChildInParent(tag);\n        const nodeRef2 = getOptimizedOnlyChildNodeRef(tag, tagSection);\n        const forAttrs = getKnownAttrValues(node);\n        const forType = getForType(node);\n        const params = node.body.params;\n        const statements = [];\n        const bodyStatements = node.body.body;\n        const sectionSources = getDynamicSourcesForSection(bodySection);\n        const hasHoists = isSectionWithHoists(bodySection);\n        const serializeReason = hasHoists || sectionSources?.all;\n        const singleNodeOptimization = bodySection.content === null || bodySection.content.singleChild && bodySection.content.startType !== 4 /* Text */;\n        if (serializeReason && onlyChildInParentOptimization) {\n          getParentTag(tag).node.extra[kSerializeMarker] = false;\n        }\n        flushInto(tag);\n        writeHTMLResumeStatements(tagBody);\n        const forTagArgs = getBaseArgsInForTag(forType, forAttrs);\n        const forTagHTMLRuntime = serializeReason ? forTypeToHTMLResumeRuntime(forType, singleNodeOptimization) : forTypeToRuntime(forType);\n        forTagArgs.push(\n          import_compiler33.types.arrowFunctionExpression(params, import_compiler33.types.blockStatement(bodyStatements))\n        );\n        if (serializeReason) {\n          forTagArgs.push(\n            forAttrs.by || import_compiler33.types.numericLiteral(0),\n            getScopeIdIdentifier(tagSection),\n            getScopeAccessorLiteral(nodeRef2)\n          );\n          if (onlyChildInParentOptimization) {\n            forTagArgs.push(import_compiler33.types.numericLiteral(1));\n          }\n        }\n        statements.push(\n          import_compiler33.types.expressionStatement(callRuntime(forTagHTMLRuntime, ...forTagArgs))\n        );\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (!bodySection) {\n          tag.remove();\n          return;\n        }\n        setSectionParentIsOwner(bodySection, true);\n        if (!isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const tagSection = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const { referencedBindings } = tagExtra;\n        const nodeRef2 = getOptimizedOnlyChildNodeRef(tag, tagSection);\n        setClosureSignalBuilder(tag, (closure, render) => {\n          return callRuntime(\n            \"loopClosure\",\n            getScopeAccessorLiteral(closure),\n            getScopeAccessorLiteral(nodeRef2),\n            render\n          );\n        });\n        const forType = getForType(node);\n        const signal = getSignal(tagSection, nodeRef2, \"for\");\n        signal.build = () => {\n          return callRuntime(\n            forTypeToDOMRuntime(forType),\n            getScopeAccessorLiteral(nodeRef2),\n            import_compiler33.types.identifier(bodySection.name)\n          );\n        };\n        const params = node.body.params;\n        signal.hasDownstreamIntersections = () => {\n          for (const param of params) {\n            const binding = param.extra?.binding;\n            if (binding) {\n              for (const {\n                referencedBindings: referencedBindings2\n              } of binding.downstreamExpressions) {\n                if (getSignal(\n                  bodySection,\n                  referencedBindings2\n                ).hasDownstreamIntersections()) {\n                  return true;\n                }\n              }\n            }\n          }\n          return false;\n        };\n        const forAttrs = getKnownAttrValues(node);\n        const loopArgs = getBaseArgsInForTag(forType, forAttrs);\n        if (forAttrs.by) {\n          loopArgs.push(forAttrs.by);\n        }\n        addValue(\n          tagSection,\n          referencedBindings,\n          signal,\n          import_compiler33.types.arrayExpression(loopArgs)\n        );\n        tag.remove();\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  attributes: {\n    of: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over a list of items.\"\n        }\n      ]\n    },\n    in: {\n      type: \"expression\",\n      autocomplete: [\n        {\n          description: \"Iterates over the keys and values of an object.\"\n        }\n      ]\n    },\n    to: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates up to the provided number (inclusive)\"\n        }\n      ]\n    },\n    from: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"Iterates starting from the provided number (inclusive)\"\n        }\n      ]\n    },\n    step: {\n      type: \"number\",\n      autocomplete: [\n        {\n          description: \"The amount to increment during each interation (with from/to)\"\n        }\n      ]\n    }\n  },\n  autocomplete: [\n    {\n      snippet: \"for|${1:value, index}| of=${3:array}\",\n      description: \"Use to iterate over lists, object properties, or between ranges.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-a-list\"\n    },\n    {\n      snippet: \"for|${1:name, value}| in=${3:object}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties\"\n    },\n    {\n      snippet: \"for|${1:index}| to=${2:number}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers\"\n    }\n  ]\n};\nfunction buildForRuntimeCall(type, attrs2, params, statements) {\n  return import_compiler33.types.expressionStatement(\n    callRuntime(\n      forTypeToRuntime(type),\n      ...getBaseArgsInForTag(type, attrs2),\n      import_compiler33.types.arrowFunctionExpression(params, import_compiler33.types.blockStatement(statements))\n    )\n  );\n}\nfunction getForType(tag) {\n  for (const attr2 of tag.attributes) {\n    if (attr2.type === \"MarkoAttribute\") {\n      switch (attr2.name) {\n        case \"of\":\n        case \"in\":\n        case \"to\":\n          return attr2.name;\n      }\n    }\n  }\n}\nfunction forTypeToRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"forOf\";\n    case \"in\":\n      return \"forIn\";\n    case \"to\":\n      return \"forTo\";\n  }\n}\nfunction forTypeToHTMLResumeRuntime(type, singleNodeOptimization) {\n  if (singleNodeOptimization) {\n    switch (type) {\n      case \"of\":\n        return \"resumeSingleNodeForOf\";\n      case \"in\":\n        return \"resumeSingleNodeForIn\";\n      case \"to\":\n        return \"resumeSingleNodeForTo\";\n    }\n  } else {\n    switch (type) {\n      case \"of\":\n        return \"resumeForOf\";\n      case \"in\":\n        return \"resumeForIn\";\n      case \"to\":\n        return \"resumeForTo\";\n    }\n  }\n}\nfunction forTypeToDOMRuntime(type) {\n  switch (type) {\n    case \"of\":\n      return \"loopOf\";\n    case \"in\":\n      return \"loopIn\";\n    case \"to\":\n      return \"loopTo\";\n  }\n}\nfunction getBaseArgsInForTag(type, attrs2) {\n  switch (type) {\n    case \"in\":\n      return [attrs2.in];\n    case \"of\":\n      return [attrs2.of];\n    case \"to\":\n      return [\n        attrs2.to,\n        attrs2.from || import_compiler33.types.numericLiteral(0),\n        attrs2.step || import_compiler33.types.numericLiteral(1)\n      ];\n  }\n}\n\n// src/translator/util/translate-attrs.ts\nvar contentProps = /* @__PURE__ */ new WeakSet();\nfunction translateAttrs(tag, templateExports, statements = [], contentKey = \"content\") {\n  const seen = /* @__PURE__ */ new Set();\n  const properties = [];\n  const attrTagLookup = tag.node.extra?.attributeTags;\n  if (attrTagLookup) {\n    for (const name2 in attrTagLookup) {\n      const attrTagMeta = attrTagLookup[name2];\n      if (usesExport(templateExports, attrTagMeta.name)) {\n        seen.add(attrTagMeta.name);\n        if (attrTagMeta.dynamic) {\n          statements.push(\n            import_compiler34.types.variableDeclaration(\"let\", [\n              import_compiler34.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta))\n            ])\n          );\n          properties.push(\n            toObjectProperty(\n              attrTagMeta.name,\n              getAttrTagIdentifier(attrTagMeta)\n            )\n          );\n        }\n      }\n    }\n    const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils24.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          if (attrTagMeta.dynamic) {\n            i = addDynamicAttrTagStatements(\n              attrTags2,\n              i,\n              attrTagLookup,\n              statements,\n              templateExports,\n              contentKey\n            );\n          } else {\n            const translatedAttrTag = translateAttrs(\n              child,\n              templateExports?.[attrTagMeta.name]?.props,\n              statements,\n              contentKey\n            );\n            if (attrTagMeta.repeated) {\n              const prevProp = findObjectProperty(attrTagMeta.name, properties);\n              if (prevProp) {\n                prevProp.value = callRuntime(\n                  \"attrTags\",\n                  prevProp.value,\n                  propsToExpression(translatedAttrTag.properties)\n                );\n              } else {\n                properties.push(\n                  toObjectProperty(\n                    attrTagMeta.name,\n                    callRuntime(\n                      \"attrTag\",\n                      propsToExpression(translatedAttrTag.properties)\n                    )\n                  )\n                );\n              }\n            } else {\n              properties.push(\n                toObjectProperty(\n                  attrTagMeta.name,\n                  callRuntime(\n                    \"attrTag\",\n                    propsToExpression(translatedAttrTag.properties)\n                  )\n                )\n              );\n            }\n          }\n        } else {\n          i = addDynamicAttrTagStatements(\n            attrTags2,\n            i,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        }\n      }\n    }\n  }\n  if (!seen.has(contentKey) && usesExport(templateExports, contentKey)) {\n    seen.add(contentKey);\n    const contentExpression = buildContent(tag.get(\"body\"));\n    if (contentExpression) {\n      const contentProp = import_compiler34.types.objectProperty(\n        import_compiler34.types.identifier(contentKey),\n        contentExpression\n      );\n      contentProps.add(contentProp);\n      properties.push(contentProp);\n    }\n  }\n  const { attributes } = tag.node;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler34.types.isMarkoSpreadAttribute(attr2)) {\n      properties.push(import_compiler34.types.spreadElement(value));\n    } else if (!seen.has(attr2.name) && usesExport(templateExports, attr2.name)) {\n      seen.add(attr2.name);\n      properties.push(toObjectProperty(attr2.name, value));\n    }\n  }\n  properties.reverse();\n  return { properties, statements };\n}\nfunction getTranslatedBodyContentProperty(props) {\n  for (const prop of props) {\n    if (contentProps.has(prop)) {\n      return prop;\n    }\n  }\n}\nfunction addDynamicAttrTagStatements(attrTags2, index, attrTagLookup, statements, templateExports, contentKey = \"content\") {\n  const tag = attrTags2[index];\n  if (tag.isMarkoTag()) {\n    if ((0, import_babel_utils24.isAttributeTag)(tag)) {\n      const attrTagMeta = attrTagLookup[getTagName(tag)];\n      if (usesExport(templateExports, attrTagMeta.name) && attrTagMeta.dynamic) {\n        const translatedAttrTag = translateAttrs(\n          tag,\n          templateExports?.[attrTagMeta.name]?.props,\n          statements,\n          contentKey\n        );\n        if (attrTagMeta.repeated) {\n          statements.push(\n            import_compiler34.types.expressionStatement(\n              import_compiler34.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTags\",\n                  getAttrTagIdentifier(attrTagMeta),\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        } else {\n          statements.push(\n            import_compiler34.types.expressionStatement(\n              import_compiler34.types.assignmentExpression(\n                \"=\",\n                getAttrTagIdentifier(attrTagMeta),\n                callRuntime(\n                  \"attrTag\",\n                  propsToExpression(translatedAttrTag.properties)\n                )\n              )\n            )\n          );\n        }\n      }\n    } else {\n      switch (getTagName(tag)) {\n        case \"if\":\n          return translateIfAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        case \"for\": {\n          return translateForAttrTag(\n            attrTags2,\n            index,\n            attrTagLookup,\n            statements,\n            templateExports,\n            contentKey\n          );\n        }\n      }\n    }\n  }\n  return index;\n}\nfunction propsToExpression(props) {\n  return props.length === 1 && import_compiler34.types.isSpreadElement(props[0]) ? props[0].argument : import_compiler34.types.objectExpression(props);\n}\nfunction translateForAttrTag(attrTags2, index, attrTagLookup, statements, templateExports, contentKey) {\n  const forTag = attrTags2[index];\n  const bodyStatements = [];\n  addAllAttrTagsAsDynamic(\n    forTag,\n    attrTagLookup,\n    bodyStatements,\n    templateExports,\n    contentKey\n  );\n  statements.push(\n    buildForRuntimeCall(\n      getForType(forTag.node),\n      getKnownAttrValues(forTag.node),\n      forTag.node.body.params,\n      bodyStatements\n    )\n  );\n  return index;\n}\nfunction translateIfAttrTag(attrTags2, index, attrTagLookup, statements, templateExports, contentKey) {\n  const ifTag = attrTags2[index];\n  const consequentStatements = [];\n  let ifStatement = import_compiler34.types.ifStatement(\n    getConditionTestValue(ifTag),\n    import_compiler34.types.blockStatement(consequentStatements)\n  );\n  statements.push(ifStatement);\n  addAllAttrTagsAsDynamic(\n    ifTag,\n    attrTagLookup,\n    consequentStatements,\n    templateExports,\n    contentKey\n  );\n  let nextIndex = index + 1;\n  while (nextIndex < attrTags2.length) {\n    const nextTag = attrTags2[nextIndex];\n    if (nextTag.isMarkoTag()) {\n      switch (getTagName(nextTag)) {\n        case \"else-if\":\n        case \"else\": {\n          const testValue = getConditionTestValue(nextTag);\n          const alternateStatements = [];\n          addAllAttrTagsAsDynamic(\n            nextTag,\n            attrTagLookup,\n            alternateStatements,\n            templateExports,\n            contentKey\n          );\n          if (testValue) {\n            ifStatement.alternate = ifStatement = import_compiler34.types.ifStatement(\n              testValue,\n              import_compiler34.types.blockStatement(alternateStatements)\n            );\n            nextIndex++;\n            continue;\n          } else {\n            ifStatement.alternate = import_compiler34.types.blockStatement(alternateStatements);\n            break;\n          }\n        }\n      }\n    }\n    break;\n  }\n  return nextIndex - 1;\n}\nfunction addAllAttrTagsAsDynamic(tag, attrTagLookup, statements, templateExports, contentKey) {\n  const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n  for (let i = 0; i < attrTags2.length; i++) {\n    i = addDynamicAttrTagStatements(\n      attrTags2,\n      i,\n      attrTagLookup,\n      statements,\n      templateExports,\n      contentKey\n    );\n  }\n}\nfunction usesExport(templateExports, name2) {\n  return !templateExports || !!templateExports[name2];\n}\nfunction findObjectProperty(name2, props) {\n  for (const prop of props) {\n    if (prop.type === \"ObjectProperty\") {\n      switch (prop.key.type) {\n        case \"StringLiteral\":\n          if (prop.key.value === name2) {\n            return prop;\n          }\n          break;\n        case \"Identifier\":\n          if (prop.key.name === name2) {\n            return prop;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\nfunction getConditionTestValue({\n  node: { attributes }\n}) {\n  return attributes.length === 1 ? attributes[0].value : void 0;\n}\nfunction buildContent(body) {\n  const bodySection = body.node.extra?.section;\n  if (bodySection) {\n    if (isOutputHTML()) {\n      const serialized = isSerializedSection(bodySection);\n      return callRuntime(\n        serialized ? \"registerContent\" : \"createContent\",\n        import_compiler34.types.stringLiteral(getResumeRegisterId(bodySection, \"renderer\")),\n        import_compiler34.types.arrowFunctionExpression(\n          body.node.params,\n          import_compiler34.types.blockStatement(body.node.body)\n        ),\n        serialized ? getScopeIdIdentifier(\n          getSection(\n            getNonAttributeTagParent(\n              body.parentPath\n            )\n          )\n        ) : void 0\n      );\n    } else {\n      return import_compiler34.types.callExpression(import_compiler34.types.identifier(bodySection.name), [\n        scopeIdentifier\n      ]);\n    }\n  }\n}\nfunction getNonAttributeTagParent(tag) {\n  let cur = tag;\n  while ((0, import_babel_utils24.isAttributeTag)(cur) || (0, import_babel_utils24.isTransparentTag)(cur)) {\n    cur = getParentTag(cur);\n  }\n  return cur;\n}\n\n// src/translator/core/define.ts\nvar define_default = {\n  analyze(tag) {\n    (0, import_babel_utils25.assertNoArgs)(tag);\n    if (!tag.node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `define` tag requires a tag variable.\");\n    }\n    const tagBody = tag.get(\"body\");\n    const bodySection = startSection(tagBody);\n    trackVarReferences(tag, 4 /* derived */);\n    if (bodySection) {\n      const varBinding = tag.node.var?.extra?.binding;\n      if (varBinding) {\n        bodySection.downstreamBinding = varBinding.propertyAliases.get(\"content\") || varBinding;\n      }\n    }\n    trackParamsReferences(tagBody, 3 /* param */);\n    analyzeAttributeTags(tag);\n    mergeReferences(\n      getOrCreateSection(tag),\n      tag.node,\n      getAllTagReferenceNodes(tag.node)\n    );\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const translatedAttrs = translateAttrs(tag);\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        tag.insertBefore(translatedAttrs.statements);\n        translateVar(tag, propsToExpression(translatedAttrs.properties));\n      } else {\n        const section = getSection(tag);\n        const referencedBindings = node.extra?.referencedBindings;\n        const derivation = initValue(tag.get(\"var\").node.extra.binding);\n        if (translatedAttrs.statements.length) {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            translatedAttrs.statements\n          );\n        }\n        addValue(\n          section,\n          referencedBindings,\n          derivation,\n          propsToExpression(translatedAttrs.properties)\n        );\n      }\n      tag.remove();\n    }\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a constant object binding that can be rendered.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#define\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/define.d.marko\"\n};\n\n// src/translator/core/effect.ts\nvar import_compiler36 = require(\"@marko/compiler\");\nvar import_babel_utils26 = require(\"@marko/compiler/babel-utils\");\nvar effect_default = {\n  migrate: [\n    (tag) => {\n      (0, import_babel_utils26.assertNoArgs)(tag);\n      (0, import_babel_utils26.assertNoParams)(tag);\n      assertNoBodyContent(tag);\n      (0, import_babel_utils26.assertNoAttributeTags)(tag);\n      assertNoSpreadAttrs(tag);\n      (0, import_babel_utils26.assertAllowedAttributes)(tag, [\"value\"]);\n      (0, import_babel_utils26.diagnosticDeprecate)(tag, {\n        label: \"The 'effect' tag has been replaced by the 'script' tag.\",\n        fix() {\n          const { node } = tag;\n          tag.replaceWith(\n            import_compiler36.types.markoTag(\n              withPreviousLocation(import_compiler36.types.stringLiteral(\"script\"), node.name),\n              node.attributes,\n              node.body,\n              node.arguments,\n              node.var,\n              node.attributeTags\n            )\n          );\n        }\n      });\n    }\n  ],\n  attributes: {},\n  types: runtime_info_default.name + \"/tag-types/effect.d.marko\"\n};\n\n// src/translator/core/export.ts\nvar import_babel_utils27 = require(\"@marko/compiler/babel-utils\");\nvar export_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils27.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"export <value>\"\n    }\n  ]\n};\n\n// src/translator/core/html-comment.ts\nvar import_compiler37 = require(\"@marko/compiler\");\nvar import_babel_utils28 = require(\"@marko/compiler/babel-utils\");\nvar kCommentTagBinding = Symbol(\"comment tag binding\");\nvar kGetterId2 = Symbol(\"node getter id\");\nvar html_comment_default = {\n  analyze(tag) {\n    (0, import_babel_utils28.assertNoArgs)(tag);\n    (0, import_babel_utils28.assertNoParams)(tag);\n    (0, import_babel_utils28.assertNoAttributes)(tag);\n    const tagVar = tag.node.var;\n    let needsBinding = false;\n    let needsGetter = false;\n    if (tagVar) {\n      if (!import_compiler37.types.isIdentifier(tagVar)) {\n        throw tag.get(\"var\").buildCodeFrameError(\n          \"The `html-comment` tag variable cannot be destructured.\"\n        );\n      }\n      needsBinding = true;\n      for (const ref of tag.scope.getBinding(tagVar.name).referencePaths) {\n        if (!isInvokedFunction(ref)) {\n          needsGetter = true;\n          break;\n        }\n      }\n    }\n    const referenceNodes = [];\n    for (const child of tag.get(\"body\").get(\"body\")) {\n      if (child.isMarkoPlaceholder()) {\n        referenceNodes.push(child.node.value);\n        needsBinding = true;\n      } else if (!child.isMarkoText()) {\n        throw child.buildCodeFrameError(\n          \"Invalid child. Only text is allowed inside an html comment.\"\n        );\n      }\n    }\n    if (needsBinding) {\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      if (needsGetter) {\n        tagExtra[kGetterId2] = getRegisterUID(section, \"comment\");\n      }\n      tagExtra[kCommentTagBinding] = createBinding(\n        \"#comment\",\n        0 /* dom */,\n        section\n      );\n      mergeReferences(section, tag.node, referenceNodes);\n    }\n    tag.skip();\n  },\n  translate: {\n    enter(tag) {\n      const tagExtra = tag.node.extra;\n      const commentBinding = tagExtra[kCommentTagBinding];\n      const hasVar = !!tag.node.var;\n      if (hasVar) {\n        const getterId = tagExtra[kGetterId2];\n        if (isOutputHTML()) {\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(getSection(tag)),\n              getterId && import_compiler37.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);\n            (0, import_babel_utils28.getProgram)().node.body.push(\n              import_compiler37.types.variableDeclaration(\"const\", [\n                import_compiler37.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler37.types.stringLiteral(getterId),\n                    getScopeAccessorLiteral(commentBinding)\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (isInvokedFunction(reference)) {\n              reference.parentPath.replaceWith(\n                import_compiler37.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, commentBinding)\n                )\n              );\n            } else if (getterFnIdentifier) {\n              reference.replaceWith(\n                import_compiler37.types.callExpression(getterFnIdentifier, [\n                  getScopeExpression(referenceSection, getSection(tag))\n                ])\n              );\n            }\n          }\n        }\n      }\n      if (tagExtra[kCommentTagBinding]) {\n        visit(tag, 32 /* Get */);\n      }\n      enter2(tag);\n      writeTo(tag)`<!--`;\n    },\n    exit(tag) {\n      const tagExtra = tag.node.extra;\n      const commentBinding = tagExtra[kCommentTagBinding];\n      const write2 = writeTo(tag);\n      if (isOutputHTML()) {\n        for (const child of tag.node.body.body) {\n          if (import_compiler37.types.isMarkoText(child)) {\n            write2`${child.value}`;\n          } else if (import_compiler37.types.isMarkoPlaceholder(child)) {\n            write2`${callRuntime(\"escapeXML\", child.value)}`;\n          }\n        }\n      } else {\n        const templateQuasis = [];\n        const templateExpressions = [];\n        let currentQuasi = \"\";\n        for (const child of tag.node.body.body) {\n          if (import_compiler37.types.isMarkoText(child)) {\n            currentQuasi += child.value;\n          } else if (import_compiler37.types.isMarkoPlaceholder(child)) {\n            templateQuasis.push(import_compiler37.types.templateElement({ raw: currentQuasi }));\n            templateExpressions.push(child.value);\n            currentQuasi = \"\";\n          }\n        }\n        if (templateExpressions.length === 0) {\n          write2`${currentQuasi}`;\n        } else {\n          templateQuasis.push(import_compiler37.types.templateElement({ raw: currentQuasi }));\n          addStatement(\n            \"render\",\n            getSection(tag),\n            tagExtra.referencedBindings,\n            import_compiler37.types.expressionStatement(\n              callRuntime(\n                \"data\",\n                import_compiler37.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(commentBinding),\n                  true\n                ),\n                import_compiler37.types.templateLiteral(templateQuasis, templateExpressions)\n              )\n            )\n          );\n        }\n      }\n      exit2(tag);\n      write2`-->`;\n      if (commentBinding) {\n        markNode(tag, commentBinding);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    text: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create an html comment that is not stripped from the output.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#html-comment\"\n    }\n  ]\n};\n\n// src/translator/core/html-script.ts\nvar import_compiler38 = require(\"@marko/compiler\");\nvar import_babel_utils29 = require(\"@marko/compiler/babel-utils\");\nvar kGetterId3 = Symbol(\"node getter id\");\nvar html_script_default = {\n  analyze(tag) {\n    (0, import_babel_utils29.assertNoArgs)(tag);\n    (0, import_babel_utils29.assertNoParams)(tag);\n    const { node } = tag;\n    if (node.var && !import_compiler38.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\n        \"Tag variables on native elements cannot be destructured.\"\n      );\n    }\n    const section = getOrCreateSection(tag);\n    let hasEventHandlers = false;\n    let hasDynamicAttributes = false;\n    const seen = {};\n    const { attributes } = tag.node;\n    let spreadReferenceNodes;\n    for (let i = attributes.length; i--; ) {\n      const attr2 = attributes[i];\n      if (import_compiler38.types.isMarkoAttribute(attr2)) {\n        if (seen[attr2.name]) {\n          dropReferences(attr2.value);\n          continue;\n        }\n        seen[attr2.name] = attr2;\n        if (isEventHandler(attr2.name)) {\n          (attr2.value.extra ??= {}).isEffect = true;\n          hasEventHandlers = true;\n        } else if (!evaluate(attr2.value).confident) {\n          hasDynamicAttributes = true;\n        }\n      } else if (import_compiler38.types.isMarkoSpreadAttribute(attr2)) {\n        hasEventHandlers = true;\n        hasDynamicAttributes = true;\n        (attr2.value.extra ??= {}).isEffect = true;\n      }\n      if (spreadReferenceNodes) {\n        spreadReferenceNodes.push(attr2.value);\n      } else if (import_compiler38.types.isMarkoSpreadAttribute(attr2)) {\n        spreadReferenceNodes = [attr2.value];\n      }\n    }\n    if (spreadReferenceNodes) {\n      mergeReferences(section, tag.node, spreadReferenceNodes);\n    }\n    const bodyPlaceholderNodes = [];\n    let hasBodyPlaceholders = false;\n    for (const child of tag.node.body.body) {\n      if (import_compiler38.types.isMarkoPlaceholder(child)) {\n        bodyPlaceholderNodes.push(child.value);\n        hasBodyPlaceholders = true;\n      } else if (!import_compiler38.types.isMarkoText(child)) {\n        throw tag.hub.buildError(\n          child,\n          \"Invalid child. Only text is allowed inside an html-script.\"\n        );\n      }\n    }\n    if (bodyPlaceholderNodes.length > 1) {\n      mergeReferences(\n        section,\n        bodyPlaceholderNodes[0],\n        bodyPlaceholderNodes.slice(1)\n      );\n    }\n    if (node.var || hasEventHandlers || hasDynamicAttributes || hasBodyPlaceholders) {\n      (0, import_babel_utils29.getProgram)().node.extra.isInteractive ||= hasEventHandlers;\n      const tagExtra = node.extra ??= {};\n      const bindingName = \"#script\";\n      tagExtra[kSerializeMarker] = hasEventHandlers || !!node.var;\n      tagExtra[kNativeTagBinding] = createBinding(\n        bindingName,\n        0 /* dom */,\n        section\n      );\n      if (node.var) {\n        for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n          if (!isInvokedFunction(ref)) {\n            tagExtra[kGetterId3] = getRegisterUID(section, bindingName);\n            break;\n          }\n        }\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagExtra = tag.node.extra;\n      const nodeRef2 = tagExtra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(tag);\n      const section = getSection(tag);\n      const hasVar = !!tag.node.var;\n      if (hasVar) {\n        const getterId = tagExtra[kGetterId3];\n        if (isHTML) {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          for (const reference of references) {\n            serializeOwners(getSection(reference), section);\n          }\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(section),\n              getterId && import_compiler38.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);\n            (0, import_babel_utils29.getProgram)().node.body.push(\n              import_compiler38.types.variableDeclaration(\"const\", [\n                import_compiler38.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler38.types.stringLiteral(getterId),\n                    getScopeAccessorLiteral(nodeRef2)\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (isInvokedFunction(reference)) {\n              reference.parentPath.replaceWith(\n                import_compiler38.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, nodeRef2)\n                )\n              );\n            } else if (getterFnIdentifier) {\n              reference.replaceWith(\n                import_compiler38.types.callExpression(getterFnIdentifier, [\n                  getScopeExpression(referenceSection, getSection(tag))\n                ])\n              );\n            }\n          }\n        }\n      }\n      let visitAccessor;\n      if (nodeRef2) {\n        visitAccessor = getScopeAccessorLiteral(nodeRef2);\n        visit(tag, 32 /* Get */);\n      }\n      write2`<script`;\n      const usedAttrs = getUsedAttrs2(tag.node);\n      const { staticAttrs, skipExpression, spreadExpression } = usedAttrs;\n      for (const attr2 of staticAttrs) {\n        const { name: name2, value } = attr2;\n        const { confident, computed } = value.extra || {};\n        const valueReferences = value.extra?.referencedBindings;\n        switch (name2) {\n          case \"class\":\n          case \"style\": {\n            const helper = `${name2}Attr`;\n            if (confident) {\n              write2`${getHTMLRuntime()[helper](computed)}`;\n            } else if (isHTML) {\n              write2`${callRuntime(helper, value)}`;\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler38.types.expressionStatement(\n                  callRuntime(\n                    helper,\n                    import_compiler38.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n          }\n          default:\n            if (confident) {\n              write2`${getHTMLRuntime().attr(name2, computed)}`;\n            } else if (isHTML) {\n              if (isEventHandler(name2)) {\n                addHTMLEffectCall(section, valueReferences);\n              } else {\n                write2`${callRuntime(\"attr\", import_compiler38.types.stringLiteral(name2), value)}`;\n              }\n            } else if (isEventHandler(name2)) {\n              addStatement(\n                \"effect\",\n                section,\n                valueReferences,\n                import_compiler38.types.expressionStatement(\n                  callRuntime(\n                    \"on\",\n                    import_compiler38.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler38.types.stringLiteral(getEventHandlerName(name2)),\n                    value\n                  )\n                )\n              );\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler38.types.expressionStatement(\n                  callRuntime(\n                    \"attr\",\n                    import_compiler38.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler38.types.stringLiteral(name2),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n        }\n      }\n      if (spreadExpression) {\n        if (isHTML) {\n          addHTMLEffectCall(section, tagExtra.referencedBindings);\n          if (skipExpression) {\n            write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler38.types.stringLiteral(\"script\"))}`;\n          } else {\n            write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler38.types.stringLiteral(\"script\"))}`;\n          }\n        } else {\n          if (skipExpression) {\n            addStatement(\n              \"render\",\n              section,\n              tagExtra.referencedBindings,\n              import_compiler38.types.expressionStatement(\n                callRuntime(\n                  \"partialAttrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression,\n                  skipExpression\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              tagExtra.referencedBindings,\n              import_compiler38.types.expressionStatement(\n                callRuntime(\n                  \"attrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression\n                )\n              )\n            );\n          }\n          addStatement(\n            \"effect\",\n            section,\n            tagExtra.referencedBindings,\n            import_compiler38.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            false\n          );\n        }\n      }\n      write2`>`;\n      enter2(tag);\n    },\n    exit(tag) {\n      const tagExtra = tag.node.extra;\n      const nodeRef2 = tagExtra[kNativeTagBinding];\n      const write2 = writeTo(tag);\n      const visitAccessor = nodeRef2 && getScopeAccessorLiteral(nodeRef2);\n      if (isOutputHTML()) {\n        for (const child of tag.node.body.body) {\n          if (import_compiler38.types.isMarkoText(child)) {\n            write2`${child.value}`;\n          } else if (import_compiler38.types.isMarkoPlaceholder(child)) {\n            write2`${callRuntime(\"escapeScript\", child.value)}`;\n          }\n        }\n      } else {\n        const templateQuasis = [];\n        const templateExpressions = [];\n        let currentQuasi = \"\";\n        let referencePlaceholder;\n        for (const child of tag.node.body.body) {\n          if (import_compiler38.types.isMarkoText(child)) {\n            currentQuasi += child.value;\n          } else if (import_compiler38.types.isMarkoPlaceholder(child)) {\n            referencePlaceholder ||= child;\n            templateQuasis.push(import_compiler38.types.templateElement({ raw: currentQuasi }));\n            templateExpressions.push(child.value);\n            currentQuasi = \"\";\n          }\n        }\n        if (!referencePlaceholder) {\n          write2`${currentQuasi}`;\n        } else {\n          templateQuasis.push(import_compiler38.types.templateElement({ raw: currentQuasi }));\n          addStatement(\n            \"render\",\n            getSection(tag),\n            referencePlaceholder.value.extra?.referencedBindings,\n            import_compiler38.types.expressionStatement(\n              callRuntime(\n                \"textContent\",\n                import_compiler38.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                import_compiler38.types.templateLiteral(templateQuasis, templateExpressions)\n              )\n            )\n          );\n        }\n      }\n      write2`</script>`;\n      if (nodeRef2) {\n        markNode(tag, nodeRef2);\n      }\n      exit2(tag);\n      tag.remove();\n    }\n  },\n  \"@async\": \"#html-async\",\n  \"@crossorigin\": \"#html-crossorigin\",\n  \"@defer\": \"#html-defer\",\n  \"@integrity\": \"#html-integrity\",\n  \"@nomodule\": \"#html-nomodule\",\n  \"@nonce\": \"#html-nonce\",\n  \"@referrerpolicy\": \"#html-referrerpolicy\",\n  \"@src\": \"#html-src\",\n  \"@type\": \"#html-type\",\n  \"attribute-groups\": [\"html-attributes\"],\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  }\n};\nfunction getUsedAttrs2(tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler38.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n      }\n      spreadProps.push(import_compiler38.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler38.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler38.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    spreadExpression,\n    skipExpression\n  };\n}\n\n// src/translator/core/html-style.ts\nvar import_compiler39 = require(\"@marko/compiler\");\nvar import_babel_utils30 = require(\"@marko/compiler/babel-utils\");\nvar kGetterId4 = Symbol(\"node getter id\");\nvar html_style_default = {\n  analyze(tag) {\n    (0, import_babel_utils30.assertNoArgs)(tag);\n    (0, import_babel_utils30.assertNoParams)(tag);\n    const { node } = tag;\n    if (node.var && !import_compiler39.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\n        \"Tag variables on native elements cannot be destructured.\"\n      );\n    }\n    const section = getOrCreateSection(tag);\n    let hasEventHandlers = false;\n    let hasDynamicAttributes = false;\n    const seen = {};\n    const { attributes } = tag.node;\n    let spreadReferenceNodes;\n    for (let i = attributes.length; i--; ) {\n      const attr2 = attributes[i];\n      if (import_compiler39.types.isMarkoAttribute(attr2)) {\n        if (seen[attr2.name]) {\n          dropReferences(attr2.value);\n          continue;\n        }\n        seen[attr2.name] = attr2;\n        if (isEventHandler(attr2.name)) {\n          (attr2.value.extra ??= {}).isEffect = true;\n          hasEventHandlers = true;\n        } else if (!evaluate(attr2.value).confident) {\n          hasDynamicAttributes = true;\n        }\n      } else if (import_compiler39.types.isMarkoSpreadAttribute(attr2)) {\n        hasEventHandlers = true;\n        hasDynamicAttributes = true;\n        (attr2.value.extra ??= {}).isEffect = true;\n      }\n      if (spreadReferenceNodes) {\n        spreadReferenceNodes.push(attr2.value);\n      } else if (import_compiler39.types.isMarkoSpreadAttribute(attr2)) {\n        spreadReferenceNodes = [attr2.value];\n      }\n    }\n    if (spreadReferenceNodes) {\n      mergeReferences(section, tag.node, spreadReferenceNodes);\n    }\n    const bodyPlaceholderNodes = [];\n    let hasBodyPlaceholders = false;\n    for (const child of tag.node.body.body) {\n      if (import_compiler39.types.isMarkoPlaceholder(child)) {\n        bodyPlaceholderNodes.push(child.value);\n        hasBodyPlaceholders = true;\n      } else if (!import_compiler39.types.isMarkoText(child)) {\n        throw tag.hub.buildError(\n          child,\n          \"Invalid child. Only text is allowed inside an html-style.\"\n        );\n      }\n    }\n    if (bodyPlaceholderNodes.length > 1) {\n      mergeReferences(\n        section,\n        bodyPlaceholderNodes[0],\n        bodyPlaceholderNodes.slice(1)\n      );\n    }\n    if (node.var || hasEventHandlers || hasDynamicAttributes || hasBodyPlaceholders) {\n      (0, import_babel_utils30.getProgram)().node.extra.isInteractive ||= hasEventHandlers;\n      const tagExtra = node.extra ??= {};\n      const bindingName = \"#style\";\n      tagExtra[kSerializeMarker] = hasEventHandlers || !!node.var;\n      tagExtra[kNativeTagBinding] = createBinding(\n        bindingName,\n        0 /* dom */,\n        section\n      );\n      if (node.var) {\n        for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {\n          if (!isInvokedFunction(ref)) {\n            tagExtra[kGetterId4] = getRegisterUID(section, bindingName);\n            break;\n          }\n        }\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagExtra = tag.node.extra;\n      const nodeRef2 = tagExtra[kNativeTagBinding];\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(tag);\n      const section = getSection(tag);\n      const hasVar = !!tag.node.var;\n      if (hasVar) {\n        const getterId = tagExtra[kGetterId4];\n        if (isHTML) {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          for (const reference of references) {\n            serializeOwners(getSection(reference), section);\n          }\n          translateVar(\n            tag,\n            callRuntime(\n              \"nodeRef\",\n              getterId && getScopeIdIdentifier(section),\n              getterId && import_compiler39.types.stringLiteral(getterId)\n            )\n          );\n        } else {\n          const varName = tag.node.var.name;\n          const references = tag.scope.getBinding(varName).referencePaths;\n          let getterFnIdentifier;\n          if (getterId) {\n            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);\n            (0, import_babel_utils30.getProgram)().node.body.push(\n              import_compiler39.types.variableDeclaration(\"const\", [\n                import_compiler39.types.variableDeclarator(\n                  getterFnIdentifier,\n                  callRuntime(\n                    \"nodeRef\",\n                    import_compiler39.types.stringLiteral(getterId),\n                    getScopeAccessorLiteral(nodeRef2)\n                  )\n                )\n              ])\n            );\n          }\n          for (const reference of references) {\n            const referenceSection = getSection(reference);\n            if (isInvokedFunction(reference)) {\n              reference.parentPath.replaceWith(\n                import_compiler39.types.expressionStatement(\n                  createScopeReadExpression(referenceSection, nodeRef2)\n                )\n              );\n            } else if (getterFnIdentifier) {\n              reference.replaceWith(\n                import_compiler39.types.callExpression(getterFnIdentifier, [\n                  getScopeExpression(referenceSection, getSection(tag))\n                ])\n              );\n            }\n          }\n        }\n      }\n      let visitAccessor;\n      if (nodeRef2) {\n        visitAccessor = getScopeAccessorLiteral(nodeRef2);\n        visit(tag, 32 /* Get */);\n      }\n      write2`<style`;\n      const usedAttrs = getUsedAttrs3(tag.node);\n      const { staticAttrs, skipExpression, spreadExpression } = usedAttrs;\n      for (const attr2 of staticAttrs) {\n        const { name: name2, value } = attr2;\n        const { confident, computed } = value.extra || {};\n        const valueReferences = value.extra?.referencedBindings;\n        switch (name2) {\n          case \"class\":\n          case \"style\": {\n            const helper = `${name2}Attr`;\n            if (confident) {\n              write2`${getHTMLRuntime()[helper](computed)}`;\n            } else if (isHTML) {\n              write2`${callRuntime(helper, value)}`;\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler39.types.expressionStatement(\n                  callRuntime(\n                    helper,\n                    import_compiler39.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n          }\n          default:\n            if (confident) {\n              write2`${getHTMLRuntime().attr(name2, computed)}`;\n            } else if (isHTML) {\n              if (isEventHandler(name2)) {\n                addHTMLEffectCall(section, valueReferences);\n              } else {\n                write2`${callRuntime(\"attr\", import_compiler39.types.stringLiteral(name2), value)}`;\n              }\n            } else if (isEventHandler(name2)) {\n              addStatement(\n                \"effect\",\n                section,\n                valueReferences,\n                import_compiler39.types.expressionStatement(\n                  callRuntime(\n                    \"on\",\n                    import_compiler39.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler39.types.stringLiteral(getEventHandlerName(name2)),\n                    value\n                  )\n                )\n              );\n            } else {\n              addStatement(\n                \"render\",\n                section,\n                valueReferences,\n                import_compiler39.types.expressionStatement(\n                  callRuntime(\n                    \"attr\",\n                    import_compiler39.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                    import_compiler39.types.stringLiteral(name2),\n                    value\n                  )\n                )\n              );\n            }\n            break;\n        }\n      }\n      if (spreadExpression) {\n        if (isHTML) {\n          addHTMLEffectCall(section, tagExtra.referencedBindings);\n          if (skipExpression) {\n            write2`${callRuntime(\"partialAttrs\", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler39.types.stringLiteral(\"style\"))}`;\n          } else {\n            write2`${callRuntime(\"attrs\", spreadExpression, visitAccessor, getScopeIdIdentifier(section), import_compiler39.types.stringLiteral(\"style\"))}`;\n          }\n        } else {\n          if (skipExpression) {\n            addStatement(\n              \"render\",\n              section,\n              tagExtra.referencedBindings,\n              import_compiler39.types.expressionStatement(\n                callRuntime(\n                  \"partialAttrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression,\n                  skipExpression\n                )\n              )\n            );\n          } else {\n            addStatement(\n              \"render\",\n              section,\n              tagExtra.referencedBindings,\n              import_compiler39.types.expressionStatement(\n                callRuntime(\n                  \"attrs\",\n                  scopeIdentifier,\n                  visitAccessor,\n                  spreadExpression\n                )\n              )\n            );\n          }\n          addStatement(\n            \"effect\",\n            section,\n            tagExtra.referencedBindings,\n            import_compiler39.types.expressionStatement(\n              callRuntime(\"attrsEvents\", scopeIdentifier, visitAccessor)\n            ),\n            false\n          );\n        }\n      }\n    },\n    exit(tag) {\n      const tagExtra = tag.node.extra;\n      const nodeRef2 = tagExtra[kNativeTagBinding];\n      const write2 = writeTo(tag);\n      const visitAccessor = nodeRef2 && getScopeAccessorLiteral(nodeRef2);\n      write2`>`;\n      enter2(tag);\n      if (isOutputHTML()) {\n        for (const child of tag.node.body.body) {\n          if (import_compiler39.types.isMarkoText(child)) {\n            write2`${child.value}`;\n          } else if (import_compiler39.types.isMarkoPlaceholder(child)) {\n            write2`${callRuntime(\"escapeStyle\", child.value)}`;\n          }\n        }\n      } else {\n        const templateQuasis = [];\n        const templateExpressions = [];\n        let currentQuasi = \"\";\n        let referencePlaceholder;\n        for (const child of tag.node.body.body) {\n          if (import_compiler39.types.isMarkoText(child)) {\n            currentQuasi += child.value;\n          } else if (import_compiler39.types.isMarkoPlaceholder(child)) {\n            referencePlaceholder ||= child;\n            templateQuasis.push(import_compiler39.types.templateElement({ raw: currentQuasi }));\n            templateExpressions.push(child.value);\n            currentQuasi = \"\";\n          }\n        }\n        if (!referencePlaceholder) {\n          write2`${currentQuasi}`;\n        } else {\n          templateQuasis.push(import_compiler39.types.templateElement({ raw: currentQuasi }));\n          addStatement(\n            \"render\",\n            getSection(tag),\n            referencePlaceholder.value.extra?.referencedBindings,\n            import_compiler39.types.expressionStatement(\n              callRuntime(\n                \"textContent\",\n                import_compiler39.types.memberExpression(scopeIdentifier, visitAccessor, true),\n                import_compiler39.types.templateLiteral(templateQuasis, templateExpressions)\n              )\n            )\n          );\n        }\n      }\n      write2`</style>`;\n      if (nodeRef2) {\n        markNode(tag, nodeRef2);\n      }\n      exit2(tag);\n      tag.remove();\n    }\n  },\n  \"@disabled\": \"#html-disabled\",\n  \"@media\": \"#html-media\",\n  \"@nonce\": \"#html-nonce\",\n  \"@type\": \"#html-type\",\n  \"attribute-groups\": [\"html-attributes\"],\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  }\n};\nfunction getUsedAttrs3(tag) {\n  const seen = {};\n  const { attributes } = tag;\n  const maybeStaticAttrs = /* @__PURE__ */ new Set();\n  let spreadExpression;\n  let skipExpression;\n  let spreadProps;\n  let skipProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    const { value } = attr2;\n    if (import_compiler39.types.isMarkoSpreadAttribute(attr2)) {\n      if (!spreadProps) {\n        spreadProps = [];\n      }\n      spreadProps.push(import_compiler39.types.spreadElement(value));\n    } else if (!seen[attr2.name]) {\n      seen[attr2.name] = attr2;\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n      } else {\n        maybeStaticAttrs.add(attr2);\n      }\n    }\n  }\n  const staticAttrs = [...maybeStaticAttrs].reverse();\n  if (spreadProps) {\n    spreadProps.reverse();\n    for (const { name: name2 } of staticAttrs) {\n      (skipProps ||= []).push(toObjectProperty(name2, import_compiler39.types.numericLiteral(1)));\n    }\n    if (skipProps) {\n      skipExpression = import_compiler39.types.objectExpression(skipProps);\n    }\n    spreadExpression = propsToExpression(spreadProps);\n  }\n  return {\n    staticAttrs,\n    spreadExpression,\n    skipExpression\n  };\n}\n\n// src/translator/core/id.ts\nvar import_compiler40 = require(\"@marko/compiler\");\nvar import_babel_utils31 = require(\"@marko/compiler/babel-utils\");\nvar id_default = {\n  analyze(tag) {\n    (0, import_babel_utils31.assertNoArgs)(tag);\n    (0, import_babel_utils31.assertNoParams)(tag);\n    (0, import_babel_utils31.assertNoAttributes)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils31.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    if (!node.var) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `id` tag requires a tag variable.\");\n    }\n    if (!import_compiler40.types.isIdentifier(node.var)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `id` tag cannot be destructured\");\n    }\n    trackVarReferences(tag, 4 /* derived */);\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const id = isOutputHTML() ? callRuntime(\"nextTagId\") : callRuntime(\"nextTagId\", scopeIdentifier);\n      if (isOutputHTML()) {\n        tag.replaceWith(\n          import_compiler40.types.variableDeclaration(\"const\", [import_compiler40.types.variableDeclarator(node.var, id)])\n        );\n      } else {\n        const source = initValue(node.var.extra.binding);\n        addValue(getSection(tag), void 0, source, id);\n        tag.remove();\n      }\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      displayText: \"id/<name>\",\n      description: \"Use to create a unique identifier.\",\n      snippet: \"id/${1:name}\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#id\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/id.d.marko\"\n};\n\n// src/translator/core/if.ts\nvar import_compiler42 = require(\"@marko/compiler\");\nvar import_babel_utils32 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/util/to-first-statement-or-block.ts\nvar import_compiler41 = require(\"@marko/compiler\");\nfunction toFirstStatementOrBlock(body) {\n  if (Array.isArray(body)) {\n    if (body.length === 1) {\n      return body[0];\n    }\n    return import_compiler41.types.blockStatement(body);\n  }\n  return body;\n}\n\n// src/translator/core/if.ts\nvar BRANCHES_LOOKUP = /* @__PURE__ */ new WeakMap();\nvar IfTag = {\n  analyze(tag) {\n    assertValidCondition(tag);\n    if (tag.node.body.attributeTags) return;\n    const bodySection = startSection(tag.get(\"body\"));\n    const [isLast, branches] = getBranches(tag, bodySection);\n    if (isLast) {\n      const [rootTag] = branches[0];\n      const rootExtra = rootTag.node.extra ??= {};\n      const mergeReferenceNodes = [];\n      let singleNodeOptimization = true;\n      for (const [branchTag, branchBodySection] of branches) {\n        if (branchBodySection) {\n          branchBodySection.isBranch = true;\n          branchBodySection.upstreamExpression = rootExtra;\n          if (!(branchBodySection.content === null || branchBodySection.content?.singleChild && branchBodySection.content.startType !== 4 /* Text */)) {\n            singleNodeOptimization = false;\n          }\n        }\n        if (branchTag.node.attributes.length) {\n          mergeReferenceNodes.push(branchTag.node.attributes[0].value);\n        }\n      }\n      const section = getOrCreateSection(tag);\n      mergeReferences(section, rootTag.node, mergeReferenceNodes);\n      bodySection.sectionAccessor = {\n        binding: getOptimizedOnlyChildNodeRef(\n          rootTag,\n          section,\n          branches.length\n        ),\n        prefix: getAccessorPrefix().ConditionalScope\n      };\n      rootExtra.singleNodeOptimization = singleNodeOptimization;\n    }\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (isRoot(tag) && !isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n        flushBefore(tag);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tagBody);\n        const [isLast, branches] = getBranches(tag, bodySection);\n        const [rootTag] = branches[0];\n        const rootExtra = rootTag.node.extra;\n        const singleNodeOptimization = rootExtra.singleNodeOptimization;\n        const branchSources = getSourcesForBranches(branches);\n        const hasHoists = hasHoistsInBranches(branches);\n        const serializeReason = hasHoists || branchSources?.all;\n        if (bodySection) {\n          flushInto(tag);\n          writeHTMLResumeStatements(tagBody);\n        }\n        if (isLast) {\n          const nodeRef2 = getOptimizedOnlyChildNodeRef(rootTag, section);\n          const onlyChildInParentOptimization = isOnlyChildInParent(rootTag);\n          const nextTag = tag.getNextSibling();\n          let statement;\n          if (branchSources?.referenced && onlyChildInParentOptimization) {\n            getParentTag(rootTag).node.extra[kSerializeMarker] = false;\n          }\n          for (let i = branches.length; i--; ) {\n            const [branchTag] = branches[i];\n            const bodyStatements = branchTag.node.body.body;\n            if (serializeReason) {\n              bodyStatements.push(\n                import_compiler42.types.returnStatement(import_compiler42.types.numericLiteral(i))\n              );\n            }\n            const [testAttr] = branchTag.node.attributes;\n            const curStatement = toFirstStatementOrBlock(bodyStatements);\n            if (testAttr) {\n              statement = import_compiler42.types.ifStatement(\n                testAttr.value,\n                curStatement,\n                statement\n              );\n            } else {\n              statement = curStatement;\n            }\n            branchTag.remove();\n          }\n          if (serializeReason) {\n            const conditionSerializeReason = branchSources?.referenced;\n            const cbNode = import_compiler42.types.arrowFunctionExpression(\n              [],\n              import_compiler42.types.blockStatement([statement])\n            );\n            statement = import_compiler42.types.expressionStatement(\n              singleNodeOptimization ? callRuntime(\n                \"resumeSingleNodeConditional\",\n                cbNode,\n                getScopeIdIdentifier(section),\n                getScopeAccessorLiteral(nodeRef2),\n                conditionSerializeReason ? import_compiler42.types.numericLiteral(1) : onlyChildInParentOptimization ? import_compiler42.types.numericLiteral(0) : void 0,\n                onlyChildInParentOptimization && import_compiler42.types.numericLiteral(1)\n              ) : callRuntime(\n                \"resumeConditional\",\n                cbNode,\n                getScopeIdIdentifier(section),\n                getScopeAccessorLiteral(nodeRef2),\n                conditionSerializeReason ? import_compiler42.types.numericLiteral(1) : void 0\n              )\n            );\n          }\n          nextTag.insertBefore(statement);\n        }\n      }\n    },\n    dom: {\n      enter(tag) {\n        if (tag.node.body.attributeTags) return;\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        if (bodySection) {\n          setSectionParentIsOwner(bodySection, true);\n        }\n        if (isRoot(tag) && !isOnlyChildInParent(tag)) {\n          visit(tag, 37 /* Replace */);\n          enterShallow(tag);\n        }\n      },\n      exit(tag) {\n        if (tag.node.body.attributeTags) return;\n        const [isLast, branches] = getBranches(\n          tag,\n          getSectionForBody(tag.get(\"body\"))\n        );\n        if (isLast) {\n          const [rootTag] = branches[0];\n          const section = getSection(rootTag);\n          const rootExtra = branches[0][0].node.extra;\n          const nodeRef2 = getOptimizedOnlyChildNodeRef(rootTag, section);\n          const rendererIdentifiers = [];\n          let expr = import_compiler42.types.numericLiteral(branches.length);\n          for (let i = branches.length; i--; ) {\n            const [branchTag, branchBodySection] = branches[i];\n            const [testAttr] = branchTag.node.attributes;\n            const consequent = import_compiler42.types.numericLiteral(branchBodySection ? i : -1);\n            if (branchBodySection) {\n              rendererIdentifiers.push(import_compiler42.types.identifier(branchBodySection.name));\n              setClosureSignalBuilder(branchTag, (closure, render) => {\n                return callRuntime(\n                  \"conditionalClosure\",\n                  getScopeAccessorLiteral(closure),\n                  getScopeAccessorLiteral(nodeRef2),\n                  import_compiler42.types.numericLiteral(i),\n                  render\n                );\n              });\n            }\n            branchTag.remove();\n            expr = testAttr ? import_compiler42.types.conditionalExpression(testAttr.value, consequent, expr) : consequent;\n          }\n          const signal = getSignal(section, nodeRef2, \"if\");\n          signal.build = () => {\n            return callRuntime(\n              \"conditional\",\n              getScopeAccessorLiteral(nodeRef2),\n              ...rendererIdentifiers.reverse()\n            );\n          };\n          addValue(section, rootExtra.referencedBindings, signal, expr);\n        }\n      }\n    }\n  }),\n  parseOptions: { controlFlow: true },\n  autocomplete: [\n    {\n      snippet: \"if=${1:condition}\",\n      description: \"Use to display content only if the condition is met.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseIfTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      snippet: \"else-if=${1:condition}\",\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nvar ElseTag = {\n  ...IfTag,\n  autocomplete: [\n    {\n      description: \"Use after an <if> or <else-if> tag to display content if those conditions do not match.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#if-else-if-else\"\n    }\n  ]\n};\nfunction assertValidCondition(tag) {\n  (0, import_babel_utils32.assertNoVar)(tag);\n  (0, import_babel_utils32.assertNoArgs)(tag);\n  (0, import_babel_utils32.assertNoParams)(tag);\n  assertHasBody(tag);\n  assertNoSpreadAttrs(tag);\n  switch (getTagName(tag)) {\n    case \"if\":\n      assertHasValueAttribute(tag);\n      break;\n    case \"else-if\":\n      assertHasValueAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n    case \"else\":\n      assertOptionalIfAttribute(tag);\n      assertHasPrecedingCondition(tag);\n      break;\n  }\n}\nfunction assertHasPrecedingCondition(tag) {\n  let prev = tag.getPrevSibling();\n  while (prev.node && prev.isMarkoComment()) prev = prev.getPrevSibling();\n  if (!isConditionTag(prev) || getTagName(prev) !== \"else\" && !prev.node.attributes.length) {\n    throw tag.buildCodeFrameError(\n      `The \\`<${getTagName(tag)}>\\` must have a preceding \\`<if=cond>\\`, \\`<else-if=cond>\\`, or \\`<else if=cond>\\`.`\n    );\n  }\n}\nfunction assertHasBody(tag) {\n  if (!(tag.node.body.body.length || tag.node.attributeTags.length)) {\n    throw tag.get(\"name\").buildCodeFrameError(\n      `The \\`${getTagName(tag)}\\` tag requires body content.`\n    );\n  }\n}\nfunction assertHasValueAttribute(tag) {\n  const { node } = tag;\n  const [valueAttr] = node.attributes;\n  if (!import_compiler42.types.isMarkoAttribute(valueAttr) || !valueAttr.default) {\n    throw tag.get(\"name\").buildCodeFrameError(`The \\`${getTagName(tag)}\\` tag requires a value.`);\n  }\n  if (node.attributes.length > 1) {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports the \\`value\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction assertOptionalIfAttribute(tag) {\n  const { node } = tag;\n  const [ifAttr] = node.attributes;\n  if (node.attributes.length > 1 || ifAttr && ifAttr.name !== \"if\") {\n    const start = node.attributes[1].loc?.start;\n    const end = node.attributes[node.attributes.length - 1].loc?.end;\n    const msg = `The \\`${getTagName(tag)}\\` tag only supports an \\`if=\\` attribute.`;\n    if (start == null || end == null) {\n      throw tag.get(\"name\").buildCodeFrameError(msg);\n    } else {\n      throw tag.hub.buildError(\n        { loc: { start, end } },\n        msg,\n        Error\n      );\n    }\n  }\n}\nfunction getBranches(tag, bodySection) {\n  const branches = BRANCHES_LOOKUP.get(tag) ?? [];\n  let nextTag = tag.getNextSibling();\n  while (nextTag.isMarkoComment()) nextTag = nextTag.getNextSibling();\n  const isLast = !(isCoreTagName(nextTag, \"else\") || isCoreTagName(nextTag, \"else-if\"));\n  branches.push([tag, bodySection]);\n  if (!isLast) {\n    BRANCHES_LOOKUP.set(nextTag, branches);\n  }\n  return [isLast, branches];\n}\nfunction hasHoistsInBranches(branches) {\n  for (const [, section] of branches) {\n    if (section && isSectionWithHoists(section)) return true;\n  }\n}\nfunction getSourcesForBranches(branches) {\n  if (branches.length === 1) {\n    return getDynamicSourcesForSection(branches[0][1]);\n  }\n  const branchSections = [];\n  for (const [, branchSection] of branches) {\n    branchSections.push(branchSection);\n  }\n  return getDynamicSourcesForSections(branchSections);\n}\nfunction isRoot(tag) {\n  return isCoreTagName(tag, \"if\");\n}\n\n// src/translator/core/import.ts\nvar import_babel_utils33 = require(\"@marko/compiler/babel-utils\");\nvar import_default = {\n  parse(tag) {\n    const { node } = tag;\n    tag.replaceWith(\n      (0, import_babel_utils33.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]\n    );\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: 'import <scope> from \"<path>\"',\n      description: \"Use to import external modules, follows the same syntax as JavaScript imports.\",\n      snippet: 'import ${2} from \"${1:path}\"',\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#importing-external-files\"\n    }\n  ]\n};\n\n// src/translator/core/let.ts\nvar import_compiler43 = require(\"@marko/compiler\");\nvar import_babel_utils34 = require(\"@marko/compiler/babel-utils\");\nvar let_default = {\n  analyze(tag) {\n    const { node } = tag;\n    const tagVar = node.var;\n    let valueAttr;\n    let valueChangeAttr;\n    for (const attr2 of node.attributes) {\n      if (import_compiler43.types.isMarkoAttribute(attr2)) {\n        if (attr2.name === \"value\") {\n          valueAttr = attr2;\n        } else if (attr2.name === \"valueChange\") {\n          valueChangeAttr = attr2;\n        } else {\n          const start = attr2.loc?.start;\n          const end = attr2.loc?.end;\n          const msg = \"The `let` tag only supports the `value` attribute and its change handler.\";\n          if (start == null || end == null) {\n            throw tag.get(\"name\").buildCodeFrameError(msg);\n          } else {\n            throw tag.hub.buildError(\n              { loc: { start, end } },\n              msg,\n              Error\n            );\n          }\n        }\n      }\n    }\n    (0, import_babel_utils34.assertNoArgs)(tag);\n    (0, import_babel_utils34.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    assertNoSpreadAttrs(tag);\n    if (!tagVar) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `let` tag requires a tag variable.\");\n    }\n    if (!import_compiler43.types.isIdentifier(tagVar)) {\n      throw tag.get(\"var\").buildCodeFrameError(\"The `let` tag variable cannot be destructured.\");\n    }\n    if (valueChangeAttr && (0, import_babel_utils34.computeNode)(valueChangeAttr.value)) {\n      throw tag.get(\"attributes\").find((attr2) => attr2.node === valueChangeAttr).get(\"value\").buildCodeFrameError(\n        \"The `let` tag `valueChange` attribute must be a function.\"\n      );\n    }\n    mergeReferences(getOrCreateSection(tag), tag.node, [\n      valueAttr?.value,\n      valueChangeAttr?.value\n    ]);\n    trackVarReferences(tag, 1 /* let */, void 0, tag.node.extra);\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const tagVar = node.var;\n      const valueAttr = node.attributes.find(\n        (attr2) => import_compiler43.types.isMarkoAttribute(attr2) && (attr2.default || attr2.name === \"value\")\n      ) ?? import_compiler43.types.markoAttribute(\"value\", import_compiler43.types.identifier(\"undefined\"));\n      const valueChangeAttr = node.attributes.find(\n        (attr2) => import_compiler43.types.isMarkoAttribute(attr2) && attr2.name === \"valueChange\"\n      );\n      const section = getSection(tag);\n      const binding = tagVar.extra.binding;\n      if (isOutputDOM()) {\n        const signal = initValue(binding, \"state\");\n        const referencedBindings = tag.node.extra.referencedBindings;\n        addValue(section, referencedBindings, signal, valueAttr.value);\n        if (valueChangeAttr) {\n          signal.extraArgs = [valueChangeAttr.value];\n        }\n        signal.buildAssignment = (valueSection, value) => {\n          const scope = getScopeExpression(valueSection, signal.section);\n          return import_compiler43.types.callExpression(signal.identifier, [scope, value]);\n        };\n      } else {\n        translateVar(tag, valueAttr.value, \"let\");\n        if (valueChangeAttr) {\n          setSerializedProperty(\n            section,\n            getAccessorPrefix().TagVariableChange + getScopeAccessor(binding),\n            valueChangeAttr.value,\n            true\n            // TODO: could be based on if there are actually assignments.\n          );\n        }\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a mutable binding.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#let\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/let.d.marko\"\n};\n\n// src/translator/core/lifecycle.ts\nvar import_compiler44 = require(\"@marko/compiler\");\nvar import_babel_utils35 = require(\"@marko/compiler/babel-utils\");\nvar kRef = Symbol(\"lifecycle attrs reference\");\nvar lifecycle_default = {\n  analyze(tag) {\n    (0, import_babel_utils35.assertNoArgs)(tag);\n    (0, import_babel_utils35.assertNoVar)(tag);\n    (0, import_babel_utils35.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    const { node } = tag;\n    const tagExtra = node.extra ??= {};\n    const section = getOrCreateSection(tag);\n    tagExtra[kRef] = createBinding(\n      generateUid(\"lifecycle\"),\n      4 /* derived */,\n      section,\n      void 0,\n      tagExtra\n    );\n    if (node.attributes.length === 0) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `lifecycle` tag requires at least one attribute.\"\n      );\n    }\n    for (const attr2 of node.attributes) {\n      if (import_compiler44.types.isMarkoSpreadAttribute(attr2)) {\n        throw tag.get(\"name\").buildCodeFrameError(\n          \"The `lifecycle` tag does not support `...spread` attributes.\"\n        );\n      }\n      (attr2.value.extra ??= {}).isEffect = true;\n    }\n    ((0, import_babel_utils35.getProgram)().node.extra ??= {}).isInteractive = true;\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const section = getSection(tag);\n      const tagExtra = node.extra;\n      const { referencedBindings } = tagExtra;\n      const lifecycleAttrsRef = tagExtra[kRef];\n      if (isOutputDOM()) {\n        const translatedAttrs = translateAttrs(tag);\n        translatedAttrs.statements.push(\n          import_compiler44.types.expressionStatement(\n            callRuntime(\n              \"lifecycle\",\n              scopeIdentifier,\n              getScopeAccessorLiteral(lifecycleAttrsRef),\n              propsToExpression(translatedAttrs.properties)\n            )\n          )\n        );\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          translatedAttrs.statements\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#effect\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/lifecycle.d.marko\"\n};\n\n// src/translator/core/log.ts\nvar import_compiler45 = require(\"@marko/compiler\");\nvar import_babel_utils36 = require(\"@marko/compiler/babel-utils\");\nvar log_default = {\n  analyze(tag) {\n    const [valueAttr] = tag.node.attributes;\n    (0, import_babel_utils36.assertNoArgs)(tag);\n    (0, import_babel_utils36.assertNoVar)(tag);\n    (0, import_babel_utils36.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    if (!valueAttr) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `log` tag requires a value.\");\n    }\n    if (tag.node.attributes.length > 1 || !import_compiler45.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== \"value\") {\n      throw tag.get(\"name\").buildCodeFrameError(\n        \"The `log` tag only supports the `value` attribute.\"\n      );\n    }\n  },\n  translate: {\n    exit(tag) {\n      const section = getSection(tag);\n      const [valueAttr] = tag.node.attributes;\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      const statement = import_compiler45.types.expressionStatement(\n        import_compiler45.types.callExpression(\n          import_compiler45.types.memberExpression(import_compiler45.types.identifier(\"console\"), import_compiler45.types.identifier(\"log\")),\n          [value]\n        )\n      );\n      if (isOutputHTML()) {\n        tag.insertBefore(statement);\n      } else {\n        addStatement(\"render\", section, referencedBindings, statement);\n      }\n      tag.remove();\n    }\n  },\n  parseOptions: {\n    openTagOnly: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to log a value to the console.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#log\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/log.d.marko\"\n};\n\n// src/translator/core/script.ts\nvar import_compiler46 = require(\"@marko/compiler\");\nvar import_babel_utils37 = require(\"@marko/compiler/babel-utils\");\nvar htmlScriptTagAlternateMsg = \" For a native html `script` tag use the `html-script` core tag instead.\";\nvar script_default = {\n  parse(tag) {\n    const { node } = tag;\n    const { body } = node.body;\n    if (body.length) {\n      let code = \"\";\n      for (const child of body) {\n        if (child.type !== \"MarkoText\") {\n          throw tag.hub.file.hub.buildError(\n            child,\n            \"Unexpected content in `script` tag. Only javascript and typescript is supported.\" + htmlScriptTagAlternateMsg,\n            SyntaxError\n          );\n        }\n        code += child.value;\n      }\n      const start = body[0]?.start;\n      const end = body[body.length - 1]?.end;\n      const bodyStatements = (0, import_babel_utils37.parseStatements)(tag.hub.file, code, start, end);\n      const valueFn = import_compiler46.types.arrowFunctionExpression(\n        [],\n        import_compiler46.types.blockStatement(bodyStatements),\n        traverseContains(bodyStatements, isAwaitExpression)\n      );\n      node.attributes.push(import_compiler46.types.markoAttribute(\"value\", valueFn));\n      node.body.body = [];\n    }\n  },\n  analyze(tag) {\n    const { node } = tag;\n    (0, import_babel_utils37.assertNoArgs)(tag);\n    (0, import_babel_utils37.assertNoParams)(tag);\n    assertNoBodyContent(tag);\n    (0, import_babel_utils37.assertNoAttributeTags)(tag);\n    if (node.var) {\n      throw tag.hub.buildError(\n        node.var,\n        \"The `script` tag does not support a tag variable reference.\" + htmlScriptTagAlternateMsg\n      );\n    }\n    let seenValueAttr = false;\n    for (const attr2 of node.attributes) {\n      if (attr2.type === \"MarkoAttribute\" && attr2.name === \"value\") {\n        if (seenValueAttr) {\n          throw tag.hub.buildError(attr2, \"Invalid duplicate value attribute.\");\n        }\n        seenValueAttr = true;\n        (attr2.value.extra ??= {}).isEffect = true;\n        ((0, import_babel_utils37.getProgram)().node.extra ??= {}).isInteractive = true;\n      } else {\n        throw tag.hub.buildError(\n          attr2,\n          \"The `script` tag does not support html attributes.\" + htmlScriptTagAlternateMsg\n        );\n      }\n    }\n    if (!seenValueAttr) {\n      dropReferences(getAllTagReferenceNodes(node));\n    }\n  },\n  translate: {\n    exit(tag) {\n      const { node } = tag;\n      const [valueAttr] = node.attributes;\n      if (!valueAttr) {\n        tag.remove();\n        return;\n      }\n      const section = getSection(tag);\n      const { value } = valueAttr;\n      const referencedBindings = value.extra?.referencedBindings;\n      if (isOutputDOM()) {\n        const { value: value2 } = valueAttr;\n        const isFunction2 = import_compiler46.types.isFunctionExpression(value2) || import_compiler46.types.isArrowFunctionExpression(value2);\n        let inlineBody = null;\n        if (isFunction2 && !(value2.async || value2.generator)) {\n          if (import_compiler46.types.isBlockStatement(value2.body)) {\n            let hasDeclaration = false;\n            for (const child of value2.body.body) {\n              if (import_compiler46.types.isDeclaration(child)) {\n                hasDeclaration = true;\n                break;\n              }\n            }\n            inlineBody = hasDeclaration ? value2.body : value2.body.body;\n          } else {\n            inlineBody = import_compiler46.types.expressionStatement(value2.body);\n          }\n        }\n        addStatement(\n          \"effect\",\n          section,\n          referencedBindings,\n          inlineBody || import_compiler46.types.expressionStatement(\n            import_compiler46.types.callExpression(value2, isFunction2 ? [] : [scopeIdentifier])\n          )\n        );\n      } else {\n        addHTMLEffectCall(section, referencedBindings);\n      }\n      tag.remove();\n    }\n  },\n  html: false,\n  parseOptions: {\n    text: true,\n    preserveWhitespace: true\n  },\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Use to create a side effects.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#script\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/script.d.marko\"\n};\nfunction isAwaitExpression(node) {\n  switch (node.type) {\n    case \"ForOfStatement\":\n      return node.await;\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ObjectMethod\":\n    case \"ClassPrivateMethod\":\n      return skip;\n    case \"AwaitExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// src/translator/core/server.ts\nvar import_compiler47 = require(\"@marko/compiler\");\nvar import_babel_utils38 = require(\"@marko/compiler/babel-utils\");\nvar server_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^server\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils38.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler47.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler47.types.markoScriptlet(body, true, \"server\"));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"server <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded on the server.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#server-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/static.ts\nvar import_compiler48 = require(\"@marko/compiler\");\nvar import_babel_utils39 = require(\"@marko/compiler/babel-utils\");\nvar static_default = {\n  parse(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const rawValue = node.rawValue;\n    const code = rawValue.replace(/^static\\s*/, \"\").trim();\n    const start = node.name.start + (rawValue.length - code.length);\n    let body = (0, import_babel_utils39.parseStatements)(file, code, start, start + code.length);\n    if (body.length === 1 && import_compiler48.types.isBlockStatement(body[0])) {\n      body = body[0].body;\n    }\n    tag.replaceWith(import_compiler48.types.markoScriptlet(body, true));\n  },\n  parseOptions: {\n    statement: true,\n    rawOpenTag: true\n  },\n  autocomplete: [\n    {\n      displayText: \"static <statement>\",\n      description: \"A JavaScript statement which is only evaluated once your template is loaded.\",\n      descriptionMoreURL: \"https://markojs.com/docs/syntax/#static-javascript\"\n    }\n  ]\n};\n\n// src/translator/core/style.ts\nvar import_compiler49 = require(\"@marko/compiler\");\nvar import_babel_utils40 = require(\"@marko/compiler/babel-utils\");\nvar import_magic_string = __toESM(require(\"magic-string\"));\nvar import_path3 = __toESM(require(\"path\"));\nvar STYLE_EXT_REG = /^style((?:\\.[a-zA-Z0-9$_-]+)+)?/;\nvar htmlStyleTagAlternateMsg = \" For a native html `style` tag use the `html-style` core tag instead.\";\nvar style_default = {\n  analyze(tag) {\n    (0, import_babel_utils40.assertNoArgs)(tag);\n    (0, import_babel_utils40.assertNoParams)(tag);\n    (0, import_babel_utils40.assertNoAttributeTags)(tag);\n    const { node } = tag;\n    const ext = STYLE_EXT_REG.exec(node.rawValue || \"\")?.[1]?.slice(1);\n    for (const attr2 of node.attributes) {\n      if (attr2.start == null && attr2.type === \"MarkoAttribute\" && attr2.name === \"class\" && attr2.value.type === \"StringLiteral\" && attr2.value.value === ext) {\n        continue;\n      }\n      throw tag.hub.buildError(\n        attr2.value,\n        \"The `style` does not support html attributes.\" + htmlStyleTagAlternateMsg\n      );\n    }\n    for (const child of node.body.body) {\n      if (child.type !== \"MarkoText\") {\n        throw tag.hub.buildError(\n          child,\n          \"The `style` tag currently only supports static content.\" + htmlStyleTagAlternateMsg\n        );\n      }\n    }\n    if (node.body.body.length > 1) {\n      throw tag.hub.buildError(\n        node.name,\n        \"The `style` tag currently only supports static content.\" + htmlStyleTagAlternateMsg\n      );\n    }\n  },\n  translate(tag) {\n    const {\n      node,\n      hub: { file }\n    } = tag;\n    const { filename, sourceMaps } = file.opts;\n    let ext = STYLE_EXT_REG.exec(node.rawValue || \"\")?.[1] || \".css\";\n    if (node.var && !/\\.module\\./.test(ext)) {\n      ext = \".module\" + ext;\n    }\n    const markoText = node.body.body[0];\n    const { resolveVirtualDependency } = getMarkoOpts();\n    const start = (0, import_babel_utils40.getStart)(file, markoText);\n    const end = (0, import_babel_utils40.getEnd)(file, markoText);\n    let code = markoText.value;\n    let map2;\n    if (resolveVirtualDependency && sourceMaps && start !== null && end !== null) {\n      const magicString = new import_magic_string.default(file.code, { filename });\n      magicString.remove(0, start);\n      magicString.remove(end, file.code.length);\n      map2 = magicString.generateMap({\n        source: filename,\n        includeContent: true\n      });\n      if (sourceMaps === \"inline\" || sourceMaps === \"both\") {\n        code += `\n/*# sourceMappingURL=${map2.toUrl()}*/`;\n        if (sourceMaps === \"inline\") {\n          map2 = void 0;\n        }\n      }\n    }\n    const importPath = resolveVirtualDependency?.(filename, {\n      virtualPath: `./${import_path3.default.basename(filename) + ext}`,\n      code,\n      map: map2\n    });\n    if (importPath) {\n      if (!node.var) {\n        (0, import_babel_utils40.getProgram)().node.body.push(\n          import_compiler49.types.importDeclaration([], import_compiler49.types.stringLiteral(importPath))\n        );\n      } else if (import_compiler49.types.isIdentifier(node.var)) {\n        (0, import_babel_utils40.getProgram)().node.body.push(\n          import_compiler49.types.importDeclaration(\n            [import_compiler49.types.importDefaultSpecifier(node.var)],\n            import_compiler49.types.stringLiteral(importPath)\n          )\n        );\n      } else {\n        (0, import_babel_utils40.getProgram)().node.body.push(\n          import_compiler49.types.variableDeclaration(\"const\", [\n            import_compiler49.types.variableDeclarator(\n              node.var,\n              (0, import_babel_utils40.importDefault)(file, importPath, \"style\")\n            )\n          ])\n        );\n      }\n    }\n    tag.remove();\n  },\n  parseOptions: {\n    html: false,\n    text: true,\n    rawOpenTag: true,\n    preserveWhitespace: true\n  },\n  attributes: {}\n};\n\n// src/translator/core/try.ts\nvar import_compiler50 = require(\"@marko/compiler\");\nvar import_babel_utils41 = require(\"@marko/compiler/babel-utils\");\nvar kDOMBinding2 = Symbol(\"try tag dom binding\");\nvar try_default = {\n  analyze(tag) {\n    (0, import_babel_utils41.assertNoVar)(tag);\n    (0, import_babel_utils41.assertNoArgs)(tag);\n    (0, import_babel_utils41.assertNoParams)(tag);\n    (0, import_babel_utils41.assertNoAttributes)(tag);\n    assertNoSpreadAttrs(tag);\n    analyzeAttributeTags(tag);\n    const { node } = tag;\n    const section = getOrCreateSection(tag);\n    const tagExtra = tag.node.extra ??= {};\n    const tagBody = tag.get(\"body\");\n    tagExtra[kDOMBinding2] = createBinding(\n      \"#text\",\n      0 /* dom */,\n      section,\n      void 0,\n      tagExtra\n    );\n    if (!node.body.body.length) {\n      throw tag.get(\"name\").buildCodeFrameError(\"The `try` tag requires body content.\");\n    }\n    startSection(tagBody);\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n  },\n  translate: translateByTarget({\n    html: {\n      enter(tag) {\n        if (!getSectionForBody(tag.get(\"body\"))) {\n          tag.remove();\n          return;\n        }\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        setSectionParentIsOwner(bodySection, true);\n        flushBefore(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const section = getSection(tag);\n        const tagExtra = node.extra;\n        const tagBody = tag.get(\"body\");\n        const translatedAttrs = translateAttrs(tag);\n        const nodeRef2 = tagExtra[kDOMBinding2];\n        const contentProp = getTranslatedBodyContentProperty(\n          translatedAttrs.properties\n        );\n        if (contentProp) {\n          translatedAttrs.properties.splice(\n            translatedAttrs.properties.indexOf(contentProp),\n            1\n          );\n        }\n        flushInto(tag);\n        writeHTMLResumeStatements(tagBody);\n        tag.insertBefore(translatedAttrs.statements);\n        tag.replaceWith(\n          import_compiler50.types.expressionStatement(\n            callRuntime(\n              \"tryContent\",\n              getScopeIdIdentifier(section),\n              getScopeAccessorLiteral(nodeRef2),\n              contentProp?.value,\n              propsToExpression(translatedAttrs.properties)\n            )\n          )\n        )[0].skip();\n      }\n    },\n    dom: {\n      enter(tag) {\n        const tagBody = tag.get(\"body\");\n        const bodySection = getSectionForBody(tagBody);\n        setSectionParentIsOwner(bodySection, true);\n        visit(tag, 37 /* Replace */);\n        enterShallow(tag);\n      },\n      exit(tag) {\n        const { node } = tag;\n        const tagExtra = node.extra;\n        const nodeRef2 = tagExtra[kDOMBinding2];\n        const referencedBindings = tagExtra.referencedBindings;\n        const translatedAttrs = translateAttrs(tag);\n        const contentProp = getTranslatedBodyContentProperty(\n          translatedAttrs.properties\n        );\n        if (contentProp) {\n          translatedAttrs.properties.splice(\n            translatedAttrs.properties.indexOf(contentProp),\n            1\n          );\n        }\n        const section = getSection(tag);\n        const bodySection = getSectionForBody(tag.get(\"body\"));\n        const signal = getSignal(section, nodeRef2, \"try\");\n        signal.build = () => {\n          return callRuntime(\n            \"createTry\",\n            getScopeAccessorLiteral(nodeRef2),\n            import_compiler50.types.identifier(bodySection.name)\n          );\n        };\n        if (translatedAttrs.statements.length) {\n          addStatement(\n            \"render\",\n            section,\n            referencedBindings,\n            translatedAttrs.statements\n          );\n        }\n        (0, import_babel_utils41.getProgram)().node.body.push(\n          import_compiler50.types.expressionStatement(callRuntime(\"enableCatch\"))\n        );\n        addValue(\n          section,\n          referencedBindings,\n          signal,\n          propsToExpression(translatedAttrs.properties)\n        );\n        signal.hasDownstreamIntersections = () => true;\n        tag.remove();\n      }\n    }\n  }),\n  attributes: {},\n  autocomplete: [\n    {\n      description: \"Used to capture errors and display placeholders for nested content.\",\n      descriptionMoreURL: \"https://markojs.com/docs/core-tags/#try\"\n    }\n  ],\n  types: runtime_info_default.name + \"/tag-types/try.d.marko\"\n};\n\n// src/translator/core/index.ts\nvar core_default = {\n  taglibId: runtime_info_default.taglibId,\n  \"<attrs>\": attrs_default,\n  \"<await>\": await_default,\n  \"<client>\": client_default,\n  \"<const>\": const_default,\n  \"<debug>\": debug_default,\n  \"<define>\": define_default,\n  \"<effect>\": effect_default,\n  \"<else-if>\": ElseIfTag,\n  \"<else>\": ElseTag,\n  \"<export>\": export_default,\n  \"<for>\": for_default,\n  \"<html-comment>\": html_comment_default,\n  \"<html-script>\": html_script_default,\n  \"<html-style>\": html_style_default,\n  \"<id>\": id_default,\n  \"<if>\": IfTag,\n  \"<import>\": import_default,\n  \"<let>\": let_default,\n  \"<lifecycle>\": lifecycle_default,\n  \"<log>\": log_default,\n  \"<return>\": return_default,\n  \"<script>\": script_default,\n  \"<server>\": server_default,\n  \"<static>\": static_default,\n  \"<style>\": style_default,\n  \"<try>\": try_default\n};\n\n// src/translator/visitors/cdata.ts\nvar cdata_default = {\n  translate: {\n    enter(cdata) {\n      throw cdata.buildCodeFrameError(\n        \"CDATA sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/translator/visitors/comment.ts\nvar comment_default = {\n  translate: {\n    exit(comment) {\n      comment.remove();\n    }\n  }\n};\n\n// src/translator/visitors/declaration.ts\nvar declaration_default = {\n  translate: {\n    enter(decl) {\n      throw decl.buildCodeFrameError(\n        \"XML declarations sections are not supported in Marko.\"\n      );\n    }\n  }\n};\n\n// src/translator/visitors/document-type.ts\nvar document_type_default = {\n  translate: {\n    exit(documentType) {\n      if (isOutputHTML()) {\n        writeTo(documentType)`<!${documentType.node.value}>`;\n      }\n      documentType.remove();\n    }\n  }\n};\n\n// src/translator/visitors/function.ts\nvar import_compiler51 = require(\"@marko/compiler\");\nvar import_babel_utils42 = require(\"@marko/compiler/babel-utils\");\nvar function_default = {\n  analyze(fn) {\n    if (fn !== getFnRoot(fn)) {\n      return;\n    }\n    const markoRoot = getMarkoRoot(fn);\n    if (markoRoot && (markoRoot.isMarkoPlaceholder() || markoRoot.isMarkoScriptlet() && markoRoot.node.target === \"server\")) {\n      return;\n    }\n    if (isMarkoAttribute(markoRoot) && ((0, import_babel_utils42.isNativeTag)(markoRoot.parentPath) && /^on[A-Z-]/.test(markoRoot.node.name) || isCoreTagName(markoRoot.parentPath, \"script\") || isCoreTagName(markoRoot.parentPath, \"lifecycle\") || isCoreTagName(markoRoot.parentPath, \"for\"))) {\n      return;\n    }\n    const { node } = fn;\n    const section = getSection(fn);\n    const extra = node.extra ??= {};\n    const {\n      markoOpts,\n      opts: { filename }\n    } = (0, import_babel_utils42.getFile)();\n    const name2 = extra.name = generateUid(\n      fn.node.id?.name || (isMarkoAttribute(markoRoot) ? markoRoot.node.default ? import_compiler51.types.toIdentifier(\n        markoRoot.parentPath.has(\"var\") ? markoRoot.parentPath.get(\"var\") : markoRoot.parentPath.get(\"name\")\n      ) : markoRoot.node.name : import_compiler51.types.isVariableDeclarator(fn.parent) && import_compiler51.types.isIdentifier(fn.parent.id) ? fn.parent.id.name : import_compiler51.types.isObjectMethod(node) && import_compiler51.types.isIdentifier(node.key) ? node.key.name : \"anonymous\")\n    );\n    extra.section = section;\n    extra.registerId = (0, import_babel_utils42.getTemplateId)(\n      markoOpts,\n      filename,\n      `${section.id}/${name2.slice(1)}`\n    );\n  }\n};\nfunction isMarkoAttribute(path5) {\n  return path5 ? path5.isMarkoAttribute() : false;\n}\n\n// src/translator/visitors/import-declaration.ts\nvar import_babel_utils43 = require(\"@marko/compiler/babel-utils\");\nvar import_declaration_default = {\n  analyze(importDecl) {\n    const { node } = importDecl;\n    const { source } = node;\n    const { value } = source;\n    const tagImport = (0, import_babel_utils43.resolveTagImport)(importDecl, value);\n    if (tagImport) {\n      node.extra ??= {};\n      node.extra.tagImport = tagImport;\n      const tags = importDecl.hub.file.metadata.marko.tags;\n      if (!tags.includes(tagImport)) {\n        tags.push(tagImport);\n      }\n    }\n  },\n  translate: {\n    exit(importDecl) {\n      const { node } = importDecl;\n      const { extra } = node;\n      const tagImport = extra?.tagImport;\n      if (tagImport) {\n        node.source.value = tagImport;\n      }\n    }\n  }\n};\n\n// src/translator/visitors/placeholder.ts\nvar import_compiler53 = require(\"@marko/compiler\");\n\n// src/translator/util/is-non-html-text.ts\nvar import_compiler52 = require(\"@marko/compiler\");\nfunction isNonHTMLText(placeholder) {\n  const parentTag = placeholder.parentPath.isMarkoTagBody() && placeholder.parentPath.parentPath;\n  if (parentTag && isCoreTag(parentTag)) {\n    switch (parentTag.node.name.value) {\n      case \"html-comment\":\n      case \"html-script\":\n      case \"html-style\":\n        return true;\n    }\n  }\n  return false;\n}\n\n// src/translator/visitors/placeholder.ts\nvar kBinding = Symbol(\"placeholder node binding\");\nvar kSiblingText = Symbol(\"placeholder has sibling text\");\nvar placeholder_default = {\n  analyze(placeholder) {\n    if (isNonHTMLText(placeholder)) return;\n    const { node } = placeholder;\n    const { confident, computed } = evaluate(node.value);\n    if (!(confident && (node.escape || isVoid2(computed)))) {\n      (node.extra ??= {})[kBinding] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        getOrCreateSection(placeholder),\n        void 0,\n        node.value.extra\n      );\n      analyzeSiblingText(placeholder);\n    }\n  },\n  translate: {\n    exit(placeholder) {\n      if (isNonHTMLText(placeholder)) return;\n      const { node } = placeholder;\n      const { value } = node;\n      const valueExtra = evaluate(value);\n      const { confident, computed } = valueExtra;\n      if (confident && isVoid2(computed)) {\n        placeholder.remove();\n        return;\n      }\n      const isHTML = isOutputHTML();\n      const write2 = writeTo(placeholder);\n      const extra = node.extra || {};\n      const nodeBinding = extra[kBinding];\n      const canWriteHTML = isHTML || confident && node.escape;\n      const method = canWriteHTML ? node.escape ? \"escapeXML\" : \"toString\" : node.escape ? \"data\" : \"html\";\n      const serializeReason = getDynamicSourcesForExtra(valueExtra);\n      const siblingText = extra[kSiblingText];\n      if (confident && canWriteHTML) {\n        write2`${getHTMLRuntime()[method](computed)}`;\n      } else {\n        if (siblingText === 1 /* Before */) {\n          if (isHTML && serializeReason) {\n            write2`<!>`;\n          }\n          visit(placeholder, 37 /* Replace */);\n        } else if (siblingText === 2 /* After */) {\n          visit(placeholder, 37 /* Replace */);\n        } else {\n          if (!isHTML) write2` `;\n          visit(placeholder, 32 /* Get */);\n        }\n        if (isHTML) {\n          write2`${callRuntime(method, value)}`;\n          if (serializeReason) {\n            markNode(placeholder, nodeBinding);\n          }\n        } else {\n          addStatement(\n            \"render\",\n            getSection(placeholder),\n            valueExtra.referencedBindings,\n            import_compiler53.types.expressionStatement(\n              method === \"data\" ? callRuntime(\n                \"data\",\n                import_compiler53.types.memberExpression(\n                  scopeIdentifier,\n                  getScopeAccessorLiteral(nodeBinding),\n                  true\n                ),\n                value\n              ) : callRuntime(\n                \"html\",\n                scopeIdentifier,\n                value,\n                getScopeAccessorLiteral(nodeBinding)\n              )\n            )\n          );\n        }\n      }\n      enterShallow(placeholder);\n      placeholder.remove();\n    }\n  }\n};\nfunction analyzeSiblingText(placeholder) {\n  const placeholderExtra = placeholder.node.extra;\n  let prev = placeholder.getPrevSibling();\n  while (prev.node) {\n    const contentType = getNodeContentType(\n      prev,\n      \"endType\"\n    );\n    if (contentType === null) {\n      prev = prev.getPrevSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 1 /* Before */;\n    } else {\n      break;\n    }\n  }\n  if (!prev.node && import_compiler53.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 1 /* Before */;\n  }\n  let next = placeholder.getNextSibling();\n  while (next.node) {\n    const contentType = getNodeContentType(\n      next,\n      \"startType\"\n    );\n    if (contentType === null) {\n      next = next.getNextSibling();\n    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {\n      return placeholderExtra[kSiblingText] = 2 /* After */;\n    } else {\n      break;\n    }\n  }\n  if (!next.node && import_compiler53.types.isProgram(placeholder.parentPath)) {\n    return placeholderExtra[kSiblingText] = 2 /* After */;\n  }\n  return placeholderExtra[kSiblingText] = 0 /* None */;\n}\nfunction isVoid2(value) {\n  return value == null || value === false;\n}\n\n// src/translator/visitors/referenced-identifier.ts\nvar import_compiler54 = require(\"@marko/compiler\");\nvar abortIdsByExpressionForSection = /* @__PURE__ */ new WeakMap();\nvar referenced_identifier_default = {\n  migrate(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    switch (name2) {\n      case \"out\":\n        if (import_compiler54.types.isMemberExpression(identifier.parent) && import_compiler54.types.isIdentifier(identifier.parent.property) && identifier.parent.property.name === \"global\") {\n          identifier.parentPath.replaceWith(import_compiler54.types.identifier(\"$global\"));\n        } else {\n          throw identifier.buildCodeFrameError(\n            \"Only `out.global` is supported for compatibility.\"\n          );\n        }\n        break;\n    }\n  },\n  analyze(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    if (name2 === \"$global\") {\n      setReferencesScope(identifier);\n    } else if (name2 === \"$signal\") {\n      const section = getOrCreateSection(identifier);\n      section.hasAbortSignal = true;\n      setReferencesScope(identifier);\n    }\n  },\n  translate(identifier) {\n    const { name: name2 } = identifier.node;\n    if (identifier.scope.hasBinding(name2)) return;\n    switch (name2) {\n      case \"$global\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler54.types.callExpression(importRuntime(\"$global\"), [])\n          );\n        } else {\n          identifier.replaceWith(\n            import_compiler54.types.memberExpression(scopeIdentifier, import_compiler54.types.identifier(\"$global\"))\n          );\n        }\n        break;\n      case \"$signal\":\n        if (isOutputHTML()) {\n          identifier.replaceWith(\n            import_compiler54.types.callExpression(\n              import_compiler54.types.arrowFunctionExpression(\n                [],\n                import_compiler54.types.blockStatement([\n                  import_compiler54.types.throwStatement(\n                    import_compiler54.types.newExpression(import_compiler54.types.identifier(\"Error\"), [\n                      import_compiler54.types.stringLiteral(\"Cannot use $signal in a server render.\")\n                    ])\n                  )\n                ])\n              ),\n              []\n            )\n          );\n        } else {\n          const section = getSection(identifier);\n          const exprRoot = getExprRoot(identifier);\n          let abortIdsByExpression = abortIdsByExpressionForSection.get(section);\n          let exprId;\n          if (abortIdsByExpression) {\n            exprId = abortIdsByExpression.get(exprRoot);\n          } else {\n            abortIdsByExpression = /* @__PURE__ */ new Map();\n            abortIdsByExpressionForSection.set(section, abortIdsByExpression);\n          }\n          if (!exprId) {\n            exprId = abortIdsByExpression.size;\n            abortIdsByExpression.set(exprRoot, exprId);\n            addStatement(\n              \"render\",\n              section,\n              exprRoot.node.extra?.referencedBindings,\n              import_compiler54.types.expressionStatement(\n                import_compiler54.types.callExpression(importRuntime(\"resetAbortSignal\"), [\n                  scopeIdentifier,\n                  import_compiler54.types.numericLiteral(exprId)\n                ])\n              ),\n              false\n            );\n          }\n          identifier.replaceWith(\n            import_compiler54.types.callExpression(importRuntime(\"getAbortSignal\"), [\n              scopeIdentifier,\n              import_compiler54.types.numericLiteral(exprId)\n            ])\n          );\n        }\n    }\n  }\n};\n\n// src/translator/visitors/scriptlet.ts\nvar scriptlet_default = {\n  analyze(scriptlet) {\n    if (!scriptlet.node.static) {\n      throw scriptlet.buildCodeFrameError(\n        \"Scriptlets are not supported when using the tags api.\"\n      );\n    }\n    mergeReferences(\n      getOrCreateSection(scriptlet),\n      scriptlet.node,\n      scriptlet.node.body\n    );\n  },\n  translate: {\n    exit(scriptlet) {\n      const { node } = scriptlet;\n      const isHTML = isOutputHTML();\n      if (node.target && node.target !== (isHTML ? \"server\" : \"client\")) {\n        scriptlet.remove();\n        return;\n      }\n      if (isHTML) {\n      } else {\n        traverseReplace(node, \"body\", replaceRegisteredFunctionNode);\n        scriptlet.replaceWithMultiple(node.body);\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/index.ts\nvar import_compiler58 = require(\"@marko/compiler\");\nvar import_babel_utils47 = require(\"@marko/compiler/babel-utils\");\n\n// src/translator/visitors/tag/attribute-tag.ts\nvar import_compiler55 = require(\"@marko/compiler\");\nvar import_babel_utils44 = require(\"@marko/compiler/babel-utils\");\nvar attribute_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils44.assertNoVar)(tag);\n      (0, import_babel_utils44.assertNoArgs)(tag);\n      const body = tag.get(\"body\");\n      startSection(body);\n      trackParamsReferences(body, 3 /* param */);\n      if (!(0, import_babel_utils44.findParentTag)(tag)) {\n        throw tag.get(\"name\").buildCodeFrameError(\"@tags must be nested within another tag.\");\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/custom-tag.ts\nvar import_compiler56 = require(\"@marko/compiler\");\nvar import_babel_utils45 = require(\"@marko/compiler/babel-utils\");\nvar import_path4 = __toESM(require(\"path\"));\nvar kChildScopeBinding = Symbol(\"custom tag child scope\");\nvar kChildOffsetScopeBinding = Symbol(\"custom tag scope offset\");\nvar kChildAttrExprs = Symbol(\"custom tag child attribute expressions\");\nvar custom_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils45.assertAttributesOrSingleArg)(tag);\n      analyzeAttributeTags(tag);\n      const templateFile = (0, import_babel_utils45.getTagTemplate)(tag);\n      if (!templateFile) {\n        const tagName = getTagName(tag);\n        if (tagName && tag.scope.hasBinding(tagName)) {\n          throw tag.get(\"name\").buildCodeFrameError(\n            `Local variables must be in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n          );\n        }\n        throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n      }\n      const section = getOrCreateSection(tag);\n      const tagBody = tag.get(\"body\");\n      const tagExtra = tag.node.extra ??= {};\n      tagExtra[kChildScopeBinding] = createBinding(\n        \"#childScope\",\n        0 /* dom */,\n        section,\n        void 0,\n        tagExtra\n      );\n      tagExtra[kChildAttrExprs] = /* @__PURE__ */ new Set([tagExtra]);\n      if (tag.has(\"var\")) {\n        trackVarReferences(tag, 4 /* derived */);\n        tag.node.var.extra.binding.scopeOffset = tagExtra[kChildOffsetScopeBinding] = createBinding(\n          \"#scopeOffset\",\n          0 /* dom */,\n          section,\n          void 0,\n          tagExtra\n        );\n      }\n      startSection(tagBody);\n      trackParamsReferences(tagBody, 3 /* param */);\n      const childFile = (0, import_babel_utils45.loadFileForTag)(tag);\n      if (childFile.opts.filename === tag.hub.file.opts.filename) {\n        mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n      } else {\n        const childProgramExtra = childFile.ast.program.extra;\n        analyzeAttrs(\n          tagExtra,\n          section,\n          tag,\n          childProgramExtra?.domExports.input\n        );\n        (0, import_babel_utils45.getProgram)().node.extra.hasInteractiveChild = childProgramExtra?.isInteractive || childProgramExtra?.hasInteractiveChild || false;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      if (isOutputHTML()) {\n        translateHTML(tag);\n      } else {\n        translateDOM(tag);\n      }\n    }\n  }\n};\nfunction translateHTML(tag) {\n  const tagBody = tag.get(\"body\");\n  const { node } = tag;\n  const tagExtra = node.extra;\n  let tagIdentifier;\n  flushInto(tag);\n  writeHTMLResumeStatements(tagBody);\n  if (import_compiler56.types.isStringLiteral(node.name)) {\n    const relativePath = getTagRelativePath(tag);\n    tagIdentifier = isCircularRequest(tag.hub.file, relativePath) ? import_compiler56.types.identifier(getTemplateContentName()) : (0, import_babel_utils45.importDefault)(tag.hub.file, relativePath, getTagName(tag));\n  } else {\n    tagIdentifier = node.name;\n  }\n  const tagVar = node.var;\n  const section = getSection(tag);\n  const inputExport = (0, import_babel_utils45.loadFileForTag)(tag)?.ast.program.extra?.domExports?.input;\n  const { properties, statements } = inputExport ? translateAttrs(tag, inputExport.props) : {\n    properties: [],\n    statements: []\n  };\n  const serializeReason = !!tagVar || getDynamicSourcesForExtras(tagExtra[kChildAttrExprs]);\n  if (serializeReason) {\n    const childScopeBinding = tagExtra[kChildScopeBinding];\n    const peekScopeId = generateUidIdentifier(childScopeBinding?.name);\n    tag.insertBefore(\n      import_compiler56.types.variableDeclaration(\"const\", [\n        import_compiler56.types.variableDeclarator(peekScopeId, callRuntime(\"peekNextScope\"))\n      ])\n    );\n    setSerializedProperty(\n      section,\n      getScopeAccessor(childScopeBinding),\n      callRuntime(\"writeExistingScope\", peekScopeId),\n      serializeReason\n    );\n    if (tagVar) {\n      statements.push(\n        import_compiler56.types.expressionStatement(\n          callRuntime(\n            \"setTagVar\",\n            getScopeIdIdentifier(section),\n            getScopeAccessorLiteral(tag.node.extra[kChildOffsetScopeBinding]),\n            peekScopeId,\n            import_compiler56.types.stringLiteral(\n              getResumeRegisterId(\n                section,\n                node.var.extra?.binding,\n                // TODO: node.var is not always an identifier.\n                \"var\"\n              )\n            )\n          )\n        )\n      );\n    }\n  }\n  if (node.extra.tagNameNullable) {\n    const contentProp = getTranslatedBodyContentProperty(properties);\n    let contentId = void 0;\n    if (contentProp) {\n      const contentExpression = contentProp.value;\n      contentProp.value = contentId = generateUidIdentifier(\"content\");\n      const [contentPath] = tag.insertBefore(\n        import_compiler56.types.variableDeclaration(\"const\", [\n          import_compiler56.types.variableDeclarator(\n            contentId,\n            // TODO: only register if needed (child template analysis)\n            contentExpression\n          )\n        ])\n      );\n      contentPath.skip();\n    }\n    let renderTagExpr = callExpression(\n      tagIdentifier,\n      propsToExpression(properties)\n    );\n    if (tagVar) {\n      translateVar(tag, import_compiler56.types.unaryExpression(\"void\", import_compiler56.types.numericLiteral(0)), \"let\");\n      renderTagExpr = import_compiler56.types.assignmentExpression(\"=\", tagVar, renderTagExpr);\n    }\n    statements.push(\n      import_compiler56.types.ifStatement(\n        tagIdentifier,\n        import_compiler56.types.expressionStatement(renderTagExpr),\n        contentId && callStatement(contentId)\n      )\n    );\n  } else if (tagVar) {\n    translateVar(\n      tag,\n      callExpression(tagIdentifier, propsToExpression(properties))\n    );\n    serializeSectionIfNeeded(section, true);\n  } else {\n    statements.push(\n      callStatement(tagIdentifier, propsToExpression(properties))\n    );\n  }\n  for (const replacement of tag.replaceWithMultiple(statements)) {\n    replacement.skip();\n  }\n}\nfunction translateDOM(tag) {\n  const tagSection = getSection(tag);\n  const { node } = tag;\n  const extra = node.extra;\n  const childScopeBinding = extra[kChildScopeBinding];\n  const write2 = writeTo(tag);\n  const { file } = tag.hub;\n  const tagName = import_compiler56.types.isIdentifier(node.name) ? node.name.name : import_compiler56.types.isStringLiteral(node.name) ? node.name.value : \"tag\";\n  const relativePath = getTagRelativePath(tag);\n  const childFile = (0, import_babel_utils45.loadFileForTag)(tag);\n  const childExports = childFile.ast.program.extra.domExports;\n  const tagIdentifier = importOrSelfReferenceName(\n    file,\n    relativePath,\n    childExports.setup,\n    tagName\n  );\n  const inputExport = childExports.input;\n  if (inputExport) {\n    writeAttrsToExports(tag, inputExport, `${getTagName(tag) || \"tag\"}_input`, {\n      circular: childFile.opts.filename === file.opts.filename,\n      tagSection,\n      relativePath,\n      childScopeBinding,\n      attrTagCallsByTag: void 0\n    });\n  }\n  write2`${(0, import_babel_utils45.importNamed)(file, relativePath, childExports.template, `${tagName}_template`)}`;\n  injectWalks(\n    tag,\n    (0, import_babel_utils45.importNamed)(file, relativePath, childExports.walks, `${tagName}_walks`)\n  );\n  if (node.var) {\n    const source = initValue(\n      // TODO: support destructuring\n      node.var.extra.binding\n    );\n    source.register = true;\n    source.buildAssignment = (valueSection, value) => {\n      return import_compiler56.types.callExpression(importRuntime(\"tagVarSignalChange\"), [\n        createScopeReadExpression(valueSection, childScopeBinding),\n        value\n      ]);\n    };\n    addStatement(\n      \"render\",\n      tagSection,\n      void 0,\n      import_compiler56.types.expressionStatement(\n        callRuntime(\n          \"setTagVar\",\n          scopeIdentifier,\n          getScopeAccessorLiteral(childScopeBinding),\n          source.identifier\n        )\n      )\n    );\n  }\n  addStatement(\n    \"render\",\n    tagSection,\n    void 0,\n    import_compiler56.types.expressionStatement(\n      import_compiler56.types.callExpression(tagIdentifier, [\n        createScopeReadExpression(tagSection, childScopeBinding)\n      ])\n    )\n  );\n  tag.remove();\n}\nfunction getTagRelativePath(tag) {\n  const {\n    node,\n    hub: { file }\n  } = tag;\n  let relativePath;\n  if (import_compiler56.types.isStringLiteral(node.name)) {\n    const template = (0, import_babel_utils45.getTagTemplate)(tag);\n    relativePath = template && (0, import_babel_utils45.resolveRelativePath)(file, template);\n  } else if (node.extra?.tagNameImported) {\n    relativePath = node.extra.tagNameImported;\n  }\n  if (!relativePath) {\n    const tagName = getTagName(tag);\n    if (tagName && tag.scope.hasBinding(tagName)) {\n      throw tag.get(\"name\").buildCodeFrameError(\n        `Local variables must be in a dynamic tag unless they are PascalCase. Use \\`<\\${${tagName}}/>\\` or rename to \\`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\\`.`\n      );\n    }\n    throw tag.get(\"name\").buildCodeFrameError(\"Unable to find entry point for custom tag.\");\n  }\n  return relativePath;\n}\nfunction analyzeAttrs(rootTagExtra, section, tag, templateExport) {\n  if (!templateExport) {\n    dropReferences(getAllTagReferenceNodes(tag.node));\n    return;\n  }\n  if (!templateExport.props || tag.node.arguments?.length) {\n    mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));\n    return;\n  }\n  const bodySection = getSectionForBody(tag.get(\"body\"));\n  if (bodySection) {\n    bodySection.downstreamBinding = (templateExport.props.content || templateExport.props).binding;\n  }\n  const attrTagLookup = analyzeAttributeTags(tag);\n  const seen = /* @__PURE__ */ new Set();\n  if (attrTagLookup) {\n    const nodeReferencesByGroup = /* @__PURE__ */ new Map();\n    const analyzeDynamicChildGroup = (group, child) => {\n      const referenceNodes = getAllTagReferenceNodes(child.node);\n      const groupReferences = nodeReferencesByGroup.get(group);\n      if (groupReferences) {\n        groupReferences.referenceNodes = groupReferences.referenceNodes.concat(referenceNodes);\n      } else {\n        nodeReferencesByGroup.set(group, {\n          firstTag: child,\n          referenceNodes\n        });\n      }\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    const attrTags2 = tag.node.body.attributeTags ? tag.get(\"body\").get(\"body\") : tag.get(\"attributeTags\");\n    for (const child of attrTags2) {\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils45.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExports = templateExport.props[attrTagMeta.name];\n          if (childAttrExports) {\n            if (childAttrExports.props && !attrTagMeta.dynamic) {\n              analyzeAttrs(rootTagExtra, section, child, childAttrExports);\n            } else {\n              analyzeDynamicChildGroup(attrTagMeta.group, child);\n            }\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        } else {\n          const group = child.node.extra.attributeTagGroup;\n          let childUsesGroupProp = false;\n          for (const name2 of group) {\n            if (templateExport.props[attrTagLookup[name2].name]) {\n              childUsesGroupProp = true;\n              break;\n            }\n          }\n          if (childUsesGroupProp) {\n            analyzeDynamicChildGroup(group, child);\n          } else {\n            dropReferences(getAllTagReferenceNodes(child.node));\n          }\n        }\n      }\n    }\n    for (const {\n      firstTag: { node },\n      referenceNodes\n    } of nodeReferencesByGroup.values()) {\n      mergeReferences(section, node, referenceNodes);\n      rootTagExtra[kChildAttrExprs].add(node.extra);\n    }\n  }\n  const { attributes } = tag.node;\n  let spreadReferenceNodes;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler56.types.isMarkoAttribute(attr2)) {\n      if (seen.has(attr2.name) || !templateExport.props[attr2.name]) {\n        dropReferences(attr2.value);\n        continue;\n      }\n      seen.add(attr2.name);\n    }\n    if (spreadReferenceNodes) {\n      spreadReferenceNodes.push(attr2.value);\n    } else if (import_compiler56.types.isMarkoSpreadAttribute(attr2)) {\n      spreadReferenceNodes = [attr2.value];\n    } else {\n      rootTagExtra[kChildAttrExprs].add(attr2.value.extra ??= {});\n    }\n  }\n  if (spreadReferenceNodes) {\n    mergeReferences(section, tag.node, spreadReferenceNodes);\n  }\n}\nfunction writeAttrsToExports(tag, templateExport, importAlias, info) {\n  if (tag.node.arguments?.length) {\n    const [arg] = tag.node.arguments;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    addValue(\n      info.tagSection,\n      // technically this should be `arg.extra?.referencedBindings`\n      // but we should probably ensure all other references are dropped in this case before we do that.\n      tag.node.extra?.referencedBindings,\n      identifierToSignal(tagInputIdentifier),\n      import_compiler56.types.isSpreadElement(arg) ? import_compiler56.types.memberExpression(arg.argument, import_compiler56.types.numericLiteral(0), true) : arg,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding)\n    );\n    return;\n  }\n  if (!templateExport.props || info.circular) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    const tagInputIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      templateExport.id,\n      importAlias\n    );\n    const translatedAttrs = translateAttrs(tag);\n    if (translatedAttrs.statements.length) {\n      addStatement(\n        \"render\",\n        info.tagSection,\n        referencedBindings,\n        translatedAttrs.statements\n      );\n    }\n    let translatedProps = propsToExpression(translatedAttrs.properties);\n    if ((0, import_babel_utils45.isAttributeTag)(tag)) {\n      const attrTagName = getTagName(tag);\n      const parentTag = tag.parentPath;\n      const repeated = analyzeAttributeTags(parentTag)?.[attrTagName]?.repeated;\n      if (repeated) {\n        let attrTagCallsForTag = (info.attrTagCallsByTag ||= /* @__PURE__ */ new Map()).get(\n          parentTag\n        );\n        if (!attrTagCallsForTag) {\n          info.attrTagCallsByTag.set(\n            parentTag,\n            attrTagCallsForTag = /* @__PURE__ */ new Map()\n          );\n        }\n        const attrTagCall = attrTagCallsForTag.get(attrTagName);\n        if (attrTagCall) {\n          attrTagCall.expression = callRuntime(\n            \"attrTags\",\n            attrTagCall.expression,\n            translatedProps\n          );\n          return;\n        } else {\n          attrTagCallsForTag.set(\n            attrTagName,\n            translatedProps = import_compiler56.types.parenthesizedExpression(\n              callRuntime(\"attrTag\", translatedProps)\n            )\n          );\n        }\n      } else {\n        translatedProps = callRuntime(\"attrTag\", translatedProps);\n      }\n    }\n    addValue(\n      info.tagSection,\n      referencedBindings,\n      identifierToSignal(tagInputIdentifier),\n      translatedProps,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding)\n    );\n    return;\n  }\n  const seen = /* @__PURE__ */ new Set();\n  const attrTagLookup = analyzeAttributeTags(tag);\n  if (attrTagLookup) {\n    const attrTags2 = tag.get(\"attributeTags\");\n    const statementsByGroup = /* @__PURE__ */ new Map();\n    const translateDynamicAttrTagChildInGroup = (group, index) => {\n      const child = attrTags2[index];\n      let statements = statementsByGroup.get(group)?.statements;\n      if (!statements) {\n        statements = [];\n        statementsByGroup.set(group, {\n          referencedBindings: child.node.extra?.referencedBindings,\n          statements\n        });\n      }\n      return addDynamicAttrTagStatements(\n        attrTags2,\n        index,\n        attrTagLookup,\n        statements,\n        templateExport.props\n      );\n    };\n    for (const attrTagName in attrTagLookup) {\n      seen.add(attrTagLookup[attrTagName].name);\n    }\n    for (let i = 0; i < attrTags2.length; i++) {\n      const child = attrTags2[i];\n      if (child.isMarkoTag()) {\n        if ((0, import_babel_utils45.isAttributeTag)(child)) {\n          const attrTagMeta = attrTagLookup[getTagName(child)];\n          const childAttrExport = templateExport.props[attrTagMeta.name];\n          if (childAttrExport) {\n            if (attrTagMeta.dynamic) {\n              i = translateDynamicAttrTagChildInGroup(attrTagMeta.group, i);\n            } else {\n              writeAttrsToExports(\n                child,\n                childAttrExport,\n                `${importAlias}_${attrTagMeta.name}`,\n                info\n              );\n            }\n          }\n        } else if (child.node.extra?.attributeTagGroup) {\n          i = translateDynamicAttrTagChildInGroup(\n            child.node.extra.attributeTagGroup,\n            i\n          );\n        }\n      }\n    }\n    for (const [\n      group,\n      { referencedBindings, statements }\n    ] of statementsByGroup) {\n      const decls = [];\n      for (const name2 of group) {\n        const attrTagMeta = attrTagLookup[name2];\n        const childAttrExports = templateExport.props[attrTagMeta.name];\n        if (!childAttrExports) continue;\n        const attrExportIdentifier = importOrSelfReferenceName(\n          tag.hub.file,\n          info.relativePath,\n          childAttrExports.id,\n          `${importAlias}_${attrTagMeta.name}`\n        );\n        decls.push(import_compiler56.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta)));\n        addValue(\n          info.tagSection,\n          referencedBindings,\n          identifierToSignal(attrExportIdentifier),\n          getAttrTagIdentifier(attrTagMeta),\n          createScopeReadExpression(info.tagSection, info.childScopeBinding)\n        );\n      }\n      addStatement(\"render\", info.tagSection, referencedBindings, [\n        import_compiler56.types.variableDeclaration(\"let\", decls),\n        ...statements\n      ]);\n    }\n  }\n  const bodySection = tag.node.body.extra?.section;\n  if (bodySection && !seen.has(\"content\")) {\n    seen.add(\"content\");\n    if (templateExport.props.content) {\n      const contentExportIdentifier = (0, import_babel_utils45.importNamed)(\n        tag.hub.file,\n        info.relativePath,\n        templateExport.props.content.id,\n        `${importAlias}_content`\n      );\n      addValue(\n        info.tagSection,\n        void 0,\n        // TODO: pretty sure content needs to have the reference group of it's param defaults.\n        identifierToSignal(contentExportIdentifier),\n        import_compiler56.types.callExpression(import_compiler56.types.identifier(bodySection.name), [scopeIdentifier]),\n        createScopeReadExpression(info.tagSection, info.childScopeBinding)\n      );\n    }\n  }\n  const { attributes } = tag.node;\n  const staticAttrs = [];\n  let spreadProps;\n  for (let i = attributes.length; i--; ) {\n    const attr2 = attributes[i];\n    if (import_compiler56.types.isMarkoAttribute(attr2)) {\n      const childAttrExports = templateExport.props[attr2.name];\n      if (!childAttrExports || seen.has(attr2.name)) continue;\n      seen.add(attr2.name);\n      if (spreadProps) {\n        spreadProps.push(toObjectProperty(attr2.name, attr2.value));\n        continue;\n      }\n      staticAttrs.push(attr2);\n    } else if (spreadProps) {\n      spreadProps.push(import_compiler56.types.spreadElement(attr2.value));\n    } else {\n      spreadProps = [import_compiler56.types.spreadElement(attr2.value)];\n    }\n  }\n  for (const attr2 of staticAttrs.reverse()) {\n    const childAttrExports = templateExport.props[attr2.name];\n    const attrExportIdentifier = importOrSelfReferenceName(\n      tag.hub.file,\n      info.relativePath,\n      childAttrExports.id,\n      `${importAlias}_${attr2.name}`\n    );\n    addValue(\n      info.tagSection,\n      attr2.value.extra?.referencedBindings,\n      identifierToSignal(attrExportIdentifier),\n      attr2.value,\n      createScopeReadExpression(info.tagSection, info.childScopeBinding)\n    );\n  }\n  const missing = new Set(Object.keys(templateExport.props));\n  for (const name2 of seen) missing.delete(name2);\n  if (missing.size) {\n    const referencedBindings = tag.node.extra?.referencedBindings;\n    let getMissingPropValue = buildUndefined2;\n    if (spreadProps) {\n      const spreadId = generateUidIdentifier(`${importAlias}_spread`);\n      spreadProps.reverse();\n      getMissingPropValue = (name2) => toMemberExpression(spreadId, name2);\n      addStatement(\"render\", info.tagSection, referencedBindings, [\n        import_compiler56.types.variableDeclaration(\"const\", [\n          import_compiler56.types.variableDeclarator(spreadId, propsToExpression(spreadProps))\n        ])\n      ]);\n    }\n    for (const name2 of missing) {\n      const childAttrExports = templateExport.props[name2];\n      const attrExportIdentifier = importOrSelfReferenceName(\n        tag.hub.file,\n        info.relativePath,\n        childAttrExports.id,\n        `${importAlias}_${name2}`\n      );\n      addValue(\n        info.tagSection,\n        referencedBindings,\n        identifierToSignal(attrExportIdentifier),\n        getMissingPropValue(name2),\n        createScopeReadExpression(info.tagSection, info.childScopeBinding)\n      );\n    }\n  }\n}\nfunction importOrSelfReferenceName(file, request, name2, nameHint) {\n  if (isCircularRequest(file, request)) {\n    return import_compiler56.types.identifier(name2);\n  }\n  return (0, import_babel_utils45.importNamed)(file, request, name2, nameHint);\n}\nfunction isCircularRequest(file, request) {\n  const { filename } = file.opts;\n  return request === filename || request[0] === \".\" && import_path4.default.resolve(filename, \"..\", request) === filename;\n}\nfunction callStatement(id, ...args) {\n  return import_compiler56.types.expressionStatement(callExpression(id, ...args));\n}\nfunction callExpression(id, ...args) {\n  return import_compiler56.types.callExpression(id, args.filter(Boolean));\n}\nfunction identifierToSignal(identifier) {\n  return {\n    identifier,\n    hasDownstreamIntersections: always\n  };\n}\nfunction buildUndefined2() {\n  return import_compiler56.types.unaryExpression(\"void\", import_compiler56.types.numericLiteral(0));\n}\nfunction always() {\n  return true;\n}\n\n// src/translator/visitors/tag/dynamic-tag.ts\nvar import_compiler57 = require(\"@marko/compiler\");\nvar import_babel_utils46 = require(\"@marko/compiler/babel-utils\");\nvar kDOMBinding3 = Symbol(\"dynamic tag dom binding\");\nvar kChildOffsetScopeBinding2 = Symbol(\"custom tag scope offset\");\nvar dynamic_tag_default = {\n  analyze: {\n    enter(tag) {\n      (0, import_babel_utils46.assertAttributesOrArgs)(tag);\n      analyzeAttributeTags(tag);\n      const section = getOrCreateSection(tag);\n      const tagExtra = tag.node.extra ??= {};\n      const tagBody = tag.get(\"body\");\n      tagExtra[kDOMBinding3] = createBinding(\n        \"#text\",\n        0 /* dom */,\n        section,\n        void 0,\n        tagExtra\n      );\n      if (tag.has(\"var\")) {\n        trackVarReferences(tag, 4 /* derived */);\n        tag.node.var.extra.binding.scopeOffset = tagExtra[kChildOffsetScopeBinding2] = createBinding(\n          \"#scopeOffset\",\n          0 /* dom */,\n          section,\n          void 0,\n          tagExtra\n        );\n      }\n      startSection(tagBody);\n      trackParamsReferences(tagBody, 3 /* param */);\n      mergeReferences(section, tag.node, [\n        tag.node.name,\n        ...getAllTagReferenceNodes(tag.node)\n      ]);\n    }\n  },\n  translate: {\n    enter(tag) {\n      visit(\n        tag,\n        tag.node.var ? 49 /* DynamicTagWithVar */ : 37 /* Replace */\n      );\n      enterShallow(tag);\n      if (isOutputHTML()) {\n        flushBefore(tag);\n      }\n    },\n    exit(tag) {\n      const { node } = tag;\n      const tagExtra = node.extra;\n      const nodeRef2 = tagExtra[kDOMBinding3];\n      const section = getSection(tag);\n      const isClassAPI = tagExtra.featureType === \"class\";\n      let tagExpression = node.name;\n      if (import_compiler57.types.isStringLiteral(tagExpression)) {\n        tagExpression = (0, import_babel_utils46.importDefault)(\n          tag.hub.file,\n          getTagRelativePath(tag),\n          tagExpression.value\n        );\n      }\n      if (isClassAPI) {\n        if (isOutputHTML()) {\n          (0, import_babel_utils46.getProgram)().node.body.push(\n            import_compiler57.types.markoScriptlet(\n              [\n                import_compiler57.types.expressionStatement(\n                  import_compiler57.types.callExpression(\n                    (0, import_babel_utils46.importNamed)(tag.hub.file, getCompatRuntimeFile(), \"s\"),\n                    [\n                      import_compiler57.types.identifier(tagExpression.name),\n                      import_compiler57.types.stringLiteral((0, import_babel_utils46.loadFileForTag)(tag).metadata.marko.id)\n                    ]\n                  )\n                )\n              ],\n              true\n            )\n          );\n        } else {\n          (0, import_babel_utils46.getProgram)().node.body.push(\n            import_compiler57.types.expressionStatement(\n              callRuntime(\n                \"register\",\n                import_compiler57.types.stringLiteral((0, import_babel_utils46.loadFileForTag)(tag).metadata.marko.id),\n                import_compiler57.types.identifier(tagExpression.name)\n              )\n            )\n          );\n        }\n      }\n      const { properties, statements } = translateAttrs(\n        tag,\n        void 0,\n        void 0,\n        isClassAPI ? \"renderBody\" : \"content\"\n      );\n      const args = [];\n      let hasTagArgs = false;\n      if (node.arguments) {\n        hasTagArgs = true;\n        args.push(...node.arguments);\n        if (properties.length) {\n          args.push(propsToExpression(properties));\n        }\n      } else {\n        const contentProp = getTranslatedBodyContentProperty(properties);\n        if (contentProp) {\n          properties.splice(properties.indexOf(contentProp), 1);\n          args.push(propsToExpression(properties), contentProp.value);\n        } else {\n          args.push(propsToExpression(properties));\n        }\n      }\n      if (isOutputHTML()) {\n        flushInto(tag);\n        writeHTMLResumeStatements(tag.get(\"body\"));\n        const serializeReason = isClassAPI || !!node.var || getDynamicSourcesForExtra(tagExtra);\n        const dynamicTagExpr = hasTagArgs ? callRuntime(\n          \"dynamicTag\",\n          getScopeIdIdentifier(section),\n          getScopeAccessorLiteral(nodeRef2),\n          tagExpression,\n          import_compiler57.types.arrayExpression(args),\n          import_compiler57.types.numericLiteral(0),\n          import_compiler57.types.numericLiteral(1),\n          serializeReason ? import_compiler57.types.numericLiteral(1) : void 0\n        ) : callRuntime(\n          \"dynamicTag\",\n          getScopeIdIdentifier(section),\n          getScopeAccessorLiteral(nodeRef2),\n          tagExpression,\n          args[0],\n          args[1] || (serializeReason ? import_compiler57.types.numericLiteral(0) : void 0),\n          serializeReason ? import_compiler57.types.numericLiteral(0) : void 0,\n          serializeReason ? import_compiler57.types.numericLiteral(1) : void 0\n        );\n        if (node.var) {\n          const dynamicScopeIdentifier = generateUidIdentifier(\"dynamicScope\");\n          statements.push(\n            import_compiler57.types.variableDeclaration(\"const\", [\n              import_compiler57.types.variableDeclarator(\n                dynamicScopeIdentifier,\n                callRuntime(\"peekNextScope\")\n              )\n            ])\n          );\n          statements.push(\n            import_compiler57.types.variableDeclaration(\"const\", [\n              import_compiler57.types.variableDeclarator(node.var, dynamicTagExpr)\n            ]),\n            import_compiler57.types.expressionStatement(\n              callRuntime(\n                \"setTagVar\",\n                getScopeIdIdentifier(section),\n                getScopeAccessorLiteral(\n                  tag.node.extra[kChildOffsetScopeBinding2]\n                ),\n                dynamicScopeIdentifier,\n                import_compiler57.types.stringLiteral(\n                  getResumeRegisterId(\n                    section,\n                    node.var.extra?.binding,\n                    // TODO: node.var is not always an identifier.\n                    \"var\"\n                  )\n                )\n              )\n            )\n          );\n        } else {\n          statements.push(import_compiler57.types.expressionStatement(dynamicTagExpr));\n        }\n        for (const replacement of tag.replaceWithMultiple(statements)) {\n          replacement.skip();\n        }\n      } else {\n        const section2 = getSection(tag);\n        const bodySection = getSectionForBody(tag.get(\"body\"));\n        const signal = getSignal(section2, nodeRef2, \"dynamicTag\");\n        let tagVarSignal;\n        if (tag.node.var) {\n          tagVarSignal = initValue(\n            // TODO: support destructuring\n            tag.node.var.extra.binding\n          );\n          tagVarSignal.register = true;\n          tagVarSignal.buildAssignment = (valueSection, value) => {\n            return import_compiler57.types.callExpression(importRuntime(\"tagVarSignalChange\"), [\n              import_compiler57.types.memberExpression(\n                getScopeExpression(tagVarSignal.section, valueSection),\n                import_compiler57.types.stringLiteral(\n                  getAccessorPrefix().ConditionalScope + getScopeAccessor(nodeRef2)\n                ),\n                true\n              ),\n              value\n            ]);\n          };\n        }\n        signal.build = () => {\n          return callRuntime(\n            \"dynamicTag\",\n            getScopeAccessorLiteral(nodeRef2),\n            bodySection && import_compiler57.types.identifier(bodySection.name),\n            tagVarSignal ? import_compiler57.types.arrowFunctionExpression([], tagVarSignal.identifier) : void 0,\n            hasTagArgs && import_compiler57.types.numericLiteral(1)\n          );\n        };\n        if (args.length) {\n          const argsOrInput = hasTagArgs ? import_compiler57.types.arrayExpression(args) : args[0];\n          if (!import_compiler57.types.isObjectExpression(argsOrInput) || argsOrInput.properties.length) {\n            signal.extraArgs = [\n              import_compiler57.types.arrowFunctionExpression(\n                [],\n                statements.length ? import_compiler57.types.blockStatement(\n                  statements.concat(import_compiler57.types.returnStatement(argsOrInput))\n                ) : argsOrInput\n              )\n            ];\n          }\n        }\n        signal.hasDownstreamIntersections = () => true;\n        addValue(section2, tagExtra.referencedBindings, signal, tagExpression);\n        tag.remove();\n      }\n    }\n  }\n};\n\n// src/translator/visitors/tag/index.ts\nvar TAG_NAME_IDENTIFIER_REG = /^[A-Z][a-zA-Z0-9_$]*$/;\nvar BINDING_CHANGE_HANDLER = /* @__PURE__ */ new WeakMap();\nvar tag_default = {\n  transform: {\n    enter(tag) {\n      const { node } = tag;\n      const { name: name2, attributes } = tag.node;\n      let crawl = false;\n      if (import_compiler58.types.isStringLiteral(name2)) {\n        const tagName = name2.value;\n        if (tag.scope.getBinding(tagName) && TAG_NAME_IDENTIFIER_REG.test(tagName)) {\n          node.name = withPreviousLocation(import_compiler58.types.identifier(tagName), name2);\n          crawl = true;\n        }\n      }\n      for (let i = 0; i < attributes.length; i++) {\n        const attr2 = attributes[i];\n        if (import_compiler58.types.isMarkoAttribute(attr2) && attr2.bound) {\n          attr2.bound = false;\n          attributes.splice(++i, 0, getChangeHandler(tag, attr2));\n          crawl = true;\n        }\n      }\n      if (crawl) {\n        tag.scope.crawl();\n      }\n    }\n  },\n  analyze: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils47.getTagDef)(tag);\n      const type = analyzeTagNameType(tag);\n      const hook = tagDef?.analyzer?.hook;\n      if (hook) {\n        enter(hook, tag);\n        return;\n      }\n      if (type === 0 /* NativeTag */) {\n        native_tag_default.analyze.enter(tag);\n        return;\n      }\n      switch (type) {\n        case 1 /* CustomTag */:\n          custom_tag_default.analyze.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.analyze.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.analyze.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const hook = (0, import_babel_utils47.getTagDef)(tag)?.analyzer?.hook;\n      if (hook) {\n        exit(hook, tag);\n        return;\n      }\n    }\n  },\n  translate: {\n    enter(tag) {\n      const tagDef = (0, import_babel_utils47.getTagDef)(tag);\n      const extra = tag.node.extra;\n      if (tagDef?.translator) {\n        if (tagDef.translator.path) {\n          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);\n        }\n        enter(tagDef.translator.hook, tag);\n        return;\n      }\n      for (const attr2 of tag.get(\"attributes\")) {\n        if (attr2.isMarkoAttribute()) {\n          if (attr2.node.arguments) {\n            throw attr2.buildCodeFrameError(\n              `Unsupported arguments on the \\`${attr2.node.name}\\` attribute.`\n            );\n          }\n          if (attr2.node.modifier) {\n            if ((0, import_babel_utils47.isNativeTag)(attr2.parentPath)) {\n              attr2.node.name += `:${attr2.node.modifier}`;\n            } else {\n              throw attr2.buildCodeFrameError(\n                `Unsupported modifier \\`${attr2.node.modifier}\\`.`\n              );\n            }\n          }\n        }\n      }\n      if (extra.tagNameDynamic && extra.tagNameNullable && !tag.get(\"name\").isIdentifier() && isOutputHTML()) {\n        const tagNameId = generateUidIdentifier(\"tagName\");\n        const [tagNameVarPath] = tag.insertBefore(\n          import_compiler58.types.variableDeclaration(\"const\", [\n            import_compiler58.types.variableDeclarator(tagNameId, tag.node.name)\n          ])\n        );\n        tagNameVarPath.skip();\n        tag.set(\"name\", tagNameId);\n      }\n      switch (extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.enter(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.enter(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.enter(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.enter(tag);\n          break;\n      }\n    },\n    exit(tag) {\n      const translator = (0, import_babel_utils47.getTagDef)(tag)?.translator;\n      if (translator) {\n        exit(translator.hook, tag);\n        return;\n      }\n      switch (tag.node.extra.tagNameType) {\n        case 0 /* NativeTag */:\n          native_tag_default.translate.exit(tag);\n          break;\n        case 1 /* CustomTag */:\n          custom_tag_default.translate.exit(tag);\n          break;\n        case 2 /* DynamicTag */:\n          dynamic_tag_default.translate.exit(tag);\n          break;\n        case 3 /* AttributeTag */:\n          attribute_tag_default.translate.exit(tag);\n          break;\n      }\n    }\n  }\n};\nfunction getChangeHandler(tag, attr2) {\n  const attrName = attr2.name;\n  const changeAttrName = attrName + \"Change\";\n  if (import_compiler58.types.isIdentifier(attr2.value)) {\n    const binding = tag.scope.getBinding(attr2.value.name);\n    if (!binding)\n      return import_compiler58.types.markoAttribute(\n        changeAttrName,\n        buildChangeHandlerFunction(attr2.value)\n      );\n    const existingChangedAttr = BINDING_CHANGE_HANDLER.get(binding.identifier);\n    if (!existingChangedAttr) {\n      const changeHandlerAttr = import_compiler58.types.markoAttribute(\n        changeAttrName,\n        buildChangeHandlerFunction(attr2.value)\n      );\n      BINDING_CHANGE_HANDLER.set(binding.identifier, changeHandlerAttr);\n      return changeHandlerAttr;\n    }\n    if (existingChangedAttr.type === \"Identifier\") {\n      return import_compiler58.types.markoAttribute(\n        changeAttrName,\n        withPreviousLocation(\n          import_compiler58.types.identifier(existingChangedAttr.name),\n          attr2.value\n        )\n      );\n    }\n    const markoRoot = isMarko(binding.path) ? binding.path : getMarkoRoot(binding.path);\n    if (!(markoRoot?.isMarkoTag() || markoRoot?.isMarkoTagBody())) {\n      throw tag.hub.buildError(attr2.value, \"Unable to bind to value.\");\n    }\n    const changeHandlerId = generateUid(changeAttrName);\n    const changeHandlerConst = import_compiler58.types.markoTag(\n      import_compiler58.types.stringLiteral(\"const\"),\n      [import_compiler58.types.markoAttribute(\"value\", existingChangedAttr.value, null, null, true)],\n      import_compiler58.types.markoTagBody([]),\n      null,\n      import_compiler58.types.identifier(changeHandlerId)\n    );\n    BINDING_CHANGE_HANDLER.set(\n      binding.identifier,\n      existingChangedAttr.value = import_compiler58.types.identifier(changeHandlerId)\n    );\n    if (markoRoot.isMarkoTag()) {\n      markoRoot.insertAfter(changeHandlerConst);\n    } else {\n      markoRoot.unshiftContainer(\"body\", changeHandlerConst);\n    }\n    return import_compiler58.types.markoAttribute(\n      changeAttrName,\n      withPreviousLocation(import_compiler58.types.identifier(changeHandlerId), attr2.value)\n    );\n  } else if (import_compiler58.types.isMemberExpression(attr2.value)) {\n    const prop = attr2.value.property;\n    if (!import_compiler58.types.isPrivateName(attr2.value.property)) {\n      return import_compiler58.types.markoAttribute(\n        changeAttrName,\n        import_compiler58.types.memberExpression(\n          import_compiler58.types.cloneNode(attr2.value.object),\n          prop.type === \"Identifier\" ? withPreviousLocation(import_compiler58.types.identifier(prop.name + \"Change\"), prop) : import_compiler58.types.binaryExpression(\n            \"+\",\n            import_compiler58.types.cloneNode(prop),\n            import_compiler58.types.stringLiteral(\"Change\")\n          ),\n          prop.type !== \"Identifier\"\n        )\n      );\n    }\n  }\n  throw tag.hub.buildError(\n    attr2.value,\n    \"Attributes may only be bound to identifiers or member expressions\"\n  );\n}\nfunction buildChangeHandlerFunction(id) {\n  const newId = \"_new_\" + id.name;\n  return import_compiler58.types.arrowFunctionExpression(\n    [withPreviousLocation(import_compiler58.types.identifier(newId), id)],\n    import_compiler58.types.blockStatement([\n      import_compiler58.types.expressionStatement(\n        import_compiler58.types.assignmentExpression(\n          \"=\",\n          withPreviousLocation(import_compiler58.types.identifier(id.name), id),\n          withPreviousLocation(import_compiler58.types.identifier(newId), id)\n        )\n      )\n    ])\n  );\n}\n\n// src/translator/visitors/text.ts\nvar import_compiler59 = require(\"@marko/compiler\");\nvar text_default = {\n  translate: {\n    exit(text) {\n      if (isNonHTMLText(text)) return;\n      writeTo(text)`${text.node.value}`;\n      enterShallow(text);\n      text.remove();\n    }\n  }\n};\n\n// src/translator/index.ts\nvar visitors = extractVisitors({\n  Program: program_default,\n  Function: function_default,\n  ReferencedIdentifier: referenced_identifier_default,\n  ImportDeclaration: import_declaration_default,\n  MarkoDocumentType: document_type_default,\n  MarkoDeclaration: declaration_default,\n  MarkoCDATA: cdata_default,\n  MarkoText: text_default,\n  MarkoTag: tag_default,\n  MarkoPlaceholder: placeholder_default,\n  MarkoScriptlet: scriptlet_default,\n  MarkoComment: comment_default\n});\nvar tagDiscoveryDirs = [\"tags\"];\nvar preferAPI = \"tags\";\nvar { transform, analyze, translate } = visitors;\nvar taglibs = [\n  [\n    __dirname,\n    {\n      ...core_default,\n      migrate: visitors.migrate\n    }\n  ]\n];\nfunction getRuntimeEntryFiles(output, optimize) {\n  return [\n    `${runtime_info_default.name}${optimize ? \"\" : \"/debug\"}/${output === \"html\" ? \"html\" : \"dom\"}`\n  ];\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  analyze,\n  getRuntimeEntryFiles,\n  internalEntryBuilder,\n  preferAPI,\n  tagDiscoveryDirs,\n  taglibs,\n  transform,\n  translate\n});\n"],"names":["mod","__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__copyProps","to","from","except","desc","key","call","get","enumerable","__toESM","isNodeMode","target","__esModule","value","index_exports","__export","all","name2","analyze","getRuntimeEntryFiles","internalEntryBuilder","entry_builder_default","preferAPI","tagDiscoveryDirs","taglibs","transform","translate","module","exports","runtime_info_default","name","require","taglibId","import_compiler","import_babel_utils","assertNoSpreadAttrs","tag","attr2","isMarkoSpreadAttribute","buildCodeFrameError","node","assertNoBodyContent","body","length","AccessorPrefix3","AccessorProp3","attrs_default","migrate","assertNoArgs","assertNoParams","assertNoAttributes","assertNoAttributeTags","diagnosticDeprecate","label","fix","tagVar","var","type","remove","constTag","types","markoTag","stringLiteral","markoAttribute","identifier","markoTagBody","replaceWith","attributes","autocomplete","displayText","description","snippet","import_compiler25","import_babel_utils16","AccessorPrefix","AccessorProp","import_babel_utils2","evaluate","extra","confident","computed","computeNode","import_compiler24","import_compiler5","import_babel_utils7","import_compiler3","import_babel_utils3","import_compiler2","skip","Symbol","traverseReplace","container","enter3","Array","isArray","i","keys","VISITOR_KEYS","replacement","traverseContains","check","item","traverse","visit2","parent","grandParent","countsForFile","WeakMap","generateUid","file","getFile","counts","cache","markoOpts","filename","opts","cacheKey","isTranslate","Map","program","path","countName","match","exec","name3","count","set","Math","max","scope","globals","isBinding","getInitialCounts","replace","uniqueName","generateUidIdentifier","___compileStage","import_babel_utils4","getTagName","isCoreTag","isMarkoTag","tagDef","getTagDef","isCoreTagName","isConditionTag","Sorted","constructor","compare","this","add","data","addSorted","joinRepeatable","union","a","b","aLen","bLen","aIndex","bIndex","result","aValue","bValue","delta","push","unionSortedRepeatable","find","findSorted","findIndex","pos","mid","compareResult","isSuperset","superset","subset","subLen","supLen","supIndex","filter","cb","len","forEach","cur","next","import_babel_utils5","createProgramState","init","map2","state","getProgram","createSectionState","section","arrayOfSectionData","id","import_compiler4","import_babel_utils6","MARKO_FILE_REG","analyzeTagNameType","tagNameType","isStringLiteral","isNativeTag","tagNameNullable","isIdentifier","pending","path5","tagNameImported","nullable","pop","isConditionalExpression","alternate","isLogicalExpression","operator","isAssignmentExpression","isBinaryExpression","isTemplateLiteral","isNullLiteral","binding","getBinding","kind","decl","test","source","specifiers","some","it","isImportDefaultSpecifier","resolvedImport","resolveTagImport","bindingTag","bindingTagName","tagNameDynamic","analyzeExpressionTagName","expressions","childFile","loadFileForTag","ast","featureType","needsCompat","sectionUtil","startSection","parentSection","parentPath","getOrCreateSection","sectionNamePath","sectionName","isProgram","toString","programExtra","hub","sections","loc","depth","sectionAccessor","params","referencedClosures","referencedHoists","bindings","hoisted","isHoistThrough","assignments","content","getContentInfo","upstreamExpression","downstreamBinding","hasAbortSignal","isBranch","attributeTags","isNativeNode","getSectionForBody","getSection","currentPath","getScopeIdIdentifier","getSectionParentIsOwner","setSectionParentIsOwner","_getScopeIdentifier","forEachSection","fn","contentInfo","startType","endType","singleChild","endIndex","getNodeContentType","startIndex","extraMember","isAttributeTag","tagSection","isSerializedSection","serialize","isSectionWithHoists","isImmediateOwner","isDynamicClosure","closure","isDirectClosure","isSameOrChildSection","other","getDynamicSourcesForBinding","sources","every","isInputBinding","getDynamicSourcesForExtra","isReferencedExtra","getDynamicSourcesForReferences","referencedBindings","getDynamicSourcesForExtras","extras","allDynamicSources","dynamicSources","bindingUtil","getDynamicSourcesForSection","referenced","closures","getDirectClosures","newDynamicSources","mergeDynamicSources","forEachIdentifier","prop","properties","left","argument","el","elements","AccessorPrefix2","AccessorProp2","import_babel_utils8","isOutputHTML","getMarkoOpts","output","isOutputDOM","isOptimize","optimize","getAccessorPrefix","getMarkoRoot","curPath","isMarko","getExprRoot","getFnRoot","fnPath","isFunction","declare","isInvokedFunction","expr","callee","import_compiler23","import_compiler22","import_babel_utils15","import_path2","bindingHasDownstreamExpressions","downstreamExpressions","size","alias","aliases","propertyAliases","values","import_compiler8","import_babel_utils9","kState","build","entryFile","imports","map","importDeclaration","unshift","importSpecifier","expressionStatement","callExpression","visit","visitChild","analyzedTags","metadata","marko","resolveRelativePath","hasInteractiveChild","isInteractive","import_compiler10","import_babel_utils10","stringifyClassObject","stringifyStyleObject","toDelimitedString","val","delimiter","stringify","curDelimiter","v","part","isEventHandler","getEventHandlerName","slice","toLowerCase","unsafeXMLReg","replaceUnsafeXML","c","escapeXML","str","unsafeScriptReg","escapeScript","unsafeStyleReg","escapeStyle","kTouchedIterator","Generator","AsyncGenerator","async","toAccess","accessor","start","patchIteratorNext","proto","classAttr","stringAttr","classValue","styleAttr","styleValue","attr","isVoid","attrAssignment","RegExp","nonVoidAttr","KNOWN_SYMBOLS2","symbol","AggregateError","of","ArrayBuffer","isView","Atomics","and","compareExchange","exchange","isLockFree","load","notify","or","store","sub","wait","BigInt","asIntN","asUintN","BigInt64Array","BigUint64Array","Boolean","console","assert","clear","countReset","debug","dir","dirxml","error","group","groupCollapsed","groupEnd","info","log","table","time","timeEnd","timeLog","timeStamp","trace","warn","DataView","Date","now","parse","UTC","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","Error","EvalError","Float32Array","Float64Array","Function","globalThis","atob","btoa","clearImmediate","clearInterval","clearTimeout","crypto","getRandomValues","randomUUID","fetch","performance","queueMicrotask","setImmediate","setInterval","setTimeout","structuredClone","URL","URLSearchParams","WritableStream","Int16Array","Int32Array","Int8Array","Intl","Collator","DateTimeFormat","DisplayNames","getCanonicalLocales","ListFormat","Locale","NumberFormat","PluralRules","RelativeTimeFormat","Segmenter","supportedValuesOf","isFinite","isNaN","JSON","groupBy","abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","floor","fround","hypot","imul","log10","log1p","log2","min","pow","random","round","sign","sin","sinh","sqrt","tan","tanh","trunc","Number","isInteger","isSafeInteger","parseFloat","parseInt","assign","defineProperties","entries","freeze","fromEntries","getOwnPropertyDescriptors","getOwnPropertySymbols","is","isExtensible","isFrozen","isSealed","preventExtensions","seal","setPrototypeOf","Promise","Proxy","RangeError","ReferenceError","Reflect","apply","construct","deleteProperty","has","ownKeys","Set","String","fromCharCode","fromCodePoint","raw","for","SyntaxError","TypeError","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","URIError","WeakSet","singleQuoteAttrReplacements","doubleQuoteAttrReplacements","needsQuotedAttr","lastIndex","replaceUnsafeSingleQuoteAttrChar","escapeSingleQuotedAttrValue","replaceUnsafeDoubleQuoteAttrChar","escapeDoubleQuotedAttrValue","import_compiler9","isValidPropertyIdentifier","toPropertyName","numericLiteral","toObjectProperty","objectProperty","toMemberExpression","object","optional","optionalMemberExpression","memberExpression","pureDOMFunctions","importRuntime","importStar","getRuntimePath","callRuntime","args","callExpression2","filteredArgs","arg","unaryExpression","filterArguments","leadingComments","getHTMLRuntime","getCompatRuntimeFile","modules","import_compiler20","import_babel_utils13","import_path","regexpCharsReg","import_compiler19","import_babel_utils12","import_compiler15","import_babel_utils11","getKnownAttrValues","attrs2","getParentTag","import_compiler11","enter","modulePlugin","plugin","isModulePlugin","default","isFunctionPlugin","exit","translateByTarget","html","dom","import_compiler14","import_compiler12","normalizeStringExpression","parts","strs","exprs","curStr","nextIndex","exprLen","shiftItems","quasis","j","templateLiteral","templateElement","appendLiteral","arr","list","offset","getWalks","getWalkComment","getSteps","walkCodeToName","enter2","exit2","enterShallow","code","steps","walks","walkComment","walkString","walkCodes","step","lastIndexOf","current","walk","nCodeString","writeTo","number","toCharString","startCode","rangeSize","multiplier","getWalkString","prefix2","postfix","walkLiteral","join","getWrites","getTrailerWrites","trailer","exprsLen","writes","consumeHTML","trailers","writeResult","trailerResult","sequenceExpression","flushBefore","insertBefore","flushInto","getSectionMeta","writePrefix","writePostfix","setup","getSetup","markNode","getScopeAccessorLiteral","tagsWithReturn","getSectionReturnValueIdentifier","setReturnValueIdentifier","return_default","assertNoVar","assertAllowedAttributes","parentTag","isControlFlowTag","valueChange","setSerializedProperty","TagVariableChange","returnId","variableDeclaration","variableDeclarator","addValue","hasDownstreamIntersections","parseOptions","openTagOnly","descriptionMoreURL","import_compiler16","getDeclaredBindingExpression","declared","upstreamAlias","property","import_compiler17","simplifyFunction","functionExpression","generator","import_compiler18","toFirstExpressionOrBlock","stmts","isExpressionStatement","expression","toParenthesizedExpressionIfNeeded","blockStatement","parenthesizedExpression","getSignals","getClosureSignalBuilder","_setClosureSignalBuilder","setClosureSignalBuilder","builder","serializeSectionReason","setSerializeSectionReason","serializeSectionIfNeeded","reason","existingReason","getSerializedScopeProperties","getSectionWriteScopeBuilder","setSectionWriteScopeBuilder","addWriteScopeBuilder","prev","htmlDynamicClosureInstancesIdentifier","getHTMLSectionStatements","getHoistFunctionsIdsMap","getHoistFunctionIdentifier","hoistedBinding","idsMap","unimplementedBuild","getSignal","ref","generateSignalName","signals","signal","exportName","export","domExports","intersection","render","renderReferencedBindings","effect","effectReferencedBindings","subscribers","subscribe","scopeOffset","intersectionMeta","getSignalFn","arrowFunctionExpression","scopeIdentifier","getScopeExpression","initValue","runtimeHelper","isParamBinding","needsCache","needsMarks","hoists","valueAccessor","isIntersection","isValue","canUseCalleeDirectly","valueParam","index","end","aliasSignal","getTranslatedExtraArgs","dynamicClosureArgs","dynamicClosureSignalIdentifier","closureSections","closureSection","prependStatements","effectIdentifier","createScopeReadPattern","arguments","param","hasTranslatedExtraArgs","emptyExtraArgs","extraArgs","replaceRenderNode","provider","subscriber","p","providerSignal","replaceNullishAndEmptyFunctionsWith0","isArrowFunctionExpression","isBlockStatement","isUnaryExpression","isNumericLiteral","addStatement","targetSection","statement","usedReferences","statements","addEffectReferences","addRenderReferences","parentSignal","getResumeRegisterId","getTemplateId","usedRegisterIdsBySection","getRegisterUID","used","baseId","writeSignals","accessors","Getter","getScopeAccessor","currentSection","getSectionInstancesAccessorLiteral","hoistIdentifier","sort","sortSignals","value2","effectDeclarator","replaceEffectNode","referencesScope","isScopeIdentifier","isCallExpression","register","signalDeclarator","signalDeclaration","isFunctionExpression","functionDeclaration","isExpression","exportNamedDeclaration","signalStatements","toReturnedFunction","rawFn","returnStatement","aReferencedBindings","getReferencedBindings","bReferencedBindings","diff","reserve","getMappedId","reference","addHTMLEffectCall","writeHTMLResumeStatements","allSignals","scopeIdIdentifier","serializeOwnersUntilBinding","serializeOwners","serializeReason","closureSignal","newExpression","ClosureScopes","ClosureSignalIndex","getDynamicClosureIndex","sectionDynamicSubscribers","subscribersIdentifier","getSectionInstancesAccessor","signalRefs","serializedLookup","serializedProperties","delete","writeScopeBuilder","forceSerializeReason","shorthand","writeScopeArgs","objectExpression","debugVars","root","access","locExpr","line","column","arrayExpression","filenameRelative","additionalStatements","returnIdentifier","serialized","replaceAssignedNode","replaceBindingReadNode","replaceRegisteredFunctionNode","getReadReplacement","isAssignedBindingExtra","buildAssignment","assignment","binaryExpression","prefix","right","resultId","assignmentExpression","registeredFnsForProgram","getRegisteredFnExpression","classProperty","classPrivateProperty","isRegisteredFnExtra","referencedBindingsInFunction","registedFns","registerId","dom_default","templateIdentifier","template","walksIdentifier","setupIdentifier","inputBinding","programInputSignal","styleFile","fs","fileSystem","base","sep","leftDot","indexOf","rightDot","closeBracket","openBracket","getBase","styleMatch","file2","readdirSync","dirname","getStyleFile","importDefault","forEachSectionReverse","childSection","tagParamsSignal","walks2","writes2","setup2","renderer","registeredFns","registeredFn","assignmentPattern","writeRegisteredFns","exportDefaultDeclaration","import_compiler21","import_babel_utils14","templateContentIdentifierForProgram","html_default","replaceNode","renderContent","child","isImportDeclaration","isExportDeclaration","isMarkoScriptlet","static","replaceWithMultiple","contentId","contentFn","exportDefault","read","replaceBindingReadNode2","getRegisteredFnExpression2","registeredFnDeclarations","registeredFnDeclarationsByBody","addRegisteredDeclarations","replaceRegisteredFunctionNode2","program_default","crawl","trackParamsReferences","input","getBindings","readsByExpression","getReadsByExpression","readsByFn","getReadsByFunction","mergedReferences","getMergedReferences","nodes","targetExtra","reads","isEffect","additionalReads","concat","intersectionsBySection","resolveReferencedBindings","pruneBinding","resolveBindingSources","section2","bindingReference","intersections","numReferences","binding1","binding2","sourceSection","intersectionIndex","bindings2","isOwnedBinding","lastBindingIndex","bindingIndex","at","getMaxOwnSourceOffset","finalizeReferences","buildTemplateExports","visitedFiles","resolved","loadFileForImport","req","resolveRelativeToEntry","compatFile","templateExport","props","rootDepth","rootPattern","objectPattern","nestedPatterns","propertyValue","propertyKey","isShorthand","pattern","relativeDepth","nestedPattern","createScopeReadExpression","propName","withPreviousLocation","newNode","originalNode","kIsInvoked","getNextBindingId","setNextBindingId","createBinding","excludeProperties","propBinding","trackVarReferences","canonicalUpstreamAlias","getCanonicalBinding","pruned","createBindingsAndTrackReferences","paramsBinding","trackHoistedReference","referencePath","referenceSection","hoistSection","ancestor","getCommonSection","createRead","trackReference","trackAssignment","setReferencesScope","fnRoot","lVal","babelBinding","referencePaths","constantViolations","isUpdateExpression","trackReferencesForBinding","patternBinding","element","propPath","isMemberExpression","getMemberExpressionPropString","isEventOrChangeHandler","exprRoot","exprExtra","addReadToExpression","fnExtra","mergeReferences","compareIntersections","lenDelta","derived","curBinding","dropReferences","getAllTagReferenceNodes","referenceNodes","includeId","shouldPrune","exprReference","resolveExpressionReference","readBinding","readProps","aliasProps","kDOMBinding","await_default","tagBody","valueAttr","tagExtra","isMarkoAttribute","isSpreadElement","bodySection","nodeRef2","import_compiler26","import_babel_utils17","client_default","rawValue","trim","parseStatements","markoScriptlet","rawOpenTag","import_compiler28","import_babel_utils18","import_compiler27","translateVar","initialValue","const_default","varBinding","derivation","import_compiler29","import_babel_utils19","debug_default","debuggerStatement","import_babel_utils25","import_compiler30","import_babel_utils20","attrTagToIdentifierLookup","getAttrTagIdentifier","meta","analyzeAttributeTags","attrTags2","lookup","attrTagNodesByName","sampleAttrTagsForControlFlow","createAttrTagMeta","isRepeated","isLoopTag","curGroup","crawlAttrTags","oldMeta","attrTagMeta","dynamic","repeated","controlFlowTag","sampleAttrName","attributeTagGroup","attrTagNodes","hasRepeatedDynamicAttrTags","attrTagNames","tagName","conditionRoot","seenBranches","attrTag2","curConditionRoot","getConditionRoot","getPrevSibling","import_compiler34","import_babel_utils24","import_compiler33","import_babel_utils23","import_babel_utils22","import_compiler31","import_babel_utils21","kNativeTagBinding","kSerializeMarker","kGetterId","htmlSelectArgs","getRelatedControllable","checked","checkedChange","special","helper","attrs","checkedValue","checkedValueChange","open","openChange","native_tag_default","escape","buildError","buildUndefined","hasEventHandlers","hasDynamicAttributes","seen","relatedControllable","spreadReferenceNodes","exclusiveGroups","assertExclusiveControllableGroups","tagName2","toIdentifier","bindingName","tagBinding","isHTML","write2","varName","getterId","hoist","getterFnIdentifier","visitAccessor","usedAttrs","maybeStaticAttrs","spreadExpression","skipExpression","spreadProps","skipProps","staticControllable","attr3","spreadElement","staticAttrs","reverse","propsToExpression","getUsedAttrs","writeAtStartOfBody","firstAttr","spreadIdentifier","valueReferences","htmlType","ifStatement","selectArgs","allExtras","shouldMark","kOnlyChildInParent","kNodeRef","isOnlyChildInParent","branchSize","getOptimizedOnlyChildNodeRef","parentTagName","for_default","isAttrTag","allowAttrs","getForType","LoopScopeMap","onlyChildInParentOptimization","forAttrs","forType","bodyStatements","sectionSources","singleNodeOptimization","forTagArgs","getBaseArgsInForTag","forTagHTMLRuntime","forTypeToHTMLResumeRuntime","forTypeToRuntime","by","forTypeToDOMRuntime","referencedBindings2","loopArgs","controlFlow","in","contentProps","translateAttrs","templateExports","contentKey","attrTagLookup","usesExport","addDynamicAttrTagStatements","translatedAttrTag","prevProp","findObjectProperty","contentExpression","isTransparentTag","getNonAttributeTagParent","buildContent","contentProp","getTranslatedBodyContentProperty","ifTag","consequentStatements","getConditionTestValue","addAllAttrTagsAsDynamic","nextTag","testValue","alternateStatements","translateIfAttrTag","forTag","buildForRuntimeCall","translateForAttrTag","define_default","translatedAttrs","import_compiler36","import_babel_utils26","effect_default","import_babel_utils27","export_default","import_compiler37","import_babel_utils28","kCommentTagBinding","kGetterId2","html_comment_default","needsBinding","needsGetter","isMarkoPlaceholder","isMarkoText","commentBinding","references","templateQuasis","templateExpressions","currentQuasi","text","import_compiler38","import_babel_utils29","kGetterId3","html_script_default","bodyPlaceholderNodes","hasBodyPlaceholders","getUsedAttrs2","referencePlaceholder","preserveWhitespace","import_compiler39","import_babel_utils30","kGetterId4","html_style_default","getUsedAttrs3","import_compiler40","import_babel_utils31","id_default","import_compiler42","import_babel_utils32","import_compiler41","BRANCHES_LOOKUP","IfTag","assertHasBody","assertHasValueAttribute","assertHasPrecedingCondition","ifAttr","msg","assertOptionalIfAttribute","assertValidCondition","isLast","branches","getBranches","rootTag","rootExtra","mergeReferenceNodes","branchTag","branchBodySection","ConditionalScope","isRoot","branchSources","branchSections","branchSection","first","merged","getDynamicSourcesForSections","getSourcesForBranches","hasHoists","hasHoistsInBranches","getNextSibling","testAttr","curStatement","conditionSerializeReason","cbNode","rendererIdentifiers","consequent","conditionalExpression","ElseIfTag","ElseTag","isMarkoComment","import_babel_utils33","import_default","import_compiler43","import_babel_utils34","let_default","valueChangeAttr","valueSection","import_compiler44","import_babel_utils35","kRef","lifecycle_default","lifecycleAttrsRef","import_compiler45","import_babel_utils36","log_default","import_compiler46","import_babel_utils37","htmlScriptTagAlternateMsg","script_default","valueFn","isAwaitExpression","seenValueAttr","isFunction2","inlineBody","hasDeclaration","isDeclaration","await","import_compiler47","import_babel_utils38","server_default","import_compiler48","import_babel_utils39","static_default","import_compiler49","import_babel_utils40","import_magic_string","import_path3","STYLE_EXT_REG","htmlStyleTagAlternateMsg","style_default","ext","sourceMaps","markoText","resolveVirtualDependency","getStart","getEnd","magicString","generateMap","includeContent","toUrl","importPath","virtualPath","basename","importDefaultSpecifier","import_compiler50","import_babel_utils41","kDOMBinding2","try_default","splice","core_default","cdata_default","cdata","comment_default","comment","declaration_default","document_type_default","documentType","import_compiler51","import_babel_utils42","function_default","markoRoot","isVariableDeclarator","isObjectMethod","import_babel_utils43","import_declaration_default","importDecl","tagImport","tags","includes","import_compiler53","isNonHTMLText","placeholder","isMarkoTagBody","kBinding","kSiblingText","placeholder_default","isVoid2","placeholderExtra","contentType","analyzeSiblingText","valueExtra","nodeBinding","canWriteHTML","method","siblingText","import_compiler54","abortIdsByExpressionForSection","referenced_identifier_default","hasBinding","throwStatement","exprId","abortIdsByExpression","scriptlet_default","scriptlet","import_compiler58","import_babel_utils47","import_babel_utils44","attribute_tag_default","findParentTag","import_compiler56","import_babel_utils45","import_path4","kChildScopeBinding","kChildOffsetScopeBinding","kChildAttrExprs","custom_tag_default","assertAttributesOrSingleArg","getTagTemplate","charAt","toUpperCase","childProgramExtra","analyzeAttrs","tagIdentifier","relativePath","getTagRelativePath","isCircularRequest","getTemplateContentName","inputExport","childScopeBinding","peekScopeId","contentPath","renderTagExpr","callStatement","translateHTML","childExports","importOrSelfReferenceName","writeAttrsToExports","circular","attrTagCallsByTag","importNamed","injectWalks","translateDOM","rootTagExtra","nodeReferencesByGroup","analyzeDynamicChildGroup","groupReferences","firstTag","attrTagName","childAttrExports","childUsesGroupProp","importAlias","tagInputIdentifier","identifierToSignal","translatedProps","attrTagCallsForTag","attrTagCall","statementsByGroup","translateDynamicAttrTagChildInGroup","childAttrExport","decls","attrExportIdentifier","contentExportIdentifier","missing","getMissingPropValue","buildUndefined2","spreadId","request","nameHint","resolve","always","import_compiler57","import_babel_utils46","kDOMBinding3","kChildOffsetScopeBinding2","dynamic_tag_default","assertAttributesOrArgs","isClassAPI","tagExpression","hasTagArgs","dynamicTagExpr","dynamicScopeIdentifier","tagVarSignal","argsOrInput","isObjectExpression","TAG_NAME_IDENTIFIER_REG","BINDING_CHANGE_HANDLER","tag_default","bound","getChangeHandler","hook","analyzer","translator","watchFiles","modifier","tagNameId","tagNameVarPath","changeAttrName","buildChangeHandlerFunction","existingChangedAttr","changeHandlerAttr","changeHandlerId","changeHandlerConst","insertAfter","unshiftContainer","isPrivateName","cloneNode","newId","visitors","visitors2","_name","extractVisitors","Program","ReferencedIdentifier","ImportDeclaration","MarkoDocumentType","MarkoDeclaration","MarkoCDATA","MarkoText","MarkoTag","MarkoPlaceholder","MarkoScriptlet","MarkoComment"],"sourceRoot":""}